(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.schemarama = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var InvalidDataError = /*#__PURE__*/function (_Error) {
  (0, _inherits2["default"])(InvalidDataError, _Error);

  var _super = _createSuper(InvalidDataError);

  function InvalidDataError(message) {
    var _this;

    (0, _classCallCheck2["default"])(this, InvalidDataError);
    _this = _super.call(this, message);
    _this.name = "InvalidDataError";
    return _this;
  }

  return InvalidDataError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

var ShexValidationError = /*#__PURE__*/function (_Error2) {
  (0, _inherits2["default"])(ShexValidationError, _Error2);

  var _super2 = _createSuper(ShexValidationError);

  function ShexValidationError(message) {
    var _this2;

    (0, _classCallCheck2["default"])(this, ShexValidationError);
    _this2 = _super2.call(this, message);
    _this2.name = "ShexValidationError";
    return _this2;
  }

  return ShexValidationError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

module.exports = {
  InvalidDataError: InvalidDataError,
  ShexValidationError: ShexValidationError
};

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"@babel/runtime/helpers/wrapNativeSuper":29}],2:[function(require,module,exports){
"use strict";

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

},{}],3:[function(require,module,exports){
"use strict";

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

},{}],4:[function(require,module,exports){
"use strict";

var arrayLikeToArray = require("./arrayLikeToArray");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

},{"./arrayLikeToArray":2}],5:[function(require,module,exports){
"use strict";

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

},{}],6:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

},{}],7:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

},{}],8:[function(require,module,exports){
"use strict";

var setPrototypeOf = require("./setPrototypeOf");

var isNativeReflectConstruct = require("./isNativeReflectConstruct");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

},{"./isNativeReflectConstruct":15,"./setPrototypeOf":23}],9:[function(require,module,exports){
"use strict";

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

},{}],10:[function(require,module,exports){
"use strict";

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

},{}],11:[function(require,module,exports){
"use strict";

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

},{}],12:[function(require,module,exports){
"use strict";

var setPrototypeOf = require("./setPrototypeOf");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

},{"./setPrototypeOf":23}],13:[function(require,module,exports){
"use strict";

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

},{}],14:[function(require,module,exports){
"use strict";

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;

},{}],15:[function(require,module,exports){
"use strict";

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

},{}],16:[function(require,module,exports){
"use strict";

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

},{}],17:[function(require,module,exports){
"use strict";

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

},{}],18:[function(require,module,exports){
"use strict";

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

},{}],19:[function(require,module,exports){
"use strict";

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

},{}],20:[function(require,module,exports){
"use strict";

var objectWithoutPropertiesLoose = require("./objectWithoutPropertiesLoose");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;

},{"./objectWithoutPropertiesLoose":21}],21:[function(require,module,exports){
"use strict";

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

},{}],22:[function(require,module,exports){
"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

var assertThisInitialized = require("./assertThisInitialized");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

},{"./assertThisInitialized":5,"@babel/runtime/helpers/typeof":27}],23:[function(require,module,exports){
"use strict";

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

},{}],24:[function(require,module,exports){
"use strict";

var arrayWithHoles = require("./arrayWithHoles");

var iterableToArrayLimit = require("./iterableToArrayLimit");

var unsupportedIterableToArray = require("./unsupportedIterableToArray");

var nonIterableRest = require("./nonIterableRest");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

},{"./arrayWithHoles":3,"./iterableToArrayLimit":17,"./nonIterableRest":18,"./unsupportedIterableToArray":28}],25:[function(require,module,exports){
"use strict";

var arrayWithHoles = require("./arrayWithHoles");

var iterableToArray = require("./iterableToArray");

var unsupportedIterableToArray = require("./unsupportedIterableToArray");

var nonIterableRest = require("./nonIterableRest");

function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
}

module.exports = _toArray;

},{"./arrayWithHoles":3,"./iterableToArray":16,"./nonIterableRest":18,"./unsupportedIterableToArray":28}],26:[function(require,module,exports){
"use strict";

var arrayWithoutHoles = require("./arrayWithoutHoles");

var iterableToArray = require("./iterableToArray");

var unsupportedIterableToArray = require("./unsupportedIterableToArray");

var nonIterableSpread = require("./nonIterableSpread");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

},{"./arrayWithoutHoles":4,"./iterableToArray":16,"./nonIterableSpread":19,"./unsupportedIterableToArray":28}],27:[function(require,module,exports){
"use strict";

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

},{}],28:[function(require,module,exports){
"use strict";

var arrayLikeToArray = require("./arrayLikeToArray");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

},{"./arrayLikeToArray":2}],29:[function(require,module,exports){
"use strict";

var getPrototypeOf = require("./getPrototypeOf");

var setPrototypeOf = require("./setPrototypeOf");

var isNativeFunction = require("./isNativeFunction");

var construct = require("./construct");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;

},{"./construct":8,"./getPrototypeOf":11,"./isNativeFunction":14,"./setPrototypeOf":23}],30:[function(require,module,exports){
"use strict";

module.exports = require("regenerator-runtime");

},{"regenerator-runtime":187}],31:[function(require,module,exports){
"use strict";

module.exports = require('./lib/axios');

},{"./lib/axios":33}],32:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var settle = require('./../core/settle');

var cookies = require('./../helpers/cookies');

var buildURL = require('./../helpers/buildURL');

var buildFullPath = require('../core/buildFullPath');

var parseHeaders = require('./../helpers/parseHeaders');

var isURLSameOrigin = require('./../helpers/isURLSameOrigin');

var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    if ((utils.isBlob(requestData) || utils.isFile(requestData)) && requestData.type) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = unescape(encodeURIComponent(config.auth.password)) || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

},{"../core/buildFullPath":39,"../core/createError":40,"./../core/settle":44,"./../helpers/buildURL":48,"./../helpers/cookies":50,"./../helpers/isURLSameOrigin":52,"./../helpers/parseHeaders":54,"./../utils":56}],33:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var bind = require('./helpers/bind');

var Axios = require('./core/Axios');

var mergeConfig = require('./core/mergeConfig');

var defaults = require('./defaults');
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel'); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = require('./helpers/spread');
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports["default"] = axios;

},{"./cancel/Cancel":34,"./cancel/CancelToken":35,"./cancel/isCancel":36,"./core/Axios":37,"./core/mergeConfig":43,"./defaults":46,"./helpers/bind":47,"./helpers/spread":55,"./utils":56}],34:[function(require,module,exports){
'use strict';
/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

},{}],35:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":34}],36:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],37:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var buildURL = require('../helpers/buildURL');

var InterceptorManager = require('./InterceptorManager');

var dispatchRequest = require('./dispatchRequest');

var mergeConfig = require('./mergeConfig');
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  } // Hook up interceptors middleware


  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

},{"../helpers/buildURL":48,"./../utils":56,"./InterceptorManager":38,"./dispatchRequest":41,"./mergeConfig":43}],38:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":56}],39:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');

var combineURLs = require('../helpers/combineURLs');
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

},{"../helpers/combineURLs":49,"../helpers/isAbsoluteURL":51}],40:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":42}],41:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var transformData = require('./transformData');

var isCancel = require('../cancel/isCancel');

var defaults = require('../defaults');
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":36,"../defaults":46,"./../utils":56,"./transformData":45}],42:[function(require,module,exports){
'use strict';
/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

},{}],43:[function(require,module,exports){
'use strict';

var utils = require('../utils');
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }

    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, mergeDeepProperties);
  return config;
};

},{"../utils":56}],44:[function(require,module,exports){
'use strict';

var createError = require('./createError');
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

},{"./createError":40}],45:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

},{"./../utils":56}],46:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('./utils');

var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

}).call(this)}).call(this,require('_process'))

},{"./adapters/http":32,"./adapters/xhr":32,"./helpers/normalizeHeaderName":53,"./utils":56,"_process":142}],47:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

},{}],48:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":56}],49:[function(require,module,exports){
'use strict';
/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

},{}],50:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

},{"./../utils":56}],51:[function(require,module,exports){
'use strict';
/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],52:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

},{"./../utils":56}],53:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":56}],54:[function(require,module,exports){
'use strict';

var utils = require('./../utils'); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

},{"./../utils":56}],55:[function(require,module,exports){
'use strict';
/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],56:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var bind = require('./helpers/bind');
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && (0, _typeof2["default"])(val) === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */


function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if ((0, _typeof2["default"])(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */


function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }

  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

},{"./helpers/bind":47,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],57:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

},{}],58:[function(require,module,exports){
"use strict";

},{}],59:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58}],60:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var base64 = require('base64-js');

var ieee754 = require('ieee754');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  } // Return an augmented `Uint8Array` instance


  var buf = new Uint8Array(length);
  buf.__proto__ = Buffer.prototype;
  return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }

    return allocUnsafe(arg);
  }

  return from(arg, encodingOrOffset, length);
} // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97


if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value);
  }

  if (value == null) {
    throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + (0, _typeof2["default"])(value));
  }

  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }

  var valueOf = value.valueOf && value.valueOf();

  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }

  var b = fromObject(value);
  if (b) return b;

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + (0, _typeof2["default"])(value));
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148


Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }

  return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);

  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }

  return buf;
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }

  var buf;

  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  } // Return an augmented `Uint8Array` instance


  buf.__proto__ = Buffer.prototype;
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }

    return fromArrayLike(obj);
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf);
    }

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + (0, _typeof2["default"])(string));
  }

  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }

  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + (0, _typeof2["default"])(target));
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  }

  var strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;

    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

  newBuf.__proto__ = Buffer.prototype;
  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;

    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166


function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}

function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27,"base64-js":57,"buffer":60,"ieee754":88}],61:[function(require,module,exports){
/* jshint esversion: 6 */

/* jslint node: true */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

module.exports = function (object) {
  return serialize(object);

  function serialize(object) {
    if (object === null || (0, _typeof2["default"])(object) !== 'object' || object.toJSON != null) {
      return JSON.stringify(object);
    }

    if (Array.isArray(object) && object.length === 0) {
      return '[]';
    }

    if (Array.isArray(object) && object.length === 1) {
      return '[' + serialize(object[0]) + ']';
    }

    if (Array.isArray(object)) {
      return '[' + object.reduce(function (t, cv, ci) {
        t = ci === 1 ? serialize(t) : t;
        return t + ',' + serialize(cv);
      }) + ']';
    }

    var keys = Object.keys(object);

    if (keys.length === 0) {
      return '{}';
    }

    if (keys.length === 1) {
      return '{' + serialize(keys[0]) + ':' + serialize(object[keys[0]]) + '}';
    }

    return '{' + keys.sort().reduce(function (t, cv, ci) {
      t = ci === 1 ? serialize(t) + ':' + serialize(object[t]) : t;
      return t + ',' + serialize(cv) + ':' + serialize(object[cv]);
    }) + '}';
  }
};

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attributeNames = exports.elementNames = void 0;
exports.elementNames = new Map([["altglyph", "altGlyph"], ["altglyphdef", "altGlyphDef"], ["altglyphitem", "altGlyphItem"], ["animatecolor", "animateColor"], ["animatemotion", "animateMotion"], ["animatetransform", "animateTransform"], ["clippath", "clipPath"], ["feblend", "feBlend"], ["fecolormatrix", "feColorMatrix"], ["fecomponenttransfer", "feComponentTransfer"], ["fecomposite", "feComposite"], ["feconvolvematrix", "feConvolveMatrix"], ["fediffuselighting", "feDiffuseLighting"], ["fedisplacementmap", "feDisplacementMap"], ["fedistantlight", "feDistantLight"], ["fedropshadow", "feDropShadow"], ["feflood", "feFlood"], ["fefunca", "feFuncA"], ["fefuncb", "feFuncB"], ["fefuncg", "feFuncG"], ["fefuncr", "feFuncR"], ["fegaussianblur", "feGaussianBlur"], ["feimage", "feImage"], ["femerge", "feMerge"], ["femergenode", "feMergeNode"], ["femorphology", "feMorphology"], ["feoffset", "feOffset"], ["fepointlight", "fePointLight"], ["fespecularlighting", "feSpecularLighting"], ["fespotlight", "feSpotLight"], ["fetile", "feTile"], ["feturbulence", "feTurbulence"], ["foreignobject", "foreignObject"], ["glyphref", "glyphRef"], ["lineargradient", "linearGradient"], ["radialgradient", "radialGradient"], ["textpath", "textPath"]]);
exports.attributeNames = new Map([["definitionurl", "definitionURL"], ["attributename", "attributeName"], ["attributetype", "attributeType"], ["basefrequency", "baseFrequency"], ["baseprofile", "baseProfile"], ["calcmode", "calcMode"], ["clippathunits", "clipPathUnits"], ["diffuseconstant", "diffuseConstant"], ["edgemode", "edgeMode"], ["filterunits", "filterUnits"], ["glyphref", "glyphRef"], ["gradienttransform", "gradientTransform"], ["gradientunits", "gradientUnits"], ["kernelmatrix", "kernelMatrix"], ["kernelunitlength", "kernelUnitLength"], ["keypoints", "keyPoints"], ["keysplines", "keySplines"], ["keytimes", "keyTimes"], ["lengthadjust", "lengthAdjust"], ["limitingconeangle", "limitingConeAngle"], ["markerheight", "markerHeight"], ["markerunits", "markerUnits"], ["markerwidth", "markerWidth"], ["maskcontentunits", "maskContentUnits"], ["maskunits", "maskUnits"], ["numoctaves", "numOctaves"], ["pathlength", "pathLength"], ["patterncontentunits", "patternContentUnits"], ["patterntransform", "patternTransform"], ["patternunits", "patternUnits"], ["pointsatx", "pointsAtX"], ["pointsaty", "pointsAtY"], ["pointsatz", "pointsAtZ"], ["preservealpha", "preserveAlpha"], ["preserveaspectratio", "preserveAspectRatio"], ["primitiveunits", "primitiveUnits"], ["refx", "refX"], ["refy", "refY"], ["repeatcount", "repeatCount"], ["repeatdur", "repeatDur"], ["requiredextensions", "requiredExtensions"], ["requiredfeatures", "requiredFeatures"], ["specularconstant", "specularConstant"], ["specularexponent", "specularExponent"], ["spreadmethod", "spreadMethod"], ["startoffset", "startOffset"], ["stddeviation", "stdDeviation"], ["stitchtiles", "stitchTiles"], ["surfacescale", "surfaceScale"], ["systemlanguage", "systemLanguage"], ["tablevalues", "tableValues"], ["targetx", "targetX"], ["targety", "targetY"], ["textlength", "textLength"], ["viewbox", "viewBox"], ["viewtarget", "viewTarget"], ["xchannelselector", "xChannelSelector"], ["ychannelselector", "yChannelSelector"], ["zoomandpan", "zoomAndPan"]]);

},{}],63:[function(require,module,exports){
"use strict";

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Module dependencies
 */

var ElementType = __importStar(require("domelementtype"));

var entities_1 = require("entities");
/*
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser, see
 * https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */


var foreignNames_1 = require("./foreignNames");

var unencodedElements = new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
/**
 * Format attributes
 */

function formatAttributes(attributes, opts) {
  if (!attributes) return;
  return Object.keys(attributes).map(function (key) {
    var _a, _b;

    var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";

    if (opts.xmlMode === "foreign") {
      /* Fix up mixed-case attribute names */
      key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }

    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }

    return key + "=\"" + (opts.decodeEntities ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + "\"";
  }).join(" ");
}
/**
 * Self-enclosing tags
 */


var singleTag = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */

function render(node, options) {
  if (options === void 0) {
    options = {};
  } // TODO: This is a bit hacky.


  var nodes = Array.isArray(node) || node.cheerio ? node : [node];
  var output = "";

  for (var i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }

  return output;
}

exports["default"] = render;

function renderNode(node, options) {
  switch (node.type) {
    case "root":
      return render(node.children, options);

    case ElementType.Directive:
      return renderDirective(node);

    case ElementType.Comment:
      return renderComment(node);

    case ElementType.CDATA:
      return renderCdata(node);

    default:
      return ElementType.isTag(node) ? renderTag(node, options) : renderText(node, options);
  }
}

var foreignModeIntegrationPoints = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]);
var foreignElements = new Set(["svg", "math"]);

function renderTag(elem, opts) {
  var _a; // Handle SVG / MathML in HTML


  if (opts.xmlMode === "foreign") {
    /* Fix up mixed-case element names */
    elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    /* Exit foreign mode at integration points */

    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = __assign(__assign({}, opts), {
        xmlMode: false
      });
    }
  }

  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = __assign(__assign({}, opts), {
      xmlMode: "foreign"
    });
  }

  var tag = "<" + elem.name;
  var attribs = formatAttributes(elem.attribs, opts);

  if (attribs) {
    tag += " " + attribs;
  }

  if (elem.children.length === 0 && (opts.xmlMode ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
  opts.selfClosingTags !== false : // User explicitly asked for self-closing tags, even in HTML mode
  opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode) tag += " ";
    tag += "/>";
  } else {
    tag += ">";

    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }

    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += "</" + elem.name + ">";
    }
  }

  return tag;
}

function renderDirective(elem) {
  return "<" + elem.data + ">";
}

function renderText(elem, opts) {
  var data = elem.data || ""; // If entities weren't decoded, no need to encode them back

  if (opts.decodeEntities && !(elem.parent && unencodedElements.has(elem.parent.name))) {
    data = entities_1.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return "<![CDATA[" + elem.children[0].data + "]]>";
}

function renderComment(elem) {
  return "<!--" + elem.data + "-->";
}

},{"./foreignNames":62,"domelementtype":64,"entities":78}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.isTag = void 0;
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */

function isTag(elem) {
  return elem.type === "tag"
  /* Tag */
  || elem.type === "script"
  /* Script */
  || elem.type === "style"
  /* Style */
  ;
}

exports.isTag = isTag; // Exports for backwards compatibility

/** Type for Text */

exports.Text = "text"
/* Text */
;
/** Type for <? ... ?> */

exports.Directive = "directive"
/* Directive */
;
/** Type for <!-- ... --> */

exports.Comment = "comment"
/* Comment */
;
/** Type for <script> tags */

exports.Script = "script"
/* Script */
;
/** Type for <style> tags */

exports.Style = "style"
/* Style */
;
/** Type for Any tag */

exports.Tag = "tag"
/* Tag */
;
/** Type for <![CDATA[ ... ]]> */

exports.CDATA = "cdata"
/* CDATA */
;
/** Type for <!doctype ...> */

exports.Doctype = "doctype"
/* Doctype */
;

},{}],65:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomHandler = void 0;

var node_1 = require("./node");

__exportStar(require("./node"), exports);

var reWhitespace = /\s+/g; // Default options

var defaultOpts = {
  normalizeWhitespace: false,
  withStartIndices: false,
  withEndIndices: false
};

var DomHandler =
/** @class */
function () {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  function DomHandler(callback, options, elementCB) {
    /** The constructed DOM */
    this.dom = [];
    /** Indicated whether parsing has been completed. */

    this._done = false;
    /** Stack of open tags. */

    this._tagStack = [];
    /** A data node that is still being written to. */

    this._lastNode = null;
    /** Reference to the parser instance. Used for location information. */

    this._parser = null; // Make it possible to skip arguments, for backwards-compatibility

    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }

    if ((0, _typeof2["default"])(callback) === "object") {
      options = callback;
      callback = undefined;
    }

    this._callback = callback !== null && callback !== void 0 ? callback : null;
    this._options = options !== null && options !== void 0 ? options : defaultOpts;
    this._elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }

  DomHandler.prototype.onparserinit = function (parser) {
    this._parser = parser;
  }; // Resets the handler back to starting state


  DomHandler.prototype.onreset = function () {
    var _a;

    this.dom = [];
    this._done = false;
    this._tagStack = [];
    this._lastNode = null;
    this._parser = (_a = this._parser) !== null && _a !== void 0 ? _a : null;
  }; // Signals the handler that parsing is done


  DomHandler.prototype.onend = function () {
    if (this._done) return;
    this._done = true;
    this._parser = null;
    this.handleCallback(null);
  };

  DomHandler.prototype.onerror = function (error) {
    this.handleCallback(error);
  };

  DomHandler.prototype.onclosetag = function () {
    this._lastNode = null;

    var elem = this._tagStack.pop();

    if (!elem || !this._parser) {
      return;
    }

    if (this._options.withEndIndices) {
      elem.endIndex = this._parser.endIndex;
    }

    if (this._elementCB) this._elementCB(elem);
  };

  DomHandler.prototype.onopentag = function (name, attribs) {
    var element = new node_1.Element(name, attribs);
    this.addNode(element);

    this._tagStack.push(element);
  };

  DomHandler.prototype.ontext = function (data) {
    var normalize = this._options.normalizeWhitespace;
    var _lastNode = this._lastNode;

    if (_lastNode && _lastNode.type === "text"
    /* Text */
    ) {
        if (normalize) {
          _lastNode.data = (_lastNode.data + data).replace(reWhitespace, " ");
        } else {
          _lastNode.data += data;
        }
      } else {
      if (normalize) {
        data = data.replace(reWhitespace, " ");
      }

      var node = new node_1.Text(data);
      this.addNode(node);
      this._lastNode = node;
    }
  };

  DomHandler.prototype.oncomment = function (data) {
    if (this._lastNode && this._lastNode.type === "comment"
    /* Comment */
    ) {
        this._lastNode.data += data;
        return;
      }

    var node = new node_1.Comment(data);
    this.addNode(node);
    this._lastNode = node;
  };

  DomHandler.prototype.oncommentend = function () {
    this._lastNode = null;
  };

  DomHandler.prototype.oncdatastart = function () {
    var text = new node_1.Text("");
    var node = new node_1.NodeWithChildren("cdata"
    /* CDATA */
    , [text]);
    this.addNode(node);
    text.parent = node;
    this._lastNode = text;
  };

  DomHandler.prototype.oncdataend = function () {
    this._lastNode = null;
  };

  DomHandler.prototype.onprocessinginstruction = function (name, data) {
    var node = new node_1.ProcessingInstruction(name, data);
    this.addNode(node);
  };

  DomHandler.prototype.handleCallback = function (error) {
    if (typeof this._callback === "function") {
      this._callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  };

  DomHandler.prototype.addNode = function (node) {
    var parent = this._tagStack[this._tagStack.length - 1];
    var siblings = parent ? parent.children : this.dom;
    var previousSibling = siblings[siblings.length - 1];

    if (this._parser) {
      if (this._options.withStartIndices) {
        node.startIndex = this._parser.startIndex;
      }

      if (this._options.withEndIndices) {
        node.endIndex = this._parser.endIndex;
      }
    }

    siblings.push(node);

    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }

    if (parent) {
      node.parent = parent;
    }

    this._lastNode = null;
  };

  DomHandler.prototype.addDataNode = function (node) {
    this.addNode(node);
    this._lastNode = node;
  };

  return DomHandler;
}();

exports.DomHandler = DomHandler;
exports["default"] = DomHandler;

},{"./node":66,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],66:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneNode = exports.Element = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var nodeTypes = new Map([["tag"
/* Tag */
, 1], ["script"
/* Script */
, 1], ["style"
/* Style */
, 1], ["directive"
/* Directive */
, 1], ["text"
/* Text */
, 3], ["cdata"
/* CDATA */
, 4], ["comment"
/* Comment */
, 8]]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */

var Node =
/** @class */
function () {
  /**
   *
   * @param type The type of the node.
   */
  function Node(type) {
    this.type = type;
    /** Parent of the node */

    this.parent = null;
    /** Previous sibling */

    this.prev = null;
    /** Next sibling */

    this.next = null;
    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */

    this.startIndex = null;
    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */

    this.endIndex = null;
  }

  Object.defineProperty(Node.prototype, "nodeType", {
    // Read-only aliases
    get: function get() {
      var _a;

      return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "parentNode", {
    // Read-write aliases for properties
    get: function get() {
      return this.parent;
    },
    set: function set(parent) {
      this.parent = parent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "previousSibling", {
    get: function get() {
      return this.prev;
    },
    set: function set(prev) {
      this.prev = prev;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "nextSibling", {
    get: function get() {
      return this.next;
    },
    set: function set(next) {
      this.next = next;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */

  Node.prototype.cloneNode = function (recursive) {
    if (recursive === void 0) {
      recursive = false;
    }

    return cloneNode(this, recursive);
  };

  return Node;
}();

exports.Node = Node;

var DataNode =
/** @class */
function (_super) {
  __extends(DataNode, _super);
  /**
   * @param type The type of the node
   * @param data The content of the data node
   */


  function DataNode(type, data) {
    var _this = _super.call(this, type) || this;

    _this.data = data;
    return _this;
  }

  Object.defineProperty(DataNode.prototype, "nodeValue", {
    get: function get() {
      return this.data;
    },
    set: function set(data) {
      this.data = data;
    },
    enumerable: false,
    configurable: true
  });
  return DataNode;
}(Node);

exports.DataNode = DataNode;

var Text =
/** @class */
function (_super) {
  __extends(Text, _super);

  function Text(data) {
    return _super.call(this, "text"
    /* Text */
    , data) || this;
  }

  return Text;
}(DataNode);

exports.Text = Text;

var Comment =
/** @class */
function (_super) {
  __extends(Comment, _super);

  function Comment(data) {
    return _super.call(this, "comment"
    /* Comment */
    , data) || this;
  }

  return Comment;
}(DataNode);

exports.Comment = Comment;

var ProcessingInstruction =
/** @class */
function (_super) {
  __extends(ProcessingInstruction, _super);

  function ProcessingInstruction(name, data) {
    var _this = _super.call(this, "directive"
    /* Directive */
    , data) || this;

    _this.name = name;
    return _this;
  }

  return ProcessingInstruction;
}(DataNode);

exports.ProcessingInstruction = ProcessingInstruction;

var NodeWithChildren =
/** @class */
function (_super) {
  __extends(NodeWithChildren, _super);
  /**
   *
   * @param type Type of the node.
   * @param children Children of the node. Only certain node types can have children.
   */


  function NodeWithChildren(type, children) {
    var _this = _super.call(this, type) || this;

    _this.children = children;
    return _this;
  }

  Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
    // Aliases
    get: function get() {
      var _a;

      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
    get: function get() {
      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
    get: function get() {
      return this.children;
    },
    set: function set(children) {
      this.children = children;
    },
    enumerable: false,
    configurable: true
  });
  return NodeWithChildren;
}(Node);

exports.NodeWithChildren = NodeWithChildren;

var Element =
/** @class */
function (_super) {
  __extends(Element, _super);
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */


  function Element(name, attribs, children) {
    if (children === void 0) {
      children = [];
    }

    var _this = _super.call(this, name === "script" ? "script"
    /* Script */
    : name === "style" ? "style"
    /* Style */
    : "tag"
    /* Tag */
    , children) || this;

    _this.name = name;
    _this.attribs = attribs;
    _this.attribs = attribs;
    return _this;
  }

  Object.defineProperty(Element.prototype, "tagName", {
    // DOM Level 1 aliases
    get: function get() {
      return this.name;
    },
    set: function set(name) {
      this.name = name;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Element.prototype, "attributes", {
    get: function get() {
      var _this = this;

      return Object.keys(this.attribs).map(function (name) {
        return {
          name: name,
          value: _this.attribs[name]
        };
      });
    },
    enumerable: false,
    configurable: true
  });
  return Element;
}(NodeWithChildren);

exports.Element = Element;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */

function cloneNode(node, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }

  switch (node.type) {
    case "text"
    /* Text */
    :
      return new Text(node.data);

    case "directive"
    /* Directive */
    :
      {
        var instr = node;
        return new ProcessingInstruction(instr.name, instr.data);
      }

    case "comment"
    /* Comment */
    :
      return new Comment(node.data);

    case "tag"
    /* Tag */
    :
    case "script"
    /* Script */
    :
    case "style"
    /* Style */
    :
      {
        var elem = node;
        var children = recursive ? cloneChildren(elem.children) : [];
        var clone_1 = new Element(elem.name, __assign({}, elem.attribs), children);
        children.forEach(function (child) {
          return child.parent = clone_1;
        });
        return clone_1;
      }

    case "cdata"
    /* CDATA */
    :
      {
        var cdata = node;
        var children = recursive ? cloneChildren(cdata.children) : [];
        var clone_2 = new NodeWithChildren("cdata"
        /* CDATA */
        , children);
        children.forEach(function (child) {
          return child.parent = clone_2;
        });
        return clone_2;
      }

    case "doctype"
    /* Doctype */
    :
      {
        // This type isn't used yet.
        throw new Error("Not implemented yet: ElementType.Doctype case");
      }
  }
}

exports.cloneNode = cloneNode;

function cloneChildren(childs) {
  var children = childs.map(function (child) {
    return cloneNode(child, true);
  });

  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }

  return children;
}

},{}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;

var tagtypes_1 = require("./tagtypes");
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */


function removeSubsets(nodes) {
  var idx = nodes.length;
  /*
   * Check if each node (or one of its ancestors) is already contained in the
   * array.
   */

  while (--idx >= 0) {
    var node = nodes[idx];
    /*
     * Remove the node if it is not unique.
     * We are going through the array from the end, so we only
     * have to check nodes that preceed the node under consideration in the array.
     */

    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }

    for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }

  return nodes;
}

exports.removeSubsets = removeSubsets;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */

function compareDocumentPosition(nodeA, nodeB) {
  var aParents = [];
  var bParents = [];

  if (nodeA === nodeB) {
    return 0;
  }

  var current = tagtypes_1.hasChildren(nodeA) ? nodeA : nodeA.parent;

  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }

  current = tagtypes_1.hasChildren(nodeB) ? nodeB : nodeB.parent;

  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }

  var maxIdx = Math.min(aParents.length, bParents.length);
  var idx = 0;

  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }

  if (idx === 0) {
    return 1
    /* DISCONNECTED */
    ;
  }

  var sharedParent = aParents[idx - 1];
  var siblings = sharedParent.children;
  var aSibling = aParents[idx];
  var bSibling = bParents[idx];

  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return 4
      /* FOLLOWING */
      | 16
      /* CONTAINED_BY */
      ;
    }

    return 4
    /* FOLLOWING */
    ;
  }

  if (sharedParent === nodeA) {
    return 2
    /* PRECEDING */
    | 8
    /* CONTAINS */
    ;
  }

  return 2
  /* PRECEDING */
  ;
}

exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */

function uniqueSort(nodes) {
  nodes = nodes.filter(function (node, i, arr) {
    return !arr.includes(node, i + 1);
  });
  nodes.sort(function (a, b) {
    var relative = compareDocumentPosition(a, b);

    if (relative & 2
    /* PRECEDING */
    ) {
        return -1;
      } else if (relative & 4
    /* FOLLOWING */
    ) {
        return 1;
      }

    return 0;
  });
  return nodes;
}

exports.uniqueSort = uniqueSort;

},{"./tagtypes":73}],68:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./stringify"), exports);

__exportStar(require("./traversal"), exports);

__exportStar(require("./manipulation"), exports);

__exportStar(require("./querying"), exports);

__exportStar(require("./legacy"), exports);

__exportStar(require("./helpers"), exports);

__exportStar(require("./tagtypes"), exports);

},{"./helpers":67,"./legacy":69,"./manipulation":70,"./querying":71,"./stringify":72,"./tagtypes":73,"./traversal":74}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;

var querying_1 = require("./querying");

var tagtypes_1 = require("./tagtypes");

var Checks = {
  tag_name: function tag_name(name) {
    if (typeof name === "function") {
      return function (elem) {
        return tagtypes_1.isTag(elem) && name(elem.name);
      };
    } else if (name === "*") {
      return tagtypes_1.isTag;
    }

    return function (elem) {
      return tagtypes_1.isTag(elem) && elem.name === name;
    };
  },
  tag_type: function tag_type(type) {
    if (typeof type === "function") {
      return function (elem) {
        return type(elem.type);
      };
    }

    return function (elem) {
      return elem.type === type;
    };
  },
  tag_contains: function tag_contains(data) {
    if (typeof data === "function") {
      return function (elem) {
        return tagtypes_1.isText(elem) && data(elem.data);
      };
    }

    return function (elem) {
      return tagtypes_1.isText(elem) && elem.data === data;
    };
  }
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */

function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function (elem) {
      return tagtypes_1.isTag(elem) && value(elem.attribs[attrib]);
    };
  }

  return function (elem) {
    return tagtypes_1.isTag(elem) && elem.attribs[attrib] === value;
  };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */


function combineFuncs(a, b) {
  return function (elem) {
    return a(elem) || b(elem);
  };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */


function compileTest(options) {
  var funcs = Object.keys(options).map(function (key) {
    var value = options[key];
    return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */


function testElement(options, node) {
  var test = compileTest(options);
  return test ? test(node) : true;
}

exports.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */

function getElements(options, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }

  var test = compileTest(options);
  return test ? querying_1.filter(test, nodes, recurse, limit) : [];
}

exports.getElements = getElements;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */

function getElementById(id, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }

  if (!Array.isArray(nodes)) nodes = [nodes];
  return querying_1.findOne(getAttribCheck("id", id), nodes, recurse);
}

exports.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */

function getElementsByTagName(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }

  if (limit === void 0) {
    limit = Infinity;
  }

  return querying_1.filter(Checks.tag_name(tagName), nodes, recurse, limit);
}

exports.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */

function getElementsByTagType(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }

  if (limit === void 0) {
    limit = Infinity;
  }

  return querying_1.filter(Checks.tag_type(type), nodes, recurse, limit);
}

exports.getElementsByTagType = getElementsByTagType;

},{"./querying":71,"./tagtypes":73}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */

function removeElement(elem) {
  if (elem.prev) elem.prev.next = elem.next;
  if (elem.next) elem.next.prev = elem.prev;

  if (elem.parent) {
    var childs = elem.parent.children;
    childs.splice(childs.lastIndexOf(elem), 1);
  }
}

exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */

function replaceElement(elem, replacement) {
  var prev = replacement.prev = elem.prev;

  if (prev) {
    prev.next = replacement;
  }

  var next = replacement.next = elem.next;

  if (next) {
    next.prev = replacement;
  }

  var parent = replacement.parent = elem.parent;

  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
  }
}

exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */

function appendChild(elem, child) {
  removeElement(child);
  child.next = null;
  child.parent = elem;

  if (elem.children.push(child) > 1) {
    var sibling = elem.children[elem.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}

exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */

function append(elem, next) {
  removeElement(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;

  if (currNext) {
    currNext.prev = next;

    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}

exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */

function prependChild(elem, child) {
  removeElement(child);
  child.parent = elem;
  child.prev = null;

  if (elem.children.unshift(child) !== 1) {
    var sibling = elem.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}

exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */

function prepend(elem, prev) {
  removeElement(prev);
  var parent = elem.parent;

  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }

  if (elem.prev) {
    elem.prev.next = prev;
  }

  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

exports.prepend = prepend;

},{}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;

var tagtypes_1 = require("./tagtypes");
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */


function filter(test, node, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }

  if (limit === void 0) {
    limit = Infinity;
  }

  if (!Array.isArray(node)) node = [node];
  return find(test, node, recurse, limit);
}

exports.filter = filter;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */

function find(test, nodes, recurse, limit) {
  var result = [];

  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var elem = nodes_1[_i];

    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0) break;
    }

    if (recurse && tagtypes_1.hasChildren(elem) && elem.children.length > 0) {
      var children = find(test, elem.children, recurse, limit);
      result.push.apply(result, children);
      limit -= children.length;
      if (limit <= 0) break;
    }
  }

  return result;
}

exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */

function findOneChild(test, nodes) {
  return nodes.find(test);
}

exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */

function findOne(test, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }

  var elem = null;

  for (var i = 0; i < nodes.length && !elem; i++) {
    var checked = nodes[i];

    if (!tagtypes_1.isTag(checked)) {
      continue;
    } else if (test(checked)) {
      elem = checked;
    } else if (recurse && checked.children.length > 0) {
      elem = findOne(test, checked.children);
    }
  }

  return elem;
}

exports.findOne = findOne;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */

function existsOne(test, nodes) {
  return nodes.some(function (checked) {
    return tagtypes_1.isTag(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
  });
}

exports.existsOne = existsOne;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */

function findAll(test, nodes) {
  var _a;

  var result = [];
  var stack = nodes.filter(tagtypes_1.isTag);
  var elem;

  while (elem = stack.shift()) {
    var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(tagtypes_1.isTag);

    if (children && children.length > 0) {
      stack.unshift.apply(stack, children);
    }

    if (test(elem)) result.push(elem);
  }

  return result;
}

exports.findAll = findAll;

},{"./tagtypes":73}],72:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;

var tagtypes_1 = require("./tagtypes");

var dom_serializer_1 = __importDefault(require("dom-serializer"));
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */


function getOuterHTML(node, options) {
  return dom_serializer_1["default"](node, options);
}

exports.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */

function getInnerHTML(node, options) {
  return tagtypes_1.hasChildren(node) ? node.children.map(function (node) {
    return getOuterHTML(node, options);
  }).join("") : "";
}

exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */

function getText(node) {
  if (Array.isArray(node)) return node.map(getText).join("");
  if (tagtypes_1.isTag(node)) return node.name === "br" ? "\n" : getText(node.children);
  if (tagtypes_1.isCDATA(node)) return getText(node.children);
  if (tagtypes_1.isText(node)) return node.data;
  return "";
}

exports.getText = getText;

},{"./tagtypes":73,"dom-serializer":63}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasChildren = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;

var domelementtype_1 = require("domelementtype");
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */


function isTag(node) {
  return domelementtype_1.isTag(node);
}

exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren`, `false` otherwise.
 */

function isCDATA(node) {
  return node.type === "cdata"
  /* CDATA */
  ;
}

exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `DataNode`, `false` otherwise.
 */

function isText(node) {
  return node.type === "text"
  /* Text */
  ;
}

exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `DataNode`, `false` otherwise.
 */

function isComment(node) {
  return node.type === "comment"
  /* Comment */
  ;
}

exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */

function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}

exports.hasChildren = hasChildren;

},{"domelementtype":64}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;

var tagtypes_1 = require("./tagtypes");

var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */

function getChildren(elem) {
  var _a;

  return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}

exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */

function getParent(elem) {
  return elem.parent || null;
}

exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */

function getSiblings(elem) {
  var _a, _b;

  var parent = getParent(elem);
  if (parent != null) return getChildren(parent);
  var siblings = [elem];
  var prev = elem.prev,
      next = elem.next;

  while (prev != null) {
    siblings.unshift(prev);
    _a = prev, prev = _a.prev;
  }

  while (next != null) {
    siblings.push(next);
    _b = next, next = _b.next;
  }

  return siblings;
}

exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */

function getAttributeValue(elem, name) {
  var _a;

  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}

exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */

function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}

exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */

function getName(elem) {
  return elem.name;
}

exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */

function nextElementSibling(elem) {
  var _a;

  var next = elem.next;

  while (next !== null && !tagtypes_1.isTag(next)) {
    _a = next, next = _a.next;
  }

  return next;
}

exports.nextElementSibling = nextElementSibling;

},{"./tagtypes":73}],75:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;

var entities_json_1 = __importDefault(require("./maps/entities.json"));

var legacy_json_1 = __importDefault(require("./maps/legacy.json"));

var xml_json_1 = __importDefault(require("./maps/xml.json"));

var decode_codepoint_1 = __importDefault(require("./decode_codepoint"));

exports.decodeXML = getStrictDecoder(xml_json_1["default"]);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1["default"]);

function getStrictDecoder(map) {
  var keys = Object.keys(map).join("|");
  var replace = getReplacer(map);
  keys += "|#[xX][\\da-fA-F]+|#\\d+";
  var re = new RegExp("&(?:" + keys + ");", "g");
  return function (str) {
    return String(str).replace(re, replace);
  };
}

var sorter = function sorter(a, b) {
  return a < b ? 1 : -1;
};

exports.decodeHTML = function () {
  var legacy = Object.keys(legacy_json_1["default"]).sort(sorter);
  var keys = Object.keys(entities_json_1["default"]).sort(sorter);

  for (var i = 0, j = 0; i < keys.length; i++) {
    if (legacy[j] === keys[i]) {
      keys[i] += ";?";
      j++;
    } else {
      keys[i] += ";";
    }
  }

  var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
  var replace = getReplacer(entities_json_1["default"]);

  function replacer(str) {
    if (str.substr(-1) !== ";") str += ";";
    return replace(str);
  } // TODO consider creating a merged map


  return function (str) {
    return String(str).replace(re, replacer);
  };
}();

function getReplacer(map) {
  return function replace(str) {
    if (str.charAt(1) === "#") {
      var secondChar = str.charAt(2);

      if (secondChar === "X" || secondChar === "x") {
        return decode_codepoint_1["default"](parseInt(str.substr(3), 16));
      }

      return decode_codepoint_1["default"](parseInt(str.substr(2), 10));
    }

    return map[str.slice(1, -1)];
  };
}

},{"./decode_codepoint":76,"./maps/entities.json":80,"./maps/legacy.json":81,"./maps/xml.json":82}],76:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var decode_json_1 = __importDefault(require("./maps/decode.json")); // Modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119


function decodeCodePoint(codePoint) {
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return "\uFFFD";
  }

  if (codePoint in decode_json_1["default"]) {
    codePoint = decode_json_1["default"][codePoint];
  }

  var output = "";

  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }

  output += String.fromCharCode(codePoint);
  return output;
}

exports["default"] = decodeCodePoint;

},{"./maps/decode.json":79}],77:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.escape = exports.encodeHTML = exports.encodeXML = void 0;

var xml_json_1 = __importDefault(require("./maps/xml.json"));

var inverseXML = getInverseObj(xml_json_1["default"]);
var xmlReplacer = getInverseReplacer(inverseXML);
exports.encodeXML = getInverse(inverseXML, xmlReplacer);

var entities_json_1 = __importDefault(require("./maps/entities.json"));

var inverseHTML = getInverseObj(entities_json_1["default"]);
var htmlReplacer = getInverseReplacer(inverseHTML);
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);

function getInverseObj(obj) {
  return Object.keys(obj).sort().reduce(function (inverse, name) {
    inverse[obj[name]] = "&" + name + ";";
    return inverse;
  }, {});
}

function getInverseReplacer(inverse) {
  var single = [];
  var multiple = [];

  for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
    var k = _a[_i];

    if (k.length === 1) {
      // Add value to single array
      single.push("\\" + k);
    } else {
      // Add value to multiple array
      multiple.push(k);
    }
  } // Add ranges to single characters.


  single.sort();

  for (var start = 0; start < single.length - 1; start++) {
    // Find the end of a run of characters
    var end = start;

    while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
      end += 1;
    }

    var count = 1 + end - start; // We want to replace at least three characters

    if (count < 3) continue;
    single.splice(start, count, single[start] + "-" + single[end]);
  }

  multiple.unshift("[" + single.join("") + "]");
  return new RegExp(multiple.join("|"), "g");
}

var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;

function singleCharReplacer(c) {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  return "&#x" + c.codePointAt(0).toString(16).toUpperCase() + ";";
}

function getInverse(inverse, re) {
  return function (data) {
    return data.replace(re, function (name) {
      return inverse[name];
    }).replace(reNonASCII, singleCharReplacer);
  };
}

var reXmlChars = getInverseReplacer(inverseXML);

function escape(data) {
  return data.replace(reXmlChars, singleCharReplacer).replace(reNonASCII, singleCharReplacer);
}

exports.escape = escape;

},{"./maps/entities.json":80,"./maps/xml.json":82}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escape = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;

var decode_1 = require("./decode");

var encode_1 = require("./encode");
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */


function decode(data, level) {
  return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}

exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */

function decodeStrict(data, level) {
  return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}

exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 */

function encode(data, level) {
  return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}

exports.encode = encode;

var encode_2 = require("./encode");

Object.defineProperty(exports, "encodeXML", {
  enumerable: true,
  get: function get() {
    return encode_2.encodeXML;
  }
});
Object.defineProperty(exports, "encodeHTML", {
  enumerable: true,
  get: function get() {
    return encode_2.encodeHTML;
  }
});
Object.defineProperty(exports, "escape", {
  enumerable: true,
  get: function get() {
    return encode_2.escape;
  }
}); // Legacy aliases

Object.defineProperty(exports, "encodeHTML4", {
  enumerable: true,
  get: function get() {
    return encode_2.encodeHTML;
  }
});
Object.defineProperty(exports, "encodeHTML5", {
  enumerable: true,
  get: function get() {
    return encode_2.encodeHTML;
  }
});

var decode_2 = require("./decode");

Object.defineProperty(exports, "decodeXML", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeXML;
  }
});
Object.defineProperty(exports, "decodeHTML", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTML;
  }
});
Object.defineProperty(exports, "decodeHTMLStrict", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTMLStrict;
  }
}); // Legacy aliases

Object.defineProperty(exports, "decodeHTML4", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTML;
  }
});
Object.defineProperty(exports, "decodeHTML5", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTML;
  }
});
Object.defineProperty(exports, "decodeHTML4Strict", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTMLStrict;
  }
});
Object.defineProperty(exports, "decodeHTML5Strict", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTMLStrict;
  }
});
Object.defineProperty(exports, "decodeXMLStrict", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeXML;
  }
});

},{"./decode":75,"./encode":77}],79:[function(require,module,exports){
module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}

},{}],80:[function(require,module,exports){
module.exports={"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\"","QUOT":"\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""}

},{}],81:[function(require,module,exports){
module.exports={"Aacute":"","aacute":"","Acirc":"","acirc":"","acute":"","AElig":"","aelig":"","Agrave":"","agrave":"","amp":"&","AMP":"&","Aring":"","aring":"","Atilde":"","atilde":"","Auml":"","auml":"","brvbar":"","Ccedil":"","ccedil":"","cedil":"","cent":"","copy":"","COPY":"","curren":"","deg":"","divide":"","Eacute":"","eacute":"","Ecirc":"","ecirc":"","Egrave":"","egrave":"","ETH":"","eth":"","Euml":"","euml":"","frac12":"","frac14":"","frac34":"","gt":">","GT":">","Iacute":"","iacute":"","Icirc":"","icirc":"","iexcl":"","Igrave":"","igrave":"","iquest":"","Iuml":"","iuml":"","laquo":"","lt":"<","LT":"<","macr":"","micro":"","middot":"","nbsp":"","not":"","Ntilde":"","ntilde":"","Oacute":"","oacute":"","Ocirc":"","ocirc":"","Ograve":"","ograve":"","ordf":"","ordm":"","Oslash":"","oslash":"","Otilde":"","otilde":"","Ouml":"","ouml":"","para":"","plusmn":"","pound":"","quot":"\"","QUOT":"\"","raquo":"","reg":"","REG":"","sect":"","shy":"","sup1":"","sup2":"","sup3":"","szlig":"","THORN":"","thorn":"","times":"","Uacute":"","uacute":"","Ucirc":"","ucirc":"","Ugrave":"","ugrave":"","uml":"","Uuml":"","uuml":"","Yacute":"","yacute":"","yen":"","yuml":""}

},{}],82:[function(require,module,exports){
module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

},{}],83:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var R = (typeof Reflect === "undefined" ? "undefined" : (0, _typeof2["default"])(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + (0, _typeof2["default"])(listener));
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    var errorListener; // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.

    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],84:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseFeed = exports.FeedHandler = void 0;

var domhandler_1 = __importDefault(require("domhandler"));

var DomUtils = __importStar(require("domutils"));

var Parser_1 = require("./Parser");

var FeedItemMediaMedium;

(function (FeedItemMediaMedium) {
  FeedItemMediaMedium[FeedItemMediaMedium["image"] = 0] = "image";
  FeedItemMediaMedium[FeedItemMediaMedium["audio"] = 1] = "audio";
  FeedItemMediaMedium[FeedItemMediaMedium["video"] = 2] = "video";
  FeedItemMediaMedium[FeedItemMediaMedium["document"] = 3] = "document";
  FeedItemMediaMedium[FeedItemMediaMedium["executable"] = 4] = "executable";
})(FeedItemMediaMedium || (FeedItemMediaMedium = {}));

var FeedItemMediaExpression;

(function (FeedItemMediaExpression) {
  FeedItemMediaExpression[FeedItemMediaExpression["sample"] = 0] = "sample";
  FeedItemMediaExpression[FeedItemMediaExpression["full"] = 1] = "full";
  FeedItemMediaExpression[FeedItemMediaExpression["nonstop"] = 2] = "nonstop";
})(FeedItemMediaExpression || (FeedItemMediaExpression = {})); // TODO: Consume data as it is coming in


var FeedHandler =
/** @class */
function (_super) {
  __extends(FeedHandler, _super);
  /**
   *
   * @param callback
   * @param options
   */


  function FeedHandler(callback, options) {
    var _this = this;

    if ((0, _typeof2["default"])(callback) === "object") {
      callback = undefined;
      options = callback;
    }

    _this = _super.call(this, callback, options) || this;
    return _this;
  }

  FeedHandler.prototype.onend = function () {
    var _a, _b;

    var feed = {};
    var feedRoot = getOneElement(isValidFeed, this.dom);

    if (feedRoot) {
      if (feedRoot.name === "feed") {
        var childs = feedRoot.children;
        feed.type = "atom";
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        var href = getAttribute("href", getOneElement("link", childs));

        if (href) {
          feed.link = href;
        }

        addConditionally(feed, "description", "subtitle", childs);
        var updated = fetch("updated", childs);

        if (updated) {
          feed.updated = new Date(updated);
        }

        addConditionally(feed, "author", "email", childs, true);
        feed.items = getElements("entry", childs).map(function (item) {
          var entry = {};
          var children = item.children;
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href = getAttribute("href", getOneElement("link", children));

          if (href) {
            entry.link = href;
          }

          var description = fetch("summary", children) || fetch("content", children);

          if (description) {
            entry.description = description;
          }

          var pubDate = fetch("updated", children);

          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }

          entry.media = getMediaElements(children);
          return entry;
        });
      } else {
        var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
        feed.type = feedRoot.name.substr(0, 3);
        feed.id = "";
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        var updated = fetch("lastBuildDate", childs);

        if (updated) {
          feed.updated = new Date(updated);
        }

        addConditionally(feed, "author", "managingEditor", childs, true);
        feed.items = getElements("item", feedRoot.children).map(function (item) {
          var entry = {};
          var children = item.children;
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch("pubDate", children);
          if (pubDate) entry.pubDate = new Date(pubDate);
          entry.media = getMediaElements(children);
          return entry;
        });
      }
    }

    this.feed = feed;
    this.handleCallback(feedRoot ? null : Error("couldn't find root of feed"));
  };

  return FeedHandler;
}(domhandler_1["default"]);

exports.FeedHandler = FeedHandler;

function getMediaElements(where) {
  return getElements("media:content", where).map(function (elem) {
    var media = {
      medium: elem.attribs.medium,
      isDefault: !!elem.attribs.isDefault
    };

    if (elem.attribs.url) {
      media.url = elem.attribs.url;
    }

    if (elem.attribs.fileSize) {
      media.fileSize = parseInt(elem.attribs.fileSize, 10);
    }

    if (elem.attribs.type) {
      media.type = elem.attribs.type;
    }

    if (elem.attribs.expression) {
      media.expression = elem.attribs.expression;
    }

    if (elem.attribs.bitrate) {
      media.bitrate = parseInt(elem.attribs.bitrate, 10);
    }

    if (elem.attribs.framerate) {
      media.framerate = parseInt(elem.attribs.framerate, 10);
    }

    if (elem.attribs.samplingrate) {
      media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
    }

    if (elem.attribs.channels) {
      media.channels = parseInt(elem.attribs.channels, 10);
    }

    if (elem.attribs.duration) {
      media.duration = parseInt(elem.attribs.duration, 10);
    }

    if (elem.attribs.height) {
      media.height = parseInt(elem.attribs.height, 10);
    }

    if (elem.attribs.width) {
      media.width = parseInt(elem.attribs.width, 10);
    }

    if (elem.attribs.lang) {
      media.lang = elem.attribs.lang;
    }

    return media;
  });
}

function getElements(tagName, where) {
  return DomUtils.getElementsByTagName(tagName, where, true);
}

function getOneElement(tagName, node) {
  return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
}

function fetch(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }

  return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
}

function getAttribute(name, elem) {
  if (!elem) {
    return null;
  }

  var attribs = elem.attribs;
  return attribs[name];
}

function addConditionally(obj, prop, what, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }

  var tmp = fetch(what, where, recurse);
  if (tmp) obj[prop] = tmp;
}

function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

var defaultOptions = {
  xmlMode: true
};
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this option, you probably want to set `xmlMode` to `true`.
 */

function parseFeed(feed, options) {
  if (options === void 0) {
    options = defaultOptions;
  }

  var handler = new FeedHandler(options);
  new Parser_1.Parser(handler, options).end(feed);
  return handler.feed;
}

exports.parseFeed = parseFeed;

},{"./Parser":85,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27,"domhandler":65,"domutils":68}],85:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = void 0;

var Tokenizer_1 = __importDefault(require("./Tokenizer"));

var formTags = new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]);
var pTag = new Set(["p"]);
var openImpliesClose = {
  tr: new Set(["tr", "th", "td"]),
  th: new Set(["th"]),
  td: new Set(["thead", "th", "td"]),
  body: new Set(["head", "link", "script"]),
  li: new Set(["li"]),
  p: pTag,
  h1: pTag,
  h2: pTag,
  h3: pTag,
  h4: pTag,
  h5: pTag,
  h6: pTag,
  select: formTags,
  input: formTags,
  output: formTags,
  button: formTags,
  datalist: formTags,
  textarea: formTags,
  option: new Set(["option"]),
  optgroup: new Set(["optgroup", "option"]),
  dd: new Set(["dt", "dd"]),
  dt: new Set(["dt", "dd"]),
  address: pTag,
  article: pTag,
  aside: pTag,
  blockquote: pTag,
  details: pTag,
  div: pTag,
  dl: pTag,
  fieldset: pTag,
  figcaption: pTag,
  figure: pTag,
  footer: pTag,
  form: pTag,
  header: pTag,
  hr: pTag,
  main: pTag,
  nav: pTag,
  ol: pTag,
  pre: pTag,
  section: pTag,
  table: pTag,
  ul: pTag,
  rt: new Set(["rt", "rp"]),
  rp: new Set(["rt", "rp"]),
  tbody: new Set(["thead", "tbody"]),
  tfoot: new Set(["thead", "tbody"])
};
var voidElements = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]);
var reNameEnd = /\s|\//;

var Parser =
/** @class */
function () {
  function Parser(cbs, options) {
    if (options === void 0) {
      options = {};
    }

    var _a, _b, _c, _d, _e;
    /** The start index of the last event. */


    this.startIndex = 0;
    /** The end index of the last event. */

    this.endIndex = null;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.options = options;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1["default"])(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }

  Parser.prototype.updatePosition = function (initialOffset) {
    if (this.endIndex === null) {
      if (this.tokenizer.sectionStart <= initialOffset) {
        this.startIndex = 0;
      } else {
        this.startIndex = this.tokenizer.sectionStart - initialOffset;
      }
    } else {
      this.startIndex = this.endIndex + 1;
    }

    this.endIndex = this.tokenizer.getAbsoluteIndex();
  }; // Tokenizer event handlers


  Parser.prototype.ontext = function (data) {
    var _a, _b;

    this.updatePosition(1);
    this.endIndex--;
    (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
  };

  Parser.prototype.onopentagname = function (name) {
    var _a, _b;

    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }

    this.tagname = name;

    if (!this.options.xmlMode && Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
      var el = void 0;

      while (this.stack.length > 0 && openImpliesClose[name].has(el = this.stack[this.stack.length - 1])) {
        this.onclosetag(el);
      }
    }

    if (this.options.xmlMode || !voidElements.has(name)) {
      this.stack.push(name);

      if (foreignContextElements.has(name)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name)) {
        this.foreignContext.push(false);
      }
    }

    (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);
    if (this.cbs.onopentag) this.attribs = {};
  };

  Parser.prototype.onopentagend = function () {
    var _a, _b;

    this.updatePosition(1);

    if (this.attribs) {
      (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);
      this.attribs = null;
    }

    if (!this.options.xmlMode && this.cbs.onclosetag && voidElements.has(this.tagname)) {
      this.cbs.onclosetag(this.tagname);
    }

    this.tagname = "";
  };

  Parser.prototype.onclosetag = function (name) {
    this.updatePosition(1);

    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }

    if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
      this.foreignContext.pop();
    }

    if (this.stack.length && (this.options.xmlMode || !voidElements.has(name))) {
      var pos = this.stack.lastIndexOf(name);

      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          pos = this.stack.length - pos;

          while (pos--) {
            // We know the stack has sufficient elements.
            this.cbs.onclosetag(this.stack.pop());
          }
        } else this.stack.length = pos;
      } else if (name === "p" && !this.options.xmlMode) {
        this.onopentagname(name);
        this.closeCurrentTag();
      }
    } else if (!this.options.xmlMode && (name === "br" || name === "p")) {
      this.onopentagname(name);
      this.closeCurrentTag();
    }
  };

  Parser.prototype.onselfclosingtag = function () {
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag();
    } else {
      this.onopentagend();
    }
  };

  Parser.prototype.closeCurrentTag = function () {
    var _a, _b;

    var name = this.tagname;
    this.onopentagend();
    /*
     * Self-closing tags will be on the top of the stack
     * (cheaper check than in onclosetag)
     */

    if (this.stack[this.stack.length - 1] === name) {
      (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name);
      this.stack.pop();
    }
  };

  Parser.prototype.onattribname = function (name) {
    if (this.lowerCaseAttributeNames) {
      name = name.toLowerCase();
    }

    this.attribname = name;
  };

  Parser.prototype.onattribdata = function (value) {
    this.attribvalue += value;
  };

  Parser.prototype.onattribend = function (quote) {
    var _a, _b;

    (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);

    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }

    this.attribname = "";
    this.attribvalue = "";
  };

  Parser.prototype.getInstructionName = function (value) {
    var idx = value.search(reNameEnd);
    var name = idx < 0 ? value : value.substr(0, idx);

    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }

    return name;
  };

  Parser.prototype.ondeclaration = function (value) {
    if (this.cbs.onprocessinginstruction) {
      var name_1 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
    }
  };

  Parser.prototype.onprocessinginstruction = function (value) {
    if (this.cbs.onprocessinginstruction) {
      var name_2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
    }
  };

  Parser.prototype.oncomment = function (value) {
    var _a, _b, _c, _d;

    this.updatePosition(4);
    (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
  };

  Parser.prototype.oncdata = function (value) {
    var _a, _b, _c, _d, _e, _f;

    this.updatePosition(1);

    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      this.oncomment("[CDATA[" + value + "]]");
    }
  };

  Parser.prototype.onerror = function (err) {
    var _a, _b;

    (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };

  Parser.prototype.onend = function () {
    var _a, _b;

    if (this.cbs.onclosetag) {
      for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i])) {
        ;
      }
    }

    (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */


  Parser.prototype.reset = function () {
    var _a, _b, _c, _d;

    (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack = [];
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
  };
  /**
   * Parses a complete document and pushes it to the handler.
   *
   * @param data Document to parse.
   */


  Parser.prototype.parseComplete = function (data) {
    this.reset();
    this.end(data);
  };
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */


  Parser.prototype.write = function (chunk) {
    this.tokenizer.write(chunk);
  };
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */


  Parser.prototype.end = function (chunk) {
    this.tokenizer.end(chunk);
  };
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */


  Parser.prototype.pause = function () {
    this.tokenizer.pause();
  };
  /**
   * Resumes parsing after `pause` was called.
   */


  Parser.prototype.resume = function () {
    this.tokenizer.resume();
  };
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */


  Parser.prototype.parseChunk = function (chunk) {
    this.write(chunk);
  };
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */


  Parser.prototype.done = function (chunk) {
    this.end(chunk);
  };

  return Parser;
}();

exports.Parser = Parser;

},{"./Tokenizer":86}],86:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var decode_codepoint_1 = __importDefault(require("entities/lib/decode_codepoint"));

var entities_json_1 = __importDefault(require("entities/lib/maps/entities.json"));

var legacy_json_1 = __importDefault(require("entities/lib/maps/legacy.json"));

var xml_json_1 = __importDefault(require("entities/lib/maps/xml.json"));

function whitespace(c) {
  return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function isASCIIAlpha(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
}

function ifElseState(upper, SUCCESS, FAILURE) {
  var lower = upper.toLowerCase();

  if (upper === lower) {
    return function (t, c) {
      if (c === lower) {
        t._state = SUCCESS;
      } else {
        t._state = FAILURE;
        t._index--;
      }
    };
  }

  return function (t, c) {
    if (c === lower || c === upper) {
      t._state = SUCCESS;
    } else {
      t._state = FAILURE;
      t._index--;
    }
  };
}

function consumeSpecialNameChar(upper, NEXT_STATE) {
  var lower = upper.toLowerCase();
  return function (t, c) {
    if (c === lower || c === upper) {
      t._state = NEXT_STATE;
    } else {
      t._state = 3
      /* InTagName */
      ;
      t._index--; // Consume the token again
    }
  };
}

var stateBeforeCdata1 = ifElseState("C", 24
/* BeforeCdata2 */
, 16
/* InDeclaration */
);
var stateBeforeCdata2 = ifElseState("D", 25
/* BeforeCdata3 */
, 16
/* InDeclaration */
);
var stateBeforeCdata3 = ifElseState("A", 26
/* BeforeCdata4 */
, 16
/* InDeclaration */
);
var stateBeforeCdata4 = ifElseState("T", 27
/* BeforeCdata5 */
, 16
/* InDeclaration */
);
var stateBeforeCdata5 = ifElseState("A", 28
/* BeforeCdata6 */
, 16
/* InDeclaration */
);
var stateBeforeScript1 = consumeSpecialNameChar("R", 35
/* BeforeScript2 */
);
var stateBeforeScript2 = consumeSpecialNameChar("I", 36
/* BeforeScript3 */
);
var stateBeforeScript3 = consumeSpecialNameChar("P", 37
/* BeforeScript4 */
);
var stateBeforeScript4 = consumeSpecialNameChar("T", 38
/* BeforeScript5 */
);
var stateAfterScript1 = ifElseState("R", 40
/* AfterScript2 */
, 1
/* Text */
);
var stateAfterScript2 = ifElseState("I", 41
/* AfterScript3 */
, 1
/* Text */
);
var stateAfterScript3 = ifElseState("P", 42
/* AfterScript4 */
, 1
/* Text */
);
var stateAfterScript4 = ifElseState("T", 43
/* AfterScript5 */
, 1
/* Text */
);
var stateBeforeStyle1 = consumeSpecialNameChar("Y", 45
/* BeforeStyle2 */
);
var stateBeforeStyle2 = consumeSpecialNameChar("L", 46
/* BeforeStyle3 */
);
var stateBeforeStyle3 = consumeSpecialNameChar("E", 47
/* BeforeStyle4 */
);
var stateAfterStyle1 = ifElseState("Y", 49
/* AfterStyle2 */
, 1
/* Text */
);
var stateAfterStyle2 = ifElseState("L", 50
/* AfterStyle3 */
, 1
/* Text */
);
var stateAfterStyle3 = ifElseState("E", 51
/* AfterStyle4 */
, 1
/* Text */
);
var stateBeforeSpecialT = consumeSpecialNameChar("I", 54
/* BeforeTitle1 */
);
var stateBeforeTitle1 = consumeSpecialNameChar("T", 55
/* BeforeTitle2 */
);
var stateBeforeTitle2 = consumeSpecialNameChar("L", 56
/* BeforeTitle3 */
);
var stateBeforeTitle3 = consumeSpecialNameChar("E", 57
/* BeforeTitle4 */
);
var stateAfterSpecialTEnd = ifElseState("I", 58
/* AfterTitle1 */
, 1
/* Text */
);
var stateAfterTitle1 = ifElseState("T", 59
/* AfterTitle2 */
, 1
/* Text */
);
var stateAfterTitle2 = ifElseState("L", 60
/* AfterTitle3 */
, 1
/* Text */
);
var stateAfterTitle3 = ifElseState("E", 61
/* AfterTitle4 */
, 1
/* Text */
);
var stateBeforeEntity = ifElseState("#", 63
/* BeforeNumericEntity */
, 64
/* InNamedEntity */
);
var stateBeforeNumericEntity = ifElseState("X", 66
/* InHexEntity */
, 65
/* InNumericEntity */
);

var Tokenizer =
/** @class */
function () {
  function Tokenizer(options, cbs) {
    var _a;
    /** The current state the tokenizer is in. */


    this._state = 1
    /* Text */
    ;
    /** The read buffer. */

    this.buffer = "";
    /** The beginning of the section that is currently being read. */

    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */

    this._index = 0;
    /**
     * Data that has already been processed will be removed from the buffer occasionally.
     * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
     */

    this.bufferOffset = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */

    this.baseState = 1
    /* Text */
    ;
    /** For special parsing behavior inside of script and style tags. */

    this.special = 1
    /* None */
    ;
    /** Indicates whether the tokenizer has been paused. */

    this.running = true;
    /** Indicates whether the tokenizer has finished running / `.end` has been called. */

    this.ended = false;
    this.cbs = cbs;
    this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
    this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;
  }

  Tokenizer.prototype.reset = function () {
    this._state = 1
    /* Text */
    ;
    this.buffer = "";
    this.sectionStart = 0;
    this._index = 0;
    this.bufferOffset = 0;
    this.baseState = 1
    /* Text */
    ;
    this.special = 1
    /* None */
    ;
    this.running = true;
    this.ended = false;
  };

  Tokenizer.prototype.write = function (chunk) {
    if (this.ended) this.cbs.onerror(Error(".write() after done!"));
    this.buffer += chunk;
    this.parse();
  };

  Tokenizer.prototype.end = function (chunk) {
    if (this.ended) this.cbs.onerror(Error(".end() after done!"));
    if (chunk) this.write(chunk);
    this.ended = true;
    if (this.running) this.finish();
  };

  Tokenizer.prototype.pause = function () {
    this.running = false;
  };

  Tokenizer.prototype.resume = function () {
    this.running = true;

    if (this._index < this.buffer.length) {
      this.parse();
    }

    if (this.ended) {
      this.finish();
    }
  };
  /**
   * The current index within all of the written data.
   */


  Tokenizer.prototype.getAbsoluteIndex = function () {
    return this.bufferOffset + this._index;
  };

  Tokenizer.prototype.stateText = function (c) {
    if (c === "<") {
      if (this._index > this.sectionStart) {
        this.cbs.ontext(this.getSection());
      }

      this._state = 2
      /* BeforeTagName */
      ;
      this.sectionStart = this._index;
    } else if (this.decodeEntities && c === "&" && (this.special === 1
    /* None */
    || this.special === 4
    /* Title */
    )) {
      if (this._index > this.sectionStart) {
        this.cbs.ontext(this.getSection());
      }

      this.baseState = 1
      /* Text */
      ;
      this._state = 62
      /* BeforeEntity */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateBeforeTagName = function (c) {
    if (c === "/") {
      this._state = 5
      /* BeforeClosingTagName */
      ;
    } else if (c === "<") {
      this.cbs.ontext(this.getSection());
      this.sectionStart = this._index;
    } else if (c === ">" || this.special !== 1
    /* None */
    || whitespace(c)) {
      this._state = 1
      /* Text */
      ;
    } else if (c === "!") {
      this._state = 15
      /* BeforeDeclaration */
      ;
      this.sectionStart = this._index + 1;
    } else if (c === "?") {
      this._state = 17
      /* InProcessingInstruction */
      ;
      this.sectionStart = this._index + 1;
    } else if (!isASCIIAlpha(c)) {
      this._state = 1
      /* Text */
      ;
    } else {
      this._state = !this.xmlMode && (c === "s" || c === "S") ? 32
      /* BeforeSpecialS */
      : !this.xmlMode && (c === "t" || c === "T") ? 52
      /* BeforeSpecialT */
      : 3
      /* InTagName */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateInTagName = function (c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this.emitToken("onopentagname");
      this._state = 8
      /* BeforeAttributeName */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
    if (whitespace(c)) {// Ignore
    } else if (c === ">") {
      this._state = 1
      /* Text */
      ;
    } else if (this.special !== 1
    /* None */
    ) {
        if (c === "s" || c === "S") {
          this._state = 33
          /* BeforeSpecialSEnd */
          ;
        } else if (c === "t" || c === "T") {
          this._state = 53
          /* BeforeSpecialTEnd */
          ;
        } else {
          this._state = 1
          /* Text */
          ;
          this._index--;
        }
      } else if (!isASCIIAlpha(c)) {
      this._state = 20
      /* InSpecialComment */
      ;
      this.sectionStart = this._index;
    } else {
      this._state = 6
      /* InClosingTagName */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateInClosingTagName = function (c) {
    if (c === ">" || whitespace(c)) {
      this.emitToken("onclosetag");
      this._state = 7
      /* AfterClosingTagName */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateAfterClosingTagName = function (c) {
    // Skip everything until ">"
    if (c === ">") {
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    }
  };

  Tokenizer.prototype.stateBeforeAttributeName = function (c) {
    if (c === ">") {
      this.cbs.onopentagend();
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    } else if (c === "/") {
      this._state = 4
      /* InSelfClosingTag */
      ;
    } else if (!whitespace(c)) {
      this._state = 9
      /* InAttributeName */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateInSelfClosingTag = function (c) {
    if (c === ">") {
      this.cbs.onselfclosingtag();
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
      this.special = 1
      /* None */
      ; // Reset special state, in case of self-closing special tags
    } else if (!whitespace(c)) {
      this._state = 8
      /* BeforeAttributeName */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateInAttributeName = function (c) {
    if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
      this.cbs.onattribname(this.getSection());
      this.sectionStart = -1;
      this._state = 10
      /* AfterAttributeName */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateAfterAttributeName = function (c) {
    if (c === "=") {
      this._state = 11
      /* BeforeAttributeValue */
      ;
    } else if (c === "/" || c === ">") {
      this.cbs.onattribend(undefined);
      this._state = 8
      /* BeforeAttributeName */
      ;
      this._index--;
    } else if (!whitespace(c)) {
      this.cbs.onattribend(undefined);
      this._state = 9
      /* InAttributeName */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
    if (c === '"') {
      this._state = 12
      /* InAttributeValueDq */
      ;
      this.sectionStart = this._index + 1;
    } else if (c === "'") {
      this._state = 13
      /* InAttributeValueSq */
      ;
      this.sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
      this._state = 14
      /* InAttributeValueNq */
      ;
      this.sectionStart = this._index;
      this._index--; // Reconsume token
    }
  };

  Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
    if (c === quote) {
      this.emitToken("onattribdata");
      this.cbs.onattribend(quote);
      this._state = 8
      /* BeforeAttributeName */
      ;
    } else if (this.decodeEntities && c === "&") {
      this.emitToken("onattribdata");
      this.baseState = this._state;
      this._state = 62
      /* BeforeEntity */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
    this.handleInAttributeValue(c, '"');
  };

  Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
    this.handleInAttributeValue(c, "'");
  };

  Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
    if (whitespace(c) || c === ">") {
      this.emitToken("onattribdata");
      this.cbs.onattribend(null);
      this._state = 8
      /* BeforeAttributeName */
      ;
      this._index--;
    } else if (this.decodeEntities && c === "&") {
      this.emitToken("onattribdata");
      this.baseState = this._state;
      this._state = 62
      /* BeforeEntity */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateBeforeDeclaration = function (c) {
    this._state = c === "[" ? 23
    /* BeforeCdata1 */
    : c === "-" ? 18
    /* BeforeComment */
    : 16
    /* InDeclaration */
    ;
  };

  Tokenizer.prototype.stateInDeclaration = function (c) {
    if (c === ">") {
      this.cbs.ondeclaration(this.getSection());
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    }
  };

  Tokenizer.prototype.stateInProcessingInstruction = function (c) {
    if (c === ">") {
      this.cbs.onprocessinginstruction(this.getSection());
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    }
  };

  Tokenizer.prototype.stateBeforeComment = function (c) {
    if (c === "-") {
      this._state = 19
      /* InComment */
      ;
      this.sectionStart = this._index + 1;
    } else {
      this._state = 16
      /* InDeclaration */
      ;
    }
  };

  Tokenizer.prototype.stateInComment = function (c) {
    if (c === "-") this._state = 21
    /* AfterComment1 */
    ;
  };

  Tokenizer.prototype.stateInSpecialComment = function (c) {
    if (c === ">") {
      this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    }
  };

  Tokenizer.prototype.stateAfterComment1 = function (c) {
    if (c === "-") {
      this._state = 22
      /* AfterComment2 */
      ;
    } else {
      this._state = 19
      /* InComment */
      ;
    }
  };

  Tokenizer.prototype.stateAfterComment2 = function (c) {
    if (c === ">") {
      // Remove 2 trailing chars
      this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    } else if (c !== "-") {
      this._state = 19
      /* InComment */
      ;
    } // Else: stay in AFTER_COMMENT_2 (`--->`)

  };

  Tokenizer.prototype.stateBeforeCdata6 = function (c) {
    if (c === "[") {
      this._state = 29
      /* InCdata */
      ;
      this.sectionStart = this._index + 1;
    } else {
      this._state = 16
      /* InDeclaration */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateInCdata = function (c) {
    if (c === "]") this._state = 30
    /* AfterCdata1 */
    ;
  };

  Tokenizer.prototype.stateAfterCdata1 = function (c) {
    if (c === "]") this._state = 31
    /* AfterCdata2 */
    ;else this._state = 29
    /* InCdata */
    ;
  };

  Tokenizer.prototype.stateAfterCdata2 = function (c) {
    if (c === ">") {
      // Remove 2 trailing chars
      this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    } else if (c !== "]") {
      this._state = 29
      /* InCdata */
      ;
    } // Else: stay in AFTER_CDATA_2 (`]]]>`)

  };

  Tokenizer.prototype.stateBeforeSpecialS = function (c) {
    if (c === "c" || c === "C") {
      this._state = 34
      /* BeforeScript1 */
      ;
    } else if (c === "t" || c === "T") {
      this._state = 44
      /* BeforeStyle1 */
      ;
    } else {
      this._state = 3
      /* InTagName */
      ;
      this._index--; // Consume the token again
    }
  };

  Tokenizer.prototype.stateBeforeSpecialSEnd = function (c) {
    if (this.special === 2
    /* Script */
    && (c === "c" || c === "C")) {
      this._state = 39
      /* AfterScript1 */
      ;
    } else if (this.special === 3
    /* Style */
    && (c === "t" || c === "T")) {
      this._state = 48
      /* AfterStyle1 */
      ;
    } else this._state = 1
    /* Text */
    ;
  };

  Tokenizer.prototype.stateBeforeSpecialLast = function (c, special) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this.special = special;
    }

    this._state = 3
    /* InTagName */
    ;
    this._index--; // Consume the token again
  };

  Tokenizer.prototype.stateAfterSpecialLast = function (c, sectionStartOffset) {
    if (c === ">" || whitespace(c)) {
      this.special = 1
      /* None */
      ;
      this._state = 6
      /* InClosingTagName */
      ;
      this.sectionStart = this._index - sectionStartOffset;
      this._index--; // Reconsume the token
    } else this._state = 1
    /* Text */
    ;
  }; // For entities terminated with a semicolon


  Tokenizer.prototype.parseFixedEntity = function (map) {
    if (map === void 0) {
      map = this.xmlMode ? xml_json_1["default"] : entities_json_1["default"];
    } // Offset = 1


    if (this.sectionStart + 1 < this._index) {
      var entity = this.buffer.substring(this.sectionStart + 1, this._index);

      if (Object.prototype.hasOwnProperty.call(map, entity)) {
        this.emitPartial(map[entity]);
        this.sectionStart = this._index + 1;
      }
    }
  }; // Parses legacy entities (without trailing semicolon)


  Tokenizer.prototype.parseLegacyEntity = function () {
    var start = this.sectionStart + 1; // The max length of legacy entities is 6

    var limit = Math.min(this._index - start, 6);

    while (limit >= 2) {
      // The min length of legacy entities is 2
      var entity = this.buffer.substr(start, limit);

      if (Object.prototype.hasOwnProperty.call(legacy_json_1["default"], entity)) {
        this.emitPartial(legacy_json_1["default"][entity]);
        this.sectionStart += limit + 1;
        return;
      }

      limit--;
    }
  };

  Tokenizer.prototype.stateInNamedEntity = function (c) {
    if (c === ";") {
      this.parseFixedEntity(); // Retry as legacy entity if entity wasn't parsed

      if (this.baseState === 1
      /* Text */
      && this.sectionStart + 1 < this._index && !this.xmlMode) {
        this.parseLegacyEntity();
      }

      this._state = this.baseState;
    } else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
      if (this.xmlMode || this.sectionStart + 1 === this._index) {// Ignore
      } else if (this.baseState !== 1
      /* Text */
      ) {
          if (c !== "=") {
            // Parse as legacy entity, without allowing additional characters.
            this.parseFixedEntity(legacy_json_1["default"]);
          }
        } else {
        this.parseLegacyEntity();
      }

      this._state = this.baseState;
      this._index--;
    }
  };

  Tokenizer.prototype.decodeNumericEntity = function (offset, base, strict) {
    var sectionStart = this.sectionStart + offset;

    if (sectionStart !== this._index) {
      // Parse entity
      var entity = this.buffer.substring(sectionStart, this._index);
      var parsed = parseInt(entity, base);
      this.emitPartial(decode_codepoint_1["default"](parsed));
      this.sectionStart = strict ? this._index + 1 : this._index;
    }

    this._state = this.baseState;
  };

  Tokenizer.prototype.stateInNumericEntity = function (c) {
    if (c === ";") {
      this.decodeNumericEntity(2, 10, true);
    } else if (c < "0" || c > "9") {
      if (!this.xmlMode) {
        this.decodeNumericEntity(2, 10, false);
      } else {
        this._state = this.baseState;
      }

      this._index--;
    }
  };

  Tokenizer.prototype.stateInHexEntity = function (c) {
    if (c === ";") {
      this.decodeNumericEntity(3, 16, true);
    } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
      if (!this.xmlMode) {
        this.decodeNumericEntity(3, 16, false);
      } else {
        this._state = this.baseState;
      }

      this._index--;
    }
  };

  Tokenizer.prototype.cleanup = function () {
    if (this.sectionStart < 0) {
      this.buffer = "";
      this.bufferOffset += this._index;
      this._index = 0;
    } else if (this.running) {
      if (this._state === 1
      /* Text */
      ) {
          if (this.sectionStart !== this._index) {
            this.cbs.ontext(this.buffer.substr(this.sectionStart));
          }

          this.buffer = "";
          this.bufferOffset += this._index;
          this._index = 0;
        } else if (this.sectionStart === this._index) {
        // The section just started
        this.buffer = "";
        this.bufferOffset += this._index;
        this._index = 0;
      } else {
        // Remove everything unnecessary
        this.buffer = this.buffer.substr(this.sectionStart);
        this._index -= this.sectionStart;
        this.bufferOffset += this.sectionStart;
      }

      this.sectionStart = 0;
    }
  };
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */


  Tokenizer.prototype.parse = function () {
    while (this._index < this.buffer.length && this.running) {
      var c = this.buffer.charAt(this._index);

      if (this._state === 1
      /* Text */
      ) {
          this.stateText(c);
        } else if (this._state === 12
      /* InAttributeValueDq */
      ) {
          this.stateInAttributeValueDoubleQuotes(c);
        } else if (this._state === 9
      /* InAttributeName */
      ) {
          this.stateInAttributeName(c);
        } else if (this._state === 19
      /* InComment */
      ) {
          this.stateInComment(c);
        } else if (this._state === 20
      /* InSpecialComment */
      ) {
          this.stateInSpecialComment(c);
        } else if (this._state === 8
      /* BeforeAttributeName */
      ) {
          this.stateBeforeAttributeName(c);
        } else if (this._state === 3
      /* InTagName */
      ) {
          this.stateInTagName(c);
        } else if (this._state === 6
      /* InClosingTagName */
      ) {
          this.stateInClosingTagName(c);
        } else if (this._state === 2
      /* BeforeTagName */
      ) {
          this.stateBeforeTagName(c);
        } else if (this._state === 10
      /* AfterAttributeName */
      ) {
          this.stateAfterAttributeName(c);
        } else if (this._state === 13
      /* InAttributeValueSq */
      ) {
          this.stateInAttributeValueSingleQuotes(c);
        } else if (this._state === 11
      /* BeforeAttributeValue */
      ) {
          this.stateBeforeAttributeValue(c);
        } else if (this._state === 5
      /* BeforeClosingTagName */
      ) {
          this.stateBeforeClosingTagName(c);
        } else if (this._state === 7
      /* AfterClosingTagName */
      ) {
          this.stateAfterClosingTagName(c);
        } else if (this._state === 32
      /* BeforeSpecialS */
      ) {
          this.stateBeforeSpecialS(c);
        } else if (this._state === 21
      /* AfterComment1 */
      ) {
          this.stateAfterComment1(c);
        } else if (this._state === 14
      /* InAttributeValueNq */
      ) {
          this.stateInAttributeValueNoQuotes(c);
        } else if (this._state === 4
      /* InSelfClosingTag */
      ) {
          this.stateInSelfClosingTag(c);
        } else if (this._state === 16
      /* InDeclaration */
      ) {
          this.stateInDeclaration(c);
        } else if (this._state === 15
      /* BeforeDeclaration */
      ) {
          this.stateBeforeDeclaration(c);
        } else if (this._state === 22
      /* AfterComment2 */
      ) {
          this.stateAfterComment2(c);
        } else if (this._state === 18
      /* BeforeComment */
      ) {
          this.stateBeforeComment(c);
        } else if (this._state === 33
      /* BeforeSpecialSEnd */
      ) {
          this.stateBeforeSpecialSEnd(c);
        } else if (this._state === 53
      /* BeforeSpecialTEnd */
      ) {
          stateAfterSpecialTEnd(this, c);
        } else if (this._state === 39
      /* AfterScript1 */
      ) {
          stateAfterScript1(this, c);
        } else if (this._state === 40
      /* AfterScript2 */
      ) {
          stateAfterScript2(this, c);
        } else if (this._state === 41
      /* AfterScript3 */
      ) {
          stateAfterScript3(this, c);
        } else if (this._state === 34
      /* BeforeScript1 */
      ) {
          stateBeforeScript1(this, c);
        } else if (this._state === 35
      /* BeforeScript2 */
      ) {
          stateBeforeScript2(this, c);
        } else if (this._state === 36
      /* BeforeScript3 */
      ) {
          stateBeforeScript3(this, c);
        } else if (this._state === 37
      /* BeforeScript4 */
      ) {
          stateBeforeScript4(this, c);
        } else if (this._state === 38
      /* BeforeScript5 */
      ) {
          this.stateBeforeSpecialLast(c, 2
          /* Script */
          );
        } else if (this._state === 42
      /* AfterScript4 */
      ) {
          stateAfterScript4(this, c);
        } else if (this._state === 43
      /* AfterScript5 */
      ) {
          this.stateAfterSpecialLast(c, 6);
        } else if (this._state === 44
      /* BeforeStyle1 */
      ) {
          stateBeforeStyle1(this, c);
        } else if (this._state === 29
      /* InCdata */
      ) {
          this.stateInCdata(c);
        } else if (this._state === 45
      /* BeforeStyle2 */
      ) {
          stateBeforeStyle2(this, c);
        } else if (this._state === 46
      /* BeforeStyle3 */
      ) {
          stateBeforeStyle3(this, c);
        } else if (this._state === 47
      /* BeforeStyle4 */
      ) {
          this.stateBeforeSpecialLast(c, 3
          /* Style */
          );
        } else if (this._state === 48
      /* AfterStyle1 */
      ) {
          stateAfterStyle1(this, c);
        } else if (this._state === 49
      /* AfterStyle2 */
      ) {
          stateAfterStyle2(this, c);
        } else if (this._state === 50
      /* AfterStyle3 */
      ) {
          stateAfterStyle3(this, c);
        } else if (this._state === 51
      /* AfterStyle4 */
      ) {
          this.stateAfterSpecialLast(c, 5);
        } else if (this._state === 52
      /* BeforeSpecialT */
      ) {
          stateBeforeSpecialT(this, c);
        } else if (this._state === 54
      /* BeforeTitle1 */
      ) {
          stateBeforeTitle1(this, c);
        } else if (this._state === 55
      /* BeforeTitle2 */
      ) {
          stateBeforeTitle2(this, c);
        } else if (this._state === 56
      /* BeforeTitle3 */
      ) {
          stateBeforeTitle3(this, c);
        } else if (this._state === 57
      /* BeforeTitle4 */
      ) {
          this.stateBeforeSpecialLast(c, 4
          /* Title */
          );
        } else if (this._state === 58
      /* AfterTitle1 */
      ) {
          stateAfterTitle1(this, c);
        } else if (this._state === 59
      /* AfterTitle2 */
      ) {
          stateAfterTitle2(this, c);
        } else if (this._state === 60
      /* AfterTitle3 */
      ) {
          stateAfterTitle3(this, c);
        } else if (this._state === 61
      /* AfterTitle4 */
      ) {
          this.stateAfterSpecialLast(c, 5);
        } else if (this._state === 17
      /* InProcessingInstruction */
      ) {
          this.stateInProcessingInstruction(c);
        } else if (this._state === 64
      /* InNamedEntity */
      ) {
          this.stateInNamedEntity(c);
        } else if (this._state === 23
      /* BeforeCdata1 */
      ) {
          stateBeforeCdata1(this, c);
        } else if (this._state === 62
      /* BeforeEntity */
      ) {
          stateBeforeEntity(this, c);
        } else if (this._state === 24
      /* BeforeCdata2 */
      ) {
          stateBeforeCdata2(this, c);
        } else if (this._state === 25
      /* BeforeCdata3 */
      ) {
          stateBeforeCdata3(this, c);
        } else if (this._state === 30
      /* AfterCdata1 */
      ) {
          this.stateAfterCdata1(c);
        } else if (this._state === 31
      /* AfterCdata2 */
      ) {
          this.stateAfterCdata2(c);
        } else if (this._state === 26
      /* BeforeCdata4 */
      ) {
          stateBeforeCdata4(this, c);
        } else if (this._state === 27
      /* BeforeCdata5 */
      ) {
          stateBeforeCdata5(this, c);
        } else if (this._state === 28
      /* BeforeCdata6 */
      ) {
          this.stateBeforeCdata6(c);
        } else if (this._state === 66
      /* InHexEntity */
      ) {
          this.stateInHexEntity(c);
        } else if (this._state === 65
      /* InNumericEntity */
      ) {
          this.stateInNumericEntity(c); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        } else if (this._state === 63
      /* BeforeNumericEntity */
      ) {
          stateBeforeNumericEntity(this, c);
        } else {
        this.cbs.onerror(Error("unknown _state"), this._state);
      }

      this._index++;
    }

    this.cleanup();
  };

  Tokenizer.prototype.finish = function () {
    // If there is remaining data, emit it in a reasonable way
    if (this.sectionStart < this._index) {
      this.handleTrailingData();
    }

    this.cbs.onend();
  };

  Tokenizer.prototype.handleTrailingData = function () {
    var data = this.buffer.substr(this.sectionStart);

    if (this._state === 29
    /* InCdata */
    || this._state === 30
    /* AfterCdata1 */
    || this._state === 31
    /* AfterCdata2 */
    ) {
        this.cbs.oncdata(data);
      } else if (this._state === 19
    /* InComment */
    || this._state === 21
    /* AfterComment1 */
    || this._state === 22
    /* AfterComment2 */
    ) {
        this.cbs.oncomment(data);
      } else if (this._state === 64
    /* InNamedEntity */
    && !this.xmlMode) {
      this.parseLegacyEntity();

      if (this.sectionStart < this._index) {
        this._state = this.baseState;
        this.handleTrailingData();
      }
    } else if (this._state === 65
    /* InNumericEntity */
    && !this.xmlMode) {
      this.decodeNumericEntity(2, 10, false);

      if (this.sectionStart < this._index) {
        this._state = this.baseState;
        this.handleTrailingData();
      }
    } else if (this._state === 66
    /* InHexEntity */
    && !this.xmlMode) {
      this.decodeNumericEntity(3, 16, false);

      if (this.sectionStart < this._index) {
        this._state = this.baseState;
        this.handleTrailingData();
      }
    } else if (this._state !== 3
    /* InTagName */
    && this._state !== 8
    /* BeforeAttributeName */
    && this._state !== 11
    /* BeforeAttributeValue */
    && this._state !== 10
    /* AfterAttributeName */
    && this._state !== 9
    /* InAttributeName */
    && this._state !== 13
    /* InAttributeValueSq */
    && this._state !== 12
    /* InAttributeValueDq */
    && this._state !== 14
    /* InAttributeValueNq */
    && this._state !== 6
    /* InClosingTagName */
    ) {
        this.cbs.ontext(data);
      }
    /*
     * Else, ignore remaining data
     * TODO add a way to remove current tag
     */

  };

  Tokenizer.prototype.getSection = function () {
    return this.buffer.substring(this.sectionStart, this._index);
  };

  Tokenizer.prototype.emitToken = function (name) {
    this.cbs[name](this.getSection());
    this.sectionStart = -1;
  };

  Tokenizer.prototype.emitPartial = function (value) {
    if (this.baseState !== 1
    /* Text */
    ) {
        this.cbs.onattribdata(value); // TODO implement the new event
      } else {
      this.cbs.ontext(value);
    }
  };

  return Tokenizer;
}();

exports["default"] = Tokenizer;

},{"entities/lib/decode_codepoint":76,"entities/lib/maps/entities.json":80,"entities/lib/maps/legacy.json":81,"entities/lib/maps/xml.json":82}],87:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.DomHandler = exports.Parser = void 0;

var Parser_1 = require("./Parser");

Object.defineProperty(exports, "Parser", {
  enumerable: true,
  get: function get() {
    return Parser_1.Parser;
  }
});

var domhandler_1 = require("domhandler");

Object.defineProperty(exports, "DomHandler", {
  enumerable: true,
  get: function get() {
    return domhandler_1.DomHandler;
  }
});
Object.defineProperty(exports, "DefaultHandler", {
  enumerable: true,
  get: function get() {
    return domhandler_1.DomHandler;
  }
}); // Helper methods

/**
 * Parses data, returns the resulting DOM.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */

function parseDOM(data, options) {
  var handler = new domhandler_1.DomHandler(void 0, options);
  new Parser_1.Parser(handler, options).end(data);
  return handler.dom;
}

exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param cb A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
 */

function createDomStream(cb, options, elementCb) {
  var handler = new domhandler_1.DomHandler(cb, options, elementCb);
  return new Parser_1.Parser(handler, options);
}

exports.createDomStream = createDomStream;

var Tokenizer_1 = require("./Tokenizer");

Object.defineProperty(exports, "Tokenizer", {
  enumerable: true,
  get: function get() {
    return __importDefault(Tokenizer_1)["default"];
  }
});

var ElementType = __importStar(require("domelementtype"));

exports.ElementType = ElementType;
/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */

__exportStar(require("./FeedHandler"), exports);

exports.DomUtils = __importStar(require("domutils"));

var FeedHandler_1 = require("./FeedHandler");

Object.defineProperty(exports, "RssHandler", {
  enumerable: true,
  get: function get() {
    return FeedHandler_1.FeedHandler;
  }
});

},{"./FeedHandler":84,"./Parser":85,"./Tokenizer":86,"domelementtype":64,"domhandler":65,"domutils":68}],88:[function(require,module,exports){
"use strict";

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],89:[function(require,module,exports){
"use strict";

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function TempCtor() {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

},{}],90:[function(require,module,exports){
/*
 * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('./types'),
    _isArray = _require.isArray,
    _isObject = _require.isObject,
    _isString = _require.isString;

var _require2 = require('./util'),
    _asArray = _require2.asArray;

var _require3 = require('./url'),
    prependBase = _require3.prependBase;

var JsonLdError = require('./JsonLdError');

var ResolvedContext = require('./ResolvedContext');

var MAX_CONTEXT_URLS = 10;

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a ContextResolver.
   *
   * @param sharedCache a shared LRU cache with `get` and `set` APIs.
   */
  function ContextResolver(_ref) {
    var sharedCache = _ref.sharedCache;
    (0, _classCallCheck2["default"])(this, ContextResolver);
    this.perOpCache = new Map();
    this.sharedCache = sharedCache;
  }

  (0, _createClass2["default"])(ContextResolver, [{
    key: "resolve",
    value: function () {
      var _resolve = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref2) {
        var activeCtx, context, documentLoader, base, _ref2$cycles, cycles, allResolved, _iterator, _step, ctx, _resolved, key, resolved;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                activeCtx = _ref2.activeCtx, context = _ref2.context, documentLoader = _ref2.documentLoader, base = _ref2.base, _ref2$cycles = _ref2.cycles, cycles = _ref2$cycles === void 0 ? new Set() : _ref2$cycles;

                // process `@context`
                if (context && _isObject(context) && context['@context']) {
                  context = context['@context'];
                } // context is one or more contexts


                context = _asArray(context); // resolve each context in the array

                allResolved = [];
                _iterator = _createForOfIteratorHelper(context);
                _context.prev = 5;

                _iterator.s();

              case 7:
                if ((_step = _iterator.n()).done) {
                  _context.next = 27;
                  break;
                }

                ctx = _step.value;

                if (!_isString(ctx)) {
                  _context.next = 17;
                  break;
                }

                // see if `ctx` has been resolved before...
                _resolved = this._get(ctx);

                if (_resolved) {
                  _context.next = 15;
                  break;
                }

                _context.next = 14;
                return this._resolveRemoteContext({
                  activeCtx: activeCtx,
                  url: ctx,
                  documentLoader: documentLoader,
                  base: base,
                  cycles: cycles
                });

              case 14:
                _resolved = _context.sent;

              case 15:
                // add to output and continue
                if (_isArray(_resolved)) {
                  allResolved.push.apply(allResolved, (0, _toConsumableArray2["default"])(_resolved));
                } else {
                  allResolved.push(_resolved);
                }

                return _context.abrupt("continue", 25);

              case 17:
                if (!(ctx === null)) {
                  _context.next = 20;
                  break;
                }

                // handle `null` context, nothing to cache
                allResolved.push(new ResolvedContext({
                  document: null
                }));
                return _context.abrupt("continue", 25);

              case 20:
                if (!_isObject(ctx)) {
                  _throwInvalidLocalContext(context);
                } // context is an object, get/create `ResolvedContext` for it


                key = JSON.stringify(ctx);
                resolved = this._get(key);

                if (!resolved) {
                  // create a new static `ResolvedContext` and cache it
                  resolved = new ResolvedContext({
                    document: ctx
                  });

                  this._cacheResolvedContext({
                    key: key,
                    resolved: resolved,
                    tag: 'static'
                  });
                }

                allResolved.push(resolved);

              case 25:
                _context.next = 7;
                break;

              case 27:
                _context.next = 32;
                break;

              case 29:
                _context.prev = 29;
                _context.t0 = _context["catch"](5);

                _iterator.e(_context.t0);

              case 32:
                _context.prev = 32;

                _iterator.f();

                return _context.finish(32);

              case 35:
                return _context.abrupt("return", allResolved);

              case 36:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[5, 29, 32, 35]]);
      }));

      function resolve(_x) {
        return _resolve.apply(this, arguments);
      }

      return resolve;
    }()
  }, {
    key: "_get",
    value: function _get(key) {
      // get key from per operation cache; no `tag` is used with this cache so
      // any retrieved context will always be the same during a single operation
      var resolved = this.perOpCache.get(key);

      if (!resolved) {
        // see if the shared cache has a `static` entry for this URL
        var tagMap = this.sharedCache.get(key);

        if (tagMap) {
          resolved = tagMap.get('static');

          if (resolved) {
            this.perOpCache.set(key, resolved);
          }
        }
      }

      return resolved;
    }
  }, {
    key: "_cacheResolvedContext",
    value: function _cacheResolvedContext(_ref3) {
      var key = _ref3.key,
          resolved = _ref3.resolved,
          tag = _ref3.tag;
      this.perOpCache.set(key, resolved);

      if (tag !== undefined) {
        var tagMap = this.sharedCache.get(key);

        if (!tagMap) {
          tagMap = new Map();
          this.sharedCache.set(key, tagMap);
        }

        tagMap.set(tag, resolved);
      }

      return resolved;
    }
  }, {
    key: "_resolveRemoteContext",
    value: function () {
      var _resolveRemoteContext2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref4) {
        var activeCtx, url, documentLoader, base, cycles, _yield$this$_fetchCon, context, remoteDoc, resolved;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                activeCtx = _ref4.activeCtx, url = _ref4.url, documentLoader = _ref4.documentLoader, base = _ref4.base, cycles = _ref4.cycles;
                // resolve relative URL and fetch context
                url = prependBase(base, url);
                _context2.next = 4;
                return this._fetchContext({
                  activeCtx: activeCtx,
                  url: url,
                  documentLoader: documentLoader,
                  cycles: cycles
                });

              case 4:
                _yield$this$_fetchCon = _context2.sent;
                context = _yield$this$_fetchCon.context;
                remoteDoc = _yield$this$_fetchCon.remoteDoc;
                // update base according to remote document and resolve any relative URLs
                base = remoteDoc.documentUrl || url;

                _resolveContextUrls({
                  context: context,
                  base: base
                }); // resolve, cache, and return context


                _context2.next = 11;
                return this.resolve({
                  activeCtx: activeCtx,
                  context: context,
                  documentLoader: documentLoader,
                  base: base,
                  cycles: cycles
                });

              case 11:
                resolved = _context2.sent;

                this._cacheResolvedContext({
                  key: url,
                  resolved: resolved,
                  tag: remoteDoc.tag
                });

                return _context2.abrupt("return", resolved);

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _resolveRemoteContext(_x2) {
        return _resolveRemoteContext2.apply(this, arguments);
      }

      return _resolveRemoteContext;
    }()
  }, {
    key: "_fetchContext",
    value: function () {
      var _fetchContext2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref5) {
        var activeCtx, url, documentLoader, cycles, context, remoteDoc;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                activeCtx = _ref5.activeCtx, url = _ref5.url, documentLoader = _ref5.documentLoader, cycles = _ref5.cycles;

                if (!(cycles.size > MAX_CONTEXT_URLS)) {
                  _context3.next = 3;
                  break;
                }

                throw new JsonLdError('Maximum number of @context URLs exceeded.', 'jsonld.ContextUrlError', {
                  code: activeCtx.processingMode === 'json-ld-1.0' ? 'loading remote context failed' : 'context overflow',
                  max: MAX_CONTEXT_URLS
                });

              case 3:
                if (!cycles.has(url)) {
                  _context3.next = 5;
                  break;
                }

                throw new JsonLdError('Cyclical @context URLs detected.', 'jsonld.ContextUrlError', {
                  code: activeCtx.processingMode === 'json-ld-1.0' ? 'recursive context inclusion' : 'context overflow',
                  url: url
                });

              case 5:
                // track cycles
                cycles.add(url);
                _context3.prev = 6;
                _context3.next = 9;
                return documentLoader(url);

              case 9:
                remoteDoc = _context3.sent;
                context = remoteDoc.document || null; // parse string context as JSON

                if (_isString(context)) {
                  context = JSON.parse(context);
                }

                _context3.next = 17;
                break;

              case 14:
                _context3.prev = 14;
                _context3.t0 = _context3["catch"](6);
                throw new JsonLdError('Dereferencing a URL did not result in a valid JSON-LD object. ' + 'Possible causes are an inaccessible URL perhaps due to ' + 'a same-origin policy (ensure the server uses CORS if you are ' + 'using client-side JavaScript), too many redirects, a ' + 'non-JSON response, or more than one HTTP Link Header was ' + 'provided for a remote context.', 'jsonld.InvalidUrl', {
                  code: 'loading remote context failed',
                  url: url,
                  cause: _context3.t0
                });

              case 17:
                if (_isObject(context)) {
                  _context3.next = 19;
                  break;
                }

                throw new JsonLdError('Dereferencing a URL did not result in a JSON object. The ' + 'response was valid JSON, but it was not a JSON object.', 'jsonld.InvalidUrl', {
                  code: 'invalid remote context',
                  url: url
                });

              case 19:
                // use empty context if no @context key is present
                if (!('@context' in context)) {
                  context = {
                    '@context': {}
                  };
                } else {
                  context = {
                    '@context': context['@context']
                  };
                } // append @context URL to context if given


                if (remoteDoc.contextUrl) {
                  if (!_isArray(context['@context'])) {
                    context['@context'] = [context['@context']];
                  }

                  context['@context'].push(remoteDoc.contextUrl);
                }

                return _context3.abrupt("return", {
                  context: context,
                  remoteDoc: remoteDoc
                });

              case 22:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[6, 14]]);
      }));

      function _fetchContext(_x3) {
        return _fetchContext2.apply(this, arguments);
      }

      return _fetchContext;
    }()
  }]);
  return ContextResolver;
}();

function _throwInvalidLocalContext(ctx) {
  throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {
    code: 'invalid local context',
    context: ctx
  });
}
/**
 * Resolve all relative `@context` URLs in the given context by inline
 * replacing them with absolute URLs.
 *
 * @param context the context.
 * @param base the base IRI to use to resolve relative IRIs.
 */


function _resolveContextUrls(_ref6) {
  var context = _ref6.context,
      base = _ref6.base;

  if (!context) {
    return;
  }

  var ctx = context['@context'];

  if (_isString(ctx)) {
    context['@context'] = prependBase(base, ctx);
    return;
  }

  if (_isArray(ctx)) {
    for (var i = 0; i < ctx.length; ++i) {
      var element = ctx[i];

      if (_isString(element)) {
        ctx[i] = prependBase(base, element);
        continue;
      }

      if (_isObject(element)) {
        _resolveContextUrls({
          context: {
            '@context': element
          },
          base: base
        });
      }
    }

    return;
  }

  if (!_isObject(ctx)) {
    // no @context URLs can be found in non-object
    return;
  } // ctx is an object, resolve any context URLs in terms


  for (var term in ctx) {
    _resolveContextUrls({
      context: ctx[term],
      base: base
    });
  }
}

},{"./JsonLdError":91,"./ResolvedContext":96,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/toConsumableArray":26,"@babel/runtime/regenerator":30}],91:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

module.exports = /*#__PURE__*/function (_Error) {
  (0, _inherits2["default"])(JsonLdError, _Error);

  var _super = _createSuper(JsonLdError);

  /**
   * Creates a JSON-LD Error.
   *
   * @param msg the error message.
   * @param type the error type.
   * @param details the error details.
   */
  function JsonLdError() {
    var _this;

    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'An unspecified JSON-LD error occurred.';
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'jsonld.Error';
    var details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, JsonLdError);
    _this = _super.call(this, message);
    _this.name = name;
    _this.message = message;
    _this.details = details;
    return _this;
  }

  return JsonLdError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"@babel/runtime/helpers/wrapNativeSuper":29}],92:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

module.exports = function (jsonld) {
  var JsonLdProcessor = /*#__PURE__*/function () {
    function JsonLdProcessor() {
      (0, _classCallCheck2["default"])(this, JsonLdProcessor);
    }

    (0, _createClass2["default"])(JsonLdProcessor, [{
      key: "toString",
      value: function toString() {
        return '[object JsonLdProcessor]';
      }
    }]);
    return JsonLdProcessor;
  }();

  Object.defineProperty(JsonLdProcessor, 'prototype', {
    writable: false,
    enumerable: false
  });
  Object.defineProperty(JsonLdProcessor.prototype, 'constructor', {
    writable: true,
    enumerable: false,
    configurable: true,
    value: JsonLdProcessor
  }); // The Web IDL test harness will check the number of parameters defined in
  // the functions below. The number of parameters must exactly match the
  // required (non-optional) parameters of the JsonLdProcessor interface as
  // defined here:
  // https://www.w3.org/TR/json-ld-api/#the-jsonldprocessor-interface

  JsonLdProcessor.compact = function (input, ctx) {
    if (arguments.length < 2) {
      return Promise.reject(new TypeError('Could not compact, too few arguments.'));
    }

    return jsonld.compact(input, ctx);
  };

  JsonLdProcessor.expand = function (input) {
    if (arguments.length < 1) {
      return Promise.reject(new TypeError('Could not expand, too few arguments.'));
    }

    return jsonld.expand(input);
  };

  JsonLdProcessor.flatten = function (input) {
    if (arguments.length < 1) {
      return Promise.reject(new TypeError('Could not flatten, too few arguments.'));
    }

    return jsonld.flatten(input);
  };

  return JsonLdProcessor;
};

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],93:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict'; // TODO: move `NQuads` to its own package

module.exports = require('rdf-canonize').NQuads;

},{"rdf-canonize":153}],94:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */

/* global Node, XMLSerializer */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _require = require('./constants'),
    RDF_LANGSTRING = _require.RDF_LANGSTRING,
    RDF_PLAIN_LITERAL = _require.RDF_PLAIN_LITERAL,
    RDF_OBJECT = _require.RDF_OBJECT,
    RDF_XML_LITERAL = _require.RDF_XML_LITERAL,
    XSD_STRING = _require.XSD_STRING;

var _Node;

if (typeof Node !== 'undefined') {
  _Node = Node;
} else {
  _Node = {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  };
}

module.exports = /*#__PURE__*/function () {
  function Rdfa() {
    (0, _classCallCheck2["default"])(this, Rdfa);
  }

  (0, _createClass2["default"])(Rdfa, [{
    key: "parse",

    /**
     * Parses the RDF dataset found via the data object from the RDFa API.
     *
     * @param data the RDFa API data object.
     *
     * @return the RDF dataset.
     */
    value: function parse(data) {
      var dataset = {};
      dataset['@default'] = [];
      var subjects = data.getSubjects();

      for (var si = 0; si < subjects.length; ++si) {
        var subject = subjects[si];

        if (subject === null) {
          continue;
        } // get all related triples


        var triples = data.getSubjectTriples(subject);

        if (triples === null) {
          continue;
        }

        var predicates = triples.predicates;

        for (var predicate in predicates) {
          // iterate over objects
          var objects = predicates[predicate].objects;

          for (var oi = 0; oi < objects.length; ++oi) {
            var object = objects[oi]; // create RDF triple

            var triple = {}; // add subject

            if (subject.indexOf('_:') === 0) {
              triple.subject = {
                type: 'blank node',
                value: subject
              };
            } else {
              triple.subject = {
                type: 'IRI',
                value: subject
              };
            } // add predicate


            if (predicate.indexOf('_:') === 0) {
              triple.predicate = {
                type: 'blank node',
                value: predicate
              };
            } else {
              triple.predicate = {
                type: 'IRI',
                value: predicate
              };
            } // serialize XML literal


            var value = object.value;

            if (object.type === RDF_XML_LITERAL) {
              // initialize XMLSerializer
              var _XMLSerializer = getXMLSerializerClass();

              var serializer = new _XMLSerializer();
              value = '';

              for (var x = 0; x < object.value.length; x++) {
                if (object.value[x].nodeType === _Node.ELEMENT_NODE) {
                  value += serializer.serializeToString(object.value[x]);
                } else if (object.value[x].nodeType === _Node.TEXT_NODE) {
                  value += object.value[x].nodeValue;
                }
              }
            } // add object


            triple.object = {}; // object is an IRI

            if (object.type === RDF_OBJECT) {
              if (object.value.indexOf('_:') === 0) {
                triple.object.type = 'blank node';
              } else {
                triple.object.type = 'IRI';
              }
            } else {
              // object is a literal
              triple.object.type = 'literal';

              if (object.type === RDF_PLAIN_LITERAL) {
                if (object.language) {
                  triple.object.datatype = RDF_LANGSTRING;
                  triple.object.language = object.language;
                } else {
                  triple.object.datatype = XSD_STRING;
                }
              } else {
                triple.object.datatype = object.type;
              }
            }

            triple.object.value = value; // add triple to dataset in default graph

            dataset['@default'].push(triple);
          }
        }
      }

      return dataset;
    }
  }]);
  return Rdfa;
}();

function getXMLSerializerClass() {
  if (typeof XMLSerializer === 'undefined') {
    return require('xmldom').XMLSerializer;
  }

  return XMLSerializer;
}

},{"./constants":98,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"xmldom":58}],95:[function(require,module,exports){
/*
 * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a simple queue for requesting documents.
   */
  function RequestQueue() {
    (0, _classCallCheck2["default"])(this, RequestQueue);
    this._requests = {};
  }

  (0, _createClass2["default"])(RequestQueue, [{
    key: "wrapLoader",
    value: function wrapLoader(loader) {
      var self = this;
      self._loader = loader;
      return function ()
      /* url */
      {
        return self.add.apply(self, arguments);
      };
    }
  }, {
    key: "add",
    value: function () {
      var _add = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url) {
        var promise;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                promise = this._requests[url];

                if (!promise) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return", Promise.resolve(promise));

              case 3:
                // queue URL and load it
                promise = this._requests[url] = this._loader(url);
                _context.prev = 4;
                _context.next = 7;
                return promise;

              case 7:
                return _context.abrupt("return", _context.sent);

              case 8:
                _context.prev = 8;
                delete this._requests[url];
                return _context.finish(8);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4,, 8, 11]]);
      }));

      function add(_x) {
        return _add.apply(this, arguments);
      }

      return add;
    }()
  }]);
  return RequestQueue;
}();

},{"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30}],96:[function(require,module,exports){
/*
 * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var LRU = require('lru-cache');

var MAX_ACTIVE_CONTEXTS = 10;

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a ResolvedContext.
   *
   * @param document the context document.
   */
  function ResolvedContext(_ref) {
    var document = _ref.document;
    (0, _classCallCheck2["default"])(this, ResolvedContext);
    this.document = document; // TODO: enable customization of processed context cache
    // TODO: limit based on size of processed contexts vs. number of them

    this.cache = new LRU({
      max: MAX_ACTIVE_CONTEXTS
    });
  }

  (0, _createClass2["default"])(ResolvedContext, [{
    key: "getProcessed",
    value: function getProcessed(activeCtx) {
      return this.cache.get(activeCtx);
    }
  }, {
    key: "setProcessed",
    value: function setProcessed(activeCtx, processedCtx) {
      this.cache.set(activeCtx, processedCtx);
    }
  }]);
  return ResolvedContext;
}();

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"lru-cache":113}],97:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var JsonLdError = require('./JsonLdError');

var _require = require('./types'),
    _isArray = _require.isArray,
    _isObject = _require.isObject,
    _isString = _require.isString,
    _isUndefined = _require.isUndefined;

var _require2 = require('./graphTypes'),
    _isList = _require2.isList,
    _isValue = _require2.isValue,
    _isGraph = _require2.isGraph,
    _isSimpleGraph = _require2.isSimpleGraph,
    _isSubjectReference = _require2.isSubjectReference;

var _require3 = require('./context'),
    _expandIri = _require3.expandIri,
    _getContextValue = _require3.getContextValue,
    _isKeyword = _require3.isKeyword,
    _processContext = _require3.process,
    _processingMode = _require3.processingMode;

var _require4 = require('./url'),
    _removeBase = _require4.removeBase,
    _prependBase = _require4.prependBase;

var _require5 = require('./util'),
    _addValue = _require5.addValue,
    _asArray = _require5.asArray,
    _compareShortestLeast = _require5.compareShortestLeast;

var api = {};
module.exports = api;
/**
 * Recursively compacts an element using the given active context. All values
 * must be in expanded form before this method is called.
 *
 * @param activeCtx the active context to use.
 * @param activeProperty the compacted property associated with the element
 *          to compact, null for none.
 * @param element the element to compact.
 * @param options the compaction options.
 * @param compactionMap the compaction map to use.
 *
 * @return a promise that resolves to the compacted value.
 */

api.compact = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref) {
    var activeCtx, _ref$activeProperty, activeProperty, element, _ref$options, options, _ref$compactionMap, compactionMap, rval, i, compacted, container, ctx, _ret;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            activeCtx = _ref.activeCtx, _ref$activeProperty = _ref.activeProperty, activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty, element = _ref.element, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, _ref$compactionMap = _ref.compactionMap, compactionMap = _ref$compactionMap === void 0 ? function () {
              return undefined;
            } : _ref$compactionMap;

            if (!_isArray(element)) {
              _context2.next = 20;
              break;
            }

            rval = [];
            i = 0;

          case 4:
            if (!(i < element.length)) {
              _context2.next = 18;
              break;
            }

            _context2.next = 7;
            return api.compact({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element[i],
              options: options,
              compactionMap: compactionMap
            });

          case 7:
            compacted = _context2.sent;

            if (!(compacted === null)) {
              _context2.next = 14;
              break;
            }

            _context2.next = 11;
            return compactionMap({
              unmappedValue: element[i],
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              parent: element,
              index: i,
              options: options
            });

          case 11:
            compacted = _context2.sent;

            if (!(compacted === undefined)) {
              _context2.next = 14;
              break;
            }

            return _context2.abrupt("continue", 15);

          case 14:
            rval.push(compacted);

          case 15:
            ++i;
            _context2.next = 4;
            break;

          case 18:
            if (options.compactArrays && rval.length === 1) {
              // use single element if no container is specified
              container = _getContextValue(activeCtx, activeProperty, '@container') || [];

              if (container.length === 0) {
                rval = rval[0];
              }
            }

            return _context2.abrupt("return", rval);

          case 20:
            // use any scoped context on activeProperty
            ctx = _getContextValue(activeCtx, activeProperty, '@context');

            if (_isUndefined(ctx)) {
              _context2.next = 25;
              break;
            }

            _context2.next = 24;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: ctx,
              propagate: true,
              overrideProtected: true,
              options: options
            });

          case 24:
            activeCtx = _context2.sent;

          case 25:
            if (!_isObject(element)) {
              _context2.next = 30;
              break;
            }

            return _context2.delegateYield( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
              var linked, _i, _rval, _container, insideReverse, rval, inputCtx, propertyScopedCtx, types, typeContext, _iterator, _step, type, compactedType, _ctx, keys, _iterator2, _step2, expandedProperty, expandedValue, compactedValue, alias, _compactedValue, _alias, _container2, typeAsSet, isArray, _compactedValue2, compactedProperty, value, _container3, useArray, _alias2, _compactedValue3, _container4, _alias3, _alias4, itemActiveProperty, nestProperty, nestResult, _iterator3, _step3, expandedItem, _itemActiveProperty, _nestProperty, _nestResult, _container5, isGraph, isList, inner, compactedItem, mapObject, key, _mapObject, _key, indexKey, containerKey, others, _asArray2, _asArray3, idKey, typeKey, _types, _asArray4, _asArray5, _isArray2;

              return _regenerator["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!(options.link && '@id' in element && options.link.hasOwnProperty(element['@id']))) {
                        _context.next = 9;
                        break;
                      }

                      // check for a linked element to reuse
                      linked = options.link[element['@id']];
                      _i = 0;

                    case 3:
                      if (!(_i < linked.length)) {
                        _context.next = 9;
                        break;
                      }

                      if (!(linked[_i].expanded === element)) {
                        _context.next = 6;
                        break;
                      }

                      return _context.abrupt("return", {
                        v: linked[_i].compacted
                      });

                    case 6:
                      ++_i;
                      _context.next = 3;
                      break;

                    case 9:
                      if (!(_isValue(element) || _isSubjectReference(element))) {
                        _context.next = 13;
                        break;
                      }

                      _rval = api.compactValue({
                        activeCtx: activeCtx,
                        activeProperty: activeProperty,
                        value: element,
                        options: options
                      });

                      if (options.link && _isSubjectReference(element)) {
                        // store linked element
                        if (!options.link.hasOwnProperty(element['@id'])) {
                          options.link[element['@id']] = [];
                        }

                        options.link[element['@id']].push({
                          expanded: element,
                          compacted: _rval
                        });
                      }

                      return _context.abrupt("return", {
                        v: _rval
                      });

                    case 13:
                      if (!_isList(element)) {
                        _context.next = 17;
                        break;
                      }

                      _container = _getContextValue(activeCtx, activeProperty, '@container') || [];

                      if (!_container.includes('@list')) {
                        _context.next = 17;
                        break;
                      }

                      return _context.abrupt("return", {
                        v: api.compact({
                          activeCtx: activeCtx,
                          activeProperty: activeProperty,
                          element: element['@list'],
                          options: options,
                          compactionMap: compactionMap
                        })
                      });

                    case 17:
                      // FIXME: avoid misuse of active property as an expanded property?
                      insideReverse = activeProperty === '@reverse';
                      rval = {}; // original context before applying property-scoped and local contexts

                      inputCtx = activeCtx; // revert to previous context, if there is one,
                      // and element is not a value object or a node reference

                      if (!_isValue(element) && !_isSubjectReference(element)) {
                        activeCtx = activeCtx.revertToPreviousContext();
                      } // apply property-scoped context after reverting term-scoped context


                      propertyScopedCtx = _getContextValue(inputCtx, activeProperty, '@context');

                      if (_isUndefined(propertyScopedCtx)) {
                        _context.next = 26;
                        break;
                      }

                      _context.next = 25;
                      return _processContext({
                        activeCtx: activeCtx,
                        localCtx: propertyScopedCtx,
                        propagate: true,
                        overrideProtected: true,
                        options: options
                      });

                    case 25:
                      activeCtx = _context.sent;

                    case 26:
                      if (options.link && '@id' in element) {
                        // store linked element
                        if (!options.link.hasOwnProperty(element['@id'])) {
                          options.link[element['@id']] = [];
                        }

                        options.link[element['@id']].push({
                          expanded: element,
                          compacted: rval
                        });
                      } // apply any context defined on an alias of @type
                      // if key is @type and any compacted value is a term having a local
                      // context, overlay that context


                      types = element['@type'] || [];

                      if (types.length > 1) {
                        types = Array.from(types).sort();
                      } // find all type-scoped contexts based on current context, prior to
                      // updating it


                      typeContext = activeCtx;
                      _iterator = _createForOfIteratorHelper(types);
                      _context.prev = 31;

                      _iterator.s();

                    case 33:
                      if ((_step = _iterator.n()).done) {
                        _context.next = 43;
                        break;
                      }

                      type = _step.value;
                      compactedType = api.compactIri({
                        activeCtx: typeContext,
                        iri: type,
                        relativeTo: {
                          vocab: true
                        }
                      }); // Use any type-scoped context defined on this value

                      _ctx = _getContextValue(inputCtx, compactedType, '@context');

                      if (_isUndefined(_ctx)) {
                        _context.next = 41;
                        break;
                      }

                      _context.next = 40;
                      return _processContext({
                        activeCtx: activeCtx,
                        localCtx: _ctx,
                        options: options,
                        propagate: false
                      });

                    case 40:
                      activeCtx = _context.sent;

                    case 41:
                      _context.next = 33;
                      break;

                    case 43:
                      _context.next = 48;
                      break;

                    case 45:
                      _context.prev = 45;
                      _context.t0 = _context["catch"](31);

                      _iterator.e(_context.t0);

                    case 48:
                      _context.prev = 48;

                      _iterator.f();

                      return _context.finish(48);

                    case 51:
                      // process element keys in order
                      keys = Object.keys(element).sort();
                      _iterator2 = _createForOfIteratorHelper(keys);
                      _context.prev = 53;

                      _iterator2.s();

                    case 55:
                      if ((_step2 = _iterator2.n()).done) {
                        _context.next = 211;
                        break;
                      }

                      expandedProperty = _step2.value;
                      expandedValue = element[expandedProperty]; // compact @id

                      if (!(expandedProperty === '@id')) {
                        _context.next = 64;
                        break;
                      }

                      compactedValue = _asArray(expandedValue).map(function (expandedIri) {
                        return api.compactIri({
                          activeCtx: activeCtx,
                          iri: expandedIri,
                          relativeTo: {
                            vocab: false
                          },
                          base: options.base
                        });
                      });

                      if (compactedValue.length === 1) {
                        compactedValue = compactedValue[0];
                      } // use keyword alias and add value


                      alias = api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@id',
                        relativeTo: {
                          vocab: true
                        }
                      });
                      rval[alias] = compactedValue;
                      return _context.abrupt("continue", 209);

                    case 64:
                      if (!(expandedProperty === '@type')) {
                        _context.next = 73;
                        break;
                      }

                      // resolve type values against previous context
                      _compactedValue = _asArray(expandedValue).map(function (expandedIri) {
                        return api.compactIri({
                          activeCtx: inputCtx,
                          iri: expandedIri,
                          relativeTo: {
                            vocab: true
                          }
                        });
                      });

                      if (_compactedValue.length === 1) {
                        _compactedValue = _compactedValue[0];
                      } // use keyword alias and add value


                      _alias = api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@type',
                        relativeTo: {
                          vocab: true
                        }
                      });
                      _container2 = _getContextValue(activeCtx, _alias, '@container') || []; // treat as array for @type if @container includes @set

                      typeAsSet = _container2.includes('@set') && _processingMode(activeCtx, 1.1);
                      isArray = typeAsSet || _isArray(_compactedValue) && expandedValue.length === 0;

                      _addValue(rval, _alias, _compactedValue, {
                        propertyIsArray: isArray
                      });

                      return _context.abrupt("continue", 209);

                    case 73:
                      if (!(expandedProperty === '@reverse')) {
                        _context.next = 80;
                        break;
                      }

                      _context.next = 76;
                      return api.compact({
                        activeCtx: activeCtx,
                        activeProperty: '@reverse',
                        element: expandedValue,
                        options: options,
                        compactionMap: compactionMap
                      });

                    case 76:
                      _compactedValue2 = _context.sent;

                      // handle double-reversed properties
                      for (compactedProperty in _compactedValue2) {
                        if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {
                          value = _compactedValue2[compactedProperty];
                          _container3 = _getContextValue(activeCtx, compactedProperty, '@container') || [];
                          useArray = _container3.includes('@set') || !options.compactArrays;

                          _addValue(rval, compactedProperty, value, {
                            propertyIsArray: useArray
                          });

                          delete _compactedValue2[compactedProperty];
                        }
                      }

                      if (Object.keys(_compactedValue2).length > 0) {
                        // use keyword alias and add value
                        _alias2 = api.compactIri({
                          activeCtx: activeCtx,
                          iri: expandedProperty,
                          relativeTo: {
                            vocab: true
                          }
                        });

                        _addValue(rval, _alias2, _compactedValue2);
                      }

                      return _context.abrupt("continue", 209);

                    case 80:
                      if (!(expandedProperty === '@preserve')) {
                        _context.next = 86;
                        break;
                      }

                      _context.next = 83;
                      return api.compact({
                        activeCtx: activeCtx,
                        activeProperty: activeProperty,
                        element: expandedValue,
                        options: options,
                        compactionMap: compactionMap
                      });

                    case 83:
                      _compactedValue3 = _context.sent;

                      if (!(_isArray(_compactedValue3) && _compactedValue3.length === 0)) {
                        _addValue(rval, expandedProperty, _compactedValue3);
                      }

                      return _context.abrupt("continue", 209);

                    case 86:
                      if (!(expandedProperty === '@index')) {
                        _context.next = 93;
                        break;
                      }

                      // drop @index if inside an @index container
                      _container4 = _getContextValue(activeCtx, activeProperty, '@container') || [];

                      if (!_container4.includes('@index')) {
                        _context.next = 90;
                        break;
                      }

                      return _context.abrupt("continue", 209);

                    case 90:
                      // use keyword alias and add value
                      _alias3 = api.compactIri({
                        activeCtx: activeCtx,
                        iri: expandedProperty,
                        relativeTo: {
                          vocab: true
                        }
                      });

                      _addValue(rval, _alias3, expandedValue);

                      return _context.abrupt("continue", 209);

                    case 93:
                      if (!(expandedProperty !== '@graph' && expandedProperty !== '@list' && expandedProperty !== '@included' && _isKeyword(expandedProperty))) {
                        _context.next = 97;
                        break;
                      }

                      // use keyword alias and add value as is
                      _alias4 = api.compactIri({
                        activeCtx: activeCtx,
                        iri: expandedProperty,
                        relativeTo: {
                          vocab: true
                        }
                      });

                      _addValue(rval, _alias4, expandedValue);

                      return _context.abrupt("continue", 209);

                    case 97:
                      if (_isArray(expandedValue)) {
                        _context.next = 99;
                        break;
                      }

                      throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');

                    case 99:
                      // preserve empty arrays
                      if (expandedValue.length === 0) {
                        itemActiveProperty = api.compactIri({
                          activeCtx: activeCtx,
                          iri: expandedProperty,
                          value: expandedValue,
                          relativeTo: {
                            vocab: true
                          },
                          reverse: insideReverse
                        });
                        nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;
                        nestResult = rval;

                        if (nestProperty) {
                          _checkNestProperty(activeCtx, nestProperty, options);

                          if (!_isObject(rval[nestProperty])) {
                            rval[nestProperty] = {};
                          }

                          nestResult = rval[nestProperty];
                        }

                        _addValue(nestResult, itemActiveProperty, expandedValue, {
                          propertyIsArray: true
                        });
                      } // recusively process array values


                      _iterator3 = _createForOfIteratorHelper(expandedValue);
                      _context.prev = 101;

                      _iterator3.s();

                    case 103:
                      if ((_step3 = _iterator3.n()).done) {
                        _context.next = 201;
                        break;
                      }

                      expandedItem = _step3.value;
                      // compact property and get container type
                      _itemActiveProperty = api.compactIri({
                        activeCtx: activeCtx,
                        iri: expandedProperty,
                        value: expandedItem,
                        relativeTo: {
                          vocab: true
                        },
                        reverse: insideReverse
                      }); // if itemActiveProperty is a @nest property, add values to nestResult,
                      // otherwise rval

                      _nestProperty = activeCtx.mappings.has(_itemActiveProperty) ? activeCtx.mappings.get(_itemActiveProperty)['@nest'] : null;
                      _nestResult = rval;

                      if (_nestProperty) {
                        _checkNestProperty(activeCtx, _nestProperty, options);

                        if (!_isObject(rval[_nestProperty])) {
                          rval[_nestProperty] = {};
                        }

                        _nestResult = rval[_nestProperty];
                      }

                      _container5 = _getContextValue(activeCtx, _itemActiveProperty, '@container') || []; // get simple @graph or @list value if appropriate

                      isGraph = _isGraph(expandedItem);
                      isList = _isList(expandedItem);
                      inner = void 0;

                      if (isList) {
                        inner = expandedItem['@list'];
                      } else if (isGraph) {
                        inner = expandedItem['@graph'];
                      } // recursively compact expanded item


                      _context.next = 116;
                      return api.compact({
                        activeCtx: activeCtx,
                        activeProperty: _itemActiveProperty,
                        element: isList || isGraph ? inner : expandedItem,
                        options: options,
                        compactionMap: compactionMap
                      });

                    case 116:
                      compactedItem = _context.sent;

                      if (!isList) {
                        _context.next = 126;
                        break;
                      }

                      // ensure @list value is an array
                      if (!_isArray(compactedItem)) {
                        compactedItem = [compactedItem];
                      }

                      if (_container5.includes('@list')) {
                        _context.next = 124;
                        break;
                      }

                      // wrap using @list alias
                      compactedItem = (0, _defineProperty2["default"])({}, api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@list',
                        relativeTo: {
                          vocab: true
                        }
                      }), compactedItem); // include @index from expanded @list, if any

                      if ('@index' in expandedItem) {
                        compactedItem[api.compactIri({
                          activeCtx: activeCtx,
                          iri: '@index',
                          relativeTo: {
                            vocab: true
                          }
                        })] = expandedItem['@index'];
                      }

                      _context.next = 126;
                      break;

                    case 124:
                      _addValue(_nestResult, _itemActiveProperty, compactedItem, {
                        valueIsArray: true,
                        allowDuplicate: true
                      });

                      return _context.abrupt("continue", 199);

                    case 126:
                      if (!isGraph) {
                        _context.next = 130;
                        break;
                      }

                      if (_container5.includes('@graph') && (_container5.includes('@id') || _container5.includes('@index') && _isSimpleGraph(expandedItem))) {
                        // get or create the map object
                        mapObject = void 0;

                        if (_nestResult.hasOwnProperty(_itemActiveProperty)) {
                          mapObject = _nestResult[_itemActiveProperty];
                        } else {
                          _nestResult[_itemActiveProperty] = mapObject = {};
                        } // index on @id or @index or alias of @none


                        key = (_container5.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({
                          activeCtx: activeCtx,
                          iri: '@none',
                          relativeTo: {
                            vocab: true
                          }
                        }); // add compactedItem to map, using value of `@id` or a new blank
                        // node identifier

                        _addValue(mapObject, key, compactedItem, {
                          propertyIsArray: !options.compactArrays || _container5.includes('@set')
                        });
                      } else if (_container5.includes('@graph') && _isSimpleGraph(expandedItem)) {
                        // container includes @graph but not @id or @index and value is a
                        // simple graph object add compact value
                        // if compactedItem contains multiple values, it is wrapped in
                        // `@included`
                        if (_isArray(compactedItem) && compactedItem.length > 1) {
                          compactedItem = {
                            '@included': compactedItem
                          };
                        }

                        _addValue(_nestResult, _itemActiveProperty, compactedItem, {
                          propertyIsArray: !options.compactArrays || _container5.includes('@set')
                        });
                      } else {
                        // wrap using @graph alias, remove array if only one item and
                        // compactArrays not set
                        if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {
                          compactedItem = compactedItem[0];
                        }

                        compactedItem = (0, _defineProperty2["default"])({}, api.compactIri({
                          activeCtx: activeCtx,
                          iri: '@graph',
                          relativeTo: {
                            vocab: true
                          }
                        }), compactedItem); // include @id from expanded graph, if any

                        if ('@id' in expandedItem) {
                          compactedItem[api.compactIri({
                            activeCtx: activeCtx,
                            iri: '@id',
                            relativeTo: {
                              vocab: true
                            }
                          })] = expandedItem['@id'];
                        } // include @index from expanded graph, if any


                        if ('@index' in expandedItem) {
                          compactedItem[api.compactIri({
                            activeCtx: activeCtx,
                            iri: '@index',
                            relativeTo: {
                              vocab: true
                            }
                          })] = expandedItem['@index'];
                        }

                        _addValue(_nestResult, _itemActiveProperty, compactedItem, {
                          propertyIsArray: !options.compactArrays || _container5.includes('@set')
                        });
                      }

                      _context.next = 199;
                      break;

                    case 130:
                      if (!(_container5.includes('@language') || _container5.includes('@index') || _container5.includes('@id') || _container5.includes('@type'))) {
                        _context.next = 197;
                        break;
                      }

                      // handle language and index maps
                      // get or create the map object
                      _mapObject = void 0;

                      if (_nestResult.hasOwnProperty(_itemActiveProperty)) {
                        _mapObject = _nestResult[_itemActiveProperty];
                      } else {
                        _nestResult[_itemActiveProperty] = _mapObject = {};
                      }

                      _key = void 0;

                      if (!_container5.includes('@language')) {
                        _context.next = 139;
                        break;
                      }

                      // if container is a language map, simplify compacted value to
                      // a simple string
                      if (_isValue(compactedItem)) {
                        compactedItem = compactedItem['@value'];
                      }

                      _key = expandedItem['@language'];
                      _context.next = 193;
                      break;

                    case 139:
                      if (!_container5.includes('@index')) {
                        _context.next = 167;
                        break;
                      }

                      indexKey = _getContextValue(activeCtx, _itemActiveProperty, '@index') || '@index';
                      containerKey = api.compactIri({
                        activeCtx: activeCtx,
                        iri: indexKey,
                        relativeTo: {
                          vocab: true
                        }
                      });

                      if (!(indexKey === '@index')) {
                        _context.next = 147;
                        break;
                      }

                      _key = expandedItem['@index'];
                      delete compactedItem[containerKey];
                      _context.next = 165;
                      break;

                    case 147:
                      others = void 0;
                      _asArray2 = _asArray(compactedItem[indexKey] || []);
                      _asArray3 = (0, _toArray2["default"])(_asArray2);
                      _key = _asArray3[0];
                      others = _asArray3.slice(1);

                      if (_isString(_key)) {
                        _context.next = 156;
                        break;
                      }

                      // Will use @none if it isn't a string.
                      _key = null;
                      _context.next = 165;
                      break;

                    case 156:
                      _context.t1 = others.length;
                      _context.next = _context.t1 === 0 ? 159 : _context.t1 === 1 ? 161 : 163;
                      break;

                    case 159:
                      delete compactedItem[indexKey];
                      return _context.abrupt("break", 165);

                    case 161:
                      compactedItem[indexKey] = others[0];
                      return _context.abrupt("break", 165);

                    case 163:
                      compactedItem[indexKey] = others;
                      return _context.abrupt("break", 165);

                    case 165:
                      _context.next = 193;
                      break;

                    case 167:
                      if (!_container5.includes('@id')) {
                        _context.next = 173;
                        break;
                      }

                      idKey = api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@id',
                        relativeTo: {
                          vocab: true
                        }
                      });
                      _key = compactedItem[idKey];
                      delete compactedItem[idKey];
                      _context.next = 193;
                      break;

                    case 173:
                      if (!_container5.includes('@type')) {
                        _context.next = 193;
                        break;
                      }

                      typeKey = api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@type',
                        relativeTo: {
                          vocab: true
                        }
                      });
                      _types = void 0;
                      _asArray4 = _asArray(compactedItem[typeKey] || []);
                      _asArray5 = (0, _toArray2["default"])(_asArray4);
                      _key = _asArray5[0];
                      _types = _asArray5.slice(1);
                      _context.t2 = _types.length;
                      _context.next = _context.t2 === 0 ? 183 : _context.t2 === 1 ? 185 : 187;
                      break;

                    case 183:
                      delete compactedItem[typeKey];
                      return _context.abrupt("break", 189);

                    case 185:
                      compactedItem[typeKey] = _types[0];
                      return _context.abrupt("break", 189);

                    case 187:
                      compactedItem[typeKey] = _types;
                      return _context.abrupt("break", 189);

                    case 189:
                      if (!(Object.keys(compactedItem).length === 1 && '@id' in expandedItem)) {
                        _context.next = 193;
                        break;
                      }

                      _context.next = 192;
                      return api.compact({
                        activeCtx: activeCtx,
                        activeProperty: _itemActiveProperty,
                        element: {
                          '@id': expandedItem['@id']
                        },
                        options: options,
                        compactionMap: compactionMap
                      });

                    case 192:
                      compactedItem = _context.sent;

                    case 193:
                      // if compacting this value which has no key, index on @none
                      if (!_key) {
                        _key = api.compactIri({
                          activeCtx: activeCtx,
                          iri: '@none',
                          relativeTo: {
                            vocab: true
                          }
                        });
                      } // add compact value to map object using key from expanded value
                      // based on the container type


                      _addValue(_mapObject, _key, compactedItem, {
                        propertyIsArray: _container5.includes('@set')
                      });

                      _context.next = 199;
                      break;

                    case 197:
                      // use an array if: compactArrays flag is false,
                      // @container is @set or @list , value is an empty
                      // array, or key is @graph
                      _isArray2 = !options.compactArrays || _container5.includes('@set') || _container5.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph'; // add compact value

                      _addValue(_nestResult, _itemActiveProperty, compactedItem, {
                        propertyIsArray: _isArray2
                      });

                    case 199:
                      _context.next = 103;
                      break;

                    case 201:
                      _context.next = 206;
                      break;

                    case 203:
                      _context.prev = 203;
                      _context.t3 = _context["catch"](101);

                      _iterator3.e(_context.t3);

                    case 206:
                      _context.prev = 206;

                      _iterator3.f();

                      return _context.finish(206);

                    case 209:
                      _context.next = 55;
                      break;

                    case 211:
                      _context.next = 216;
                      break;

                    case 213:
                      _context.prev = 213;
                      _context.t4 = _context["catch"](53);

                      _iterator2.e(_context.t4);

                    case 216:
                      _context.prev = 216;

                      _iterator2.f();

                      return _context.finish(216);

                    case 219:
                      return _context.abrupt("return", {
                        v: rval
                      });

                    case 220:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, null, [[31, 45, 48, 51], [53, 213, 216, 219], [101, 203, 206, 209]]);
            })(), "t0", 27);

          case 27:
            _ret = _context2.t0;

            if (!((0, _typeof2["default"])(_ret) === "object")) {
              _context2.next = 30;
              break;
            }

            return _context2.abrupt("return", _ret.v);

          case 30:
            return _context2.abrupt("return", element);

          case 31:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Compacts an IRI or keyword into a term or prefix if it can be. If the
 * IRI has an associated value it may be passed.
 *
 * @param activeCtx the active context to use.
 * @param iri the IRI to compact.
 * @param value the value to check or null.
 * @param relativeTo options for how to compact IRIs:
 *          vocab: true to split after @vocab, false not to.
 * @param reverse true if a reverse property is being compacted, false if not.
 * @param base the absolute URL to use for compacting document-relative IRIs.
 *
 * @return the compacted term, prefix, keyword alias, or the original IRI.
 */


api.compactIri = function (_ref3) {
  var activeCtx = _ref3.activeCtx,
      iri = _ref3.iri,
      _ref3$value = _ref3.value,
      value = _ref3$value === void 0 ? null : _ref3$value,
      _ref3$relativeTo = _ref3.relativeTo,
      relativeTo = _ref3$relativeTo === void 0 ? {
    vocab: false
  } : _ref3$relativeTo,
      _ref3$reverse = _ref3.reverse,
      reverse = _ref3$reverse === void 0 ? false : _ref3$reverse,
      _ref3$base = _ref3.base,
      base = _ref3$base === void 0 ? null : _ref3$base;

  // can't compact null
  if (iri === null) {
    return iri;
  } // if context is from a property term scoped context composed with a
  // type-scoped context, then use the previous context instead


  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {
    activeCtx = activeCtx.previousContext;
  }

  var inverseCtx = activeCtx.getInverse(); // if term is a keyword, it may be compacted to a simple alias

  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {
    return inverseCtx[iri]['@none']['@type']['@none'];
  } // use inverse context to pick a term if iri is relative to vocab


  if (relativeTo.vocab && iri in inverseCtx) {
    var defaultLanguage = activeCtx['@language'] || '@none'; // prefer @index if available in value

    var containers = [];

    if (_isObject(value) && '@index' in value && !('@graph' in value)) {
      containers.push('@index', '@index@set');
    } // if value is a preserve object, use its value


    if (_isObject(value) && '@preserve' in value) {
      value = value['@preserve'][0];
    } // prefer most specific container including @graph, prefering @set
    // variations


    if (_isGraph(value)) {
      // favor indexmap if the graph is indexed
      if ('@index' in value) {
        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');
      } // favor idmap if the graph is has an @id


      if ('@id' in value) {
        containers.push('@graph@id', '@graph@id@set');
      }

      containers.push('@graph', '@graph@set', '@set'); // allow indexmap if the graph is not indexed

      if (!('@index' in value)) {
        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');
      } // allow idmap if the graph does not have an @id


      if (!('@id' in value)) {
        containers.push('@graph@id', '@graph@id@set');
      }
    } else if (_isObject(value) && !_isValue(value)) {
      containers.push('@id', '@id@set', '@type', '@set@type');
    } // defaults for term selection based on type/language


    var typeOrLanguage = '@language';
    var typeOrLanguageValue = '@null';

    if (reverse) {
      typeOrLanguage = '@type';
      typeOrLanguageValue = '@reverse';
      containers.push('@set');
    } else if (_isList(value)) {
      // choose the most specific term that works for all elements in @list
      // only select @list containers if @index is NOT in value
      if (!('@index' in value)) {
        containers.push('@list');
      }

      var list = value['@list'];

      if (list.length === 0) {
        // any empty list can be matched against any term that uses the
        // @list container regardless of @type or @language
        typeOrLanguage = '@any';
        typeOrLanguageValue = '@none';
      } else {
        var commonLanguage = list.length === 0 ? defaultLanguage : null;
        var commonType = null;

        for (var i = 0; i < list.length; ++i) {
          var item = list[i];
          var itemLanguage = '@none';
          var itemType = '@none';

          if (_isValue(item)) {
            if ('@direction' in item) {
              var lang = (item['@language'] || '').toLowerCase();
              var dir = item['@direction'];
              itemLanguage = "".concat(lang, "_").concat(dir);
            } else if ('@language' in item) {
              itemLanguage = item['@language'].toLowerCase();
            } else if ('@type' in item) {
              itemType = item['@type'];
            } else {
              // plain literal
              itemLanguage = '@null';
            }
          } else {
            itemType = '@id';
          }

          if (commonLanguage === null) {
            commonLanguage = itemLanguage;
          } else if (itemLanguage !== commonLanguage && _isValue(item)) {
            commonLanguage = '@none';
          }

          if (commonType === null) {
            commonType = itemType;
          } else if (itemType !== commonType) {
            commonType = '@none';
          } // there are different languages and types in the list, so choose
          // the most generic term, no need to keep iterating the list


          if (commonLanguage === '@none' && commonType === '@none') {
            break;
          }
        }

        commonLanguage = commonLanguage || '@none';
        commonType = commonType || '@none';

        if (commonType !== '@none') {
          typeOrLanguage = '@type';
          typeOrLanguageValue = commonType;
        } else {
          typeOrLanguageValue = commonLanguage;
        }
      }
    } else {
      if (_isValue(value)) {
        if ('@language' in value && !('@index' in value)) {
          containers.push('@language', '@language@set');
          typeOrLanguageValue = value['@language'];
          var _dir = value['@direction'];

          if (_dir) {
            typeOrLanguageValue = "".concat(typeOrLanguageValue, "_").concat(_dir);
          }
        } else if ('@direction' in value && !('@index' in value)) {
          typeOrLanguageValue = "_".concat(value['@direction']);
        } else if ('@type' in value) {
          typeOrLanguage = '@type';
          typeOrLanguageValue = value['@type'];
        }
      } else {
        typeOrLanguage = '@type';
        typeOrLanguageValue = '@id';
      }

      containers.push('@set');
    } // do term selection


    containers.push('@none'); // an index map can be used to index values using @none, so add as a low
    // priority

    if (_isObject(value) && !('@index' in value)) {
      // allow indexing even if no @index present
      containers.push('@index', '@index@set');
    } // values without type or language can use @language map


    if (_isValue(value) && Object.keys(value).length === 1) {
      // allow indexing even if no @index present
      containers.push('@language', '@language@set');
    }

    var term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);

    if (term !== null) {
      return term;
    }
  } // no term match, use @vocab if available


  if (relativeTo.vocab) {
    if ('@vocab' in activeCtx) {
      // determine if vocab is a prefix of the iri
      var vocab = activeCtx['@vocab'];

      if (iri.indexOf(vocab) === 0 && iri !== vocab) {
        // use suffix as relative iri if it is not a term in the active context
        var suffix = iri.substr(vocab.length);

        if (!activeCtx.mappings.has(suffix)) {
          return suffix;
        }
      }
    }
  } // no term or @vocab match, check for possible CURIEs


  var choice = null; // TODO: make FastCurieMap a class with a method to do this lookup

  var partialMatches = [];
  var iriMap = activeCtx.fastCurieMap; // check for partial matches of against `iri`, which means look until
  // iri.length - 1, not full length

  var maxPartialLength = iri.length - 1;

  for (var _i2 = 0; _i2 < maxPartialLength && iri[_i2] in iriMap; ++_i2) {
    iriMap = iriMap[iri[_i2]];

    if ('' in iriMap) {
      partialMatches.push(iriMap[''][0]);
    }
  } // check partial matches in reverse order to prefer longest ones first


  for (var _i3 = partialMatches.length - 1; _i3 >= 0; --_i3) {
    var entry = partialMatches[_i3];
    var terms = entry.terms;

    var _iterator4 = _createForOfIteratorHelper(terms),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _term = _step4.value;
        // a CURIE is usable if:
        // 1. it has no mapping, OR
        // 2. value is null, which means we're not compacting an @value, AND
        //   the mapping matches the IRI
        var curie = _term + ':' + iri.substr(entry.iri.length);
        var isUsableCurie = activeCtx.mappings.get(_term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri); // select curie if it is shorter or the same length but lexicographically
        // less than the current choice

        if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {
          choice = curie;
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  } // return chosen curie


  if (choice !== null) {
    return choice;
  } // If iri could be confused with a compact IRI using a term in this context,
  // signal an error


  var _iterator5 = _createForOfIteratorHelper(activeCtx.mappings),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _step5$value = (0, _slicedToArray2["default"])(_step5.value, 2),
          _term2 = _step5$value[0],
          td = _step5$value[1];

      if (td && td._prefix && iri.startsWith(_term2 + ':')) {
        throw new JsonLdError("Absolute IRI \"".concat(iri, "\" confused with prefix \"").concat(_term2, "\"."), 'jsonld.SyntaxError', {
          code: 'IRI confused with prefix',
          context: activeCtx
        });
      }
    } // compact IRI relative to base

  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  if (!relativeTo.vocab) {
    if ('@base' in activeCtx) {
      if (!activeCtx['@base']) {
        // The None case preserves rval as potentially relative
        return iri;
      } else {
        return _removeBase(_prependBase(base, activeCtx['@base']), iri);
      }
    } else {
      return _removeBase(base, iri);
    }
  } // return IRI as is


  return iri;
};
/**
 * Performs value compaction on an object with '@value' or '@id' as the only
 * property.
 *
 * @param activeCtx the active context.
 * @param activeProperty the active property that points to the value.
 * @param value the value to compact.
 * @param {Object} [options] - processing options.
 *
 * @return the compaction result.
 */


api.compactValue = function (_ref4) {
  var activeCtx = _ref4.activeCtx,
      activeProperty = _ref4.activeProperty,
      value = _ref4.value,
      options = _ref4.options;

  // value is a @value
  if (_isValue(value)) {
    // get context rules
    var _type = _getContextValue(activeCtx, activeProperty, '@type');

    var language = _getContextValue(activeCtx, activeProperty, '@language');

    var direction = _getContextValue(activeCtx, activeProperty, '@direction');

    var container = _getContextValue(activeCtx, activeProperty, '@container') || []; // whether or not the value has an @index that must be preserved

    var preserveIndex = '@index' in value && !container.includes('@index'); // if there's no @index to preserve ...

    if (!preserveIndex && _type !== '@none') {
      // matching @type or @language specified in context, compact value
      if (value['@type'] === _type) {
        return value['@value'];
      }

      if ('@language' in value && value['@language'] === language && '@direction' in value && value['@direction'] === direction) {
        return value['@value'];
      }

      if ('@language' in value && value['@language'] === language) {
        return value['@value'];
      }

      if ('@direction' in value && value['@direction'] === direction) {
        return value['@value'];
      }
    } // return just the value of @value if all are true:
    // 1. @value is the only key or @index isn't being preserved
    // 2. there is no default language or @value is not a string or
    //   the key has a mapping with a null @language


    var keyCount = Object.keys(value).length;
    var isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;
    var hasDefaultLanguage = ('@language' in activeCtx);

    var isValueString = _isString(value['@value']);

    var hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;

    if (isValueOnlyKey && _type !== '@none' && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {
      return value['@value'];
    }

    var rval = {}; // preserve @index

    if (preserveIndex) {
      rval[api.compactIri({
        activeCtx: activeCtx,
        iri: '@index',
        relativeTo: {
          vocab: true
        }
      })] = value['@index'];
    }

    if ('@type' in value) {
      // compact @type IRI
      rval[api.compactIri({
        activeCtx: activeCtx,
        iri: '@type',
        relativeTo: {
          vocab: true
        }
      })] = api.compactIri({
        activeCtx: activeCtx,
        iri: value['@type'],
        relativeTo: {
          vocab: true
        }
      });
    } else if ('@language' in value) {
      // alias @language
      rval[api.compactIri({
        activeCtx: activeCtx,
        iri: '@language',
        relativeTo: {
          vocab: true
        }
      })] = value['@language'];
    }

    if ('@direction' in value) {
      // alias @direction
      rval[api.compactIri({
        activeCtx: activeCtx,
        iri: '@direction',
        relativeTo: {
          vocab: true
        }
      })] = value['@direction'];
    } // alias @value


    rval[api.compactIri({
      activeCtx: activeCtx,
      iri: '@value',
      relativeTo: {
        vocab: true
      }
    })] = value['@value'];
    return rval;
  } // value is a subject reference


  var expandedProperty = _expandIri(activeCtx, activeProperty, {
    vocab: true
  }, options);

  var type = _getContextValue(activeCtx, activeProperty, '@type');

  var compacted = api.compactIri({
    activeCtx: activeCtx,
    iri: value['@id'],
    relativeTo: {
      vocab: type === '@vocab'
    },
    base: options.base
  }); // compact to scalar

  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {
    return compacted;
  }

  return (0, _defineProperty2["default"])({}, api.compactIri({
    activeCtx: activeCtx,
    iri: '@id',
    relativeTo: {
      vocab: true
    }
  }), compacted);
};
/**
 * Picks the preferred compaction term from the given inverse context entry.
 *
 * @param activeCtx the active context.
 * @param iri the IRI to pick the term for.
 * @param value the value to pick the term for.
 * @param containers the preferred containers.
 * @param typeOrLanguage either '@type' or '@language'.
 * @param typeOrLanguageValue the preferred value for '@type' or '@language'.
 *
 * @return the preferred term.
 */


function _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
  if (typeOrLanguageValue === null) {
    typeOrLanguageValue = '@null';
  } // preferences for the value of @type or @language


  var prefs = []; // determine prefs for @id based on whether or not value compacts to a term

  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isObject(value) && '@id' in value) {
    // prefer @reverse first
    if (typeOrLanguageValue === '@reverse') {
      prefs.push('@reverse');
    } // try to compact value to a term


    var term = api.compactIri({
      activeCtx: activeCtx,
      iri: value['@id'],
      relativeTo: {
        vocab: true
      }
    });

    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {
      // prefer @vocab
      prefs.push.apply(prefs, ['@vocab', '@id']);
    } else {
      // prefer @id
      prefs.push.apply(prefs, ['@id', '@vocab']);
    }
  } else {
    prefs.push(typeOrLanguageValue); // consider direction only

    var langDir = prefs.find(function (el) {
      return el.includes('_');
    });

    if (langDir) {
      // consider _dir portion
      prefs.push(langDir.replace(/^[^_]+_/, '_'));
    }
  }

  prefs.push('@none');
  var containerMap = activeCtx.inverse[iri];

  var _iterator6 = _createForOfIteratorHelper(containers),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var container = _step6.value;

      // if container not available in the map, continue
      if (!(container in containerMap)) {
        continue;
      }

      var typeOrLanguageValueMap = containerMap[container][typeOrLanguage];

      var _iterator7 = _createForOfIteratorHelper(prefs),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var pref = _step7.value;

          // if type/language option not available in the map, continue
          if (!(pref in typeOrLanguageValueMap)) {
            continue;
          } // select term


          return typeOrLanguageValueMap[pref];
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return null;
}
/**
 * The value of `@nest` in the term definition must either be `@nest`, or a term
 * which resolves to `@nest`.
 *
 * @param activeCtx the active context.
 * @param nestProperty a term in the active context or `@nest`.
 * @param {Object} [options] - processing options.
 */


function _checkNestProperty(activeCtx, nestProperty, options) {
  if (_expandIri(activeCtx, nestProperty, {
    vocab: true
  }, options) !== '@nest') {
    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {
      code: 'invalid @nest value'
    });
  }
}

},{"./JsonLdError":91,"./context":99,"./graphTypes":106,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/defineProperty":10,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/toArray":25,"@babel/runtime/helpers/typeof":27,"@babel/runtime/regenerator":30}],98:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
var XSD = 'http://www.w3.org/2001/XMLSchema#';
module.exports = {
  // TODO: Deprecated and will be removed later. Use LINK_HEADER_CONTEXT.
  LINK_HEADER_REL: 'http://www.w3.org/ns/json-ld#context',
  LINK_HEADER_CONTEXT: 'http://www.w3.org/ns/json-ld#context',
  RDF: RDF,
  RDF_LIST: RDF + 'List',
  RDF_FIRST: RDF + 'first',
  RDF_REST: RDF + 'rest',
  RDF_NIL: RDF + 'nil',
  RDF_TYPE: RDF + 'type',
  RDF_PLAIN_LITERAL: RDF + 'PlainLiteral',
  RDF_XML_LITERAL: RDF + 'XMLLiteral',
  RDF_JSON_LITERAL: RDF + 'JSON',
  RDF_OBJECT: RDF + 'object',
  RDF_LANGSTRING: RDF + 'langString',
  XSD: XSD,
  XSD_BOOLEAN: XSD + 'boolean',
  XSD_DOUBLE: XSD + 'double',
  XSD_INTEGER: XSD + 'integer',
  XSD_STRING: XSD + 'string'
};

},{}],99:[function(require,module,exports){
/*
 * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var util = require('./util');

var JsonLdError = require('./JsonLdError');

var _require = require('./types'),
    _isArray = _require.isArray,
    _isObject = _require.isObject,
    _isString = _require.isString,
    _isUndefined = _require.isUndefined;

var _require2 = require('./url'),
    _isAbsoluteIri = _require2.isAbsolute,
    _isRelativeIri = _require2.isRelative,
    prependBase = _require2.prependBase,
    parseUrl = _require2.parse;

var _require3 = require('./util'),
    _asArray = _require3.asArray,
    _compareShortestLeast = _require3.compareShortestLeast;

var INITIAL_CONTEXT_CACHE = new Map();
var INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;
var KEYWORD_PATTERN = /^@[a-zA-Z]+$/;
var api = {};
module.exports = api;
/**
 * Processes a local context and returns a new active context.
 *
 * @param activeCtx the current active context.
 * @param localCtx the local context to process.
 * @param options the context processing options.
 * @param propagate `true` if `false`, retains any previously defined term,
 *   which can be rolled back when the descending into a new node object.
 * @param overrideProtected `false` allows protected terms to be modified.
 *
 * @return a Promise that resolves to the new active context.
 */

api.process = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref) {
    var activeCtx, localCtx, options, _ref$propagate, propagate, _ref$overrideProtecte, overrideProtected, _ref$cycles, cycles, ctxs, resolved, rval, _iterator, _step, resolvedContext, ctx, protectedMode, _processed, oldActiveCtx, _i, _Object$entries, _Object$entries$_i, term, _protected, processed, defined, base, value, _value, _value2, _value3, _value4, resolvedImport, processedImport, importCtx, key, _key, keyCtx, process, url;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            activeCtx = _ref.activeCtx, localCtx = _ref.localCtx, options = _ref.options, _ref$propagate = _ref.propagate, propagate = _ref$propagate === void 0 ? true : _ref$propagate, _ref$overrideProtecte = _ref.overrideProtected, overrideProtected = _ref$overrideProtecte === void 0 ? false : _ref$overrideProtecte, _ref$cycles = _ref.cycles, cycles = _ref$cycles === void 0 ? new Set() : _ref$cycles;

            // normalize local context to an array of @context objects
            if (_isObject(localCtx) && '@context' in localCtx && _isArray(localCtx['@context'])) {
              localCtx = localCtx['@context'];
            }

            ctxs = _asArray(localCtx); // no contexts in array, return current active context w/o changes

            if (!(ctxs.length === 0)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", activeCtx);

          case 5:
            _context.next = 7;
            return options.contextResolver.resolve({
              activeCtx: activeCtx,
              context: localCtx,
              documentLoader: options.documentLoader,
              base: options.base
            });

          case 7:
            resolved = _context.sent;

            // override propagate if first resolved context has `@propagate`
            if (_isObject(resolved[0].document) && typeof resolved[0].document['@propagate'] === 'boolean') {
              // retrieve early, error checking done later
              propagate = resolved[0].document['@propagate'];
            } // process each context in order, update active context
            // on each iteration to ensure proper caching


            rval = activeCtx; // track the previous context
            // if not propagating, make sure rval has a previous context

            if (!propagate && !rval.previousContext) {
              // clone `rval` context before updating
              rval = rval.clone();
              rval.previousContext = activeCtx;
            }

            _iterator = _createForOfIteratorHelper(resolved);
            _context.prev = 12;

            _iterator.s();

          case 14:
            if ((_step = _iterator.n()).done) {
              _context.next = 164;
              break;
            }

            resolvedContext = _step.value;
            ctx = resolvedContext.document; // update active context to one computed from last iteration

            activeCtx = rval; // reset to initial context

            if (!(ctx === null)) {
              _context.next = 40;
              break;
            }

            if (!(!overrideProtected && Object.keys(activeCtx["protected"]).length !== 0)) {
              _context.next = 38;
              break;
            }

            protectedMode = options && options.protectedMode || 'error';

            if (!(protectedMode === 'error')) {
              _context.next = 25;
              break;
            }

            throw new JsonLdError('Tried to nullify a context with protected terms outside of ' + 'a term definition.', 'jsonld.SyntaxError', {
              code: 'invalid context nullification'
            });

          case 25:
            if (!(protectedMode === 'warn')) {
              _context.next = 37;
              break;
            }

            // FIXME: remove logging and use a handler
            console.warn('WARNING: invalid context nullification'); // get processed context from cache if available

            _processed = resolvedContext.getProcessed(activeCtx);

            if (!_processed) {
              _context.next = 31;
              break;
            }

            rval = activeCtx = _processed;
            return _context.abrupt("continue", 162);

          case 31:
            oldActiveCtx = activeCtx; // copy all protected term definitions to fresh initial context

            rval = activeCtx = api.getInitialContext(options).clone();

            for (_i = 0, _Object$entries = Object.entries(oldActiveCtx["protected"]); _i < _Object$entries.length; _i++) {
              _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2), term = _Object$entries$_i[0], _protected = _Object$entries$_i[1];

              if (_protected) {
                activeCtx.mappings[term] = util.clone(oldActiveCtx.mappings[term]);
              }
            }

            activeCtx["protected"] = util.clone(oldActiveCtx["protected"]); // cache processed result

            resolvedContext.setProcessed(oldActiveCtx, rval);
            return _context.abrupt("continue", 162);

          case 37:
            throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {
              code: 'invalid protected mode',
              context: localCtx,
              protectedMode: protectedMode
            });

          case 38:
            rval = activeCtx = api.getInitialContext(options).clone();
            return _context.abrupt("continue", 162);

          case 40:
            // get processed context from cache if available
            processed = resolvedContext.getProcessed(activeCtx);

            if (!processed) {
              _context.next = 44;
              break;
            }

            rval = activeCtx = processed;
            return _context.abrupt("continue", 162);

          case 44:
            // dereference @context key if present
            if (_isObject(ctx) && '@context' in ctx) {
              ctx = ctx['@context'];
            } // context must be an object by now, all URLs retrieved before this call


            if (_isObject(ctx)) {
              _context.next = 47;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {
              code: 'invalid local context',
              context: ctx
            });

          case 47:
            // TODO: there is likely a `previousContext` cloning optimization that
            // could be applied here (no need to copy it under certain conditions)
            // clone context before updating it
            rval = rval.clone(); // define context mappings for keys in local context

            defined = new Map(); // handle @version

            if (!('@version' in ctx)) {
              _context.next = 57;
              break;
            }

            if (!(ctx['@version'] !== 1.1)) {
              _context.next = 52;
              break;
            }

            throw new JsonLdError('Unsupported JSON-LD version: ' + ctx['@version'], 'jsonld.UnsupportedVersion', {
              code: 'invalid @version value',
              context: ctx
            });

          case 52:
            if (!(activeCtx.processingMode && activeCtx.processingMode === 'json-ld-1.0')) {
              _context.next = 54;
              break;
            }

            throw new JsonLdError('@version: ' + ctx['@version'] + ' not compatible with ' + activeCtx.processingMode, 'jsonld.ProcessingModeConflict', {
              code: 'processing mode conflict',
              context: ctx
            });

          case 54:
            rval.processingMode = 'json-ld-1.1';
            rval['@version'] = ctx['@version'];
            defined.set('@version', true);

          case 57:
            // if not set explicitly, set processingMode to "json-ld-1.1"
            rval.processingMode = rval.processingMode || activeCtx.processingMode; // handle @base

            if (!('@base' in ctx)) {
              _context.next = 70;
              break;
            }

            base = ctx['@base'];

            if (!(base === null || _isAbsoluteIri(base))) {
              _context.next = 63;
              break;
            }

            _context.next = 68;
            break;

          case 63:
            if (!_isRelativeIri(base)) {
              _context.next = 67;
              break;
            }

            base = prependBase(rval['@base'], base);
            _context.next = 68;
            break;

          case 67:
            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@base" in a ' + '@context must be an absolute IRI, a relative IRI, or null.', 'jsonld.SyntaxError', {
              code: 'invalid base IRI',
              context: ctx
            });

          case 68:
            rval['@base'] = base;
            defined.set('@base', true);

          case 70:
            if (!('@vocab' in ctx)) {
              _context.next = 86;
              break;
            }

            value = ctx['@vocab'];

            if (!(value === null)) {
              _context.next = 76;
              break;
            }

            delete rval['@vocab'];
            _context.next = 85;
            break;

          case 76:
            if (_isString(value)) {
              _context.next = 80;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {
              code: 'invalid vocab mapping',
              context: ctx
            });

          case 80:
            if (!(!_isAbsoluteIri(value) && api.processingMode(rval, 1.0))) {
              _context.next = 84;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a ' + '@context must be an absolute IRI.', 'jsonld.SyntaxError', {
              code: 'invalid vocab mapping',
              context: ctx
            });

          case 84:
            rval['@vocab'] = _expandIri(rval, value, {
              vocab: true,
              base: true
            }, undefined, undefined, options);

          case 85:
            defined.set('@vocab', true);

          case 86:
            if (!('@language' in ctx)) {
              _context.next = 98;
              break;
            }

            _value = ctx['@language'];

            if (!(_value === null)) {
              _context.next = 92;
              break;
            }

            delete rval['@language'];
            _context.next = 97;
            break;

          case 92:
            if (_isString(_value)) {
              _context.next = 96;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@language" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {
              code: 'invalid default language',
              context: ctx
            });

          case 96:
            rval['@language'] = _value.toLowerCase();

          case 97:
            defined.set('@language', true);

          case 98:
            if (!('@direction' in ctx)) {
              _context.next = 112;
              break;
            }

            _value2 = ctx['@direction'];

            if (!(activeCtx.processingMode === 'json-ld-1.0')) {
              _context.next = 102;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @direction not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {
              code: 'invalid context member',
              context: ctx
            });

          case 102:
            if (!(_value2 === null)) {
              _context.next = 106;
              break;
            }

            delete rval['@direction'];
            _context.next = 111;
            break;

          case 106:
            if (!(_value2 !== 'ltr' && _value2 !== 'rtl')) {
              _context.next = 110;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@direction" in a ' + '@context must be null, "ltr", or "rtl".', 'jsonld.SyntaxError', {
              code: 'invalid base direction',
              context: ctx
            });

          case 110:
            rval['@direction'] = _value2;

          case 111:
            defined.set('@direction', true);

          case 112:
            if (!('@propagate' in ctx)) {
              _context.next = 119;
              break;
            }

            _value3 = ctx['@propagate'];

            if (!(activeCtx.processingMode === 'json-ld-1.0')) {
              _context.next = 116;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @propagate not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {
              code: 'invalid context entry',
              context: ctx
            });

          case 116:
            if (!(typeof _value3 !== 'boolean')) {
              _context.next = 118;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @propagate value must be a boolean.', 'jsonld.SyntaxError', {
              code: 'invalid @propagate value',
              context: localCtx
            });

          case 118:
            defined.set('@propagate', true);

          case 119:
            if (!('@import' in ctx)) {
              _context.next = 141;
              break;
            }

            _value4 = ctx['@import'];

            if (!(activeCtx.processingMode === 'json-ld-1.0')) {
              _context.next = 123;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @import not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {
              code: 'invalid context entry',
              context: ctx
            });

          case 123:
            if (_isString(_value4)) {
              _context.next = 125;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @import must be a string.', 'jsonld.SyntaxError', {
              code: 'invalid @import value',
              context: localCtx
            });

          case 125:
            _context.next = 127;
            return options.contextResolver.resolve({
              activeCtx: activeCtx,
              context: _value4,
              documentLoader: options.documentLoader,
              base: options.base
            });

          case 127:
            resolvedImport = _context.sent;

            if (!(resolvedImport.length !== 1)) {
              _context.next = 130;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @import must reference a single context.', 'jsonld.SyntaxError', {
              code: 'invalid remote context',
              context: localCtx
            });

          case 130:
            processedImport = resolvedImport[0].getProcessed(activeCtx);

            if (!processedImport) {
              _context.next = 135;
              break;
            }

            // Note: if the same context were used in this active context
            // as a reference context, then processed_input might not
            // be a dict.
            ctx = processedImport;
            _context.next = 140;
            break;

          case 135:
            importCtx = resolvedImport[0].document;

            if (!('@import' in importCtx)) {
              _context.next = 138;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax: ' + 'imported context must not include @import.', 'jsonld.SyntaxError', {
              code: 'invalid context entry',
              context: localCtx
            });

          case 138:
            // merge ctx into importCtx and replace rval with the result
            for (key in importCtx) {
              if (!ctx.hasOwnProperty(key)) {
                ctx[key] = importCtx[key];
              }
            } // Note: this could potenially conflict if the import
            // were used in the same active context as a referenced
            // context and an import. In this case, we
            // could override the cached result, but seems unlikely.


            resolvedImport[0].setProcessed(activeCtx, ctx);

          case 140:
            defined.set('@import', true);

          case 141:
            // handle @protected; determine whether this sub-context is declaring
            // all its terms to be "protected" (exceptions can be made on a
            // per-definition basis)
            defined.set('@protected', ctx['@protected'] || false); // process all other keys

            _context.t0 = _regenerator["default"].keys(ctx);

          case 143:
            if ((_context.t1 = _context.t0()).done) {
              _context.next = 161;
              break;
            }

            _key = _context.t1.value;
            api.createTermDefinition({
              activeCtx: rval,
              localCtx: ctx,
              term: _key,
              defined: defined,
              options: options,
              overrideProtected: overrideProtected
            });

            if (!(_isObject(ctx[_key]) && '@context' in ctx[_key])) {
              _context.next = 159;
              break;
            }

            keyCtx = ctx[_key]['@context'];
            process = true;

            if (_isString(keyCtx)) {
              url = prependBase(options.base, keyCtx); // track processed contexts to avoid scoped context recursion

              if (cycles.has(url)) {
                process = false;
              } else {
                cycles.add(url);
              }
            } // parse context to validate


            if (!process) {
              _context.next = 159;
              break;
            }

            _context.prev = 151;
            _context.next = 154;
            return api.process({
              activeCtx: rval.clone(),
              localCtx: ctx[_key]['@context'],
              overrideProtected: true,
              options: options,
              cycles: cycles
            });

          case 154:
            _context.next = 159;
            break;

          case 156:
            _context.prev = 156;
            _context.t2 = _context["catch"](151);
            throw new JsonLdError('Invalid JSON-LD syntax; invalid scoped context.', 'jsonld.SyntaxError', {
              code: 'invalid scoped context',
              context: ctx[_key]['@context'],
              term: _key
            });

          case 159:
            _context.next = 143;
            break;

          case 161:
            // cache processed result
            resolvedContext.setProcessed(activeCtx, rval);

          case 162:
            _context.next = 14;
            break;

          case 164:
            _context.next = 169;
            break;

          case 166:
            _context.prev = 166;
            _context.t3 = _context["catch"](12);

            _iterator.e(_context.t3);

          case 169:
            _context.prev = 169;

            _iterator.f();

            return _context.finish(169);

          case 172:
            return _context.abrupt("return", rval);

          case 173:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[12, 166, 169, 172], [151, 156]]);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Creates a term definition during context processing.
 *
 * @param activeCtx the current active context.
 * @param localCtx the local context being processed.
 * @param term the term in the local context to define the mapping for.
 * @param defined a map of defining/defined keys to detect cycles and prevent
 *          double definitions.
 * @param {Object} [options] - creation options.
 * @param {string} [options.protectedMode="error"] - "error" to throw error
 *   on `@protected` constraint violation, "warn" to allow violations and
 *   signal a warning.
 * @param overrideProtected `false` allows protected terms to be modified.
 */


api.createTermDefinition = function (_ref3) {
  var activeCtx = _ref3.activeCtx,
      localCtx = _ref3.localCtx,
      term = _ref3.term,
      defined = _ref3.defined,
      options = _ref3.options,
      _ref3$overrideProtect = _ref3.overrideProtected,
      overrideProtected = _ref3$overrideProtect === void 0 ? false : _ref3$overrideProtect;

  if (defined.has(term)) {
    // term already defined
    if (defined.get(term)) {
      return;
    } // cycle detected


    throw new JsonLdError('Cyclical context definition detected.', 'jsonld.CyclicalContext', {
      code: 'cyclic IRI mapping',
      context: localCtx,
      term: term
    });
  } // now defining term


  defined.set(term, false); // get context term value

  var value;

  if (localCtx.hasOwnProperty(term)) {
    value = localCtx[term];
  }

  if (term === '@type' && _isObject(value) && (value['@container'] || '@set') === '@set' && api.processingMode(activeCtx, 1.1)) {
    var _validKeys = ['@container', '@id', '@protected'];
    var keys = Object.keys(value);

    if (keys.length === 0 || keys.some(function (k) {
      return !_validKeys.includes(k);
    })) {
      throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {
        code: 'keyword redefinition',
        context: localCtx,
        term: term
      });
    }
  } else if (api.isKeyword(term)) {
    throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {
      code: 'keyword redefinition',
      context: localCtx,
      term: term
    });
  } else if (term.match(KEYWORD_PATTERN)) {
    // FIXME: remove logging and use a handler
    console.warn('WARNING: terms beginning with "@" are reserved' + ' for future use and ignored', {
      term: term
    });
    return;
  } else if (term === '') {
    throw new JsonLdError('Invalid JSON-LD syntax; a term cannot be an empty string.', 'jsonld.SyntaxError', {
      code: 'invalid term definition',
      context: localCtx
    });
  } // keep reference to previous mapping for potential `@protected` check


  var previousMapping = activeCtx.mappings.get(term); // remove old mapping

  if (activeCtx.mappings.has(term)) {
    activeCtx.mappings["delete"](term);
  } // convert short-hand value to object w/@id


  var simpleTerm = false;

  if (_isString(value) || value === null) {
    simpleTerm = true;
    value = {
      '@id': value
    };
  }

  if (!_isObject(value)) {
    throw new JsonLdError('Invalid JSON-LD syntax; @context term values must be ' + 'strings or objects.', 'jsonld.SyntaxError', {
      code: 'invalid term definition',
      context: localCtx
    });
  } // create new mapping


  var mapping = {};
  activeCtx.mappings.set(term, mapping);
  mapping.reverse = false; // make sure term definition only has expected keywords

  var validKeys = ['@container', '@id', '@language', '@reverse', '@type']; // JSON-LD 1.1 support

  if (api.processingMode(activeCtx, 1.1)) {
    validKeys.push('@context', '@direction', '@index', '@nest', '@prefix', '@protected');
  }

  for (var kw in value) {
    if (!validKeys.includes(kw)) {
      throw new JsonLdError('Invalid JSON-LD syntax; a term definition must not contain ' + kw, 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }
  } // always compute whether term has a colon as an optimization for
  // _compactIri


  var colon = term.indexOf(':');
  mapping._termHasColon = colon > 0;

  if ('@reverse' in value) {
    if ('@id' in value) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @id.', 'jsonld.SyntaxError', {
        code: 'invalid reverse property',
        context: localCtx
      });
    }

    if ('@nest' in value) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @nest.', 'jsonld.SyntaxError', {
        code: 'invalid reverse property',
        context: localCtx
      });
    }

    var reverse = value['@reverse'];

    if (!_isString(reverse)) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be a string.', 'jsonld.SyntaxError', {
        code: 'invalid IRI mapping',
        context: localCtx
      });
    }

    if (!api.isKeyword(reverse) && reverse.match(KEYWORD_PATTERN)) {
      // FIXME: remove logging and use a handler
      console.warn('WARNING: values beginning with "@" are reserved' + ' for future use and ignored', {
        reverse: reverse
      });

      if (previousMapping) {
        activeCtx.mappings.set(term, previousMapping);
      } else {
        activeCtx.mappings["delete"](term);
      }

      return;
    } // expand and add @id mapping


    var _id = _expandIri(activeCtx, reverse, {
      vocab: true,
      base: false
    }, localCtx, defined, options);

    if (!_isAbsoluteIri(_id)) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be an ' + 'absolute IRI or a blank node identifier.', 'jsonld.SyntaxError', {
        code: 'invalid IRI mapping',
        context: localCtx
      });
    }

    mapping['@id'] = _id;
    mapping.reverse = true;
  } else if ('@id' in value) {
    var _id2 = value['@id'];

    if (_id2 && !_isString(_id2)) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an array ' + 'of strings or a string.', 'jsonld.SyntaxError', {
        code: 'invalid IRI mapping',
        context: localCtx
      });
    }

    if (_id2 === null) {
      // reserve a null term, which may be protected
      mapping['@id'] = null;
    } else if (!api.isKeyword(_id2) && _id2.match(KEYWORD_PATTERN)) {
      // FIXME: remove logging and use a handler
      console.warn('WARNING: values beginning with "@" are reserved' + ' for future use and ignored', {
        id: _id2
      });

      if (previousMapping) {
        activeCtx.mappings.set(term, previousMapping);
      } else {
        activeCtx.mappings["delete"](term);
      }

      return;
    } else if (_id2 !== term) {
      // expand and add @id mapping
      _id2 = _expandIri(activeCtx, _id2, {
        vocab: true,
        base: false
      }, localCtx, defined, options);

      if (!_isAbsoluteIri(_id2) && !api.isKeyword(_id2)) {
        throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an ' + 'absolute IRI, a blank node identifier, or a keyword.', 'jsonld.SyntaxError', {
          code: 'invalid IRI mapping',
          context: localCtx
        });
      } // if term has the form of an IRI it must map the same


      if (term.match(/(?::[^:])|\//)) {
        var termDefined = new Map(defined).set(term, true);

        var termIri = _expandIri(activeCtx, term, {
          vocab: true,
          base: false
        }, localCtx, termDefined, options);

        if (termIri !== _id2) {
          throw new JsonLdError('Invalid JSON-LD syntax; term in form of IRI must ' + 'expand to definition.', 'jsonld.SyntaxError', {
            code: 'invalid IRI mapping',
            context: localCtx
          });
        }
      }

      mapping['@id'] = _id2; // indicate if this term may be used as a compact IRI prefix

      mapping._prefix = simpleTerm && !mapping._termHasColon && _id2.match(/[:\/\?#\[\]@]$/);
    }
  }

  if (!('@id' in mapping)) {
    // see if the term has a prefix
    if (mapping._termHasColon) {
      var prefix = term.substr(0, colon);

      if (localCtx.hasOwnProperty(prefix)) {
        // define parent prefix
        api.createTermDefinition({
          activeCtx: activeCtx,
          localCtx: localCtx,
          term: prefix,
          defined: defined,
          options: options
        });
      }

      if (activeCtx.mappings.has(prefix)) {
        // set @id based on prefix parent
        var suffix = term.substr(colon + 1);
        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;
      } else {
        // term is an absolute IRI
        mapping['@id'] = term;
      }
    } else if (term === '@type') {
      // Special case, were we've previously determined that container is @set
      mapping['@id'] = term;
    } else {
      // non-IRIs *must* define @ids if @vocab is not available
      if (!('@vocab' in activeCtx)) {
        throw new JsonLdError('Invalid JSON-LD syntax; @context terms must define an @id.', 'jsonld.SyntaxError', {
          code: 'invalid IRI mapping',
          context: localCtx,
          term: term
        });
      } // prepend vocab to term


      mapping['@id'] = activeCtx['@vocab'] + term;
    }
  } // Handle term protection


  if (value['@protected'] === true || defined.get('@protected') === true && value['@protected'] !== false) {
    activeCtx["protected"][term] = true;
    mapping["protected"] = true;
  } // IRI mapping now defined


  defined.set(term, true);

  if ('@type' in value) {
    var type = value['@type'];

    if (!_isString(type)) {
      throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be a string.', 'jsonld.SyntaxError', {
        code: 'invalid type mapping',
        context: localCtx
      });
    }

    if (type === '@json' || type === '@none') {
      if (api.processingMode(activeCtx, 1.0)) {
        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must not be ' + "\"".concat(type, "\" in JSON-LD 1.0 mode."), 'jsonld.SyntaxError', {
          code: 'invalid type mapping',
          context: localCtx
        });
      }
    } else if (type !== '@id' && type !== '@vocab') {
      // expand @type to full IRI
      type = _expandIri(activeCtx, type, {
        vocab: true,
        base: false
      }, localCtx, defined, options);

      if (!_isAbsoluteIri(type)) {
        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an ' + 'absolute IRI.', 'jsonld.SyntaxError', {
          code: 'invalid type mapping',
          context: localCtx
        });
      }

      if (type.indexOf('_:') === 0) {
        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an IRI, ' + 'not a blank node identifier.', 'jsonld.SyntaxError', {
          code: 'invalid type mapping',
          context: localCtx
        });
      }
    } // add @type to mapping


    mapping['@type'] = type;
  }

  if ('@container' in value) {
    // normalize container to an array form
    var container = _isString(value['@container']) ? [value['@container']] : value['@container'] || [];
    var validContainers = ['@list', '@set', '@index', '@language'];
    var isValid = true;
    var hasSet = container.includes('@set'); // JSON-LD 1.1 support

    if (api.processingMode(activeCtx, 1.1)) {
      validContainers.push('@graph', '@id', '@type'); // check container length

      if (container.includes('@list')) {
        if (container.length !== 1) {
          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @list must ' + 'have no other values', 'jsonld.SyntaxError', {
            code: 'invalid container mapping',
            context: localCtx
          });
        }
      } else if (container.includes('@graph')) {
        if (container.some(function (key) {
          return key !== '@graph' && key !== '@id' && key !== '@index' && key !== '@set';
        })) {
          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @graph must ' + 'have no other values other than @id, @index, and @set', 'jsonld.SyntaxError', {
            code: 'invalid container mapping',
            context: localCtx
          });
        }
      } else {
        // otherwise, container may also include @set
        isValid &= container.length <= (hasSet ? 2 : 1);
      }

      if (container.includes('@type')) {
        // If mapping does not have an @type,
        // set it to @id
        mapping['@type'] = mapping['@type'] || '@id'; // type mapping must be either @id or @vocab

        if (!['@id', '@vocab'].includes(mapping['@type'])) {
          throw new JsonLdError('Invalid JSON-LD syntax; container: @type requires @type to be ' + '@id or @vocab.', 'jsonld.SyntaxError', {
            code: 'invalid type mapping',
            context: localCtx
          });
        }
      }
    } else {
      // in JSON-LD 1.0, container must not be an array (it must be a string,
      // which is one of the validContainers)
      isValid &= !_isArray(value['@container']); // check container length

      isValid &= container.length <= 1;
    } // check against valid containers


    isValid &= container.every(function (c) {
      return validContainers.includes(c);
    }); // @set not allowed with @list

    isValid &= !(hasSet && container.includes('@list'));

    if (!isValid) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value must be ' + 'one of the following: ' + validContainers.join(', '), 'jsonld.SyntaxError', {
        code: 'invalid container mapping',
        context: localCtx
      });
    }

    if (mapping.reverse && !container.every(function (c) {
      return ['@index', '@set'].includes(c);
    })) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value for a @reverse ' + 'type definition must be @index or @set.', 'jsonld.SyntaxError', {
        code: 'invalid reverse property',
        context: localCtx
      });
    } // add @container to mapping


    mapping['@container'] = container;
  } // property indexing


  if ('@index' in value) {
    if (!('@container' in value) || !mapping['@container'].includes('@index')) {
      throw new JsonLdError('Invalid JSON-LD syntax; @index without @index in @container: ' + "\"".concat(value['@index'], "\" on term \"").concat(term, "\"."), 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }

    if (!_isString(value['@index']) || value['@index'].indexOf('@') === 0) {
      throw new JsonLdError('Invalid JSON-LD syntax; @index must expand to an IRI: ' + "\"".concat(value['@index'], "\" on term \"").concat(term, "\"."), 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }

    mapping['@index'] = value['@index'];
  } // scoped contexts


  if ('@context' in value) {
    mapping['@context'] = value['@context'];
  }

  if ('@language' in value && !('@type' in value)) {
    var language = value['@language'];

    if (language !== null && !_isString(language)) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @language value must be ' + 'a string or null.', 'jsonld.SyntaxError', {
        code: 'invalid language mapping',
        context: localCtx
      });
    } // add @language to mapping


    if (language !== null) {
      language = language.toLowerCase();
    }

    mapping['@language'] = language;
  } // term may be used as a prefix


  if ('@prefix' in value) {
    if (term.match(/:|\//)) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @prefix used on a compact IRI term', 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }

    if (api.isKeyword(mapping['@id'])) {
      throw new JsonLdError('Invalid JSON-LD syntax; keywords may not be used as prefixes', 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }

    if (typeof value['@prefix'] === 'boolean') {
      mapping._prefix = value['@prefix'] === true;
    } else {
      throw new JsonLdError('Invalid JSON-LD syntax; @context value for @prefix must be boolean', 'jsonld.SyntaxError', {
        code: 'invalid @prefix value',
        context: localCtx
      });
    }
  }

  if ('@direction' in value) {
    var direction = value['@direction'];

    if (direction !== null && direction !== 'ltr' && direction !== 'rtl') {
      throw new JsonLdError('Invalid JSON-LD syntax; @direction value must be ' + 'null, "ltr", or "rtl".', 'jsonld.SyntaxError', {
        code: 'invalid base direction',
        context: localCtx
      });
    }

    mapping['@direction'] = direction;
  }

  if ('@nest' in value) {
    var nest = value['@nest'];

    if (!_isString(nest) || nest !== '@nest' && nest.indexOf('@') === 0) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @nest value must be ' + 'a string which is not a keyword other than @nest.', 'jsonld.SyntaxError', {
        code: 'invalid @nest value',
        context: localCtx
      });
    }

    mapping['@nest'] = nest;
  } // disallow aliasing @context and @preserve


  var id = mapping['@id'];

  if (id === '@context' || id === '@preserve') {
    throw new JsonLdError('Invalid JSON-LD syntax; @context and @preserve cannot be aliased.', 'jsonld.SyntaxError', {
      code: 'invalid keyword alias',
      context: localCtx
    });
  } // Check for overriding protected terms


  if (previousMapping && previousMapping["protected"] && !overrideProtected) {
    // force new term to continue to be protected and see if the mappings would
    // be equal
    activeCtx["protected"][term] = true;
    mapping["protected"] = true;

    if (!_deepCompare(previousMapping, mapping)) {
      var protectedMode = options && options.protectedMode || 'error';

      if (protectedMode === 'error') {
        throw new JsonLdError('Invalid JSON-LD syntax; tried to redefine a protected term.', 'jsonld.SyntaxError', {
          code: 'protected term redefinition',
          context: localCtx,
          term: term
        });
      } else if (protectedMode === 'warn') {
        // FIXME: remove logging and use a handler
        console.warn('WARNING: protected term redefinition', {
          term: term
        });
        return;
      }

      throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {
        code: 'invalid protected mode',
        context: localCtx,
        term: term,
        protectedMode: protectedMode
      });
    }
  }
};
/**
 * Expands a string to a full IRI. The string may be a term, a prefix, a
 * relative IRI, or an absolute IRI. The associated absolute IRI will be
 * returned.
 *
 * @param activeCtx the current active context.
 * @param value the string to expand.
 * @param relativeTo options for how to resolve relative IRIs:
 *          base: true to resolve against the base IRI, false not to.
 *          vocab: true to concatenate after @vocab, false not to.
 * @param {Object} [options] - processing options.
 *
 * @return the expanded value.
 */


api.expandIri = function (activeCtx, value, relativeTo, options) {
  return _expandIri(activeCtx, value, relativeTo, undefined, undefined, options);
};
/**
 * Expands a string to a full IRI. The string may be a term, a prefix, a
 * relative IRI, or an absolute IRI. The associated absolute IRI will be
 * returned.
 *
 * @param activeCtx the current active context.
 * @param value the string to expand.
 * @param relativeTo options for how to resolve relative IRIs:
 *          base: true to resolve against the base IRI, false not to.
 *          vocab: true to concatenate after @vocab, false not to.
 * @param localCtx the local context being processed (only given if called
 *          during context processing).
 * @param defined a map for tracking cycles in context definitions (only given
 *          if called during context processing).
 * @param {Object} [options] - processing options.
 *
 * @return the expanded value.
 */


function _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {
  // already expanded
  if (value === null || !_isString(value) || api.isKeyword(value)) {
    return value;
  } // ignore non-keyword things that look like a keyword


  if (value.match(KEYWORD_PATTERN)) {
    return null;
  } // define term dependency if not defined


  if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {
    api.createTermDefinition({
      activeCtx: activeCtx,
      localCtx: localCtx,
      term: value,
      defined: defined,
      options: options
    });
  }

  relativeTo = relativeTo || {};

  if (relativeTo.vocab) {
    var mapping = activeCtx.mappings.get(value); // value is explicitly ignored with a null mapping

    if (mapping === null) {
      return null;
    }

    if (_isObject(mapping) && '@id' in mapping) {
      // value is a term
      return mapping['@id'];
    }
  } // split value into prefix:suffix


  var colon = value.indexOf(':');

  if (colon > 0) {
    var prefix = value.substr(0, colon);
    var suffix = value.substr(colon + 1); // do not expand blank nodes (prefix of '_') or already-absolute
    // IRIs (suffix of '//')

    if (prefix === '_' || suffix.indexOf('//') === 0) {
      return value;
    } // prefix dependency not defined, define it


    if (localCtx && localCtx.hasOwnProperty(prefix)) {
      api.createTermDefinition({
        activeCtx: activeCtx,
        localCtx: localCtx,
        term: prefix,
        defined: defined,
        options: options
      });
    } // use mapping if prefix is defined


    var _mapping = activeCtx.mappings.get(prefix);

    if (_mapping && _mapping._prefix) {
      return _mapping['@id'] + suffix;
    } // already absolute IRI


    if (_isAbsoluteIri(value)) {
      return value;
    }
  } // prepend vocab


  if (relativeTo.vocab && '@vocab' in activeCtx) {
    return activeCtx['@vocab'] + value;
  } // prepend base


  if (relativeTo.base && '@base' in activeCtx) {
    if (activeCtx['@base']) {
      // The null case preserves value as potentially relative
      return prependBase(prependBase(options.base, activeCtx['@base']), value);
    }
  } else if (relativeTo.base) {
    return prependBase(options.base, value);
  }

  return value;
}
/**
 * Gets the initial context.
 *
 * @param options the options to use:
 *          [base] the document base IRI.
 *
 * @return the initial context.
 */


api.getInitialContext = function (options) {
  var key = JSON.stringify({
    processingMode: options.processingMode
  });
  var cached = INITIAL_CONTEXT_CACHE.get(key);

  if (cached) {
    return cached;
  }

  var initialContext = {
    processingMode: options.processingMode,
    mappings: new Map(),
    inverse: null,
    getInverse: _createInverseContext,
    clone: _cloneActiveContext,
    revertToPreviousContext: _revertToPreviousContext,
    "protected": {}
  }; // TODO: consider using LRU cache instead

  if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {
    // clear whole cache -- assumes scenario where the cache fills means
    // the cache isn't being used very efficiently anyway
    INITIAL_CONTEXT_CACHE.clear();
  }

  INITIAL_CONTEXT_CACHE.set(key, initialContext);
  return initialContext;
  /**
   * Generates an inverse context for use in the compaction algorithm, if
   * not already generated for the given active context.
   *
   * @return the inverse context.
   */

  function _createInverseContext() {
    var activeCtx = this; // lazily create inverse

    if (activeCtx.inverse) {
      return activeCtx.inverse;
    }

    var inverse = activeCtx.inverse = {}; // variables for building fast CURIE map

    var fastCurieMap = activeCtx.fastCurieMap = {};
    var irisToTerms = {}; // handle default language

    var defaultLanguage = (activeCtx['@language'] || '@none').toLowerCase(); // handle default direction

    var defaultDirection = activeCtx['@direction']; // create term selections for each mapping in the context, ordered by
    // shortest and then lexicographically least

    var mappings = activeCtx.mappings;
    var terms = (0, _toConsumableArray2["default"])(mappings.keys()).sort(_compareShortestLeast);

    var _iterator2 = _createForOfIteratorHelper(terms),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var term = _step2.value;
        var mapping = mappings.get(term);

        if (mapping === null) {
          continue;
        }

        var container = mapping['@container'] || '@none';
        container = [].concat(container).sort().join('');

        if (mapping['@id'] === null) {
          continue;
        } // iterate over every IRI in the mapping


        var ids = _asArray(mapping['@id']);

        var _iterator3 = _createForOfIteratorHelper(ids),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var iri = _step3.value;
            var entry = inverse[iri];
            var isKeyword = api.isKeyword(iri);

            if (!entry) {
              // initialize entry
              inverse[iri] = entry = {};

              if (!isKeyword && !mapping._termHasColon) {
                // init IRI to term map and fast CURIE prefixes
                irisToTerms[iri] = [term];
                var fastCurieEntry = {
                  iri: iri,
                  terms: irisToTerms[iri]
                };

                if (iri[0] in fastCurieMap) {
                  fastCurieMap[iri[0]].push(fastCurieEntry);
                } else {
                  fastCurieMap[iri[0]] = [fastCurieEntry];
                }
              }
            } else if (!isKeyword && !mapping._termHasColon) {
              // add IRI to term match
              irisToTerms[iri].push(term);
            } // add new entry


            if (!entry[container]) {
              entry[container] = {
                '@language': {},
                '@type': {},
                '@any': {}
              };
            }

            entry = entry[container];

            _addPreferredTerm(term, entry['@any'], '@none');

            if (mapping.reverse) {
              // term is preferred for values using @reverse
              _addPreferredTerm(term, entry['@type'], '@reverse');
            } else if (mapping['@type'] === '@none') {
              _addPreferredTerm(term, entry['@any'], '@none');

              _addPreferredTerm(term, entry['@language'], '@none');

              _addPreferredTerm(term, entry['@type'], '@none');
            } else if ('@type' in mapping) {
              // term is preferred for values using specific type
              _addPreferredTerm(term, entry['@type'], mapping['@type']);
            } else if ('@language' in mapping && '@direction' in mapping) {
              // term is preferred for values using specific language and direction
              var language = mapping['@language'];
              var direction = mapping['@direction'];

              if (language && direction) {
                _addPreferredTerm(term, entry['@language'], "".concat(language, "_").concat(direction).toLowerCase());
              } else if (language) {
                _addPreferredTerm(term, entry['@language'], language.toLowerCase());
              } else if (direction) {
                _addPreferredTerm(term, entry['@language'], "_".concat(direction));
              } else {
                _addPreferredTerm(term, entry['@language'], '@null');
              }
            } else if ('@language' in mapping) {
              _addPreferredTerm(term, entry['@language'], (mapping['@language'] || '@null').toLowerCase());
            } else if ('@direction' in mapping) {
              if (mapping['@direction']) {
                _addPreferredTerm(term, entry['@language'], "_".concat(mapping['@direction']));
              } else {
                _addPreferredTerm(term, entry['@language'], '@none');
              }
            } else if (defaultDirection) {
              _addPreferredTerm(term, entry['@language'], "_".concat(defaultDirection));

              _addPreferredTerm(term, entry['@language'], '@none');

              _addPreferredTerm(term, entry['@type'], '@none');
            } else {
              // add entries for no type and no language
              _addPreferredTerm(term, entry['@language'], defaultLanguage);

              _addPreferredTerm(term, entry['@language'], '@none');

              _addPreferredTerm(term, entry['@type'], '@none');
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } // build fast CURIE map

    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    for (var _key2 in fastCurieMap) {
      _buildIriMap(fastCurieMap, _key2, 1);
    }

    return inverse;
  }
  /**
   * Runs a recursive algorithm to build a lookup map for quickly finding
   * potential CURIEs.
   *
   * @param iriMap the map to build.
   * @param key the current key in the map to work on.
   * @param idx the index into the IRI to compare.
   */


  function _buildIriMap(iriMap, key, idx) {
    var entries = iriMap[key];
    var next = iriMap[key] = {};
    var iri;
    var letter;

    var _iterator4 = _createForOfIteratorHelper(entries),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var entry = _step4.value;
        iri = entry.iri;

        if (idx >= iri.length) {
          letter = '';
        } else {
          letter = iri[idx];
        }

        if (letter in next) {
          next[letter].push(entry);
        } else {
          next[letter] = [entry];
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    for (var _key3 in next) {
      if (_key3 === '') {
        continue;
      }

      _buildIriMap(next, _key3, idx + 1);
    }
  }
  /**
   * Adds the term for the given entry if not already added.
   *
   * @param term the term to add.
   * @param entry the inverse context typeOrLanguage entry to add to.
   * @param typeOrLanguageValue the key in the entry to add to.
   */


  function _addPreferredTerm(term, entry, typeOrLanguageValue) {
    if (!entry.hasOwnProperty(typeOrLanguageValue)) {
      entry[typeOrLanguageValue] = term;
    }
  }
  /**
   * Clones an active context, creating a child active context.
   *
   * @return a clone (child) of the active context.
   */


  function _cloneActiveContext() {
    var child = {};
    child.mappings = util.clone(this.mappings);
    child.clone = this.clone;
    child.inverse = null;
    child.getInverse = this.getInverse;
    child["protected"] = util.clone(this["protected"]);

    if (this.previousContext) {
      child.previousContext = this.previousContext.clone();
    }

    child.revertToPreviousContext = this.revertToPreviousContext;

    if ('@base' in this) {
      child['@base'] = this['@base'];
    }

    if ('@language' in this) {
      child['@language'] = this['@language'];
    }

    if ('@vocab' in this) {
      child['@vocab'] = this['@vocab'];
    }

    return child;
  }
  /**
   * Reverts any type-scoped context in this active context to the previous
   * context.
   */


  function _revertToPreviousContext() {
    if (!this.previousContext) {
      return this;
    }

    return this.previousContext.clone();
  }
};
/**
 * Gets the value for the given active context key and type, null if none is
 * set or undefined if none is set and type is '@context'.
 *
 * @param ctx the active context.
 * @param key the context key.
 * @param [type] the type of value to get (eg: '@id', '@type'), if not
 *          specified gets the entire entry for a key, null if not found.
 *
 * @return the value, null, or undefined.
 */


api.getContextValue = function (ctx, key, type) {
  // invalid key
  if (key === null) {
    if (type === '@context') {
      return undefined;
    }

    return null;
  } // get specific entry information


  if (ctx.mappings.has(key)) {
    var entry = ctx.mappings.get(key);

    if (_isUndefined(type)) {
      // return whole entry
      return entry;
    }

    if (entry.hasOwnProperty(type)) {
      // return entry value for type
      return entry[type];
    }
  } // get default language


  if (type === '@language' && type in ctx) {
    return ctx[type];
  } // get default direction


  if (type === '@direction' && type in ctx) {
    return ctx[type];
  }

  if (type === '@context') {
    return undefined;
  }

  return null;
};
/**
 * Processing Mode check.
 *
 * @param activeCtx the current active context.
 * @param version the string or numeric version to check.
 *
 * @return boolean.
 */


api.processingMode = function (activeCtx, version) {
  if (version.toString() >= '1.1') {
    return !activeCtx.processingMode || activeCtx.processingMode >= 'json-ld-' + version.toString();
  } else {
    return activeCtx.processingMode === 'json-ld-1.0';
  }
};
/**
 * Returns whether or not the given value is a keyword.
 *
 * @param v the value to check.
 *
 * @return true if the value is a keyword, false if not.
 */


api.isKeyword = function (v) {
  if (!_isString(v) || v[0] !== '@') {
    return false;
  }

  switch (v) {
    case '@base':
    case '@container':
    case '@context':
    case '@default':
    case '@direction':
    case '@embed':
    case '@explicit':
    case '@graph':
    case '@id':
    case '@included':
    case '@index':
    case '@json':
    case '@language':
    case '@list':
    case '@nest':
    case '@none':
    case '@omitDefault':
    case '@prefix':
    case '@preserve':
    case '@protected':
    case '@requireAll':
    case '@reverse':
    case '@set':
    case '@type':
    case '@value':
    case '@version':
    case '@vocab':
      return true;
  }

  return false;
};

function _deepCompare(x1, x2) {
  // compare `null` or primitive types directly
  if (!(x1 && (0, _typeof2["default"])(x1) === 'object') || !(x2 && (0, _typeof2["default"])(x2) === 'object')) {
    return x1 === x2;
  } // x1 and x2 are objects (also potentially arrays)


  var x1Array = Array.isArray(x1);

  if (x1Array !== Array.isArray(x2)) {
    return false;
  }

  if (x1Array) {
    if (x1.length !== x2.length) {
      return false;
    }

    for (var i = 0; i < x1.length; ++i) {
      if (!_deepCompare(x1[i], x2[i])) {
        return false;
      }
    }

    return true;
  } // x1 and x2 are non-array objects


  var k1s = Object.keys(x1);
  var k2s = Object.keys(x2);

  if (k1s.length !== k2s.length) {
    return false;
  }

  for (var k1 in x1) {
    var v1 = x1[k1];
    var v2 = x2[k1]; // special case: `@container` can be in any order

    if (k1 === '@container') {
      if (Array.isArray(v1) && Array.isArray(v2)) {
        v1 = v1.slice().sort();
        v2 = v2.slice().sort();
      }
    }

    if (!_deepCompare(v1, v2)) {
      return false;
    }
  }

  return true;
}

},{"./JsonLdError":91,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/toConsumableArray":26,"@babel/runtime/helpers/typeof":27,"@babel/runtime/regenerator":30}],100:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _require = require('../util'),
    parseLinkHeader = _require.parseLinkHeader,
    buildHeaders = _require.buildHeaders;

var _require2 = require('../constants'),
    LINK_HEADER_CONTEXT = _require2.LINK_HEADER_CONTEXT;

var JsonLdError = require('../JsonLdError');

var RequestQueue = require('../RequestQueue');

var _require3 = require('../url'),
    prependBase = _require3.prependBase;
/**
 * Creates a built-in node document loader.
 *
 * @param options the options to use:
 *          secure: require all URLs to use HTTPS.
 *          strictSSL: true to require SSL certificates to be valid,
 *            false not to (default: true).
 *          maxRedirects: the maximum number of redirects to permit, none by
 *            default.
 *          request: the object which will make the request, default is
 *            provided by `https://www.npmjs.com/package/request`.
 *          headers: an object (map) of headers which will be passed as request
 *            headers for the requested document. Accept is not allowed.
 *
 * @return the node document loader.
 */


module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    strictSSL: true,
    maxRedirects: -1,
    headers: {}
  },
      secure = _ref.secure,
      _ref$strictSSL = _ref.strictSSL,
      strictSSL = _ref$strictSSL === void 0 ? true : _ref$strictSSL,
      _ref$maxRedirects = _ref.maxRedirects,
      maxRedirects = _ref$maxRedirects === void 0 ? -1 : _ref$maxRedirects,
      request = _ref.request,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers;

  headers = buildHeaders(headers); // TODO: use `axios`

  request = request || require('request');

  var http = require('http');

  var queue = new RequestQueue();
  return queue.wrapLoader(function (url) {
    return loadDocument(url, []);
  });

  function loadDocument(_x, _x2) {
    return _loadDocument.apply(this, arguments);
  }

  function _loadDocument() {
    _loadDocument = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url, redirects) {
      var doc, result, alternate, _result, res, body, statusText, linkHeaders, linkedContext;

      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0)) {
                _context.next = 2;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              });

            case 2:
              if (!(secure && url.indexOf('https') !== 0)) {
                _context.next = 4;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\'s scheme is not "https".', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              });

            case 4:
              // TODO: disable cache until HTTP caching implemented
              doc = null; //cache.get(url);

              if (!(doc !== null)) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", doc);

            case 7:
              alternate = null;
              _context.prev = 8;
              _context.next = 11;
              return _request(request, {
                url: url,
                headers: headers,
                strictSSL: strictSSL,
                followRedirect: false
              });

            case 11:
              result = _context.sent;
              _context.next = 17;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](8);
              throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                url: url,
                cause: _context.t0
              });

            case 17:
              _result = result, res = _result.res, body = _result.body;
              doc = {
                contextUrl: null,
                documentUrl: url,
                document: body || null
              }; // handle error

              statusText = http.STATUS_CODES[res.statusCode];

              if (!(res.statusCode >= 400)) {
                _context.next = 22;
                break;
              }

              throw new JsonLdError("URL \"".concat(url, "\" could not be dereferenced: ").concat(statusText), 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url,
                httpStatusCode: res.statusCode
              });

            case 22:
              if (!(res.headers.link && res.headers['content-type'] !== 'application/ld+json')) {
                _context.next = 30;
                break;
              }

              // only 1 related link header permitted
              linkHeaders = parseLinkHeader(res.headers.link);
              linkedContext = linkHeaders[LINK_HEADER_CONTEXT];

              if (!Array.isArray(linkedContext)) {
                _context.next = 27;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', {
                code: 'multiple context link headers',
                url: url
              });

            case 27:
              if (linkedContext) {
                doc.contextUrl = linkedContext.target;
              } // "alternate" link header is a redirect


              alternate = linkHeaders['alternate'];

              if (alternate && alternate.type == 'application/ld+json' && !(res.headers['content-type'] || '').match(/^application\/(\w*\+)?json$/)) {
                res.headers.location = prependBase(url, alternate.target);
              }

            case 30:
              if (!((alternate || res.statusCode >= 300 && res.statusCode < 400) && res.headers.location)) {
                _context.next = 37;
                break;
              }

              if (!(redirects.length === maxRedirects)) {
                _context.next = 33;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {
                code: 'loading document failed',
                url: url,
                httpStatusCode: res.statusCode,
                redirects: redirects
              });

            case 33:
              if (!(redirects.indexOf(url) !== -1)) {
                _context.next = 35;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {
                code: 'recursive context inclusion',
                url: url,
                httpStatusCode: res.statusCode,
                redirects: redirects
              });

            case 35:
              redirects.push(url);
              return _context.abrupt("return", loadDocument(res.headers.location, redirects));

            case 37:
              // cache for each redirected URL
              redirects.push(url); // TODO: disable cache until HTTP caching implemented

              /*
              for(let i = 0; i < redirects.length; ++i) {
                cache.set(
                  redirects[i],
                  {contextUrl: null, documentUrl: redirects[i], document: body});
              }
              */

              return _context.abrupt("return", doc);

            case 39:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[8, 14]]);
    }));
    return _loadDocument.apply(this, arguments);
  }
};

function _request(request, options) {
  return new Promise(function (resolve, reject) {
    request(options, function (err, res, body) {
      if (err) {
        reject(err);
      } else {
        resolve({
          res: res,
          body: body
        });
      }
    });
  });
}

},{"../JsonLdError":91,"../RequestQueue":95,"../constants":98,"../url":111,"../util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30,"http":58,"request":58}],101:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _require = require('../util'),
    parseLinkHeader = _require.parseLinkHeader,
    buildHeaders = _require.buildHeaders;

var _require2 = require('../constants'),
    LINK_HEADER_CONTEXT = _require2.LINK_HEADER_CONTEXT;

var JsonLdError = require('../JsonLdError');

var RequestQueue = require('../RequestQueue');

var _require3 = require('../url'),
    prependBase = _require3.prependBase;

var REGEX_LINK_HEADER = /(^|(\r\n))link:/i;
/**
 * Creates a built-in XMLHttpRequest document loader.
 *
 * @param options the options to use:
 *          secure: require all URLs to use HTTPS.
 *          headers: an object (map) of headers which will be passed as request
 *            headers for the requested document. Accept is not allowed.
 *          [xhr]: the XMLHttpRequest API to use.
 *
 * @return the XMLHttpRequest document loader.
 */

module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    headers: {}
  },
      secure = _ref.secure,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      xhr = _ref.xhr;

  headers = buildHeaders(headers);
  var queue = new RequestQueue();
  return queue.wrapLoader(loader);

  function loader(_x) {
    return _loader.apply(this, arguments);
  }

  function _loader() {
    _loader = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url) {
      var req, doc, alternate, contentType, linkHeader, linkHeaders, linkedContext;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0)) {
                _context.next = 2;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              });

            case 2:
              if (!(secure && url.indexOf('https') !== 0)) {
                _context.next = 4;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\'s scheme is not "https".', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              });

            case 4:
              _context.prev = 4;
              _context.next = 7;
              return _get(xhr, url, headers);

            case 7:
              req = _context.sent;
              _context.next = 13;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](4);
              throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                url: url,
                cause: _context.t0
              });

            case 13:
              if (!(req.status >= 400)) {
                _context.next = 15;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced: ' + req.statusText, 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                url: url,
                httpStatusCode: req.status
              });

            case 15:
              doc = {
                contextUrl: null,
                documentUrl: url,
                document: req.response
              };
              alternate = null; // handle Link Header (avoid unsafe header warning by existence testing)

              contentType = req.getResponseHeader('Content-Type');

              if (REGEX_LINK_HEADER.test(req.getAllResponseHeaders())) {
                linkHeader = req.getResponseHeader('Link');
              }

              if (!(linkHeader && contentType !== 'application/ld+json')) {
                _context.next = 30;
                break;
              }

              // only 1 related link header permitted
              linkHeaders = parseLinkHeader(linkHeader);
              linkedContext = linkHeaders[LINK_HEADER_CONTEXT];

              if (!Array.isArray(linkedContext)) {
                _context.next = 24;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced, it has more than one ' + 'associated HTTP Link Header.', 'jsonld.InvalidUrl', {
                code: 'multiple context link headers',
                url: url
              });

            case 24:
              if (linkedContext) {
                doc.contextUrl = linkedContext.target;
              } // "alternate" link header is a redirect


              alternate = linkHeaders['alternate'];

              if (!(alternate && alternate.type == 'application/ld+json' && !(contentType || '').match(/^application\/(\w*\+)?json$/))) {
                _context.next = 30;
                break;
              }

              _context.next = 29;
              return loader(prependBase(url, alternate.target));

            case 29:
              doc = _context.sent;

            case 30:
              return _context.abrupt("return", doc);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[4, 10]]);
    }));
    return _loader.apply(this, arguments);
  }
};

function _get(xhr, url, headers) {
  xhr = xhr || XMLHttpRequest;
  var req = new xhr();
  return new Promise(function (resolve, reject) {
    req.onload = function () {
      return resolve(req);
    };

    req.onerror = function (err) {
      return reject(err);
    };

    req.open('GET', url, true);

    for (var k in headers) {
      req.setRequestHeader(k, headers[k]);
    }

    req.send();
  });
}

},{"../JsonLdError":91,"../RequestQueue":95,"../constants":98,"../url":111,"../util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30}],102:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var JsonLdError = require('./JsonLdError');

var _require = require('./types'),
    _isArray = _require.isArray,
    _isObject = _require.isObject,
    _isEmptyObject = _require.isEmptyObject,
    _isString = _require.isString,
    _isUndefined = _require.isUndefined;

var _require2 = require('./graphTypes'),
    _isList = _require2.isList,
    _isValue = _require2.isValue,
    _isGraph = _require2.isGraph,
    _isSubject = _require2.isSubject;

var _require3 = require('./context'),
    _expandIri = _require3.expandIri,
    _getContextValue = _require3.getContextValue,
    _isKeyword = _require3.isKeyword,
    _processContext = _require3.process,
    _processingMode = _require3.processingMode;

var _require4 = require('./url'),
    _isAbsoluteIri = _require4.isAbsolute;

var _require5 = require('./util'),
    _addValue = _require5.addValue,
    _asArray = _require5.asArray,
    _getValues = _require5.getValues,
    _validateTypeValue = _require5.validateTypeValue;

var api = {};
module.exports = api;
var REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
/**
 * Recursively expands an element using the given context. Any context in
 * the element will be removed. All context URLs must have been retrieved
 * before calling this method.
 *
 * @param activeCtx the context to use.
 * @param activeProperty the property for the element, null for none.
 * @param element the element to expand.
 * @param options the expansion options.
 * @param insideList true if the element is a list, false if not.
 * @param insideIndex true if the element is inside an index container,
 *          false if not.
 * @param typeScopedContext an optional type-scoped active context for
 *          expanding values of nodes that were expressed according to
 *          a type-scoped context.
 * @param expansionMap(info) a function that can be used to custom map
 *          unmappable values (or to throw an error when they are detected);
 *          if this function returns `undefined` then the default behavior
 *          will be used.
 *
 * @return a Promise that resolves to the expanded value.
 */

api.expand = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref) {
    var activeCtx, _ref$activeProperty, activeProperty, element, _ref$options, options, _ref$insideList, insideList, _ref$insideIndex, insideIndex, _ref$typeScopedContex, typeScopedContext, _ref$expansionMap, expansionMap, mapped, _rval, container, i, e, expandedActiveProperty, propertyScopedCtx, keys, mustRevert, _iterator, _step, key, expandedProperty, typeKey, _iterator2, _step2, _key, _expandedProperty, value, _types, _iterator3, _step3, type, ctx, rval, count, validCount, values, types, _mapped, _mapped2, _mapped3;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            activeCtx = _ref.activeCtx, _ref$activeProperty = _ref.activeProperty, activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty, element = _ref.element, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, _ref$insideList = _ref.insideList, insideList = _ref$insideList === void 0 ? false : _ref$insideList, _ref$insideIndex = _ref.insideIndex, insideIndex = _ref$insideIndex === void 0 ? false : _ref$insideIndex, _ref$typeScopedContex = _ref.typeScopedContext, typeScopedContext = _ref$typeScopedContex === void 0 ? null : _ref$typeScopedContex, _ref$expansionMap = _ref.expansionMap, expansionMap = _ref$expansionMap === void 0 ? function () {
              return undefined;
            } : _ref$expansionMap;

            if (!(element === null || element === undefined)) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return", null);

          case 3:
            // disable framing if activeProperty is @default
            if (activeProperty === '@default') {
              options = Object.assign({}, options, {
                isFrame: false
              });
            }

            if (!(!_isArray(element) && !_isObject(element))) {
              _context.next = 13;
              break;
            }

            if (!(!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, {
              vocab: true
            }, options) === '@graph'))) {
              _context.next = 12;
              break;
            }

            _context.next = 8;
            return expansionMap({
              unmappedValue: element,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              options: options,
              insideList: insideList
            });

          case 8:
            mapped = _context.sent;

            if (!(mapped === undefined)) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("return", null);

          case 11:
            return _context.abrupt("return", mapped);

          case 12:
            return _context.abrupt("return", _expandValue({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              value: element,
              options: options
            }));

          case 13:
            if (!_isArray(element)) {
              _context.next = 34;
              break;
            }

            _rval = [];
            container = _getContextValue(activeCtx, activeProperty, '@container') || [];
            insideList = insideList || container.includes('@list');
            i = 0;

          case 18:
            if (!(i < element.length)) {
              _context.next = 33;
              break;
            }

            _context.next = 21;
            return api.expand({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element[i],
              options: options,
              expansionMap: expansionMap,
              insideIndex: insideIndex,
              typeScopedContext: typeScopedContext
            });

          case 21:
            e = _context.sent;

            if (insideList && _isArray(e)) {
              e = {
                '@list': e
              };
            }

            if (!(e === null)) {
              _context.next = 29;
              break;
            }

            _context.next = 26;
            return expansionMap({
              unmappedValue: element[i],
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              parent: element,
              index: i,
              options: options,
              expandedParent: _rval,
              insideList: insideList
            });

          case 26:
            e = _context.sent;

            if (!(e === undefined)) {
              _context.next = 29;
              break;
            }

            return _context.abrupt("continue", 30);

          case 29:
            if (_isArray(e)) {
              _rval = _rval.concat(e);
            } else {
              _rval.push(e);
            }

          case 30:
            ++i;
            _context.next = 18;
            break;

          case 33:
            return _context.abrupt("return", _rval);

          case 34:
            // recursively expand object:
            // first, expand the active property
            expandedActiveProperty = _expandIri(activeCtx, activeProperty, {
              vocab: true
            }, options); // Get any property-scoped context for activeProperty

            propertyScopedCtx = _getContextValue(activeCtx, activeProperty, '@context'); // second, determine if any type-scoped context should be reverted; it
            // should only be reverted when the following are all true:
            // 1. `element` is not a value or subject reference
            // 2. `insideIndex` is false

            typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);
            keys = Object.keys(element).sort();
            mustRevert = !insideIndex;

            if (!(mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes('@context'))) {
              _context.next = 63;
              break;
            }

            _iterator = _createForOfIteratorHelper(keys);
            _context.prev = 41;

            _iterator.s();

          case 43:
            if ((_step = _iterator.n()).done) {
              _context.next = 55;
              break;
            }

            key = _step.value;
            expandedProperty = _expandIri(typeScopedContext, key, {
              vocab: true
            }, options);

            if (!(expandedProperty === '@value')) {
              _context.next = 50;
              break;
            }

            // value found, ensure type-scoped context is used to expand it
            mustRevert = false;
            activeCtx = typeScopedContext;
            return _context.abrupt("break", 55);

          case 50:
            if (!(expandedProperty === '@id' && keys.length === 1)) {
              _context.next = 53;
              break;
            }

            // subject reference found, do not revert
            mustRevert = false;
            return _context.abrupt("break", 55);

          case 53:
            _context.next = 43;
            break;

          case 55:
            _context.next = 60;
            break;

          case 57:
            _context.prev = 57;
            _context.t0 = _context["catch"](41);

            _iterator.e(_context.t0);

          case 60:
            _context.prev = 60;

            _iterator.f();

            return _context.finish(60);

          case 63:
            if (mustRevert) {
              // revert type scoped context
              activeCtx = activeCtx.revertToPreviousContext();
            } // apply property-scoped context after reverting term-scoped context


            if (_isUndefined(propertyScopedCtx)) {
              _context.next = 68;
              break;
            }

            _context.next = 67;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: propertyScopedCtx,
              propagate: true,
              overrideProtected: true,
              options: options
            });

          case 67:
            activeCtx = _context.sent;

          case 68:
            if (!('@context' in element)) {
              _context.next = 72;
              break;
            }

            _context.next = 71;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: element['@context'],
              options: options
            });

          case 71:
            activeCtx = _context.sent;

          case 72:
            // set the type-scoped context to the context on input, for use later
            typeScopedContext = activeCtx; // Remember the first key found expanding to @type

            typeKey = null; // look for scoped contexts on `@type`

            _iterator2 = _createForOfIteratorHelper(keys);
            _context.prev = 75;

            _iterator2.s();

          case 77:
            if ((_step2 = _iterator2.n()).done) {
              _context.next = 106;
              break;
            }

            _key = _step2.value;
            _expandedProperty = _expandIri(activeCtx, _key, {
              vocab: true
            }, options);

            if (!(_expandedProperty === '@type')) {
              _context.next = 104;
              break;
            }

            // set scoped contexts from @type
            // avoid sorting if possible
            typeKey = typeKey || _key;
            value = element[_key];
            _types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];
            _iterator3 = _createForOfIteratorHelper(_types);
            _context.prev = 85;

            _iterator3.s();

          case 87:
            if ((_step3 = _iterator3.n()).done) {
              _context.next = 96;
              break;
            }

            type = _step3.value;
            ctx = _getContextValue(typeScopedContext, type, '@context');

            if (_isUndefined(ctx)) {
              _context.next = 94;
              break;
            }

            _context.next = 93;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: ctx,
              options: options,
              propagate: false
            });

          case 93:
            activeCtx = _context.sent;

          case 94:
            _context.next = 87;
            break;

          case 96:
            _context.next = 101;
            break;

          case 98:
            _context.prev = 98;
            _context.t1 = _context["catch"](85);

            _iterator3.e(_context.t1);

          case 101:
            _context.prev = 101;

            _iterator3.f();

            return _context.finish(101);

          case 104:
            _context.next = 77;
            break;

          case 106:
            _context.next = 111;
            break;

          case 108:
            _context.prev = 108;
            _context.t2 = _context["catch"](75);

            _iterator2.e(_context.t2);

          case 111:
            _context.prev = 111;

            _iterator2.f();

            return _context.finish(111);

          case 114:
            // process each key and value in element, ignoring @nest content
            rval = {};
            _context.next = 117;
            return _expandObject({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              expandedActiveProperty: expandedActiveProperty,
              element: element,
              expandedParent: rval,
              options: options,
              insideList: insideList,
              typeKey: typeKey,
              typeScopedContext: typeScopedContext,
              expansionMap: expansionMap
            });

          case 117:
            // get property count on expanded output
            keys = Object.keys(rval);
            count = keys.length;

            if (!('@value' in rval)) {
              _context.next = 149;
              break;
            }

            if (!('@type' in rval && ('@language' in rval || '@direction' in rval))) {
              _context.next = 122;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may not ' + 'contain both "@type" and either "@language" or "@direction".', 'jsonld.SyntaxError', {
              code: 'invalid value object',
              element: rval
            });

          case 122:
            validCount = count - 1;

            if ('@type' in rval) {
              validCount -= 1;
            }

            if ('@index' in rval) {
              validCount -= 1;
            }

            if ('@language' in rval) {
              validCount -= 1;
            }

            if ('@direction' in rval) {
              validCount -= 1;
            }

            if (!(validCount !== 0)) {
              _context.next = 129;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may only ' + 'have an "@index" property and either "@type" ' + 'or either or both "@language" or "@direction".', 'jsonld.SyntaxError', {
              code: 'invalid value object',
              element: rval
            });

          case 129:
            values = rval['@value'] === null ? [] : _asArray(rval['@value']);
            types = _getValues(rval, '@type'); // drop null @values unless custom mapped

            if (!(_processingMode(activeCtx, 1.1) && types.includes('@json') && types.length === 1)) {
              _context.next = 134;
              break;
            }

            _context.next = 147;
            break;

          case 134:
            if (!(values.length === 0)) {
              _context.next = 141;
              break;
            }

            _context.next = 137;
            return expansionMap({
              unmappedValue: rval,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element,
              options: options,
              insideList: insideList
            });

          case 137:
            _mapped = _context.sent;

            if (_mapped !== undefined) {
              rval = _mapped;
            } else {
              rval = null;
            }

            _context.next = 147;
            break;

          case 141:
            if (!(!values.every(function (v) {
              return _isString(v) || _isEmptyObject(v);
            }) && '@language' in rval)) {
              _context.next = 145;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; only strings may be language-tagged.', 'jsonld.SyntaxError', {
              code: 'invalid language-tagged value',
              element: rval
            });

          case 145:
            if (types.every(function (t) {
              return _isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) || _isEmptyObject(t);
            })) {
              _context.next = 147;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" and "@type" ' + 'must have an absolute IRI for the value of "@type".', 'jsonld.SyntaxError', {
              code: 'invalid typed value',
              element: rval
            });

          case 147:
            _context.next = 164;
            break;

          case 149:
            if (!('@type' in rval && !_isArray(rval['@type']))) {
              _context.next = 153;
              break;
            }

            // convert @type to an array
            rval['@type'] = [rval['@type']];
            _context.next = 164;
            break;

          case 153:
            if (!('@set' in rval || '@list' in rval)) {
              _context.next = 159;
              break;
            }

            if (!(count > 1 && !(count === 2 && '@index' in rval))) {
              _context.next = 156;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property "@set" ' + 'or "@list", then it can have at most one other property that is ' + '"@index".', 'jsonld.SyntaxError', {
              code: 'invalid set or list object',
              element: rval
            });

          case 156:
            // optimize away @set
            if ('@set' in rval) {
              rval = rval['@set'];
              keys = Object.keys(rval);
              count = keys.length;
            }

            _context.next = 164;
            break;

          case 159:
            if (!(count === 1 && '@language' in rval)) {
              _context.next = 164;
              break;
            }

            _context.next = 162;
            return expansionMap(rval, {
              unmappedValue: rval,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element,
              options: options,
              insideList: insideList
            });

          case 162:
            _mapped2 = _context.sent;

            if (_mapped2 !== undefined) {
              rval = _mapped2;
            } else {
              rval = null;
            }

          case 164:
            if (!(_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === '@graph'))) {
              _context.next = 170;
              break;
            }

            if (!(count === 0 || '@value' in rval || '@list' in rval || count === 1 && '@id' in rval)) {
              _context.next = 170;
              break;
            }

            _context.next = 168;
            return expansionMap({
              unmappedValue: rval,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element,
              options: options,
              insideList: insideList
            });

          case 168:
            _mapped3 = _context.sent;

            if (_mapped3 !== undefined) {
              rval = _mapped3;
            } else {
              rval = null;
            }

          case 170:
            return _context.abrupt("return", rval);

          case 171:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[41, 57, 60, 63], [75, 108, 111, 114], [85, 98, 101, 104]]);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Expand each key and value of element adding to result
 *
 * @param activeCtx the context to use.
 * @param activeProperty the property for the element.
 * @param expandedActiveProperty the expansion of activeProperty
 * @param element the element to expand.
 * @param expandedParent the expanded result into which to add values.
 * @param options the expansion options.
 * @param insideList true if the element is a list, false if not.
 * @param typeKey first key found expanding to @type.
 * @param typeScopedContext the context before reverting.
 * @param expansionMap(info) a function that can be used to custom map
 *          unmappable values (or to throw an error when they are detected);
 *          if this function returns `undefined` then the default behavior
 *          will be used.
 */


function _expandObject(_x2) {
  return _expandObject2.apply(this, arguments);
}
/**
 * Expands the given value by using the coercion and keyword rules in the
 * given context.
 *
 * @param activeCtx the active context to use.
 * @param activeProperty the active property the value is associated with.
 * @param value the value to expand.
 * @param {Object} [options] - processing options.
 *
 * @return the expanded value.
 */


function _expandObject2() {
  _expandObject2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref3) {
    var activeCtx, activeProperty, expandedActiveProperty, element, expandedParent, _ref3$options, options, insideList, typeKey, typeScopedContext, expansionMap, keys, nests, unexpandedValue, isJsonType, _iterator6, _step6, _key2, value, expandedValue, expandedProperty, includedResult, _iterator8, _step8, lang, _iterator9, _step9, dir, property, reverseMap, _property, items, ii, item, termCtx, ctx, container, direction, asGraph, indexKey, propertyIndex, _asGraph, isList, nextActiveProperty, _reverseMap, _ii, _item, _i, _nests, key, nestedValues, _iterator7, _step7, nv;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            activeCtx = _ref3.activeCtx, activeProperty = _ref3.activeProperty, expandedActiveProperty = _ref3.expandedActiveProperty, element = _ref3.element, expandedParent = _ref3.expandedParent, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, insideList = _ref3.insideList, typeKey = _ref3.typeKey, typeScopedContext = _ref3.typeScopedContext, expansionMap = _ref3.expansionMap;
            keys = Object.keys(element).sort();
            nests = [];
            // Figure out if this is the type for a JSON literal
            isJsonType = element[typeKey] && _expandIri(activeCtx, _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey], {
              vocab: true
            }, options) === '@json';
            _iterator6 = _createForOfIteratorHelper(keys);
            _context2.prev = 5;

            _iterator6.s();

          case 7:
            if ((_step6 = _iterator6.n()).done) {
              _context2.next = 202;
              break;
            }

            _key2 = _step6.value;
            value = element[_key2];
            expandedValue = void 0; // skip @context

            if (!(_key2 === '@context')) {
              _context2.next = 13;
              break;
            }

            return _context2.abrupt("continue", 200);

          case 13:
            // expand property
            expandedProperty = _expandIri(activeCtx, _key2, {
              vocab: true
            }, options); // drop non-absolute IRI keys that aren't keywords unless custom mapped

            if (!(expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty)))) {
              _context2.next = 18;
              break;
            }

            // TODO: use `await` to support async
            expandedProperty = expansionMap({
              unmappedProperty: _key2,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              parent: element,
              options: options,
              insideList: insideList,
              value: value,
              expandedParent: expandedParent
            });

            if (!(expandedProperty === undefined)) {
              _context2.next = 18;
              break;
            }

            return _context2.abrupt("continue", 200);

          case 18:
            if (!_isKeyword(expandedProperty)) {
              _context2.next = 23;
              break;
            }

            if (!(expandedActiveProperty === '@reverse')) {
              _context2.next = 21;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' + 'property.', 'jsonld.SyntaxError', {
              code: 'invalid reverse property map',
              value: value
            });

          case 21:
            if (!(expandedProperty in expandedParent && expandedProperty !== '@included' && expandedProperty !== '@type')) {
              _context2.next = 23;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; colliding keywords detected.', 'jsonld.SyntaxError', {
              code: 'colliding keywords',
              keyword: expandedProperty
            });

          case 23:
            if (!(expandedProperty === '@id')) {
              _context2.next = 40;
              break;
            }

            if (_isString(value)) {
              _context2.next = 38;
              break;
            }

            if (options.isFrame) {
              _context2.next = 27;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value must a string.', 'jsonld.SyntaxError', {
              code: 'invalid @id value',
              value: value
            });

          case 27:
            if (!_isObject(value)) {
              _context2.next = 32;
              break;
            }

            if (_isEmptyObject(value)) {
              _context2.next = 30;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {
              code: 'invalid @id value',
              value: value
            });

          case 30:
            _context2.next = 38;
            break;

          case 32:
            if (!_isArray(value)) {
              _context2.next = 37;
              break;
            }

            if (value.every(function (v) {
              return _isString(v);
            })) {
              _context2.next = 35;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {
              code: 'invalid @id value',
              value: value
            });

          case 35:
            _context2.next = 38;
            break;

          case 37:
            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {
              code: 'invalid @id value',
              value: value
            });

          case 38:
            _addValue(expandedParent, '@id', _asArray(value).map(function (v) {
              return _isString(v) ? _expandIri(activeCtx, v, {
                base: true
              }, options) : v;
            }), {
              propertyIsArray: options.isFrame
            });

            return _context2.abrupt("continue", 200);

          case 40:
            if (!(expandedProperty === '@type')) {
              _context2.next = 45;
              break;
            }

            // if framing, can be a default object, but need to expand
            // key to determine that
            if (_isObject(value)) {
              value = Object.fromEntries(Object.entries(value).map(function (_ref6) {
                var _ref7 = (0, _slicedToArray2["default"])(_ref6, 2),
                    k = _ref7[0],
                    v = _ref7[1];

                return [_expandIri(typeScopedContext, k, {
                  vocab: true
                }), _asArray(v).map(function (vv) {
                  return _expandIri(typeScopedContext, vv, {
                    base: true,
                    vocab: true
                  });
                })];
              }));
            }

            _validateTypeValue(value, options.isFrame);

            _addValue(expandedParent, '@type', _asArray(value).map(function (v) {
              return _isString(v) ? _expandIri(typeScopedContext, v, {
                base: true,
                vocab: true
              }, options) : v;
            }), {
              propertyIsArray: options.isFrame
            });

            return _context2.abrupt("continue", 200);

          case 45:
            if (!(expandedProperty === '@included' && _processingMode(activeCtx, 1.1))) {
              _context2.next = 55;
              break;
            }

            _context2.t0 = _asArray;
            _context2.next = 49;
            return api.expand({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: value,
              options: options,
              expansionMap: expansionMap
            });

          case 49:
            _context2.t1 = _context2.sent;
            includedResult = (0, _context2.t0)(_context2.t1);

            if (includedResult.every(function (v) {
              return _isSubject(v);
            })) {
              _context2.next = 53;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; ' + 'values of @included must expand to node objects.', 'jsonld.SyntaxError', {
              code: 'invalid @included value',
              value: value
            });

          case 53:
            _addValue(expandedParent, '@included', includedResult, {
              propertyIsArray: true
            });

            return _context2.abrupt("continue", 200);

          case 55:
            if (!(expandedProperty === '@graph' && !(_isObject(value) || _isArray(value)))) {
              _context2.next = 57;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@graph" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {
              code: 'invalid @graph value',
              value: value
            });

          case 57:
            if (!(expandedProperty === '@value')) {
              _context2.next = 61;
              break;
            }

            // capture value for later
            // "colliding keywords" check prevents this from being set twice
            unexpandedValue = value;

            if (isJsonType && _processingMode(activeCtx, 1.1)) {
              // no coercion to array, and retain all values
              expandedParent['@value'] = value;
            } else {
              _addValue(expandedParent, '@value', value, {
                propertyIsArray: options.isFrame
              });
            }

            return _context2.abrupt("continue", 200);

          case 61:
            if (!(expandedProperty === '@language')) {
              _context2.next = 71;
              break;
            }

            if (!(value === null)) {
              _context2.next = 64;
              break;
            }

            return _context2.abrupt("continue", 200);

          case 64:
            if (!(!_isString(value) && !options.isFrame)) {
              _context2.next = 66;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@language" value must be a string.', 'jsonld.SyntaxError', {
              code: 'invalid language-tagged string',
              value: value
            });

          case 66:
            // ensure language value is lowercase
            value = _asArray(value).map(function (v) {
              return _isString(v) ? v.toLowerCase() : v;
            }); // ensure language tag matches BCP47

            _iterator8 = _createForOfIteratorHelper(value);

            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                lang = _step8.value;

                if (_isString(lang) && !lang.match(REGEX_BCP47)) {
                  console.warn("@language must be valid BCP47: ".concat(lang));
                }
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }

            _addValue(expandedParent, '@language', value, {
              propertyIsArray: options.isFrame
            });

            return _context2.abrupt("continue", 200);

          case 71:
            if (!(expandedProperty === '@direction')) {
              _context2.next = 94;
              break;
            }

            if (!(!_isString(value) && !options.isFrame)) {
              _context2.next = 74;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@direction" value must be a string.', 'jsonld.SyntaxError', {
              code: 'invalid base direction',
              value: value
            });

          case 74:
            value = _asArray(value); // ensure direction is "ltr" or "rtl"

            _iterator9 = _createForOfIteratorHelper(value);
            _context2.prev = 76;

            _iterator9.s();

          case 78:
            if ((_step9 = _iterator9.n()).done) {
              _context2.next = 84;
              break;
            }

            dir = _step9.value;

            if (!(_isString(dir) && dir !== 'ltr' && dir !== 'rtl')) {
              _context2.next = 82;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".', 'jsonld.SyntaxError', {
              code: 'invalid base direction',
              value: value
            });

          case 82:
            _context2.next = 78;
            break;

          case 84:
            _context2.next = 89;
            break;

          case 86:
            _context2.prev = 86;
            _context2.t2 = _context2["catch"](76);

            _iterator9.e(_context2.t2);

          case 89:
            _context2.prev = 89;

            _iterator9.f();

            return _context2.finish(89);

          case 92:
            _addValue(expandedParent, '@direction', value, {
              propertyIsArray: options.isFrame
            });

            return _context2.abrupt("continue", 200);

          case 94:
            if (!(expandedProperty === '@index')) {
              _context2.next = 99;
              break;
            }

            if (_isString(value)) {
              _context2.next = 97;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@index" value must be a string.', 'jsonld.SyntaxError', {
              code: 'invalid @index value',
              value: value
            });

          case 97:
            _addValue(expandedParent, '@index', value);

            return _context2.abrupt("continue", 200);

          case 99:
            if (!(expandedProperty === '@reverse')) {
              _context2.next = 127;
              break;
            }

            if (_isObject(value)) {
              _context2.next = 102;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must be an object.', 'jsonld.SyntaxError', {
              code: 'invalid @reverse value',
              value: value
            });

          case 102:
            _context2.next = 104;
            return api.expand({
              activeCtx: activeCtx,
              activeProperty: '@reverse',
              element: value,
              options: options,
              expansionMap: expansionMap
            });

          case 104:
            expandedValue = _context2.sent;

            // properties double-reversed
            if ('@reverse' in expandedValue) {
              for (property in expandedValue['@reverse']) {
                _addValue(expandedParent, property, expandedValue['@reverse'][property], {
                  propertyIsArray: true
                });
              }
            } // FIXME: can this be merged with code below to simplify?
            // merge in all reversed properties


            reverseMap = expandedParent['@reverse'] || null;
            _context2.t3 = _regenerator["default"].keys(expandedValue);

          case 108:
            if ((_context2.t4 = _context2.t3()).done) {
              _context2.next = 126;
              break;
            }

            _property = _context2.t4.value;

            if (!(_property === '@reverse')) {
              _context2.next = 112;
              break;
            }

            return _context2.abrupt("continue", 108);

          case 112:
            if (reverseMap === null) {
              reverseMap = expandedParent['@reverse'] = {};
            }

            _addValue(reverseMap, _property, [], {
              propertyIsArray: true
            });

            items = expandedValue[_property];
            ii = 0;

          case 116:
            if (!(ii < items.length)) {
              _context2.next = 124;
              break;
            }

            item = items[ii];

            if (!(_isValue(item) || _isList(item))) {
              _context2.next = 120;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {
              code: 'invalid reverse property value',
              value: expandedValue
            });

          case 120:
            _addValue(reverseMap, _property, item, {
              propertyIsArray: true
            });

          case 121:
            ++ii;
            _context2.next = 116;
            break;

          case 124:
            _context2.next = 108;
            break;

          case 126:
            return _context2.abrupt("continue", 200);

          case 127:
            if (!(expandedProperty === '@nest')) {
              _context2.next = 130;
              break;
            }

            nests.push(_key2);
            return _context2.abrupt("continue", 200);

          case 130:
            // use potential scoped context for key
            termCtx = activeCtx;
            ctx = _getContextValue(activeCtx, _key2, '@context');

            if (_isUndefined(ctx)) {
              _context2.next = 136;
              break;
            }

            _context2.next = 135;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: ctx,
              propagate: true,
              overrideProtected: true,
              options: options
            });

          case 135:
            termCtx = _context2.sent;

          case 136:
            container = _getContextValue(termCtx, _key2, '@container') || [];

            if (!(container.includes('@language') && _isObject(value))) {
              _context2.next = 142;
              break;
            }

            direction = _getContextValue(termCtx, _key2, '@direction'); // handle language map container (skip if value is not an object)

            expandedValue = _expandLanguageMap(termCtx, value, direction, options);
            _context2.next = 180;
            break;

          case 142:
            if (!(container.includes('@index') && _isObject(value))) {
              _context2.next = 151;
              break;
            }

            // handle index container (skip if value is not an object)
            asGraph = container.includes('@graph');
            indexKey = _getContextValue(termCtx, _key2, '@index') || '@index';
            propertyIndex = indexKey !== '@index' && _expandIri(activeCtx, indexKey, {
              vocab: true
            }, options);
            _context2.next = 148;
            return _expandIndexMap({
              activeCtx: termCtx,
              options: options,
              activeProperty: _key2,
              value: value,
              expansionMap: expansionMap,
              asGraph: asGraph,
              indexKey: indexKey,
              propertyIndex: propertyIndex
            });

          case 148:
            expandedValue = _context2.sent;
            _context2.next = 180;
            break;

          case 151:
            if (!(container.includes('@id') && _isObject(value))) {
              _context2.next = 158;
              break;
            }

            // handle id container (skip if value is not an object)
            _asGraph = container.includes('@graph');
            _context2.next = 155;
            return _expandIndexMap({
              activeCtx: termCtx,
              options: options,
              activeProperty: _key2,
              value: value,
              expansionMap: expansionMap,
              asGraph: _asGraph,
              indexKey: '@id'
            });

          case 155:
            expandedValue = _context2.sent;
            _context2.next = 180;
            break;

          case 158:
            if (!(container.includes('@type') && _isObject(value))) {
              _context2.next = 164;
              break;
            }

            _context2.next = 161;
            return _expandIndexMap({
              // since container is `@type`, revert type scoped context when expanding
              activeCtx: termCtx.revertToPreviousContext(),
              options: options,
              activeProperty: _key2,
              value: value,
              expansionMap: expansionMap,
              asGraph: false,
              indexKey: '@type'
            });

          case 161:
            expandedValue = _context2.sent;
            _context2.next = 180;
            break;

          case 164:
            // recurse into @list or @set
            isList = expandedProperty === '@list';

            if (!(isList || expandedProperty === '@set')) {
              _context2.next = 173;
              break;
            }

            nextActiveProperty = activeProperty;

            if (isList && expandedActiveProperty === '@graph') {
              nextActiveProperty = null;
            }

            _context2.next = 170;
            return api.expand({
              activeCtx: termCtx,
              activeProperty: nextActiveProperty,
              element: value,
              options: options,
              insideList: isList,
              expansionMap: expansionMap
            });

          case 170:
            expandedValue = _context2.sent;
            _context2.next = 180;
            break;

          case 173:
            if (!(_getContextValue(activeCtx, _key2, '@type') === '@json')) {
              _context2.next = 177;
              break;
            }

            expandedValue = {
              '@type': '@json',
              '@value': value
            };
            _context2.next = 180;
            break;

          case 177:
            _context2.next = 179;
            return api.expand({
              activeCtx: termCtx,
              activeProperty: _key2,
              element: value,
              options: options,
              insideList: false,
              expansionMap: expansionMap
            });

          case 179:
            expandedValue = _context2.sent;

          case 180:
            if (!(expandedValue === null && expandedProperty !== '@value')) {
              _context2.next = 184;
              break;
            }

            // TODO: use `await` to support async
            expandedValue = expansionMap({
              unmappedValue: value,
              expandedProperty: expandedProperty,
              activeCtx: termCtx,
              activeProperty: activeProperty,
              parent: element,
              options: options,
              insideList: insideList,
              key: _key2,
              expandedParent: expandedParent
            });

            if (!(expandedValue === undefined)) {
              _context2.next = 184;
              break;
            }

            return _context2.abrupt("continue", 200);

          case 184:
            // convert expanded value to @list if container specifies it
            if (expandedProperty !== '@list' && !_isList(expandedValue) && container.includes('@list')) {
              // ensure expanded value in @list is an array
              expandedValue = {
                '@list': _asArray(expandedValue)
              };
            } // convert expanded value to @graph if container specifies it
            // and value is not, itself, a graph
            // index cases handled above


            if (container.includes('@graph') && !container.some(function (key) {
              return key === '@id' || key === '@index';
            })) {
              // ensure expanded values are arrays
              expandedValue = _asArray(expandedValue).map(function (v) {
                return {
                  '@graph': _asArray(v)
                };
              });
            } // FIXME: can this be merged with code above to simplify?
            // merge in reverse properties


            if (!(termCtx.mappings.has(_key2) && termCtx.mappings.get(_key2).reverse)) {
              _context2.next = 199;
              break;
            }

            _reverseMap = expandedParent['@reverse'] = expandedParent['@reverse'] || {};
            expandedValue = _asArray(expandedValue);
            _ii = 0;

          case 190:
            if (!(_ii < expandedValue.length)) {
              _context2.next = 198;
              break;
            }

            _item = expandedValue[_ii];

            if (!(_isValue(_item) || _isList(_item))) {
              _context2.next = 194;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {
              code: 'invalid reverse property value',
              value: expandedValue
            });

          case 194:
            _addValue(_reverseMap, expandedProperty, _item, {
              propertyIsArray: true
            });

          case 195:
            ++_ii;
            _context2.next = 190;
            break;

          case 198:
            return _context2.abrupt("continue", 200);

          case 199:
            // add value for property
            // special keywords handled above
            _addValue(expandedParent, expandedProperty, expandedValue, {
              propertyIsArray: true
            });

          case 200:
            _context2.next = 7;
            break;

          case 202:
            _context2.next = 207;
            break;

          case 204:
            _context2.prev = 204;
            _context2.t5 = _context2["catch"](5);

            _iterator6.e(_context2.t5);

          case 207:
            _context2.prev = 207;

            _iterator6.f();

            return _context2.finish(207);

          case 210:
            if (!('@value' in expandedParent)) {
              _context2.next = 216;
              break;
            }

            if (!(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1))) {
              _context2.next = 214;
              break;
            }

            _context2.next = 216;
            break;

          case 214:
            if (!((_isObject(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame)) {
              _context2.next = 216;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@value" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {
              code: 'invalid value object value',
              value: unexpandedValue
            });

          case 216:
            _i = 0, _nests = nests;

          case 217:
            if (!(_i < _nests.length)) {
              _context2.next = 242;
              break;
            }

            key = _nests[_i];
            nestedValues = _isArray(element[key]) ? element[key] : [element[key]];
            _iterator7 = _createForOfIteratorHelper(nestedValues);
            _context2.prev = 221;

            _iterator7.s();

          case 223:
            if ((_step7 = _iterator7.n()).done) {
              _context2.next = 231;
              break;
            }

            nv = _step7.value;

            if (!(!_isObject(nv) || Object.keys(nv).some(function (k) {
              return _expandIri(activeCtx, k, {
                vocab: true
              }, options) === '@value';
            }))) {
              _context2.next = 227;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; nested value must be a node object.', 'jsonld.SyntaxError', {
              code: 'invalid @nest value',
              value: nv
            });

          case 227:
            _context2.next = 229;
            return _expandObject({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              expandedActiveProperty: expandedActiveProperty,
              element: nv,
              expandedParent: expandedParent,
              options: options,
              insideList: insideList,
              typeScopedContext: typeScopedContext,
              typeKey: typeKey,
              expansionMap: expansionMap
            });

          case 229:
            _context2.next = 223;
            break;

          case 231:
            _context2.next = 236;
            break;

          case 233:
            _context2.prev = 233;
            _context2.t6 = _context2["catch"](221);

            _iterator7.e(_context2.t6);

          case 236:
            _context2.prev = 236;

            _iterator7.f();

            return _context2.finish(236);

          case 239:
            _i++;
            _context2.next = 217;
            break;

          case 242:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[5, 204, 207, 210], [76, 86, 89, 92], [221, 233, 236, 239]]);
  }));
  return _expandObject2.apply(this, arguments);
}

function _expandValue(_ref4) {
  var activeCtx = _ref4.activeCtx,
      activeProperty = _ref4.activeProperty,
      value = _ref4.value,
      options = _ref4.options;

  // nothing to expand
  if (value === null || value === undefined) {
    return null;
  } // special-case expand @id and @type (skips '@id' expansion)


  var expandedProperty = _expandIri(activeCtx, activeProperty, {
    vocab: true
  }, options);

  if (expandedProperty === '@id') {
    return _expandIri(activeCtx, value, {
      base: true
    }, options);
  } else if (expandedProperty === '@type') {
    return _expandIri(activeCtx, value, {
      vocab: true,
      base: true
    }, options);
  } // get type definition from context


  var type = _getContextValue(activeCtx, activeProperty, '@type'); // do @id expansion (automatic for @graph)


  if ((type === '@id' || expandedProperty === '@graph') && _isString(value)) {
    return {
      '@id': _expandIri(activeCtx, value, {
        base: true
      }, options)
    };
  } // do @id expansion w/vocab


  if (type === '@vocab' && _isString(value)) {
    return {
      '@id': _expandIri(activeCtx, value, {
        vocab: true,
        base: true
      }, options)
    };
  } // do not expand keyword values


  if (_isKeyword(expandedProperty)) {
    return value;
  }

  var rval = {};

  if (type && !['@id', '@vocab', '@none'].includes(type)) {
    // other type
    rval['@type'] = type;
  } else if (_isString(value)) {
    // check for language tagging for strings
    var language = _getContextValue(activeCtx, activeProperty, '@language');

    if (language !== null) {
      rval['@language'] = language;
    }

    var direction = _getContextValue(activeCtx, activeProperty, '@direction');

    if (direction !== null) {
      rval['@direction'] = direction;
    }
  } // do conversion of values that aren't basic JSON types to strings


  if (!['boolean', 'number', 'string'].includes((0, _typeof2["default"])(value))) {
    value = value.toString();
  }

  rval['@value'] = value;
  return rval;
}
/**
 * Expands a language map.
 *
 * @param activeCtx the active context to use.
 * @param languageMap the language map to expand.
 * @param direction the direction to apply to values.
 * @param {Object} [options] - processing options.
 *
 * @return the expanded language map.
 */


function _expandLanguageMap(activeCtx, languageMap, direction, options) {
  var rval = [];
  var keys = Object.keys(languageMap).sort();

  var _iterator4 = _createForOfIteratorHelper(keys),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var key = _step4.value;

      var expandedKey = _expandIri(activeCtx, key, {
        vocab: true
      }, options);

      var val = languageMap[key];

      if (!_isArray(val)) {
        val = [val];
      }

      var _iterator5 = _createForOfIteratorHelper(val),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var item = _step5.value;

          if (item === null) {
            // null values are allowed (8.5) but ignored (3.1)
            continue;
          }

          if (!_isString(item)) {
            throw new JsonLdError('Invalid JSON-LD syntax; language map values must be strings.', 'jsonld.SyntaxError', {
              code: 'invalid language map value',
              languageMap: languageMap
            });
          }

          var _val = {
            '@value': item
          };

          if (expandedKey !== '@none') {
            _val['@language'] = key.toLowerCase();
          }

          if (direction) {
            _val['@direction'] = direction;
          }

          rval.push(_val);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return rval;
}

function _expandIndexMap(_x3) {
  return _expandIndexMap2.apply(this, arguments);
}

function _expandIndexMap2() {
  _expandIndexMap2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref5) {
    var activeCtx, options, activeProperty, value, expansionMap, asGraph, indexKey, propertyIndex, rval, keys, isTypeIndex, _iterator10, _step10, key, ctx, val, expandedKey, _iterator11, _step11, item;

    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            activeCtx = _ref5.activeCtx, options = _ref5.options, activeProperty = _ref5.activeProperty, value = _ref5.value, expansionMap = _ref5.expansionMap, asGraph = _ref5.asGraph, indexKey = _ref5.indexKey, propertyIndex = _ref5.propertyIndex;
            rval = [];
            keys = Object.keys(value).sort();
            isTypeIndex = indexKey === '@type';
            _iterator10 = _createForOfIteratorHelper(keys);
            _context3.prev = 5;

            _iterator10.s();

          case 7:
            if ((_step10 = _iterator10.n()).done) {
              _context3.next = 51;
              break;
            }

            key = _step10.value;

            if (!isTypeIndex) {
              _context3.next = 15;
              break;
            }

            ctx = _getContextValue(activeCtx, key, '@context');

            if (_isUndefined(ctx)) {
              _context3.next = 15;
              break;
            }

            _context3.next = 14;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: ctx,
              propagate: false,
              options: options
            });

          case 14:
            activeCtx = _context3.sent;

          case 15:
            val = value[key];

            if (!_isArray(val)) {
              val = [val];
            }

            _context3.next = 19;
            return api.expand({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: val,
              options: options,
              insideList: false,
              insideIndex: true,
              expansionMap: expansionMap
            });

          case 19:
            val = _context3.sent;
            // expand for @type, but also for @none
            expandedKey = void 0;

            if (propertyIndex) {
              if (key === '@none') {
                expandedKey = '@none';
              } else {
                expandedKey = _expandValue({
                  activeCtx: activeCtx,
                  activeProperty: indexKey,
                  value: key,
                  options: options
                });
              }
            } else {
              expandedKey = _expandIri(activeCtx, key, {
                vocab: true
              }, options);
            }

            if (indexKey === '@id') {
              // expand document relative
              key = _expandIri(activeCtx, key, {
                base: true
              }, options);
            } else if (isTypeIndex) {
              key = expandedKey;
            }

            _iterator11 = _createForOfIteratorHelper(val);
            _context3.prev = 24;

            _iterator11.s();

          case 26:
            if ((_step11 = _iterator11.n()).done) {
              _context3.next = 41;
              break;
            }

            item = _step11.value;

            // If this is also a @graph container, turn items into graphs
            if (asGraph && !_isGraph(item)) {
              item = {
                '@graph': [item]
              };
            }

            if (!(indexKey === '@type')) {
              _context3.next = 33;
              break;
            }

            if (expandedKey === '@none') {// ignore @none
            } else if (item['@type']) {
              item['@type'] = [key].concat(item['@type']);
            } else {
              item['@type'] = [key];
            }

            _context3.next = 38;
            break;

          case 33:
            if (!(_isValue(item) && !['@language', '@type', '@index'].includes(indexKey))) {
              _context3.next = 37;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; Attempt to add illegal key to value ' + "object: \"".concat(indexKey, "\"."), 'jsonld.SyntaxError', {
              code: 'invalid value object',
              value: item
            });

          case 37:
            if (propertyIndex) {
              // index is a property to be expanded, and values interpreted for that
              // property
              if (expandedKey !== '@none') {
                // expand key as a value
                _addValue(item, propertyIndex, expandedKey, {
                  propertyIsArray: true,
                  prependValue: true
                });
              }
            } else if (expandedKey !== '@none' && !(indexKey in item)) {
              item[indexKey] = key;
            }

          case 38:
            rval.push(item);

          case 39:
            _context3.next = 26;
            break;

          case 41:
            _context3.next = 46;
            break;

          case 43:
            _context3.prev = 43;
            _context3.t0 = _context3["catch"](24);

            _iterator11.e(_context3.t0);

          case 46:
            _context3.prev = 46;

            _iterator11.f();

            return _context3.finish(46);

          case 49:
            _context3.next = 7;
            break;

          case 51:
            _context3.next = 56;
            break;

          case 53:
            _context3.prev = 53;
            _context3.t1 = _context3["catch"](5);

            _iterator10.e(_context3.t1);

          case 56:
            _context3.prev = 56;

            _iterator10.f();

            return _context3.finish(56);

          case 59:
            return _context3.abrupt("return", rval);

          case 60:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[5, 53, 56, 59], [24, 43, 46, 49]]);
  }));
  return _expandIndexMap2.apply(this, arguments);
}

},{"./JsonLdError":91,"./context":99,"./graphTypes":106,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/typeof":27,"@babel/runtime/regenerator":30}],103:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _require = require('./graphTypes'),
    _isSubjectReference = _require.isSubjectReference;

var _require2 = require('./nodeMap'),
    _createMergedNodeMap = _require2.createMergedNodeMap;

var api = {};
module.exports = api;
/**
 * Performs JSON-LD flattening.
 *
 * @param input the expanded JSON-LD to flatten.
 *
 * @return the flattened output.
 */

api.flatten = function (input) {
  var defaultGraph = _createMergedNodeMap(input); // produce flattened output


  var flattened = [];
  var keys = Object.keys(defaultGraph).sort();

  for (var ki = 0; ki < keys.length; ++ki) {
    var node = defaultGraph[keys[ki]]; // only add full subjects to top-level

    if (!_isSubjectReference(node)) {
      flattened.push(node);
    }
  }

  return flattened;
};

},{"./graphTypes":106,"./nodeMap":108}],104:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('./context'),
    isKeyword = _require.isKeyword;

var graphTypes = require('./graphTypes');

var types = require('./types');

var util = require('./util');

var url = require('./url');

var JsonLdError = require('./JsonLdError');

var _require2 = require('./nodeMap'),
    _createNodeMap = _require2.createNodeMap,
    _mergeNodeMapGraphs = _require2.mergeNodeMapGraphs;

var api = {};
module.exports = api;
/**
 * Performs JSON-LD `merged` framing.
 *
 * @param input the expanded JSON-LD to frame.
 * @param frame the expanded JSON-LD frame to use.
 * @param options the framing options.
 *
 * @return the framed output.
 */

api.frameMergedOrDefault = function (input, frame, options) {
  // create framing state
  var state = {
    options: options,
    embedded: false,
    graph: '@default',
    graphMap: {
      '@default': {}
    },
    subjectStack: [],
    link: {},
    bnodeMap: {}
  }; // produce a map of all graphs and name each bnode
  // FIXME: currently uses subjects from @merged graph only

  var issuer = new util.IdentifierIssuer('_:b');

  _createNodeMap(input, state.graphMap, '@default', issuer);

  if (options.merged) {
    state.graphMap['@merged'] = _mergeNodeMapGraphs(state.graphMap);
    state.graph = '@merged';
  }

  state.subjects = state.graphMap[state.graph]; // frame the subjects

  var framed = [];
  api.frame(state, Object.keys(state.subjects).sort(), frame, framed); // If pruning blank nodes, find those to prune

  if (options.pruneBlankNodeIdentifiers) {
    // remove all blank nodes appearing only once, done in compaction
    options.bnodesToClear = Object.keys(state.bnodeMap).filter(function (id) {
      return state.bnodeMap[id].length === 1;
    });
  } // remove @preserve from results


  options.link = {};
  return _cleanupPreserve(framed, options);
};
/**
 * Frames subjects according to the given frame.
 *
 * @param state the current framing state.
 * @param subjects the subjects to filter.
 * @param frame the frame.
 * @param parent the parent subject or top-level array.
 * @param property the parent property, initialized to null.
 */


api.frame = function (state, subjects, frame, parent) {
  var property = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

  // validate the frame
  _validateFrame(frame);

  frame = frame[0]; // get flags for current frame

  var options = state.options;
  var flags = {
    embed: _getFrameFlag(frame, options, 'embed'),
    explicit: _getFrameFlag(frame, options, 'explicit'),
    requireAll: _getFrameFlag(frame, options, 'requireAll')
  }; // get link for current graph

  if (!state.link.hasOwnProperty(state.graph)) {
    state.link[state.graph] = {};
  }

  var link = state.link[state.graph]; // filter out subjects that match the frame

  var matches = _filterSubjects(state, subjects, frame, flags); // add matches to output


  var ids = Object.keys(matches).sort();

  var _iterator = _createForOfIteratorHelper(ids),
      _step;

  try {
    var _loop = function _loop() {
      var id = _step.value;
      var subject = matches[id];
      /* Note: In order to treat each top-level match as a compartmentalized
      result, clear the unique embedded subjects map when the property is null,
      which only occurs at the top-level. */

      if (property === null) {
        state.uniqueEmbeds = (0, _defineProperty2["default"])({}, state.graph, {});
      } else {
        state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};
      }

      if (flags.embed === '@link' && id in link) {
        // TODO: may want to also match an existing linked subject against
        // the current frame ... so different frames could produce different
        // subjects that are only shared in-memory when the frames are the same
        // add existing linked subject
        _addFrameOutput(parent, property, link[id]);

        return "continue";
      } // start output for subject


      var output = {
        '@id': id
      };

      if (id.indexOf('_:') === 0) {
        util.addValue(state.bnodeMap, id, output, {
          propertyIsArray: true
        });
      }

      link[id] = output; // validate @embed

      if ((flags.embed === '@first' || flags.embed === '@last') && state.is11) {
        throw new JsonLdError('Invalid JSON-LD syntax; invalid value of @embed.', 'jsonld.SyntaxError', {
          code: 'invalid @embed value',
          frame: frame
        });
      }

      if (!state.embedded && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
        // skip adding this node object to the top level, as it was
        // already included in another node object
        return "continue";
      } // if embed is @never or if a circular reference would be created by an
      // embed, the subject cannot be embedded, just add the reference;
      // note that a circular reference won't occur when the embed flag is
      // `@link` as the above check will short-circuit before reaching this point


      if (state.embedded && (flags.embed === '@never' || _createsCircularReference(subject, state.graph, state.subjectStack))) {
        _addFrameOutput(parent, property, output);

        return "continue";
      } // if only the first (or once) should be embedded


      if (state.embedded && (flags.embed == '@first' || flags.embed == '@once') && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
        _addFrameOutput(parent, property, output);

        return "continue";
      } // if only the last match should be embedded


      if (flags.embed === '@last') {
        // remove any existing embed
        if (id in state.uniqueEmbeds[state.graph]) {
          _removeEmbed(state, id);
        }
      }

      state.uniqueEmbeds[state.graph][id] = {
        parent: parent,
        property: property
      }; // push matching subject onto stack to enable circular embed checks

      state.subjectStack.push({
        subject: subject,
        graph: state.graph
      }); // subject is also the name of a graph

      if (id in state.graphMap) {
        var recurse = false;
        var subframe = null;

        if (!('@graph' in frame)) {
          recurse = state.graph !== '@merged';
          subframe = {};
        } else {
          subframe = frame['@graph'][0];
          recurse = !(id === '@merged' || id === '@default');

          if (!types.isObject(subframe)) {
            subframe = {};
          }
        }

        if (recurse) {
          // recurse into graph
          api.frame(_objectSpread(_objectSpread({}, state), {}, {
            graph: id,
            embedded: false
          }), Object.keys(state.graphMap[id]).sort(), [subframe], output, '@graph');
        }
      } // if frame has @included, recurse over its sub-frame


      if ('@included' in frame) {
        api.frame(_objectSpread(_objectSpread({}, state), {}, {
          embedded: false
        }), subjects, frame['@included'], output, '@included');
      } // iterate over subject properties


      var _iterator2 = _createForOfIteratorHelper(Object.keys(subject).sort()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var prop = _step2.value;

          // copy keywords to output
          if (isKeyword(prop)) {
            output[prop] = util.clone(subject[prop]);

            if (prop === '@type') {
              // count bnode values of @type
              var _iterator5 = _createForOfIteratorHelper(subject['@type']),
                  _step5;

              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  var type = _step5.value;

                  if (type.indexOf('_:') === 0) {
                    util.addValue(state.bnodeMap, type, output, {
                      propertyIsArray: true
                    });
                  }
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
            }

            continue;
          } // explicit is on and property isn't in the frame, skip processing


          if (flags.explicit && !(prop in frame)) {
            continue;
          } // add objects


          var _iterator6 = _createForOfIteratorHelper(subject[prop]),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var o = _step6.value;

              var _subframe = prop in frame ? frame[prop] : _createImplicitFrame(flags); // recurse into list


              if (graphTypes.isList(o)) {
                var _subframe2 = frame[prop] && frame[prop][0] && frame[prop][0]['@list'] ? frame[prop][0]['@list'] : _createImplicitFrame(flags); // add empty list


                var list = {
                  '@list': []
                };

                _addFrameOutput(output, prop, list); // add list objects


                var src = o['@list'];

                var _iterator7 = _createForOfIteratorHelper(src),
                    _step7;

                try {
                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                    var oo = _step7.value;

                    if (graphTypes.isSubjectReference(oo)) {
                      // recurse into subject reference
                      api.frame(_objectSpread(_objectSpread({}, state), {}, {
                        embedded: true
                      }), [oo['@id']], _subframe2, list, '@list');
                    } else {
                      // include other values automatically
                      _addFrameOutput(list, '@list', util.clone(oo));
                    }
                  }
                } catch (err) {
                  _iterator7.e(err);
                } finally {
                  _iterator7.f();
                }
              } else if (graphTypes.isSubjectReference(o)) {
                // recurse into subject reference
                api.frame(_objectSpread(_objectSpread({}, state), {}, {
                  embedded: true
                }), [o['@id']], _subframe, output, prop);
              } else if (_valueMatch(_subframe[0], o)) {
                // include other values, if they match
                _addFrameOutput(output, prop, util.clone(o));
              }
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        } // handle defaults

      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper(Object.keys(frame).sort()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _prop = _step3.value;

          // skip keywords
          if (_prop === '@type') {
            if (!types.isObject(frame[_prop][0]) || !('@default' in frame[_prop][0])) {
              continue;
            } // allow through default types

          } else if (isKeyword(_prop)) {
            continue;
          } // if omit default is off, then include default values for properties
          // that appear in the next frame but are not in the matching subject


          var next = frame[_prop][0] || {};

          var omitDefaultOn = _getFrameFlag(next, options, 'omitDefault');

          if (!omitDefaultOn && !(_prop in output)) {
            var preserve = '@null';

            if ('@default' in next) {
              preserve = util.clone(next['@default']);
            }

            if (!types.isArray(preserve)) {
              preserve = [preserve];
            }

            output[_prop] = [{
              '@preserve': preserve
            }];
          }
        } // if embed reverse values by finding nodes having this subject as a value
        // of the associated property

      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      var _iterator4 = _createForOfIteratorHelper(Object.keys(frame['@reverse'] || {}).sort()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var reverseProp = _step4.value;
          var _subframe3 = frame['@reverse'][reverseProp];

          for (var _i = 0, _Object$keys = Object.keys(state.subjects); _i < _Object$keys.length; _i++) {
            var _subject = _Object$keys[_i];
            var nodeValues = util.getValues(state.subjects[_subject], reverseProp);

            if (nodeValues.some(function (v) {
              return v['@id'] === id;
            })) {
              // node has property referencing this subject, recurse
              output['@reverse'] = output['@reverse'] || {};
              util.addValue(output['@reverse'], reverseProp, [], {
                propertyIsArray: true
              });
              api.frame(_objectSpread(_objectSpread({}, state), {}, {
                embedded: true
              }), [_subject], _subframe3, output['@reverse'][reverseProp], property);
            }
          }
        } // add output to parent

      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      _addFrameOutput(parent, property, output); // pop matching subject from circular ref-checking stack


      state.subjectStack.pop();
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};
/**
 * Replace `@null` with `null`, removing it from arrays.
 *
 * @param input the framed, compacted output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */


api.cleanupNull = function (input, options) {
  // recurse through arrays
  if (types.isArray(input)) {
    var noNulls = input.map(function (v) {
      return api.cleanupNull(v, options);
    });
    return noNulls.filter(function (v) {
      return v;
    }); // removes nulls from array
  }

  if (input === '@null') {
    return null;
  }

  if (types.isObject(input)) {
    // handle in-memory linked nodes
    if ('@id' in input) {
      var id = input['@id'];

      if (options.link.hasOwnProperty(id)) {
        var idx = options.link[id].indexOf(input);

        if (idx !== -1) {
          // already visited
          return options.link[id][idx];
        } // prevent circular visitation


        options.link[id].push(input);
      } else {
        // prevent circular visitation
        options.link[id] = [input];
      }
    }

    for (var key in input) {
      input[key] = api.cleanupNull(input[key], options);
    }
  }

  return input;
};
/**
 * Creates an implicit frame when recursing through subject matches. If
 * a frame doesn't have an explicit frame for a particular property, then
 * a wildcard child frame will be created that uses the same flags that the
 * parent frame used.
 *
 * @param flags the current framing flags.
 *
 * @return the implicit frame.
 */


function _createImplicitFrame(flags) {
  var frame = {};

  for (var key in flags) {
    if (flags[key] !== undefined) {
      frame['@' + key] = [flags[key]];
    }
  }

  return [frame];
}
/**
 * Checks the current subject stack to see if embedding the given subject
 * would cause a circular reference.
 *
 * @param subjectToEmbed the subject to embed.
 * @param graph the graph the subject to embed is in.
 * @param subjectStack the current stack of subjects.
 *
 * @return true if a circular reference would be created, false if not.
 */


function _createsCircularReference(subjectToEmbed, graph, subjectStack) {
  for (var i = subjectStack.length - 1; i >= 0; --i) {
    var subject = subjectStack[i];

    if (subject.graph === graph && subject.subject['@id'] === subjectToEmbed['@id']) {
      return true;
    }
  }

  return false;
}
/**
 * Gets the frame flag value for the given flag name.
 *
 * @param frame the frame.
 * @param options the framing options.
 * @param name the flag name.
 *
 * @return the flag value.
 */


function _getFrameFlag(frame, options, name) {
  var flag = '@' + name;
  var rval = flag in frame ? frame[flag][0] : options[name];

  if (name === 'embed') {
    // default is "@last"
    // backwards-compatibility support for "embed" maps:
    // true => "@last"
    // false => "@never"
    if (rval === true) {
      rval = '@once';
    } else if (rval === false) {
      rval = '@never';
    } else if (rval !== '@always' && rval !== '@never' && rval !== '@link' && rval !== '@first' && rval !== '@last' && rval !== '@once') {
      throw new JsonLdError('Invalid JSON-LD syntax; invalid value of @embed.', 'jsonld.SyntaxError', {
        code: 'invalid @embed value',
        frame: frame
      });
    }
  }

  return rval;
}
/**
 * Validates a JSON-LD frame, throwing an exception if the frame is invalid.
 *
 * @param frame the frame to validate.
 */


function _validateFrame(frame) {
  if (!types.isArray(frame) || frame.length !== 1 || !types.isObject(frame[0])) {
    throw new JsonLdError('Invalid JSON-LD syntax; a JSON-LD frame must be a single object.', 'jsonld.SyntaxError', {
      frame: frame
    });
  }

  if ('@id' in frame[0]) {
    var _iterator8 = _createForOfIteratorHelper(util.asArray(frame[0]['@id'])),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var id = _step8.value;

        // @id must be wildcard or an IRI
        if (!(types.isObject(id) || url.isAbsolute(id)) || types.isString(id) && id.indexOf('_:') === 0) {
          throw new JsonLdError('Invalid JSON-LD syntax; invalid @id in frame.', 'jsonld.SyntaxError', {
            code: 'invalid frame',
            frame: frame
          });
        }
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
  }

  if ('@type' in frame[0]) {
    var _iterator9 = _createForOfIteratorHelper(util.asArray(frame[0]['@type'])),
        _step9;

    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var type = _step9.value;

        // @id must be wildcard or an IRI
        if (!(types.isObject(type) || url.isAbsolute(type)) || types.isString(type) && type.indexOf('_:') === 0) {
          throw new JsonLdError('Invalid JSON-LD syntax; invalid @type in frame.', 'jsonld.SyntaxError', {
            code: 'invalid frame',
            frame: frame
          });
        }
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
  }
}
/**
 * Returns a map of all of the subjects that match a parsed frame.
 *
 * @param state the current framing state.
 * @param subjects the set of subjects to filter.
 * @param frame the parsed frame.
 * @param flags the frame flags.
 *
 * @return all of the matched subjects.
 */


function _filterSubjects(state, subjects, frame, flags) {
  // filter subjects in @id order
  var rval = {};

  var _iterator10 = _createForOfIteratorHelper(subjects),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var id = _step10.value;
      var subject = state.graphMap[state.graph][id];

      if (_filterSubject(state, subject, frame, flags)) {
        rval[id] = subject;
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  return rval;
}
/**
 * Returns true if the given subject matches the given frame.
 *
 * Matches either based on explicit type inclusion where the node has any
 * type listed in the frame. If the frame has empty types defined matches
 * nodes not having a @type. If the frame has a type of {} defined matches
 * nodes having any type defined.
 *
 * Otherwise, does duck typing, where the node must have all of the
 * properties defined in the frame.
 *
 * @param state the current framing state.
 * @param subject the subject to check.
 * @param frame the frame to check.
 * @param flags the frame flags.
 *
 * @return true if the subject matches, false if not.
 */


function _filterSubject(state, subject, frame, flags) {
  // check ducktype
  var wildcard = true;
  var matchesSome = false;

  for (var key in frame) {
    var matchThis = false;
    var nodeValues = util.getValues(subject, key);
    var isEmpty = util.getValues(frame, key).length === 0;

    if (key === '@id') {
      // match on no @id or any matching @id, including wildcard
      if (types.isEmptyObject(frame['@id'][0] || {})) {
        matchThis = true;
      } else if (frame['@id'].length >= 0) {
        matchThis = frame['@id'].includes(nodeValues[0]);
      }

      if (!flags.requireAll) {
        return matchThis;
      }
    } else if (key === '@type') {
      // check @type (object value means 'any' type,
      // fall through to ducktyping)
      wildcard = false;

      if (isEmpty) {
        if (nodeValues.length > 0) {
          // don't match on no @type
          return false;
        }

        matchThis = true;
      } else if (frame['@type'].length === 1 && types.isEmptyObject(frame['@type'][0])) {
        // match on wildcard @type if there is a type
        matchThis = nodeValues.length > 0;
      } else {
        // match on a specific @type
        var _iterator11 = _createForOfIteratorHelper(frame['@type']),
            _step11;

        try {
          var _loop2 = function _loop2() {
            var type = _step11.value;

            if (types.isObject(type) && '@default' in type) {
              // match on default object
              matchThis = true;
            } else {
              matchThis = matchThis || nodeValues.some(function (tt) {
                return tt === type;
              });
            }
          };

          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            _loop2();
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
      }

      if (!flags.requireAll) {
        return matchThis;
      }
    } else if (isKeyword(key)) {
      continue;
    } else {
      var _ret2 = function () {
        // Force a copy of this frame entry so it can be manipulated
        var thisFrame = util.getValues(frame, key)[0];
        var hasDefault = false;

        if (thisFrame) {
          _validateFrame([thisFrame]);

          hasDefault = '@default' in thisFrame;
        } // no longer a wildcard pattern if frame has any non-keyword properties


        wildcard = false; // skip, but allow match if node has no value for property, and frame has
        // a default value

        if (nodeValues.length === 0 && hasDefault) {
          return "continue";
        } // if frame value is empty, don't match if subject has any value


        if (nodeValues.length > 0 && isEmpty) {
          return {
            v: false
          };
        }

        if (thisFrame === undefined) {
          // node does not match if values is not empty and the value of property
          // in frame is match none.
          if (nodeValues.length > 0) {
            return {
              v: false
            };
          }

          matchThis = true;
        } else {
          if (graphTypes.isList(thisFrame)) {
            var listValue = thisFrame['@list'][0];

            if (graphTypes.isList(nodeValues[0])) {
              var nodeListValues = nodeValues[0]['@list'];

              if (graphTypes.isValue(listValue)) {
                // match on any matching value
                matchThis = nodeListValues.some(function (lv) {
                  return _valueMatch(listValue, lv);
                });
              } else if (graphTypes.isSubject(listValue) || graphTypes.isSubjectReference(listValue)) {
                matchThis = nodeListValues.some(function (lv) {
                  return _nodeMatch(state, listValue, lv, flags);
                });
              }
            }
          } else if (graphTypes.isValue(thisFrame)) {
            matchThis = nodeValues.some(function (nv) {
              return _valueMatch(thisFrame, nv);
            });
          } else if (graphTypes.isSubjectReference(thisFrame)) {
            matchThis = nodeValues.some(function (nv) {
              return _nodeMatch(state, thisFrame, nv, flags);
            });
          } else if (types.isObject(thisFrame)) {
            matchThis = nodeValues.length > 0;
          } else {
            matchThis = false;
          }
        }
      }();

      if (_ret2 === "continue") continue;
      if ((0, _typeof2["default"])(_ret2) === "object") return _ret2.v;
    } // all non-defaulted values must match if requireAll is set


    if (!matchThis && flags.requireAll) {
      return false;
    }

    matchesSome = matchesSome || matchThis;
  } // return true if wildcard or subject matches some properties


  return wildcard || matchesSome;
}
/**
 * Removes an existing embed.
 *
 * @param state the current framing state.
 * @param id the @id of the embed to remove.
 */


function _removeEmbed(state, id) {
  // get existing embed
  var embeds = state.uniqueEmbeds[state.graph];
  var embed = embeds[id];
  var parent = embed.parent;
  var property = embed.property; // create reference to replace embed

  var subject = {
    '@id': id
  }; // remove existing embed

  if (types.isArray(parent)) {
    // replace subject with reference
    for (var i = 0; i < parent.length; ++i) {
      if (util.compareValues(parent[i], subject)) {
        parent[i] = subject;
        break;
      }
    }
  } else {
    // replace subject with reference
    var useArray = types.isArray(parent[property]);
    util.removeValue(parent, property, subject, {
      propertyIsArray: useArray
    });
    util.addValue(parent, property, subject, {
      propertyIsArray: useArray
    });
  } // recursively remove dependent dangling embeds


  var removeDependents = function removeDependents(id) {
    // get embed keys as a separate array to enable deleting keys in map
    var ids = Object.keys(embeds);

    for (var _i2 = 0, _ids = ids; _i2 < _ids.length; _i2++) {
      var next = _ids[_i2];

      if (next in embeds && types.isObject(embeds[next].parent) && embeds[next].parent['@id'] === id) {
        delete embeds[next];
        removeDependents(next);
      }
    }
  };

  removeDependents(id);
}
/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */


function _cleanupPreserve(input, options) {
  // recurse through arrays
  if (types.isArray(input)) {
    return input.map(function (value) {
      return _cleanupPreserve(value, options);
    });
  }

  if (types.isObject(input)) {
    // remove @preserve
    if ('@preserve' in input) {
      return input['@preserve'][0];
    } // skip @values


    if (graphTypes.isValue(input)) {
      return input;
    } // recurse through @lists


    if (graphTypes.isList(input)) {
      input['@list'] = _cleanupPreserve(input['@list'], options);
      return input;
    } // handle in-memory linked nodes


    if ('@id' in input) {
      var id = input['@id'];

      if (options.link.hasOwnProperty(id)) {
        var idx = options.link[id].indexOf(input);

        if (idx !== -1) {
          // already visited
          return options.link[id][idx];
        } // prevent circular visitation


        options.link[id].push(input);
      } else {
        // prevent circular visitation
        options.link[id] = [input];
      }
    } // recurse through properties


    for (var prop in input) {
      // potentially remove the id, if it is an unreference bnode
      if (prop === '@id' && options.bnodesToClear.includes(input[prop])) {
        delete input['@id'];
        continue;
      }

      input[prop] = _cleanupPreserve(input[prop], options);
    }
  }

  return input;
}
/**
 * Adds framing output to the given parent.
 *
 * @param parent the parent to add to.
 * @param property the parent property.
 * @param output the output to add.
 */


function _addFrameOutput(parent, property, output) {
  if (types.isObject(parent)) {
    util.addValue(parent, property, output, {
      propertyIsArray: true
    });
  } else {
    parent.push(output);
  }
}
/**
 * Node matches if it is a node, and matches the pattern as a frame.
 *
 * @param state the current framing state.
 * @param pattern used to match value
 * @param value to check
 * @param flags the frame flags.
 */


function _nodeMatch(state, pattern, value, flags) {
  if (!('@id' in value)) {
    return false;
  }

  var nodeObject = state.subjects[value['@id']];
  return nodeObject && _filterSubject(state, nodeObject, pattern, flags);
}
/**
 * Value matches if it is a value and matches the value pattern
 *
 * * `pattern` is empty
 * * @values are the same, or `pattern[@value]` is a wildcard, and
 * * @types are the same or `value[@type]` is not null
 *   and `pattern[@type]` is `{}`, or `value[@type]` is null
 *   and `pattern[@type]` is null or `[]`, and
 * * @languages are the same or `value[@language]` is not null
 *   and `pattern[@language]` is `{}`, or `value[@language]` is null
 *   and `pattern[@language]` is null or `[]`.
 *
 * @param pattern used to match value
 * @param value to check
 */


function _valueMatch(pattern, value) {
  var v1 = value['@value'];
  var t1 = value['@type'];
  var l1 = value['@language'];
  var v2 = pattern['@value'] ? types.isArray(pattern['@value']) ? pattern['@value'] : [pattern['@value']] : [];
  var t2 = pattern['@type'] ? types.isArray(pattern['@type']) ? pattern['@type'] : [pattern['@type']] : [];
  var l2 = pattern['@language'] ? types.isArray(pattern['@language']) ? pattern['@language'] : [pattern['@language']] : [];

  if (v2.length === 0 && t2.length === 0 && l2.length === 0) {
    return true;
  }

  if (!(v2.includes(v1) || types.isEmptyObject(v2[0]))) {
    return false;
  }

  if (!(!t1 && t2.length === 0 || t2.includes(t1) || t1 && types.isEmptyObject(t2[0]))) {
    return false;
  }

  if (!(!l1 && l2.length === 0 || l2.includes(l1) || l1 && types.isEmptyObject(l2[0]))) {
    return false;
  }

  return true;
}

},{"./JsonLdError":91,"./context":99,"./graphTypes":106,"./nodeMap":108,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/defineProperty":10,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],105:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var JsonLdError = require('./JsonLdError');

var graphTypes = require('./graphTypes');

var types = require('./types');

var util = require('./util'); // constants


var _require = require('./constants'),
    RDF_LIST = _require.RDF_LIST,
    RDF_FIRST = _require.RDF_FIRST,
    RDF_REST = _require.RDF_REST,
    RDF_NIL = _require.RDF_NIL,
    RDF_TYPE = _require.RDF_TYPE,
    RDF_JSON_LITERAL = _require.RDF_JSON_LITERAL,
    XSD_BOOLEAN = _require.XSD_BOOLEAN,
    XSD_DOUBLE = _require.XSD_DOUBLE,
    XSD_INTEGER = _require.XSD_INTEGER,
    XSD_STRING = _require.XSD_STRING;

var REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
var api = {};
module.exports = api;
/**
 * Converts an RDF dataset to JSON-LD.
 *
 * @param dataset the RDF dataset.
 * @param options the RDF serialization options.
 *
 * @return a Promise that resolves to the JSON-LD output.
 */

api.fromRDF = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(dataset, _ref) {
    var _ref$useRdfType, useRdfType, _ref$useNativeTypes, useNativeTypes, _ref$rdfDirection, rdfDirection, defaultGraph, graphMap, referencedOnce, _iterator, _step, quad, _name, nodeMap, s, p, o, _node, objectIsNode, value, object, name, graphObject, nil, _iterator2, _step2, usage, node, property, head, list, listNodes, nodeKeyCount, _i, _listNodes, listNode, result, subjects, _iterator3, _step3, subject, _node2, graph, _graphObject, graphSubjects, _iterator4, _step4, graphSubject, _node3;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref$useRdfType = _ref.useRdfType, useRdfType = _ref$useRdfType === void 0 ? false : _ref$useRdfType, _ref$useNativeTypes = _ref.useNativeTypes, useNativeTypes = _ref$useNativeTypes === void 0 ? false : _ref$useNativeTypes, _ref$rdfDirection = _ref.rdfDirection, rdfDirection = _ref$rdfDirection === void 0 ? null : _ref$rdfDirection;
            defaultGraph = {};
            graphMap = {
              '@default': defaultGraph
            };
            referencedOnce = {};
            _iterator = _createForOfIteratorHelper(dataset);
            _context.prev = 5;

            _iterator.s();

          case 7:
            if ((_step = _iterator.n()).done) {
              _context.next = 28;
              break;
            }

            quad = _step.value;
            // TODO: change 'name' to 'graph'
            _name = quad.graph.termType === 'DefaultGraph' ? '@default' : quad.graph.value;

            if (!(_name in graphMap)) {
              graphMap[_name] = {};
            }

            if (_name !== '@default' && !(_name in defaultGraph)) {
              defaultGraph[_name] = {
                '@id': _name
              };
            }

            nodeMap = graphMap[_name]; // get subject, predicate, object

            s = quad.subject.value;
            p = quad.predicate.value;
            o = quad.object;

            if (!(s in nodeMap)) {
              nodeMap[s] = {
                '@id': s
              };
            }

            _node = nodeMap[s];
            objectIsNode = o.termType.endsWith('Node');

            if (objectIsNode && !(o.value in nodeMap)) {
              nodeMap[o.value] = {
                '@id': o.value
              };
            }

            if (!(p === RDF_TYPE && !useRdfType && objectIsNode)) {
              _context.next = 23;
              break;
            }

            util.addValue(_node, '@type', o.value, {
              propertyIsArray: true
            });
            return _context.abrupt("continue", 26);

          case 23:
            value = _RDFToObject(o, useNativeTypes, rdfDirection);
            util.addValue(_node, p, value, {
              propertyIsArray: true
            }); // object may be an RDF list/partial list node but we can't know easily
            // until all triples are read

            if (objectIsNode) {
              if (o.value === RDF_NIL) {
                // track rdf:nil uniquely per graph
                object = nodeMap[o.value];

                if (!('usages' in object)) {
                  object.usages = [];
                }

                object.usages.push({
                  node: _node,
                  property: p,
                  value: value
                });
              } else if (o.value in referencedOnce) {
                // object referenced more than once
                referencedOnce[o.value] = false;
              } else {
                // keep track of single reference
                referencedOnce[o.value] = {
                  node: _node,
                  property: p,
                  value: value
                };
              }
            }

          case 26:
            _context.next = 7;
            break;

          case 28:
            _context.next = 33;
            break;

          case 30:
            _context.prev = 30;
            _context.t0 = _context["catch"](5);

            _iterator.e(_context.t0);

          case 33:
            _context.prev = 33;

            _iterator.f();

            return _context.finish(33);

          case 36:
            _context.t1 = _regenerator["default"].keys(graphMap);

          case 37:
            if ((_context.t2 = _context.t1()).done) {
              _context.next = 84;
              break;
            }

            name = _context.t2.value;
            graphObject = graphMap[name]; // no @lists to be converted, continue

            if (RDF_NIL in graphObject) {
              _context.next = 42;
              break;
            }

            return _context.abrupt("continue", 37);

          case 42:
            // iterate backwards through each RDF list
            nil = graphObject[RDF_NIL];

            if (nil.usages) {
              _context.next = 45;
              break;
            }

            return _context.abrupt("continue", 37);

          case 45:
            _iterator2 = _createForOfIteratorHelper(nil.usages);
            _context.prev = 46;

            _iterator2.s();

          case 48:
            if ((_step2 = _iterator2.n()).done) {
              _context.next = 73;
              break;
            }

            usage = _step2.value;
            node = usage.node;
            property = usage.property;
            head = usage.value;
            list = [];
            listNodes = []; // ensure node is a well-formed list node; it must:
            // 1. Be referenced only once.
            // 2. Have an array for rdf:first that has 1 item.
            // 3. Have an array for rdf:rest that has 1 item.
            // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,
            //   optionally, @type where the value is rdf:List.

            nodeKeyCount = Object.keys(node).length;

          case 56:
            if (!(property === RDF_REST && types.isObject(referencedOnce[node['@id']]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node['@type']) && node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {
              _context.next = 68;
              break;
            }

            list.push(node[RDF_FIRST][0]);
            listNodes.push(node['@id']); // get next node, moving backwards through list

            usage = referencedOnce[node['@id']];
            node = usage.node;
            property = usage.property;
            head = usage.value;
            nodeKeyCount = Object.keys(node).length; // if node is not a blank node, then list head found

            if (graphTypes.isBlankNode(node)) {
              _context.next = 66;
              break;
            }

            return _context.abrupt("break", 68);

          case 66:
            _context.next = 56;
            break;

          case 68:
            // transform list into @list object
            delete head['@id'];
            head['@list'] = list.reverse();

            for (_i = 0, _listNodes = listNodes; _i < _listNodes.length; _i++) {
              listNode = _listNodes[_i];
              delete graphObject[listNode];
            }

          case 71:
            _context.next = 48;
            break;

          case 73:
            _context.next = 78;
            break;

          case 75:
            _context.prev = 75;
            _context.t3 = _context["catch"](46);

            _iterator2.e(_context.t3);

          case 78:
            _context.prev = 78;

            _iterator2.f();

            return _context.finish(78);

          case 81:
            delete nil.usages;
            _context.next = 37;
            break;

          case 84:
            result = [];
            subjects = Object.keys(defaultGraph).sort();
            _iterator3 = _createForOfIteratorHelper(subjects);

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                subject = _step3.value;
                _node2 = defaultGraph[subject];

                if (subject in graphMap) {
                  graph = _node2['@graph'] = [];
                  _graphObject = graphMap[subject];
                  graphSubjects = Object.keys(_graphObject).sort();
                  _iterator4 = _createForOfIteratorHelper(graphSubjects);

                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                      graphSubject = _step4.value;
                      _node3 = _graphObject[graphSubject]; // only add full subjects to top-level

                      if (!graphTypes.isSubjectReference(_node3)) {
                        graph.push(_node3);
                      }
                    }
                  } catch (err) {
                    _iterator4.e(err);
                  } finally {
                    _iterator4.f();
                  }
                } // only add full subjects to top-level


                if (!graphTypes.isSubjectReference(_node2)) {
                  result.push(_node2);
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }

            return _context.abrupt("return", result);

          case 89:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[5, 30, 33, 36], [46, 75, 78, 81]]);
  }));

  return function (_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Converts an RDF triple object to a JSON-LD object.
 *
 * @param o the RDF triple object to convert.
 * @param useNativeTypes true to output native types, false not to.
 *
 * @return the JSON-LD object.
 */


function _RDFToObject(o, useNativeTypes, rdfDirection) {
  // convert NamedNode/BlankNode object to JSON-LD
  if (o.termType.endsWith('Node')) {
    return {
      '@id': o.value
    };
  } // convert literal to JSON-LD


  var rval = {
    '@value': o.value
  }; // add language

  if (o.language) {
    rval['@language'] = o.language;
  } else {
    var type = o.datatype.value;

    if (!type) {
      type = XSD_STRING;
    }

    if (type === RDF_JSON_LITERAL) {
      type = '@json';

      try {
        rval['@value'] = JSON.parse(rval['@value']);
      } catch (e) {
        throw new JsonLdError('JSON literal could not be parsed.', 'jsonld.InvalidJsonLiteral', {
          code: 'invalid JSON literal',
          value: rval['@value'],
          cause: e
        });
      }
    } // use native types for certain xsd types


    if (useNativeTypes) {
      if (type === XSD_BOOLEAN) {
        if (rval['@value'] === 'true') {
          rval['@value'] = true;
        } else if (rval['@value'] === 'false') {
          rval['@value'] = false;
        }
      } else if (types.isNumeric(rval['@value'])) {
        if (type === XSD_INTEGER) {
          var i = parseInt(rval['@value'], 10);

          if (i.toFixed(0) === rval['@value']) {
            rval['@value'] = i;
          }
        } else if (type === XSD_DOUBLE) {
          rval['@value'] = parseFloat(rval['@value']);
        }
      } // do not add native type


      if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {
        rval['@type'] = type;
      }
    } else if (rdfDirection === 'i18n-datatype' && type.startsWith('https://www.w3.org/ns/i18n#')) {
      var _type$split = type.split(/[#_]/),
          _type$split2 = (0, _slicedToArray2["default"])(_type$split, 3),
          language = _type$split2[1],
          direction = _type$split2[2];

      if (language.length > 0) {
        rval['@language'] = language;

        if (!language.match(REGEX_BCP47)) {
          console.warn("@language must be valid BCP47: ".concat(language));
        }
      }

      rval['@direction'] = direction;
    } else if (type !== XSD_STRING) {
      rval['@type'] = type;
    }
  }

  return rval;
}

},{"./JsonLdError":91,"./constants":98,"./graphTypes":106,"./types":110,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/regenerator":30}],106:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var types = require('./types');

var api = {};
module.exports = api;
/**
 * Returns true if the given value is a subject with properties.
 *
 * @param v the value to check.
 *
 * @return true if the value is a subject with properties, false if not.
 */

api.isSubject = function (v) {
  // Note: A value is a subject if all of these hold true:
  // 1. It is an Object.
  // 2. It is not a @value, @set, or @list.
  // 3. It has more than 1 key OR any existing key is not @id.
  if (types.isObject(v) && !('@value' in v || '@set' in v || '@list' in v)) {
    var keyCount = Object.keys(v).length;
    return keyCount > 1 || !('@id' in v);
  }

  return false;
};
/**
 * Returns true if the given value is a subject reference.
 *
 * @param v the value to check.
 *
 * @return true if the value is a subject reference, false if not.
 */


api.isSubjectReference = function (v) {
  return (// Note: A value is a subject reference if all of these hold true:
    // 1. It is an Object.
    // 2. It has a single key: @id.
    types.isObject(v) && Object.keys(v).length === 1 && '@id' in v
  );
};
/**
 * Returns true if the given value is a @value.
 *
 * @param v the value to check.
 *
 * @return true if the value is a @value, false if not.
 */


api.isValue = function (v) {
  return (// Note: A value is a @value if all of these hold true:
    // 1. It is an Object.
    // 2. It has the @value property.
    types.isObject(v) && '@value' in v
  );
};
/**
 * Returns true if the given value is a @list.
 *
 * @param v the value to check.
 *
 * @return true if the value is a @list, false if not.
 */


api.isList = function (v) {
  return (// Note: A value is a @list if all of these hold true:
    // 1. It is an Object.
    // 2. It has the @list property.
    types.isObject(v) && '@list' in v
  );
};
/**
 * Returns true if the given value is a @graph.
 *
 * @return true if the value is a @graph, false if not.
 */


api.isGraph = function (v) {
  // Note: A value is a graph if all of these hold true:
  // 1. It is an object.
  // 2. It has an `@graph` key.
  // 3. It may have '@id' or '@index'
  return types.isObject(v) && '@graph' in v && Object.keys(v).filter(function (key) {
    return key !== '@id' && key !== '@index';
  }).length === 1;
};
/**
 * Returns true if the given value is a simple @graph.
 *
 * @return true if the value is a simple @graph, false if not.
 */


api.isSimpleGraph = function (v) {
  // Note: A value is a simple graph if all of these hold true:
  // 1. It is an object.
  // 2. It has an `@graph` key.
  // 3. It has only 1 key or 2 keys where one of them is `@index`.
  return api.isGraph(v) && !('@id' in v);
};
/**
 * Returns true if the given value is a blank node.
 *
 * @param v the value to check.
 *
 * @return true if the value is a blank node, false if not.
 */


api.isBlankNode = function (v) {
  // Note: A value is a blank node if all of these hold true:
  // 1. It is an Object.
  // 2. If it has an @id key its value begins with '_:'.
  // 3. It has no keys OR is not a @value, @set, or @list.
  if (types.isObject(v)) {
    if ('@id' in v) {
      return v['@id'].indexOf('_:') === 0;
    }

    return Object.keys(v).length === 0 || !('@value' in v || '@set' in v || '@list' in v);
  }

  return false;
};

},{"./types":110}],107:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2019 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var canonize = require('rdf-canonize');

var util = require('./util');

var ContextResolver = require('./ContextResolver');

var IdentifierIssuer = util.IdentifierIssuer;

var JsonLdError = require('./JsonLdError');

var LRU = require('lru-cache');

var NQuads = require('./NQuads');

var Rdfa = require('./Rdfa');

var _require = require('./expand'),
    _expand = _require.expand;

var _require2 = require('./flatten'),
    _flatten = _require2.flatten;

var _require3 = require('./fromRdf'),
    _fromRDF = _require3.fromRDF;

var _require4 = require('./toRdf'),
    _toRDF = _require4.toRDF;

var _require5 = require('./frame'),
    _frameMergedOrDefault = _require5.frameMergedOrDefault,
    _cleanupNull = _require5.cleanupNull;

var _require6 = require('./types'),
    _isArray = _require6.isArray,
    _isObject = _require6.isObject,
    _isString = _require6.isString;

var _require7 = require('./graphTypes'),
    _isSubjectReference = _require7.isSubjectReference;

var _require8 = require('./context'),
    _expandIri = _require8.expandIri,
    _getInitialContext = _require8.getInitialContext,
    _processContext = _require8.process,
    _processingMode = _require8.processingMode;

var _require9 = require('./compact'),
    _compact = _require9.compact,
    _compactIri = _require9.compactIri;

var _require10 = require('./nodeMap'),
    _createNodeMap = _require10.createNodeMap,
    _createMergedNodeMap = _require10.createMergedNodeMap,
    _mergeNodeMaps = _require10.mergeNodeMaps; // determine if in-browser or using Node.js


var _nodejs = typeof process !== 'undefined' && process.versions && process.versions.node;

var _browser = !_nodejs && (typeof window !== 'undefined' || typeof self !== 'undefined');
/* eslint-disable indent */
// attaches jsonld API to the given object


var wrapper = function wrapper(jsonld) {
  /** Registered RDF dataset parsers hashed by content-type. */
  var _rdfParsers = {}; // resolved context cache
  // TODO: consider basing max on context size rather than number

  var RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;

  var _resolvedContextCache = new LRU({
    max: RESOLVED_CONTEXT_CACHE_MAX_SIZE
  });
  /* Core API */

  /**
   * Performs JSON-LD compaction.
   *
   * @param input the JSON-LD input to compact.
   * @param ctx the context to compact with.
   * @param [options] options to use:
   *          [base] the base IRI to use.
   *          [compactArrays] true to compact arrays to single values when
   *            appropriate, false not to (default: true).
   *          [compactToRelative] true to compact IRIs to be relative to document
   *            base, false to keep absolute (default: true)
   *          [graph] true to always output a top-level graph (default: false).
   *          [expandContext] a context to expand with.
   *          [skipExpansion] true to assume the input is expanded and skip
   *            expansion, false not to, defaults to false.
   *          [documentLoader(url, options)] the document loader.
   *          [expansionMap(info)] a function that can be used to custom map
   *            unmappable values (or to throw an error when they are detected);
   *            if this function returns `undefined` then the default behavior
   *            will be used.
   *          [framing] true if compaction is occuring during a framing operation.
   *          [compactionMap(info)] a function that can be used to custom map
   *            unmappable values (or to throw an error when they are detected);
   *            if this function returns `undefined` then the default behavior
   *            will be used.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the compacted output.
   */


  jsonld.compact = /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(input, ctx, options) {
      var expanded,
          activeCtx,
          compacted,
          tmp,
          i,
          hasContext,
          graphAlias,
          graph,
          _graph,
          key,
          _args = arguments;

      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(_args.length < 2)) {
                _context.next = 2;
                break;
              }

              throw new TypeError('Could not compact, too few arguments.');

            case 2:
              if (!(ctx === null)) {
                _context.next = 4;
                break;
              }

              throw new JsonLdError('The compaction context must not be null.', 'jsonld.CompactError', {
                code: 'invalid local context'
              });

            case 4:
              if (!(input === null)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", null);

            case 6:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                compactArrays: true,
                compactToRelative: true,
                graph: false,
                skipExpansion: false,
                link: false,
                issuer: new IdentifierIssuer('_:b'),
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              });

              if (options.link) {
                // force skip expansion when linking, "link" is not part of the public
                // API, it should only be called from framing
                options.skipExpansion = true;
              }

              if (!options.compactToRelative) {
                delete options.base;
              } // expand input


              if (!options.skipExpansion) {
                _context.next = 13;
                break;
              }

              expanded = input;
              _context.next = 16;
              break;

            case 13:
              _context.next = 15;
              return jsonld.expand(input, options);

            case 15:
              expanded = _context.sent;

            case 16:
              _context.next = 18;
              return jsonld.processContext(_getInitialContext(options), ctx, options);

            case 18:
              activeCtx = _context.sent;
              _context.next = 21;
              return _compact({
                activeCtx: activeCtx,
                element: expanded,
                options: options,
                compactionMap: options.compactionMap
              });

            case 21:
              compacted = _context.sent;

              // perform clean up
              if (options.compactArrays && !options.graph && _isArray(compacted)) {
                if (compacted.length === 1) {
                  // simplify to a single item
                  compacted = compacted[0];
                } else if (compacted.length === 0) {
                  // simplify to an empty object
                  compacted = {};
                }
              } else if (options.graph && _isObject(compacted)) {
                // always use array if graph option is on
                compacted = [compacted];
              } // follow @context key


              if (_isObject(ctx) && '@context' in ctx) {
                ctx = ctx['@context'];
              } // build output context


              ctx = util.clone(ctx);

              if (!_isArray(ctx)) {
                ctx = [ctx];
              } // remove empty contexts


              tmp = ctx;
              ctx = [];

              for (i = 0; i < tmp.length; ++i) {
                if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {
                  ctx.push(tmp[i]);
                }
              } // remove array if only one context


              hasContext = ctx.length > 0;

              if (ctx.length === 1) {
                ctx = ctx[0];
              } // add context and/or @graph


              if (_isArray(compacted)) {
                // use '@graph' keyword
                graphAlias = _compactIri({
                  activeCtx: activeCtx,
                  iri: '@graph',
                  relativeTo: {
                    vocab: true
                  }
                });
                graph = compacted;
                compacted = {};

                if (hasContext) {
                  compacted['@context'] = ctx;
                }

                compacted[graphAlias] = graph;
              } else if (_isObject(compacted) && hasContext) {
                // reorder keys so @context is first
                _graph = compacted;
                compacted = {
                  '@context': ctx
                };

                for (key in _graph) {
                  compacted[key] = _graph[key];
                }
              }

              return _context.abrupt("return", compacted);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * Performs JSON-LD expansion.
   *
   * @param input the JSON-LD input to expand.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [keepFreeFloatingNodes] true to keep free-floating nodes,
   *            false not to, defaults to false.
   *          [documentLoader(url, options)] the document loader.
   *          [expansionMap(info)] a function that can be used to custom map
   *            unmappable values (or to throw an error when they are detected);
   *            if this function returns `undefined` then the default behavior
   *            will be used.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the expanded output.
   */


  jsonld.expand = /*#__PURE__*/function () {
    var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(input, options) {
      var toResolve,
          contextsToProcess,
          expandContext,
          defaultBase,
          remoteDoc,
          activeCtx,
          _i,
          _contextsToProcess,
          localCtx,
          expanded,
          _args2 = arguments;

      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(_args2.length < 1)) {
                _context2.next = 2;
                break;
              }

              throw new TypeError('Could not expand, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                keepFreeFloatingNodes: false,
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              });

              if (options.expansionMap === false) {
                options.expansionMap = undefined;
              } // build set of objects that may have @contexts to resolve


              toResolve = {}; // build set of contexts to process prior to expansion

              contextsToProcess = []; // if an `expandContext` has been given ensure it gets resolved

              if ('expandContext' in options) {
                expandContext = util.clone(options.expandContext);

                if (_isObject(expandContext) && '@context' in expandContext) {
                  toResolve.expandContext = expandContext;
                } else {
                  toResolve.expandContext = {
                    '@context': expandContext
                  };
                }

                contextsToProcess.push(toResolve.expandContext);
              } // if input is a string, attempt to dereference remote document


              if (_isString(input)) {
                _context2.next = 11;
                break;
              }

              // input is not a URL, do not need to retrieve it first
              toResolve.input = util.clone(input);
              _context2.next = 17;
              break;

            case 11:
              _context2.next = 13;
              return jsonld.get(input, options);

            case 13:
              remoteDoc = _context2.sent;
              defaultBase = remoteDoc.documentUrl;
              toResolve.input = remoteDoc.document;

              if (remoteDoc.contextUrl) {
                // context included in HTTP link header and must be resolved
                toResolve.remoteContext = {
                  '@context': remoteDoc.contextUrl
                };
                contextsToProcess.push(toResolve.remoteContext);
              }

            case 17:
              // set default base
              if (!('base' in options)) {
                options.base = defaultBase || '';
              } // process any additional contexts


              activeCtx = _getInitialContext(options);
              _i = 0, _contextsToProcess = contextsToProcess;

            case 20:
              if (!(_i < _contextsToProcess.length)) {
                _context2.next = 28;
                break;
              }

              localCtx = _contextsToProcess[_i];
              _context2.next = 24;
              return _processContext({
                activeCtx: activeCtx,
                localCtx: localCtx,
                options: options
              });

            case 24:
              activeCtx = _context2.sent;

            case 25:
              _i++;
              _context2.next = 20;
              break;

            case 28:
              _context2.next = 30;
              return _expand({
                activeCtx: activeCtx,
                element: toResolve.input,
                options: options,
                expansionMap: options.expansionMap
              });

            case 30:
              expanded = _context2.sent;

              // optimize away @graph with no other properties
              if (_isObject(expanded) && '@graph' in expanded && Object.keys(expanded).length === 1) {
                expanded = expanded['@graph'];
              } else if (expanded === null) {
                expanded = [];
              } // normalize to an array


              if (!_isArray(expanded)) {
                expanded = [expanded];
              }

              return _context2.abrupt("return", expanded);

            case 34:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x4, _x5) {
      return _ref2.apply(this, arguments);
    };
  }();
  /**
   * Performs JSON-LD flattening.
   *
   * @param input the JSON-LD to flatten.
   * @param ctx the context to use to compact the flattened output, or null.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the flattened output.
   */


  jsonld.flatten = /*#__PURE__*/function () {
    var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(input, ctx, options) {
      var expanded,
          flattened,
          compacted,
          _args3 = arguments;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(_args3.length < 1)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", new TypeError('Could not flatten, too few arguments.'));

            case 2:
              if (typeof ctx === 'function') {
                ctx = null;
              } else {
                ctx = ctx || null;
              } // set default options


              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // expand input

              _context3.next = 6;
              return jsonld.expand(input, options);

            case 6:
              expanded = _context3.sent;
              // do flattening
              flattened = _flatten(expanded);

              if (!(ctx === null)) {
                _context3.next = 10;
                break;
              }

              return _context3.abrupt("return", flattened);

            case 10:
              // compact result (force @graph option to true, skip expansion)
              options.graph = true;
              options.skipExpansion = true;
              _context3.next = 14;
              return jsonld.compact(flattened, ctx, options);

            case 14:
              compacted = _context3.sent;
              return _context3.abrupt("return", compacted);

            case 16:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x6, _x7, _x8) {
      return _ref3.apply(this, arguments);
    };
  }();
  /**
   * Performs JSON-LD framing.
   *
   * @param input the JSON-LD input to frame.
   * @param frame the JSON-LD frame to use.
   * @param [options] the framing options.
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [embed] default @embed flag: '@last', '@always', '@never', '@link'
   *            (default: '@last').
   *          [explicit] default @explicit flag (default: false).
   *          [requireAll] default @requireAll flag (default: true).
   *          [omitDefault] default @omitDefault flag (default: false).
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the framed output.
   */


  jsonld.frame = /*#__PURE__*/function () {
    var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(input, frame, options) {
      var remoteDoc,
          ctx,
          frameContext,
          activeCtx,
          expanded,
          opts,
          expandedFrame,
          frameKeys,
          framed,
          compacted,
          _args4 = arguments;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(_args4.length < 2)) {
                _context4.next = 2;
                break;
              }

              throw new TypeError('Could not frame, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                embed: '@once',
                explicit: false,
                requireAll: false,
                omitDefault: false,
                bnodesToClear: [],
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // if frame is a string, attempt to dereference remote document

              if (!_isString(frame)) {
                _context4.next = 9;
                break;
              }

              _context4.next = 6;
              return jsonld.get(frame, options);

            case 6:
              remoteDoc = _context4.sent;
              frame = remoteDoc.document;

              if (remoteDoc.contextUrl) {
                // inject link header @context into frame
                ctx = frame['@context'];

                if (!ctx) {
                  ctx = remoteDoc.contextUrl;
                } else if (_isArray(ctx)) {
                  ctx.push(remoteDoc.contextUrl);
                } else {
                  ctx = [ctx, remoteDoc.contextUrl];
                }

                frame['@context'] = ctx;
              }

            case 9:
              frameContext = frame ? frame['@context'] || {} : {}; // process context

              _context4.next = 12;
              return jsonld.processContext(_getInitialContext(options), frameContext, options);

            case 12:
              activeCtx = _context4.sent;

              // mode specific defaults
              if (!options.hasOwnProperty('omitGraph')) {
                options.omitGraph = _processingMode(activeCtx, 1.1);
              }

              if (!options.hasOwnProperty('pruneBlankNodeIdentifiers')) {
                options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);
              } // expand input


              _context4.next = 17;
              return jsonld.expand(input, options);

            case 17:
              expanded = _context4.sent;
              // expand frame
              opts = _objectSpread({}, options);
              opts.isFrame = true;
              opts.keepFreeFloatingNodes = true;
              _context4.next = 23;
              return jsonld.expand(frame, opts);

            case 23:
              expandedFrame = _context4.sent;
              // if the unexpanded frame includes a key expanding to @graph, frame the
              // default graph, otherwise, the merged graph
              frameKeys = Object.keys(frame).map(function (key) {
                return _expandIri(activeCtx, key, {
                  vocab: true
                });
              });
              opts.merged = !frameKeys.includes('@graph');
              opts.is11 = _processingMode(activeCtx, 1.1); // do framing

              framed = _frameMergedOrDefault(expanded, expandedFrame, opts);
              opts.graph = !options.omitGraph;
              opts.skipExpansion = true;
              opts.link = {};
              opts.framing = true;
              _context4.next = 34;
              return jsonld.compact(framed, frameContext, opts);

            case 34:
              compacted = _context4.sent;
              // replace @null with null, compacting arrays
              opts.link = {};
              compacted = _cleanupNull(compacted, opts);
              return _context4.abrupt("return", compacted);

            case 38:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x9, _x10, _x11) {
      return _ref4.apply(this, arguments);
    };
  }();
  /**
   * **Experimental**
   *
   * Links a JSON-LD document's nodes in memory.
   *
   * @param input the JSON-LD document to link.
   * @param [ctx] the JSON-LD context to apply.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the linked output.
   */


  jsonld.link = /*#__PURE__*/function () {
    var _ref5 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(input, ctx, options) {
      var frame;
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              // API matches running frame with a wildcard frame and embed: '@link'
              // get arguments
              frame = {};

              if (ctx) {
                frame['@context'] = ctx;
              }

              frame['@embed'] = '@link';
              return _context5.abrupt("return", jsonld.frame(input, frame, options));

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function (_x12, _x13, _x14) {
      return _ref5.apply(this, arguments);
    };
  }();
  /**
   * Performs RDF dataset normalization on the given input. The input is JSON-LD
   * unless the 'inputFormat' option is used. The output is an RDF dataset
   * unless the 'format' option is used.
   *
   * @param input the input to normalize as JSON-LD or as a format specified by
   *          the 'inputFormat' option.
   * @param [options] the options to use:
   *          [algorithm] the normalization algorithm to use, `URDNA2015` or
   *            `URGNA2012` (default: `URDNA2015`).
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [skipExpansion] true to assume the input is expanded and skip
   *            expansion, false not to, defaults to false.
   *          [inputFormat] the format if input is not JSON-LD:
   *            'application/n-quads' for N-Quads.
   *          [format] the format if output is a string:
   *            'application/n-quads' for N-Quads.
   *          [documentLoader(url, options)] the document loader.
   *          [useNative] true to use a native canonize algorithm
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the normalized output.
   */


  jsonld.normalize = jsonld.canonize = /*#__PURE__*/function () {
    var _ref6 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(input, options) {
      var parsedInput,
          opts,
          dataset,
          _args6 = arguments;
      return _regenerator["default"].wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!(_args6.length < 1)) {
                _context6.next = 2;
                break;
              }

              throw new TypeError('Could not canonize, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                algorithm: 'URDNA2015',
                skipExpansion: false,
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              });

              if (!('inputFormat' in options)) {
                _context6.next = 8;
                break;
              }

              if (!(options.inputFormat !== 'application/n-quads' && options.inputFormat !== 'application/nquads')) {
                _context6.next = 6;
                break;
              }

              throw new JsonLdError('Unknown canonicalization input format.', 'jsonld.CanonizeError');

            case 6:
              // TODO: `await` for async parsers
              parsedInput = NQuads.parse(input); // do canonicalization

              return _context6.abrupt("return", canonize.canonize(parsedInput, options));

            case 8:
              // convert to RDF dataset then do normalization
              opts = _objectSpread({}, options);
              delete opts.format;
              opts.produceGeneralizedRdf = false;
              _context6.next = 13;
              return jsonld.toRDF(input, opts);

            case 13:
              dataset = _context6.sent;
              return _context6.abrupt("return", canonize.canonize(dataset, options));

            case 15:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function (_x15, _x16) {
      return _ref6.apply(this, arguments);
    };
  }();
  /**
   * Converts an RDF dataset to JSON-LD.
   *
   * @param dataset a serialized string of RDF in a format specified by the
   *          format option or an RDF dataset to convert.
   * @param [options] the options to use:
   *          [format] the format if dataset param must first be parsed:
   *            'application/n-quads' for N-Quads (default).
   *          [rdfParser] a custom RDF-parser to use to parse the dataset.
   *          [useRdfType] true to use rdf:type, false to use @type
   *            (default: false).
   *          [useNativeTypes] true to convert XSD types into native types
   *            (boolean, integer, double), false not to (default: false).
   *
   * @return a Promise that resolves to the JSON-LD document.
   */


  jsonld.fromRDF = /*#__PURE__*/function () {
    var _ref7 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(dataset, options) {
      var _options,
          format,
          _options2,
          rdfParser,
          parsedDataset,
          _args7 = arguments;

      return _regenerator["default"].wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!(_args7.length < 1)) {
                _context7.next = 2;
                break;
              }

              throw new TypeError('Could not convert from RDF, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                format: _isString(dataset) ? 'application/n-quads' : undefined
              });
              _options = options, format = _options.format;
              _options2 = options, rdfParser = _options2.rdfParser; // handle special format

              if (!format) {
                _context7.next = 11;
                break;
              }

              // check supported formats
              rdfParser = rdfParser || _rdfParsers[format];

              if (rdfParser) {
                _context7.next = 9;
                break;
              }

              throw new JsonLdError('Unknown input format.', 'jsonld.UnknownFormat', {
                format: format
              });

            case 9:
              _context7.next = 12;
              break;

            case 11:
              // no-op parser, assume dataset already parsed
              rdfParser = function rdfParser() {
                return dataset;
              };

            case 12:
              _context7.next = 14;
              return rdfParser(dataset);

            case 14:
              parsedDataset = _context7.sent;
              return _context7.abrupt("return", _fromRDF(parsedDataset, options));

            case 16:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function (_x17, _x18) {
      return _ref7.apply(this, arguments);
    };
  }();
  /**
   * Outputs the RDF dataset found in the given JSON-LD object.
   *
   * @param input the JSON-LD input.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [skipExpansion] true to assume the input is expanded and skip
   *            expansion, false not to, defaults to false.
   *          [format] the format to use to output a string:
   *            'application/n-quads' for N-Quads.
   *          [produceGeneralizedRdf] true to output generalized RDF, false
   *            to produce only standard RDF (default: false).
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the RDF dataset.
   */


  jsonld.toRDF = /*#__PURE__*/function () {
    var _ref8 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(input, options) {
      var expanded,
          dataset,
          _args8 = arguments;
      return _regenerator["default"].wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (!(_args8.length < 1)) {
                _context8.next = 2;
                break;
              }

              throw new TypeError('Could not convert to RDF, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                skipExpansion: false,
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // TODO: support toRDF custom map?

              if (!options.skipExpansion) {
                _context8.next = 7;
                break;
              }

              expanded = input;
              _context8.next = 10;
              break;

            case 7:
              _context8.next = 9;
              return jsonld.expand(input, options);

            case 9:
              expanded = _context8.sent;

            case 10:
              // output RDF dataset
              dataset = _toRDF(expanded, options);

              if (!options.format) {
                _context8.next = 17;
                break;
              }

              if (!(options.format === 'application/n-quads' || options.format === 'application/nquads')) {
                _context8.next = 16;
                break;
              }

              _context8.next = 15;
              return NQuads.serialize(dataset);

            case 15:
              return _context8.abrupt("return", _context8.sent);

            case 16:
              throw new JsonLdError('Unknown output format.', 'jsonld.UnknownFormat', {
                format: options.format
              });

            case 17:
              return _context8.abrupt("return", dataset);

            case 18:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    return function (_x19, _x20) {
      return _ref8.apply(this, arguments);
    };
  }();
  /**
   * **Experimental**
   *
   * Recursively flattens the nodes in the given JSON-LD input into a merged
   * map of node ID => node. All graphs will be merged into the default graph.
   *
   * @param input the JSON-LD input.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the merged node map.
   */


  jsonld.createNodeMap = /*#__PURE__*/function () {
    var _ref9 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(input, options) {
      var expanded,
          _args9 = arguments;
      return _regenerator["default"].wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (!(_args9.length < 1)) {
                _context9.next = 2;
                break;
              }

              throw new TypeError('Could not create node map, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // expand input

              _context9.next = 5;
              return jsonld.expand(input, options);

            case 5:
              expanded = _context9.sent;
              return _context9.abrupt("return", _createMergedNodeMap(expanded, options));

            case 7:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));

    return function (_x21, _x22) {
      return _ref9.apply(this, arguments);
    };
  }();
  /**
   * **Experimental**
   *
   * Merges two or more JSON-LD documents into a single flattened document.
   *
   * @param docs the JSON-LD documents to merge together.
   * @param ctx the context to use to compact the merged result, or null.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.
   *          [mergeNodes] true to merge properties for nodes with the same ID,
   *            false to ignore new properties for nodes with the same ID once
   *            the ID has been defined; note that this may not prevent merging
   *            new properties where a node is in the `object` position
   *            (default: true).
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the merged output.
   */


  jsonld.merge = /*#__PURE__*/function () {
    var _ref10 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(docs, ctx, options) {
      var expanded,
          mergeNodes,
          issuer,
          graphs,
          i,
          doc,
          _graphs,
          graphName,
          _nodeMap,
          nodeMap,
          key,
          defaultGraph,
          flattened,
          keys,
          ki,
          node,
          compacted,
          _args10 = arguments;

      return _regenerator["default"].wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (!(_args10.length < 1)) {
                _context10.next = 2;
                break;
              }

              throw new TypeError('Could not merge, too few arguments.');

            case 2:
              if (_isArray(docs)) {
                _context10.next = 4;
                break;
              }

              throw new TypeError('Could not merge, "docs" must be an array.');

            case 4:
              if (typeof ctx === 'function') {
                ctx = null;
              } else {
                ctx = ctx || null;
              } // set default options


              options = _setDefaults(options, {
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // expand all documents

              _context10.next = 8;
              return Promise.all(docs.map(function (doc) {
                var opts = _objectSpread({}, options);

                return jsonld.expand(doc, opts);
              }));

            case 8:
              expanded = _context10.sent;
              mergeNodes = true;

              if ('mergeNodes' in options) {
                mergeNodes = options.mergeNodes;
              }

              issuer = options.issuer || new IdentifierIssuer('_:b');
              graphs = {
                '@default': {}
              };
              i = 0;

            case 14:
              if (!(i < expanded.length)) {
                _context10.next = 33;
                break;
              }

              // uniquely relabel blank nodes
              doc = util.relabelBlankNodes(expanded[i], {
                issuer: new IdentifierIssuer('_:b' + i + '-')
              }); // add nodes to the shared node map graphs if merging nodes, to a
              // separate graph set if not

              _graphs = mergeNodes || i === 0 ? graphs : {
                '@default': {}
              };

              _createNodeMap(doc, _graphs, '@default', issuer);

              if (!(_graphs !== graphs)) {
                _context10.next = 30;
                break;
              }

              _context10.t0 = _regenerator["default"].keys(_graphs);

            case 20:
              if ((_context10.t1 = _context10.t0()).done) {
                _context10.next = 30;
                break;
              }

              graphName = _context10.t1.value;
              _nodeMap = _graphs[graphName];

              if (graphName in graphs) {
                _context10.next = 26;
                break;
              }

              graphs[graphName] = _nodeMap;
              return _context10.abrupt("continue", 20);

            case 26:
              nodeMap = graphs[graphName];

              for (key in _nodeMap) {
                if (!(key in nodeMap)) {
                  nodeMap[key] = _nodeMap[key];
                }
              }

              _context10.next = 20;
              break;

            case 30:
              ++i;
              _context10.next = 14;
              break;

            case 33:
              // add all non-default graphs to default graph
              defaultGraph = _mergeNodeMaps(graphs); // produce flattened output

              flattened = [];
              keys = Object.keys(defaultGraph).sort();

              for (ki = 0; ki < keys.length; ++ki) {
                node = defaultGraph[keys[ki]]; // only add full subjects to top-level

                if (!_isSubjectReference(node)) {
                  flattened.push(node);
                }
              }

              if (!(ctx === null)) {
                _context10.next = 39;
                break;
              }

              return _context10.abrupt("return", flattened);

            case 39:
              // compact result (force @graph option to true, skip expansion)
              options.graph = true;
              options.skipExpansion = true;
              _context10.next = 43;
              return jsonld.compact(flattened, ctx, options);

            case 43:
              compacted = _context10.sent;
              return _context10.abrupt("return", compacted);

            case 45:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));

    return function (_x23, _x24, _x25) {
      return _ref10.apply(this, arguments);
    };
  }();
  /**
   * The default document loader for external documents.
   *
   * @param url the URL to load.
   *
   * @return a promise that resolves to the remote document.
   */


  Object.defineProperty(jsonld, 'documentLoader', {
    get: function get() {
      return jsonld._documentLoader;
    },
    set: function set(v) {
      return jsonld._documentLoader = v;
    }
  }); // default document loader not implemented

  jsonld.documentLoader = /*#__PURE__*/function () {
    var _ref11 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(url) {
      return _regenerator["default"].wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              throw new JsonLdError('Could not retrieve a JSON-LD document from the URL. URL ' + 'dereferencing not implemented.', 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                url: url
              });

            case 1:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));

    return function (_x26) {
      return _ref11.apply(this, arguments);
    };
  }();
  /**
   * Gets a remote JSON-LD document using the default document loader or
   * one given in the passed options.
   *
   * @param url the URL to fetch.
   * @param [options] the options to use:
   *          [documentLoader] the document loader to use.
   *
   * @return a Promise that resolves to the retrieved remote document.
   */


  jsonld.get = /*#__PURE__*/function () {
    var _ref12 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(url, options) {
      var load, remoteDoc;
      return _regenerator["default"].wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (typeof options.documentLoader === 'function') {
                load = options.documentLoader;
              } else {
                load = jsonld.documentLoader;
              }

              _context12.next = 3;
              return load(url);

            case 3:
              remoteDoc = _context12.sent;
              _context12.prev = 4;

              if (remoteDoc.document) {
                _context12.next = 7;
                break;
              }

              throw new JsonLdError('No remote document found at the given URL.', 'jsonld.NullRemoteDocument');

            case 7:
              if (_isString(remoteDoc.document)) {
                remoteDoc.document = JSON.parse(remoteDoc.document);
              }

              _context12.next = 13;
              break;

            case 10:
              _context12.prev = 10;
              _context12.t0 = _context12["catch"](4);
              throw new JsonLdError('Could not retrieve a JSON-LD document from the URL.', 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                cause: _context12.t0,
                remoteDoc: remoteDoc
              });

            case 13:
              return _context12.abrupt("return", remoteDoc);

            case 14:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, null, [[4, 10]]);
    }));

    return function (_x27, _x28) {
      return _ref12.apply(this, arguments);
    };
  }();
  /**
   * Processes a local context, resolving any URLs as necessary, and returns a
   * new active context.
   *
   * @param activeCtx the current active context.
   * @param localCtx the local context to process.
   * @param [options] the options to use:
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the new active context.
   */


  jsonld.processContext = /*#__PURE__*/function () {
    var _ref13 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(activeCtx, localCtx, options) {
      return _regenerator["default"].wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              // set default options
              options = _setDefaults(options, {
                base: '',
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // return initial context early for null context

              if (!(localCtx === null)) {
                _context13.next = 3;
                break;
              }

              return _context13.abrupt("return", _getInitialContext(options));

            case 3:
              // get URLs in localCtx
              localCtx = util.clone(localCtx);

              if (!(_isObject(localCtx) && '@context' in localCtx)) {
                localCtx = {
                  '@context': localCtx
                };
              }

              return _context13.abrupt("return", _processContext({
                activeCtx: activeCtx,
                localCtx: localCtx,
                options: options
              }));

            case 6:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    }));

    return function (_x29, _x30, _x31) {
      return _ref13.apply(this, arguments);
    };
  }(); // backwards compatibility


  jsonld.getContextValue = require('./context').getContextValue;
  /**
   * Document loaders.
   */

  jsonld.documentLoaders = {};
  jsonld.documentLoaders.node = require('./documentLoaders/node');
  jsonld.documentLoaders.xhr = require('./documentLoaders/xhr');
  /**
   * Assigns the default document loader for external document URLs to a built-in
   * default. Supported types currently include: 'xhr' and 'node'.
   *
   * @param type the type to set.
   * @param [params] the parameters required to use the document loader.
   */

  jsonld.useDocumentLoader = function (type) {
    if (!(type in jsonld.documentLoaders)) {
      throw new JsonLdError('Unknown document loader type: "' + type + '"', 'jsonld.UnknownDocumentLoader', {
        type: type
      });
    } // set document loader


    jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));
  };
  /**
   * Registers an RDF dataset parser by content-type, for use with
   * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,
   * a string of input. An RDF dataset parser can be synchronous or
   * asynchronous (by returning a promise).
   *
   * @param contentType the content-type for the parser.
   * @param parser(input) the parser function (takes a string as a parameter
   *          and either returns an RDF dataset or a Promise that resolves to one.
   */


  jsonld.registerRDFParser = function (contentType, parser) {
    _rdfParsers[contentType] = parser;
  };
  /**
   * Unregisters an RDF dataset parser by content-type.
   *
   * @param contentType the content-type for the parser.
   */


  jsonld.unregisterRDFParser = function (contentType) {
    delete _rdfParsers[contentType];
  }; // register the N-Quads RDF parser


  jsonld.registerRDFParser('application/n-quads', NQuads.parse);
  jsonld.registerRDFParser('application/nquads', NQuads.parse); // register the RDFa API RDF parser

  jsonld.registerRDFParser('rdfa-api', Rdfa.parse);
  /* URL API */

  jsonld.url = require('./url');
  /* Utility API */

  jsonld.util = util; // backwards compatibility

  Object.assign(jsonld, util); // reexpose API as jsonld.promises for backwards compatability

  jsonld.promises = jsonld; // backwards compatibility

  jsonld.RequestQueue = require('./RequestQueue');
  /* WebIDL API */

  jsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld); // setup browser global JsonLdProcessor

  if (_browser && typeof global.JsonLdProcessor === 'undefined') {
    Object.defineProperty(global, 'JsonLdProcessor', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: jsonld.JsonLdProcessor
    });
  } // set platform-specific defaults/APIs


  if (_nodejs) {
    // use node document loader by default
    jsonld.useDocumentLoader('node');
  } else if (typeof XMLHttpRequest !== 'undefined') {
    // use xhr document loader by default
    jsonld.useDocumentLoader('xhr');
  }

  function _setDefaults(options, _ref14) {
    var _ref14$documentLoader = _ref14.documentLoader,
        documentLoader = _ref14$documentLoader === void 0 ? jsonld.documentLoader : _ref14$documentLoader,
        defaults = (0, _objectWithoutProperties2["default"])(_ref14, ["documentLoader"]);
    return Object.assign({}, {
      documentLoader: documentLoader
    }, defaults, options);
  } // end of jsonld API `wrapper` factory


  return jsonld;
}; // external APIs:
// used to generate a new jsonld API instance


var factory = function factory() {
  return wrapper(function () {
    return factory();
  });
}; // wrap the main jsonld API instance


wrapper(factory); // export API

module.exports = factory;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ContextResolver":90,"./JsonLdError":91,"./JsonLdProcessor":92,"./NQuads":93,"./Rdfa":94,"./RequestQueue":95,"./compact":97,"./context":99,"./documentLoaders/node":100,"./documentLoaders/xhr":101,"./expand":102,"./flatten":103,"./frame":104,"./fromRdf":105,"./graphTypes":106,"./nodeMap":108,"./toRdf":109,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/defineProperty":10,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/objectWithoutProperties":20,"@babel/runtime/regenerator":30,"_process":142,"lru-cache":113,"rdf-canonize":153}],108:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('./context'),
    isKeyword = _require.isKeyword;

var graphTypes = require('./graphTypes');

var types = require('./types');

var util = require('./util');

var JsonLdError = require('./JsonLdError');

var api = {};
module.exports = api;
/**
 * Creates a merged JSON-LD node map (node ID => node).
 *
 * @param input the expanded JSON-LD to create a node map of.
 * @param [options] the options to use:
 *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.
 *
 * @return the node map.
 */

api.createMergedNodeMap = function (input, options) {
  options = options || {}; // produce a map of all subjects and name each bnode

  var issuer = options.issuer || new util.IdentifierIssuer('_:b');
  var graphs = {
    '@default': {}
  };
  api.createNodeMap(input, graphs, '@default', issuer); // add all non-default graphs to default graph

  return api.mergeNodeMaps(graphs);
};
/**
 * Recursively flattens the subjects in the given JSON-LD expanded input
 * into a node map.
 *
 * @param input the JSON-LD expanded input.
 * @param graphs a map of graph name to subject map.
 * @param graph the name of the current graph.
 * @param issuer the blank node identifier issuer.
 * @param name the name assigned to the current input if it is a bnode.
 * @param list the list to append to, null for none.
 */


api.createNodeMap = function (input, graphs, graph, issuer, name, list) {
  // recurse through array
  if (types.isArray(input)) {
    var _iterator = _createForOfIteratorHelper(input),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;
        api.createNodeMap(node, graphs, graph, issuer, undefined, list);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return;
  } // add non-object to list


  if (!types.isObject(input)) {
    if (list) {
      list.push(input);
    }

    return;
  } // add values to list


  if (graphTypes.isValue(input)) {
    if ('@type' in input) {
      var type = input['@type']; // rename @type blank node

      if (type.indexOf('_:') === 0) {
        input['@type'] = type = issuer.getId(type);
      }
    }

    if (list) {
      list.push(input);
    }

    return;
  } else if (list && graphTypes.isList(input)) {
    var _list = [];
    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);
    list.push({
      '@list': _list
    });
    return;
  } // Note: At this point, input must be a subject.
  // spec requires @type to be named first, so assign names early


  if ('@type' in input) {
    var _types = input['@type'];

    var _iterator2 = _createForOfIteratorHelper(_types),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _type = _step2.value;

        if (_type.indexOf('_:') === 0) {
          issuer.getId(_type);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  } // get name for subject


  if (types.isUndefined(name)) {
    name = graphTypes.isBlankNode(input) ? issuer.getId(input['@id']) : input['@id'];
  } // add subject reference to list


  if (list) {
    list.push({
      '@id': name
    });
  } // create new subject or merge into existing one


  var subjects = graphs[graph];
  var subject = subjects[name] = subjects[name] || {};
  subject['@id'] = name;
  var properties = Object.keys(input).sort();

  var _iterator3 = _createForOfIteratorHelper(properties),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var property = _step3.value;

      // skip @id
      if (property === '@id') {
        continue;
      } // handle reverse properties


      if (property === '@reverse') {
        var referencedNode = {
          '@id': name
        };
        var reverseMap = input['@reverse'];

        for (var reverseProperty in reverseMap) {
          var items = reverseMap[reverseProperty];

          var _iterator4 = _createForOfIteratorHelper(items),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var item = _step4.value;
              var itemName = item['@id'];

              if (graphTypes.isBlankNode(item)) {
                itemName = issuer.getId(itemName);
              }

              api.createNodeMap(item, graphs, graph, issuer, itemName);
              util.addValue(subjects[itemName], reverseProperty, referencedNode, {
                propertyIsArray: true,
                allowDuplicate: false
              });
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }

        continue;
      } // recurse into graph


      if (property === '@graph') {
        // add graph subjects map entry
        if (!(name in graphs)) {
          graphs[name] = {};
        }

        api.createNodeMap(input[property], graphs, name, issuer);
        continue;
      } // recurse into included


      if (property === '@included') {
        api.createNodeMap(input[property], graphs, graph, issuer);
        continue;
      } // copy non-@type keywords


      if (property !== '@type' && isKeyword(property)) {
        if (property === '@index' && property in subject && (input[property] !== subject[property] || input[property]['@id'] !== subject[property]['@id'])) {
          throw new JsonLdError('Invalid JSON-LD syntax; conflicting @index property detected.', 'jsonld.SyntaxError', {
            code: 'conflicting indexes',
            subject: subject
          });
        }

        subject[property] = input[property];
        continue;
      } // iterate over objects


      var objects = input[property]; // if property is a bnode, assign it a new id

      if (property.indexOf('_:') === 0) {
        property = issuer.getId(property);
      } // ensure property is added for empty arrays


      if (objects.length === 0) {
        util.addValue(subject, property, [], {
          propertyIsArray: true
        });
        continue;
      }

      var _iterator5 = _createForOfIteratorHelper(objects),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var o = _step5.value;

          if (property === '@type') {
            // rename @type blank nodes
            o = o.indexOf('_:') === 0 ? issuer.getId(o) : o;
          } // handle embedded subject or subject reference


          if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {
            // skip null @id
            if ('@id' in o && !o['@id']) {
              continue;
            } // relabel blank node @id


            var id = graphTypes.isBlankNode(o) ? issuer.getId(o['@id']) : o['@id']; // add reference and recurse

            util.addValue(subject, property, {
              '@id': id
            }, {
              propertyIsArray: true,
              allowDuplicate: false
            });
            api.createNodeMap(o, graphs, graph, issuer, id);
          } else if (graphTypes.isValue(o)) {
            util.addValue(subject, property, o, {
              propertyIsArray: true,
              allowDuplicate: false
            });
          } else if (graphTypes.isList(o)) {
            // handle @list
            var _list2 = [];
            api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list2);
            o = {
              '@list': _list2
            };
            util.addValue(subject, property, o, {
              propertyIsArray: true,
              allowDuplicate: false
            });
          } else {
            // handle @value
            api.createNodeMap(o, graphs, graph, issuer, name);
            util.addValue(subject, property, o, {
              propertyIsArray: true,
              allowDuplicate: false
            });
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
};
/**
 * Merge separate named graphs into a single merged graph including
 * all nodes from the default graph and named graphs.
 *
 * @param graphs a map of graph name to subject map.
 *
 * @return the merged graph map.
 */


api.mergeNodeMapGraphs = function (graphs) {
  var merged = {};

  var _iterator6 = _createForOfIteratorHelper(Object.keys(graphs).sort()),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var name = _step6.value;

      var _iterator7 = _createForOfIteratorHelper(Object.keys(graphs[name]).sort()),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var id = _step7.value;
          var node = graphs[name][id];

          if (!(id in merged)) {
            merged[id] = {
              '@id': id
            };
          }

          var mergedNode = merged[id];

          var _iterator8 = _createForOfIteratorHelper(Object.keys(node).sort()),
              _step8;

          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var property = _step8.value;

              if (isKeyword(property) && property !== '@type') {
                // copy keywords
                mergedNode[property] = util.clone(node[property]);
              } else {
                // merge objects
                var _iterator9 = _createForOfIteratorHelper(node[property]),
                    _step9;

                try {
                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                    var value = _step9.value;
                    util.addValue(mergedNode, property, util.clone(value), {
                      propertyIsArray: true,
                      allowDuplicate: false
                    });
                  }
                } catch (err) {
                  _iterator9.e(err);
                } finally {
                  _iterator9.f();
                }
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return merged;
};

api.mergeNodeMaps = function (graphs) {
  // add all non-default graphs to default graph
  var defaultGraph = graphs['@default'];
  var graphNames = Object.keys(graphs).sort();

  var _iterator10 = _createForOfIteratorHelper(graphNames),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var graphName = _step10.value;

      if (graphName === '@default') {
        continue;
      }

      var nodeMap = graphs[graphName];
      var subject = defaultGraph[graphName];

      if (!subject) {
        defaultGraph[graphName] = subject = {
          '@id': graphName,
          '@graph': []
        };
      } else if (!('@graph' in subject)) {
        subject['@graph'] = [];
      }

      var graph = subject['@graph'];

      var _iterator11 = _createForOfIteratorHelper(Object.keys(nodeMap).sort()),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var id = _step11.value;
          var node = nodeMap[id]; // only add full subjects

          if (!graphTypes.isSubjectReference(node)) {
            graph.push(node);
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  return defaultGraph;
};

},{"./JsonLdError":91,"./context":99,"./graphTypes":106,"./types":110,"./util":112}],109:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('./nodeMap'),
    createNodeMap = _require.createNodeMap;

var _require2 = require('./context'),
    isKeyword = _require2.isKeyword;

var graphTypes = require('./graphTypes');

var jsonCanonicalize = require('canonicalize');

var types = require('./types');

var util = require('./util');

var _require3 = require('./constants'),
    RDF_FIRST = _require3.RDF_FIRST,
    RDF_REST = _require3.RDF_REST,
    RDF_NIL = _require3.RDF_NIL,
    RDF_TYPE = _require3.RDF_TYPE,
    RDF_JSON_LITERAL = _require3.RDF_JSON_LITERAL,
    RDF_LANGSTRING = _require3.RDF_LANGSTRING,
    XSD_BOOLEAN = _require3.XSD_BOOLEAN,
    XSD_DOUBLE = _require3.XSD_DOUBLE,
    XSD_INTEGER = _require3.XSD_INTEGER,
    XSD_STRING = _require3.XSD_STRING;

var _require4 = require('./url'),
    _isAbsoluteIri = _require4.isAbsolute;

var api = {};
module.exports = api;
/**
 * Outputs an RDF dataset for the expanded JSON-LD input.
 *
 * @param input the expanded JSON-LD input.
 * @param options the RDF serialization options.
 *
 * @return the RDF dataset.
 */

api.toRDF = function (input, options) {
  // create node map for default graph (and any named graphs)
  var issuer = new util.IdentifierIssuer('_:b');
  var nodeMap = {
    '@default': {}
  };
  createNodeMap(input, nodeMap, '@default', issuer);
  var dataset = [];
  var graphNames = Object.keys(nodeMap).sort();

  var _iterator = _createForOfIteratorHelper(graphNames),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var graphName = _step.value;
      var graphTerm = void 0;

      if (graphName === '@default') {
        graphTerm = {
          termType: 'DefaultGraph',
          value: ''
        };
      } else if (_isAbsoluteIri(graphName)) {
        if (graphName.startsWith('_:')) {
          graphTerm = {
            termType: 'BlankNode'
          };
        } else {
          graphTerm = {
            termType: 'NamedNode'
          };
        }

        graphTerm.value = graphName;
      } else {
        // skip relative IRIs (not valid RDF)
        continue;
      }

      _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return dataset;
};
/**
 * Adds RDF quads for a particular graph to the given dataset.
 *
 * @param dataset the dataset to append RDF quads to.
 * @param graph the graph to create RDF quads for.
 * @param graphTerm the graph term for each quad.
 * @param issuer a IdentifierIssuer for assigning blank node names.
 * @param options the RDF serialization options.
 *
 * @return the array of RDF triples for the given graph.
 */


function _graphToRDF(dataset, graph, graphTerm, issuer, options) {
  var ids = Object.keys(graph).sort();

  var _iterator2 = _createForOfIteratorHelper(ids),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var id = _step2.value;
      var node = graph[id];
      var properties = Object.keys(node).sort();

      var _iterator3 = _createForOfIteratorHelper(properties),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var property = _step3.value;
          var items = node[property];

          if (property === '@type') {
            property = RDF_TYPE;
          } else if (isKeyword(property)) {
            continue;
          }

          var _iterator4 = _createForOfIteratorHelper(items),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var item = _step4.value;
              // RDF subject
              var subject = {
                termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',
                value: id
              }; // skip relative IRI subjects (not valid RDF)

              if (!_isAbsoluteIri(id)) {
                continue;
              } // RDF predicate


              var predicate = {
                termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',
                value: property
              }; // skip relative IRI predicates (not valid RDF)

              if (!_isAbsoluteIri(property)) {
                continue;
              } // skip blank node predicates unless producing generalized RDF


              if (predicate.termType === 'BlankNode' && !options.produceGeneralizedRdf) {
                continue;
              } // convert list, value or node object to triple


              var object = _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection); // skip null objects (they are relative IRIs)


              if (object) {
                dataset.push({
                  subject: subject,
                  predicate: predicate,
                  object: object,
                  graph: graphTerm
                });
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
/**
 * Converts a @list value into linked list of blank node RDF quads
 * (an RDF collection).
 *
 * @param list the @list value.
 * @param issuer a IdentifierIssuer for assigning blank node names.
 * @param dataset the array of quads to append to.
 * @param graphTerm the graph term for each quad.
 *
 * @return the head of the list.
 */


function _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {
  var first = {
    termType: 'NamedNode',
    value: RDF_FIRST
  };
  var rest = {
    termType: 'NamedNode',
    value: RDF_REST
  };
  var nil = {
    termType: 'NamedNode',
    value: RDF_NIL
  };
  var last = list.pop(); // Result is the head of the list

  var result = last ? {
    termType: 'BlankNode',
    value: issuer.getId()
  } : nil;
  var subject = result;

  var _iterator5 = _createForOfIteratorHelper(list),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var item = _step5.value;

      var _object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);

      var next = {
        termType: 'BlankNode',
        value: issuer.getId()
      };
      dataset.push({
        subject: subject,
        predicate: first,
        object: _object,
        graph: graphTerm
      });
      dataset.push({
        subject: subject,
        predicate: rest,
        object: next,
        graph: graphTerm
      });
      subject = next;
    } // Tail of list

  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  if (last) {
    var object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);

    dataset.push({
      subject: subject,
      predicate: first,
      object: object,
      graph: graphTerm
    });
    dataset.push({
      subject: subject,
      predicate: rest,
      object: nil,
      graph: graphTerm
    });
  }

  return result;
}
/**
 * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,
 * node object to an RDF resource, or adds a list.
 *
 * @param item the JSON-LD value or node object.
 * @param issuer a IdentifierIssuer for assigning blank node names.
 * @param dataset the dataset to append RDF quads to.
 * @param graphTerm the graph term for each quad.
 *
 * @return the RDF literal or RDF resource.
 */


function _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {
  var object = {}; // convert value object to RDF

  if (graphTypes.isValue(item)) {
    object.termType = 'Literal';
    object.value = undefined;
    object.datatype = {
      termType: 'NamedNode'
    };
    var value = item['@value'];
    var datatype = item['@type'] || null; // convert to XSD/JSON datatypes as appropriate

    if (datatype === '@json') {
      object.value = jsonCanonicalize(value);
      object.datatype.value = RDF_JSON_LITERAL;
    } else if (types.isBoolean(value)) {
      object.value = value.toString();
      object.datatype.value = datatype || XSD_BOOLEAN;
    } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {
      if (!types.isDouble(value)) {
        value = parseFloat(value);
      } // canonical double representation


      object.value = value.toExponential(15).replace(/(\d)0*e\+?/, '$1E');
      object.datatype.value = datatype || XSD_DOUBLE;
    } else if (types.isNumber(value)) {
      object.value = value.toFixed(0);
      object.datatype.value = datatype || XSD_INTEGER;
    } else if (rdfDirection === 'i18n-datatype' && '@direction' in item) {
      var _datatype = 'https://www.w3.org/ns/i18n#' + (item['@language'] || '') + "_".concat(item['@direction']);

      object.datatype.value = _datatype;
      object.value = value;
    } else if ('@language' in item) {
      object.value = value;
      object.datatype.value = datatype || RDF_LANGSTRING;
      object.language = item['@language'];
    } else {
      object.value = value;
      object.datatype.value = datatype || XSD_STRING;
    }
  } else if (graphTypes.isList(item)) {
    var _list = _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection);

    object.termType = _list.termType;
    object.value = _list.value;
  } else {
    // convert string/node object to RDF
    var id = types.isObject(item) ? item['@id'] : item;
    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';
    object.value = id;
  } // skip relative IRIs, not valid RDF


  if (object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {
    return null;
  }

  return object;
}

},{"./constants":98,"./context":99,"./graphTypes":106,"./nodeMap":108,"./types":110,"./url":111,"./util":112,"canonicalize":61}],110:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var api = {};
module.exports = api;
/**
 * Returns true if the given value is an Array.
 *
 * @param v the value to check.
 *
 * @return true if the value is an Array, false if not.
 */

api.isArray = Array.isArray;
/**
 * Returns true if the given value is a Boolean.
 *
 * @param v the value to check.
 *
 * @return true if the value is a Boolean, false if not.
 */

api.isBoolean = function (v) {
  return typeof v === 'boolean' || Object.prototype.toString.call(v) === '[object Boolean]';
};
/**
 * Returns true if the given value is a double.
 *
 * @param v the value to check.
 *
 * @return true if the value is a double, false if not.
 */


api.isDouble = function (v) {
  return api.isNumber(v) && (String(v).indexOf('.') !== -1 || Math.abs(v) >= 1e21);
};
/**
 * Returns true if the given value is an empty Object.
 *
 * @param v the value to check.
 *
 * @return true if the value is an empty Object, false if not.
 */


api.isEmptyObject = function (v) {
  return api.isObject(v) && Object.keys(v).length === 0;
};
/**
 * Returns true if the given value is a Number.
 *
 * @param v the value to check.
 *
 * @return true if the value is a Number, false if not.
 */


api.isNumber = function (v) {
  return typeof v === 'number' || Object.prototype.toString.call(v) === '[object Number]';
};
/**
 * Returns true if the given value is numeric.
 *
 * @param v the value to check.
 *
 * @return true if the value is numeric, false if not.
 */


api.isNumeric = function (v) {
  return !isNaN(parseFloat(v)) && isFinite(v);
};
/**
 * Returns true if the given value is an Object.
 *
 * @param v the value to check.
 *
 * @return true if the value is an Object, false if not.
 */


api.isObject = function (v) {
  return Object.prototype.toString.call(v) === '[object Object]';
};
/**
 * Returns true if the given value is a String.
 *
 * @param v the value to check.
 *
 * @return true if the value is a String, false if not.
 */


api.isString = function (v) {
  return typeof v === 'string' || Object.prototype.toString.call(v) === '[object String]';
};
/**
 * Returns true if the given value is undefined.
 *
 * @param v the value to check.
 *
 * @return true if the value is undefined, false if not.
 */


api.isUndefined = function (v) {
  return typeof v === 'undefined';
};

},{}],111:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var types = require('./types');

var api = {};
module.exports = api; // define URL parser
// parseUri 1.2.2
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
// with local jsonld.js modifications

api.parsers = {
  simple: {
    // RFC 3986 basic parts
    keys: ['href', 'scheme', 'authority', 'path', 'query', 'fragment'],

    /* eslint-disable-next-line max-len */
    regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
  },
  full: {
    keys: ['href', 'protocol', 'scheme', 'authority', 'auth', 'user', 'password', 'hostname', 'port', 'path', 'directory', 'file', 'query', 'fragment'],

    /* eslint-disable-next-line max-len */
    regex: /^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};

api.parse = function (str, parser) {
  var parsed = {};
  var o = api.parsers[parser || 'full'];
  var m = o.regex.exec(str);
  var i = o.keys.length;

  while (i--) {
    parsed[o.keys[i]] = m[i] === undefined ? null : m[i];
  } // remove default ports in found in URLs


  if (parsed.scheme === 'https' && parsed.port === '443' || parsed.scheme === 'http' && parsed.port === '80') {
    parsed.href = parsed.href.replace(':' + parsed.port, '');
    parsed.authority = parsed.authority.replace(':' + parsed.port, '');
    parsed.port = null;
  }

  parsed.normalizedPath = api.removeDotSegments(parsed.path);
  return parsed;
};
/**
 * Prepends a base IRI to the given relative IRI.
 *
 * @param base the base IRI.
 * @param iri the relative IRI.
 *
 * @return the absolute IRI.
 */


api.prependBase = function (base, iri) {
  // skip IRI processing
  if (base === null) {
    return iri;
  } // already an absolute IRI


  if (api.isAbsolute(iri)) {
    return iri;
  } // parse base if it is a string


  if (!base || types.isString(base)) {
    base = api.parse(base || '');
  } // parse given IRI


  var rel = api.parse(iri); // per RFC3986 5.2.2

  var transform = {
    protocol: base.protocol || ''
  };

  if (rel.authority !== null) {
    transform.authority = rel.authority;
    transform.path = rel.path;
    transform.query = rel.query;
  } else {
    transform.authority = base.authority;

    if (rel.path === '') {
      transform.path = base.path;

      if (rel.query !== null) {
        transform.query = rel.query;
      } else {
        transform.query = base.query;
      }
    } else {
      if (rel.path.indexOf('/') === 0) {
        // IRI represents an absolute path
        transform.path = rel.path;
      } else {
        // merge paths
        var path = base.path; // append relative path to the end of the last directory from base

        path = path.substr(0, path.lastIndexOf('/') + 1);

        if ((path.length > 0 || base.authority) && path.substr(-1) !== '/') {
          path += '/';
        }

        path += rel.path;
        transform.path = path;
      }

      transform.query = rel.query;
    }
  }

  if (rel.path !== '') {
    // remove slashes and dots in path
    transform.path = api.removeDotSegments(transform.path);
  } // construct URL


  var rval = transform.protocol;

  if (transform.authority !== null) {
    rval += '//' + transform.authority;
  }

  rval += transform.path;

  if (transform.query !== null) {
    rval += '?' + transform.query;
  }

  if (rel.fragment !== null) {
    rval += '#' + rel.fragment;
  } // handle empty base


  if (rval === '') {
    rval = './';
  }

  return rval;
};
/**
 * Removes a base IRI from the given absolute IRI.
 *
 * @param base the base IRI.
 * @param iri the absolute IRI.
 *
 * @return the relative IRI if relative to base, otherwise the absolute IRI.
 */


api.removeBase = function (base, iri) {
  // skip IRI processing
  if (base === null) {
    return iri;
  }

  if (!base || types.isString(base)) {
    base = api.parse(base || '');
  } // establish base root


  var root = '';

  if (base.href !== '') {
    root += (base.protocol || '') + '//' + (base.authority || '');
  } else if (iri.indexOf('//')) {
    // support network-path reference with empty base
    root += '//';
  } // IRI not relative to base


  if (iri.indexOf(root) !== 0) {
    return iri;
  } // remove root from IRI and parse remainder


  var rel = api.parse(iri.substr(root.length)); // remove path segments that match (do not remove last segment unless there
  // is a hash or query)

  var baseSegments = base.normalizedPath.split('/');
  var iriSegments = rel.normalizedPath.split('/');
  var last = rel.fragment || rel.query ? 0 : 1;

  while (baseSegments.length > 0 && iriSegments.length > last) {
    if (baseSegments[0] !== iriSegments[0]) {
      break;
    }

    baseSegments.shift();
    iriSegments.shift();
  } // use '../' for each non-matching base segment


  var rval = '';

  if (baseSegments.length > 0) {
    // don't count the last segment (if it ends with '/' last path doesn't
    // count and if it doesn't end with '/' it isn't a path)
    baseSegments.pop();

    for (var i = 0; i < baseSegments.length; ++i) {
      rval += '../';
    }
  } // prepend remaining segments


  rval += iriSegments.join('/'); // add query and hash

  if (rel.query !== null) {
    rval += '?' + rel.query;
  }

  if (rel.fragment !== null) {
    rval += '#' + rel.fragment;
  } // handle empty base


  if (rval === '') {
    rval = './';
  }

  return rval;
};
/**
 * Removes dot segments from a URL path.
 *
 * @param path the path to remove dot segments from.
 */


api.removeDotSegments = function (path) {
  // RFC 3986 5.2.4 (reworked)
  // empty path shortcut
  if (path.length === 0) {
    return '';
  }

  var input = path.split('/');
  var output = [];

  while (input.length > 0) {
    var next = input.shift();
    var done = input.length === 0;

    if (next === '.') {
      if (done) {
        // ensure output has trailing /
        output.push('');
      }

      continue;
    }

    if (next === '..') {
      output.pop();

      if (done) {
        // ensure output has trailing /
        output.push('');
      }

      continue;
    }

    output.push(next);
  } // if path was absolute, ensure output has leading /


  if (path[0] === '/' && output.length > 0 && output[0] !== '') {
    output.unshift('');
  }

  if (output.length === 1 && output[0] === '') {
    return '/';
  }

  return output.join('/');
}; // TODO: time better isAbsolute/isRelative checks using full regexes:
// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html
// regex to check for absolute IRI (starting scheme and ':') or blank node IRI


var isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
/**
 * Returns true if the given value is an absolute IRI or blank node IRI, false
 * if not.
 * Note: This weak check only checks for a correct starting scheme.
 *
 * @param v the value to check.
 *
 * @return true if the value is an absolute IRI, false if not.
 */

api.isAbsolute = function (v) {
  return types.isString(v) && isAbsoluteRegex.test(v);
};
/**
 * Returns true if the given value is a relative IRI, false if not.
 * Note: this is a weak check.
 *
 * @param v the value to check.
 *
 * @return true if the value is a relative IRI, false if not.
 */


api.isRelative = function (v) {
  return types.isString(v);
};

},{"./types":110}],112:[function(require,module,exports){
/*
 * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var graphTypes = require('./graphTypes');

var types = require('./types'); // TODO: move `IdentifierIssuer` to its own package


var IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;

var JsonLdError = require('./JsonLdError'); // constants


var REGEX_LINK_HEADERS = /(?:<[^>]*?>|"[^"]*?"|[^,])+/g;
var REGEX_LINK_HEADER = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
var REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
var DEFAULTS = {
  headers: {
    accept: 'application/ld+json, application/json'
  }
};
var api = {};
module.exports = api;
api.IdentifierIssuer = IdentifierIssuer;
/**
 * Clones an object, array, Map, Set, or string/number. If a typed JavaScript
 * object is given, such as a Date, it will be converted to a string.
 *
 * @param value the value to clone.
 *
 * @return the cloned value.
 */

api.clone = function (value) {
  if (value && (0, _typeof2["default"])(value) === 'object') {
    var rval;

    if (types.isArray(value)) {
      rval = [];

      for (var i = 0; i < value.length; ++i) {
        rval[i] = api.clone(value[i]);
      }
    } else if (value instanceof Map) {
      rval = new Map();

      var _iterator = _createForOfIteratorHelper(value),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
              k = _step$value[0],
              v = _step$value[1];

          rval.set(k, api.clone(v));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else if (value instanceof Set) {
      rval = new Set();

      var _iterator2 = _createForOfIteratorHelper(value),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _v = _step2.value;
          rval.add(api.clone(_v));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } else if (types.isObject(value)) {
      rval = {};

      for (var key in value) {
        rval[key] = api.clone(value[key]);
      }
    } else {
      rval = value.toString();
    }

    return rval;
  }

  return value;
};
/**
 * Ensure a value is an array. If the value is an array, it is returned.
 * Otherwise, it is wrapped in an array.
 *
 * @param value the value to return as an array.
 *
 * @return the value as an array.
 */


api.asArray = function (value) {
  return Array.isArray(value) ? value : [value];
};
/**
 * Builds an HTTP headers object for making a JSON-LD request from custom
 * headers and asserts the `accept` header isn't overridden.
 *
 * @param headers an object of headers with keys as header names and values
 *          as header values.
 *
 * @return an object of headers with a valid `accept` header.
 */


api.buildHeaders = function () {
  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var hasAccept = Object.keys(headers).some(function (h) {
    return h.toLowerCase() === 'accept';
  });

  if (hasAccept) {
    throw new RangeError('Accept header may not be specified; only "' + DEFAULTS.headers.accept + '" is supported.');
  }

  return Object.assign({
    Accept: DEFAULTS.headers.accept
  }, headers);
};
/**
 * Parses a link header. The results will be key'd by the value of "rel".
 *
 * Link: <http://json-ld.org/contexts/person.jsonld>;
 * rel="http://www.w3.org/ns/json-ld#context"; type="application/ld+json"
 *
 * Parses as: {
 *   'http://www.w3.org/ns/json-ld#context': {
 *     target: http://json-ld.org/contexts/person.jsonld,
 *     type: 'application/ld+json'
 *   }
 * }
 *
 * If there is more than one "rel" with the same IRI, then entries in the
 * resulting map for that "rel" will be arrays.
 *
 * @param header the link header to parse.
 */


api.parseLinkHeader = function (header) {
  var rval = {}; // split on unbracketed/unquoted commas

  var entries = header.match(REGEX_LINK_HEADERS);

  for (var i = 0; i < entries.length; ++i) {
    var match = entries[i].match(REGEX_LINK_HEADER);

    if (!match) {
      continue;
    }

    var result = {
      target: match[1]
    };
    var params = match[2];

    while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {
      result[match[1]] = match[2] === undefined ? match[3] : match[2];
    }

    var rel = result['rel'] || '';

    if (Array.isArray(rval[rel])) {
      rval[rel].push(result);
    } else if (rval.hasOwnProperty(rel)) {
      rval[rel] = [rval[rel], result];
    } else {
      rval[rel] = result;
    }
  }

  return rval;
};
/**
 * Throws an exception if the given value is not a valid @type value.
 *
 * @param v the value to check.
 */


api.validateTypeValue = function (v, isFrame) {
  if (types.isString(v)) {
    return;
  }

  if (types.isArray(v) && v.every(function (vv) {
    return types.isString(vv);
  })) {
    return;
  }

  if (isFrame && types.isObject(v)) {
    switch (Object.keys(v).length) {
      case 0:
        // empty object is wildcard
        return;

      case 1:
        // default entry is all strings
        if ('@default' in v && api.asArray(v['@default']).every(function (vv) {
          return types.isString(vv);
        })) {
          return;
        }

    }
  }

  throw new JsonLdError('Invalid JSON-LD syntax; "@type" value must a string, an array of ' + 'strings, an empty object, ' + 'or a default object.', 'jsonld.SyntaxError', {
    code: 'invalid type value',
    value: v
  });
};
/**
 * Returns true if the given subject has the given property.
 *
 * @param subject the subject to check.
 * @param property the property to look for.
 *
 * @return true if the subject has the given property, false if not.
 */


api.hasProperty = function (subject, property) {
  if (subject.hasOwnProperty(property)) {
    var value = subject[property];
    return !types.isArray(value) || value.length > 0;
  }

  return false;
};
/**
 * Determines if the given value is a property of the given subject.
 *
 * @param subject the subject to check.
 * @param property the property to check.
 * @param value the value to check.
 *
 * @return true if the value exists, false if not.
 */


api.hasValue = function (subject, property, value) {
  if (api.hasProperty(subject, property)) {
    var val = subject[property];
    var isList = graphTypes.isList(val);

    if (types.isArray(val) || isList) {
      if (isList) {
        val = val['@list'];
      }

      for (var i = 0; i < val.length; ++i) {
        if (api.compareValues(value, val[i])) {
          return true;
        }
      }
    } else if (!types.isArray(value)) {
      // avoid matching the set of values with an array value parameter
      return api.compareValues(value, val);
    }
  }

  return false;
};
/**
 * Adds a value to a subject. If the value is an array, all values in the
 * array will be added.
 *
 * @param subject the subject to add the value to.
 * @param property the property that relates the value to the subject.
 * @param value the value to add.
 * @param [options] the options to use:
 *        [propertyIsArray] true if the property is always an array, false
 *          if not (default: false).
 *        [valueIsArray] true if the value to be added should be preserved as
 *          an array (lists) (default: false).
 *        [allowDuplicate] true to allow duplicates, false not to (uses a
 *          simple shallow comparison of subject ID or value) (default: true).
 *        [prependValue] false to prepend value to any existing values.
 *          (default: false)
 */


api.addValue = function (subject, property, value, options) {
  options = options || {};

  if (!('propertyIsArray' in options)) {
    options.propertyIsArray = false;
  }

  if (!('valueIsArray' in options)) {
    options.valueIsArray = false;
  }

  if (!('allowDuplicate' in options)) {
    options.allowDuplicate = true;
  }

  if (!('prependValue' in options)) {
    options.prependValue = false;
  }

  if (options.valueIsArray) {
    subject[property] = value;
  } else if (types.isArray(value)) {
    if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {
      subject[property] = [];
    }

    if (options.prependValue) {
      value = value.concat(subject[property]);
      subject[property] = [];
    }

    for (var i = 0; i < value.length; ++i) {
      api.addValue(subject, property, value[i], options);
    }
  } else if (subject.hasOwnProperty(property)) {
    // check if subject already has value if duplicates not allowed
    var hasValue = !options.allowDuplicate && api.hasValue(subject, property, value); // make property an array if value not present or always an array

    if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {
      subject[property] = [subject[property]];
    } // add new value


    if (!hasValue) {
      if (options.prependValue) {
        subject[property].unshift(value);
      } else {
        subject[property].push(value);
      }
    }
  } else {
    // add new value as set or single value
    subject[property] = options.propertyIsArray ? [value] : value;
  }
};
/**
 * Gets all of the values for a subject's property as an array.
 *
 * @param subject the subject.
 * @param property the property.
 *
 * @return all of the values for a subject's property as an array.
 */


api.getValues = function (subject, property) {
  return [].concat(subject[property] || []);
};
/**
 * Removes a property from a subject.
 *
 * @param subject the subject.
 * @param property the property.
 */


api.removeProperty = function (subject, property) {
  delete subject[property];
};
/**
 * Removes a value from a subject.
 *
 * @param subject the subject.
 * @param property the property that relates the value to the subject.
 * @param value the value to remove.
 * @param [options] the options to use:
 *          [propertyIsArray] true if the property is always an array, false
 *            if not (default: false).
 */


api.removeValue = function (subject, property, value, options) {
  options = options || {};

  if (!('propertyIsArray' in options)) {
    options.propertyIsArray = false;
  } // filter out value


  var values = api.getValues(subject, property).filter(function (e) {
    return !api.compareValues(e, value);
  });

  if (values.length === 0) {
    api.removeProperty(subject, property);
  } else if (values.length === 1 && !options.propertyIsArray) {
    subject[property] = values[0];
  } else {
    subject[property] = values;
  }
};
/**
 * Relabels all blank nodes in the given JSON-LD input.
 *
 * @param input the JSON-LD input.
 * @param [options] the options to use:
 *          [issuer] an IdentifierIssuer to use to label blank nodes.
 */


api.relabelBlankNodes = function (input, options) {
  options = options || {};
  var issuer = options.issuer || new IdentifierIssuer('_:b');
  return _labelBlankNodes(issuer, input);
};
/**
 * Compares two JSON-LD values for equality. Two JSON-LD values will be
 * considered equal if:
 *
 * 1. They are both primitives of the same type and value.
 * 2. They are both @values with the same @value, @type, @language,
 *   and @index, OR
 * 3. They both have @ids they are the same.
 *
 * @param v1 the first value.
 * @param v2 the second value.
 *
 * @return true if v1 and v2 are considered equal, false if not.
 */


api.compareValues = function (v1, v2) {
  // 1. equal primitives
  if (v1 === v2) {
    return true;
  } // 2. equal @values


  if (graphTypes.isValue(v1) && graphTypes.isValue(v2) && v1['@value'] === v2['@value'] && v1['@type'] === v2['@type'] && v1['@language'] === v2['@language'] && v1['@index'] === v2['@index']) {
    return true;
  } // 3. equal @ids


  if (types.isObject(v1) && '@id' in v1 && types.isObject(v2) && '@id' in v2) {
    return v1['@id'] === v2['@id'];
  }

  return false;
};
/**
 * Compares two strings first based on length and then lexicographically.
 *
 * @param a the first string.
 * @param b the second string.
 *
 * @return -1 if a < b, 1 if a > b, 0 if a === b.
 */


api.compareShortestLeast = function (a, b) {
  if (a.length < b.length) {
    return -1;
  }

  if (b.length < a.length) {
    return 1;
  }

  if (a === b) {
    return 0;
  }

  return a < b ? -1 : 1;
};
/**
 * Labels the blank nodes in the given value using the given IdentifierIssuer.
 *
 * @param issuer the IdentifierIssuer to use.
 * @param element the element with blank nodes to rename.
 *
 * @return the element.
 */


function _labelBlankNodes(issuer, element) {
  if (types.isArray(element)) {
    for (var i = 0; i < element.length; ++i) {
      element[i] = _labelBlankNodes(issuer, element[i]);
    }
  } else if (graphTypes.isList(element)) {
    element['@list'] = _labelBlankNodes(issuer, element['@list']);
  } else if (types.isObject(element)) {
    // relabel blank node
    if (graphTypes.isBlankNode(element)) {
      element['@id'] = issuer.getId(element['@id']);
    } // recursively apply to all keys


    var keys = Object.keys(element).sort();

    for (var ki = 0; ki < keys.length; ++ki) {
      var key = keys[ki];

      if (key !== '@id') {
        element[key] = _labelBlankNodes(issuer, element[key]);
      }
    }
  }

  return element;
}

},{"./JsonLdError":91,"./graphTypes":106,"./types":110,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/typeof":27,"rdf-canonize":153}],113:[function(require,module,exports){
'use strict'; // A linked list to keep track of recently-used-ness

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var Yallist = require('yallist');

var MAX = Symbol('max');
var LENGTH = Symbol('length');
var LENGTH_CALCULATOR = Symbol('lengthCalculator');
var ALLOW_STALE = Symbol('allowStale');
var MAX_AGE = Symbol('maxAge');
var DISPOSE = Symbol('dispose');
var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
var LRU_LIST = Symbol('lruList');
var CACHE = Symbol('cache');
var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

var naiveLength = function naiveLength() {
  return 1;
}; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


var LRUCache = /*#__PURE__*/function () {
  function LRUCache(options) {
    (0, _classCallCheck2["default"])(this, LRUCache);
    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    var max = this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  (0, _createClass2["default"])(LRUCache, [{
    key: "rforEach",
    value: function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
  }, {
    key: "forEach",
    value: function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].head; walker !== null;) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
  }, {
    key: "keys",
    value: function keys() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.key;
      });
    }
  }, {
    key: "values",
    value: function values() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.value;
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this = this;

      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function (hit) {
          return _this[DISPOSE](hit.key, hit.value);
        });
      }

      this[CACHE] = new Map(); // hash of items by key

      this[LRU_LIST] = new Yallist(); // list of items in order of use recency

      this[LENGTH] = 0; // length of items in the list
    }
  }, {
    key: "dump",
    value: function dump() {
      var _this2 = this;

      return this[LRU_LIST].map(function (hit) {
        return isStale(_this2, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    }
  }, {
    key: "dumpLru",
    value: function dumpLru() {
      return this[LRU_LIST];
    }
  }, {
    key: "set",
    value: function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);

      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          _del(this, this[CACHE].get(key));

          return false;
        }

        var node = this[CACHE].get(key);
        var item = node.value; // dispose of the old one before overwriting
        // split out into 2 ifs for better coverage tracking

        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }

      var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }

      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (!this[CACHE].has(key)) return false;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
  }, {
    key: "get",
    value: function get(key) {
      return _get(this, key, true);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      return _get(this, key, false);
    }
  }, {
    key: "pop",
    value: function pop() {
      var node = this[LRU_LIST].tail;
      if (!node) return null;

      _del(this, node);

      return node.value;
    }
  }, {
    key: "del",
    value: function del(key) {
      _del(this, this[CACHE].get(key));
    }
  }, {
    key: "load",
    value: function load(arr) {
      // reset the cache
      this.reset();
      var now = Date.now(); // A previous serialized cache has the most recent items first

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) // the item was created without expiration in a non aged cache
          this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now; // dont add already expired items

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
  }, {
    key: "prune",
    value: function prune() {
      var _this3 = this;

      this[CACHE].forEach(function (value, key) {
        return _get(_this3, key, false);
      });
    }
  }, {
    key: "max",
    set: function set(mL) {
      if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
      this[MAX] = mL || Infinity;
      trim(this);
    },
    get: function get() {
      return this[MAX];
    }
  }, {
    key: "allowStale",
    set: function set(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    },
    get: function get() {
      return this[ALLOW_STALE];
    }
  }, {
    key: "maxAge",
    set: function set(mA) {
      if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
      this[MAX_AGE] = mA;
      trim(this);
    },
    get: function get() {
      return this[MAX_AGE];
    } // resize the cache when the lengthCalculator changes.

  }, {
    key: "lengthCalculator",
    set: function set(lC) {
      var _this4 = this;

      if (typeof lC !== 'function') lC = naiveLength;

      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(function (hit) {
          hit.length = _this4[LENGTH_CALCULATOR](hit.value, hit.key);
          _this4[LENGTH] += hit.length;
        });
      }

      trim(this);
    },
    get: function get() {
      return this[LENGTH_CALCULATOR];
    }
  }, {
    key: "length",
    get: function get() {
      return this[LENGTH];
    }
  }, {
    key: "itemCount",
    get: function get() {
      return this[LRU_LIST].length;
    }
  }]);
  return LRUCache;
}();

var _get = function _get(self, key, doUse) {
  var node = self[CACHE].get(key);

  if (node) {
    var hit = node.value;

    if (isStale(self, hit)) {
      _del(self, node);

      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

var isStale = function isStale(self, hit) {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};

var trim = function trim(self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev;

      _del(self, walker);

      walker = prev;
    }
  }
};

var _del = function _del(self, node) {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE]["delete"](hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

var Entry = function Entry(key, value, length, now, maxAge) {
  (0, _classCallCheck2["default"])(this, Entry);
  this.key = key;
  this.value = value;
  this.length = length;
  this.now = now;
  this.maxAge = maxAge || 0;
};

var forEachStep = function forEachStep(self, fn, node, thisp) {
  var hit = node.value;

  if (isStale(self, hit)) {
    _del(self, node);

    if (!self[ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

module.exports = LRUCache;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"yallist":196}],114:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./lib/propertyhandler/IItemPropertyHandler"), exports);

__exportStar(require("./lib/propertyhandler/ItemPropertyHandlerContent"), exports);

__exportStar(require("./lib/propertyhandler/ItemPropertyHandlerNumber"), exports);

__exportStar(require("./lib/propertyhandler/ItemPropertyHandlerTime"), exports);

__exportStar(require("./lib/propertyhandler/ItemPropertyHandlerUrl"), exports);

__exportStar(require("./lib/IHtmlParseListener"), exports);

__exportStar(require("./lib/IItemScope"), exports);

__exportStar(require("./lib/IVocabRegistry"), exports);

__exportStar(require("./lib/MicrodataRdfParser"), exports);

__exportStar(require("./lib/Util"), exports);

},{"./lib/IHtmlParseListener":115,"./lib/IItemScope":116,"./lib/IVocabRegistry":117,"./lib/MicrodataRdfParser":118,"./lib/Util":119,"./lib/propertyhandler/IItemPropertyHandler":120,"./lib/propertyhandler/ItemPropertyHandlerContent":121,"./lib/propertyhandler/ItemPropertyHandlerNumber":122,"./lib/propertyhandler/ItemPropertyHandlerTime":123,"./lib/propertyhandler/ItemPropertyHandlerUrl":124}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],118:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MicrodataRdfParser = void 0;

var stream_1 = require("stream");

var htmlparser2_1 = require("htmlparser2");

var ItemPropertyHandlerContent_1 = require("./propertyhandler/ItemPropertyHandlerContent");

var ItemPropertyHandlerNumber_1 = require("./propertyhandler/ItemPropertyHandlerNumber");

var ItemPropertyHandlerTime_1 = require("./propertyhandler/ItemPropertyHandlerTime");

var ItemPropertyHandlerUrl_1 = require("./propertyhandler/ItemPropertyHandlerUrl");

var Util_1 = require("./Util");

var VOCAB_REGISTRY_DEFAULT = require("./vocab-registry-default.json");
/**
 * A stream transformer that parses Microdata (text) streams to an {@link RDF.Stream}.
 */


var MicrodataRdfParser = /*#__PURE__*/function (_stream_1$Transform) {
  (0, _inherits2["default"])(MicrodataRdfParser, _stream_1$Transform);

  var _super = _createSuper(MicrodataRdfParser);

  function MicrodataRdfParser(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, MicrodataRdfParser);
    _this = _super.call(this, {
      readableObjectMode: true
    }); // Stacks, where the key is the current depth.

    _this.itemScopeStack = [];
    _this.textBufferStack = []; // Variables for managing itemrefs.

    _this.isEmittingReferences = false;
    _this.pendingItemRefsDomain = {};
    _this.pendingItemRefsRangeFinalized = {}; // eslint-disable-next-line lines-between-class-members

    _this.pendingItemRefsRangeCollecting = {};
    options = options || {};
    _this.options = options;
    _this.util = new Util_1.Util(options.dataFactory, options.baseIRI);
    _this.defaultGraph = options.defaultGraph || _this.util.dataFactory.defaultGraph();
    _this.htmlParseListener = options.htmlParseListener;
    _this.vocabRegistry = options.vocabRegistry || VOCAB_REGISTRY_DEFAULT;
    _this.parser = _this.initializeParser(!!options.xmlMode);
    return _this;
  }
  /**
   * Parses the given text stream into a quad stream.
   * @param {NodeJS.EventEmitter} stream A text stream.
   * @return {RDF.Stream} A quad stream.
   */


  (0, _createClass2["default"])(MicrodataRdfParser, [{
    key: "import",
    value: function _import(stream) {
      var output = new stream_1.PassThrough({
        readableObjectMode: true
      });
      stream.on('error', function (error) {
        return parsed.emit('error', error);
      });
      stream.on('data', function (data) {
        return output.push(data);
      });
      stream.on('end', function () {
        return output.push(null);
      });
      var parsed = output.pipe(new MicrodataRdfParser(this.options));
      return parsed;
    }
  }, {
    key: "_transform",
    value: function _transform(chunk, encoding, callback) {
      this.parser.write(chunk);
      callback();
    }
  }, {
    key: "_flush",
    value: function _flush(callback) {
      this.parser.end();
      callback();
    }
    /**
     * Get the current item scope for the current depth.
     * This will skip all undefined item scopes.
     * @param parent If we should start looking one level higher in the stack.
     */

  }, {
    key: "getItemScope",
    value: function getItemScope(parent) {
      var parentTagI = this.itemScopeStack.length - (parent ? 2 : 1);

      while (parentTagI > 0 && !this.itemScopeStack[parentTagI]) {
        parentTagI--;
      }

      return this.itemScopeStack[parentTagI];
    }
    /**
     * Get the current stack depth.
     */

  }, {
    key: "getDepth",
    value: function getDepth() {
      return this.itemScopeStack.length;
    }
  }, {
    key: "onTagOpen",
    value: function onTagOpen(name, attributes) {
      if (!this.isEmittingReferences) {
        // If the tag has an 'id', start collecting the whole stack in the item reference buffer
        if ('id' in attributes) {
          var id = attributes.id;
          this.pendingItemRefsRangeCollecting[id] = {
            events: [],
            counter: 0,
            ids: []
          };
        } // Store this event in all collecting item reference buffers


        for (var _i = 0, _Object$values = Object.values(this.pendingItemRefsRangeCollecting); _i < _Object$values.length; _i++) {
          var buffer = _Object$values[_i];
          buffer.counter++;
          buffer.events.push({
            type: 'open',
            name: name,
            attributes: attributes
          });
        }
      } // Ensure the text buffer stack is in line with the stack depth
      // eslint-disable-next-line unicorn/no-useless-undefined


      this.textBufferStack.push(undefined); // Processing steps based on https://w3c.github.io/microdata-rdf/#rdf-conversion-algorithm
      // 1. Determine the current item scope

      var itemScope;

      if ('itemscope' in attributes) {
        // Create a new item scope
        var subject;

        if (this.emittingReferencesItemScopeIdGenerator) {
          subject = this.emittingReferencesItemScopeIdGenerator();
        } else {
          subject = 'itemid' in attributes && this.util.createSubject(attributes.itemid) || this.util.dataFactory.blankNode(); // Store the genererated id in all collecting item reference buffers

          for (var _i2 = 0, _Object$values2 = Object.values(this.pendingItemRefsRangeCollecting); _i2 < _Object$values2.length; _i2++) {
            var _buffer = _Object$values2[_i2];

            _buffer.ids.push(subject);
          }
        }

        itemScope = {
          subject: subject
        }; // If the id was reused from a reference, block any new triples to be generated from it

        if (this.isEmittingReferences) {
          itemScope.blockEmission = true;
        } // Inherit vocab from parent item scope


        var parentItemScope = this.getItemScope();

        if (parentItemScope && parentItemScope.vocab) {
          itemScope.vocab = parentItemScope.vocab;
        } // 2. Push any changes to the item scope to the stack


        this.itemScopeStack.push(itemScope);
      } else {
        // Determine the parent item scope
        itemScope = this.getItemScope(); // 2. Push any changes to the item scope to the stack
        // eslint-disable-next-line unicorn/no-useless-undefined

        this.itemScopeStack.push(undefined);
      } // If we have a valid item scope, process the current node


      if (itemScope) {
        // 3. Handle item types
        if ('itemtype' in attributes) {
          var _iterator = _createForOfIteratorHelper(this.util.createVocabIris(attributes.itemtype, itemScope, false)),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var type = _step.value;

              // 4. Vocab identifier is the first valid item
              if (!itemScope.vocab) {
                // 5. Modify vocab based on registry
                itemScope.vocab = this.util.deriveVocab(type.value, this.vocabRegistry);
              } // Emit item type


              if (!itemScope.blockEmission) {
                this.emitTriple(itemScope.subject, this.util.dataFactory.namedNode("".concat(Util_1.Util.RDF, "type")), type);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } // Save language in item scope


        if ('lang' in attributes) {
          itemScope.language = attributes.lang;
        }

        if ('xml:lang' in attributes) {
          itemScope.language = attributes['xml:lang'];
        } // Handle itemrefs (only if we also had an itemscope)


        if ('itemscope' in attributes) {
          // If we have an itemref, store it in our domain buffer.
          if (!this.isEmittingReferences && 'itemref' in attributes) {
            var _iterator2 = _createForOfIteratorHelper(attributes.itemref.split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/)),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var reference = _step2.value;

                if (!(reference in this.pendingItemRefsDomain)) {
                  this.pendingItemRefsDomain[reference] = [];
                }

                this.pendingItemRefsDomain[reference].push(itemScope);
                this.tryToEmitReferences(reference, itemScope);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        }
      } // 6. Handle item properties


      if ('itemprop' in attributes) {
        this.handleItemProperties(attributes.itemprop, false, itemScope, name, attributes);
      } // Handle reverse item properties
      // https://w3c.github.io/microdata-rdf/#reverse-itemprop


      if ('itemprop-reverse' in attributes) {
        this.handleItemProperties(attributes['itemprop-reverse'], true, itemScope, name, attributes);
      }
    }
  }, {
    key: "onText",
    value: function onText(data) {
      // Store this event in all collecting item reference buffers
      if (!this.isEmittingReferences) {
        for (var _i3 = 0, _Object$values3 = Object.values(this.pendingItemRefsRangeCollecting); _i3 < _Object$values3.length; _i3++) {
          var buffer = _Object$values3[_i3];
          buffer.events.push({
            type: 'text',
            data: data
          });
        }
      } // Save the text inside all item scopes that need to collect text


      var _iterator3 = _createForOfIteratorHelper(this.textBufferStack),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var textBuffer = _step3.value;

          if (textBuffer) {
            textBuffer.push(data);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "onTagClose",
    value: function onTagClose() {
      // Store this event in all collecting item reference buffers
      if (!this.isEmittingReferences) {
        for (var _i4 = 0, _Object$entries = Object.entries(this.pendingItemRefsRangeCollecting); _i4 < _Object$entries.length; _i4++) {
          var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i4], 2),
              reference = _Object$entries$_i[0],
              buffer = _Object$entries$_i[1];

          buffer.counter--;
          buffer.events.push({
            type: 'close'
          }); // Once the counter becomes zero, the tag is fully buffered, so we finalize it.

          if (buffer.counter === 0) {
            this.pendingItemRefsRangeFinalized[reference] = buffer;
            delete this.pendingItemRefsRangeCollecting[reference]; // Try to emit this reference with buffered domain items

            this.tryToEmitReferences(reference);
          }
        }
      } // Emit all triples that were determined in the active tag


      var itemScope = this.getItemScope(true);

      if (itemScope) {
        var depth = this.getDepth();

        if (itemScope.predicates && depth in itemScope.predicates) {
          for (var _i5 = 0, _Object$entries2 = Object.entries(itemScope.predicates[depth]); _i5 < _Object$entries2.length; _i5++) {
            var _Object$entries2$_i = (0, _slicedToArray2["default"])(_Object$entries2[_i5], 2),
                predicateKey = _Object$entries2$_i[0],
                predicates = _Object$entries2$_i[1];

            // First check if we have a child item scope, otherwise get the text content
            // Safely cast textBufferStack, as it is always defined when itemScope.predicates is defined.
            var object = this.util.createLiteral(this.textBufferStack[depth].join(''), itemScope);
            this.emitPredicateTriples(itemScope, predicates, object, predicateKey === 'reverse');
            delete itemScope.predicates[depth][predicateKey];
          }
        }
      } // Remove the active tag from the stack


      this.itemScopeStack.pop();
      this.textBufferStack.pop();
    }
  }, {
    key: "onEnd",
    value: function onEnd() {// Nothing important should happen here.
    }
    /**
     * Initialize a new HtmlParser.
     * @param xmlMode If the parser should be setup in strict mode.
     */

  }, {
    key: "initializeParser",
    value: function initializeParser(xmlMode) {
      var _this2 = this;

      return new htmlparser2_1.Parser({
        onclosetag: function onclosetag() {
          try {
            _this2.onTagClose();

            if (_this2.htmlParseListener) {
              _this2.htmlParseListener.onTagClose();
            }
          } catch (error) {
            _this2.emit('error', error);
          }
        },
        onend: function onend() {
          try {
            _this2.onEnd();

            if (_this2.htmlParseListener) {
              _this2.htmlParseListener.onEnd();
            }
          } catch (error) {
            _this2.emit('error', error);
          }
        },
        onopentag: function onopentag(name, attributes) {
          try {
            _this2.onTagOpen(name, attributes);

            if (_this2.htmlParseListener) {
              _this2.htmlParseListener.onTagOpen(name, attributes);
            }
          } catch (error) {
            _this2.emit('error', error);
          }
        },
        ontext: function ontext(data) {
          try {
            _this2.onText(data);

            if (_this2.htmlParseListener) {
              _this2.htmlParseListener.onText(data);
            }
          } catch (error) {
            _this2.emit('error', error);
          }
        }
      }, {
        decodeEntities: true,
        recognizeSelfClosing: true,
        xmlMode: xmlMode
      });
    }
    /**
     * Handle the given item properties.
     * @param itempropValue The value of itemprop or itemprop-reverse.
     * @param reverse If the item properties are reversed (itemprop-reverse).
     * @param itemScope The current item scope.
     * @param tagName The current tag name.
     * @param tagAttributes The current tag attributes.
     */

  }, {
    key: "handleItemProperties",
    value: function handleItemProperties(itempropValue, reverse, itemScope, tagName, tagAttributes) {
      var parentItemScope = this.getItemScope(true);

      if (parentItemScope) {
        // Set predicates in the scope, and handle them on tag close.
        var depth = this.getDepth();
        var predicates = this.util.createVocabIris(itempropValue, parentItemScope, true);

        if (!parentItemScope.predicates) {
          parentItemScope.predicates = {};
        }

        if (!parentItemScope.predicates[depth]) {
          parentItemScope.predicates[depth] = {};
        }

        var predicatesKey = reverse ? 'reverse' : 'forward';
        parentItemScope.predicates[depth][predicatesKey] = predicates; // Append rdf:type predicate if vocabulary expansion applies

        var _iterator4 = _createForOfIteratorHelper(this.util.getVocabularyExpansionType(itempropValue, parentItemScope, this.vocabRegistry)),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var vocabularyExpansionType = _step4.value;
            predicates.push(vocabularyExpansionType);
          } // Check if a property handler that applies, forcefully use that as predicate value.
          // But DON'T call handlers in this prop is a direct (nested) itemscope.

        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        if (itemScope && 'itemscope' in tagAttributes) {
          this.emitPredicateTriples(parentItemScope, predicates, itemScope.subject, reverse); // Finalize the predicates, so text values do not apply to them.

          delete parentItemScope.predicates[depth][predicatesKey];
        } else {
          var _iterator5 = _createForOfIteratorHelper(MicrodataRdfParser.ITEM_PROPERTY_HANDLERS),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var handler = _step5.value;

              if (handler.canHandle(tagName, tagAttributes)) {
                var object = handler.getObject(tagAttributes, this.util, parentItemScope);
                this.emitPredicateTriples(parentItemScope, predicates, object, reverse); // Finalize the predicates, so text values do not apply to them.

                delete parentItemScope.predicates[depth][predicatesKey];
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        } // If no valid handler was found, indicate that we should collect text at this depth.


        if (parentItemScope.predicates[depth][predicatesKey]) {
          this.textBufferStack[depth] = [];
        }
      }
    }
    /**
     * Emit the given object for the given predicates.
     * @param itemScope The current item scope.
     * @param predicates An array of predicates.
     * @param object An object.
     * @param reverse If the triples should be reversed.
     */

  }, {
    key: "emitPredicateTriples",
    value: function emitPredicateTriples(itemScope, predicates, object, reverse) {
      if (!itemScope.blockEmission) {
        var _iterator6 = _createForOfIteratorHelper(predicates),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var predicate = _step6.value;

            if (reverse) {
              // Literals can not exist in subject position, so they must be ignored.
              if (object.termType !== 'Literal') {
                this.emitTriple(object, predicate, itemScope.subject);
              }
            } else {
              this.emitTriple(itemScope.subject, predicate, object);
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }
    }
    /**
     * Emit the given triple to the stream.
     * @param {Quad_Subject} subject A subject term.
     * @param {Quad_Predicate} predicate A predicate term.
     * @param {Quad_Object} object An object term.
     */

  }, {
    key: "emitTriple",
    value: function emitTriple(subject, predicate, object) {
      this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));
    }
    /**
     * Attempt to emit all pending itemrefs for the given reference.
     * @param reference An item reference id.
     * @param itemScopeDomain An optional item scope. If defined, only refs from this scope will be emitted.
     */

  }, {
    key: "tryToEmitReferences",
    value: function tryToEmitReferences(reference, itemScopeDomain) {
      var _this3 = this;

      var range = this.pendingItemRefsRangeFinalized[reference];

      if (range) {
        // Determine the item scope domains to emit
        var applicableItemScopes;

        if (itemScopeDomain) {
          applicableItemScopes = [itemScopeDomain]; // Remove the item from the pending array
          // Element is guaranteed to exist in buffer

          var itemScopeDomainIndex = this.pendingItemRefsDomain[reference].indexOf(itemScopeDomain);
          this.pendingItemRefsDomain[reference].splice(itemScopeDomainIndex, 1);
        } else {
          applicableItemScopes = this.pendingItemRefsDomain[reference]; // Remove all items from the pending array

          delete this.pendingItemRefsDomain[reference];
        }

        if (applicableItemScopes) {
          // Save the stack state
          var itemScopeStackOld = this.itemScopeStack;
          var textBufferStackOld = this.textBufferStack;
          this.isEmittingReferences = true; // For all applicable item scopes, emit the buffered events.

          var _iterator7 = _createForOfIteratorHelper(applicableItemScopes),
              _step7;

          try {
            var _loop = function _loop() {
              var itemScope = _step7.value;
              _this3.itemScopeStack = [itemScope];
              _this3.textBufferStack = [undefined];
              var pendingIds = range.ids.slice();

              _this3.emittingReferencesItemScopeIdGenerator = function () {
                return pendingIds.shift();
              };

              var _iterator8 = _createForOfIteratorHelper(range.events),
                  _step8;

              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  var event = _step8.value;

                  switch (event.type) {
                    case 'open':
                      _this3.onTagOpen(event.name, event.attributes);

                      break;

                    case 'text':
                      _this3.onText(event.data);

                      break;

                    case 'close':
                      _this3.onTagClose();

                      break;
                  }
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            };

            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              _loop();
            } // Restore the stack state

          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }

          this.emittingReferencesItemScopeIdGenerator = undefined;
          this.itemScopeStack = itemScopeStackOld;
          this.textBufferStack = textBufferStackOld;
          this.isEmittingReferences = false;
        }
      }
    }
  }]);
  return MicrodataRdfParser;
}(stream_1.Transform);

exports.MicrodataRdfParser = MicrodataRdfParser;
MicrodataRdfParser.ITEM_PROPERTY_HANDLERS = [new ItemPropertyHandlerContent_1.ItemPropertyHandlerContent(), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('a', 'href'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('area', 'href'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('audio', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('embed', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('iframe', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('img', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('link', 'href'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('object', 'data'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('source', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('track', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('video', 'src'), new ItemPropertyHandlerNumber_1.ItemPropertyHandlerNumber('data', 'value'), new ItemPropertyHandlerNumber_1.ItemPropertyHandlerNumber('meter', 'value'), new ItemPropertyHandlerTime_1.ItemPropertyHandlerTime()];

},{"./Util":119,"./propertyhandler/ItemPropertyHandlerContent":121,"./propertyhandler/ItemPropertyHandlerNumber":122,"./propertyhandler/ItemPropertyHandlerTime":123,"./propertyhandler/ItemPropertyHandlerUrl":124,"./vocab-registry-default.json":125,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"@babel/runtime/helpers/slicedToArray":24,"htmlparser2":87,"stream":191}],119:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Util = void 0;

var rdf_data_factory_1 = require("rdf-data-factory");

var relative_to_absolute_iri_1 = require("relative-to-absolute-iri");
/**
 * A collection of utility functions.
 */


var Util = /*#__PURE__*/function () {
  function Util(dataFactory, baseIRI) {
    (0, _classCallCheck2["default"])(this, Util);
    this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();
    this.baseIRI = baseIRI || '';
  }
  /**
   * Check if the given IRI is valid.
   * @param {string} iri A potential IRI.
   * @return {boolean} If the given IRI is valid.
   */


  (0, _createClass2["default"])(Util, [{
    key: "createVocabIris",

    /**
     * Create vocab terms for the given terms attribute.
     *
     * Relative IRIs will be based on the active vocab or baseIRI if `allowRelativeIris` is true.
     *
     * @param {string} terms An attribute value.
     * @param {IItemScope} itemScope The active item scope.
     * @param {boolean} allowRelativeIris If relative IRIs are allowed.
     * @return {Term[]} The IRI terms.
     */
    value: function createVocabIris(terms, itemScope, allowRelativeIris) {
      var _this = this;

      return terms.split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/).filter(function (term) {
        return !!term;
      }).map(function (property) {
        if (!Util.isValidIri(property)) {
          if (!allowRelativeIris) {
            return;
          }

          property = "".concat(itemScope.vocab || "".concat(_this.baseIRI, "#")).concat(property);
        }

        return _this.dataFactory.namedNode(property);
      }).filter(function (term) {
        return !!term;
      });
    }
    /**
     * Get the predicates for which the given itemprop value should cause vocabulary expansion.
     * @param terms An attribute value.
     * @param itemScope The active item scope.
     * @param vocabRegistry The active vocabulary registry.
     */

  }, {
    key: "getVocabularyExpansionType",
    value: function getVocabularyExpansionType(terms, itemScope, vocabRegistry) {
      var _this2 = this;

      // Check the presence of subPropertyOf or equivalentProperty
      var parts = terms.split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/);

      if (parts.includes('subPropertyOf') || parts.includes('equivalentProperty')) {
        return [this.dataFactory.namedNode("".concat(Util.RDF, "type"))];
      } // Check in the item scope's vocab


      if (itemScope.vocab && itemScope.vocab in vocabRegistry && vocabRegistry[itemScope.vocab].properties) {
        var predicates = [];

        for (var _i = 0, _Object$entries = Object.entries(vocabRegistry[itemScope.vocab].properties); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2),
              property = _Object$entries$_i[0],
              expansions = _Object$entries$_i[1];

          if (parts.includes(property)) {
            predicates = predicates.concat(Object.values(expansions).map(function (iri) {
              return _this2.dataFactory.namedNode(iri);
            }));
          }
        }

        return predicates;
      }

      return [];
    }
    /**
     * Create a named node for the given term, which can be relative to the document base.
     * @param {string} iri A term string.
     * @return {Term} An RDF term, or undefined if invalid.
     */

  }, {
    key: "createSubject",
    value: function createSubject(iri) {
      if (!Util.isValidIri(iri)) {
        try {
          iri = relative_to_absolute_iri_1.resolve(iri, this.baseIRI);
        } catch (_a) {
          return;
        }
      }

      return this.dataFactory.namedNode(iri);
    }
    /**
     * Create a new literal node.
     * @param {string} literal The literal value.
     * @param {IActiveTag} activeTag The current active tag.
     * @return {Literal} A new literal node.
     */

  }, {
    key: "createLiteral",
    value: function createLiteral(literal, activeTag) {
      return this.dataFactory.literal(literal, activeTag.language);
    }
    /**
     * Determine the vocab IRI from a given type IRI.
     * @link https://w3c.github.io/microdata-rdf/#property-uri-generation
     * @param typeIri A type IRI.
     * @param vocabRegistry The active vocabulary registry.
     */

  }, {
    key: "deriveVocab",
    value: function deriveVocab(typeIri, vocabRegistry) {
      var vocab; // First check if we find a prefix in the vocab registry

      for (var uriPrefix in vocabRegistry) {
        if (typeIri.startsWith(uriPrefix)) {
          vocab = uriPrefix; // Append fragment if prefix does not end with a slash

          if (!vocab.endsWith('/')) {
            vocab += '#';
          }

          break;
        }
      } // If no match was found, remove the last path segment from the URI


      if (!vocab) {
        var hashPos = typeIri.indexOf('#');

        if (hashPos > 0) {
          vocab = typeIri.slice(0, hashPos + 1);
        } else {
          vocab = relative_to_absolute_iri_1.resolve('.', typeIri);
        }
      }

      return vocab;
    }
  }], [{
    key: "isValidIri",
    value: function isValidIri(iri) {
      return Util.IRI_REGEX.test(iri);
    }
  }]);
  return Util;
}();

exports.Util = Util;
Util.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
Util.XSD = 'http://www.w3.org/2001/XMLSchema#';
Util.RDFA = 'http://www.w3.org/ns/rdfa#';
Util.IRI_REGEX = /^([A-Za-z][\+-\.0-9A-Za-z]*|_):(?:(?![ "<>\[-\]`\{-\}])[\s\S])*$/;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"rdf-data-factory":155,"relative-to-absolute-iri":188}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],121:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ItemPropertyHandlerContent = void 0;
/**
 * Handler for an item property with the 'content' attribute.
 */

var ItemPropertyHandlerContent = /*#__PURE__*/function () {
  function ItemPropertyHandlerContent() {
    (0, _classCallCheck2["default"])(this, ItemPropertyHandlerContent);
  }

  (0, _createClass2["default"])(ItemPropertyHandlerContent, [{
    key: "canHandle",
    value: function canHandle(tagName, attributes) {
      return 'content' in attributes;
    }
  }, {
    key: "getObject",
    value: function getObject(attributes, util, itemScope) {
      return util.createLiteral(attributes.content, itemScope);
    }
  }]);
  return ItemPropertyHandlerContent;
}();

exports.ItemPropertyHandlerContent = ItemPropertyHandlerContent;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],122:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ItemPropertyHandlerNumber = void 0;

var Util_1 = require("../Util");
/**
 * Handler for an item property with a number attribute.
 */


var ItemPropertyHandlerNumber = /*#__PURE__*/function () {
  function ItemPropertyHandlerNumber(tagName, attributeName) {
    (0, _classCallCheck2["default"])(this, ItemPropertyHandlerNumber);
    this.tagName = tagName;
    this.attributeName = attributeName;
  }

  (0, _createClass2["default"])(ItemPropertyHandlerNumber, [{
    key: "canHandle",
    value: function canHandle(tagName, attributes) {
      return this.tagName === tagName && this.attributeName in attributes;
    }
  }, {
    key: "getObject",
    value: function getObject(attributes, util, itemScope) {
      var value = attributes[this.attributeName];
      var datatype;

      if (!Number.isNaN(Number.parseInt(value, 10)) && !value.includes('.')) {
        datatype = "".concat(Util_1.Util.XSD, "integer");
      } else if (!Number.isNaN(Number.parseFloat(value))) {
        datatype = "".concat(Util_1.Util.XSD, "double");
      }

      return util.dataFactory.literal(value, datatype && util.dataFactory.namedNode(datatype));
    }
  }]);
  return ItemPropertyHandlerNumber;
}();

exports.ItemPropertyHandlerNumber = ItemPropertyHandlerNumber;

},{"../Util":119,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],123:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ItemPropertyHandlerTime = void 0;

var Util_1 = require("../Util");
/**
 * Handler for an item property for time tags.
 */


var ItemPropertyHandlerTime = /*#__PURE__*/function () {
  function ItemPropertyHandlerTime() {
    (0, _classCallCheck2["default"])(this, ItemPropertyHandlerTime);
  }

  (0, _createClass2["default"])(ItemPropertyHandlerTime, [{
    key: "canHandle",
    value: function canHandle(tagName, attributes) {
      return tagName === 'time' && 'datetime' in attributes;
    }
  }, {
    key: "getObject",
    value: function getObject(attributes, util, itemScope) {
      var value = attributes.datetime;
      var datatype;

      var _iterator = _createForOfIteratorHelper(ItemPropertyHandlerTime.TIME_REGEXES),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var entry = _step.value;

          if (entry.regex.exec(value)) {
            datatype = util.dataFactory.namedNode(Util_1.Util.XSD + entry.type);
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return util.dataFactory.literal(value, datatype);
    }
  }]);
  return ItemPropertyHandlerTime;
}();

exports.ItemPropertyHandlerTime = ItemPropertyHandlerTime;
ItemPropertyHandlerTime.TIME_REGEXES = [{
  regex: /^\x2D?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9])?S)?)?$/,
  type: 'duration'
}, {
  regex: /^[0-9]+\x2D[0-9][0-9]\x2D[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+\x2D][0-9][0-9]:[0-9][0-9]))$/,
  type: 'dateTime'
}, {
  regex: /^[0-9]+\x2D[0-9][0-9]\x2D[0-9][0-9]Z?$/,
  type: 'date'
}, {
  regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+\x2D][0-9][0-9]:[0-9][0-9]))$/,
  type: 'time'
}, {
  regex: /^[0-9]+\x2D[0-9][0-9]$/,
  type: 'gYearMonth'
}, {
  regex: /^[0-9]+$/,
  type: 'gYear'
}];

},{"../Util":119,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],124:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ItemPropertyHandlerUrl = void 0;

var relative_to_absolute_iri_1 = require("relative-to-absolute-iri");
/**
 * Handler for an item property with a URL attribute.
 */


var ItemPropertyHandlerUrl = /*#__PURE__*/function () {
  function ItemPropertyHandlerUrl(tagName, attributeName) {
    (0, _classCallCheck2["default"])(this, ItemPropertyHandlerUrl);
    this.tagName = tagName;
    this.attributeName = attributeName;
  }

  (0, _createClass2["default"])(ItemPropertyHandlerUrl, [{
    key: "canHandle",
    value: function canHandle(tagName, attributes) {
      return this.tagName === tagName && this.attributeName in attributes;
    }
  }, {
    key: "getObject",
    value: function getObject(attributes, util, itemScope) {
      return util.dataFactory.namedNode(relative_to_absolute_iri_1.resolve(attributes[this.attributeName], util.baseIRI));
    }
  }]);
  return ItemPropertyHandlerUrl;
}();

exports.ItemPropertyHandlerUrl = ItemPropertyHandlerUrl;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"relative-to-absolute-iri":188}],125:[function(require,module,exports){
module.exports={
  "http://schema.org/": {
    "properties": {
      "additionalType": {"subPropertyOf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"}
    }
  },
  "http://microformats.org/profile/hcard": {}
}

},{}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    XSD = 'http://www.w3.org/2001/XMLSchema#',
    SWAP = 'http://www.w3.org/2000/10/swap/';
var _default = {
  xsd: {
    decimal: XSD + 'decimal',
    "boolean": XSD + 'boolean',
    "double": XSD + 'double',
    integer: XSD + 'integer',
    string: XSD + 'string'
  },
  rdf: {
    type: RDF + 'type',
    nil: RDF + 'nil',
    first: RDF + 'first',
    rest: RDF + 'rest',
    langString: RDF + 'langString'
  },
  owl: {
    sameAs: 'http://www.w3.org/2002/07/owl#sameAs'
  },
  r: {
    forSome: SWAP + 'reify#forSome',
    forAll: SWAP + 'reify#forAll'
  },
  log: {
    implies: SWAP + 'log#implies'
  }
};
exports["default"] = _default;

},{}],127:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _assertThisInitialized2 = _interopRequireDefault2(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.termFromId = termFromId;
exports.termToId = termToId;
exports.escapeQuotes = escapeQuotes;
exports.unescapeQuotes = unescapeQuotes;
exports.Triple = exports.Quad = exports.DefaultGraph = exports.Variable = exports.BlankNode = exports.Literal = exports.NamedNode = exports.Term = exports["default"] = void 0;

var _IRIs = _interopRequireDefault(require("./IRIs"));

var _N3Util = require("./N3Util");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // N3.js implementations of the RDF/JS core data types
// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md


var _IRIs$default = _IRIs["default"],
    rdf = _IRIs$default.rdf,
    xsd = _IRIs$default.xsd;
var DEFAULTGRAPH;
var _blankNodeCounter = 0;
var escapedLiteral = /^"(.*".*)(?="[^"]*$)/;
var quadId = /^<<("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ?("(?:""|[^"])*"[^ ]*|[^ ]+)?>>$/; // ## DataFactory singleton

var DataFactory = {
  namedNode: namedNode,
  blankNode: blankNode,
  variable: variable,
  literal: literal,
  defaultGraph: defaultGraph,
  quad: quad,
  triple: quad
};
var _default = DataFactory; // ## Term constructor

exports["default"] = _default;

var Term = /*#__PURE__*/function () {
  function Term(id) {
    (0, _classCallCheck2["default"])(this, Term);
    this.id = id;
  } // ### The value of this term


  (0, _createClass2["default"])(Term, [{
    key: "equals",
    // ### Returns whether this object represents the same term as the other
    value: function equals(other) {
      // If both terms were created by this library,
      // equality can be computed through ids
      if (other instanceof Term) return this.id === other.id; // Otherwise, compare term type and value

      return !!other && this.termType === other.termType && this.value === other.value;
    } // ### Returns a plain object representation of this term

  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        termType: this.termType,
        value: this.value
      };
    }
  }, {
    key: "value",
    get: function get() {
      return this.id;
    }
  }]);
  return Term;
}(); // ## NamedNode constructor


exports.Term = Term;

var NamedNode = /*#__PURE__*/function (_Term) {
  (0, _inherits2["default"])(NamedNode, _Term);

  var _super = _createSuper(NamedNode);

  function NamedNode() {
    (0, _classCallCheck2["default"])(this, NamedNode);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(NamedNode, [{
    key: "termType",
    // ### The term type of this term
    get: function get() {
      return 'NamedNode';
    }
  }]);
  return NamedNode;
}(Term); // ## Literal constructor


exports.NamedNode = NamedNode;

var Literal = /*#__PURE__*/function (_Term2) {
  (0, _inherits2["default"])(Literal, _Term2);

  var _super2 = _createSuper(Literal);

  function Literal() {
    (0, _classCallCheck2["default"])(this, Literal);
    return _super2.apply(this, arguments);
  }

  (0, _createClass2["default"])(Literal, [{
    key: "equals",
    // ### Returns whether this object represents the same term as the other
    value: function equals(other) {
      // If both literals were created by this library,
      // equality can be computed through ids
      if (other instanceof Literal) return this.id === other.id; // Otherwise, compare term type, value, language, and datatype

      return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        termType: this.termType,
        value: this.value,
        language: this.language,
        datatype: {
          termType: 'NamedNode',
          value: this.datatypeString
        }
      };
    }
  }, {
    key: "termType",
    // ### The term type of this term
    get: function get() {
      return 'Literal';
    } // ### The text value of this literal

  }, {
    key: "value",
    get: function get() {
      return this.id.substring(1, this.id.lastIndexOf('"'));
    } // ### The language of this literal

  }, {
    key: "language",
    get: function get() {
      // Find the last quotation mark (e.g., '"abc"@en-us')
      var id = this.id,
          atPos = id.lastIndexOf('"') + 1; // If "@" it follows, return the remaining substring; empty otherwise

      return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';
    } // ### The datatype IRI of this literal

  }, {
    key: "datatype",
    get: function get() {
      return new NamedNode(this.datatypeString);
    } // ### The datatype string of this literal

  }, {
    key: "datatypeString",
    get: function get() {
      // Find the last quotation mark (e.g., '"abc"^^http://ex.org/types#t')
      var id = this.id,
          dtPos = id.lastIndexOf('"') + 1,
          ch; // If "^" it follows, return the remaining substring

      return dtPos < id.length && (ch = id[dtPos]) === '^' ? id.substr(dtPos + 2) : // If "@" follows, return rdf:langString; xsd:string otherwise
      ch !== '@' ? xsd.string : rdf.langString;
    }
  }]);
  return Literal;
}(Term); // ## BlankNode constructor


exports.Literal = Literal;

var BlankNode = /*#__PURE__*/function (_Term3) {
  (0, _inherits2["default"])(BlankNode, _Term3);

  var _super3 = _createSuper(BlankNode);

  function BlankNode(name) {
    (0, _classCallCheck2["default"])(this, BlankNode);
    return _super3.call(this, '_:' + name);
  } // ### The term type of this term


  (0, _createClass2["default"])(BlankNode, [{
    key: "termType",
    get: function get() {
      return 'BlankNode';
    } // ### The name of this blank node

  }, {
    key: "value",
    get: function get() {
      return this.id.substr(2);
    }
  }]);
  return BlankNode;
}(Term);

exports.BlankNode = BlankNode;

var Variable = /*#__PURE__*/function (_Term4) {
  (0, _inherits2["default"])(Variable, _Term4);

  var _super4 = _createSuper(Variable);

  function Variable(name) {
    (0, _classCallCheck2["default"])(this, Variable);
    return _super4.call(this, '?' + name);
  } // ### The term type of this term


  (0, _createClass2["default"])(Variable, [{
    key: "termType",
    get: function get() {
      return 'Variable';
    } // ### The name of this variable

  }, {
    key: "value",
    get: function get() {
      return this.id.substr(1);
    }
  }]);
  return Variable;
}(Term); // ## DefaultGraph constructor


exports.Variable = Variable;

var DefaultGraph = /*#__PURE__*/function (_Term5) {
  (0, _inherits2["default"])(DefaultGraph, _Term5);

  var _super5 = _createSuper(DefaultGraph);

  function DefaultGraph() {
    var _this;

    (0, _classCallCheck2["default"])(this, DefaultGraph);
    _this = _super5.call(this, '');
    return (0, _possibleConstructorReturn2["default"])(_this, DEFAULTGRAPH || (0, _assertThisInitialized2["default"])(_this));
  } // ### The term type of this term


  (0, _createClass2["default"])(DefaultGraph, [{
    key: "equals",
    // ### Returns whether this object represents the same term as the other
    value: function equals(other) {
      // If both terms were created by this library,
      // equality can be computed through strict equality;
      // otherwise, compare term types.
      return this === other || !!other && this.termType === other.termType;
    }
  }, {
    key: "termType",
    get: function get() {
      return 'DefaultGraph';
    }
  }]);
  return DefaultGraph;
}(Term); // ## DefaultGraph singleton


exports.DefaultGraph = DefaultGraph;
DEFAULTGRAPH = new DefaultGraph(); // ### Constructs a term from the given internal string ID

function termFromId(id, factory) {
  factory = factory || DataFactory; // Falsy value or empty string indicate the default graph

  if (!id) return factory.defaultGraph(); // Identify the term type based on the first character

  switch (id[0]) {
    case '?':
      return factory.variable(id.substr(1));

    case '_':
      return factory.blankNode(id.substr(2));

    case '"':
      // Shortcut for internal literals
      if (factory === DataFactory) return new Literal(id); // Literal without datatype or language

      if (id[id.length - 1] === '"') return factory.literal(id.substr(1, id.length - 2)); // Literal with datatype or language

      var endPos = id.lastIndexOf('"', id.length - 1);
      return factory.literal(id.substr(1, endPos - 1), id[endPos + 1] === '@' ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3)));

    case '<':
      var components = quadId.exec(id);
      return factory.quad(termFromId(unescapeQuotes(components[1]), factory), termFromId(unescapeQuotes(components[2]), factory), termFromId(unescapeQuotes(components[3]), factory), components[4] && termFromId(unescapeQuotes(components[4]), factory));

    default:
      return factory.namedNode(id);
  }
} // ### Constructs an internal string ID from the given term or ID string


function termToId(term) {
  if (typeof term === 'string') return term;
  if (term instanceof Term && term.termType !== 'Quad') return term.id;
  if (!term) return DEFAULTGRAPH.id; // Term instantiated with another library

  switch (term.termType) {
    case 'NamedNode':
      return term.value;

    case 'BlankNode':
      return '_:' + term.value;

    case 'Variable':
      return '?' + term.value;

    case 'DefaultGraph':
      return '';

    case 'Literal':
      return '"' + term.value + '"' + (term.language ? '@' + term.language : term.datatype && term.datatype.value !== xsd.string ? '^^' + term.datatype.value : '');

    case 'Quad':
      // To identify RDF* quad components, we escape quotes by doubling them.
      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.
      return "<<".concat(escapeQuotes(termToId(term.subject)), " ").concat(escapeQuotes(termToId(term.predicate)), " ").concat(escapeQuotes(termToId(term.object))).concat((0, _N3Util.isDefaultGraph)(term.graph) ? '' : " ".concat(termToId(term.graph)), ">>");

    default:
      throw new Error('Unexpected termType: ' + term.termType);
  }
} // ## Quad constructor


var Quad = /*#__PURE__*/function (_Term6) {
  (0, _inherits2["default"])(Quad, _Term6);

  var _super6 = _createSuper(Quad);

  function Quad(subject, predicate, object, graph) {
    var _this2;

    (0, _classCallCheck2["default"])(this, Quad);
    _this2 = _super6.call(this, '');
    _this2.subject = subject;
    _this2.predicate = predicate;
    _this2.object = object;
    _this2.graph = graph || DEFAULTGRAPH;
    return _this2;
  } // ### The term type of this term


  (0, _createClass2["default"])(Quad, [{
    key: "toJSON",
    // ### Returns a plain object representation of this quad
    value: function toJSON() {
      return {
        termType: this.termType,
        subject: this.subject.toJSON(),
        predicate: this.predicate.toJSON(),
        object: this.object.toJSON(),
        graph: this.graph.toJSON()
      };
    } // ### Returns whether this object represents the same quad as the other

  }, {
    key: "equals",
    value: function equals(other) {
      return !!other && this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph);
    }
  }, {
    key: "termType",
    get: function get() {
      return 'Quad';
    }
  }]);
  return Quad;
}(Term);

exports.Triple = exports.Quad = Quad; // ### Escapes the quotes within the given literal

function escapeQuotes(id) {
  return id.replace(escapedLiteral, function (_, quoted) {
    return "\"".concat(quoted.replace(/"/g, '""'));
  });
} // ### Unescapes the quotes within the given literal


function unescapeQuotes(id) {
  return id.replace(escapedLiteral, function (_, quoted) {
    return "\"".concat(quoted.replace(/""/g, '"'));
  });
} // ### Creates an IRI


function namedNode(iri) {
  return new NamedNode(iri);
} // ### Creates a blank node


function blankNode(name) {
  return new BlankNode(name || "n3-".concat(_blankNodeCounter++));
} // ### Creates a literal


function literal(value, languageOrDataType) {
  // Create a language-tagged string
  if (typeof languageOrDataType === 'string') return new Literal('"' + value + '"@' + languageOrDataType.toLowerCase()); // Automatically determine datatype for booleans and numbers

  var datatype = languageOrDataType ? languageOrDataType.value : '';

  if (datatype === '') {
    // Convert a boolean
    if (typeof value === 'boolean') datatype = xsd["boolean"]; // Convert an integer or double
    else if (typeof value === 'number') {
        if (Number.isFinite(value)) datatype = Number.isInteger(value) ? xsd.integer : xsd["double"];else {
          datatype = xsd["double"];
          if (!Number.isNaN(value)) value = value > 0 ? 'INF' : '-INF';
        }
      }
  } // Create a datatyped literal


  return datatype === '' || datatype === xsd.string ? new Literal('"' + value + '"') : new Literal('"' + value + '"^^' + datatype);
} // ### Creates a variable


function variable(name) {
  return new Variable(name);
} // ### Returns the default graph


function defaultGraph() {
  return DEFAULTGRAPH;
} // ### Creates a quad


function quad(subject, predicate, object, graph) {
  return new Quad(subject, predicate, object, graph);
}

},{"./IRIs":126,"./N3Util":133,"@babel/runtime/helpers/assertThisInitialized":5,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22}],128:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _IRIs = _interopRequireDefault(require("./IRIs"));

var _queueMicrotask = _interopRequireDefault(require("queue-microtask"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3Lexer** tokenizes N3 documents.


var xsd = _IRIs["default"].xsd; // Regular expression and replacement string to escape N3 strings

var escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g;
var escapeReplacements = {
  '\\': '\\',
  "'": "'",
  '"': '"',
  'n': '\n',
  'r': '\r',
  't': '\t',
  'f': '\f',
  'b': '\b',
  '_': '_',
  '~': '~',
  '.': '.',
  '-': '-',
  '!': '!',
  '$': '$',
  '&': '&',
  '(': '(',
  ')': ')',
  '*': '*',
  '+': '+',
  ',': ',',
  ';': ';',
  '=': '=',
  '/': '/',
  '?': '?',
  '#': '#',
  '@': '@',
  '%': '%'
};
var illegalIriChars = /[\x00-\x20<>\\"\{\}\|\^\`]/;
var lineModeRegExps = {
  _iri: true,
  _unescapedIri: true,
  _simpleQuotedString: true,
  _langcode: true,
  _blank: true,
  _newline: true,
  _comment: true,
  _whitespace: true,
  _endOfFile: true
};
var invalidRegExp = /$0^/; // ## Constructor

var N3Lexer = /*#__PURE__*/function () {
  function N3Lexer(options) {
    (0, _classCallCheck2["default"])(this, N3Lexer);
    // ## Regular expressions
    // It's slightly faster to have these as properties than as in-scope variables
    this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/; // IRI with escape sequences; needs sanity check after unescaping

    this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/; // IRI without escape sequences; no unescaping

    this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/; // string without escape sequences

    this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/;
    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i;
    this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/;
    this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/;
    this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/;
    this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/;
    this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/;
    this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/;
    this._keyword = /^@[a-z]+(?=[\s#<:])/i;
    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i;
    this._shortPredicates = /^a(?=[\s()\[\]\{\}"'<>])/;
    this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/;
    this._comment = /#([^\n\r]*)/;
    this._whitespace = /^[ \t]+/;
    this._endOfFile = /^(?:#[^\n\r]*)?$/;
    options = options || {}; // In line mode (N-Triples or N-Quads), only simple features may be parsed

    if (this._lineMode = !!options.lineMode) {
      this._n3Mode = false; // Don't tokenize special literals

      for (var key in this) {
        if (!(key in lineModeRegExps) && this[key] instanceof RegExp) this[key] = invalidRegExp;
      }
    } // When not in line mode, enable N3 functionality by default
    else {
        this._n3Mode = options.n3 !== false;
      } // Don't output comment tokens by default


    this._comments = !!options.comments; // Cache the last tested closing position of long literals

    this._literalClosingPos = 0;
  } // ## Private methods
  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback


  (0, _createClass2["default"])(N3Lexer, [{
    key: "_tokenizeToEnd",
    value: function _tokenizeToEnd(callback, inputFinished) {
      // Continue parsing as far as possible; the loop will return eventually
      var input = this._input,
          outputComments = this._comments;

      while (true) {
        // Count and skip whitespace lines
        var whiteSpaceMatch, comment;

        while (whiteSpaceMatch = this._newline.exec(input)) {
          // Try to find a comment
          if (outputComments && (comment = this._comment.exec(whiteSpaceMatch[0]))) callback(null, {
            line: this._line,
            type: 'comment',
            value: comment[1],
            prefix: ''
          }); // Advance the input

          input = input.substr(whiteSpaceMatch[0].length, input.length);
          this._line++;
        } // Skip whitespace on current line


        if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input))) input = input.substr(whiteSpaceMatch[0].length, input.length); // Stop for now if we're at the end

        if (this._endOfFile.test(input)) {
          // If the input is finished, emit EOF
          if (inputFinished) {
            // Try to find a final comment
            if (outputComments && (comment = this._comment.exec(input))) callback(null, {
              line: this._line,
              type: 'comment',
              value: comment[1],
              prefix: ''
            });
            callback(input = null, {
              line: this._line,
              type: 'eof',
              value: '',
              prefix: ''
            });
          }

          return this._input = input;
        } // Look for specific token types based on the first character


        var line = this._line,
            type = '',
            value = '',
            prefix = '',
            firstChar = input[0],
            match = null,
            matchLength = 0,
            inconclusive = false;

        switch (firstChar) {
          case '^':
            // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed
            if (input.length < 3) break; // Try to match a type
            else if (input[1] === '^') {
                this._previousMarker = '^^'; // Move to type IRI or prefixed name

                input = input.substr(2);

                if (input[0] !== '<') {
                  inconclusive = true;
                  break;
                }
              } // If no type, it must be a path expression
              else {
                  if (this._n3Mode) {
                    matchLength = 1;
                    type = '^';
                  }

                  break;
                }
          // Fall through in case the type is an IRI

          case '<':
            // Try to find a full IRI without escape sequences
            if (match = this._unescapedIri.exec(input)) type = 'IRI', value = match[1]; // Try to find a full IRI with escape sequences
            else if (match = this._iri.exec(input)) {
                value = this._unescape(match[1]);
                if (value === null || illegalIriChars.test(value)) return reportSyntaxError(this);
                type = 'IRI';
              } // Try to find a nested triple
              else if (input.length > 1 && input[1] === '<') type = '<<', matchLength = 2; // Try to find a backwards implication arrow
                else if (this._n3Mode && input.length > 1 && input[1] === '=') type = 'inverse', matchLength = 2, value = '>';
            break;

          case '>':
            if (input.length > 1 && input[1] === '>') type = '>>', matchLength = 2;
            break;

          case '_':
            // Try to find a blank node. Since it can contain (but not end with) a dot,
            // we always need a non-dot character before deciding it is a blank node.
            // Therefore, try inserting a space if we're at the end of the input.
            if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(input + ' '))) type = 'blank', prefix = '_', value = match[1];
            break;

          case '"':
            // Try to find a literal without escape sequences
            if (match = this._simpleQuotedString.exec(input)) value = match[1]; // Try to find a literal wrapped in three pairs of quotes
            else {
                var _this$_parseLiteral = this._parseLiteral(input);

                value = _this$_parseLiteral.value;
                matchLength = _this$_parseLiteral.matchLength;
                if (value === null) return reportSyntaxError(this);
              }

            if (match !== null || matchLength !== 0) {
              type = 'literal';
              this._literalClosingPos = 0;
            }

            break;

          case "'":
            if (!this._lineMode) {
              // Try to find a literal without escape sequences
              if (match = this._simpleApostropheString.exec(input)) value = match[1]; // Try to find a literal wrapped in three pairs of quotes
              else {
                  var _this$_parseLiteral2 = this._parseLiteral(input);

                  value = _this$_parseLiteral2.value;
                  matchLength = _this$_parseLiteral2.matchLength;
                  if (value === null) return reportSyntaxError(this);
                }

              if (match !== null || matchLength !== 0) {
                type = 'literal';
                this._literalClosingPos = 0;
              }
            }

            break;

          case '?':
            // Try to find a variable
            if (this._n3Mode && (match = this._variable.exec(input))) type = 'var', value = match[0];
            break;

          case '@':
            // Try to find a language code
            if (this._previousMarker === 'literal' && (match = this._langcode.exec(input))) type = 'langcode', value = match[1]; // Try to find a keyword
            else if (match = this._keyword.exec(input)) type = match[0];
            break;

          case '.':
            // Try to find a dot as punctuation
            if (input.length === 1 ? inputFinished : input[1] < '0' || input[1] > '9') {
              type = '.';
              matchLength = 1;
              break;
            }

          // Fall through to numerical case (could be a decimal dot)

          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
          case '+':
          case '-':
            // Try to find a number. Since it can contain (but not end with) a dot,
            // we always need a non-dot character before deciding it is a number.
            // Therefore, try inserting a space if we're at the end of the input.
            if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(input + ' '))) {
              type = 'literal', value = match[0];
              prefix = typeof match[1] === 'string' ? xsd["double"] : typeof match[2] === 'string' ? xsd.decimal : xsd.integer;
            }

            break;

          case 'B':
          case 'b':
          case 'p':
          case 'P':
          case 'G':
          case 'g':
            // Try to find a SPARQL-style keyword
            if (match = this._sparqlKeyword.exec(input)) type = match[0].toUpperCase();else inconclusive = true;
            break;

          case 'f':
          case 't':
            // Try to match a boolean
            if (match = this._boolean.exec(input)) type = 'literal', value = match[0], prefix = xsd["boolean"];else inconclusive = true;
            break;

          case 'a':
            // Try to find an abbreviated predicate
            if (match = this._shortPredicates.exec(input)) type = 'abbreviation', value = 'a';else inconclusive = true;
            break;

          case '=':
            // Try to find an implication arrow or equals sign
            if (this._n3Mode && input.length > 1) {
              type = 'abbreviation';
              if (input[1] !== '>') matchLength = 1, value = '=';else matchLength = 2, value = '>';
            }

            break;

          case '!':
            if (!this._n3Mode) break;

          case ',':
          case ';':
          case '[':
          case ']':
          case '(':
          case ')':
          case '{':
          case '}':
            if (!this._lineMode) {
              matchLength = 1;
              type = firstChar;
            }

            break;

          default:
            inconclusive = true;
        } // Some first characters do not allow an immediate decision, so inspect more


        if (inconclusive) {
          // Try to find a prefix
          if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') && (match = this._prefix.exec(input))) type = 'prefix', value = match[1] || ''; // Try to find a prefixed name. Since it can contain (but not end with) a dot,
          // we always need a non-dot character before deciding it is a prefixed name.
          // Therefore, try inserting a space if we're at the end of the input.
          else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(input + ' '))) type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);
        } // A type token is special: it can only be emitted after an IRI or prefixed name is read


        if (this._previousMarker === '^^') {
          switch (type) {
            case 'prefixed':
              type = 'type';
              break;

            case 'IRI':
              type = 'typeIRI';
              break;

            default:
              type = '';
          }
        } // What if nothing of the above was found?


        if (!type) {
          // We could be in streaming mode, and then we just wait for more input to arrive.
          // Otherwise, a syntax error has occurred in the input.
          // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).
          if (inputFinished || !/^'''|^"""/.test(input) && /\n|\r/.test(input)) return reportSyntaxError(this);else return this._input = input;
        } // Emit the parsed token


        var token = {
          line: line,
          type: type,
          value: value,
          prefix: prefix
        };
        callback(null, token);
        this.previousToken = token;
        this._previousMarker = type; // Advance to next part to tokenize

        input = input.substr(matchLength || match[0].length, input.length);
      } // Signals the syntax error through the callback


      function reportSyntaxError(self) {
        callback(self._syntaxError(/^\S*/.exec(input)[0]));
      }
    } // ### `_unescape` replaces N3 escape codes by their corresponding characters

  }, {
    key: "_unescape",
    value: function _unescape(item) {
      var invalid = false;
      var replaced = item.replace(escapeSequence, function (sequence, unicode4, unicode8, escapedChar) {
        // 4-digit unicode character
        if (typeof unicode4 === 'string') return String.fromCharCode(Number.parseInt(unicode4, 16)); // 8-digit unicode character

        if (typeof unicode8 === 'string') {
          var charCode = Number.parseInt(unicode8, 16);
          return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));
        } // fixed escape sequence


        if (escapedChar in escapeReplacements) return escapeReplacements[escapedChar]; // invalid escape sequence

        invalid = true;
        return '';
      });
      return invalid ? null : replaced;
    } // ### `_parseLiteral` parses a literal into an unescaped value

  }, {
    key: "_parseLiteral",
    value: function _parseLiteral(input) {
      // Ensure we have enough lookahead to identify triple-quoted strings
      if (input.length >= 3) {
        // Identify the opening quote(s)
        var opening = input.match(/^(?:"""|"|'''|'|)/)[0];
        var openingLength = opening.length; // Find the next candidate closing quotes

        var closingPos = Math.max(this._literalClosingPos, openingLength);

        while ((closingPos = input.indexOf(opening, closingPos)) > 0) {
          // Count backslashes right before the closing quotes
          var backslashCount = 0;

          while (input[closingPos - backslashCount - 1] === '\\') {
            backslashCount++;
          } // An even number of backslashes (in particular 0)
          // means these are actual, non-escaped closing quotes


          if (backslashCount % 2 === 0) {
            // Extract and unescape the value
            var raw = input.substring(openingLength, closingPos);
            var lines = raw.split(/\r\n|\r|\n/).length - 1;
            var matchLength = closingPos + openingLength; // Only triple-quoted strings can be multi-line

            if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode) break;
            this._line += lines;
            return {
              value: this._unescape(raw),
              matchLength: matchLength
            };
          }

          closingPos++;
        }

        this._literalClosingPos = input.length - openingLength + 1;
      }

      return {
        value: '',
        matchLength: 0
      };
    } // ### `_syntaxError` creates a syntax error for the given issue

  }, {
    key: "_syntaxError",
    value: function _syntaxError(issue) {
      this._input = null;
      var err = new Error('Unexpected "' + issue + '" on line ' + this._line + '.');
      err.context = {
        token: undefined,
        line: this._line,
        previousToken: this.previousToken
      };
      return err;
    } // ## Public methods
    // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
    // The input can be a string or a stream.

  }, {
    key: "tokenize",
    value: function tokenize(input, callback) {
      var self = this;
      this._line = 1; // If the input is a string, continuously emit tokens through the callback until the end

      if (typeof input === 'string') {
        this._input = input; // If a callback was passed, asynchronously call it

        if (typeof callback === 'function') (0, _queueMicrotask["default"])(function () {
          return self._tokenizeToEnd(callback, true);
        }); // If no callback was passed, tokenize synchronously and return
        else {
            var tokens = [],
                error;

            this._tokenizeToEnd(function (e, t) {
              e ? error = e : tokens.push(t);
            }, true);

            if (error) throw error;
            return tokens;
          }
      } // Otherwise, the input must be a stream
      else {
          this._input = '';
          this._pendingBuffer = null;
          if (typeof input.setEncoding === 'function') input.setEncoding('utf8'); // Adds the data chunk to the buffer and parses as far as possible

          input.on('data', function (data) {
            if (self._input !== null && data.length !== 0) {
              // Prepend any previous pending writes
              if (self._pendingBuffer) {
                data = Buffer.concat([self._pendingBuffer, data]);
                self._pendingBuffer = null;
              } // Hold if the buffer ends in an incomplete unicode sequence


              if (data[data.length - 1] & 0x80) {
                self._pendingBuffer = data;
              } // Otherwise, tokenize as far as possible
              else {
                  self._input += data;

                  self._tokenizeToEnd(callback, false);
                }
            }
          }); // Parses until the end

          input.on('end', function () {
            if (self._input !== null) self._tokenizeToEnd(callback, true);
          });
          input.on('error', callback);
        }
    }
  }]);
  return N3Lexer;
}();

exports["default"] = N3Lexer;

}).call(this)}).call(this,require("buffer").Buffer)

},{"./IRIs":126,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"buffer":60,"queue-microtask":143}],129:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _N3Lexer = _interopRequireDefault(require("./N3Lexer"));

var _N3DataFactory = _interopRequireDefault(require("./N3DataFactory"));

var _IRIs = _interopRequireDefault(require("./IRIs"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3Parser** parses N3 documents.


var blankNodePrefix = 0; // ## Constructor

var N3Parser = /*#__PURE__*/function () {
  function N3Parser(options) {
    (0, _classCallCheck2["default"])(this, N3Parser);
    this._contextStack = [];
    this._graph = null; // Set the document IRI

    options = options || {};

    this._setBase(options.baseIRI);

    options.factory && initDataFactory(this, options.factory); // Set supported features depending on the format

    var format = typeof options.format === 'string' ? options.format.match(/\w*$/)[0].toLowerCase() : '',
        isTurtle = /turtle/.test(format),
        isTriG = /trig/.test(format),
        isNTriples = /triple/.test(format),
        isNQuads = /quad/.test(format),
        isN3 = this._n3Mode = /n3/.test(format),
        isLineMode = isNTriples || isNQuads;
    if (!(this._supportsNamedGraphs = !(isTurtle || isN3))) this._readPredicateOrNamedGraph = this._readPredicate; // Support triples in other graphs

    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3); // Support nesting of triples

    this._supportsRDFStar = format === '' || /star|\*$/.test(format); // Disable relative IRIs in N-Triples or N-Quads mode

    if (isLineMode) this._resolveRelativeIRI = function (iri) {
      return null;
    };
    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' : options.blankNodePrefix.replace(/^(?!_:)/, '_:');
    this._lexer = options.lexer || new _N3Lexer["default"]({
      lineMode: isLineMode,
      n3: isN3
    }); // Disable explicit quantifiers by default

    this._explicitQuantifiers = !!options.explicitQuantifiers;
  } // ## Static class methods
  // ### `_resetBlankNodePrefix` restarts blank node prefix identification


  (0, _createClass2["default"])(N3Parser, [{
    key: "_setBase",
    // ## Private methods
    // ### `_setBase` sets the base IRI to resolve relative IRIs
    value: function _setBase(baseIRI) {
      if (!baseIRI) {
        this._base = '';
        this._basePath = '';
      } else {
        // Remove fragment if present
        var fragmentPos = baseIRI.indexOf('#');
        if (fragmentPos >= 0) baseIRI = baseIRI.substr(0, fragmentPos); // Set base IRI and its components

        this._base = baseIRI;
        this._basePath = baseIRI.indexOf('/') < 0 ? baseIRI : baseIRI.replace(/[^\/?]*(?:\?.*)?$/, '');
        baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i);
        this._baseRoot = baseIRI[0];
        this._baseScheme = baseIRI[1];
      }
    } // ### `_saveContext` stores the current parsing context
    // when entering a new scope (list, blank node, formula)

  }, {
    key: "_saveContext",
    value: function _saveContext(type, graph, subject, predicate, object) {
      var n3Mode = this._n3Mode;

      this._contextStack.push({
        subject: subject,
        predicate: predicate,
        object: object,
        graph: graph,
        type: type,
        inverse: n3Mode ? this._inversePredicate : false,
        blankPrefix: n3Mode ? this._prefixes._ : '',
        quantified: n3Mode ? this._quantified : null
      }); // The settings below only apply to N3 streams


      if (n3Mode) {
        // Every new scope resets the predicate direction
        this._inversePredicate = false; // In N3, blank nodes are scoped to a formula
        // (using a dot as separator, as a blank node label cannot start with it)

        this._prefixes._ = this._graph ? this._graph.id.substr(2) + '.' : '.'; // Quantifiers are scoped to a formula

        this._quantified = Object.create(this._quantified);
      }
    } // ### `_restoreContext` restores the parent context
    // when leaving a scope (list, blank node, formula)

  }, {
    key: "_restoreContext",
    value: function _restoreContext() {
      var context = this._contextStack.pop(),
          n3Mode = this._n3Mode;

      this._subject = context.subject;
      this._predicate = context.predicate;
      this._object = context.object;
      this._graph = context.graph; // The settings below only apply to N3 streams

      if (n3Mode) {
        this._inversePredicate = context.inverse;
        this._prefixes._ = context.blankPrefix;
        this._quantified = context.quantified;
      }
    } // ### `_readInTopContext` reads a token when in the top context

  }, {
    key: "_readInTopContext",
    value: function _readInTopContext(token) {
      switch (token.type) {
        // If an EOF token arrives in the top context, signal that we're done
        case 'eof':
          if (this._graph !== null) return this._error('Unclosed graph', token);
          delete this._prefixes._;
          return this._callback(null, null, this._prefixes);
        // It could be a prefix declaration

        case 'PREFIX':
          this._sparqlStyle = true;

        case '@prefix':
          return this._readPrefix;
        // It could be a base declaration

        case 'BASE':
          this._sparqlStyle = true;

        case '@base':
          return this._readBaseIRI;
        // It could be a graph

        case '{':
          if (this._supportsNamedGraphs) {
            this._graph = '';
            this._subject = null;
            return this._readSubject;
          }

        case 'GRAPH':
          if (this._supportsNamedGraphs) return this._readNamedGraphLabel;
        // Otherwise, the next token must be a subject

        default:
          return this._readSubject(token);
      }
    } // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable

  }, {
    key: "_readEntity",
    value: function _readEntity(token, quantifier) {
      var value;

      switch (token.type) {
        // Read a relative or absolute IRI
        case 'IRI':
        case 'typeIRI':
          var iri = this._resolveIRI(token.value);

          if (iri === null) return this._error('Invalid IRI', token);
          value = this._namedNode(iri);
          break;
        // Read a prefixed name

        case 'type':
        case 'prefixed':
          var prefix = this._prefixes[token.prefix];
          if (prefix === undefined) return this._error('Undefined prefix "' + token.prefix + ':"', token);
          value = this._namedNode(prefix + token.value);
          break;
        // Read a blank node

        case 'blank':
          value = this._blankNode(this._prefixes[token.prefix] + token.value);
          break;
        // Read a variable

        case 'var':
          value = this._variable(token.value.substr(1));
          break;
        // Everything else is not an entity

        default:
          return this._error('Expected entity but got ' + token.type, token);
      } // In N3 mode, replace the entity if it is quantified


      if (!quantifier && this._n3Mode && value.id in this._quantified) value = this._quantified[value.id];
      return value;
    } // ### `_readSubject` reads a quad's subject

  }, {
    key: "_readSubject",
    value: function _readSubject(token) {
      this._predicate = null;

      switch (token.type) {
        case '[':
          // Start a new quad with a new blank node as subject
          this._saveContext('blank', this._graph, this._subject = this._blankNode(), null, null);

          return this._readBlankNodeHead;

        case '(':
          // Start a new list
          this._saveContext('list', this._graph, this.RDF_NIL, null, null);

          this._subject = null;
          return this._readListItem;

        case '{':
          // Start a new formula
          if (!this._n3Mode) return this._error('Unexpected graph', token);

          this._saveContext('formula', this._graph, this._graph = this._blankNode(), null, null);

          return this._readSubject;

        case '}':
          // No subject; the graph in which we are reading is closed instead
          return this._readPunctuation(token);

        case '@forSome':
          if (!this._n3Mode) return this._error('Unexpected "@forSome"', token);
          this._subject = null;
          this._predicate = this.N3_FORSOME;
          this._quantifier = this._blankNode;
          return this._readQuantifierList;

        case '@forAll':
          if (!this._n3Mode) return this._error('Unexpected "@forAll"', token);
          this._subject = null;
          this._predicate = this.N3_FORALL;
          this._quantifier = this._variable;
          return this._readQuantifierList;

        case 'literal':
          if (!this._n3Mode) return this._error('Unexpected literal', token);

          if (token.prefix.length === 0) {
            this._literalValue = token.value;
            return this._completeSubjectLiteral;
          } else this._subject = this._literal(token.value, this._namedNode(token.prefix));

          break;

        case '<<':
          if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);

          this._saveContext('<<', this._graph, null, null, null);

          this._graph = null;
          return this._readSubject;

        default:
          // Read the subject entity
          if ((this._subject = this._readEntity(token)) === undefined) return; // In N3 mode, the subject might be a path

          if (this._n3Mode) return this._getPathReader(this._readPredicateOrNamedGraph);
      } // The next token must be a predicate,
      // or, if the subject was actually a graph IRI, a named graph


      return this._readPredicateOrNamedGraph;
    } // ### `_readPredicate` reads a quad's predicate

  }, {
    key: "_readPredicate",
    value: function _readPredicate(token) {
      var type = token.type;

      switch (type) {
        case 'inverse':
          this._inversePredicate = true;

        case 'abbreviation':
          this._predicate = this.ABBREVIATIONS[token.value];
          break;

        case '.':
        case ']':
        case '}':
          // Expected predicate didn't come, must have been trailing semicolon
          if (this._predicate === null) return this._error('Unexpected ' + type, token);
          this._subject = null;
          return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);

        case ';':
          // Additional semicolons can be safely ignored
          return this._predicate !== null ? this._readPredicate : this._error('Expected predicate but got ;', token);

        case 'blank':
          if (!this._n3Mode) return this._error('Disallowed blank node as predicate', token);

        default:
          if ((this._predicate = this._readEntity(token)) === undefined) return;
      } // The next token must be an object


      return this._readObject;
    } // ### `_readObject` reads a quad's object

  }, {
    key: "_readObject",
    value: function _readObject(token) {
      switch (token.type) {
        case 'literal':
          // Regular literal, can still get a datatype or language
          if (token.prefix.length === 0) {
            this._literalValue = token.value;
            return this._readDataTypeOrLang;
          } // Pre-datatyped string literal (prefix stores the datatype)
          else this._object = this._literal(token.value, this._namedNode(token.prefix));

          break;

        case '[':
          // Start a new quad with a new blank node as subject
          this._saveContext('blank', this._graph, this._subject, this._predicate, this._subject = this._blankNode());

          return this._readBlankNodeHead;

        case '(':
          // Start a new list
          this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);

          this._subject = null;
          return this._readListItem;

        case '{':
          // Start a new formula
          if (!this._n3Mode) return this._error('Unexpected graph', token);

          this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());

          return this._readSubject;

        case '<<':
          if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);

          this._saveContext('<<', this._graph, this._subject, this._predicate, null);

          this._graph = null;
          return this._readSubject;

        default:
          // Read the object entity
          if ((this._object = this._readEntity(token)) === undefined) return; // In N3 mode, the object might be a path

          if (this._n3Mode) return this._getPathReader(this._getContextEndReader());
      }

      return this._getContextEndReader();
    } // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph

  }, {
    key: "_readPredicateOrNamedGraph",
    value: function _readPredicateOrNamedGraph(token) {
      return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);
    } // ### `_readGraph` reads a graph

  }, {
    key: "_readGraph",
    value: function _readGraph(token) {
      if (token.type !== '{') return this._error('Expected graph but got ' + token.type, token); // The "subject" we read is actually the GRAPH's label

      this._graph = this._subject, this._subject = null;
      return this._readSubject;
    } // ### `_readBlankNodeHead` reads the head of a blank node

  }, {
    key: "_readBlankNodeHead",
    value: function _readBlankNodeHead(token) {
      if (token.type === ']') {
        this._subject = null;
        return this._readBlankNodeTail(token);
      } else {
        this._predicate = null;
        return this._readPredicate(token);
      }
    } // ### `_readBlankNodeTail` reads the end of a blank node

  }, {
    key: "_readBlankNodeTail",
    value: function _readBlankNodeTail(token) {
      if (token.type !== ']') return this._readBlankNodePunctuation(token); // Store blank node quad

      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this blank node

      var empty = this._predicate === null;

      this._restoreContext(); // If the blank node was the subject, continue reading the predicate


      if (this._object === null) // If the blank node was empty, it could be a named graph label
        return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank; // If the blank node was the object, restore previous context and read punctuation
      else return this._getContextEndReader();
    } // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node

  }, {
    key: "_readPredicateAfterBlank",
    value: function _readPredicateAfterBlank(token) {
      switch (token.type) {
        case '.':
        case '}':
          // No predicate is coming if the triple is terminated here
          this._subject = null;
          return this._readPunctuation(token);

        default:
          return this._readPredicate(token);
      }
    } // ### `_readListItem` reads items from a list

  }, {
    key: "_readListItem",
    value: function _readListItem(token) {
      var item = null,
          // The item of the list
      list = null,
          // The list itself
      previousList = this._subject,
          // The previous list that contains this list
      stack = this._contextStack,
          // The stack of parent contexts
      parent = stack[stack.length - 1],
          // The parent containing the current list
      next = this._readListItem; // The next function to execute

      switch (token.type) {
        case '[':
          // Stack the current list quad and start a new quad with a blank node as subject
          this._saveContext('blank', this._graph, list = this._blankNode(), this.RDF_FIRST, this._subject = item = this._blankNode());

          next = this._readBlankNodeHead;
          break;

        case '(':
          // Stack the current list quad and start a new list
          this._saveContext('list', this._graph, list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);

          this._subject = null;
          break;

        case ')':
          // Closing the list; restore the parent context
          this._restoreContext(); // If this list is contained within a parent list, return the membership quad here.
          // This will be `<parent list element> rdf:first <this list>.`.


          if (stack.length !== 0 && stack[stack.length - 1].type === 'list') this._emit(this._subject, this._predicate, this._object, this._graph); // Was this list the parent's subject?

          if (this._predicate === null) {
            // The next token is the predicate
            next = this._readPredicate; // No list tail if this was an empty list

            if (this._subject === this.RDF_NIL) return next;
          } // The list was in the parent context's object
          else {
              next = this._getContextEndReader(); // No list tail if this was an empty list

              if (this._object === this.RDF_NIL) return next;
            } // Close the list by making the head nil


          list = this.RDF_NIL;
          break;

        case 'literal':
          // Regular literal, can still get a datatype or language
          if (token.prefix.length === 0) {
            this._literalValue = token.value;
            next = this._readListItemDataTypeOrLang;
          } // Pre-datatyped string literal (prefix stores the datatype)
          else {
              item = this._literal(token.value, this._namedNode(token.prefix));
              next = this._getContextEndReader();
            }

          break;

        case '{':
          // Start a new formula
          if (!this._n3Mode) return this._error('Unexpected graph', token);

          this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());

          return this._readSubject;

        default:
          if ((item = this._readEntity(token)) === undefined) return;
      } // Create a new blank node if no item head was assigned yet


      if (list === null) this._subject = list = this._blankNode(); // Is this the first element of the list?

      if (previousList === null) {
        // This list is either the subject or the object of its parent
        if (parent.predicate === null) parent.subject = list;else parent.object = list;
      } else {
        // Continue the previous list with the current list
        this._emit(previousList, this.RDF_REST, list, this._graph);
      } // If an item was read, add it to the list


      if (item !== null) {
        // In N3 mode, the item might be a path
        if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {
          // Create a new context to add the item's path
          this._saveContext('item', this._graph, list, this.RDF_FIRST, item);

          this._subject = item, this._predicate = null; // _readPath will restore the context and output the item

          return this._getPathReader(this._readListItem);
        } // Output the item


        this._emit(list, this.RDF_FIRST, item, this._graph);
      }

      return next;
    } // ### `_readDataTypeOrLang` reads an _optional_ datatype or language

  }, {
    key: "_readDataTypeOrLang",
    value: function _readDataTypeOrLang(token) {
      return this._completeObjectLiteral(token, false);
    } // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list

  }, {
    key: "_readListItemDataTypeOrLang",
    value: function _readListItemDataTypeOrLang(token) {
      return this._completeObjectLiteral(token, true);
    } // ### `_completeLiteral` completes a literal with an optional datatype or language

  }, {
    key: "_completeLiteral",
    value: function _completeLiteral(token) {
      // Create a simple string literal by default
      var literal = this._literal(this._literalValue);

      switch (token.type) {
        // Create a datatyped literal
        case 'type':
        case 'typeIRI':
          var datatype = this._readEntity(token);

          if (datatype === undefined) return; // No datatype means an error occurred

          literal = this._literal(this._literalValue, datatype);
          token = null;
          break;
        // Create a language-tagged string

        case 'langcode':
          literal = this._literal(this._literalValue, token.value);
          token = null;
          break;
      }

      return {
        token: token,
        literal: literal
      };
    } // Completes a literal in subject position

  }, {
    key: "_completeSubjectLiteral",
    value: function _completeSubjectLiteral(token) {
      this._subject = this._completeLiteral(token).literal;
      return this._readPredicateOrNamedGraph;
    } // Completes a literal in object position

  }, {
    key: "_completeObjectLiteral",
    value: function _completeObjectLiteral(token, listItem) {
      var completed = this._completeLiteral(token);

      if (!completed) return;
      this._object = completed.literal; // If this literal was part of a list, write the item
      // (we could also check the context stack, but passing in a flag is faster)

      if (listItem) this._emit(this._subject, this.RDF_FIRST, this._object, this._graph); // If the token was consumed, continue with the rest of the input

      if (completed.token === null) return this._getContextEndReader(); // Otherwise, consume the token now
      else {
          this._readCallback = this._getContextEndReader();
          return this._readCallback(completed.token);
        }
    } // ### `_readFormulaTail` reads the end of a formula

  }, {
    key: "_readFormulaTail",
    value: function _readFormulaTail(token) {
      if (token.type !== '}') return this._readPunctuation(token); // Store the last quad of the formula

      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this formula

      this._restoreContext(); // If the formula was the subject, continue reading the predicate.
      // If the formula was the object, read punctuation.


      return this._object === null ? this._readPredicate : this._getContextEndReader();
    } // ### `_readPunctuation` reads punctuation between quads or quad parts

  }, {
    key: "_readPunctuation",
    value: function _readPunctuation(token) {
      var next,
          subject = this._subject,
          graph = this._graph,
          inversePredicate = this._inversePredicate;

      switch (token.type) {
        // A closing brace ends a graph
        case '}':
          if (this._graph === null) return this._error('Unexpected graph closing', token);
          if (this._n3Mode) return this._readFormulaTail(token);
          this._graph = null;
        // A dot just ends the statement, without sharing anything with the next

        case '.':
          this._subject = null;
          next = this._contextStack.length ? this._readSubject : this._readInTopContext;
          if (inversePredicate) this._inversePredicate = false;
          break;
        // Semicolon means the subject is shared; predicate and object are different

        case ';':
          next = this._readPredicate;
          break;
        // Comma means both the subject and predicate are shared; the object is different

        case ',':
          next = this._readObject;
          break;

        default:
          // An entity means this is a quad (only allowed if not already inside a graph)
          if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {
            next = this._readQuadPunctuation;
            break;
          }

          return this._error('Expected punctuation to follow "' + this._object.id + '"', token);
      } // A quad has been completed now, so return it


      if (subject !== null) {
        var predicate = this._predicate,
            object = this._object;
        if (!inversePredicate) this._emit(subject, predicate, object, graph);else this._emit(object, predicate, subject, graph);
      }

      return next;
    } // ### `_readBlankNodePunctuation` reads punctuation in a blank node

  }, {
    key: "_readBlankNodePunctuation",
    value: function _readBlankNodePunctuation(token) {
      var next;

      switch (token.type) {
        // Semicolon means the subject is shared; predicate and object are different
        case ';':
          next = this._readPredicate;
          break;
        // Comma means both the subject and predicate are shared; the object is different

        case ',':
          next = this._readObject;
          break;

        default:
          return this._error('Expected punctuation to follow "' + this._object.id + '"', token);
      } // A quad has been completed now, so return it


      this._emit(this._subject, this._predicate, this._object, this._graph);

      return next;
    } // ### `_readQuadPunctuation` reads punctuation after a quad

  }, {
    key: "_readQuadPunctuation",
    value: function _readQuadPunctuation(token) {
      if (token.type !== '.') return this._error('Expected dot to follow quad', token);
      return this._readInTopContext;
    } // ### `_readPrefix` reads the prefix of a prefix declaration

  }, {
    key: "_readPrefix",
    value: function _readPrefix(token) {
      if (token.type !== 'prefix') return this._error('Expected prefix to follow @prefix', token);
      this._prefix = token.value;
      return this._readPrefixIRI;
    } // ### `_readPrefixIRI` reads the IRI of a prefix declaration

  }, {
    key: "_readPrefixIRI",
    value: function _readPrefixIRI(token) {
      if (token.type !== 'IRI') return this._error('Expected IRI to follow prefix "' + this._prefix + ':"', token);

      var prefixNode = this._readEntity(token);

      this._prefixes[this._prefix] = prefixNode.value;

      this._prefixCallback(this._prefix, prefixNode);

      return this._readDeclarationPunctuation;
    } // ### `_readBaseIRI` reads the IRI of a base declaration

  }, {
    key: "_readBaseIRI",
    value: function _readBaseIRI(token) {
      var iri = token.type === 'IRI' && this._resolveIRI(token.value);

      if (!iri) return this._error('Expected valid IRI to follow base declaration', token);

      this._setBase(iri);

      return this._readDeclarationPunctuation;
    } // ### `_readNamedGraphLabel` reads the label of a named graph

  }, {
    key: "_readNamedGraphLabel",
    value: function _readNamedGraphLabel(token) {
      switch (token.type) {
        case 'IRI':
        case 'blank':
        case 'prefixed':
          return this._readSubject(token), this._readGraph;

        case '[':
          return this._readNamedGraphBlankLabel;

        default:
          return this._error('Invalid graph label', token);
      }
    } // ### `_readNamedGraphLabel` reads a blank node label of a named graph

  }, {
    key: "_readNamedGraphBlankLabel",
    value: function _readNamedGraphBlankLabel(token) {
      if (token.type !== ']') return this._error('Invalid graph label', token);
      this._subject = this._blankNode();
      return this._readGraph;
    } // ### `_readDeclarationPunctuation` reads the punctuation of a declaration

  }, {
    key: "_readDeclarationPunctuation",
    value: function _readDeclarationPunctuation(token) {
      // SPARQL-style declarations don't have punctuation
      if (this._sparqlStyle) {
        this._sparqlStyle = false;
        return this._readInTopContext(token);
      }

      if (token.type !== '.') return this._error('Expected declaration to end with a dot', token);
      return this._readInTopContext;
    } // Reads a list of quantified symbols from a @forSome or @forAll statement

  }, {
    key: "_readQuantifierList",
    value: function _readQuantifierList(token) {
      var entity;

      switch (token.type) {
        case 'IRI':
        case 'prefixed':
          if ((entity = this._readEntity(token, true)) !== undefined) break;

        default:
          return this._error('Unexpected ' + token.type, token);
      } // Without explicit quantifiers, map entities to a quantified entity


      if (!this._explicitQuantifiers) this._quantified[entity.id] = this._quantifier(this._blankNode().value); // With explicit quantifiers, output the reified quantifier
      else {
          // If this is the first item, start a new quantifier list
          if (this._subject === null) this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH); // Otherwise, continue the previous list
          else this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH); // Output the list item

          this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);
        }
      return this._readQuantifierPunctuation;
    } // Reads punctuation from a @forSome or @forAll statement

  }, {
    key: "_readQuantifierPunctuation",
    value: function _readQuantifierPunctuation(token) {
      // Read more quantifiers
      if (token.type === ',') return this._readQuantifierList; // End of the quantifier list
      else {
          // With explicit quantifiers, close the quantifier list
          if (this._explicitQuantifiers) {
            this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);

            this._subject = null;
          } // Read a dot


          this._readCallback = this._getContextEndReader();
          return this._readCallback(token);
        }
    } // ### `_getPathReader` reads a potential path and then resumes with the given function

  }, {
    key: "_getPathReader",
    value: function _getPathReader(afterPath) {
      this._afterPath = afterPath;
      return this._readPath;
    } // ### `_readPath` reads a potential path

  }, {
    key: "_readPath",
    value: function _readPath(token) {
      switch (token.type) {
        // Forward path
        case '!':
          return this._readForwardPath;
        // Backward path

        case '^':
          return this._readBackwardPath;
        // Not a path; resume reading where we left off

        default:
          var stack = this._contextStack,
              parent = stack.length && stack[stack.length - 1]; // If we were reading a list item, we still need to output it

          if (parent && parent.type === 'item') {
            // The list item is the remaining subejct after reading the path
            var item = this._subject; // Switch back to the context of the list

            this._restoreContext(); // Output the list item


            this._emit(this._subject, this.RDF_FIRST, item, this._graph);
          }

          return this._afterPath(token);
      }
    } // ### `_readForwardPath` reads a '!' path

  }, {
    key: "_readForwardPath",
    value: function _readForwardPath(token) {
      var subject,
          predicate,
          object = this._blankNode(); // The next token is the predicate


      if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's object

      if (this._predicate === null) subject = this._subject, this._subject = object; // If we were reading an object, replace the subject by the path's object
      else subject = this._object, this._object = object; // Emit the path's current quad and read its next section

      this._emit(subject, predicate, object, this._graph);

      return this._readPath;
    } // ### `_readBackwardPath` reads a '^' path

  }, {
    key: "_readBackwardPath",
    value: function _readBackwardPath(token) {
      var subject = this._blankNode(),
          predicate,
          object; // The next token is the predicate


      if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's subject

      if (this._predicate === null) object = this._subject, this._subject = subject; // If we were reading an object, replace the subject by the path's subject
      else object = this._object, this._object = subject; // Emit the path's current quad and read its next section

      this._emit(subject, predicate, object, this._graph);

      return this._readPath;
    } // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple

  }, {
    key: "_readRDFStarTailOrGraph",
    value: function _readRDFStarTailOrGraph(token) {
      if (token.type !== '>>') {
        // An entity means this is a quad (only allowed if not already inside a graph)
        if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined) return this._readRDFStarTail;
        return this._error('Expected >> to follow "' + this._object.id + '"', token);
      }

      return this._readRDFStarTail(token);
    } // ### `_readRDFStarTail` reads the end of a nested RDF* triple

  }, {
    key: "_readRDFStarTail",
    value: function _readRDFStarTail(token) {
      if (token.type !== '>>') return this._error("Expected >> but got ".concat(token.type), token); // Read the quad and restore the previous context

      var quad = this._quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);

      this._restoreContext(); // If the triple was the subject, continue by reading the predicate.


      if (this._subject === null) {
        this._subject = quad;
        return this._readPredicate;
      } // If the triple was the object, read context end.
      else {
          this._object = quad;
          return this._getContextEndReader();
        }
    } // ### `_getContextEndReader` gets the next reader function at the end of a context

  }, {
    key: "_getContextEndReader",
    value: function _getContextEndReader() {
      var contextStack = this._contextStack;
      if (!contextStack.length) return this._readPunctuation;

      switch (contextStack[contextStack.length - 1].type) {
        case 'blank':
          return this._readBlankNodeTail;

        case 'list':
          return this._readListItem;

        case 'formula':
          return this._readFormulaTail;

        case '<<':
          return this._readRDFStarTailOrGraph;
      }
    } // ### `_emit` sends a quad through the callback

  }, {
    key: "_emit",
    value: function _emit(subject, predicate, object, graph) {
      this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));
    } // ### `_error` emits an error message through the callback

  }, {
    key: "_error",
    value: function _error(message, token) {
      var err = new Error(message + ' on line ' + token.line + '.');
      err.context = {
        token: token,
        line: token.line,
        previousToken: this._lexer.previousToken
      };

      this._callback(err);

      this._callback = noop;
    } // ### `_resolveIRI` resolves an IRI against the base path

  }, {
    key: "_resolveIRI",
    value: function _resolveIRI(iri) {
      return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);
    } // ### `_resolveRelativeIRI` resolves an IRI against the base path,
    // assuming that a base path has been set and that the IRI is indeed relative

  }, {
    key: "_resolveRelativeIRI",
    value: function _resolveRelativeIRI(iri) {
      // An empty relative IRI indicates the base IRI
      if (!iri.length) return this._base; // Decide resolving strategy based in the first character

      switch (iri[0]) {
        // Resolve relative fragment IRIs against the base IRI
        case '#':
          return this._base + iri;
        // Resolve relative query string IRIs by replacing the query string

        case '?':
          return this._base.replace(/(?:\?.*)?$/, iri);
        // Resolve root-relative IRIs at the root of the base IRI

        case '/':
          // Resolve scheme-relative IRIs to the scheme
          return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);
        // Resolve all other IRIs at the base IRI's path

        default:
          // Relative IRIs cannot contain a colon in the first path segment
          return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);
      }
    } // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986

  }, {
    key: "_removeDotSegments",
    value: function _removeDotSegments(iri) {
      // Don't modify the IRI if it does not contain any dot segments
      if (!/(^|\/)\.\.?($|[/#?])/.test(iri)) return iri; // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'

      var result = '',
          length = iri.length,
          i = -1,
          pathStart = -1,
          segmentStart = 0,
          next = '/';

      while (i < length) {
        switch (next) {
          // The path starts with the first slash after the authority
          case ':':
            if (pathStart < 0) {
              // Skip two slashes before the authority
              if (iri[++i] === '/' && iri[++i] === '/') // Skip to slash after the authority
                while ((pathStart = i + 1) < length && iri[pathStart] !== '/') {
                  i = pathStart;
                }
            }

            break;
          // Don't modify a query string or fragment

          case '?':
          case '#':
            i = length;
            break;
          // Handle '/.' or '/..' path segments

          case '/':
            if (iri[i + 1] === '.') {
              next = iri[++i + 1];

              switch (next) {
                // Remove a '/.' segment
                case '/':
                  result += iri.substring(segmentStart, i - 1);
                  segmentStart = i + 1;
                  break;
                // Remove a trailing '/.' segment

                case undefined:
                case '?':
                case '#':
                  return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
                // Remove a '/..' segment

                case '.':
                  next = iri[++i + 1];

                  if (next === undefined || next === '/' || next === '?' || next === '#') {
                    result += iri.substring(segmentStart, i - 2); // Try to remove the parent path from result

                    if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart); // Remove a trailing '/..' segment

                    if (next !== '/') return result + '/' + iri.substr(i + 1);
                    segmentStart = i + 1;
                  }

              }
            }

        }

        next = iri[++i];
      }

      return result + iri.substring(segmentStart);
    } // ## Public methods
    // ### `parse` parses the N3 input and emits each parsed quad through the callback

  }, {
    key: "parse",
    value: function parse(input, quadCallback, prefixCallback) {
      var self = this; // The read callback is the next function to be executed when a token arrives.
      // We start reading in the top context.

      this._readCallback = this._readInTopContext;
      this._sparqlStyle = false;
      this._prefixes = Object.create(null);
      this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : 'b' + blankNodePrefix++ + '_';
      this._prefixCallback = prefixCallback || noop;
      this._inversePredicate = false;
      this._quantified = Object.create(null); // Parse synchronously if no quad callback is given

      if (!quadCallback) {
        var quads = [],
            error;

        this._callback = function (e, t) {
          e ? error = e : t && quads.push(t);
        };

        this._lexer.tokenize(input).every(function (token) {
          return self._readCallback = self._readCallback(token);
        });

        if (error) throw error;
        return quads;
      } // Parse asynchronously otherwise, executing the read callback when a token arrives


      this._callback = quadCallback;

      this._lexer.tokenize(input, function (error, token) {
        if (error !== null) self._callback(error), self._callback = noop;else if (self._readCallback) self._readCallback = self._readCallback(token);
      });
    }
  }], [{
    key: "_resetBlankNodePrefix",
    value: function _resetBlankNodePrefix() {
      blankNodePrefix = 0;
    }
  }]);
  return N3Parser;
}(); // The empty function


exports["default"] = N3Parser;

function noop() {} // Initializes the parser with the given data factory


function initDataFactory(parser, factory) {
  // Set factory methods
  var namedNode = factory.namedNode;
  parser._namedNode = namedNode;
  parser._blankNode = factory.blankNode;
  parser._literal = factory.literal;
  parser._variable = factory.variable;
  parser._quad = factory.quad;
  parser.DEFAULTGRAPH = factory.defaultGraph(); // Set common named nodes

  parser.RDF_FIRST = namedNode(_IRIs["default"].rdf.first);
  parser.RDF_REST = namedNode(_IRIs["default"].rdf.rest);
  parser.RDF_NIL = namedNode(_IRIs["default"].rdf.nil);
  parser.N3_FORALL = namedNode(_IRIs["default"].r.forAll);
  parser.N3_FORSOME = namedNode(_IRIs["default"].r.forSome);
  parser.ABBREVIATIONS = {
    'a': namedNode(_IRIs["default"].rdf.type),
    '=': namedNode(_IRIs["default"].owl.sameAs),
    '>': namedNode(_IRIs["default"].log.implies)
  };
  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');
}

initDataFactory(N3Parser.prototype, _N3DataFactory["default"]);

},{"./IRIs":126,"./N3DataFactory":127,"./N3Lexer":128,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],130:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault2(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

var _typeof2 = _interopRequireDefault2(require("@babel/runtime/helpers/typeof"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _N3DataFactory = _interopRequireWildcard(require("./N3DataFactory"));

var _readableStream = require("readable-stream");

var _IRIs = _interopRequireDefault(require("./IRIs"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || (0, _typeof2["default"])(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // **N3Store** objects store N3 quads by graph in memory.
// ## Constructor


var N3Store = /*#__PURE__*/function () {
  function N3Store(quads, options) {
    (0, _classCallCheck2["default"])(this, N3Store);
    // The number of quads is initially zero
    this._size = 0; // `_graphs` contains subject, predicate, and object indexes per graph

    this._graphs = Object.create(null); // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,
    // saving memory by using only numbers as keys in `_graphs`

    this._id = 0;
    this._ids = Object.create(null);
    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero

    this._entities = Object.create(null); // inverse of `_ids`
    // `_blankNodeIndex` is the index of the last automatically named blank node

    this._blankNodeIndex = 0; // Shift parameters if `quads` is not given

    if (!options && quads && !quads[0]) options = quads, quads = null;
    options = options || {};
    this._factory = options.factory || _N3DataFactory["default"]; // Add quads if passed

    if (quads) this.addQuads(quads);
  } // ## Public properties
  // ### `size` returns the number of quads in the store


  (0, _createClass2["default"])(N3Store, [{
    key: "_addToIndex",
    // ## Private methods
    // ### `_addToIndex` adds a quad to a three-layered index.
    // Returns if the index has changed, if the entry did not already exist.
    value: function _addToIndex(index0, key0, key1, key2) {
      // Create layers as necessary
      var index1 = index0[key0] || (index0[key0] = {});
      var index2 = index1[key1] || (index1[key1] = {}); // Setting the key to _any_ value signals the presence of the quad

      var existed = (key2 in index2);
      if (!existed) index2[key2] = null;
      return !existed;
    } // ### `_removeFromIndex` removes a quad from a three-layered index

  }, {
    key: "_removeFromIndex",
    value: function _removeFromIndex(index0, key0, key1, key2) {
      // Remove the quad from the index
      var index1 = index0[key0],
          index2 = index1[key1],
          key;
      delete index2[key2]; // Remove intermediary index layers if they are empty

      for (key in index2) {
        return;
      }

      delete index1[key1];

      for (key in index1) {
        return;
      }

      delete index0[key0];
    } // ### `_findInIndex` finds a set of quads in a three-layered index.
    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
    // Any of these keys can be undefined, which is interpreted as a wildcard.
    // `name0`, `name1`, and `name2` are the names of the keys at each level,
    // used when reconstructing the resulting quad
    // (for instance: _subject_, _predicate_, and _object_).
    // Finally, `graph` will be the graph of the created quads.
    // If `callback` is given, each result is passed through it
    // and iteration halts when it returns truthy for any quad.
    // If instead `array` is given, each result is added to the array.

  }, {
    key: "_findInIndex",
    value: function _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {
      var tmp,
          index1,
          index2,
          varCount = !key0 + !key1 + !key2,
          // depending on the number of variables, keys or reverse index are faster
      entityKeys = varCount > 1 ? Object.keys(this._ids) : this._entities; // If a key is specified, use only that part of index 0.

      if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];

      for (var value0 in index0) {
        var entity0 = entityKeys[value0];

        if (index1 = index0[value0]) {
          // If a key is specified, use only that part of index 1.
          if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];

          for (var value1 in index1) {
            var entity1 = entityKeys[value1];

            if (index2 = index1[value1]) {
              // If a key is specified, use only that part of index 2, if it exists.
              var values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2); // Create quads for all items found in index 2.

              for (var l = 0; l < values.length; l++) {
                var parts = {
                  subject: null,
                  predicate: null,
                  object: null
                };
                parts[name0] = (0, _N3DataFactory.termFromId)(entity0, this._factory);
                parts[name1] = (0, _N3DataFactory.termFromId)(entity1, this._factory);
                parts[name2] = (0, _N3DataFactory.termFromId)(entityKeys[values[l]], this._factory);

                var quad = this._factory.quad(parts.subject, parts.predicate, parts.object, (0, _N3DataFactory.termFromId)(graph, this._factory));

                if (array) array.push(quad);else if (callback(quad)) return true;
              }
            }
          }
        }
      }

      return array;
    } // ### `_loop` executes the callback on all keys of index 0

  }, {
    key: "_loop",
    value: function _loop(index0, callback) {
      for (var key0 in index0) {
        callback(key0);
      }
    } // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0

  }, {
    key: "_loopByKey0",
    value: function _loopByKey0(index0, key0, callback) {
      var index1, key1;

      if (index1 = index0[key0]) {
        for (key1 in index1) {
          callback(key1);
        }
      }
    } // ### `_loopByKey1` executes the callback on given keys of all entries in index 0

  }, {
    key: "_loopByKey1",
    value: function _loopByKey1(index0, key1, callback) {
      var key0, index1;

      for (key0 in index0) {
        index1 = index0[key0];
        if (index1[key1]) callback(key0);
      }
    } // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2

  }, {
    key: "_loopBy2Keys",
    value: function _loopBy2Keys(index0, key0, key1, callback) {
      var index1, index2, key2;

      if ((index1 = index0[key0]) && (index2 = index1[key1])) {
        for (key2 in index2) {
          callback(key2);
        }
      }
    } // ### `_countInIndex` counts matching quads in a three-layered index.
    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
    // Any of these keys can be undefined, which is interpreted as a wildcard.

  }, {
    key: "_countInIndex",
    value: function _countInIndex(index0, key0, key1, key2) {
      var count = 0,
          tmp,
          index1,
          index2; // If a key is specified, count only that part of index 0

      if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];

      for (var value0 in index0) {
        if (index1 = index0[value0]) {
          // If a key is specified, count only that part of index 1
          if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];

          for (var value1 in index1) {
            if (index2 = index1[value1]) {
              // If a key is specified, count the quad if it exists
              if (key2) key2 in index2 && count++; // Otherwise, count all quads
              else count += Object.keys(index2).length;
            }
          }
        }
      }

      return count;
    } // ### `_getGraphs` returns an array with the given graph,
    // or all graphs if the argument is null or undefined.

  }, {
    key: "_getGraphs",
    value: function _getGraphs(graph) {
      if (!isString(graph)) return this._graphs;
      var graphs = {};
      graphs[graph] = this._graphs[graph];
      return graphs;
    } // ### `_uniqueEntities` returns a function that accepts an entity ID
    // and passes the corresponding entity to callback if it hasn't occurred before.

  }, {
    key: "_uniqueEntities",
    value: function _uniqueEntities(callback) {
      var uniqueIds = Object.create(null),
          entities = this._entities;
      return function (id) {
        if (!(id in uniqueIds)) {
          uniqueIds[id] = true;
          callback((0, _N3DataFactory.termFromId)(entities[id]));
        }
      };
    } // ## Public methods
    // ### `addQuad` adds a new quad to the store.
    // Returns if the quad index has changed, if the quad did not already exist.

  }, {
    key: "addQuad",
    value: function addQuad(subject, predicate, object, graph) {
      // Shift arguments if a quad object is given instead of components
      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation

      subject = (0, _N3DataFactory.termToId)(subject);
      predicate = (0, _N3DataFactory.termToId)(predicate);
      object = (0, _N3DataFactory.termToId)(object);
      graph = (0, _N3DataFactory.termToId)(graph); // Find the graph that will contain the triple

      var graphItem = this._graphs[graph]; // Create the graph if it doesn't exist yet

      if (!graphItem) {
        graphItem = this._graphs[graph] = {
          subjects: {},
          predicates: {},
          objects: {}
        }; // Freezing a graph helps subsequent `add` performance,
        // and properties will never be modified anyway

        Object.freeze(graphItem);
      } // Since entities can often be long IRIs, we avoid storing them in every index.
      // Instead, we have a separate index that maps entities to numbers,
      // which are then used as keys in the other indexes.


      var ids = this._ids;
      var entities = this._entities;
      subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);
      predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);
      object = ids[object] || (ids[entities[++this._id] = object] = this._id);

      var changed = this._addToIndex(graphItem.subjects, subject, predicate, object);

      this._addToIndex(graphItem.predicates, predicate, object, subject);

      this._addToIndex(graphItem.objects, object, subject, predicate); // The cached quad count is now invalid


      this._size = null;
      return changed;
    } // ### `addQuads` adds multiple quads to the store

  }, {
    key: "addQuads",
    value: function addQuads(quads) {
      for (var i = 0; i < quads.length; i++) {
        this.addQuad(quads[i]);
      }
    } // ### `import` adds a stream of quads to the store

  }, {
    key: "import",
    value: function _import(stream) {
      var self = this;
      stream.on('data', function (quad) {
        self.addQuad(quad);
      });
      return stream;
    } // ### `removeQuad` removes a quad from the store if it exists

  }, {
    key: "removeQuad",
    value: function removeQuad(subject, predicate, object, graph) {
      // Shift arguments if a quad object is given instead of components
      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation

      subject = (0, _N3DataFactory.termToId)(subject);
      predicate = (0, _N3DataFactory.termToId)(predicate);
      object = (0, _N3DataFactory.termToId)(object);
      graph = (0, _N3DataFactory.termToId)(graph); // Find internal identifiers for all components
      // and verify the quad exists.

      var graphItem,
          ids = this._ids,
          graphs = this._graphs,
          subjects,
          predicates;
      if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) return false; // Remove it from all indexes

      this._removeFromIndex(graphItem.subjects, subject, predicate, object);

      this._removeFromIndex(graphItem.predicates, predicate, object, subject);

      this._removeFromIndex(graphItem.objects, object, subject, predicate);

      if (this._size !== null) this._size--; // Remove the graph if it is empty

      for (subject in graphItem.subjects) {
        return true;
      }

      delete graphs[graph];
      return true;
    } // ### `removeQuads` removes multiple quads from the store

  }, {
    key: "removeQuads",
    value: function removeQuads(quads) {
      for (var i = 0; i < quads.length; i++) {
        this.removeQuad(quads[i]);
      }
    } // ### `remove` removes a stream of quads from the store

  }, {
    key: "remove",
    value: function remove(stream) {
      var self = this;
      stream.on('data', function (quad) {
        self.removeQuad(quad);
      });
      return stream;
    } // ### `removeMatches` removes all matching quads from the store
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "removeMatches",
    value: function removeMatches(subject, predicate, object, graph) {
      return this.remove(this.match(subject, predicate, object, graph));
    } // ### `deleteGraph` removes all triples with the given graph from the store

  }, {
    key: "deleteGraph",
    value: function deleteGraph(graph) {
      return this.removeMatches(null, null, null, graph);
    } // ### `getQuads` returns an array of quads matching a pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getQuads",
    value: function getQuads(subject, predicate, object, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var quads = [],
          graphs = this._getGraphs(graph),
          content,
          ids = this._ids,
          subjectId,
          predicateId,
          objectId; // Translate IRIs to internal index keys.


      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return quads;

      for (var graphId in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graphId]) {
          // Choose the optimal index, based on what fields are present
          if (subjectId) {
            if (objectId) // If subject and object are given, the object index will be the fastest
              this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads);else // If only subject and possibly predicate are given, the subject index will be the fastest
              this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads);
          } else if (predicateId) // If only predicate and possibly object are given, the predicate index will be the fastest
            this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads);else if (objectId) // If only object is given, the object index will be the fastest
            this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads);else // If nothing is given, iterate subjects and predicates first
            this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads);
        }
      }

      return quads;
    } // ### `match` returns a stream of quads matching a pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "match",
    value: function match(subject, predicate, object, graph) {
      var _this = this;

      var stream = new _readableStream.Readable({
        objectMode: true
      }); // Initialize stream once it is being read

      stream._read = function () {
        var _iterator = _createForOfIteratorHelper(_this.getQuads(subject, predicate, object, graph)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var quad = _step.value;
            stream.push(quad);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        stream.push(null);
      };

      return stream;
    } // ### `countQuads` returns the number of quads matching a pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "countQuads",
    value: function countQuads(subject, predicate, object, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var count = 0,
          graphs = this._getGraphs(graph),
          content,
          ids = this._ids,
          subjectId,
          predicateId,
          objectId; // Translate IRIs to internal index keys.


      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return 0;

      for (var graphId in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graphId]) {
          // Choose the optimal index, based on what fields are present
          if (subject) {
            if (object) // If subject and object are given, the object index will be the fastest
              count += this._countInIndex(content.objects, objectId, subjectId, predicateId);else // If only subject and possibly predicate are given, the subject index will be the fastest
              count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);
          } else if (predicate) {
            // If only predicate and possibly object are given, the predicate index will be the fastest
            count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);
          } else {
            // If only object is possibly given, the object index will be the fastest
            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
          }
        }
      }

      return count;
    } // ### `forEach` executes the callback on all quads.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forEach",
    value: function forEach(callback, subject, predicate, object, graph) {
      this.some(function (quad) {
        callback(quad);
        return false;
      }, subject, predicate, object, graph);
    } // ### `every` executes the callback on all quads,
    // and returns `true` if it returns truthy for all them.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "every",
    value: function every(callback, subject, predicate, object, graph) {
      var some = false;
      var every = !this.some(function (quad) {
        some = true;
        return !callback(quad);
      }, subject, predicate, object, graph);
      return some && every;
    } // ### `some` executes the callback on all quads,
    // and returns `true` if it returns truthy for any of them.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "some",
    value: function some(callback, subject, predicate, object, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var graphs = this._getGraphs(graph),
          content,
          ids = this._ids,
          subjectId,
          predicateId,
          objectId; // Translate IRIs to internal index keys.


      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return false;

      for (var graphId in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graphId]) {
          // Choose the optimal index, based on what fields are present
          if (subjectId) {
            if (objectId) {
              // If subject and object are given, the object index will be the fastest
              if (this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, callback, null)) return true;
            } else // If only subject and possibly predicate are given, the subject index will be the fastest
              if (this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, callback, null)) return true;
          } else if (predicateId) {
            // If only predicate and possibly object are given, the predicate index will be the fastest
            if (this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, callback, null)) {
              return true;
            }
          } else if (objectId) {
            // If only object is given, the object index will be the fastest
            if (this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, callback, null)) {
              return true;
            }
          } else // If nothing is given, iterate subjects and predicates first
            if (this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, callback, null)) {
              return true;
            }
        }
      }

      return false;
    } // ### `getSubjects` returns all subjects that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getSubjects",
    value: function getSubjects(predicate, object, graph) {
      var results = [];
      this.forSubjects(function (s) {
        results.push(s);
      }, predicate, object, graph);
      return results;
    } // ### `forSubjects` executes the callback on all subjects that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forSubjects",
    value: function forSubjects(callback, predicate, object, graph) {
      // Convert terms to internal string representation
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var ids = this._ids,
          graphs = this._getGraphs(graph),
          content,
          predicateId,
          objectId;

      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.

      if (isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;

      for (graph in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graph]) {
          // Choose optimal index based on which fields are wildcards
          if (predicateId) {
            if (objectId) // If predicate and object are given, the POS index is best.
              this._loopBy2Keys(content.predicates, predicateId, objectId, callback);else // If only predicate is given, the SPO index is best.
              this._loopByKey1(content.subjects, predicateId, callback);
          } else if (objectId) // If only object is given, the OSP index is best.
            this._loopByKey0(content.objects, objectId, callback);else // If no params given, iterate all the subjects
            this._loop(content.subjects, callback);
        }
      }
    } // ### `getPredicates` returns all predicates that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getPredicates",
    value: function getPredicates(subject, object, graph) {
      var results = [];
      this.forPredicates(function (p) {
        results.push(p);
      }, subject, object, graph);
      return results;
    } // ### `forPredicates` executes the callback on all predicates that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forPredicates",
    value: function forPredicates(callback, subject, object, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var ids = this._ids,
          graphs = this._getGraphs(graph),
          content,
          subjectId,
          objectId;

      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.

      if (isString(subject) && !(subjectId = ids[subject]) || isString(object) && !(objectId = ids[object])) return;

      for (graph in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graph]) {
          // Choose optimal index based on which fields are wildcards
          if (subjectId) {
            if (objectId) // If subject and object are given, the OSP index is best.
              this._loopBy2Keys(content.objects, objectId, subjectId, callback);else // If only subject is given, the SPO index is best.
              this._loopByKey0(content.subjects, subjectId, callback);
          } else if (objectId) // If only object is given, the POS index is best.
            this._loopByKey1(content.predicates, objectId, callback);else // If no params given, iterate all the predicates.
            this._loop(content.predicates, callback);
        }
      }
    } // ### `getObjects` returns all objects that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getObjects",
    value: function getObjects(subject, predicate, graph) {
      var results = [];
      this.forObjects(function (o) {
        results.push(o);
      }, subject, predicate, graph);
      return results;
    } // ### `forObjects` executes the callback on all objects that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forObjects",
    value: function forObjects(callback, subject, predicate, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var ids = this._ids,
          graphs = this._getGraphs(graph),
          content,
          subjectId,
          predicateId;

      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.

      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate])) return;

      for (graph in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graph]) {
          // Choose optimal index based on which fields are wildcards
          if (subjectId) {
            if (predicateId) // If subject and predicate are given, the SPO index is best.
              this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);else // If only subject is given, the OSP index is best.
              this._loopByKey1(content.objects, subjectId, callback);
          } else if (predicateId) // If only predicate is given, the POS index is best.
            this._loopByKey0(content.predicates, predicateId, callback);else // If no params given, iterate all the objects.
            this._loop(content.objects, callback);
        }
      }
    } // ### `getGraphs` returns all graphs that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getGraphs",
    value: function getGraphs(subject, predicate, object) {
      var results = [];
      this.forGraphs(function (g) {
        results.push(g);
      }, subject, predicate, object);
      return results;
    } // ### `forGraphs` executes the callback on all graphs that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forGraphs",
    value: function forGraphs(callback, subject, predicate, object) {
      for (var graph in this._graphs) {
        this.some(function (quad) {
          callback(quad.graph);
          return true; // Halt iteration of some()
        }, subject, predicate, object, graph);
      }
    } // ### `createBlankNode` creates a new blank node, returning its name

  }, {
    key: "createBlankNode",
    value: function createBlankNode(suggestedName) {
      var name, index; // Generate a name based on the suggested name

      if (suggestedName) {
        name = suggestedName = '_:' + suggestedName, index = 1;

        while (this._ids[name]) {
          name = suggestedName + index++;
        }
      } // Generate a generic blank node name
      else {
          do {
            name = '_:b' + this._blankNodeIndex++;
          } while (this._ids[name]);
        } // Add the blank node to the entities, avoiding the generation of duplicates


      this._ids[name] = ++this._id;
      this._entities[this._id] = name;
      return this._factory.blankNode(name.substr(2));
    } // ### `extractLists` finds and removes all list triples
    // and returns the items per list.

  }, {
    key: "extractLists",
    value: function extractLists() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$remove = _ref.remove,
          remove = _ref$remove === void 0 ? false : _ref$remove,
          _ref$ignoreErrors = _ref.ignoreErrors,
          ignoreErrors = _ref$ignoreErrors === void 0 ? false : _ref$ignoreErrors;

      var lists = {}; // has scalar keys so could be a simple Object

      var onError = ignoreErrors ? function () {
        return true;
      } : function (node, message) {
        throw new Error("".concat(node.value, " ").concat(message));
      }; // Traverse each list from its tail

      var tails = this.getQuads(null, _IRIs["default"].rdf.rest, _IRIs["default"].rdf.nil, null);
      var toRemove = remove ? (0, _toConsumableArray2["default"])(tails) : [];
      tails.forEach(function (tailQuad) {
        var items = []; // the members found as objects of rdf:first quads

        var malformed = false; // signals whether the current list is malformed

        var head; // the head of the list (_:b1 in above example)

        var headPos; // set to subject or object when head is set

        var graph = tailQuad.graph; // make sure list is in exactly one graph
        // Traverse the list from tail to end

        var current = tailQuad.subject;

        while (current && !malformed) {
          var objectQuads = _this2.getQuads(null, null, current, null);

          var subjectQuads = _this2.getQuads(current, null, null, null);

          var i,
              quad,
              first = null,
              rest = null,
              parent = null; // Find the first and rest of this list node

          for (i = 0; i < subjectQuads.length && !malformed; i++) {
            quad = subjectQuads[i];
            if (!quad.graph.equals(graph)) malformed = onError(current, 'not confined to single graph');else if (head) malformed = onError(current, 'has non-list arcs out'); // one rdf:first
            else if (quad.predicate.value === _IRIs["default"].rdf.first) {
                if (first) malformed = onError(current, 'has multiple rdf:first arcs');else toRemove.push(first = quad);
              } // one rdf:rest
              else if (quad.predicate.value === _IRIs["default"].rdf.rest) {
                  if (rest) malformed = onError(current, 'has multiple rdf:rest arcs');else toRemove.push(rest = quad);
                } // alien triple
                else if (objectQuads.length) malformed = onError(current, 'can\'t be subject and object');else {
                    head = quad; // e.g. { (1 2 3) :p :o }

                    headPos = 'subject';
                  }
          } // { :s :p (1 2) } arrives here with no head
          // { (1 2) :p :o } arrives here with head set to the list.


          for (i = 0; i < objectQuads.length && !malformed; ++i) {
            quad = objectQuads[i];
            if (head) malformed = onError(current, 'can\'t have coreferences'); // one rdf:rest
            else if (quad.predicate.value === _IRIs["default"].rdf.rest) {
                if (parent) malformed = onError(current, 'has incoming rdf:rest arcs');else parent = quad;
              } else {
                head = quad; // e.g. { :s :p (1 2) }

                headPos = 'object';
              }
          } // Store the list item and continue with parent


          if (!first) malformed = onError(current, 'has no list head');else items.unshift(first.object);
          current = parent && parent.subject;
        } // Don't remove any quads if the list is malformed


        if (malformed) remove = false; // Store the list under the value of its head
        else if (head) lists[head[headPos].value] = items;
      }); // Remove list quads if requested

      if (remove) this.removeQuads(toRemove);
      return lists;
    }
  }, {
    key: "size",
    get: function get() {
      // Return the quad count if if was cached
      var size = this._size;
      if (size !== null) return size; // Calculate the number of quads by counting to the deepest level

      size = 0;
      var graphs = this._graphs,
          subjects,
          subject;

      for (var graphKey in graphs) {
        for (var subjectKey in subjects = graphs[graphKey].subjects) {
          for (var predicateKey in subject = subjects[subjectKey]) {
            size += Object.keys(subject[predicateKey]).length;
          }
        }
      }

      return this._size = size;
    }
  }]);
  return N3Store;
}(); // Determines whether the argument is a string


exports["default"] = N3Store;

function isString(s) {
  return typeof s === 'string' || s instanceof String;
}

},{"./IRIs":126,"./N3DataFactory":127,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/toConsumableArray":26,"@babel/runtime/helpers/typeof":27,"readable-stream":186}],131:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault2(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _N3Parser = _interopRequireDefault(require("./N3Parser"));

var _readableStream = require("readable-stream");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3StreamParser** parses a text stream into a quad stream.
// ## Constructor


var N3StreamParser = /*#__PURE__*/function (_readableStream$Trans) {
  (0, _inherits2["default"])(N3StreamParser, _readableStream$Trans);

  var _super = _createSuper(N3StreamParser);

  function N3StreamParser(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, N3StreamParser);
    _this = _super.call(this, {
      decodeStrings: true
    });
    _this._readableState.objectMode = true; // Set up parser with dummy stream to obtain `data` and `end` callbacks

    var self = (0, _assertThisInitialized2["default"])(_this),
        parser = new _N3Parser["default"](options),
        onData,
        onEnd;
    parser.parse({
      on: function on(event, callback) {
        switch (event) {
          case 'data':
            onData = callback;
            break;

          case 'end':
            onEnd = callback;
            break;
        }
      }
    }, // Handle quads by pushing them down the pipeline
    function (error, quad) {
      error && self.emit('error', error) || quad && self.push(quad);
    }, // Emit prefixes through the `prefix` event
    function (prefix, uri) {
      self.emit('prefix', prefix, uri);
    }); // Implement Transform methods through parser callbacks

    _this._transform = function (chunk, encoding, done) {
      onData(chunk);
      done();
    };

    _this._flush = function (done) {
      onEnd();
      done();
    };

    return _this;
  } // ### Parses a stream of strings


  (0, _createClass2["default"])(N3StreamParser, [{
    key: "import",
    value: function _import(stream) {
      var self = this;
      stream.on('data', function (chunk) {
        self.write(chunk);
      });
      stream.on('end', function () {
        self.end();
      });
      stream.on('error', function (error) {
        self.emit('error', error);
      });
      return this;
    }
  }]);
  return N3StreamParser;
}(_readableStream.Transform);

exports["default"] = N3StreamParser;

},{"./N3Parser":129,"@babel/runtime/helpers/assertThisInitialized":5,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"readable-stream":186}],132:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault2(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _readableStream = require("readable-stream");

var _N3Writer = _interopRequireDefault(require("./N3Writer"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3StreamWriter** serializes a quad stream into a text stream.
// ## Constructor


var N3StreamWriter = /*#__PURE__*/function (_readableStream$Trans) {
  (0, _inherits2["default"])(N3StreamWriter, _readableStream$Trans);

  var _super = _createSuper(N3StreamWriter);

  function N3StreamWriter(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, N3StreamWriter);
    _this = _super.call(this, {
      encoding: 'utf8'
    });
    _this._writableState.objectMode = true; // Set up writer with a dummy stream object

    var self = (0, _assertThisInitialized2["default"])(_this);
    var writer = _this._writer = new _N3Writer["default"]({
      write: function write(quad, encoding, callback) {
        self.push(quad);
        callback && callback();
      },
      end: function end(callback) {
        self.push(null);
        callback && callback();
      }
    }, options); // Implement Transform methods on top of writer

    _this._transform = function (quad, encoding, done) {
      writer.addQuad(quad, done);
    };

    _this._flush = function (done) {
      writer.end(done);
    };

    return _this;
  } // ### Serializes a stream of quads


  (0, _createClass2["default"])(N3StreamWriter, [{
    key: "import",
    value: function _import(stream) {
      var self = this;
      stream.on('data', function (quad) {
        self.write(quad);
      });
      stream.on('end', function () {
        self.end();
      });
      stream.on('error', function (error) {
        self.emit('error', error);
      });
      stream.on('prefix', function (prefix, iri) {
        self._writer.addPrefix(prefix, iri);
      });
      return this;
    }
  }]);
  return N3StreamWriter;
}(_readableStream.Transform);

exports["default"] = N3StreamWriter;

},{"./N3Writer":134,"@babel/runtime/helpers/assertThisInitialized":5,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"readable-stream":186}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNamedNode = isNamedNode;
exports.isBlankNode = isBlankNode;
exports.isLiteral = isLiteral;
exports.isVariable = isVariable;
exports.isDefaultGraph = isDefaultGraph;
exports.inDefaultGraph = inDefaultGraph;
exports.prefix = prefix;
exports.prefixes = prefixes;

var _N3DataFactory = _interopRequireDefault(require("./N3DataFactory"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3Util** provides N3 utility functions.
// Tests whether the given term represents an IRI


function isNamedNode(term) {
  return !!term && term.termType === 'NamedNode';
} // Tests whether the given term represents a blank node


function isBlankNode(term) {
  return !!term && term.termType === 'BlankNode';
} // Tests whether the given term represents a literal


function isLiteral(term) {
  return !!term && term.termType === 'Literal';
} // Tests whether the given term represents a variable


function isVariable(term) {
  return !!term && term.termType === 'Variable';
} // Tests whether the given term represents the default graph


function isDefaultGraph(term) {
  return !!term && term.termType === 'DefaultGraph';
} // Tests whether the given quad is in the default graph


function inDefaultGraph(quad) {
  return isDefaultGraph(quad.graph);
} // Creates a function that prepends the given IRI to a local name


function prefix(iri, factory) {
  return prefixes({
    '': iri
  }, factory)('');
} // Creates a function that allows registering and expanding prefixes


function prefixes(defaultPrefixes, factory) {
  // Add all of the default prefixes
  var prefixes = Object.create(null);

  for (var prefix in defaultPrefixes) {
    processPrefix(prefix, defaultPrefixes[prefix]);
  } // Set the default factory if none was specified


  factory = factory || _N3DataFactory["default"]; // Registers a new prefix (if an IRI was specified)
  // or retrieves a function that expands an existing prefix (if no IRI was specified)

  function processPrefix(prefix, iri) {
    // Create a new prefix if an IRI is specified or the prefix doesn't exist
    if (typeof iri === 'string') {
      // Create a function that expands the prefix
      var cache = Object.create(null);

      prefixes[prefix] = function (local) {
        return cache[local] || (cache[local] = factory.namedNode(iri + local));
      };
    } else if (!(prefix in prefixes)) {
      throw new Error('Unknown prefix: ' + prefix);
    }

    return prefixes[prefix];
  }

  return processPrefix;
}

},{"./N3DataFactory":127}],134:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

var _typeof2 = _interopRequireDefault2(require("@babel/runtime/helpers/typeof"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _IRIs = _interopRequireDefault(require("./IRIs"));

var _N3DataFactory = _interopRequireWildcard(require("./N3DataFactory"));

var _N3Util = require("./N3Util");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || (0, _typeof2["default"])(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3Writer** writes N3 documents.


var DEFAULTGRAPH = _N3DataFactory["default"].defaultGraph();

var _IRIs$default = _IRIs["default"],
    rdf = _IRIs$default.rdf,
    xsd = _IRIs$default.xsd; // Characters in literals that require escaping

var escape = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/,
    escapeAll = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g,
    escapedCharacters = {
  '\\': '\\\\',
  '"': '\\"',
  '\t': '\\t',
  '\n': '\\n',
  '\r': '\\r',
  '\b': '\\b',
  '\f': '\\f'
}; // ## Placeholder class to represent already pretty-printed terms

var SerializedTerm = /*#__PURE__*/function (_N3DataFactory$Term) {
  (0, _inherits2["default"])(SerializedTerm, _N3DataFactory$Term);

  var _super = _createSuper(SerializedTerm);

  function SerializedTerm() {
    (0, _classCallCheck2["default"])(this, SerializedTerm);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(SerializedTerm, [{
    key: "equals",
    // Pretty-printed nodes are not equal to any other node
    // (e.g., [] does not equal [])
    value: function equals() {
      return false;
    }
  }]);
  return SerializedTerm;
}(_N3DataFactory.Term); // ## Constructor


var N3Writer = /*#__PURE__*/function () {
  function N3Writer(outputStream, options) {
    (0, _classCallCheck2["default"])(this, N3Writer);
    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes
    this._prefixRegex = /$0^/; // Shift arguments if the first argument is not a stream

    if (outputStream && typeof outputStream.write !== 'function') options = outputStream, outputStream = null;
    options = options || {};
    this._lists = options.lists; // If no output stream given, send the output as string through the end callback

    if (!outputStream) {
      var output = '';
      this._outputStream = {
        write: function write(chunk, encoding, done) {
          output += chunk;
          done && done();
        },
        end: function end(done) {
          done && done(null, output);
        }
      };
      this._endStream = true;
    } else {
      this._outputStream = outputStream;
      this._endStream = options.end === undefined ? true : !!options.end;
    } // Initialize writer, depending on the format


    this._subject = null;

    if (!/triple|quad/i.test(options.format)) {
      this._graph = DEFAULTGRAPH;
      this._prefixIRIs = Object.create(null);
      options.prefixes && this.addPrefixes(options.prefixes);
    } else {
      this._writeQuad = this._writeQuadLine;
    }
  } // ## Private methods
  // ### Whether the current graph is the default graph


  (0, _createClass2["default"])(N3Writer, [{
    key: "_write",
    // ### `_write` writes the argument to the output stream
    value: function _write(string, callback) {
      this._outputStream.write(string, 'utf8', callback);
    } // ### `_writeQuad` writes the quad to the output stream

  }, {
    key: "_writeQuad",
    value: function _writeQuad(subject, predicate, object, graph, done) {
      try {
        // Write the graph's label if it has changed
        if (!graph.equals(this._graph)) {
          // Close the previous graph and start the new one
          this._write((this._subject === null ? '' : this._inDefaultGraph ? '.\n' : '\n}\n') + (DEFAULTGRAPH.equals(graph) ? '' : this._encodeIriOrBlank(graph) + ' {\n'));

          this._graph = graph;
          this._subject = null;
        } // Don't repeat the subject if it's the same


        if (subject.equals(this._subject)) {
          // Don't repeat the predicate if it's the same
          if (predicate.equals(this._predicate)) this._write(', ' + this._encodeObject(object), done); // Same subject, different predicate
          else this._write(';\n    ' + this._encodePredicate(this._predicate = predicate) + ' ' + this._encodeObject(object), done);
        } // Different subject; write the whole quad
        else this._write((this._subject === null ? '' : '.\n') + this._encodeSubject(this._subject = subject) + ' ' + this._encodePredicate(this._predicate = predicate) + ' ' + this._encodeObject(object), done);
      } catch (error) {
        done && done(error);
      }
    } // ### `_writeQuadLine` writes the quad to the output stream as a single line

  }, {
    key: "_writeQuadLine",
    value: function _writeQuadLine(subject, predicate, object, graph, done) {
      // Write the quad without prefixes
      delete this._prefixMatch;

      this._write(this.quadToString(subject, predicate, object, graph), done);
    } // ### `quadToString` serializes a quad as a string

  }, {
    key: "quadToString",
    value: function quadToString(subject, predicate, object, graph) {
      return this._encodeSubject(subject) + ' ' + this._encodeIriOrBlank(predicate) + ' ' + this._encodeObject(object) + (graph && graph.value ? ' ' + this._encodeIriOrBlank(graph) + ' .\n' : ' .\n');
    } // ### `quadsToString` serializes an array of quads as a string

  }, {
    key: "quadsToString",
    value: function quadsToString(quads) {
      return quads.map(function (t) {
        return this.quadToString(t.subject, t.predicate, t.object, t.graph);
      }, this).join('');
    } // ### `_encodeSubject` represents a subject

  }, {
    key: "_encodeSubject",
    value: function _encodeSubject(entity) {
      return entity.termType === 'Quad' ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);
    } // ### `_encodeIriOrBlank` represents an IRI or blank node

  }, {
    key: "_encodeIriOrBlank",
    value: function _encodeIriOrBlank(entity) {
      // A blank node or list is represented as-is
      if (entity.termType !== 'NamedNode') {
        // If it is a list head, pretty-print it
        if (this._lists && entity.value in this._lists) entity = this.list(this._lists[entity.value]);
        return 'id' in entity ? entity.id : '_:' + entity.value;
      } // Escape special characters


      var iri = entity.value;
      if (escape.test(iri)) iri = iri.replace(escapeAll, characterReplacer); // Try to represent the IRI as prefixed name

      var prefixMatch = this._prefixRegex.exec(iri);

      return !prefixMatch ? '<' + iri + '>' : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];
    } // ### `_encodeLiteral` represents a literal

  }, {
    key: "_encodeLiteral",
    value: function _encodeLiteral(literal) {
      // Escape special characters
      var value = literal.value;
      if (escape.test(value)) value = value.replace(escapeAll, characterReplacer); // Write the literal, possibly with type or language

      if (literal.language) return '"' + value + '"@' + literal.language;else if (literal.datatype.value !== xsd.string) return '"' + value + '"^^' + this._encodeIriOrBlank(literal.datatype);else return '"' + value + '"';
    } // ### `_encodePredicate` represents a predicate

  }, {
    key: "_encodePredicate",
    value: function _encodePredicate(predicate) {
      return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);
    } // ### `_encodeObject` represents an object

  }, {
    key: "_encodeObject",
    value: function _encodeObject(object) {
      switch (object.termType) {
        case 'Quad':
          return this._encodeQuad(object);

        case 'Literal':
          return this._encodeLiteral(object);

        default:
          return this._encodeIriOrBlank(object);
      }
    } // ### `_encodeQuad` encodes an RDF* quad

  }, {
    key: "_encodeQuad",
    value: function _encodeQuad(_ref) {
      var subject = _ref.subject,
          predicate = _ref.predicate,
          object = _ref.object,
          graph = _ref.graph;
      return "<<".concat(this._encodeSubject(subject), " ").concat(this._encodePredicate(predicate), " ").concat(this._encodeObject(object)).concat((0, _N3Util.isDefaultGraph)(graph) ? '' : " ".concat(this._encodeIriOrBlank(graph)), ">>");
    } // ### `_blockedWrite` replaces `_write` after the writer has been closed

  }, {
    key: "_blockedWrite",
    value: function _blockedWrite() {
      throw new Error('Cannot write because the writer has been closed.');
    } // ### `addQuad` adds the quad to the output stream

  }, {
    key: "addQuad",
    value: function addQuad(subject, predicate, object, graph, done) {
      // The quad was given as an object, so shift parameters
      if (object === undefined) this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate); // The optional `graph` parameter was not provided
      else if (typeof graph === 'function') this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph); // The `graph` parameter was provided
        else this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);
    } // ### `addQuads` adds the quads to the output stream

  }, {
    key: "addQuads",
    value: function addQuads(quads) {
      for (var i = 0; i < quads.length; i++) {
        this.addQuad(quads[i]);
      }
    } // ### `addPrefix` adds the prefix to the output stream

  }, {
    key: "addPrefix",
    value: function addPrefix(prefix, iri, done) {
      var prefixes = {};
      prefixes[prefix] = iri;
      this.addPrefixes(prefixes, done);
    } // ### `addPrefixes` adds the prefixes to the output stream

  }, {
    key: "addPrefixes",
    value: function addPrefixes(prefixes, done) {
      var prefixIRIs = this._prefixIRIs,
          hasPrefixes = false;

      for (var prefix in prefixes) {
        var iri = prefixes[prefix];
        if (typeof iri !== 'string') iri = iri.value;
        hasPrefixes = true; // Finish a possible pending quad

        if (this._subject !== null) {
          this._write(this._inDefaultGraph ? '.\n' : '\n}\n');

          this._subject = null, this._graph = '';
        } // Store and write the prefix


        prefixIRIs[iri] = prefix += ':';

        this._write('@prefix ' + prefix + ' <' + iri + '>.\n');
      } // Recreate the prefix matcher


      if (hasPrefixes) {
        var IRIlist = '',
            prefixList = '';

        for (var prefixIRI in prefixIRIs) {
          IRIlist += IRIlist ? '|' + prefixIRI : prefixIRI;
          prefixList += (prefixList ? '|' : '') + prefixIRIs[prefixIRI];
        }

        IRIlist = IRIlist.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, '\\$&');
        this._prefixRegex = new RegExp('^(?:' + prefixList + ')[^\/]*$|' + '^(' + IRIlist + ')([a-zA-Z][\\-_a-zA-Z0-9]*)$');
      } // End a prefix block with a newline


      this._write(hasPrefixes ? '\n' : '', done);
    } // ### `blank` creates a blank node with the given content

  }, {
    key: "blank",
    value: function blank(predicate, object) {
      var children = predicate,
          child,
          length; // Empty blank node

      if (predicate === undefined) children = []; // Blank node passed as blank(Term("predicate"), Term("object"))
      else if (predicate.termType) children = [{
          predicate: predicate,
          object: object
        }]; // Blank node passed as blank({ predicate: predicate, object: object })
        else if (!('length' in predicate)) children = [predicate];

      switch (length = children.length) {
        // Generate an empty blank node
        case 0:
          return new SerializedTerm('[]');
        // Generate a non-nested one-triple blank node

        case 1:
          child = children[0];
          if (!(child.object instanceof SerializedTerm)) return new SerializedTerm('[ ' + this._encodePredicate(child.predicate) + ' ' + this._encodeObject(child.object) + ' ]');
        // Generate a multi-triple or nested blank node

        default:
          var contents = '['; // Write all triples in order

          for (var i = 0; i < length; i++) {
            child = children[i]; // Write only the object is the predicate is the same as the previous

            if (child.predicate.equals(predicate)) contents += ', ' + this._encodeObject(child.object); // Otherwise, write the predicate and the object
            else {
                contents += (i ? ';\n  ' : '\n  ') + this._encodePredicate(child.predicate) + ' ' + this._encodeObject(child.object);
                predicate = child.predicate;
              }
          }

          return new SerializedTerm(contents + '\n]');
      }
    } // ### `list` creates a list node with the given content

  }, {
    key: "list",
    value: function list(elements) {
      var length = elements && elements.length || 0,
          contents = new Array(length);

      for (var i = 0; i < length; i++) {
        contents[i] = this._encodeObject(elements[i]);
      }

      return new SerializedTerm('(' + contents.join(' ') + ')');
    } // ### `end` signals the end of the output stream

  }, {
    key: "end",
    value: function end(done) {
      // Finish a possible pending quad
      if (this._subject !== null) {
        this._write(this._inDefaultGraph ? '.\n' : '\n}\n');

        this._subject = null;
      } // Disallow further writing


      this._write = this._blockedWrite; // Try to end the underlying stream, ensuring done is called exactly one time

      var singleDone = done && function (error, result) {
        singleDone = null, done(error, result);
      };

      if (this._endStream) {
        try {
          return this._outputStream.end(singleDone);
        } catch (error) {
          /* error closing stream */
        }
      }

      singleDone && singleDone();
    }
  }, {
    key: "_inDefaultGraph",
    get: function get() {
      return DEFAULTGRAPH.equals(this._graph);
    }
  }]);
  return N3Writer;
}(); // Replaces a character by its escaped version


exports["default"] = N3Writer;

function characterReplacer(character) {
  // Replace a single character by its escaped version
  var result = escapedCharacters[character];

  if (result === undefined) {
    // Replace a single character with its 4-bit unicode escape sequence
    if (character.length === 1) {
      result = character.charCodeAt(0).toString(16);
      result = "\\u0000".substr(0, 6 - result.length) + result;
    } // Replace a surrogate pair with its 8-bit unicode escape sequence
    else {
        result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);
        result = "\\U00000000".substr(0, 10 - result.length) + result;
      }
  }

  return result;
}

},{"./IRIs":126,"./N3DataFactory":127,"./N3Util":133,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"@babel/runtime/helpers/typeof":27}],135:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault2(require("@babel/runtime/helpers/typeof"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Lexer", {
  enumerable: true,
  get: function get() {
    return _N3Lexer["default"];
  }
});
Object.defineProperty(exports, "Parser", {
  enumerable: true,
  get: function get() {
    return _N3Parser["default"];
  }
});
Object.defineProperty(exports, "Writer", {
  enumerable: true,
  get: function get() {
    return _N3Writer["default"];
  }
});
Object.defineProperty(exports, "Store", {
  enumerable: true,
  get: function get() {
    return _N3Store["default"];
  }
});
Object.defineProperty(exports, "StreamParser", {
  enumerable: true,
  get: function get() {
    return _N3StreamParser["default"];
  }
});
Object.defineProperty(exports, "StreamWriter", {
  enumerable: true,
  get: function get() {
    return _N3StreamWriter["default"];
  }
});
Object.defineProperty(exports, "DataFactory", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory["default"];
  }
});
Object.defineProperty(exports, "Term", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Term;
  }
});
Object.defineProperty(exports, "NamedNode", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.NamedNode;
  }
});
Object.defineProperty(exports, "Literal", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Literal;
  }
});
Object.defineProperty(exports, "BlankNode", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.BlankNode;
  }
});
Object.defineProperty(exports, "Variable", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Variable;
  }
});
Object.defineProperty(exports, "DefaultGraph", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.DefaultGraph;
  }
});
Object.defineProperty(exports, "Quad", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Quad;
  }
});
Object.defineProperty(exports, "Triple", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Triple;
  }
});
Object.defineProperty(exports, "termFromId", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.termFromId;
  }
});
Object.defineProperty(exports, "termToId", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.termToId;
  }
});
exports.Util = void 0;

var _N3Lexer = _interopRequireDefault(require("./N3Lexer"));

var _N3Parser = _interopRequireDefault(require("./N3Parser"));

var _N3Writer = _interopRequireDefault(require("./N3Writer"));

var _N3Store = _interopRequireDefault(require("./N3Store"));

var _N3StreamParser = _interopRequireDefault(require("./N3StreamParser"));

var _N3StreamWriter = _interopRequireDefault(require("./N3StreamWriter"));

var Util = _interopRequireWildcard(require("./N3Util"));

exports.Util = Util;

var _N3DataFactory = _interopRequireWildcard(require("./N3DataFactory"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || (0, _typeof2["default"])(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

},{"./N3DataFactory":127,"./N3Lexer":128,"./N3Parser":129,"./N3Store":130,"./N3StreamParser":131,"./N3StreamWriter":132,"./N3Util":133,"./N3Writer":134,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],136:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
var api = {};
module.exports = api; // baseN alphabet indexes

var _reverseAlphabets = {};
/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */

api.encode = function (input, alphabet, maxline) {
  if (typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }

  if (maxline !== undefined && typeof maxline !== 'number') {
    throw new TypeError('"maxline" must be a number.');
  }

  var output = '';

  if (!(input instanceof Uint8Array)) {
    // assume forge byte buffer
    output = _encodeWithByteBuffer(input, alphabet);
  } else {
    var i = 0;
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var digits = [0];

    for (i = 0; i < input.length; ++i) {
      for (var j = 0, carry = input[i]; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base;
        carry = carry / base | 0;
      }

      while (carry > 0) {
        digits.push(carry % base);
        carry = carry / base | 0;
      }
    } // deal with leading zeros


    for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
      output += first;
    } // convert digits to a string


    for (i = digits.length - 1; i >= 0; --i) {
      output += alphabet[digits[i]];
    }
  }

  if (maxline) {
    var regex = new RegExp('.{1,' + maxline + '}', 'g');
    output = output.match(regex).join('\r\n');
  }

  return output;
};
/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */


api.decode = function (input, alphabet) {
  if (typeof input !== 'string') {
    throw new TypeError('"input" must be a string.');
  }

  if (typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }

  var table = _reverseAlphabets[alphabet];

  if (!table) {
    // compute reverse alphabet
    table = _reverseAlphabets[alphabet] = [];

    for (var i = 0; i < alphabet.length; ++i) {
      table[alphabet.charCodeAt(i)] = i;
    }
  } // remove whitespace characters


  input = input.replace(/\s/g, '');
  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var bytes = [0];

  for (var i = 0; i < input.length; i++) {
    var value = table[input.charCodeAt(i)];

    if (value === undefined) {
      return;
    }

    for (var j = 0, carry = value; j < bytes.length; ++j) {
      carry += bytes[j] * base;
      bytes[j] = carry & 0xff;
      carry >>= 8;
    }

    while (carry > 0) {
      bytes.push(carry & 0xff);
      carry >>= 8;
    }
  } // deal with leading zeros


  for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
    bytes.push(0);
  }

  if (typeof Buffer !== 'undefined') {
    return Buffer.from(bytes.reverse());
  }

  return new Uint8Array(bytes.reverse());
};

function _encodeWithByteBuffer(input, alphabet) {
  var i = 0;
  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var digits = [0];

  for (i = 0; i < input.length(); ++i) {
    for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
      carry += digits[j] << 8;
      digits[j] = carry % base;
      carry = carry / base | 0;
    }

    while (carry > 0) {
      digits.push(carry % base);
      carry = carry / base | 0;
    }
  }

  var output = ''; // deal with leading zeros

  for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
    output += first;
  } // convert digits to a string


  for (i = digits.length - 1; i >= 0; --i) {
    output += alphabet[digits[i]];
  }

  return output;
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":58}],137:[function(require,module,exports){
"use strict";

/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */
module.exports = {
  // default options
  options: {
    usePureJavaScript: false
  }
};

},{}],138:[function(require,module,exports){
"use strict";

/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */
var forge = require('./forge');

module.exports = forge.md = forge.md || {};
forge.md.algorithms = forge.md.algorithms || {};

},{"./forge":137}],139:[function(require,module,exports){
"use strict";

/**
 * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./md');

require('./util');

var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
/**
 * Creates a SHA-1 message digest object.
 *
 * @return a message digest object.
 */

sha1.create = function () {
  // do initialization as necessary
  if (!_initialized) {
    _init();
  } // SHA-1 state contains five 32-bit integers


  var _state = null; // input buffer

  var _input = forge.util.createBuffer(); // used for word storage


  var _w = new Array(80); // message digest object


  var md = {
    algorithm: 'sha1',
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  /**
   * Starts the digest.
   *
   * @return this digest object.
   */

  md.start = function () {
    // up to 56-bit message length for convenience
    md.messageLength = 0; // full message length (set md.messageLength64 for backwards-compatibility)

    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;

    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }

    _input = forge.util.createBuffer();
    _state = {
      h0: 0x67452301,
      h1: 0xEFCDAB89,
      h2: 0x98BADCFE,
      h3: 0x10325476,
      h4: 0xC3D2E1F0
    };
    return md;
  }; // start digest automatically for first time


  md.start();
  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */

  md.update = function (msg, encoding) {
    if (encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    } // update message length


    var len = msg.length;
    md.messageLength += len;
    len = [len / 0x100000000 >>> 0, len >>> 0];

    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 0x100000000 >>> 0;
    } // add bytes to input buffer


    _input.putBytes(msg); // process bytes


    _update(_state, _w, _input); // compact input buffer every 2K or if empty


    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };
  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */


  md.digest = function () {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.
     In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */
    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes()); // compute remaining size to be digested (include message length size)

    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes

    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int

    var next, carry;
    var bits = md.fullMessageLength[0] * 8;

    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 0x100000000 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }

    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4
    };

    _update(s2, _w, finalBlock);

    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };

  return md;
}; // sha-1 padding bytes not initialized yet


var _padding = null;
var _initialized = false;
/**
 * Initializes the constant tables.
 */

function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64); // now initialized

  _initialized = true;
}
/**
 * Updates a SHA-1 state with the given byte buffer.
 *
 * @param s the SHA-1 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */


function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t, a, b, c, d, e, f, i;
  var len = bytes.length();

  while (len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 80 32-bit words according to SHA-1 algorithm
    // and for 32-79 using Max Locktyukhin's optimization
    // initialize hash value for this chunk
    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4; // round 1

    for (i = 0; i < 16; ++i) {
      t = bytes.getInt32();
      w[i] = t;
      f = d ^ b & (c ^ d);
      t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    }

    for (; i < 20; ++i) {
      t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      t = t << 1 | t >>> 31;
      w[i] = t;
      f = d ^ b & (c ^ d);
      t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // round 2


    for (; i < 32; ++i) {
      t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      t = t << 1 | t >>> 31;
      w[i] = t;
      f = b ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    }

    for (; i < 40; ++i) {
      t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
      t = t << 2 | t >>> 30;
      w[i] = t;
      f = b ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // round 3


    for (; i < 60; ++i) {
      t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
      t = t << 2 | t >>> 30;
      w[i] = t;
      f = b & c | d & (b ^ c);
      t = (a << 5 | a >>> 27) + f + e + 0x8F1BBCDC + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // round 4


    for (; i < 80; ++i) {
      t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
      t = t << 2 | t >>> 30;
      w[i] = t;
      f = b ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 0xCA62C1D6 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // update hash state


    s.h0 = s.h0 + a | 0;
    s.h1 = s.h1 + b | 0;
    s.h2 = s.h2 + c | 0;
    s.h3 = s.h3 + d | 0;
    s.h4 = s.h4 + e | 0;
    len -= 64;
  }
}

},{"./forge":137,"./md":138,"./util":141}],140:[function(require,module,exports){
"use strict";

/**
 * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
 *
 * See FIPS 180-2 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./md');

require('./util');

var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
/**
 * Creates a SHA-256 message digest object.
 *
 * @return a message digest object.
 */

sha256.create = function () {
  // do initialization as necessary
  if (!_initialized) {
    _init();
  } // SHA-256 state contains eight 32-bit integers


  var _state = null; // input buffer

  var _input = forge.util.createBuffer(); // used for word storage


  var _w = new Array(64); // message digest object


  var md = {
    algorithm: 'sha256',
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  /**
   * Starts the digest.
   *
   * @return this digest object.
   */

  md.start = function () {
    // up to 56-bit message length for convenience
    md.messageLength = 0; // full message length (set md.messageLength64 for backwards-compatibility)

    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;

    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }

    _input = forge.util.createBuffer();
    _state = {
      h0: 0x6A09E667,
      h1: 0xBB67AE85,
      h2: 0x3C6EF372,
      h3: 0xA54FF53A,
      h4: 0x510E527F,
      h5: 0x9B05688C,
      h6: 0x1F83D9AB,
      h7: 0x5BE0CD19
    };
    return md;
  }; // start digest automatically for first time


  md.start();
  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */

  md.update = function (msg, encoding) {
    if (encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    } // update message length


    var len = msg.length;
    md.messageLength += len;
    len = [len / 0x100000000 >>> 0, len >>> 0];

    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 0x100000000 >>> 0;
    } // add bytes to input buffer


    _input.putBytes(msg); // process bytes


    _update(_state, _w, _input); // compact input buffer every 2K or if empty


    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };
  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */


  md.digest = function () {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.
     In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */
    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes()); // compute remaining size to be digested (include message length size)

    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes

    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int

    var next, carry;
    var bits = md.fullMessageLength[0] * 8;

    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 0x100000000 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }

    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4,
      h5: _state.h5,
      h6: _state.h6,
      h7: _state.h7
    };

    _update(s2, _w, finalBlock);

    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };

  return md;
}; // sha-256 padding bytes not initialized yet


var _padding = null;
var _initialized = false; // table of constants

var _k = null;
/**
 * Initializes the constant tables.
 */

function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64); // create K table for SHA-256

  _k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; // now initialized

  _initialized = true;
}
/**
 * Updates a SHA-256 state with the given byte buffer.
 *
 * @param s the SHA-256 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */


function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
  var len = bytes.length();

  while (len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 64 32-bit words according to SHA-256
    for (i = 0; i < 16; ++i) {
      w[i] = bytes.getInt32();
    }

    for (; i < 64; ++i) {
      // XOR word 2 words ago rot right 17, rot right 19, shft right 10
      t1 = w[i - 2];
      t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10; // XOR word 15 words ago rot right 7, rot right 18, shft right 3

      t2 = w[i - 15];
      t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3; // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32

      w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
    } // initialize hash value for this chunk


    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4;
    f = s.h5;
    g = s.h6;
    h = s.h7; // round function

    for (i = 0; i < 64; ++i) {
      // Sum1(e)
      s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7); // Ch(e, f, g) (optimized the same way as SHA-1)

      ch = g ^ e & (f ^ g); // Sum0(a)

      s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10); // Maj(a, b, c) (optimized the same way as SHA-1)

      maj = a & b | c & (a ^ b); // main algorithm

      t1 = h + s1 + ch + _k[i] + w[i];
      t2 = s0 + maj;
      h = g;
      g = f;
      f = e; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`

      e = d + t1 >>> 0;
      d = c;
      c = b;
      b = a; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`

      a = t1 + t2 >>> 0;
    } // update hash state


    s.h0 = s.h0 + a | 0;
    s.h1 = s.h1 + b | 0;
    s.h2 = s.h2 + c | 0;
    s.h3 = s.h3 + d | 0;
    s.h4 = s.h4 + e | 0;
    s.h5 = s.h5 + f | 0;
    s.h6 = s.h6 + g | 0;
    s.h7 = s.h7 + h | 0;
    len -= 64;
  }
}

},{"./forge":137,"./md":138,"./util":141}],141:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */
var forge = require('./forge');

var baseN = require('./baseN');
/* Utilities API */


var util = module.exports = forge.util = forge.util || {}; // define setImmediate and nextTick

(function () {
  // use native nextTick (unless we're in webpack)
  // webpack (or better node-libs-browser polyfill) sets process.browser.
  // this way we can detect webpack properly
  if (typeof process !== 'undefined' && process.nextTick && !process.browser) {
    util.nextTick = process.nextTick;

    if (typeof setImmediate === 'function') {
      util.setImmediate = setImmediate;
    } else {
      // polyfill setImmediate with nextTick, older versions of node
      // (those w/o setImmediate) won't totally starve IO
      util.setImmediate = util.nextTick;
    }

    return;
  } // polyfill nextTick with native setImmediate


  if (typeof setImmediate === 'function') {
    util.setImmediate = function () {
      return setImmediate.apply(undefined, arguments);
    };

    util.nextTick = function (callback) {
      return setImmediate(callback);
    };

    return;
  }
  /* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */
  // polyfill with setTimeout


  util.setImmediate = function (callback) {
    setTimeout(callback, 0);
  }; // upgrade polyfill to use postMessage


  if (typeof window !== 'undefined' && typeof window.postMessage === 'function') {
    var handler = function handler(event) {
      if (event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function (callback) {
          callback();
        });
      }
    };

    var msg = 'forge.setImmediate';
    var callbacks = [];

    util.setImmediate = function (callback) {
      callbacks.push(callback); // only send message when one hasn't been sent in
      // the current turn of the event loop

      if (callbacks.length === 1) {
        window.postMessage(msg, '*');
      }
    };

    window.addEventListener('message', handler, true);
  } // upgrade polyfill to use MutationObserver


  if (typeof MutationObserver !== 'undefined') {
    // polyfill with MutationObserver
    var now = Date.now();
    var attr = true;
    var div = document.createElement('div');
    var callbacks = [];
    new MutationObserver(function () {
      var copy = callbacks.slice();
      callbacks.length = 0;
      copy.forEach(function (callback) {
        callback();
      });
    }).observe(div, {
      attributes: true
    });
    var oldSetImmediate = util.setImmediate;

    util.setImmediate = function (callback) {
      if (Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback); // only trigger observer when it hasn't been triggered in
        // the current turn of the event loop

        if (callbacks.length === 1) {
          div.setAttribute('a', attr = !attr);
        }
      }
    };
  }

  util.nextTick = util.setImmediate;
})(); // check if running under Node.js


util.isNodejs = typeof process !== 'undefined' && process.versions && process.versions.node; // 'self' will also work in Web Workers (instance of WorkerGlobalScope) while
// it will point to `window` in the main thread.
// To remain compatible with older browsers, we fall back to 'window' if 'self'
// is not available.

util.globalScope = function () {
  if (util.isNodejs) {
    return global;
  }

  return typeof self === 'undefined' ? window : self;
}(); // define isArray


util.isArray = Array.isArray || function (x) {
  return Object.prototype.toString.call(x) === '[object Array]';
}; // define isArrayBuffer


util.isArrayBuffer = function (x) {
  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;
}; // define isArrayBufferView


util.isArrayBufferView = function (x) {
  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
};
/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */


function _checkBitsParam(n) {
  if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);
  }
} // TODO: set ByteBuffer to best available backing


util.ByteBuffer = ByteStringBuffer;
/** Buffer w/BinaryString backing */

/**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */

function ByteStringBuffer(b) {
  // TODO: update to match DataBuffer API
  // the data in this buffer
  this.data = ''; // the pointer for reading from this buffer

  this.read = 0;

  if (typeof b === 'string') {
    this.data = b;
  } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
    if (typeof Buffer !== 'undefined' && b instanceof Buffer) {
      this.data = b.toString('binary');
    } else {
      // convert native buffer to forge buffer
      // FIXME: support native buffers internally instead
      var arr = new Uint8Array(b);

      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch (e) {
        for (var i = 0; i < arr.length; ++i) {
          this.putByte(arr[i]);
        }
      }
    }
  } else if (b instanceof ByteStringBuffer || (0, _typeof2["default"])(b) === 'object' && typeof b.data === 'string' && typeof b.read === 'number') {
    // copy existing buffer
    this.data = b.data;
    this.read = b.read;
  } // used for v8 optimization


  this._constructedStringLength = 0;
}

util.ByteStringBuffer = ByteStringBuffer;
/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */

var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;

util.ByteStringBuffer.prototype._optimizeConstructedString = function (x) {
  this._constructedStringLength += x;

  if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
    // this substr() should cause the constructed string to join
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};
/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */


util.ByteStringBuffer.prototype.length = function () {
  return this.data.length - this.read;
};
/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */


util.ByteStringBuffer.prototype.isEmpty = function () {
  return this.length() <= 0;
};
/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putByte = function (b) {
  return this.putBytes(String.fromCharCode(b));
};
/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.fillWithByte = function (b, n) {
  b = String.fromCharCode(b);
  var d = this.data;

  while (n > 0) {
    if (n & 1) {
      d += b;
    }

    n >>>= 1;

    if (n > 0) {
      b += b;
    }
  }

  this.data = d;

  this._optimizeConstructedString(n);

  return this;
};
/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a binary encoded string) to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putBytes = function (bytes) {
  this.data += bytes;

  this._optimizeConstructedString(bytes.length);

  return this;
};
/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putString = function (str) {
  return this.putBytes(util.encodeUtf8(str));
};
/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt16 = function (i) {
  return this.putBytes(String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt24 = function (i) {
  return this.putBytes(String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt32 = function (i) {
  return this.putBytes(String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt16Le = function (i) {
  return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF));
};
/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt24Le = function (i) {
  return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF));
};
/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt32Le = function (i) {
  return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 24 & 0xFF));
};
/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt = function (i, n) {
  _checkBitsParam(n);

  var bytes = '';

  do {
    n -= 8;
    bytes += String.fromCharCode(i >> n & 0xFF);
  } while (n > 0);

  return this.putBytes(bytes);
};
/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putSignedInt = function (i, n) {
  // putInt checks n
  if (i < 0) {
    i += 2 << n - 1;
  }

  return this.putInt(i, n);
};
/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putBuffer = function (buffer) {
  return this.putBytes(buffer.getBytes());
};
/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */


util.ByteStringBuffer.prototype.getByte = function () {
  return this.data.charCodeAt(this.read++);
};
/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.ByteStringBuffer.prototype.getInt16 = function () {
  var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.ByteStringBuffer.prototype.getInt24 = function () {
  var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.ByteStringBuffer.prototype.getInt32 = function () {
  var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  this.read += 4;
  return rval;
};
/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.ByteStringBuffer.prototype.getInt16Le = function () {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.ByteStringBuffer.prototype.getInt24Le = function () {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.ByteStringBuffer.prototype.getInt32Le = function () {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  this.read += 4;
  return rval;
};
/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.ByteStringBuffer.prototype.getInt = function (n) {
  _checkBitsParam(n);

  var rval = 0;

  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n -= 8;
  } while (n > 0);

  return rval;
};
/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.ByteStringBuffer.prototype.getSignedInt = function (n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << n - 2;

  if (x >= max) {
    x -= max << 1;
  }

  return x;
};
/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer. Note that the resulting string is binary encoded (in node.js this
 * encoding is referred to as `binary`, it is *not* `utf8`).
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */


util.ByteStringBuffer.prototype.getBytes = function (count) {
  var rval;

  if (count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }

  return rval;
};
/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */


util.ByteStringBuffer.prototype.bytes = function (count) {
  return typeof count === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */


util.ByteStringBuffer.prototype.at = function (i) {
  return this.data.charCodeAt(this.read + i);
};
/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.setAt = function (i, b) {
  this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
  return this;
};
/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */


util.ByteStringBuffer.prototype.last = function () {
  return this.data.charCodeAt(this.data.length - 1);
};
/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */


util.ByteStringBuffer.prototype.copy = function () {
  var c = util.createBuffer(this.data);
  c.read = this.read;
  return c;
};
/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.compact = function () {
  if (this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }

  return this;
};
/**
 * Clears this buffer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.clear = function () {
  this.data = '';
  this.read = 0;
  return this;
};
/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.truncate = function (count) {
  var len = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len);
  this.read = 0;
  return this;
};
/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */


util.ByteStringBuffer.prototype.toHex = function () {
  var rval = '';

  for (var i = this.read; i < this.data.length; ++i) {
    var b = this.data.charCodeAt(i);

    if (b < 16) {
      rval += '0';
    }

    rval += b.toString(16);
  }

  return rval;
};
/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */


util.ByteStringBuffer.prototype.toString = function () {
  return util.decodeUtf8(this.bytes());
};
/** End Buffer w/BinaryString backing */

/** Buffer w/UInt8Array backing */

/**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */


function DataBuffer(b, options) {
  // default options
  options = options || {}; // pointers for read from/write to buffer

  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;
  var isArrayBuffer = util.isArrayBuffer(b);
  var isArrayBufferView = util.isArrayBufferView(b);

  if (isArrayBuffer || isArrayBufferView) {
    // use ArrayBuffer directly
    if (isArrayBuffer) {
      this.data = new DataView(b);
    } else {
      // TODO: adjust read/write offset based on the type of view
      // or specify that this must be done in the options ... that the
      // offsets are byte-based
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }

    this.write = 'writeOffset' in options ? options.writeOffset : this.data.byteLength;
    return;
  } // initialize to empty array buffer and add any given bytes using putBytes


  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;

  if (b !== null && b !== undefined) {
    this.putBytes(b);
  }

  if ('writeOffset' in options) {
    this.write = options.writeOffset;
  }
}

util.DataBuffer = DataBuffer;
/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */

util.DataBuffer.prototype.length = function () {
  return this.write - this.read;
};
/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */


util.DataBuffer.prototype.isEmpty = function () {
  return this.length() <= 0;
};
/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */


util.DataBuffer.prototype.accommodate = function (amount, growSize) {
  if (this.length() >= amount) {
    return this;
  }

  growSize = Math.max(growSize || this.growSize, amount); // grow buffer

  var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src);
  this.data = new DataView(dst.buffer);
  return this;
};
/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putByte = function (b) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b);
  return this;
};
/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.fillWithByte = function (b, n) {
  this.accommodate(n);

  for (var i = 0; i < n; ++i) {
    this.data.setUint8(b);
  }

  return this;
};
/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putBytes = function (bytes, encoding) {
  if (util.isArrayBufferView(bytes)) {
    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var len = src.byteLength - src.byteOffset;
    this.accommodate(len);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src);
    this.write += len;
    return this;
  }

  if (util.isArrayBuffer(bytes)) {
    var src = new Uint8Array(bytes);
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src, this.write);
    this.write += src.byteLength;
    return this;
  } // bytes is a util.DataBuffer or equivalent


  if (bytes instanceof util.DataBuffer || (0, _typeof2["default"])(bytes) === 'object' && typeof bytes.read === 'number' && typeof bytes.write === 'number' && util.isArrayBufferView(bytes.data)) {
    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(bytes.data.byteLength, this.write);
    dst.set(src);
    this.write += src.byteLength;
    return this;
  }

  if (bytes instanceof util.ByteStringBuffer) {
    // copy binary string and process as the same as a string parameter below
    bytes = bytes.data;
    encoding = 'binary';
  } // string conversion


  encoding = encoding || 'binary';

  if (typeof bytes === 'string') {
    var view; // decode from string

    if (encoding === 'hex') {
      this.accommodate(Math.ceil(bytes.length / 2));
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.hex.decode(bytes, view, this.write);
      return this;
    }

    if (encoding === 'base64') {
      this.accommodate(Math.ceil(bytes.length / 4) * 3);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.base64.decode(bytes, view, this.write);
      return this;
    } // encode text as UTF-8 bytes


    if (encoding === 'utf8') {
      // encode as UTF-8 then decode string as raw binary
      bytes = util.encodeUtf8(bytes);
      encoding = 'binary';
    } // decode string as raw binary


    if (encoding === 'binary' || encoding === 'raw') {
      // one byte per character
      this.accommodate(bytes.length);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.raw.decode(view);
      return this;
    } // encode text as UTF-16 bytes


    if (encoding === 'utf16') {
      // two bytes per character
      this.accommodate(bytes.length * 2);
      view = new Uint16Array(this.data.buffer, this.write);
      this.write += util.text.utf16.encode(view);
      return this;
    }

    throw new Error('Invalid encoding: ' + encoding);
  }

  throw Error('Invalid parameter: ' + bytes);
};
/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putBuffer = function (buffer) {
  this.putBytes(buffer);
  buffer.clear();
  return this;
};
/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putString = function (str) {
  return this.putBytes(str, 'utf16');
};
/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt16 = function (i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i);
  this.write += 2;
  return this;
};
/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt24 = function (i) {
  this.accommodate(3);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.write += 3;
  return this;
};
/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt32 = function (i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i);
  this.write += 4;
  return this;
};
/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt16Le = function (i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i, true);
  this.write += 2;
  return this;
};
/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt24Le = function (i) {
  this.accommodate(3);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
  this.write += 3;
  return this;
};
/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt32Le = function (i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i, true);
  this.write += 4;
  return this;
};
/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt = function (i, n) {
  _checkBitsParam(n);

  this.accommodate(n / 8);

  do {
    n -= 8;
    this.data.setInt8(this.write++, i >> n & 0xFF);
  } while (n > 0);

  return this;
};
/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putSignedInt = function (i, n) {
  _checkBitsParam(n);

  this.accommodate(n / 8);

  if (i < 0) {
    i += 2 << n - 1;
  }

  return this.putInt(i, n);
};
/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */


util.DataBuffer.prototype.getByte = function () {
  return this.data.getInt8(this.read++);
};
/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.DataBuffer.prototype.getInt16 = function () {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.DataBuffer.prototype.getInt24 = function () {
  var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.DataBuffer.prototype.getInt32 = function () {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};
/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.DataBuffer.prototype.getInt16Le = function () {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.DataBuffer.prototype.getInt24Le = function () {
  var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.DataBuffer.prototype.getInt32Le = function () {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};
/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.DataBuffer.prototype.getInt = function (n) {
  _checkBitsParam(n);

  var rval = 0;

  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n -= 8;
  } while (n > 0);

  return rval;
};
/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.DataBuffer.prototype.getSignedInt = function (n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << n - 2;

  if (x >= max) {
    x -= max << 1;
  }

  return x;
};
/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */


util.DataBuffer.prototype.getBytes = function (count) {
  // TODO: deprecate this method, it is poorly named and
  // this.toString('binary') replaces it
  // add a toTypedArray()/toArrayBuffer() function
  var rval;

  if (count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }

  return rval;
};
/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */


util.DataBuffer.prototype.bytes = function (count) {
  // TODO: deprecate this method, it is poorly named, add "getString()"
  return typeof count === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */


util.DataBuffer.prototype.at = function (i) {
  return this.data.getUint8(this.read + i);
};
/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.setAt = function (i, b) {
  this.data.setUint8(i, b);
  return this;
};
/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */


util.DataBuffer.prototype.last = function () {
  return this.data.getUint8(this.write - 1);
};
/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */


util.DataBuffer.prototype.copy = function () {
  return new util.DataBuffer(this);
};
/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.compact = function () {
  if (this.read > 0) {
    var src = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src.byteLength);
    dst.set(src);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }

  return this;
};
/**
 * Clears this buffer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.clear = function () {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};
/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.truncate = function (count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};
/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */


util.DataBuffer.prototype.toHex = function () {
  var rval = '';

  for (var i = this.read; i < this.data.byteLength; ++i) {
    var b = this.data.getUint8(i);

    if (b < 16) {
      rval += '0';
    }

    rval += b.toString(16);
  }

  return rval;
};
/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */


util.DataBuffer.prototype.toString = function (encoding) {
  var view = new Uint8Array(this.data, this.read, this.length());
  encoding = encoding || 'utf8'; // encode to string

  if (encoding === 'binary' || encoding === 'raw') {
    return util.binary.raw.encode(view);
  }

  if (encoding === 'hex') {
    return util.binary.hex.encode(view);
  }

  if (encoding === 'base64') {
    return util.binary.base64.encode(view);
  } // decode to text


  if (encoding === 'utf8') {
    return util.text.utf8.decode(view);
  }

  if (encoding === 'utf16') {
    return util.text.utf16.decode(view);
  }

  throw new Error('Invalid encoding: ' + encoding);
};
/** End Buffer w/UInt8Array backing */

/**
 * Creates a buffer that stores bytes. A value may be given to populate the
 * buffer with data. This value can either be string of encoded bytes or a
 * regular string of characters. When passing a string of binary encoded
 * bytes, the encoding `raw` should be given. This is also the default. When
 * passing a string of characters, the encoding `utf8` should be given.
 *
 * @param [input] a string with encoded bytes to store in the buffer.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */


util.createBuffer = function (input, encoding) {
  // TODO: deprecate, use new ByteBuffer() instead
  encoding = encoding || 'raw';

  if (input !== undefined && encoding === 'utf8') {
    input = util.encodeUtf8(input);
  }

  return new util.ByteBuffer(input);
};
/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */


util.fillString = function (c, n) {
  var s = '';

  while (n > 0) {
    if (n & 1) {
      s += c;
    }

    n >>>= 1;

    if (n > 0) {
      c += c;
    }
  }

  return s;
};
/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */


util.xorBytes = function (s1, s2, n) {
  var s3 = '';
  var b = '';
  var t = '';
  var i = 0;
  var c = 0;

  for (; n > 0; --n, ++i) {
    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);

    if (c >= 10) {
      s3 += t;
      t = '';
      c = 0;
    }

    t += String.fromCharCode(b);
    ++c;
  }

  s3 += t;
  return s3;
};
/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */


util.hexToBytes = function (hex) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
  var rval = '';
  var i = 0;

  if (hex.length & 1 == 1) {
    // odd number of characters, convert first character alone
    i = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  } // convert 2 characters (1 byte) at a time


  for (; i < hex.length; i += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }

  return rval;
};
/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */


util.bytesToHex = function (bytes) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
  return util.createBuffer(bytes).toHex();
};
/**
 * Converts an 32-bit integer to 4-big-endian byte string.
 *
 * @param i the integer.
 *
 * @return the byte string.
 */


util.int32ToBytes = function (i) {
  return String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF);
}; // base64 characters, reverse mapping


var _base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var _base64Idx = [
/*43 -43 = 0*/

/*'+',  1,  2,  3,'/' */
62, -1, -1, -1, 63,
/*'0','1','2','3','4','5','6','7','8','9' */
52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
/*15, 16, 17,'=', 19, 20, 21 */
-1, -1, -1, 64, -1, -1, -1,
/*65 - 43 = 22*/

/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
/*91 - 43 = 48 */

/*48, 49, 50, 51, 52, 53 */
-1, -1, -1, -1, -1, -1,
/*97 - 43 = 54*/

/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51]; // base58 characters (Bitcoin alphabet)

var _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
/**
 * Base64 encodes a 'binary' encoded string of bytes.
 *
 * @param input the binary encoded string of bytes to base64-encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output.
 */

util.encode64 = function (input, maxline) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;

  while (i < input.length) {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++); // encode 4 character group

    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);

    if (isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }

  output += line;
  return output;
};
/**
 * Base64 decodes a string into a 'binary' encoded string of bytes.
 *
 * @param input the base64-encoded input.
 *
 * @return the binary encoded string.
 */


util.decode64 = function (input) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."
  // remove all non-base64 characters
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  var output = '';
  var enc1, enc2, enc3, enc4;
  var i = 0;

  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    output += String.fromCharCode(enc1 << 2 | enc2 >> 4);

    if (enc3 !== 64) {
      // decoded at least 2 bytes
      output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);

      if (enc4 !== 64) {
        // decoded 3 bytes
        output += String.fromCharCode((enc3 & 3) << 6 | enc4);
      }
    }
  }

  return output;
};
/**
 * Encodes the given string of characters (a standard JavaScript
 * string) as a binary encoded string where the bytes represent
 * a UTF-8 encoded string of characters. Non-ASCII characters will be
 * encoded as multiple bytes according to UTF-8.
 *
 * @param str a standard string of characters to encode.
 *
 * @return the binary encoded string.
 */


util.encodeUtf8 = function (str) {
  return unescape(encodeURIComponent(str));
};
/**
 * Decodes a binary encoded string that contains bytes that
 * represent a UTF-8 encoded string of characters -- into a
 * string of characters (a standard JavaScript string).
 *
 * @param str the binary encoded string to decode.
 *
 * @return the resulting standard string of characters.
 */


util.decodeUtf8 = function (str) {
  return decodeURIComponent(escape(str));
}; // binary encoding/decoding tools
// FIXME: Experimental. Do not use yet.


util.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: baseN.encode,
    decode: baseN.decode
  }
};
/**
 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param bytes the Uint8Array to encode.
 *
 * @return the binary-encoded string.
 */

util.binary.raw.encode = function (bytes) {
  return String.fromCharCode.apply(null, bytes);
};
/**
 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param str the binary-encoded string to decode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */


util.binary.raw.decode = function (str, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(str.length);
  }

  offset = offset || 0;
  var j = offset;

  for (var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }

  return output ? j - offset : out;
};
/**
 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
 * ByteBuffer as a string of hexadecimal characters.
 *
 * @param bytes the bytes to convert.
 *
 * @return the string of hexadecimal characters.
 */


util.binary.hex.encode = util.bytesToHex;
/**
 * Decodes a hex-encoded string to a Uint8Array.
 *
 * @param hex the hexadecimal string to convert.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */

util.binary.hex.decode = function (hex, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }

  offset = offset || 0;
  var i = 0,
      j = offset;

  if (hex.length & 1) {
    // odd number of characters, convert first character alone
    i = 1;
    out[j++] = parseInt(hex[0], 16);
  } // convert 2 characters (1 byte) at a time


  for (; i < hex.length; i += 2) {
    out[j++] = parseInt(hex.substr(i, 2), 16);
  }

  return output ? j - offset : out;
};
/**
 * Base64-encodes a Uint8Array.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output string.
 */


util.binary.base64.encode = function (input, maxline) {
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;

  while (i < input.byteLength) {
    chr1 = input[i++];
    chr2 = input[i++];
    chr3 = input[i++]; // encode 4 character group

    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);

    if (isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }

  output += line;
  return output;
};
/**
 * Decodes a base64-encoded string to a Uint8Array.
 *
 * @param input the base64-encoded input string.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */


util.binary.base64.decode = function (input, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  } // remove all non-base64 characters


  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i = 0,
      j = offset;

  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    out[j++] = enc1 << 2 | enc2 >> 4;

    if (enc3 !== 64) {
      // decoded at least 2 bytes
      out[j++] = (enc2 & 15) << 4 | enc3 >> 2;

      if (enc4 !== 64) {
        // decoded 3 bytes
        out[j++] = (enc3 & 3) << 6 | enc4;
      }
    }
  } // make sure result is the exact decoded length


  return output ? j - offset : out.subarray(0, j);
}; // add support for base58 encoding/decoding with Bitcoin alphabet


util.binary.base58.encode = function (input, maxline) {
  return util.binary.baseN.encode(input, _base58, maxline);
};

util.binary.base58.decode = function (input, maxline) {
  return util.binary.baseN.decode(input, _base58, maxline);
}; // text encoding/decoding tools
// FIXME: Experimental. Do not use yet.


util.text = {
  utf8: {},
  utf16: {}
};
/**
 * Encodes the given string as UTF-8 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */

util.text.utf8.encode = function (str, output, offset) {
  str = util.encodeUtf8(str);
  var out = output;

  if (!out) {
    out = new Uint8Array(str.length);
  }

  offset = offset || 0;
  var j = offset;

  for (var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }

  return output ? j - offset : out;
};
/**
 * Decodes the UTF-8 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */


util.text.utf8.decode = function (bytes) {
  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
};
/**
 * Encodes the given string as UTF-16 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */


util.text.utf16.encode = function (str, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(str.length * 2);
  }

  var view = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j = offset;
  var k = offset;

  for (var i = 0; i < str.length; ++i) {
    view[k++] = str.charCodeAt(i);
    j += 2;
  }

  return output ? j - offset : out;
};
/**
 * Decodes the UTF-16 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */


util.text.utf16.decode = function (bytes) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
};
/**
 * Deflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true to return only raw deflate data, false to include zlib
 *          header and trailer.
 *
 * @return the deflated data as a string.
 */


util.deflate = function (api, bytes, raw) {
  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval); // strip zlib header and trailer if necessary

  if (raw) {
    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that
    // there is a 4-byte DICT (alder-32) block before the data if
    // its 5th bit is set
    var start = 2;
    var flg = bytes.charCodeAt(1);

    if (flg & 0x20) {
      start = 6;
    } // zlib trailer is 4 bytes of adler-32


    bytes = bytes.substring(start, bytes.length - 4);
  }

  return bytes;
};
/**
 * Inflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true if the incoming data has no zlib header or trailer and is
 *          raw DEFLATE data.
 *
 * @return the inflated data as a string, null on error.
 */


util.inflate = function (api, bytes, raw) {
  // TODO: add zlib header and trailer if necessary/possible
  var rval = api.inflate(util.encode64(bytes)).rval;
  return rval === null ? null : util.decode64(rval);
};
/**
 * Sets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param obj the storage object, null to remove.
 */


var _setStorageObject = function _setStorageObject(api, id, obj) {
  if (!api) {
    throw new Error('WebStorage not available.');
  }

  var rval;

  if (obj === null) {
    rval = api.removeItem(id);
  } else {
    // json-encode and base64-encode object
    obj = util.encode64(JSON.stringify(obj));
    rval = api.setItem(id, obj);
  } // handle potential flash error


  if (typeof rval !== 'undefined' && rval.rval !== true) {
    var error = new Error(rval.error.message);
    error.id = rval.error.id;
    error.name = rval.error.name;
    throw error;
  }
};
/**
 * Gets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 *
 * @return the storage object entry or null if none exists.
 */


var _getStorageObject = function _getStorageObject(api, id) {
  if (!api) {
    throw new Error('WebStorage not available.');
  } // get the existing entry


  var rval = api.getItem(id);
  /* Note: We check api.init because we can't do (api == localStorage)
    on IE because of "Class doesn't support Automation" exception. Only
    the flash api has an init method so this works too, but we need a
    better solution in the future. */
  // flash returns item wrapped in an object, handle special case

  if (api.init) {
    if (rval.rval === null) {
      if (rval.error) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      } // no error, but also no item


      rval = null;
    } else {
      rval = rval.rval;
    }
  } // handle decoding


  if (rval !== null) {
    // base64-decode and json-decode data
    rval = JSON.parse(util.decode64(rval));
  }

  return rval;
};
/**
 * Stores an item in local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 */


var _setItem = function _setItem(api, id, key, data) {
  // get storage object
  var obj = _getStorageObject(api, id);

  if (obj === null) {
    // create a new storage object
    obj = {};
  } // update key


  obj[key] = data; // set storage object

  _setStorageObject(api, id, obj);
};
/**
 * Gets an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 *
 * @return the item.
 */


var _getItem = function _getItem(api, id, key) {
  // get storage object
  var rval = _getStorageObject(api, id);

  if (rval !== null) {
    // return data at key
    rval = key in rval ? rval[key] : null;
  }

  return rval;
};
/**
 * Removes an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 */


var _removeItem = function _removeItem(api, id, key) {
  // get storage object
  var obj = _getStorageObject(api, id);

  if (obj !== null && key in obj) {
    // remove key
    delete obj[key]; // see if entry has no keys remaining

    var empty = true;

    for (var prop in obj) {
      empty = false;
      break;
    }

    if (empty) {
      // remove entry entirely if no keys are left
      obj = null;
    } // set storage object


    _setStorageObject(api, id, obj);
  }
};
/**
 * Clears the local disk storage identified by the given ID.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 */


var _clearItems = function _clearItems(api, id) {
  _setStorageObject(api, id, null);
};
/**
 * Calls a storage function.
 *
 * @param func the function to call.
 * @param args the arguments for the function.
 * @param location the location argument.
 *
 * @return the return value from the function.
 */


var _callStorageFunction = function _callStorageFunction(func, args, location) {
  var rval = null; // default storage types

  if (typeof location === 'undefined') {
    location = ['web', 'flash'];
  } // apply storage types in order of preference


  var type;
  var done = false;
  var exception = null;

  for (var idx in location) {
    type = location[idx];

    try {
      if (type === 'flash' || type === 'both') {
        if (args[0] === null) {
          throw new Error('Flash local storage not available.');
        }

        rval = func.apply(this, args);
        done = type === 'flash';
      }

      if (type === 'web' || type === 'both') {
        args[0] = localStorage;
        rval = func.apply(this, args);
        done = true;
      }
    } catch (ex) {
      exception = ex;
    }

    if (done) {
      break;
    }
  }

  if (!done) {
    throw exception;
  }

  return rval;
};
/**
 * Stores an item on local disk.
 *
 * The available types of local storage include 'flash', 'web', and 'both'.
 *
 * The type 'flash' refers to flash local storage (SharedObject). In order
 * to use flash local storage, the 'api' parameter must be valid. The type
 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
 * refers to storing using both 'flash' and 'web', not just one or the
 * other.
 *
 * The location array should list the storage types to use in order of
 * preference:
 *
 * ['flash']: flash only storage
 * ['web']: web only storage
 * ['both']: try to store in both
 * ['flash','web']: store in flash first, but if not available, 'web'
 * ['web','flash']: store in web first, but if not available, 'flash'
 *
 * The location array defaults to: ['web', 'flash']
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 * @param location an array with the preferred types of storage to use.
 */


util.setItem = function (api, id, key, data, location) {
  _callStorageFunction(_setItem, arguments, location);
};
/**
 * Gets an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 *
 * @return the item.
 */


util.getItem = function (api, id, key, location) {
  return _callStorageFunction(_getItem, arguments, location);
};
/**
 * Removes an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 */


util.removeItem = function (api, id, key, location) {
  _callStorageFunction(_removeItem, arguments, location);
};
/**
 * Clears the local disk storage identified by the given ID.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface if flash is available.
 * @param id the storage ID to use.
 * @param location an array with the preferred types of storage to use.
 */


util.clearItems = function (api, id, location) {
  _callStorageFunction(_clearItems, arguments, location);
};
/**
 * Parses the scheme, host, and port from an http(s) url.
 *
 * @param str the url string.
 *
 * @return the parsed url object or null if the url is invalid.
 */


util.parseUrl = function (str) {
  // FIXME: this regex looks a bit broken
  var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
  regex.lastIndex = 0;
  var m = regex.exec(str);
  var url = m === null ? null : {
    full: str,
    scheme: m[1],
    host: m[2],
    port: m[3],
    path: m[4]
  };

  if (url) {
    url.fullHost = url.host;

    if (url.port) {
      if (url.port !== 80 && url.scheme === 'http') {
        url.fullHost += ':' + url.port;
      } else if (url.port !== 443 && url.scheme === 'https') {
        url.fullHost += ':' + url.port;
      }
    } else if (url.scheme === 'http') {
      url.port = 80;
    } else if (url.scheme === 'https') {
      url.port = 443;
    }

    url.full = url.scheme + '://' + url.fullHost;
  }

  return url;
};
/* Storage for query variables */


var _queryVariables = null;
/**
 * Returns the window location query variables. Query is parsed on the first
 * call and the same object is returned on subsequent calls. The mapping
 * is from keys to an array of values. Parameters without values will have
 * an object key set but no value added to the value array. Values are
 * unescaped.
 *
 * ...?k1=v1&k2=v2:
 * {
 *   "k1": ["v1"],
 *   "k2": ["v2"]
 * }
 *
 * ...?k1=v1&k1=v2:
 * {
 *   "k1": ["v1", "v2"]
 * }
 *
 * ...?k1=v1&k2:
 * {
 *   "k1": ["v1"],
 *   "k2": []
 * }
 *
 * ...?k1=v1&k1:
 * {
 *   "k1": ["v1"]
 * }
 *
 * ...?k1&k1:
 * {
 *   "k1": []
 * }
 *
 * @param query the query string to parse (optional, default to cached
 *          results from parsing window location search query).
 *
 * @return object mapping keys to variables.
 */

util.getQueryVariables = function (query) {
  var parse = function parse(q) {
    var rval = {};
    var kvpairs = q.split('&');

    for (var i = 0; i < kvpairs.length; i++) {
      var pos = kvpairs[i].indexOf('=');
      var key;
      var val;

      if (pos > 0) {
        key = kvpairs[i].substring(0, pos);
        val = kvpairs[i].substring(pos + 1);
      } else {
        key = kvpairs[i];
        val = null;
      }

      if (!(key in rval)) {
        rval[key] = [];
      } // disallow overriding object prototype keys


      if (!(key in Object.prototype) && val !== null) {
        rval[key].push(unescape(val));
      }
    }

    return rval;
  };

  var rval;

  if (typeof query === 'undefined') {
    // set cached variables if needed
    if (_queryVariables === null) {
      if (typeof window !== 'undefined' && window.location && window.location.search) {
        // parse window search query
        _queryVariables = parse(window.location.search.substring(1));
      } else {
        // no query variables available
        _queryVariables = {};
      }
    }

    rval = _queryVariables;
  } else {
    // parse given query
    rval = parse(query);
  }

  return rval;
};
/**
 * Parses a fragment into a path and query. This method will take a URI
 * fragment and break it up as if it were the main URI. For example:
 *    /bar/baz?a=1&b=2
 * results in:
 *    {
 *       path: ["bar", "baz"],
 *       query: {"k1": ["v1"], "k2": ["v2"]}
 *    }
 *
 * @return object with a path array and query object.
 */


util.parseFragment = function (fragment) {
  // default to whole fragment
  var fp = fragment;
  var fq = ''; // split into path and query if possible at the first '?'

  var pos = fragment.indexOf('?');

  if (pos > 0) {
    fp = fragment.substring(0, pos);
    fq = fragment.substring(pos + 1);
  } // split path based on '/' and ignore first element if empty


  var path = fp.split('/');

  if (path.length > 0 && path[0] === '') {
    path.shift();
  } // convert query into object


  var query = fq === '' ? {} : util.getQueryVariables(fq);
  return {
    pathString: fp,
    queryString: fq,
    path: path,
    query: query
  };
};
/**
 * Makes a request out of a URI-like request string. This is intended to
 * be used where a fragment id (after a URI '#') is parsed as a URI with
 * path and query parts. The string should have a path beginning and
 * delimited by '/' and optional query parameters following a '?'. The
 * query should be a standard URL set of key value pairs delimited by
 * '&'. For backwards compatibility the initial '/' on the path is not
 * required. The request object has the following API, (fully described
 * in the method code):
 *    {
 *       path: <the path string part>.
 *       query: <the query string part>,
 *       getPath(i): get part or all of the split path array,
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */


util.makeRequest = function (reqString) {
  var frag = util.parseFragment(reqString);
  var req = {
    // full path string
    path: frag.pathString,
    // full query string
    query: frag.queryString,

    /**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */
    getPath: function getPath(i) {
      return typeof i === 'undefined' ? frag.path : frag.path[i];
    },

    /**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */
    getQuery: function getQuery(k, i) {
      var rval;

      if (typeof k === 'undefined') {
        rval = frag.query;
      } else {
        rval = frag.query[k];

        if (rval && typeof i !== 'undefined') {
          rval = rval[i];
        }
      }

      return rval;
    },
    getQueryLast: function getQueryLast(k, _default) {
      var rval;
      var vals = req.getQuery(k);

      if (vals) {
        rval = vals[vals.length - 1];
      } else {
        rval = _default;
      }

      return rval;
    }
  };
  return req;
};
/**
 * Makes a URI out of a path, an object with query parameters, and a
 * fragment. Uses jQuery.param() internally for query string creation.
 * If the path is an array, it will be joined with '/'.
 *
 * @param path string path or array of strings.
 * @param query object with query parameters. (optional)
 * @param fragment fragment string. (optional)
 *
 * @return string object with request parameters.
 */


util.makeLink = function (path, query, fragment) {
  // join path parts if needed
  path = jQuery.isArray(path) ? path.join('/') : path;
  var qstr = jQuery.param(query || {});
  fragment = fragment || '';
  return path + (qstr.length > 0 ? '?' + qstr : '') + (fragment.length > 0 ? '#' + fragment : '');
};
/**
 * Check if an object is empty.
 *
 * Taken from:
 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
 *
 * @param object the object to check.
 */


util.isEmpty = function (obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }

  return true;
};
/**
 * Format with simple printf-style interpolation.
 *
 * %%: literal '%'
 * %s,%o: convert next argument into a string.
 *
 * @param format the string to format.
 * @param ... arguments to interpolate into the format string.
 */


util.format = function (format) {
  var re = /%./g; // current match

  var match; // current part

  var part; // current arg index

  var argi = 0; // collected parts to recombine later

  var parts = []; // last index found

  var last = 0; // loop while matches remain

  while (match = re.exec(format)) {
    part = format.substring(last, re.lastIndex - 2); // don't add empty strings (ie, parts between %s%s)

    if (part.length > 0) {
      parts.push(part);
    }

    last = re.lastIndex; // switch on % code

    var code = match[0][1];

    switch (code) {
      case 's':
      case 'o':
        // check if enough arguments were given
        if (argi < arguments.length) {
          parts.push(arguments[argi++ + 1]);
        } else {
          parts.push('<?>');
        }

        break;
      // FIXME: do proper formating for numbers, etc
      //case 'f':
      //case 'd':

      case '%':
        parts.push('%');
        break;

      default:
        parts.push('<%' + code + '?>');
    }
  } // add trailing part of format string


  parts.push(format.substring(last));
  return parts.join('');
};
/**
 * Formats a number.
 *
 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
 */


util.formatNumber = function (number, decimals, dec_point, thousands_sep) {
  // http://kevin.vanzonneveld.net
  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +     bugfix by: Michael White (http://crestidg.com)
  // +     bugfix by: Benjamin Lupton
  // +     bugfix by: Allan Jensen (http://www.winternet.no)
  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // *     example 1: number_format(1234.5678, 2, '.', '');
  // *     returns 1: 1234.57
  var n = number,
      c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d = dec_point === undefined ? ',' : dec_point;
  var t = thousands_sep === undefined ? '.' : thousands_sep,
      s = n < 0 ? '-' : '';
  var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + '';
  var j = i.length > 3 ? i.length % 3 : 0;
  return s + (j ? i.substr(0, j) + t : '') + i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
};
/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */


util.formatSize = function (size) {
  if (size >= 1073741824) {
    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';
  } else if (size >= 1048576) {
    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
  } else if (size >= 1024) {
    size = util.formatNumber(size / 1024, 0) + ' KiB';
  } else {
    size = util.formatNumber(size, 0) + ' bytes';
  }

  return size;
};
/**
 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */


util.bytesFromIP = function (ip) {
  if (ip.indexOf('.') !== -1) {
    return util.bytesFromIPv4(ip);
  }

  if (ip.indexOf(':') !== -1) {
    return util.bytesFromIPv6(ip);
  }

  return null;
};
/**
 * Converts an IPv4 string representation into bytes (in network order).
 *
 * @param ip the IPv4 address to convert.
 *
 * @return the 4-byte address or null if the address can't be parsed.
 */


util.bytesFromIPv4 = function (ip) {
  ip = ip.split('.');

  if (ip.length !== 4) {
    return null;
  }

  var b = util.createBuffer();

  for (var i = 0; i < ip.length; ++i) {
    var num = parseInt(ip[i], 10);

    if (isNaN(num)) {
      return null;
    }

    b.putByte(num);
  }

  return b.getBytes();
};
/**
 * Converts an IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv6 address to convert.
 *
 * @return the 16-byte address or null if the address can't be parsed.
 */


util.bytesFromIPv6 = function (ip) {
  var blanks = 0;
  ip = ip.split(':').filter(function (e) {
    if (e.length === 0) ++blanks;
    return true;
  });
  var zeros = (8 - ip.length + blanks) * 2;
  var b = util.createBuffer();

  for (var i = 0; i < 8; ++i) {
    if (!ip[i] || ip[i].length === 0) {
      b.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }

    var bytes = util.hexToBytes(ip[i]);

    if (bytes.length < 2) {
      b.putByte(0);
    }

    b.putBytes(bytes);
  }

  return b.getBytes();
};
/**
 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
 * an IPv6 string representation. The bytes must be in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */


util.bytesToIP = function (bytes) {
  if (bytes.length === 4) {
    return util.bytesToIPv4(bytes);
  }

  if (bytes.length === 16) {
    return util.bytesToIPv6(bytes);
  }

  return null;
};
/**
 * Converts 4-bytes into an IPv4 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 string representation or null for an invalid # of bytes.
 */


util.bytesToIPv4 = function (bytes) {
  if (bytes.length !== 4) {
    return null;
  }

  var ip = [];

  for (var i = 0; i < bytes.length; ++i) {
    ip.push(bytes.charCodeAt(i));
  }

  return ip.join('.');
};
/**
 * Converts 16-bytes into an IPv16 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv16 string representation or null for an invalid # of bytes.
 */


util.bytesToIPv6 = function (bytes) {
  if (bytes.length !== 16) {
    return null;
  }

  var ip = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;

  for (var i = 0; i < bytes.length; i += 2) {
    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]); // canonicalize zero representation

    while (hex[0] === '0' && hex !== '0') {
      hex = hex.substr(1);
    }

    if (hex === '0') {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip.length;

      if (!last || idx !== last.end + 1) {
        zeroGroups.push({
          start: idx,
          end: idx
        });
      } else {
        last.end = idx;

        if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }

    ip.push(hex);
  }

  if (zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup]; // only shorten group of length > 0

    if (group.end - group.start > 0) {
      ip.splice(group.start, group.end - group.start + 1, '');

      if (group.start === 0) {
        ip.unshift('');
      }

      if (group.end === 7) {
        ip.push('');
      }
    }
  }

  return ip.join(':');
};
/**
 * Estimates the number of processes that can be run concurrently. If
 * creating Web Workers, keep in mind that the main JavaScript process needs
 * its own core.
 *
 * @param options the options to use:
 *          update true to force an update (not use the cached value).
 * @param callback(err, max) called once the operation completes.
 */


util.estimateCores = function (options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};

  if ('cores' in util && !options.update) {
    return callback(null, util.cores);
  }

  if (typeof navigator !== 'undefined' && 'hardwareConcurrency' in navigator && navigator.hardwareConcurrency > 0) {
    util.cores = navigator.hardwareConcurrency;
    return callback(null, util.cores);
  }

  if (typeof Worker === 'undefined') {
    // workers not available
    util.cores = 1;
    return callback(null, util.cores);
  }

  if (typeof Blob === 'undefined') {
    // can't estimate, default to 2
    util.cores = 2;
    return callback(null, util.cores);
  } // create worker concurrency estimation code as blob


  var blobUrl = URL.createObjectURL(new Blob(['(', function () {
    self.addEventListener('message', function (e) {
      // run worker for 4 ms
      var st = Date.now();
      var et = st + 4;

      while (Date.now() < et) {
        ;
      }

      self.postMessage({
        st: st,
        et: et
      });
    });
  }.toString(), ')()'], {
    type: 'application/javascript'
  })); // take 5 samples using 16 workers

  sample([], 5, 16);

  function sample(max, samples, numWorkers) {
    if (samples === 0) {
      // get overlap average
      var avg = Math.floor(max.reduce(function (avg, x) {
        return avg + x;
      }, 0) / max.length);
      util.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util.cores);
    }

    map(numWorkers, function (err, results) {
      max.push(reduce(numWorkers, results));
      sample(max, samples - 1, numWorkers);
    });
  }

  function map(numWorkers, callback) {
    var workers = [];
    var results = [];

    for (var i = 0; i < numWorkers; ++i) {
      var worker = new Worker(blobUrl);
      worker.addEventListener('message', function (e) {
        results.push(e.data);

        if (results.length === numWorkers) {
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].terminate();
          }

          callback(null, results);
        }
      });
      workers.push(worker);
    }

    for (var i = 0; i < numWorkers; ++i) {
      workers[i].postMessage(i);
    }
  }

  function reduce(numWorkers, results) {
    // find overlapping time windows
    var overlaps = [];

    for (var n = 0; n < numWorkers; ++n) {
      var r1 = results[n];
      var overlap = overlaps[n] = [];

      for (var i = 0; i < numWorkers; ++i) {
        if (n === i) {
          continue;
        }

        var r2 = results[i];

        if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
          overlap.push(i);
        }
      }
    } // get maximum overlaps ... don't include overlapping worker itself
    // as the main JS process was also being scheduled during the work and
    // would have to be subtracted from the estimate anyway


    return overlaps.reduce(function (max, overlap) {
      return Math.max(max, overlap.length);
    }, 0);
  }
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate)

},{"./baseN":136,"./forge":137,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27,"_process":142,"buffer":58,"timers":193}],142:[function(require,module,exports){
"use strict";

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

},{}],143:[function(require,module,exports){
"use strict";

/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var promise;
module.exports = typeof queueMicrotask === 'function' ? queueMicrotask.bind(globalThis) // reuse resolved promise, and allocate it lazily
: function (cb) {
  return (promise || (promise = Promise.resolve())).then(cb)["catch"](function (err) {
    return setTimeout(function () {
      throw err;
    }, 0);
  });
};

},{}],144:[function(require,module,exports){
/**
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var util = require('./util');

module.exports = /*#__PURE__*/function () {
  function AsyncAlgorithm() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$maxCallStackDept = _ref.maxCallStackDepth,
        maxCallStackDepth = _ref$maxCallStackDept === void 0 ? 500 : _ref$maxCallStackDept,
        _ref$maxTotalCallStac = _ref.maxTotalCallStackDepth,
        maxTotalCallStackDepth = _ref$maxTotalCallStac === void 0 ? 0xFFFFFFFF : _ref$maxTotalCallStac,
        _ref$timeSlice = _ref.timeSlice,
        timeSlice = _ref$timeSlice === void 0 ? 10 : _ref$timeSlice;

    (0, _classCallCheck2["default"])(this, AsyncAlgorithm);
    this.schedule = {};
    this.schedule.MAX_DEPTH = maxCallStackDepth;
    this.schedule.MAX_TOTAL_DEPTH = maxTotalCallStackDepth;
    this.schedule.depth = 0;
    this.schedule.totalDepth = 0;
    this.schedule.timeSlice = timeSlice;
  } // do some work in a time slice, but in serial


  (0, _createClass2["default"])(AsyncAlgorithm, [{
    key: "doWork",
    value: function doWork(fn, callback) {
      var schedule = this.schedule;

      if (schedule.totalDepth >= schedule.MAX_TOTAL_DEPTH) {
        return callback(new Error('Maximum total call stack depth exceeded; canonicalization aborting.'));
      }

      (function work() {
        if (schedule.depth === schedule.MAX_DEPTH) {
          // stack too deep, run on next tick
          schedule.depth = 0;
          schedule.running = false;
          return util.nextTick(work);
        } // if not yet running, force run


        var now = Date.now();

        if (!schedule.running) {
          schedule.start = Date.now();
          schedule.deadline = schedule.start + schedule.timeSlice;
        } // TODO: should also include an estimate of expectedWorkTime


        if (now < schedule.deadline) {
          schedule.running = true;
          schedule.depth++;
          schedule.totalDepth++;
          return fn(function (err, result) {
            schedule.depth--;
            schedule.totalDepth--;
            callback(err, result);
          });
        } // not enough time left in this slice, run after letting browser
        // do some other things


        schedule.depth = 0;
        schedule.running = false;
        util.setImmediate(work);
      })();
    } // asynchronously loop

  }, {
    key: "forEach",
    value: function forEach(iterable, fn, callback) {
      var self = this;

      var _iterator2;

      var idx = 0;
      var length;

      if (Array.isArray(iterable)) {
        length = iterable.length;

        _iterator2 = function iterator() {
          if (idx === length) {
            return false;
          }

          _iterator2.value = iterable[idx++];
          _iterator2.key = idx;
          return true;
        };
      } else {
        var keys = Object.keys(iterable);
        length = keys.length;

        _iterator2 = function _iterator() {
          if (idx === length) {
            return false;
          }

          _iterator2.key = keys[idx++];
          _iterator2.value = iterable[_iterator2.key];
          return true;
        };
      }

      (function iterate(err) {
        if (err) {
          return callback(err);
        }

        if (_iterator2()) {
          return self.doWork(function () {
            return fn(_iterator2.value, _iterator2.key, iterate);
          });
        }

        callback();
      })();
    } // asynchronous waterfall

  }, {
    key: "waterfall",
    value: function waterfall(fns, callback) {
      var self = this;
      self.forEach(fns, function (fn, idx, callback) {
        return self.doWork(fn, callback);
      }, callback);
    } // asynchronous while

  }, {
    key: "whilst",
    value: function whilst(condition, fn, callback) {
      var self = this;

      (function loop(err) {
        if (err) {
          return callback(err);
        }

        if (!condition()) {
          return callback();
        }

        self.doWork(fn, loop);
      })();
    }
  }]);
  return AsyncAlgorithm;
}();

},{"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],145:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var util = require('./util');

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a new IdentifierIssuer. A IdentifierIssuer issues unique
   * identifiers, keeping track of any previously issued identifiers.
   *
   * @param prefix the prefix to use ('<prefix><counter>').
   */
  function IdentifierIssuer(prefix) {
    (0, _classCallCheck2["default"])(this, IdentifierIssuer);
    this.prefix = prefix;
    this.counter = 0;
    this.existing = {};
  }
  /**
   * Copies this IdentifierIssuer.
   *
   * @return a copy of this IdentifierIssuer.
   */


  (0, _createClass2["default"])(IdentifierIssuer, [{
    key: "clone",
    value: function clone() {
      var copy = new IdentifierIssuer(this.prefix);
      copy.counter = this.counter;
      copy.existing = util.clone(this.existing);
      return copy;
    }
    /**
     * Gets the new identifier for the given old identifier, where if no old
     * identifier is given a new identifier will be generated.
     *
     * @param [old] the old identifier to get the new identifier for.
     *
     * @return the new identifier.
     */

  }, {
    key: "getId",
    value: function getId(old) {
      // return existing old identifier
      if (old && old in this.existing) {
        return this.existing[old];
      } // get next identifier


      var identifier = this.prefix + this.counter;
      this.counter += 1; // save mapping

      if (old) {
        this.existing[old] = identifier;
      }

      return identifier;
    }
    /**
     * Returns true if the given old identifer has already been assigned a new
     * identifier.
     *
     * @param old the old identifier to check.
     *
     * @return true if the old identifier has been assigned a new identifier,
     *   false if not.
     */

  }, {
    key: "hasId",
    value: function hasId(old) {
      return old in this.existing;
    }
  }]);
  return IdentifierIssuer;
}();

},{"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],146:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var forge = require('node-forge/lib/forge');

require('node-forge/lib/md');

require('node-forge/lib/sha1');

require('node-forge/lib/sha256');

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a new MessageDigest.
   *
   * @param algorithm the algorithm to use.
   */
  function MessageDigest(algorithm) {
    (0, _classCallCheck2["default"])(this, MessageDigest);
    this.md = forge.md[algorithm].create();
  }

  (0, _createClass2["default"])(MessageDigest, [{
    key: "update",
    value: function update(msg) {
      this.md.update(msg, 'utf8');
    }
  }, {
    key: "digest",
    value: function digest() {
      return this.md.digest().toHex();
    }
  }]);
  return MessageDigest;
}();

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"node-forge/lib/forge":137,"node-forge/lib/md":138,"node-forge/lib/sha1":139,"node-forge/lib/sha256":140}],147:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict'; // eslint-disable-next-line no-unused-vars

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var TERMS = ['subject', 'predicate', 'object', 'graph'];
var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
var RDF_LANGSTRING = RDF + 'langString';
var XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string'; // build regexes

var REGEX = {};

(function () {
  var iri = '(?:<([^:]+:[^>]*)>)'; // https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL

  var PN_CHARS_BASE = 'A-Z' + 'a-z' + "\xC0-\xD6" + "\xD8-\xF6" + "\xF8-\u02FF" + "\u0370-\u037D" + "\u037F-\u1FFF" + "\u200C-\u200D" + "\u2070-\u218F" + "\u2C00-\u2FEF" + "\u3001-\uD7FF" + "\uF900-\uFDCF" + "\uFDF0-\uFFFD"; // TODO:
  //'\u10000-\uEFFFF';

  var PN_CHARS_U = PN_CHARS_BASE + '_';
  var PN_CHARS = PN_CHARS_U + '0-9' + '-' + "\xB7" + "\u0300-\u036F" + "\u203F-\u2040";
  var BLANK_NODE_LABEL = '(_:' + '(?:[' + PN_CHARS_U + '0-9])' + '(?:(?:[' + PN_CHARS + '.])*(?:[' + PN_CHARS + ']))?' + ')';
  var bnode = BLANK_NODE_LABEL;
  var plain = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"';
  var datatype = '(?:\\^\\^' + iri + ')';
  var language = '(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))';
  var literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';
  var ws = '[ \\t]+';
  var wso = '[ \\t]*'; // define quad part regexes

  var subject = '(?:' + iri + '|' + bnode + ')' + ws;
  var property = iri + ws;
  var object = '(?:' + iri + '|' + bnode + '|' + literal + ')' + wso;
  var graphName = '(?:\\.|(?:(?:' + iri + '|' + bnode + ')' + wso + '\\.))'; // end of line and empty regexes

  REGEX.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g;
  REGEX.empty = new RegExp('^' + wso + '$'); // full quad regex

  REGEX.quad = new RegExp('^' + wso + subject + property + object + graphName + wso + '$');
})();

module.exports = /*#__PURE__*/function () {
  function NQuads() {
    (0, _classCallCheck2["default"])(this, NQuads);
  }

  (0, _createClass2["default"])(NQuads, null, [{
    key: "parse",

    /**
     * Parses RDF in the form of N-Quads.
     *
     * @param input the N-Quads input to parse.
     *
     * @return an RDF dataset (an array of quads per http://rdf.js.org/).
     */
    value: function parse(input) {
      // build RDF dataset
      var dataset = [];
      var graphs = {}; // split N-Quad input into lines

      var lines = input.split(REGEX.eoln);
      var lineNumber = 0;

      var _iterator = _createForOfIteratorHelper(lines),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var line = _step.value;
          lineNumber++; // skip empty lines

          if (REGEX.empty.test(line)) {
            continue;
          } // parse quad


          var match = line.match(REGEX.quad);

          if (match === null) {
            throw new Error('N-Quads parse error on line ' + lineNumber + '.');
          } // create RDF quad


          var quad = {}; // get subject

          if (match[1] !== undefined) {
            quad.subject = {
              termType: 'NamedNode',
              value: match[1]
            };
          } else {
            quad.subject = {
              termType: 'BlankNode',
              value: match[2]
            };
          } // get predicate


          quad.predicate = {
            termType: 'NamedNode',
            value: match[3]
          }; // get object

          if (match[4] !== undefined) {
            quad.object = {
              termType: 'NamedNode',
              value: match[4]
            };
          } else if (match[5] !== undefined) {
            quad.object = {
              termType: 'BlankNode',
              value: match[5]
            };
          } else {
            quad.object = {
              termType: 'Literal',
              value: undefined,
              datatype: {
                termType: 'NamedNode'
              }
            };

            if (match[7] !== undefined) {
              quad.object.datatype.value = match[7];
            } else if (match[8] !== undefined) {
              quad.object.datatype.value = RDF_LANGSTRING;
              quad.object.language = match[8];
            } else {
              quad.object.datatype.value = XSD_STRING;
            }

            quad.object.value = _unescape(match[6]);
          } // get graph


          if (match[9] !== undefined) {
            quad.graph = {
              termType: 'NamedNode',
              value: match[9]
            };
          } else if (match[10] !== undefined) {
            quad.graph = {
              termType: 'BlankNode',
              value: match[10]
            };
          } else {
            quad.graph = {
              termType: 'DefaultGraph',
              value: ''
            };
          } // only add quad if it is unique in its graph


          if (!(quad.graph.value in graphs)) {
            graphs[quad.graph.value] = [quad];
            dataset.push(quad);
          } else {
            var unique = true;
            var quads = graphs[quad.graph.value];

            var _iterator2 = _createForOfIteratorHelper(quads),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var q = _step2.value;

                if (_compareTriples(q, quad)) {
                  unique = false;
                  break;
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            if (unique) {
              quads.push(quad);
              dataset.push(quad);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return dataset;
    }
    /**
     * Converts an RDF dataset to N-Quads.
     *
     * @param dataset (array of quads) the RDF dataset to convert.
     *
     * @return the N-Quads string.
     */

  }, {
    key: "serialize",
    value: function serialize(dataset) {
      if (!Array.isArray(dataset)) {
        dataset = NQuads.legacyDatasetToQuads(dataset);
      }

      var quads = [];

      var _iterator3 = _createForOfIteratorHelper(dataset),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var quad = _step3.value;
          quads.push(NQuads.serializeQuad(quad));
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return quads.sort().join('');
    }
    /**
     * Converts an RDF quad to an N-Quad string (a single quad).
     *
     * @param quad the RDF quad convert.
     *
     * @return the N-Quad string.
     */

  }, {
    key: "serializeQuad",
    value: function serializeQuad(quad) {
      var s = quad.subject;
      var p = quad.predicate;
      var o = quad.object;
      var g = quad.graph;
      var nquad = ''; // subject and predicate can only be NamedNode or BlankNode

      [s, p].forEach(function (term) {
        if (term.termType === 'NamedNode') {
          nquad += '<' + term.value + '>';
        } else {
          nquad += term.value;
        }

        nquad += ' ';
      }); // object is NamedNode, BlankNode, or Literal

      if (o.termType === 'NamedNode') {
        nquad += '<' + o.value + '>';
      } else if (o.termType === 'BlankNode') {
        nquad += o.value;
      } else {
        nquad += '"' + _escape(o.value) + '"';

        if (o.datatype.value === RDF_LANGSTRING) {
          if (o.language) {
            nquad += '@' + o.language;
          }
        } else if (o.datatype.value !== XSD_STRING) {
          nquad += '^^<' + o.datatype.value + '>';
        }
      } // graph can only be NamedNode or BlankNode (or DefaultGraph, but that
      // does not add to `nquad`)


      if (g.termType === 'NamedNode') {
        nquad += ' <' + g.value + '>';
      } else if (g.termType === 'BlankNode') {
        nquad += ' ' + g.value;
      }

      nquad += ' .\n';
      return nquad;
    }
    /**
     * Converts a legacy-formatted dataset to an array of quads dataset per
     * http://rdf.js.org/.
     *
     * @param dataset the legacy dataset to convert.
     *
     * @return the array of quads dataset.
     */

  }, {
    key: "legacyDatasetToQuads",
    value: function legacyDatasetToQuads(dataset) {
      var quads = [];
      var termTypeMap = {
        'blank node': 'BlankNode',
        IRI: 'NamedNode',
        literal: 'Literal'
      };

      var _loop = function _loop(graphName) {
        var triples = dataset[graphName];
        triples.forEach(function (triple) {
          var quad = {};

          for (var componentName in triple) {
            var oldComponent = triple[componentName];
            var newComponent = {
              termType: termTypeMap[oldComponent.type],
              value: oldComponent.value
            };

            if (newComponent.termType === 'Literal') {
              newComponent.datatype = {
                termType: 'NamedNode'
              };

              if ('datatype' in oldComponent) {
                newComponent.datatype.value = oldComponent.datatype;
              }

              if ('language' in oldComponent) {
                if (!('datatype' in oldComponent)) {
                  newComponent.datatype.value = RDF_LANGSTRING;
                }

                newComponent.language = oldComponent.language;
              } else if (!('datatype' in oldComponent)) {
                newComponent.datatype.value = XSD_STRING;
              }
            }

            quad[componentName] = newComponent;
          }

          if (graphName === '@default') {
            quad.graph = {
              termType: 'DefaultGraph',
              value: ''
            };
          } else {
            quad.graph = {
              termType: graphName.startsWith('_:') ? 'BlankNode' : 'NamedNode',
              value: graphName
            };
          }

          quads.push(quad);
        });
      };

      for (var graphName in dataset) {
        _loop(graphName);
      }

      return quads;
    }
  }]);
  return NQuads;
}();
/**
 * Compares two RDF triples for equality.
 *
 * @param t1 the first triple.
 * @param t2 the second triple.
 *
 * @return true if the triples are the same, false if not.
 */


function _compareTriples(t1, t2) {
  for (var k in t1) {
    if (t1[k].termType !== t2[k].termType || t1[k].value !== t2[k].value) {
      return false;
    }
  }

  if (t1.object.termType !== 'Literal') {
    return true;
  }

  return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.datatype.value === t2.object.datatype.value && t1.object.language === t2.object.language;
}

var _escapeRegex = /["\\\n\r]/g;
/**
 * Escape string to N-Quads literal
 */

function _escape(s) {
  return s.replace(_escapeRegex, function (match) {
    switch (match) {
      case '"':
        return '\\"';

      case '\\':
        return '\\\\';

      case '\n':
        return '\\n';

      case '\r':
        return '\\r';
    }
  });
}

var _unescapeRegex = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
/**
 * Unescape N-Quads literal to string
 */

function _unescape(s) {
  return s.replace(_unescapeRegex, function (match, code, u, U) {
    if (code) {
      switch (code) {
        case 't':
          return '\t';

        case 'b':
          return '\b';

        case 'n':
          return '\n';

        case 'r':
          return '\r';

        case 'f':
          return '\f';

        case '"':
          return '"';

        case '\'':
          return '\'';

        case '\\':
          return '\\';
      }
    }

    if (u) {
      return String.fromCharCode(parseInt(u, 16));
    }

    if (U) {
      // FIXME: support larger values
      throw new Error('Unsupported U escape');
    }
  });
}

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],148:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict'; // TODO: convert to ES6 iterable

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

module.exports = /*#__PURE__*/function () {
  /**
   * A Permutator iterates over all possible permutations of the given array
   * of elements.
   *
   * @param list the array of elements to iterate over.
   */
  function Permutator(list) {
    (0, _classCallCheck2["default"])(this, Permutator);
    // original array
    this.list = list.sort(); // indicates whether there are more permutations

    this.done = false; // directional info for permutation algorithm

    this.left = {};

    for (var i = 0; i < list.length; ++i) {
      this.left[list[i]] = true;
    }
  }
  /**
   * Returns true if there is another permutation.
   *
   * @return true if there is another permutation, false if not.
   */


  (0, _createClass2["default"])(Permutator, [{
    key: "hasNext",
    value: function hasNext() {
      return !this.done;
    }
    /**
     * Gets the next permutation. Call hasNext() to ensure there is another one
     * first.
     *
     * @return the next permutation.
     */

  }, {
    key: "next",
    value: function next() {
      // copy current permutation
      var rval = this.list.slice();
      /* Calculate the next permutation using the Steinhaus-Johnson-Trotter
       permutation algorithm. */
      // get largest mobile element k
      // (mobile: element is greater than the one it is looking at)

      var k = null;
      var pos = 0;
      var length = this.list.length;

      for (var i = 0; i < length; ++i) {
        var element = this.list[i];
        var left = this.left[element];

        if ((k === null || element > k) && (left && i > 0 && element > this.list[i - 1] || !left && i < length - 1 && element > this.list[i + 1])) {
          k = element;
          pos = i;
        }
      } // no more permutations


      if (k === null) {
        this.done = true;
      } else {
        // swap k and the element it is looking at
        var swap = this.left[k] ? pos - 1 : pos + 1;
        this.list[pos] = this.list[swap];
        this.list[swap] = k; // reverse the direction of all elements larger than k

        for (var _i = 0; _i < length; ++_i) {
          if (this.list[_i] > k) {
            this.left[this.list[_i]] = !this.left[this.list[_i]];
          }
        }
      }

      return rval;
    }
  }]);
  return Permutator;
}();

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],149:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var AsyncAlgorithm = require('./AsyncAlgorithm');

var IdentifierIssuer = require('./IdentifierIssuer');

var MessageDigest = require('./MessageDigest');

var Permutator = require('./Permutator');

var NQuads = require('./NQuads');

var util = require('./util');

var POSITIONS = {
  subject: 's',
  object: 'o',
  graph: 'g'
};

module.exports = /*#__PURE__*/function (_AsyncAlgorithm) {
  (0, _inherits2["default"])(URDNA2015, _AsyncAlgorithm);

  var _super = _createSuper(URDNA2015);

  function URDNA2015(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, URDNA2015);
    options = options || {};
    _this = _super.call(this, options);
    _this.name = 'URDNA2015';
    _this.options = Object.assign({}, options);
    _this.blankNodeInfo = {};
    _this.hashToBlankNodes = {};
    _this.canonicalIssuer = new IdentifierIssuer('_:c14n');
    _this.hashAlgorithm = 'sha256';
    _this.quads;
    return _this;
  } // 4.4) Normalization Algorithm


  (0, _createClass2["default"])(URDNA2015, [{
    key: "main",
    value: function main(dataset, callback) {
      var self = this;
      self.schedule.start = Date.now();
      var result;
      self.quads = dataset; // 1) Create the normalization state.
      // Note: Optimize by generating non-normalized blank node map concurrently.

      var nonNormalized = {};
      self.waterfall([function (callback) {
        // 2) For every quad in input dataset:
        self.forEach(dataset, function (quad, idx, callback) {
          // 2.1) For each blank node that occurs in the quad, add a reference
          // to the quad using the blank node identifier in the blank node to
          // quads map, creating a new entry if necessary.
          self.forEachComponent(quad, function (component) {
            if (component.termType !== 'BlankNode') {
              return;
            }

            var id = component.value;

            if (id in self.blankNodeInfo) {
              self.blankNodeInfo[id].quads.push(quad);
            } else {
              nonNormalized[id] = true;
              self.blankNodeInfo[id] = {
                quads: [quad]
              };
            }
          });
          callback();
        }, callback);
      }, function (callback) {
        // 3) Create a list of non-normalized blank node identifiers
        // non-normalized identifiers and populate it using the keys from the
        // blank node to quads map.
        // Note: We use a map here and it was generated during step 2.
        // 4) Initialize simple, a boolean flag, to true.
        var simple = true; // 5) While simple is true, issue canonical identifiers for blank nodes:

        self.whilst(function () {
          return simple;
        }, function (callback) {
          // 5.1) Set simple to false.
          simple = false; // 5.2) Clear hash to blank nodes map.

          self.hashToBlankNodes = {};
          self.waterfall([function (callback) {
            // 5.3) For each blank node identifier identifier in
            // non-normalized identifiers:
            self.forEach(nonNormalized, function (value, id, callback) {
              // 5.3.1) Create a hash, hash, according to the Hash First
              // Degree Quads algorithm.
              self.hashFirstDegreeQuads(id, function (err, hash) {
                if (err) {
                  return callback(err);
                } // 5.3.2) Add hash and identifier to hash to blank nodes map,
                // creating a new entry if necessary.


                if (hash in self.hashToBlankNodes) {
                  self.hashToBlankNodes[hash].push(id);
                } else {
                  self.hashToBlankNodes[hash] = [id];
                }

                callback();
              });
            }, callback);
          }, function (callback) {
            // 5.4) For each hash to identifier list mapping in hash to blank
            // nodes map, lexicographically-sorted by hash:
            var hashes = Object.keys(self.hashToBlankNodes).sort();
            self.forEach(hashes, function (hash, i, callback) {
              // 5.4.1) If the length of identifier list is greater than 1,
              // continue to the next mapping.
              var idList = self.hashToBlankNodes[hash];

              if (idList.length > 1) {
                return callback();
              } // 5.4.2) Use the Issue Identifier algorithm, passing canonical
              // issuer and the single blank node identifier in identifier
              // list, identifier, to issue a canonical replacement identifier
              // for identifier.
              // TODO: consider changing `getId` to `issue`


              var id = idList[0];
              self.canonicalIssuer.getId(id); // 5.4.3) Remove identifier from non-normalized identifiers.

              delete nonNormalized[id]; // 5.4.4) Remove hash from the hash to blank nodes map.

              delete self.hashToBlankNodes[hash]; // 5.4.5) Set simple to true.

              simple = true;
              callback();
            }, callback);
          }], callback);
        }, callback);
      }, function (callback) {
        // 6) For each hash to identifier list mapping in hash to blank nodes
        // map, lexicographically-sorted by hash:
        var hashes = Object.keys(self.hashToBlankNodes).sort();
        self.forEach(hashes, function (hash, idx, callback) {
          // 6.1) Create hash path list where each item will be a result of
          // running the Hash N-Degree Quads algorithm.
          var hashPathList = []; // 6.2) For each blank node identifier identifier in identifier list:

          var idList = self.hashToBlankNodes[hash];
          self.waterfall([function (callback) {
            self.forEach(idList, function (id, idx, callback) {
              // 6.2.1) If a canonical identifier has already been issued for
              // identifier, continue to the next identifier.
              if (self.canonicalIssuer.hasId(id)) {
                return callback();
              } // 6.2.2) Create temporary issuer, an identifier issuer
              // initialized with the prefix _:b.


              var issuer = new IdentifierIssuer('_:b'); // 6.2.3) Use the Issue Identifier algorithm, passing temporary
              // issuer and identifier, to issue a new temporary blank node
              // identifier for identifier.

              issuer.getId(id); // 6.2.4) Run the Hash N-Degree Quads algorithm, passing
              // temporary issuer, and append the result to the hash path
              // list.

              self.hashNDegreeQuads(id, issuer, function (err, result) {
                if (err) {
                  return callback(err);
                }

                hashPathList.push(result);
                callback();
              });
            }, callback);
          }, function (callback) {
            // 6.3) For each result in the hash path list,
            // lexicographically-sorted by the hash in result:
            // TODO: use `String.localeCompare`?
            hashPathList.sort(function (a, b) {
              return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
            });
            self.forEach(hashPathList, function (result, idx, callback) {
              // 6.3.1) For each blank node identifier, existing identifier,
              // that was issued a temporary identifier by identifier issuer
              // in result, issue a canonical identifier, in the same order,
              // using the Issue Identifier algorithm, passing canonical
              // issuer and existing identifier.
              for (var existing in result.issuer.existing) {
                self.canonicalIssuer.getId(existing);
              }

              callback();
            }, callback);
          }], callback);
        }, callback);
      }, function (callback) {
        /* Note: At this point all blank nodes in the set of RDF quads have been
        assigned canonical identifiers, which have been stored in the canonical
        issuer. Here each quad is updated by assigning each of its blank nodes
        its new identifier. */
        // 7) For each quad, quad, in input dataset:
        var normalized = [];
        self.waterfall([function (callback) {
          self.forEach(self.quads, function (quad, idx, callback) {
            // 7.1) Create a copy, quad copy, of quad and replace any existing
            // blank node identifiers using the canonical identifiers
            // previously issued by canonical issuer.
            // Note: We optimize away the copy here.
            self.forEachComponent(quad, function (component) {
              if (component.termType === 'BlankNode' && !component.value.startsWith(self.canonicalIssuer.prefix)) {
                component.value = self.canonicalIssuer.getId(component.value);
              }
            }); // 7.2) Add quad copy to the normalized dataset.

            normalized.push(NQuads.serializeQuad(quad));
            callback();
          }, callback);
        }, function (callback) {
          // sort normalized output
          normalized.sort(); // 8) Return the normalized dataset.

          result = normalized.join('');
          return callback();
        }], callback);
      }], function (err) {
        return callback(err, result);
      });
    } // 4.6) Hash First Degree Quads

  }, {
    key: "hashFirstDegreeQuads",
    value: function hashFirstDegreeQuads(id, callback) {
      var self = this; // return cached hash

      var info = self.blankNodeInfo[id];

      if ('hash' in info) {
        return callback(null, info.hash);
      } // 1) Initialize nquads to an empty list. It will be used to store quads in
      // N-Quads format.


      var nquads = []; // 2) Get the list of quads quads associated with the reference blank node
      // identifier in the blank node to quads map.

      var quads = info.quads; // 3) For each quad quad in quads:

      self.forEach(quads, function (quad, idx, callback) {
        // 3.1) Serialize the quad in N-Quads format with the following special
        // rule:
        // 3.1.1) If any component in quad is an blank node, then serialize it
        // using a special identifier as follows:
        var copy = {
          predicate: quad.predicate
        };
        self.forEachComponent(quad, function (component, key) {
          // 3.1.2) If the blank node's existing blank node identifier matches the
          // reference blank node identifier then use the blank node identifier
          // _:a, otherwise, use the blank node identifier _:z.
          copy[key] = self.modifyFirstDegreeComponent(id, component, key);
        });
        nquads.push(NQuads.serializeQuad(copy));
        callback();
      }, function (err) {
        if (err) {
          return callback(err);
        } // 4) Sort nquads in lexicographical order.


        nquads.sort(); // 5) Return the hash that results from passing the sorted, joined nquads
        // through the hash algorithm.

        var md = new MessageDigest(self.hashAlgorithm);

        for (var i = 0; i < nquads.length; ++i) {
          md.update(nquads[i]);
        } // TODO: represent as byte buffer instead to cut memory usage in half


        info.hash = md.digest();
        callback(null, info.hash);
      });
    } // 4.7) Hash Related Blank Node

  }, {
    key: "hashRelatedBlankNode",
    value: function hashRelatedBlankNode(related, quad, issuer, position, callback) {
      var self = this; // 1) Set the identifier to use for related, preferring first the canonical
      // identifier for related if issued, second the identifier issued by issuer
      // if issued, and last, if necessary, the result of the Hash First Degree
      // Quads algorithm, passing related.

      var id;
      self.waterfall([function (callback) {
        if (self.canonicalIssuer.hasId(related)) {
          id = self.canonicalIssuer.getId(related);
          return callback();
        }

        if (issuer.hasId(related)) {
          id = issuer.getId(related);
          return callback();
        }

        self.hashFirstDegreeQuads(related, function (err, hash) {
          if (err) {
            return callback(err);
          }

          id = hash;
          callback();
        });
      }], function (err) {
        if (err) {
          return callback(err);
        } // 2) Initialize a string input to the value of position.
        // Note: We use a hash object instead.


        var md = new MessageDigest(self.hashAlgorithm);
        md.update(position); // 3) If position is not g, append <, the value of the predicate in quad,
        // and > to input.

        if (position !== 'g') {
          md.update(self.getRelatedPredicate(quad));
        } // 4) Append identifier to input.


        md.update(id); // 5) Return the hash that results from passing input through the hash
        // algorithm.
        // TODO: represent as byte buffer instead to cut memory usage in half

        return callback(null, md.digest());
      });
    } // 4.8) Hash N-Degree Quads

  }, {
    key: "hashNDegreeQuads",
    value: function hashNDegreeQuads(id, issuer, callback) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.
      // Note: 2) and 3) handled within `createHashToRelated`

      var hashToRelated;
      var md = new MessageDigest(self.hashAlgorithm);
      self.waterfall([function (callback) {
        return self.createHashToRelated(id, issuer, function (err, result) {
          if (err) {
            return callback(err);
          }

          hashToRelated = result;
          callback();
        });
      }, function (callback) {
        // 4) Create an empty string, data to hash.
        // Note: We created a hash object `md` above instead.
        // 5) For each related hash to blank node list mapping in hash to
        // related blank nodes map, sorted lexicographically by related hash:
        var hashes = Object.keys(hashToRelated).sort();
        self.forEach(hashes, function (hash, idx, callback) {
          // 5.1) Append the related hash to the data to hash.
          md.update(hash); // 5.2) Create a string chosen path.

          var chosenPath = ''; // 5.3) Create an unset chosen issuer variable.

          var chosenIssuer; // 5.4) For each permutation of blank node list:

          var permutator = new Permutator(hashToRelated[hash]);
          self.whilst(function () {
            return permutator.hasNext();
          }, function (nextPermutation) {
            var permutation = permutator.next(); // 5.4.1) Create a copy of issuer, issuer copy.

            var issuerCopy = issuer.clone(); // 5.4.2) Create a string path.

            var path = ''; // 5.4.3) Create a recursion list, to store blank node identifiers
            // that must be recursively processed by this algorithm.

            var recursionList = [];
            self.waterfall([function (callback) {
              // 5.4.4) For each related in permutation:
              self.forEach(permutation, function (related, idx, callback) {
                // 5.4.4.1) If a canonical identifier has been issued for
                // related, append it to path.
                if (self.canonicalIssuer.hasId(related)) {
                  path += self.canonicalIssuer.getId(related);
                } else {
                  // 5.4.4.2) Otherwise:
                  // 5.4.4.2.1) If issuer copy has not issued an identifier
                  // for related, append related to recursion list.
                  if (!issuerCopy.hasId(related)) {
                    recursionList.push(related);
                  } // 5.4.4.2.2) Use the Issue Identifier algorithm, passing
                  // issuer copy and related and append the result to path.


                  path += issuerCopy.getId(related);
                } // 5.4.4.3) If chosen path is not empty and the length of path
                // is greater than or equal to the length of chosen path and
                // path is lexicographically greater than chosen path, then
                // skip to the next permutation.
                // Note: Comparing path length to chosen path length can be
                // optimized away; only compare lexicographically.


                if (chosenPath.length !== 0 && path > chosenPath) {
                  // FIXME: may cause inaccurate total depth calculation
                  return nextPermutation();
                }

                callback();
              }, callback);
            }, function (callback) {
              // 5.4.5) For each related in recursion list:
              self.forEach(recursionList, function (related, idx, callback) {
                // 5.4.5.1) Set result to the result of recursively executing
                // the Hash N-Degree Quads algorithm, passing related for
                // identifier and issuer copy for path identifier issuer.
                self.hashNDegreeQuads(related, issuerCopy, function (err, result) {
                  if (err) {
                    return callback(err);
                  } // 5.4.5.2) Use the Issue Identifier algorithm, passing
                  // issuer copy and related and append the result to path.


                  path += issuerCopy.getId(related); // 5.4.5.3) Append <, the hash in result, and > to path.

                  path += '<' + result.hash + '>'; // 5.4.5.4) Set issuer copy to the identifier issuer in
                  // result.

                  issuerCopy = result.issuer; // 5.4.5.5) If chosen path is not empty and the length of
                  // path is greater than or equal to the length of chosen
                  // path and path is lexicographically greater than chosen
                  // path, then skip to the next permutation.
                  // Note: Comparing path length to chosen path length can be
                  // optimized away; only compare lexicographically.

                  if (chosenPath.length !== 0 && path > chosenPath) {
                    // FIXME: may cause inaccurate total depth calculation
                    return nextPermutation();
                  }

                  callback();
                });
              }, callback);
            }, function (callback) {
              // 5.4.6) If chosen path is empty or path is lexicographically
              // less than chosen path, set chosen path to path and chosen
              // issuer to issuer copy.
              if (chosenPath.length === 0 || path < chosenPath) {
                chosenPath = path;
                chosenIssuer = issuerCopy;
              }

              callback();
            }], nextPermutation);
          }, function (err) {
            if (err) {
              return callback(err);
            } // 5.5) Append chosen path to data to hash.


            md.update(chosenPath); // 5.6) Replace issuer, by reference, with chosen issuer.

            issuer = chosenIssuer;
            callback();
          });
        }, callback);
      }], function (err) {
        // 6) Return issuer and the hash that results from passing data to hash
        // through the hash algorithm.
        callback(err, {
          hash: md.digest(),
          issuer: issuer
        });
      });
    } // helper for modifying component during Hash First Degree Quads

  }, {
    key: "modifyFirstDegreeComponent",
    value: function modifyFirstDegreeComponent(id, component) {
      if (component.termType !== 'BlankNode') {
        return component;
      }

      component = util.clone(component);
      component.value = component.value === id ? '_:a' : '_:z';
      return component;
    } // helper for getting a related predicate

  }, {
    key: "getRelatedPredicate",
    value: function getRelatedPredicate(quad) {
      return '<' + quad.predicate.value + '>';
    } // helper for creating hash to related blank nodes map

  }, {
    key: "createHashToRelated",
    value: function createHashToRelated(id, issuer, callback) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.

      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to
      // quads map for the key identifier.

      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:

      self.forEach(quads, function (quad, idx, callback) {
        // 3.1) For each component in quad, if component is the subject, object,
        // and graph name and it is a blank node that is not identified by
        // identifier:
        self.forEach(quad, function (component, key, callback) {
          if (key === 'predicate' || !(component.termType === 'BlankNode' && component.value !== id)) {
            return callback();
          } // 3.1.1) Set hash to the result of the Hash Related Blank Node
          // algorithm, passing the blank node identifier for component as
          // related, quad, path identifier issuer as issuer, and position as
          // either s, o, or g based on whether component is a subject, object,
          // graph name, respectively.


          var related = component.value;
          var position = POSITIONS[key];
          self.hashRelatedBlankNode(related, quad, issuer, position, function (err, hash) {
            if (err) {
              return callback(err);
            } // 3.1.2) Add a mapping of hash to the blank node identifier for
            // component to hash to related blank nodes map, adding an entry as
            // necessary.


            if (hash in hashToRelated) {
              hashToRelated[hash].push(related);
            } else {
              hashToRelated[hash] = [related];
            }

            callback();
          });
        }, callback);
      }, function (err) {
        return callback(err, hashToRelated);
      });
    } // helper that iterates over quad components (skips predicate)

  }, {
    key: "forEachComponent",
    value: function forEachComponent(quad, op) {
      for (var key in quad) {
        // skip `predicate`
        if (key === 'predicate') {
          continue;
        }

        op(quad[key], key, quad);
      }
    }
  }]);
  return URDNA2015;
}(AsyncAlgorithm);

},{"./AsyncAlgorithm":144,"./IdentifierIssuer":145,"./MessageDigest":146,"./NQuads":147,"./Permutator":148,"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22}],150:[function(require,module,exports){
/*
 * Copyright (c) 2016 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var IdentifierIssuer = require('./IdentifierIssuer');

var MessageDigest = require('./MessageDigest');

var Permutator = require('./Permutator');

var NQuads = require('./NQuads');

var util = require('./util');

var POSITIONS = {
  subject: 's',
  object: 'o',
  graph: 'g'
};

module.exports = /*#__PURE__*/function () {
  function URDNA2015Sync() {
    (0, _classCallCheck2["default"])(this, URDNA2015Sync);
    this.name = 'URDNA2015';
    this.blankNodeInfo = {};
    this.hashToBlankNodes = {};
    this.canonicalIssuer = new IdentifierIssuer('_:c14n');
    this.hashAlgorithm = 'sha256';
    this.quads;
  } // 4.4) Normalization Algorithm


  (0, _createClass2["default"])(URDNA2015Sync, [{
    key: "main",
    value: function main(dataset) {
      var self = this;
      self.quads = dataset; // 1) Create the normalization state.
      // Note: Optimize by generating non-normalized blank node map concurrently.

      var nonNormalized = {}; // 2) For every quad in input dataset:

      var _iterator = _createForOfIteratorHelper(dataset),
          _step;

      try {
        var _loop = function _loop() {
          var quad = _step.value;
          // 2.1) For each blank node that occurs in the quad, add a reference
          // to the quad using the blank node identifier in the blank node to
          // quads map, creating a new entry if necessary.
          self.forEachComponent(quad, function (component) {
            if (component.termType !== 'BlankNode') {
              return;
            }

            var id = component.value;

            if (id in self.blankNodeInfo) {
              self.blankNodeInfo[id].quads.push(quad);
            } else {
              nonNormalized[id] = true;
              self.blankNodeInfo[id] = {
                quads: [quad]
              };
            }
          });
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        } // 3) Create a list of non-normalized blank node identifiers
        // non-normalized identifiers and populate it using the keys from the
        // blank node to quads map.
        // Note: We use a map here and it was generated during step 2.
        // 4) Initialize simple, a boolean flag, to true.

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var simple = true; // 5) While simple is true, issue canonical identifiers for blank nodes:

      while (simple) {
        // 5.1) Set simple to false.
        simple = false; // 5.2) Clear hash to blank nodes map.

        self.hashToBlankNodes = {}; // 5.3) For each blank node identifier identifier in non-normalized
        // identifiers:

        for (var id in nonNormalized) {
          // 5.3.1) Create a hash, hash, according to the Hash First Degree
          // Quads algorithm.
          var hash = self.hashFirstDegreeQuads(id); // 5.3.2) Add hash and identifier to hash to blank nodes map,
          // creating a new entry if necessary.

          if (hash in self.hashToBlankNodes) {
            self.hashToBlankNodes[hash].push(id);
          } else {
            self.hashToBlankNodes[hash] = [id];
          }
        } // 5.4) For each hash to identifier list mapping in hash to blank
        // nodes map, lexicographically-sorted by hash:


        var _hashes = Object.keys(self.hashToBlankNodes).sort();

        for (var i = 0; i < _hashes.length; ++i) {
          // 5.4.1) If the length of identifier list is greater than 1,
          // continue to the next mapping.
          var _hash = _hashes[i];
          var idList = self.hashToBlankNodes[_hash];

          if (idList.length > 1) {
            continue;
          } // 5.4.2) Use the Issue Identifier algorithm, passing canonical
          // issuer and the single blank node identifier in identifier
          // list, identifier, to issue a canonical replacement identifier
          // for identifier.
          // TODO: consider changing `getId` to `issue`


          var _id = idList[0];
          self.canonicalIssuer.getId(_id); // 5.4.3) Remove identifier from non-normalized identifiers.

          delete nonNormalized[_id]; // 5.4.4) Remove hash from the hash to blank nodes map.

          delete self.hashToBlankNodes[_hash]; // 5.4.5) Set simple to true.

          simple = true;
        }
      } // 6) For each hash to identifier list mapping in hash to blank nodes map,
      // lexicographically-sorted by hash:


      var hashes = Object.keys(self.hashToBlankNodes).sort();

      for (var _i = 0; _i < hashes.length; ++_i) {
        // 6.1) Create hash path list where each item will be a result of
        // running the Hash N-Degree Quads algorithm.
        var hashPathList = []; // 6.2) For each blank node identifier identifier in identifier list:

        var _hash2 = hashes[_i];
        var _idList = self.hashToBlankNodes[_hash2];

        for (var j = 0; j < _idList.length; ++j) {
          // 6.2.1) If a canonical identifier has already been issued for
          // identifier, continue to the next identifier.
          var _id2 = _idList[j];

          if (self.canonicalIssuer.hasId(_id2)) {
            continue;
          } // 6.2.2) Create temporary issuer, an identifier issuer
          // initialized with the prefix _:b.


          var issuer = new IdentifierIssuer('_:b'); // 6.2.3) Use the Issue Identifier algorithm, passing temporary
          // issuer and identifier, to issue a new temporary blank node
          // identifier for identifier.

          issuer.getId(_id2); // 6.2.4) Run the Hash N-Degree Quads algorithm, passing
          // temporary issuer, and append the result to the hash path list.

          var result = self.hashNDegreeQuads(_id2, issuer);
          hashPathList.push(result);
        } // 6.3) For each result in the hash path list,
        // lexicographically-sorted by the hash in result:
        // TODO: use `String.localeCompare`?


        hashPathList.sort(function (a, b) {
          return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
        });

        for (var _j = 0; _j < hashPathList.length; ++_j) {
          // 6.3.1) For each blank node identifier, existing identifier,
          // that was issued a temporary identifier by identifier issuer
          // in result, issue a canonical identifier, in the same order,
          // using the Issue Identifier algorithm, passing canonical
          // issuer and existing identifier.
          var _result = hashPathList[_j];

          for (var existing in _result.issuer.existing) {
            self.canonicalIssuer.getId(existing);
          }
        }
      }
      /* Note: At this point all blank nodes in the set of RDF quads have been
      assigned canonical identifiers, which have been stored in the canonical
      issuer. Here each quad is updated by assigning each of its blank nodes
      its new identifier. */
      // 7) For each quad, quad, in input dataset:


      var normalized = [];

      for (var _i2 = 0; _i2 < self.quads.length; ++_i2) {
        // 7.1) Create a copy, quad copy, of quad and replace any existing
        // blank node identifiers using the canonical identifiers
        // previously issued by canonical issuer.
        // Note: We optimize away the copy here.
        var quad = self.quads[_i2];
        self.forEachComponent(quad, function (component) {
          if (component.termType === 'BlankNode' && !component.value.startsWith(self.canonicalIssuer.prefix)) {
            component.value = self.canonicalIssuer.getId(component.value);
          }
        }); // 7.2) Add quad copy to the normalized dataset.

        normalized.push(NQuads.serializeQuad(quad));
      } // sort normalized output


      normalized.sort(); // 8) Return the normalized dataset.

      return normalized.join('');
    } // 4.6) Hash First Degree Quads

  }, {
    key: "hashFirstDegreeQuads",
    value: function hashFirstDegreeQuads(id) {
      var self = this; // return cached hash

      var info = self.blankNodeInfo[id];

      if ('hash' in info) {
        return info.hash;
      } // 1) Initialize nquads to an empty list. It will be used to store quads in
      // N-Quads format.


      var nquads = []; // 2) Get the list of quads `quads` associated with the reference blank node
      // identifier in the blank node to quads map.

      var quads = info.quads; // 3) For each quad `quad` in `quads`:

      var _loop2 = function _loop2(i) {
        var quad = quads[i]; // 3.1) Serialize the quad in N-Quads format with the following special
        // rule:
        // 3.1.1) If any component in quad is an blank node, then serialize it
        // using a special identifier as follows:

        var copy = {
          predicate: quad.predicate
        };
        self.forEachComponent(quad, function (component, key) {
          // 3.1.2) If the blank node's existing blank node identifier matches
          // the reference blank node identifier then use the blank node
          // identifier _:a, otherwise, use the blank node identifier _:z.
          copy[key] = self.modifyFirstDegreeComponent(id, component, key);
        });
        nquads.push(NQuads.serializeQuad(copy));
      };

      for (var i = 0; i < quads.length; ++i) {
        _loop2(i);
      } // 4) Sort nquads in lexicographical order.


      nquads.sort(); // 5) Return the hash that results from passing the sorted, joined nquads
      // through the hash algorithm.

      var md = new MessageDigest(self.hashAlgorithm);

      for (var _i3 = 0; _i3 < nquads.length; ++_i3) {
        md.update(nquads[_i3]);
      } // TODO: represent as byte buffer instead to cut memory usage in half


      info.hash = md.digest();
      return info.hash;
    } // 4.7) Hash Related Blank Node

  }, {
    key: "hashRelatedBlankNode",
    value: function hashRelatedBlankNode(related, quad, issuer, position) {
      var self = this; // 1) Set the identifier to use for related, preferring first the canonical
      // identifier for related if issued, second the identifier issued by issuer
      // if issued, and last, if necessary, the result of the Hash First Degree
      // Quads algorithm, passing related.

      var id;

      if (self.canonicalIssuer.hasId(related)) {
        id = self.canonicalIssuer.getId(related);
      } else if (issuer.hasId(related)) {
        id = issuer.getId(related);
      } else {
        id = self.hashFirstDegreeQuads(related);
      } // 2) Initialize a string input to the value of position.
      // Note: We use a hash object instead.


      var md = new MessageDigest(self.hashAlgorithm);
      md.update(position); // 3) If position is not g, append <, the value of the predicate in quad,
      // and > to input.

      if (position !== 'g') {
        md.update(self.getRelatedPredicate(quad));
      } // 4) Append identifier to input.


      md.update(id); // 5) Return the hash that results from passing input through the hash
      // algorithm.
      // TODO: represent as byte buffer instead to cut memory usage in half

      return md.digest();
    } // 4.8) Hash N-Degree Quads

  }, {
    key: "hashNDegreeQuads",
    value: function hashNDegreeQuads(id, issuer) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.
      // Note: 2) and 3) handled within `createHashToRelated`

      var md = new MessageDigest(self.hashAlgorithm);
      var hashToRelated = self.createHashToRelated(id, issuer); // 4) Create an empty string, data to hash.
      // Note: We created a hash object `md` above instead.
      // 5) For each related hash to blank node list mapping in hash to related
      // blank nodes map, sorted lexicographically by related hash:

      var hashes = Object.keys(hashToRelated).sort();

      for (var i = 0; i < hashes.length; ++i) {
        // 5.1) Append the related hash to the data to hash.
        var hash = hashes[i];
        md.update(hash); // 5.2) Create a string chosen path.

        var chosenPath = ''; // 5.3) Create an unset chosen issuer variable.

        var chosenIssuer = void 0; // 5.4) For each permutation of blank node list:

        var permutator = new Permutator(hashToRelated[hash]);

        while (permutator.hasNext()) {
          var permutation = permutator.next(); // 5.4.1) Create a copy of issuer, issuer copy.

          var issuerCopy = issuer.clone(); // 5.4.2) Create a string path.

          var path = ''; // 5.4.3) Create a recursion list, to store blank node identifiers
          // that must be recursively processed by this algorithm.

          var recursionList = []; // 5.4.4) For each related in permutation:

          var nextPermutation = false;

          for (var j = 0; j < permutation.length; ++j) {
            // 5.4.4.1) If a canonical identifier has been issued for
            // related, append it to path.
            var related = permutation[j];

            if (self.canonicalIssuer.hasId(related)) {
              path += self.canonicalIssuer.getId(related);
            } else {
              // 5.4.4.2) Otherwise:
              // 5.4.4.2.1) If issuer copy has not issued an identifier for
              // related, append related to recursion list.
              if (!issuerCopy.hasId(related)) {
                recursionList.push(related);
              } // 5.4.4.2.2) Use the Issue Identifier algorithm, passing
              // issuer copy and related and append the result to path.


              path += issuerCopy.getId(related);
            } // 5.4.4.3) If chosen path is not empty and the length of path
            // is greater than or equal to the length of chosen path and
            // path is lexicographically greater than chosen path, then
            // skip to the next permutation.
            // Note: Comparing path length to chosen path length can be optimized
            // away; only compare lexicographically.


            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }

          if (nextPermutation) {
            continue;
          } // 5.4.5) For each related in recursion list:


          for (var _j2 = 0; _j2 < recursionList.length; ++_j2) {
            // 5.4.5.1) Set result to the result of recursively executing
            // the Hash N-Degree Quads algorithm, passing related for
            // identifier and issuer copy for path identifier issuer.
            var _related = recursionList[_j2];
            var result = self.hashNDegreeQuads(_related, issuerCopy); // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer
            // copy and related and append the result to path.

            path += issuerCopy.getId(_related); // 5.4.5.3) Append <, the hash in result, and > to path.

            path += '<' + result.hash + '>'; // 5.4.5.4) Set issuer copy to the identifier issuer in
            // result.

            issuerCopy = result.issuer; // 5.4.5.5) If chosen path is not empty and the length of path
            // is greater than or equal to the length of chosen path and
            // path is lexicographically greater than chosen path, then
            // skip to the next permutation.
            // Note: Comparing path length to chosen path length can be optimized
            // away; only compare lexicographically.

            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }

          if (nextPermutation) {
            continue;
          } // 5.4.6) If chosen path is empty or path is lexicographically
          // less than chosen path, set chosen path to path and chosen
          // issuer to issuer copy.


          if (chosenPath.length === 0 || path < chosenPath) {
            chosenPath = path;
            chosenIssuer = issuerCopy;
          }
        } // 5.5) Append chosen path to data to hash.


        md.update(chosenPath); // 5.6) Replace issuer, by reference, with chosen issuer.

        issuer = chosenIssuer;
      } // 6) Return issuer and the hash that results from passing data to hash
      // through the hash algorithm.


      return {
        hash: md.digest(),
        issuer: issuer
      };
    } // helper for modifying component during Hash First Degree Quads

  }, {
    key: "modifyFirstDegreeComponent",
    value: function modifyFirstDegreeComponent(id, component) {
      if (component.termType !== 'BlankNode') {
        return component;
      }

      component = util.clone(component);
      component.value = component.value === id ? '_:a' : '_:z';
      return component;
    } // helper for getting a related predicate

  }, {
    key: "getRelatedPredicate",
    value: function getRelatedPredicate(quad) {
      return '<' + quad.predicate.value + '>';
    } // helper for creating hash to related blank nodes map

  }, {
    key: "createHashToRelated",
    value: function createHashToRelated(id, issuer) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.

      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to
      // quads map for the key identifier.

      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:

      for (var i = 0; i < quads.length; ++i) {
        // 3.1) For each component in quad, if component is the subject, object,
        // and graph name and it is a blank node that is not identified by
        // identifier:
        var quad = quads[i];

        for (var key in quad) {
          var component = quad[key];

          if (key === 'predicate' || !(component.termType === 'BlankNode' && component.value !== id)) {
            continue;
          } // 3.1.1) Set hash to the result of the Hash Related Blank Node
          // algorithm, passing the blank node identifier for component as
          // related, quad, path identifier issuer as issuer, and position as
          // either s, o, or g based on whether component is a subject, object,
          // graph name, respectively.


          var related = component.value;
          var position = POSITIONS[key];
          var hash = self.hashRelatedBlankNode(related, quad, issuer, position); // 3.1.2) Add a mapping of hash to the blank node identifier for
          // component to hash to related blank nodes map, adding an entry as
          // necessary.

          if (hash in hashToRelated) {
            hashToRelated[hash].push(related);
          } else {
            hashToRelated[hash] = [related];
          }
        }
      }

      return hashToRelated;
    } // helper that iterates over quad components (skips predicate)

  }, {
    key: "forEachComponent",
    value: function forEachComponent(quad, op) {
      for (var key in quad) {
        // skip `predicate`
        if (key === 'predicate') {
          continue;
        }

        op(quad[key], key, quad);
      }
    }
  }]);
  return URDNA2015Sync;
}();

},{"./IdentifierIssuer":145,"./MessageDigest":146,"./NQuads":147,"./Permutator":148,"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],151:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var URDNA2015 = require('./URDNA2015');

var util = require('./util');

module.exports = /*#__PURE__*/function (_URDNA) {
  (0, _inherits2["default"])(URDNA2012, _URDNA);

  var _super = _createSuper(URDNA2012);

  function URDNA2012(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, URDNA2012);
    _this = _super.call(this, options);
    _this.name = 'URGNA2012';
    _this.hashAlgorithm = 'sha1';
    return _this;
  } // helper for modifying component during Hash First Degree Quads


  (0, _createClass2["default"])(URDNA2012, [{
    key: "modifyFirstDegreeComponent",
    value: function modifyFirstDegreeComponent(id, component, key) {
      if (component.termType !== 'BlankNode') {
        return component;
      }

      component = util.clone(component);

      if (key === 'name') {
        component.value = '_:g';
      } else {
        component.value = component.value === id ? '_:a' : '_:z';
      }

      return component;
    } // helper for getting a related predicate

  }, {
    key: "getRelatedPredicate",
    value: function getRelatedPredicate(quad) {
      return quad.predicate.value;
    } // helper for creating hash to related blank nodes map

  }, {
    key: "createHashToRelated",
    value: function createHashToRelated(id, issuer, callback) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.

      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to
      // quads map for the key identifier.

      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:

      self.forEach(quads, function (quad, idx, callback) {
        // 3.1) If the quad's subject is a blank node that does not match
        // identifier, set hash to the result of the Hash Related Blank Node
        // algorithm, passing the blank node identifier for subject as related,
        // quad, path identifier issuer as issuer, and p as position.
        var position;
        var related;

        if (quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {
          related = quad.subject.value;
          position = 'p';
        } else if (quad.object.termType === 'BlankNode' && quad.object.value !== id) {
          // 3.2) Otherwise, if quad's object is a blank node that does not match
          // identifier, to the result of the Hash Related Blank Node algorithm,
          // passing the blank node identifier for object as related, quad, path
          // identifier issuer as issuer, and r as position.
          related = quad.object.value;
          position = 'r';
        } else {
          // 3.3) Otherwise, continue to the next quad.
          return callback();
        } // 3.4) Add a mapping of hash to the blank node identifier for the
        // component that matched (subject or object) to hash to related blank
        // nodes map, adding an entry as necessary.


        self.hashRelatedBlankNode(related, quad, issuer, position, function (err, hash) {
          if (err) {
            return callback(err);
          }

          if (hash in hashToRelated) {
            hashToRelated[hash].push(related);
          } else {
            hashToRelated[hash] = [related];
          }

          callback();
        });
      }, function (err) {
        return callback(err, hashToRelated);
      });
    }
  }]);
  return URDNA2012;
}(URDNA2015);

},{"./URDNA2015":149,"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22}],152:[function(require,module,exports){
/*
 * Copyright (c) 2016 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var URDNA2015Sync = require('./URDNA2015Sync');

var util = require('./util');

module.exports = /*#__PURE__*/function (_URDNA2015Sync) {
  (0, _inherits2["default"])(URDNA2012Sync, _URDNA2015Sync);

  var _super = _createSuper(URDNA2012Sync);

  function URDNA2012Sync() {
    var _this;

    (0, _classCallCheck2["default"])(this, URDNA2012Sync);
    _this = _super.call(this);
    _this.name = 'URGNA2012';
    _this.hashAlgorithm = 'sha1';
    return _this;
  } // helper for modifying component during Hash First Degree Quads


  (0, _createClass2["default"])(URDNA2012Sync, [{
    key: "modifyFirstDegreeComponent",
    value: function modifyFirstDegreeComponent(id, component, key) {
      if (component.termType !== 'BlankNode') {
        return component;
      }

      component = util.clone(component);

      if (key === 'name') {
        component.value = '_:g';
      } else {
        component.value = component.value === id ? '_:a' : '_:z';
      }

      return component;
    } // helper for getting a related predicate

  }, {
    key: "getRelatedPredicate",
    value: function getRelatedPredicate(quad) {
      return quad.predicate.value;
    } // helper for creating hash to related blank nodes map

  }, {
    key: "createHashToRelated",
    value: function createHashToRelated(id, issuer) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.

      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to
      // quads map for the key identifier.

      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:

      for (var i = 0; i < quads.length; ++i) {
        // 3.1) If the quad's subject is a blank node that does not match
        // identifier, set hash to the result of the Hash Related Blank Node
        // algorithm, passing the blank node identifier for subject as related,
        // quad, path identifier issuer as issuer, and p as position.
        var quad = quads[i];
        var position = void 0;
        var related = void 0;

        if (quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {
          related = quad.subject.value;
          position = 'p';
        } else if (quad.object.termType === 'BlankNode' && quad.object.value !== id) {
          // 3.2) Otherwise, if quad's object is a blank node that does not match
          // identifier, to the result of the Hash Related Blank Node algorithm,
          // passing the blank node identifier for object as related, quad, path
          // identifier issuer as issuer, and r as position.
          related = quad.object.value;
          position = 'r';
        } else {
          // 3.3) Otherwise, continue to the next quad.
          continue;
        } // 3.4) Add a mapping of hash to the blank node identifier for the
        // component that matched (subject or object) to hash to related blank
        // nodes map, adding an entry as necessary.


        var hash = self.hashRelatedBlankNode(related, quad, issuer, position);

        if (hash in hashToRelated) {
          hashToRelated[hash].push(related);
        } else {
          hashToRelated[hash] = [related];
        }
      }

      return hashToRelated;
    }
  }]);
  return URDNA2012Sync;
}(URDNA2015Sync);

},{"./URDNA2015Sync":150,"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22}],153:[function(require,module,exports){
/**
 * An implementation of the RDF Dataset Normalization specification.
 * This library works in the browser and node.js.
 *
 * BSD 3-Clause License
 * Copyright (c) 2016-2017 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var util = require('./util');

var URDNA2015 = require('./URDNA2015');

var URGNA2012 = require('./URGNA2012');

var URDNA2015Sync = require('./URDNA2015Sync');

var URGNA2012Sync = require('./URGNA2012Sync'); // optional native support


var rdfCanonizeNative;

try {
  rdfCanonizeNative = require('rdf-canonize-native');
} catch (e) {}

var api = {};
module.exports = api; // expose helpers

api.NQuads = require('./NQuads');
api.IdentifierIssuer = require('./IdentifierIssuer');
/**
 * Get or set native API.
 *
 * @param api the native API.
 *
 * @return the currently set native API.
 */

api._rdfCanonizeNative = function (api) {
  if (api) {
    rdfCanonizeNative = api;
  }

  return rdfCanonizeNative;
};
/**
 * Asynchronously canonizes an RDF dataset.
 *
 * @param dataset the dataset to canonize.
 * @param options the options to use:
 *          algorithm the canonicalization algorithm to use, `URDNA2015` or
 *            `URGNA2012`.
 *          [useNative] use native implementation (default: false).
 * @param [callback(err, canonical)] called once the operation completes.
 *
 * @return a Promise that resolves to the canonicalized RDF Dataset.
 */


api.canonize = util.callbackify( /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(dataset, options) {
    var callback, promise;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            promise = new Promise(function (resolve, reject) {
              callback = function callback(err, canonical) {
                if (err) {
                  return reject(err);
                }
                /*if(options.format === 'application/n-quads') {
                  canonical = canonical.join('');
                }
                canonical = _parseNQuads(canonical.join(''));*/


                resolve(canonical);
              };
            }); // back-compat with legacy dataset

            if (!Array.isArray(dataset)) {
              dataset = api.NQuads.legacyDatasetToQuads(dataset);
            } // TODO: convert algorithms to Promise-based async


            if (!options.useNative) {
              _context.next = 10;
              break;
            }

            if (!rdfCanonizeNative) {
              _context.next = 7;
              break;
            }

            rdfCanonizeNative.canonize(dataset, options, callback);
            _context.next = 8;
            break;

          case 7:
            throw new Error('rdf-canonize-native not available');

          case 8:
            _context.next = 23;
            break;

          case 10:
            if (!(options.algorithm === 'URDNA2015')) {
              _context.next = 14;
              break;
            }

            new URDNA2015(options).main(dataset, callback);
            _context.next = 23;
            break;

          case 14:
            if (!(options.algorithm === 'URGNA2012')) {
              _context.next = 18;
              break;
            }

            new URGNA2012(options).main(dataset, callback);
            _context.next = 23;
            break;

          case 18:
            if ('algorithm' in options) {
              _context.next = 22;
              break;
            }

            throw new Error('No RDF Dataset Canonicalization algorithm specified.');

          case 22:
            throw new Error('Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);

          case 23:
            return _context.abrupt("return", promise);

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}());
/**
 * Synchronously canonizes an RDF dataset.
 *
 * @param dataset the dataset to canonize.
 * @param options the options to use:
 *          algorithm the canonicalization algorithm to use, `URDNA2015` or
 *            `URGNA2012`.
 *          [useNative] use native implementation (default: false).
 *
 * @return the RDF dataset in canonical form.
 */

api.canonizeSync = function (dataset, options) {
  // back-compat with legacy dataset
  if (!Array.isArray(dataset)) {
    dataset = api.NQuads.legacyDatasetToQuads(dataset);
  }

  if (options.useNative) {
    if (rdfCanonizeNative) {
      return rdfCanonizeNative.canonizeSync(dataset, options);
    }

    throw new Error('rdf-canonize-native not available');
  }

  if (options.algorithm === 'URDNA2015') {
    return new URDNA2015Sync(options).main(dataset);
  } else if (options.algorithm === 'URGNA2012') {
    return new URGNA2012Sync(options).main(dataset);
  }

  if (!('algorithm' in options)) {
    throw new Error('No RDF Dataset Canonicalization algorithm specified.');
  }

  throw new Error('Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);
};

},{"./IdentifierIssuer":145,"./NQuads":147,"./URDNA2015":149,"./URDNA2015Sync":150,"./URGNA2012":151,"./URGNA2012Sync":152,"./util":154,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30,"rdf-canonize-native":58}],154:[function(require,module,exports){
(function (process,setImmediate){(function (){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var api = {};
module.exports = api; // define setImmediate and nextTick
//// nextTick implementation with browser-compatible fallback ////
// from https://github.com/caolan/async/blob/master/lib/async.js
// capture the global reference to guard against fakeTimer mocks

var _setImmediate = typeof setImmediate === 'function' && setImmediate;

var _delay = _setImmediate ? // not a direct alias (for IE10 compatibility)
function (fn) {
  return _setImmediate(fn);
} : function (fn) {
  return setTimeout(fn, 0);
};

if ((typeof process === "undefined" ? "undefined" : (0, _typeof2["default"])(process)) === 'object' && typeof process.nextTick === 'function') {
  api.nextTick = process.nextTick;
} else {
  api.nextTick = _delay;
}

api.setImmediate = _setImmediate ? _delay : api.nextTick;
/**
 * Clones an object, array, or string/number. If a typed JavaScript object
 * is given, such as a Date, it will be converted to a string.
 *
 * @param value the value to clone.
 *
 * @return the cloned value.
 */

api.clone = function (value) {
  if (value && (0, _typeof2["default"])(value) === 'object') {
    var rval;

    if (Array.isArray(value)) {
      rval = [];

      for (var i = 0; i < value.length; ++i) {
        rval[i] = api.clone(value[i]);
      }
    } else if (api.isObject(value)) {
      rval = {};

      for (var key in value) {
        rval[key] = api.clone(value[key]);
      }
    } else {
      rval = value.toString();
    }

    return rval;
  }

  return value;
};
/**
 * Returns true if the given value is an Object.
 *
 * @param v the value to check.
 *
 * @return true if the value is an Object, false if not.
 */


api.isObject = function (v) {
  return Object.prototype.toString.call(v) === '[object Object]';
};
/**
 * Returns true if the given value is undefined.
 *
 * @param v the value to check.
 *
 * @return true if the value is undefined, false if not.
 */


api.isUndefined = function (v) {
  return typeof v === 'undefined';
};

api.callbackify = function (fn) {
  return /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
    var _len,
        args,
        _key,
        callback,
        result,
        _args = arguments;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = _args[_key];
            }

            callback = args[args.length - 1];

            if (typeof callback === 'function') {
              args.pop();
            }

            _context.prev = 3;
            _context.next = 6;
            return fn.apply(null, args);

          case 6:
            result = _context.sent;
            _context.next = 14;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](3);

            if (!(typeof callback === 'function')) {
              _context.next = 13;
              break;
            }

            return _context.abrupt("return", _invokeCallback(callback, _context.t0));

          case 13:
            throw _context.t0;

          case 14:
            if (!(typeof callback === 'function')) {
              _context.next = 16;
              break;
            }

            return _context.abrupt("return", _invokeCallback(callback, null, result));

          case 16:
            return _context.abrupt("return", result);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 9]]);
  }));
};

function _invokeCallback(callback, err, result) {
  try {
    return callback(err, result);
  } catch (unhandledError) {
    // throw unhandled errors to prevent "unhandled rejected promise"
    // and simulate what would have happened in a promiseless API
    process.nextTick(function () {
      throw unhandledError;
    });
  }
}

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

},{"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27,"@babel/runtime/regenerator":30,"_process":142,"timers":193}],155:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./lib/BlankNode"), exports);

__exportStar(require("./lib/DataFactory"), exports);

__exportStar(require("./lib/DefaultGraph"), exports);

__exportStar(require("./lib/Literal"), exports);

__exportStar(require("./lib/NamedNode"), exports);

__exportStar(require("./lib/Quad"), exports);

__exportStar(require("./lib/Variable"), exports);

},{"./lib/BlankNode":156,"./lib/DataFactory":157,"./lib/DefaultGraph":158,"./lib/Literal":159,"./lib/NamedNode":160,"./lib/Quad":161,"./lib/Variable":162}],156:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BlankNode = void 0;
/**
 * A term that represents an RDF blank node with a label.
 */

var BlankNode = /*#__PURE__*/function () {
  function BlankNode(value) {
    (0, _classCallCheck2["default"])(this, BlankNode);
    this.termType = 'BlankNode';
    this.value = value;
  }

  (0, _createClass2["default"])(BlankNode, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'BlankNode' && other.value === this.value;
    }
  }]);
  return BlankNode;
}();

exports.BlankNode = BlankNode;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],157:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataFactory = void 0;

var BlankNode_1 = require("./BlankNode");

var DefaultGraph_1 = require("./DefaultGraph");

var Literal_1 = require("./Literal");

var NamedNode_1 = require("./NamedNode");

var Quad_1 = require("./Quad");

var Variable_1 = require("./Variable");

var dataFactoryCounter = 0;
/**
 * A factory for instantiating RDF terms and quads.
 */

var DataFactory = /*#__PURE__*/function () {
  function DataFactory(options) {
    (0, _classCallCheck2["default"])(this, DataFactory);
    this.blankNodeCounter = 0;
    options = options || {};
    this.blankNodePrefix = options.blankNodePrefix || "df_".concat(dataFactoryCounter++, "_");
  }
  /**
   * @param value The IRI for the named node.
   * @return A new instance of NamedNode.
   * @see NamedNode
   */


  (0, _createClass2["default"])(DataFactory, [{
    key: "namedNode",
    value: function namedNode(value) {
      return new NamedNode_1.NamedNode(value);
    }
    /**
     * @param value The optional blank node identifier.
     * @return A new instance of BlankNode.
     *         If the `value` parameter is undefined a new identifier
     *         for the blank node is generated for each call.
     * @see BlankNode
     */

  }, {
    key: "blankNode",
    value: function blankNode(value) {
      return new BlankNode_1.BlankNode(value || "".concat(this.blankNodePrefix).concat(this.blankNodeCounter++));
    }
    /**
     * @param value              The literal value.
     * @param languageOrDatatype The optional language or datatype.
     *                           If `languageOrDatatype` is a NamedNode,
     *                           then it is used for the value of `NamedNode.datatype`.
     *                           Otherwise `languageOrDatatype` is used for the value
     *                           of `NamedNode.language`.
     * @return A new instance of Literal.
     * @see Literal
     */

  }, {
    key: "literal",
    value: function literal(value, languageOrDatatype) {
      return new Literal_1.Literal(value, languageOrDatatype);
    }
    /**
     * This method is optional.
     * @param value The variable name
     * @return A new instance of Variable.
     * @see Variable
     */

  }, {
    key: "variable",
    value: function variable(value) {
      return new Variable_1.Variable(value);
    }
    /**
     * @return An instance of DefaultGraph.
     */

  }, {
    key: "defaultGraph",
    value: function defaultGraph() {
      return DefaultGraph_1.DefaultGraph.INSTANCE;
    }
    /**
     * @param subject   The quad subject term.
     * @param predicate The quad predicate term.
     * @param object    The quad object term.
     * @param graph     The quad graph term.
     * @return A new instance of Quad.
     * @see Quad
     */

  }, {
    key: "quad",
    value: function quad(subject, predicate, object, graph) {
      return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());
    }
    /**
     * Create a deep copy of the given term using this data factory.
     * @param original An RDF term.
     * @return A deep copy of the given term.
     */

  }, {
    key: "fromTerm",
    value: function fromTerm(original) {
      // TODO: remove nasty any casts when this TS bug has been fixed:
      //  https://github.com/microsoft/TypeScript/issues/26933
      switch (original.termType) {
        case 'NamedNode':
          return this.namedNode(original.value);

        case 'BlankNode':
          return this.blankNode(original.value);

        case 'Literal':
          if (original.language) {
            return this.literal(original.value, original.language);
          }

          if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {
            return this.literal(original.value, this.fromTerm(original.datatype));
          }

          return this.literal(original.value);

        case 'Variable':
          return this.variable(original.value);

        case 'DefaultGraph':
          return this.defaultGraph();

        case 'Quad':
          return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));
      }
    }
    /**
     * Create a deep copy of the given quad using this data factory.
     * @param original An RDF quad.
     * @return A deep copy of the given quad.
     */

  }, {
    key: "fromQuad",
    value: function fromQuad(original) {
      return this.fromTerm(original);
    }
    /**
     * Reset the internal blank node counter.
     */

  }, {
    key: "resetBlankNodeCounter",
    value: function resetBlankNodeCounter() {
      this.blankNodeCounter = 0;
    }
  }]);
  return DataFactory;
}();

exports.DataFactory = DataFactory;

},{"./BlankNode":156,"./DefaultGraph":158,"./Literal":159,"./NamedNode":160,"./Quad":161,"./Variable":162,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],158:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultGraph = void 0;
/**
 * A singleton term instance that represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */

var DefaultGraph = /*#__PURE__*/function () {
  function DefaultGraph() {
    (0, _classCallCheck2["default"])(this, DefaultGraph);
    this.termType = 'DefaultGraph';
    this.value = ''; // Private constructor
  }

  (0, _createClass2["default"])(DefaultGraph, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'DefaultGraph';
    }
  }]);
  return DefaultGraph;
}();

exports.DefaultGraph = DefaultGraph;
DefaultGraph.INSTANCE = new DefaultGraph();

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],159:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Literal = void 0;

var NamedNode_1 = require("./NamedNode");
/**
 * A term that represents an RDF literal, containing a string with an optional language tag or datatype.
 */


var Literal = /*#__PURE__*/function () {
  function Literal(value, languageOrDatatype) {
    (0, _classCallCheck2["default"])(this, Literal);
    this.termType = 'Literal';
    this.value = value;

    if (typeof languageOrDatatype === 'string') {
      this.language = languageOrDatatype;
      this.datatype = Literal.RDF_LANGUAGE_STRING;
    } else if (languageOrDatatype) {
      this.language = '';
      this.datatype = languageOrDatatype;
    } else {
      this.language = '';
      this.datatype = Literal.XSD_STRING;
    }
  }

  (0, _createClass2["default"])(Literal, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'Literal' && other.value === this.value && other.language === this.language && other.datatype.equals(this.datatype);
    }
  }]);
  return Literal;
}();

exports.Literal = Literal;
Literal.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
Literal.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');

},{"./NamedNode":160,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],160:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NamedNode = void 0;
/**
 * A term that contains an IRI.
 */

var NamedNode = /*#__PURE__*/function () {
  function NamedNode(value) {
    (0, _classCallCheck2["default"])(this, NamedNode);
    this.termType = 'NamedNode';
    this.value = value;
  }

  (0, _createClass2["default"])(NamedNode, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'NamedNode' && other.value === this.value;
    }
  }]);
  return NamedNode;
}();

exports.NamedNode = NamedNode;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],161:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Quad = void 0;
/**
 * An instance of DefaultGraph represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */

var Quad = /*#__PURE__*/function () {
  function Quad(subject, predicate, object, graph) {
    (0, _classCallCheck2["default"])(this, Quad);
    this.termType = 'Quad';
    this.value = '';
    this.subject = subject;
    this.predicate = predicate;
    this.object = object;
    this.graph = graph;
  }

  (0, _createClass2["default"])(Quad, [{
    key: "equals",
    value: function equals(other) {
      // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.
      return !!other && (other.termType === 'Quad' || !other.termType) && this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph);
    }
  }]);
  return Quad;
}();

exports.Quad = Quad;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],162:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Variable = void 0;
/**
 * A term that represents a variable.
 */

var Variable = /*#__PURE__*/function () {
  function Variable(value) {
    (0, _classCallCheck2["default"])(this, Variable);
    this.termType = 'Variable';
    this.value = value;
  }

  (0, _createClass2["default"])(Variable, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'Variable' && other.value === this.value;
    }
  }]);
  return Variable;
}();

exports.Variable = Variable;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],163:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./lib/IActiveTag"), exports);

__exportStar(require("./lib/IHtmlParseListener"), exports);

__exportStar(require("./lib/IRdfaPattern"), exports);

__exportStar(require("./lib/RdfaParser"), exports);

__exportStar(require("./lib/RdfaProfile"), exports);

__exportStar(require("./lib/Util"), exports);

},{"./lib/IActiveTag":164,"./lib/IHtmlParseListener":165,"./lib/IRdfaPattern":166,"./lib/RdfaParser":167,"./lib/RdfaProfile":168,"./lib/Util":169}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],165:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],167:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RdfaParser = void 0;

var htmlparser2_1 = require("htmlparser2");

var stream_1 = require("stream");

var INITIAL_CONTEXT_XHTML = require("./initial-context-xhtml.json");

var INITIAL_CONTEXT = require("./initial-context.json");

var RdfaProfile_1 = require("./RdfaProfile");

var Util_1 = require("./Util");
/**
 * A stream transformer that parses RDFa (text) streams to an {@link RDF.Stream}.
 */


var RdfaParser = /*#__PURE__*/function (_stream_1$Transform) {
  (0, _inherits2["default"])(RdfaParser, _stream_1$Transform);

  var _super = _createSuper(RdfaParser);

  function RdfaParser(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, RdfaParser);
    _this = _super.call(this, {
      readableObjectMode: true
    });
    _this.activeTagStack = [];
    options = options || {};
    _this.options = options;
    _this.util = new Util_1.Util(options.dataFactory, options.baseIRI);
    _this.defaultGraph = options.defaultGraph || _this.util.dataFactory.defaultGraph();
    var profile = options.contentType ? Util_1.Util.contentTypeToProfile(options.contentType) : options.profile || '';
    _this.features = options.features || RdfaProfile_1.RDFA_FEATURES[profile];
    _this.htmlParseListener = options.htmlParseListener;
    _this.rdfaPatterns = _this.features.copyRdfaPatterns ? {} : null;
    _this.pendingRdfaPatternCopies = _this.features.copyRdfaPatterns ? {} : null;
    _this.parser = _this.initializeParser(profile === 'xml');

    _this.activeTagStack.push({
      incompleteTriples: [],
      inlist: false,
      language: options.language,
      listMapping: {},
      listMappingLocal: {},
      name: '',
      prefixesAll: Object.assign(Object.assign({}, INITIAL_CONTEXT['@context']), _this.features.xhtmlInitialContext ? INITIAL_CONTEXT_XHTML['@context'] : {}),
      prefixesCustom: {},
      skipElement: false,
      vocab: options.vocab
    });

    return _this;
  }
  /**
   * Parses the given text stream into a quad stream.
   * @param {NodeJS.EventEmitter} stream A text stream.
   * @return {RDF.Stream} A quad stream.
   */


  (0, _createClass2["default"])(RdfaParser, [{
    key: "import",
    value: function _import(stream) {
      var output = new stream_1.PassThrough({
        readableObjectMode: true
      });
      stream.on('error', function (error) {
        return parsed.emit('error', error);
      });
      stream.on('data', function (data) {
        return output.push(data);
      });
      stream.on('end', function () {
        return output.push(null);
      });
      var parsed = output.pipe(new RdfaParser(this.options));
      return parsed;
    }
  }, {
    key: "_transform",
    value: function _transform(chunk, encoding, callback) {
      this.parser.write(chunk);
      callback();
    }
  }, {
    key: "_flush",
    value: function _flush(callback) {
      this.parser.end();
      callback();
    }
  }, {
    key: "onTagOpen",
    value: function onTagOpen(name, attributes) {
      // Determine the parent tag (ignore skipped tags)
      var parentTagI = this.activeTagStack.length - 1;

      while (parentTagI > 0 && this.activeTagStack[parentTagI].skipElement) {
        parentTagI--;
      }

      var parentTag = this.activeTagStack[parentTagI]; // If we skipped a tag, make sure we DO use the lang, prefixes and vocab of the skipped tag

      if (parentTagI !== this.activeTagStack.length - 1) {
        parentTag = Object.assign(Object.assign({}, parentTag), {
          language: this.activeTagStack[this.activeTagStack.length - 1].language,
          prefixesAll: this.activeTagStack[this.activeTagStack.length - 1].prefixesAll,
          prefixesCustom: this.activeTagStack[this.activeTagStack.length - 1].prefixesCustom,
          vocab: this.activeTagStack[this.activeTagStack.length - 1].vocab
        });
      } // Create a new active tag and inherit language scope and baseIRI from parent


      var activeTag = {
        collectChildTags: parentTag.collectChildTags,
        incompleteTriples: [],
        inlist: 'inlist' in attributes,
        listMapping: [],
        listMappingLocal: parentTag.listMapping,
        localBaseIRI: parentTag.localBaseIRI,
        name: name,
        prefixesAll: null,
        prefixesCustom: null,
        skipElement: false
      };
      this.activeTagStack.push(activeTag); // Save the tag contents if needed

      if (activeTag.collectChildTags) {
        // Add explicitly defined xmlns, xmlns:* and prefixes to attributes, as required by the spec (Step 11, note)
        // Sort prefixes alphabetically for deterministic namespace declaration order
        var _iterator = _createForOfIteratorHelper(Object.keys(parentTag.prefixesCustom).sort()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var prefix = _step.value;
            var suffix = parentTag.prefixesCustom[prefix];
            var attributeKey = prefix === '' ? 'xmlns' : 'xmlns:' + prefix;

            if (!(attributeKey in attributes)) {
              attributes[attributeKey] = suffix;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var attributesSerialized = Object.keys(attributes).map(function (key) {
          return "".concat(key, "=\"").concat(attributes[key], "\"");
        }).join(' ');
        activeTag.text = ["<".concat(name).concat(attributesSerialized ? ' ' + attributesSerialized : '', ">")];

        if (this.features.skipHandlingXmlLiteralChildren) {
          return;
        }
      }

      var allowTermsInRelPredicates = true;
      var allowTermsInRevPredicates = true;

      if (this.features.onlyAllowUriRelRevIfProperty) {
        // Ignore illegal rel/rev values when property is present
        if ('property' in attributes && 'rel' in attributes) {
          allowTermsInRelPredicates = false;

          if (attributes.rel.indexOf(':') < 0) {
            delete attributes.rel;
          }
        }

        if ('property' in attributes && 'rev' in attributes) {
          allowTermsInRevPredicates = false;

          if (attributes.rev.indexOf(':') < 0) {
            delete attributes.rev;
          }
        }
      }

      if (this.features.copyRdfaPatterns) {
        // Save the tag if needed
        if (parentTag.collectedPatternTag) {
          var patternTag = {
            attributes: attributes,
            children: [],
            name: name,
            referenced: false,
            rootPattern: false,
            text: []
          };
          parentTag.collectedPatternTag.children.push(patternTag);
          activeTag.collectedPatternTag = patternTag;
          return;
        } // Store tags with type rdfa:Pattern as patterns


        if (attributes["typeof"] === 'rdfa:Pattern') {
          activeTag.collectedPatternTag = {
            attributes: attributes,
            children: [],
            name: name,
            parentTag: parentTag,
            referenced: false,
            rootPattern: true,
            text: []
          };
          return;
        } // Instantiate patterns on rdfa:copy


        if (attributes.property === 'rdfa:copy') {
          var copyTargetPatternId = attributes.resource || attributes.href || attributes.src;

          if (this.rdfaPatterns[copyTargetPatternId]) {
            this.emitPatternCopy(parentTag, this.rdfaPatterns[copyTargetPatternId], copyTargetPatternId);
          } else {
            if (!this.pendingRdfaPatternCopies[copyTargetPatternId]) {
              this.pendingRdfaPatternCopies[copyTargetPatternId] = [];
            }

            this.pendingRdfaPatternCopies[copyTargetPatternId].push(parentTag);
          }

          return;
        }
      } // <base> tags override the baseIRI of the whole document


      if (this.features.baseTag && name === 'base' && attributes.href) {
        this.util.baseIRI = this.util.getBaseIRI(attributes.href);
      } // xml:base attributes override the baseIRI of the current tag and children


      if (this.features.xmlBase && attributes['xml:base']) {
        activeTag.localBaseIRI = this.util.getBaseIRI(attributes['xml:base']);
      } // <time> tags set an initial datatype


      if (this.features.timeTag && name === 'time' && !attributes.datatype) {
        activeTag.interpretObjectAsTime = true;
      } // Processing based on https://www.w3.org/TR/rdfa-core/#s_rdfaindetail
      // 1: initialize values


      var newSubject;
      var currentObjectResource;
      var typedResource; // 2: handle vocab attribute to set active vocabulary
      // Vocab sets the active vocabulary

      if ('vocab' in attributes) {
        if (attributes.vocab) {
          activeTag.vocab = attributes.vocab;
          this.emitTriple(this.util.getBaseIriTerm(activeTag), this.util.dataFactory.namedNode(Util_1.Util.RDFA + 'usesVocabulary'), this.util.dataFactory.namedNode(activeTag.vocab));
        } else {
          // If vocab is set to '', then we fallback to the root vocab as defined via the parser constructor
          activeTag.vocab = this.activeTagStack[0].vocab;
        }
      } else {
        activeTag.vocab = parentTag.vocab;
      } // 3: handle prefixes


      activeTag.prefixesCustom = Util_1.Util.parsePrefixes(attributes, parentTag.prefixesCustom, this.features.xmlnsPrefixMappings);
      activeTag.prefixesAll = Object.keys(activeTag.prefixesCustom).length > 0 ? Object.assign(Object.assign({}, parentTag.prefixesAll), activeTag.prefixesCustom) : parentTag.prefixesAll; // Handle role attribute

      if (this.features.roleAttribute && attributes.role) {
        var roleSubject = attributes.id ? this.util.createIri('#' + attributes.id, activeTag, false, false, false) : this.util.createBlankNode(); // Temporarily override vocab

        var vocabOld = activeTag.vocab;
        activeTag.vocab = 'http://www.w3.org/1999/xhtml/vocab#';

        var _iterator2 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.role, activeTag, true, false)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var role = _step2.value;
            this.emitTriple(roleSubject, this.util.dataFactory.namedNode('http://www.w3.org/1999/xhtml/vocab#role'), role);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        activeTag.vocab = vocabOld;
      } // 4: handle language
      // Save language attribute value in active tag


      if ('xml:lang' in attributes || this.features.langAttribute && 'lang' in attributes) {
        activeTag.language = attributes['xml:lang'] || attributes.lang;
      } else {
        activeTag.language = parentTag.language;
      }

      var isRootTag = this.activeTagStack.length === 2;

      if (!('rel' in attributes) && !('rev' in attributes)) {
        // 5: Determine the new subject when rel and rev are not present
        if ('property' in attributes && !('content' in attributes) && !('datatype' in attributes)) {
          // 5.1: property is present, but not content and datatype
          // Determine new subject
          if ('about' in attributes) {
            newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);
            activeTag.explicitNewSubject = !!newSubject;
          } else if (isRootTag) {
            newSubject = true;
          } else if (parentTag.object) {
            newSubject = parentTag.object;
          } // Determine type


          if ('typeof' in attributes) {
            if ('about' in attributes) {
              typedResource = this.util.createIri(attributes.about, activeTag, false, true, true);
            }

            if (!typedResource && isRootTag) {
              typedResource = true;
            }

            if (!typedResource && 'resource' in attributes) {
              typedResource = this.util.createIri(attributes.resource, activeTag, false, true, true);
            }

            if (!typedResource && ('href' in attributes || 'src' in attributes)) {
              typedResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);
            }

            if (!typedResource && this.isInheritSubjectInHeadBody(name)) {
              typedResource = newSubject;
            }

            if (!typedResource) {
              typedResource = this.util.createBlankNode();
            }

            currentObjectResource = typedResource;
          }
        } else {
          // 5.2
          if ('about' in attributes || 'resource' in attributes) {
            newSubject = this.util.createIri(attributes.about || attributes.resource, activeTag, false, true, true);
            activeTag.explicitNewSubject = !!newSubject;
          }

          if (!newSubject && ('href' in attributes || 'src' in attributes)) {
            newSubject = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);
            activeTag.explicitNewSubject = !!newSubject;
          }

          if (!newSubject) {
            if (isRootTag) {
              newSubject = true;
            } else if (this.isInheritSubjectInHeadBody(name)) {
              newSubject = parentTag.object;
            } else if ('typeof' in attributes) {
              newSubject = this.util.createBlankNode();
              activeTag.explicitNewSubject = true;
            } else if (parentTag.object) {
              newSubject = parentTag.object;

              if (!('property' in attributes)) {
                activeTag.skipElement = true;
              }
            }
          } // Determine type


          if ('typeof' in attributes) {
            typedResource = newSubject;
          }
        }
      } else {
        // either rel or rev is present
        // 6: Determine the new subject when rel or rev are present
        // Define new subject
        if ('about' in attributes) {
          newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);
          activeTag.explicitNewSubject = !!newSubject;

          if ('typeof' in attributes) {
            typedResource = newSubject;
          }
        } else if (isRootTag) {
          newSubject = true;
        } else if (parentTag.object) {
          newSubject = parentTag.object;
        } // Define object


        if ('resource' in attributes) {
          currentObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);
        }

        if (!currentObjectResource) {
          if ('href' in attributes || 'src' in attributes) {
            currentObjectResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);
          } else if ('typeof' in attributes && !('about' in attributes) && !this.isInheritSubjectInHeadBody(name)) {
            currentObjectResource = this.util.createBlankNode();
          }
        } // Set typed resource


        if ('typeof' in attributes && !('about' in attributes)) {
          if (this.isInheritSubjectInHeadBody(name)) {
            typedResource = newSubject;
          } else {
            typedResource = currentObjectResource;
          }
        }
      } // 7: If a typed resource was defined, emit it as a triple


      if (typedResource) {
        var _iterator3 = _createForOfIteratorHelper(this.util.createVocabIris(attributes["typeof"], activeTag, true, true)),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var type = _step3.value;
            this.emitTriple(this.util.getResourceOrBaseIri(typedResource, activeTag), this.util.dataFactory.namedNode(Util_1.Util.RDF + 'type'), type);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } // 8: Reset list mapping if we have a new subject


      if (newSubject) {
        activeTag.listMapping = {};
      } // 9: If an object was defined, emit triples for it


      if (currentObjectResource) {
        // Handle list mapping
        if ('rel' in attributes && 'inlist' in attributes) {
          var _iterator4 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var predicate = _step4.value;
              this.addListMapping(activeTag, newSubject, predicate, currentObjectResource);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        } // Determine predicates using rel or rev (unless rel and inlist are present)


        if (!('rel' in attributes && 'inlist' in attributes)) {
          if ('rel' in attributes) {
            var _iterator5 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var _predicate = _step5.value;
                this.emitTriple(this.util.getResourceOrBaseIri(newSubject, activeTag), _predicate, this.util.getResourceOrBaseIri(currentObjectResource, activeTag));
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }

          if ('rev' in attributes) {
            var _iterator6 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates, false)),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _predicate2 = _step6.value;
                this.emitTriple(this.util.getResourceOrBaseIri(currentObjectResource, activeTag), _predicate2, this.util.getResourceOrBaseIri(newSubject, activeTag));
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
        }
      } // 10: Store incomplete triples if we don't have an object, but we do have predicates


      if (!currentObjectResource) {
        if ('rel' in attributes) {
          if ('inlist' in attributes) {
            var _iterator7 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)),
                _step7;

            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var _predicate3 = _step7.value;
                this.addListMapping(activeTag, newSubject, _predicate3, null);
                activeTag.incompleteTriples.push({
                  predicate: _predicate3,
                  reverse: false,
                  list: true
                });
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          } else {
            var _iterator8 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)),
                _step8;

            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                var _predicate4 = _step8.value;
                activeTag.incompleteTriples.push({
                  predicate: _predicate4,
                  reverse: false
                });
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
          }
        }

        if ('rev' in attributes) {
          var _iterator9 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates, false)),
              _step9;

          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var _predicate5 = _step9.value;
              activeTag.incompleteTriples.push({
                predicate: _predicate5,
                reverse: true
              });
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        } // Set a blank node object, so the children can make use of this when completing the triples


        if (activeTag.incompleteTriples.length > 0) {
          currentObjectResource = this.util.createBlankNode();
        }
      } // 11: Determine current property value


      if ('property' in attributes) {
        // Create predicates
        activeTag.predicates = this.util.createVocabIris(attributes.property, activeTag, true, false); // Save datatype attribute value in active tag

        var localObjectResource;

        if ('datatype' in attributes) {
          activeTag.datatype = this.util.createIri(attributes.datatype, activeTag, true, true, false);

          if (activeTag.datatype && (activeTag.datatype.value === Util_1.Util.RDF + 'XMLLiteral' || this.features.htmlDatatype && activeTag.datatype.value === Util_1.Util.RDF + 'HTML')) {
            activeTag.collectChildTags = true;
          }
        } else {
          // Try to determine resource
          if (!('rev' in attributes) && !('rel' in attributes) && !('content' in attributes)) {
            if ('resource' in attributes) {
              localObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);
            }

            if (!localObjectResource && 'href' in attributes) {
              localObjectResource = this.util.createIri(attributes.href, activeTag, false, false, true);
            }

            if (!localObjectResource && 'src' in attributes) {
              localObjectResource = this.util.createIri(attributes.src, activeTag, false, false, true);
            }
          }

          if ('typeof' in attributes && !('about' in attributes)) {
            localObjectResource = typedResource;
          }
        }

        if ('content' in attributes) {
          // Emit triples based on content attribute has preference over text content
          var object = this.util.createLiteral(attributes.content, activeTag);

          if ('inlist' in attributes) {
            var _iterator10 = _createForOfIteratorHelper(activeTag.predicates),
                _step10;

            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var _predicate6 = _step10.value;
                this.addListMapping(activeTag, newSubject, _predicate6, object);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
          } else {
            var subject = this.util.getResourceOrBaseIri(newSubject, activeTag);

            var _iterator11 = _createForOfIteratorHelper(activeTag.predicates),
                _step11;

            try {
              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                var _predicate7 = _step11.value;
                this.emitTriple(subject, _predicate7, object);
              }
            } catch (err) {
              _iterator11.e(err);
            } finally {
              _iterator11.f();
            }
          } // Unset predicate to avoid text contents to produce new triples


          activeTag.predicates = null;
        } else if (this.features.datetimeAttribute && 'datetime' in attributes) {
          activeTag.interpretObjectAsTime = true; // Datetime attribute on time tag has preference over text content

          var _object = this.util.createLiteral(attributes.datetime, activeTag);

          if ('inlist' in attributes) {
            var _iterator12 = _createForOfIteratorHelper(activeTag.predicates),
                _step12;

            try {
              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                var _predicate8 = _step12.value;
                this.addListMapping(activeTag, newSubject, _predicate8, _object);
              }
            } catch (err) {
              _iterator12.e(err);
            } finally {
              _iterator12.f();
            }
          } else {
            var _subject = this.util.getResourceOrBaseIri(newSubject, activeTag);

            var _iterator13 = _createForOfIteratorHelper(activeTag.predicates),
                _step13;

            try {
              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                var _predicate9 = _step13.value;
                this.emitTriple(_subject, _predicate9, _object);
              }
            } catch (err) {
              _iterator13.e(err);
            } finally {
              _iterator13.f();
            }
          } // Unset predicate to avoid text contents to produce new triples


          activeTag.predicates = null;
        } else if (localObjectResource) {
          // Emit triples for all resource objects
          var _object2 = this.util.getResourceOrBaseIri(localObjectResource, activeTag);

          if ('inlist' in attributes) {
            var _iterator14 = _createForOfIteratorHelper(activeTag.predicates),
                _step14;

            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var _predicate10 = _step14.value;
                this.addListMapping(activeTag, newSubject, _predicate10, _object2);
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
          } else {
            var _subject2 = this.util.getResourceOrBaseIri(newSubject, activeTag);

            var _iterator15 = _createForOfIteratorHelper(activeTag.predicates),
                _step15;

            try {
              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                var _predicate11 = _step15.value;
                this.emitTriple(_subject2, _predicate11, _object2);
              }
            } catch (err) {
              _iterator15.e(err);
            } finally {
              _iterator15.f();
            }
          } // Unset predicate to avoid text contents to produce new triples


          activeTag.predicates = null;
        }
      } // 12: Complete incomplete triples


      var incompleteTriplesCompleted = false;

      if (!activeTag.skipElement && newSubject && parentTag.incompleteTriples.length > 0) {
        incompleteTriplesCompleted = true;

        var _subject3 = this.util.getResourceOrBaseIri(parentTag.subject, activeTag);

        var _object3 = this.util.getResourceOrBaseIri(newSubject, activeTag);

        var _iterator16 = _createForOfIteratorHelper(parentTag.incompleteTriples),
            _step16;

        try {
          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
            var incompleteTriple = _step16.value;

            if (!incompleteTriple.reverse) {
              if (incompleteTriple.list) {
                // Find the active tag that defined the list by going up the stack
                var firstInListTag = null;

                for (var i = this.activeTagStack.length - 1; i >= 0; i--) {
                  if (this.activeTagStack[i].inlist) {
                    firstInListTag = this.activeTagStack[i];
                    break;
                  }
                } // firstInListTag is guaranteed to be non-null


                this.addListMapping(firstInListTag, newSubject, incompleteTriple.predicate, _object3);
              } else {
                this.emitTriple(_subject3, incompleteTriple.predicate, _object3);
              }
            } else {
              this.emitTriple(_object3, incompleteTriple.predicate, _subject3);
            }
          }
        } catch (err) {
          _iterator16.e(err);
        } finally {
          _iterator16.f();
        }
      }

      if (!incompleteTriplesCompleted && parentTag.incompleteTriples.length > 0) {
        activeTag.incompleteTriples = activeTag.incompleteTriples.concat(parentTag.incompleteTriples);
      } // 13: Save evaluation context into active tag


      activeTag.subject = newSubject || parentTag.subject;
      activeTag.object = currentObjectResource || newSubject;
    }
  }, {
    key: "onText",
    value: function onText(data) {
      var activeTag = this.activeTagStack[this.activeTagStack.length - 1]; // Collect text in pattern tag if needed

      if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag) {
        activeTag.collectedPatternTag.text.push(data);
        return;
      } // Save the text inside the active tag


      if (!activeTag.text) {
        activeTag.text = [];
      }

      activeTag.text.push(data);
    }
  }, {
    key: "onTagClose",
    value: function onTagClose() {
      var _this2 = this;

      // Get the active tag
      var activeTag = this.activeTagStack[this.activeTagStack.length - 1];
      var parentTag = this.activeTagStack[this.activeTagStack.length - 2];

      if (!(activeTag.collectChildTags && parentTag.collectChildTags && this.features.skipHandlingXmlLiteralChildren)) {
        // If we detect a finalized rdfa:Pattern tag, store it
        if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag && activeTag.collectedPatternTag.rootPattern) {
          var patternId = activeTag.collectedPatternTag.attributes.resource; // Remove resource and typeof attributes to avoid it being seen as a new pattern

          delete activeTag.collectedPatternTag.attributes.resource;
          delete activeTag.collectedPatternTag.attributes["typeof"]; // Store the pattern

          this.rdfaPatterns[patternId] = activeTag.collectedPatternTag; // Apply all pending copies for this pattern

          if (this.pendingRdfaPatternCopies[patternId]) {
            var _iterator17 = _createForOfIteratorHelper(this.pendingRdfaPatternCopies[patternId]),
                _step17;

            try {
              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                var tag = _step17.value;
                this.emitPatternCopy(tag, activeTag.collectedPatternTag, patternId);
              }
            } catch (err) {
              _iterator17.e(err);
            } finally {
              _iterator17.f();
            }

            delete this.pendingRdfaPatternCopies[patternId];
          } // Remove the active tag from the stack


          this.activeTagStack.pop();
          return;
        } // Emit all triples that were determined in the active tag


        if (activeTag.predicates) {
          var subject = this.util.getResourceOrBaseIri(activeTag.subject, activeTag);
          var textSegments = activeTag.text || [];

          if (activeTag.collectChildTags && parentTag.collectChildTags) {
            // If we are inside an XMLLiteral child that also has RDFa content, ignore the tag name that was collected.
            textSegments = textSegments.slice(1);
          }

          var object = this.util.createLiteral(textSegments.join(''), activeTag);

          if (activeTag.inlist) {
            var _iterator18 = _createForOfIteratorHelper(activeTag.predicates),
                _step18;

            try {
              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                var predicate = _step18.value;
                this.addListMapping(activeTag, subject, predicate, object);
              }
            } catch (err) {
              _iterator18.e(err);
            } finally {
              _iterator18.f();
            }
          } else {
            var _iterator19 = _createForOfIteratorHelper(activeTag.predicates),
                _step19;

            try {
              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                var _predicate12 = _step19.value;
                this.emitTriple(subject, _predicate12, object);
              }
            } catch (err) {
              _iterator19.e(err);
            } finally {
              _iterator19.f();
            }
          } // Reset text, unless the parent is also collecting text


          if (!parentTag.predicates) {
            activeTag.text = null;
          }
        } // 14: Handle local list mapping


        if (activeTag.object && Object.keys(activeTag.listMapping).length > 0) {
          var _subject4 = this.util.getResourceOrBaseIri(activeTag.object, activeTag);

          for (var predicateValue in activeTag.listMapping) {
            var _predicate13 = this.util.dataFactory.namedNode(predicateValue);

            var values = activeTag.listMapping[predicateValue];

            if (values.length > 0) {
              // Non-empty list, emit linked list of rdf:first and rdf:rest chains
              var bnodes = values.map(function () {
                return _this2.util.createBlankNode();
              });

              for (var i = 0; i < values.length; i++) {
                var _object4 = this.util.getResourceOrBaseIri(values[i], activeTag);

                this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util_1.Util.RDF + 'first'), _object4);
                this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util_1.Util.RDF + 'rest'), i < values.length - 1 ? bnodes[i + 1] : this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));
              } // Emit triple for the first linked list chain


              this.emitTriple(_subject4, _predicate13, bnodes[0]);
            } else {
              // Empty list, just emit rdf:nil
              this.emitTriple(_subject4, _predicate13, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));
            }
          }
        }
      } // Remove the active tag from the stack


      this.activeTagStack.pop(); // Save the tag contents if needed

      if (activeTag.collectChildTags && activeTag.text) {
        activeTag.text.push("</".concat(activeTag.name, ">"));
      } // If we still have text contents, try to append it to the parent tag


      if (activeTag.text && parentTag) {
        if (!parentTag.text) {
          parentTag.text = activeTag.text;
        } else {
          parentTag.text = parentTag.text.concat(activeTag.text);
        }
      }
    }
  }, {
    key: "onEnd",
    value: function onEnd() {
      if (this.features.copyRdfaPatterns) {
        this.features.copyRdfaPatterns = false; // Emit all unreferenced patterns

        for (var patternId in this.rdfaPatterns) {
          var pattern = this.rdfaPatterns[patternId];

          if (!pattern.referenced) {
            pattern.attributes["typeof"] = 'rdfa:Pattern';
            pattern.attributes.resource = patternId;
            this.emitPatternCopy(pattern.parentTag, pattern, patternId);
            pattern.referenced = false;
            delete pattern.attributes["typeof"];
            delete pattern.attributes.resource;
          }
        } // Emit all unreferenced copy links


        for (var _patternId in this.pendingRdfaPatternCopies) {
          var _iterator20 = _createForOfIteratorHelper(this.pendingRdfaPatternCopies[_patternId]),
              _step20;

          try {
            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
              var parentTag = _step20.value;
              this.activeTagStack.push(parentTag);
              this.onTagOpen('link', {
                property: 'rdfa:copy',
                href: _patternId
              });
              this.onTagClose();
              this.activeTagStack.pop();
            }
          } catch (err) {
            _iterator20.e(err);
          } finally {
            _iterator20.f();
          }
        }

        this.features.copyRdfaPatterns = true;
      }
    }
    /**
     * If the new subject can be inherited from the parent object
     * if the resource defines no new subject.
     * @param {string} name The current tag name.
     * @returns {boolean} If the subject can be inherited.
     */

  }, {
    key: "isInheritSubjectInHeadBody",
    value: function isInheritSubjectInHeadBody(name) {
      return this.features.inheritSubjectInHeadBody && (name === 'head' || name === 'body');
    }
    /**
     * Add a list mapping for the given predicate and object in the active tag.
     * @param {IActiveTag} activeTag The active tag.
     * @param {Term | boolean} subject A subject term, this will only be used to create a separate list
     *                                 if activeTag.explicitNewSubject is true.
     * @param {Term} predicate A predicate term.
     * @param {Term | boolean} currentObjectResource The current object resource.
     */

  }, {
    key: "addListMapping",
    value: function addListMapping(activeTag, subject, predicate, currentObjectResource) {
      if (activeTag.explicitNewSubject) {
        var bNode = this.util.createBlankNode();
        this.emitTriple(this.util.getResourceOrBaseIri(subject, activeTag), predicate, bNode);
        this.emitTriple(bNode, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'first'), this.util.getResourceOrBaseIri(currentObjectResource, activeTag));
        this.emitTriple(bNode, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'rest'), this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));
      } else {
        var predicateList = activeTag.listMappingLocal[predicate.value];

        if (!predicateList) {
          activeTag.listMappingLocal[predicate.value] = predicateList = [];
        }

        if (currentObjectResource) {
          predicateList.push(currentObjectResource);
        }
      }
    }
    /**
     * Emit the given triple to the stream.
     * @param {Term} subject A subject term.
     * @param {Term} predicate A predicate term.
     * @param {Term} object An object term.
     */

  }, {
    key: "emitTriple",
    value: function emitTriple(subject, predicate, object) {
      // Validate IRIs
      if (subject.termType === 'NamedNode' && subject.value.indexOf(':') < 0 || predicate.termType === 'NamedNode' && predicate.value.indexOf(':') < 0 || object.termType === 'NamedNode' && object.value.indexOf(':') < 0) {
        return;
      }

      this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));
    }
    /**
     * Emit an instantiation of the given pattern with the given parent tag.
     * @param {IActiveTag} parentTag The parent tag to instantiate in.
     * @param {IRdfaPattern} pattern The pattern to instantiate.
     * @param {string} rootPatternId The pattern id.
     */

  }, {
    key: "emitPatternCopy",
    value: function emitPatternCopy(parentTag, pattern, rootPatternId) {
      var _this3 = this;

      this.activeTagStack.push(parentTag);
      pattern.referenced = true; // Ensure that blank nodes within patterns are instantiated only once.
      // All next pattern copies will reuse the instantiated blank nodes from the first pattern.

      if (!pattern.constructedBlankNodes) {
        pattern.constructedBlankNodes = [];

        this.util.blankNodeFactory = function () {
          var bNode = _this3.util.dataFactory.blankNode();

          pattern.constructedBlankNodes.push(bNode);
          return bNode;
        };
      } else {
        var blankNodeIndex = 0;

        this.util.blankNodeFactory = function () {
          return pattern.constructedBlankNodes[blankNodeIndex++];
        };
      } // Apply everything within the pattern


      this.emitPatternCopyAbsolute(pattern, true, rootPatternId);
      this.util.blankNodeFactory = null;
      this.activeTagStack.pop();
    }
    /**
     * Emit an instantiation of the given pattern with the given parent tag.
     *
     * This should probably not be called directly,
     * call {@link emitPatternCopy} instead.
     *
     * @param {IRdfaPattern} pattern The pattern to instantiate.
     * @param {boolean} root If this is the root call for the given pattern.
     * @param {string} rootPatternId The pattern id.
     */

  }, {
    key: "emitPatternCopyAbsolute",
    value: function emitPatternCopyAbsolute(pattern, root, rootPatternId) {
      // Stop on detection of cyclic patterns
      if (!root && pattern.attributes.property === 'rdfa:copy' && pattern.attributes.href === rootPatternId) {
        return;
      }

      this.onTagOpen(pattern.name, pattern.attributes);

      var _iterator21 = _createForOfIteratorHelper(pattern.text),
          _step21;

      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var text = _step21.value;
          this.onText(text);
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }

      var _iterator22 = _createForOfIteratorHelper(pattern.children),
          _step22;

      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var child = _step22.value;
          this.emitPatternCopyAbsolute(child, false, rootPatternId);
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }

      this.onTagClose();
    }
  }, {
    key: "initializeParser",
    value: function initializeParser(xmlMode) {
      var _this4 = this;

      return new htmlparser2_1.Parser({
        onclosetag: function onclosetag() {
          try {
            _this4.onTagClose();

            if (_this4.htmlParseListener) {
              _this4.htmlParseListener.onTagClose();
            }
          } catch (e) {
            _this4.emit('error', e);
          }
        },
        onend: function onend() {
          try {
            _this4.onEnd();

            if (_this4.htmlParseListener) {
              _this4.htmlParseListener.onEnd();
            }
          } catch (e) {
            _this4.emit('error', e);
          }
        },
        onopentag: function onopentag(name, attributes) {
          try {
            _this4.onTagOpen(name, attributes);

            if (_this4.htmlParseListener) {
              _this4.htmlParseListener.onTagOpen(name, attributes);
            }
          } catch (e) {
            _this4.emit('error', e);
          }
        },
        ontext: function ontext(data) {
          try {
            _this4.onText(data);

            if (_this4.htmlParseListener) {
              _this4.htmlParseListener.onText(data);
            }
          } catch (e) {
            _this4.emit('error', e);
          }
        }
      }, {
        decodeEntities: true,
        recognizeSelfClosing: true,
        xmlMode: xmlMode
      });
    }
  }]);
  return RdfaParser;
}(stream_1.Transform);

exports.RdfaParser = RdfaParser;

},{"./RdfaProfile":168,"./Util":169,"./initial-context-xhtml.json":170,"./initial-context.json":171,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"htmlparser2":87,"stream":191}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RDFA_CONTENTTYPES = exports.RDFA_FEATURES = void 0;
/**
 * A mapping of RDFa profile to a features object.
 */
// tslint:disable:object-literal-sort-keys

exports.RDFA_FEATURES = {
  '': {
    baseTag: true,
    xmlBase: true,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: true,
    inheritSubjectInHeadBody: true,
    datetimeAttribute: true,
    timeTag: true,
    htmlDatatype: true,
    copyRdfaPatterns: true,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: true,
    roleAttribute: true
  },
  'core': {
    baseTag: false,
    xmlBase: false,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: true,
    inheritSubjectInHeadBody: false,
    datetimeAttribute: false,
    timeTag: false,
    htmlDatatype: false,
    copyRdfaPatterns: true,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: false,
    roleAttribute: false
  },
  'html': {
    baseTag: true,
    xmlBase: false,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: true,
    inheritSubjectInHeadBody: true,
    datetimeAttribute: true,
    timeTag: true,
    htmlDatatype: true,
    copyRdfaPatterns: true,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: false,
    roleAttribute: true
  },
  'xhtml': {
    baseTag: true,
    xmlBase: false,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: true,
    inheritSubjectInHeadBody: true,
    datetimeAttribute: true,
    timeTag: true,
    htmlDatatype: true,
    copyRdfaPatterns: true,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: true,
    roleAttribute: true
  },
  'xml': {
    baseTag: false,
    xmlBase: true,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: false,
    inheritSubjectInHeadBody: false,
    datetimeAttribute: true,
    timeTag: true,
    htmlDatatype: false,
    copyRdfaPatterns: false,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: false,
    roleAttribute: true
  }
}; // tslint:enable:object-literal-sort-keys
// tslint:disable:object-literal-sort-keys

exports.RDFA_CONTENTTYPES = {
  // HTML
  'text/html': 'html',
  // XHTML
  'application/xhtml+xml': 'xhtml',
  // XML
  'application/xml': 'xml',
  'text/xml': 'xml',
  'image/svg+xml': 'xml'
}; // tslint:enable:object-literal-sort-keys

},{}],169:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Util = void 0;

var relative_to_absolute_iri_1 = require("relative-to-absolute-iri");

var RdfaProfile_1 = require("./RdfaProfile");

var rdf_data_factory_1 = require("rdf-data-factory");
/**
 * A collection of utility functions.
 */


var Util = /*#__PURE__*/function () {
  function Util(dataFactory, baseIRI) {
    (0, _classCallCheck2["default"])(this, Util);
    this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();
    this.baseIRI = this.dataFactory.namedNode(baseIRI || '');
    this.baseIRIDocument = this.baseIRI;
  }
  /**
   * Retrieve the prefixes of the current tag's attributes.
   * @param {{[p: string]: string}} attributes A tag's attributes.
   * @param {{[p: string]: string}} parentPrefixes The prefixes from the parent tag.
   * @param {boolean} xmlnsPrefixMappings If prefixes should be extracted from xmlnsPrefixMappings.
   * @return {{[p: string]: string}} The new prefixes.
   */


  (0, _createClass2["default"])(Util, [{
    key: "getBaseIRI",

    /**
     * Get the base IRI.
     * @param {string} baseIriValue A base IRI value.
     * @return A base IRI named node.
     */
    value: function getBaseIRI(baseIriValue) {
      var href = baseIriValue;
      var fragmentIndex = href.indexOf('#');

      if (fragmentIndex >= 0) {
        href = href.substr(0, fragmentIndex);
      }

      return this.dataFactory.namedNode(relative_to_absolute_iri_1.resolve(href, this.baseIRI.value));
    }
    /**
     * If the term is a boolean, return the baseIRI, otherwise return the term as-is.
     * @param {Term | boolean} term A term or boolean, where the boolean indicates the baseIRI.
     * @param {IActiveTag} activeTag An active tag.
     * @returns {Term} A term.
     */

  }, {
    key: "getResourceOrBaseIri",
    value: function getResourceOrBaseIri(term, activeTag) {
      return term === true ? this.getBaseIriTerm(activeTag) : term;
    }
    /**
     * Get the active base IRI as an RDF term.
     * @param {IActiveTag} activeTag The active tag.
     * @return {NamedNode} The base IRI term.
     */

  }, {
    key: "getBaseIriTerm",
    value: function getBaseIriTerm(activeTag) {
      return activeTag.localBaseIRI || this.baseIRI;
    }
  }, {
    key: "createVocabIris",
    value: function createVocabIris(terms, activeTag, allowTerms, allowBlankNode) {
      var _this = this;

      return terms.split(/\s+/).filter(function (term) {
        return term && (allowTerms || term.indexOf(':') >= 0);
      }).map(function (property) {
        return _this.createIri(property, activeTag, true, true, allowBlankNode);
      }).filter(function (term) {
        return term != null;
      });
    }
    /**
     * Create a new literal node.
     * @param {string} literal The literal value.
     * @param {IActiveTag} activeTag The current active tag.
     * @return {Literal} A new literal node.
     */

  }, {
    key: "createLiteral",
    value: function createLiteral(literal, activeTag) {
      if (activeTag.interpretObjectAsTime && !activeTag.datatype) {
        var _iterator = _createForOfIteratorHelper(Util.TIME_REGEXES),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var entry = _step.value;

            if (literal.match(entry.regex)) {
              activeTag.datatype = this.dataFactory.namedNode(Util.XSD + entry.type);
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return this.dataFactory.literal(literal, activeTag.datatype || activeTag.language);
    }
    /**
     * Create a blank node.
     * @returns {BlankNode} A new blank node.
     */

  }, {
    key: "createBlankNode",
    value: function createBlankNode() {
      if (this.blankNodeFactory) {
        return this.blankNodeFactory();
      }

      return this.dataFactory.blankNode();
    }
  }, {
    key: "createIri",
    value: function createIri(term, activeTag, vocab, allowSafeCurie, allowBlankNode) {
      term = term || '';

      if (!allowSafeCurie) {
        if (!vocab) {
          term = relative_to_absolute_iri_1.resolve(term, this.getBaseIriTerm(activeTag).value);
        }

        if (!Util.isValidIri(term)) {
          return null;
        }

        return this.dataFactory.namedNode(term);
      } // Handle strict CURIEs


      if (term.length > 0 && term[0] === '[' && term[term.length - 1] === ']') {
        term = term.substr(1, term.length - 2); // Strict CURIEs MUST have a prefix separator

        if (term.indexOf(':') < 0) {
          return null;
        }
      } // Handle blank nodes


      if (term.startsWith('_:')) {
        return allowBlankNode ? this.dataFactory.blankNode(term.substr(2) || 'b_identity') : null;
      } // Handle vocab IRIs


      if (vocab) {
        if (activeTag.vocab && term.indexOf(':') < 0) {
          return this.dataFactory.namedNode(activeTag.vocab + term);
        }
      } // Handle prefixed IRIs


      var iri = Util.expandPrefixedTerm(term, activeTag); // Resolve against baseIRI if in base-mode, or if the term was a prefixed relative IRI

      if (!vocab) {
        iri = relative_to_absolute_iri_1.resolve(iri, this.getBaseIriTerm(activeTag).value);
      } else if (term !== iri) {
        iri = relative_to_absolute_iri_1.resolve(iri, this.baseIRIDocument.value);
      }

      if (!Util.isValidIri(iri)) {
        return null;
      }

      return this.dataFactory.namedNode(iri);
    }
  }], [{
    key: "parsePrefixes",
    value: function parsePrefixes(attributes, parentPrefixes, xmlnsPrefixMappings) {
      var additionalPrefixes = {};

      if (xmlnsPrefixMappings) {
        for (var attribute in attributes) {
          if (attribute.startsWith('xmlns')) {
            additionalPrefixes[attribute.substr(6)] = attributes[attribute];
          }
        }
      }

      if (attributes.prefix || Object.keys(additionalPrefixes).length > 0) {
        var prefixes = Object.assign(Object.assign({}, parentPrefixes), additionalPrefixes);

        if (attributes.prefix) {
          var prefixMatch; // tslint:disable-next-line:no-conditional-assignment

          while (prefixMatch = Util.PREFIX_REGEX.exec(attributes.prefix)) {
            prefixes[prefixMatch[1]] = prefixMatch[2];
          }
        }

        return prefixes;
      } else {
        return parentPrefixes;
      }
    }
    /**
     * Expand the given term value based on the given prefixes.
     * @param {string} term A term value.
     * @param {{[p: string]: string}[]} prefixes The available prefixes.
     * @return {string} An expanded URL, or the term as-is.
     */

  }, {
    key: "expandPrefixedTerm",
    value: function expandPrefixedTerm(term, activeTag) {
      // Check if the term is prefixed
      var colonIndex = term.indexOf(':');
      var prefix;
      var local;

      if (colonIndex >= 0) {
        prefix = term.substr(0, colonIndex);
        local = term.substr(colonIndex + 1);
      } // Expand default namespace


      if (prefix === '') {
        return 'http://www.w3.org/1999/xhtml/vocab#' + local;
      } // Try to expand the prefix


      if (prefix) {
        var prefixElement = activeTag.prefixesAll[prefix];

        if (prefixElement) {
          return prefixElement + local;
        }
      } // Try to expand the term


      if (term) {
        var expandedTerm = activeTag.prefixesAll[term.toLocaleLowerCase()];

        if (expandedTerm) {
          return expandedTerm;
        }
      }

      return term;
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */

  }, {
    key: "isValidIri",
    value: function isValidIri(iri) {
      return Util.IRI_REGEX.test(iri);
    }
    /**
     * Determine the RDFa profile from the given content type.
     * Defaults to the default RDFa profile (all features enabled) for unknown content types.
     * @param {string} contentType A content type.
     * @returns {RdfaProfile} An RDFa profile.
     */

  }, {
    key: "contentTypeToProfile",
    value: function contentTypeToProfile(contentType) {
      return RdfaProfile_1.RDFA_CONTENTTYPES[contentType] || '';
    }
  }]);
  return Util;
}();

exports.Util = Util;
Util.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
Util.XSD = 'http://www.w3.org/2001/XMLSchema#';
Util.RDFA = 'http://www.w3.org/ns/rdfa#';
Util.PREFIX_REGEX = /\s*([^:\s]*)*:\s*([^\s]*)*\s*/g;
Util.TIME_REGEXES = [{
  regex: /^-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9])?S)?)?$/,
  type: 'duration'
}, {
  regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
  type: 'dateTime'
}, {
  regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/,
  type: 'date'
}, {
  regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
  type: 'time'
}, {
  regex: /^[0-9]+-[0-9][0-9]$/,
  type: 'gYearMonth'
}, {
  regex: /^[0-9]+$/,
  type: 'gYear'
}];
Util.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`]*$/;

},{"./RdfaProfile":168,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"rdf-data-factory":155,"relative-to-absolute-iri":188}],170:[function(require,module,exports){
module.exports={
  "@context": {
    "alternate": "http://www.w3.org/1999/xhtml/vocab#alternate",
    "appendix": "http://www.w3.org/1999/xhtml/vocab#appendix",
    "cite": "http://www.w3.org/1999/xhtml/vocab#cite",
    "bookmark": "http://www.w3.org/1999/xhtml/vocab#bookmark",
    "contents": "http://www.w3.org/1999/xhtml/vocab#contents",
    "chapter": "http://www.w3.org/1999/xhtml/vocab#chapter",
    "copyright": "http://www.w3.org/1999/xhtml/vocab#copyright",
    "first": "http://www.w3.org/1999/xhtml/vocab#first",
    "glossary": "http://www.w3.org/1999/xhtml/vocab#glossary",
    "help": "http://www.w3.org/1999/xhtml/vocab#help",
    "icon": "http://www.w3.org/1999/xhtml/vocab#icon",
    "index": "http://www.w3.org/1999/xhtml/vocab#index",
    "last": "http://www.w3.org/1999/xhtml/vocab#last",
    "license": "http://www.w3.org/1999/xhtml/vocab#license",
    "meta": "http://www.w3.org/1999/xhtml/vocab#meta",
    "next": "http://www.w3.org/1999/xhtml/vocab#next",
    "prev": "http://www.w3.org/1999/xhtml/vocab#prev",
    "previous": "http://www.w3.org/1999/xhtml/vocab#previous",
    "section": "http://www.w3.org/1999/xhtml/vocab#section",
    "start": "http://www.w3.org/1999/xhtml/vocab#start",
    "stylesheet": "http://www.w3.org/1999/xhtml/vocab#stylesheet",
    "subsection": "http://www.w3.org/1999/xhtml/vocab#subsection",
    "top": "http://www.w3.org/1999/xhtml/vocab#top",
    "up": "http://www.w3.org/1999/xhtml/vocab#up",
    "p3pv1": "http://www.w3.org/1999/xhtml/vocab#p3pv1"
  }
}

},{}],171:[function(require,module,exports){
module.exports={
  "@context": {
    "as": "https://www.w3.org/ns/activitystreams#",
    "cat": "http://www.w3.org/ns/dcat#",
    "cc": "http://creativecommons.org/ns#",
    "cnt": "http://www.w3.org/2008/content#",
    "csvw": "http://www.w3.org/ns/csvw#",
    "ctag": "http://commontag.org/ns#",
    "dc": "http://purl.org/dc/terms/",
    "dc11": "http://purl.org/dc/elements/1.1/",
    "dcat": "http://www.w3.org/ns/dcat#",
    "dcterms": "http://purl.org/dc/terms/",
    "dqv": "http://www.w3.org/ns/dqv#",
    "duv": "https://www.w3.org/TR/vocab-duv#",
    "earl": "http://www.w3.org/ns/earl#",
    "foaf": "http://xmlns.com/foaf/0.1/",
    "gldp": "http://www.w3.org/ns/people#",
    "gr": "http://purl.org/goodrelations/v1#",
    "grddl": "http://www.w3.org/2003/g/data-view#",
    "ht": "http://www.w3.org/2006/http#",
    "ical": "http://www.w3.org/2002/12/cal/icaltzd#",
    "ldp": "http://www.w3.org/ns/ldp#",
    "ma": "http://www.w3.org/ns/ma-ont#",
    "oa": "http://www.w3.org/ns/oa#",
    "odrl": "http://www.w3.org/ns/odrl/2/",
    "og": "http://ogp.me/ns#",
    "org": "http://www.w3.org/ns/org#",
    "owl": "http://www.w3.org/2002/07/owl#",
    "prov": "http://www.w3.org/ns/prov#",
    "ptr": "http://www.w3.org/2009/pointers#",
    "qb": "http://purl.org/linked-data/cube#",
    "rev": "http://purl.org/stuff/rev#",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfa": "http://www.w3.org/ns/rdfa#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "rif": "http://www.w3.org/2007/rif#",
    "rr": "http://www.w3.org/ns/r2rml#",
    "schema": "http://schema.org/",
    "sd": "http://www.w3.org/ns/sparql-service-description#",
    "sioc": "http://rdfs.org/sioc/ns#",
    "skos": "http://www.w3.org/2004/02/skos/core#",
    "skosxl": "http://www.w3.org/2008/05/skos-xl#",
    "ssn": "http://www.w3.org/ns/ssn/",
    "sosa": "http://www.w3.org/ns/sosa/",
    "time": "http://www.w3.org/2006/time#",
    "v": "http://rdf.data-vocabulary.org/#",
    "vcard": "http://www.w3.org/2006/vcard/ns#",
    "void": "http://rdfs.org/ns/void#",
    "wdr": "http://www.w3.org/2007/05/powder#",
    "wdrs": "http://www.w3.org/2007/05/powder-s#",
    "xhv": "http://www.w3.org/1999/xhtml/vocab#",
    "xml": "http://www.w3.org/XML/1998/namespace",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "describedby": "http://www.w3.org/2007/05/powder-s#describedby",
    "license": "http://www.w3.org/1999/xhtml/vocab#license",
    "role": "http://www.w3.org/1999/xhtml/vocab#role"
  }
}

},{}],172:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError = /*#__PURE__*/function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat((0, _typeof2["default"])(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],173:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":175,"./_stream_writable":177,"_process":142,"inherits":89}],174:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":176,"inherits":89}],175:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":172,"./_stream_duplex":173,"./internal/streams/async_iterator":178,"./internal/streams/buffer_list":179,"./internal/streams/destroy":180,"./internal/streams/from":182,"./internal/streams/state":184,"./internal/streams/stream":185,"_process":142,"buffer":60,"events":83,"inherits":89,"string_decoder/":192,"util":58}],176:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

},{"../errors":172,"./_stream_duplex":173,"inherits":89}],177:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options["final"] === 'function') this._final = options["final"];
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":172,"./_stream_duplex":173,"./internal/streams/destroy":180,"./internal/streams/state":184,"./internal/streams/stream":185,"_process":142,"buffer":60,"inherits":89,"util-deprecate":194}],178:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this; // if we have detected an error in the meanwhile
    // reject straight away


    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this; // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to


  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":181,"_process":142}],179:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

},{"buffer":60,"util":58}],180:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

}).call(this)}).call(this,require('_process'))

},{"_process":142}],181:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

},{"../../../errors":172}],182:[function(require,module,exports){
"use strict";

module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};

},{}],183:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

},{"../../../errors":172,"./end-of-stream":181}],184:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

},{"../../../errors":172}],185:[function(require,module,exports){
"use strict";

module.exports = require('events').EventEmitter;

},{"events":83}],186:[function(require,module,exports){
"use strict";

exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":173,"./lib/_stream_passthrough.js":174,"./lib/_stream_readable.js":175,"./lib/_stream_transform.js":176,"./lib/_stream_writable.js":177,"./lib/internal/streams/end-of-stream.js":181,"./lib/internal/streams/pipeline.js":183}],187:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }

  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && (0, _typeof2["default"])(value) === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
(typeof module === "undefined" ? "undefined" : (0, _typeof2["default"])(module)) === "object" ? module.exports : {});

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],188:[function(require,module,exports){
"use strict";

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

__export(require("./lib/Resolve"));

},{"./lib/Resolve":189}],189:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Convert the given relative IRI to an absolute IRI
 * by taking into account the given optional baseIRI.
 *
 * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.
 * @param {string} baseIRI The optional base IRI.
 * @return {string} an absolute IRI.
 */

function resolve(relativeIRI, baseIRI) {
  baseIRI = baseIRI || '';
  var baseFragmentPos = baseIRI.indexOf('#'); // Ignore any fragments in the base IRI

  if (baseFragmentPos > 0) {
    baseIRI = baseIRI.substr(0, baseFragmentPos);
  } // Convert empty value directly to base IRI


  if (!relativeIRI.length) {
    // At this point, the baseIRI MUST be absolute, otherwise we error
    if (baseIRI.indexOf(':') < 0) {
      throw new Error("Found invalid baseIRI '".concat(baseIRI, "' for value '").concat(relativeIRI, "'"));
    }

    return baseIRI;
  } // If the value starts with a query character, concat directly (but strip the existing query)


  if (relativeIRI.startsWith('?')) {
    var baseQueryPos = baseIRI.indexOf('?');

    if (baseQueryPos > 0) {
      baseIRI = baseIRI.substr(0, baseQueryPos);
    }

    return baseIRI + relativeIRI;
  } // If the value starts with a fragment character, concat directly


  if (relativeIRI.startsWith('#')) {
    return baseIRI + relativeIRI;
  } // Ignore baseIRI if it is empty


  if (!baseIRI.length) {
    var relativeColonPos = relativeIRI.indexOf(':');

    if (relativeColonPos < 0) {
      throw new Error("Found invalid relative IRI '".concat(relativeIRI, "' for a missing baseIRI"));
    }

    return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);
  } // Ignore baseIRI if the value is absolute


  var valueColonPos = relativeIRI.indexOf(':');

  if (valueColonPos >= 0) {
    return removeDotSegmentsOfPath(relativeIRI, valueColonPos);
  } // At this point, the baseIRI MUST be absolute, otherwise we error


  var baseColonPos = baseIRI.indexOf(':');

  if (baseColonPos < 0) {
    throw new Error("Found invalid baseIRI '".concat(baseIRI, "' for value '").concat(relativeIRI, "'"));
  }

  var baseIRIScheme = baseIRI.substr(0, baseColonPos + 1); // Inherit the baseIRI scheme if the value starts with '//'

  if (relativeIRI.indexOf('//') === 0) {
    return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
  } // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.


  var baseSlashAfterColonPos;

  if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {
    // If there is no additional '/' after the '//'.
    baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);

    if (baseSlashAfterColonPos < 0) {
      // If something other than a '/' follows the '://', append the value after a '/',
      // otherwise, prefix the value with only the baseIRI scheme.
      if (baseIRI.length > baseColonPos + 3) {
        return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
      } else {
        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
      }
    }
  } else {
    // If there is not even a single '/' after the ':'
    baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);

    if (baseSlashAfterColonPos < 0) {
      // If we don't have a '/' after the ':',
      // prefix the value with only the baseIRI scheme.
      return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
    }
  } // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.


  if (relativeIRI.indexOf('/') === 0) {
    return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);
  }

  var baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);
  var baseIRILastSlashPos = baseIRIPath.lastIndexOf('/'); // Ignore everything after the last '/' in the baseIRI path

  if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {
    baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1); // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')
    // This change is only allowed if there is something else following the path

    if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {
      relativeIRI = relativeIRI.substr(1);
    }
  } // Prefix the value with the baseIRI path where


  relativeIRI = baseIRIPath + relativeIRI; // Remove dot segment from the IRI

  relativeIRI = removeDotSegments(relativeIRI); // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.

  return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;
}

exports.resolve = resolve;
/**
 * Remove dot segments from the given path,
 * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).
 * @param {string} path An IRI path.
 * @return {string} A path, will always start with a '/'.
 */

function removeDotSegments(path) {
  // Prepare a buffer with segments between each '/.
  // Each segment represents an array of characters.
  var segmentBuffers = [];
  var i = 0;

  while (i < path.length) {
    // Remove '/.' or '/..'
    switch (path[i]) {
      case '/':
        if (path[i + 1] === '.') {
          if (path[i + 2] === '.') {
            // Start a new segment if we find an invalid character after the '.'
            if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {
              segmentBuffers.push([]);
              i++;
              break;
            } // Go to parent directory,
            // so we remove a parent segment


            segmentBuffers.pop(); // Ensure that we end with a slash if there is a trailing '/..'

            if (!path[i + 3]) {
              segmentBuffers.push([]);
            }

            i += 3;
          } else {
            // Start a new segment if we find an invalid character after the '.'
            if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {
              segmentBuffers.push([]);
              i++;
              break;
            } // Ensure that we end with a slash if there is a trailing '/.'


            if (!path[i + 2]) {
              segmentBuffers.push([]);
            } // Go to the current directory,
            // so we do nothing


            i += 2;
          }
        } else {
          // Start a new segment
          segmentBuffers.push([]);
          i++;
        }

        break;

      case '#':
      case '?':
        // Query and fragment string should be appended unchanged
        if (!segmentBuffers.length) {
          segmentBuffers.push([]);
        }

        segmentBuffers[segmentBuffers.length - 1].push(path.substr(i)); // Break the while loop

        i = path.length;
        break;

      default:
        // Not a special character, just append it to our buffer
        if (!segmentBuffers.length) {
          segmentBuffers.push([]);
        }

        segmentBuffers[segmentBuffers.length - 1].push(path[i]);
        i++;
        break;
    }
  }

  return '/' + segmentBuffers.map(function (buffer) {
    return buffer.join('');
  }).join('/');
}

exports.removeDotSegments = removeDotSegments;
/**
 * Removes dot segments of the given IRI.
 * @param {string} iri An IRI (or part of IRI).
 * @param {number} colonPosition The position of the first ':' in the IRI.
 * @return {string} The IRI where dot segments were removed.
 */

function removeDotSegmentsOfPath(iri, colonPosition) {
  // Determine where we should start looking for the first '/' that indicates the start of the path
  var searchOffset = colonPosition + 1;

  if (colonPosition >= 0) {
    if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {
      searchOffset = colonPosition + 3;
    }
  } else {
    if (iri[0] === '/' && iri[1] === '/') {
      searchOffset = 2;
    }
  } // Determine the path


  var pathSeparator = iri.indexOf('/', searchOffset);

  if (pathSeparator < 0) {
    return iri;
  }

  var base = iri.substr(0, pathSeparator);
  var path = iri.substr(pathSeparator); // Remove dot segments from the path

  return base + removeDotSegments(path);
}

exports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;

function isCharacterAllowedAfterRelativePathSegment(character) {
  return !character || character === '#' || character === '?' || character === '/';
}

},{}],190:[function(require,module,exports){
"use strict";

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

},{"buffer":60}],191:[function(require,module,exports){
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = require('events').EventEmitter;

var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js');
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js'); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

},{"events":83,"inherits":89,"readable-stream/lib/_stream_duplex.js":173,"readable-stream/lib/_stream_passthrough.js":174,"readable-stream/lib/_stream_readable.js":175,"readable-stream/lib/_stream_transform.js":176,"readable-stream/lib/_stream_writable.js":177,"readable-stream/lib/internal/streams/end-of-stream.js":181,"readable-stream/lib/internal/streams/pipeline.js":183}],192:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(_byte) {
  if (_byte <= 0x7F) return 0;else if (_byte >> 5 === 0x06) return 2;else if (_byte >> 4 === 0x0E) return 3;else if (_byte >> 3 === 0x1E) return 4;
  return _byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD";
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD";
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD";
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":190}],193:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
"use strict";

var nextTick = require('process/browser.js').nextTick;

var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  timeout.close();
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // That's not how node.js implements it but the exposed api is the same.


exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
  immediateIds[id] = true;
  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      } // Prevent ids from leaking


      exports.clearImmediate(id);
    }
  });
  return id;
};
exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
  delete immediateIds[id];
};

}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":142,"timers":193}],194:[function(require,module,exports){
(function (global){(function (){
"use strict";

/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],195:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/_regenerator["default"].mark(function _callee() {
    var walker;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;

          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }

            _context.next = 4;
            return walker.value;

          case 4:
            walker = walker.next;
            _context.next = 1;
            break;

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  });
};

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30}],196:[function(require,module,exports){
'use strict';

module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;

function Yallist(list) {
  var self = this;

  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.splice = function (start, deleteCount
/*, ...nodes */
) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i]);
  }

  return ret;
};

Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  require('./iterator.js')(Yallist);
} catch (er) {}

},{"./iterator.js":195}],197:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Store = require('n3').Store;

var Parser = require('n3').Parser;

var jsonld = require('jsonld');

var Readable = require('stream').Readable;

var RdfaParser = require('rdfa-streaming-parser').RdfaParser;

var MicrodataParser = require('microdata-rdf-streaming-parser').MicrodataRdfParser;

var errors = require('./errors.js');
/**
 * Parses json-ld to quads into the n3.Store
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Promise<Store>}
 */


function parseJsonLd(_x, _x2) {
  return _parseJsonLd.apply(this, arguments);
}
/**
 * Parse RDFa to quads into the n3.Store
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Promise<Store>}
 */


function _parseJsonLd() {
  _parseJsonLd = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(text, baseUrl) {
    var data, nquads;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            data = JSON.parse(text);
            _context.next = 3;
            return jsonld.toRDF(data, {
              format: 'application/n-quads',
              base: baseUrl
            });

          case 3:
            nquads = _context.sent;
            return _context.abrupt("return", parseNQuads(nquads, baseUrl));

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseJsonLd.apply(this, arguments);
}

function parseRdfa(_x3, _x4) {
  return _parseRdfa.apply(this, arguments);
}
/**
 * Parses microdata to quads into the n3.Store
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Promise<Store>}
 */


function _parseRdfa() {
  _parseRdfa = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(text, baseUrl) {
    var textStream;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            textStream = new Readable();
            textStream.push(text);
            textStream.push(null);
            return _context2.abrupt("return", new Promise(function (res, rej) {
              var store = new Store();
              var rdfaParser = new RdfaParser({
                baseIRI: baseUrl,
                contentType: 'text/html'
              });
              textStream.pipe(rdfaParser).on('data', function (quad) {
                store.addQuad(quad);
              }).on('error', function (err) {
                return rej(err);
              }).on('end', function () {
                if (store.getQuads().length === 0) res(undefined);
                res(store);
              });
            }));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseRdfa.apply(this, arguments);
}

function parseMicrodata(_x5, _x6) {
  return _parseMicrodata.apply(this, arguments);
}
/**
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Store}
 */


function _parseMicrodata() {
  _parseMicrodata = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(text, baseUrl) {
    var textStream;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            textStream = new Readable();
            textStream.push(text);
            textStream.push(null);
            return _context3.abrupt("return", new Promise(function (res, rej) {
              var store = new Store();
              var rdfaParser = new MicrodataParser({
                baseIRI: baseUrl
              });
              textStream.pipe(rdfaParser).on('data', function (quad) {
                store.addQuad(quad);
              }).on('error', function (err) {
                return rej(err);
              }).on('end', function () {
                if (store.getQuads().length === 0) res(undefined);
                res(store);
              });
            }));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _parseMicrodata.apply(this, arguments);
}

function parseNQuads(text, baseUrl) {
  var turtleParser = new Parser({
    format: 'application/n-quads',
    baseIRI: baseUrl
  });
  var store = new Store();
  turtleParser.parse(text).forEach(function (quad) {
    store.addQuad(quad);
  });
  return store;
}
/**
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Store}
 */


function parseTurtle(text, baseUrl) {
  var turtleParser = new Parser({
    format: 'text/turtle',
    baseIRI: baseUrl
  });
  var store = new Store();
  turtleParser.parse(text).forEach(function (quad) {
    store.addQuad(quad);
  });
  return store;
}
/**
 * Helper for trying to parse input text into a certain format
 * @param {*} parser parser function
 * @returns {Promise<undefined|Store>}
 */


function tryParse(_x7) {
  return _tryParse.apply(this, arguments);
}
/**
 * Transforms input to quads
 * @param {string} text - input data
 * @param {string} url - main shape URL
 * @returns {Promise<Store>}
 */


function _tryParse() {
  _tryParse = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(parser) {
    var quads;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return parser();

          case 3:
            quads = _context4.sent;
            _context4.next = 8;
            break;

          case 6:
            _context4.prev = 6;
            _context4.t0 = _context4["catch"](0);

          case 8:
            return _context4.abrupt("return", quads);

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 6]]);
  }));
  return _tryParse.apply(this, arguments);
}

function stringToQuads(_x8, _x9) {
  return _stringToQuads.apply(this, arguments);
}

function _stringToQuads() {
  _stringToQuads = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(text, url) {
    var jsonParser, microdataParser, rdfaParser, res;
    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            jsonParser = /*#__PURE__*/function () {
              var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
                return _regenerator["default"].wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        _context5.next = 2;
                        return parseJsonLd(text, url);

                      case 2:
                        return _context5.abrupt("return", _context5.sent);

                      case 3:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));

              return function jsonParser() {
                return _ref.apply(this, arguments);
              };
            }();

            microdataParser = /*#__PURE__*/function () {
              var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
                return _regenerator["default"].wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return parseMicrodata(text, url);

                      case 2:
                        return _context6.abrupt("return", _context6.sent);

                      case 3:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));

              return function microdataParser() {
                return _ref2.apply(this, arguments);
              };
            }();

            rdfaParser = /*#__PURE__*/function () {
              var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
                return _regenerator["default"].wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        _context7.next = 2;
                        return parseRdfa(text, url);

                      case 2:
                        return _context7.abrupt("return", _context7.sent);

                      case 3:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7);
              }));

              return function rdfaParser() {
                return _ref3.apply(this, arguments);
              };
            }();

            _context8.next = 5;
            return tryParse(jsonParser);

          case 5:
            _context8.t1 = _context8.sent;

            if (_context8.t1) {
              _context8.next = 10;
              break;
            }

            _context8.next = 9;
            return tryParse(microdataParser);

          case 9:
            _context8.t1 = _context8.sent;

          case 10:
            _context8.t0 = _context8.t1;

            if (_context8.t0) {
              _context8.next = 15;
              break;
            }

            _context8.next = 14;
            return tryParse(rdfaParser);

          case 14:
            _context8.t0 = _context8.sent;

          case 15:
            res = _context8.t0;

            if (!(res === undefined || res.getQuads().length === 0)) {
              _context8.next = 18;
              break;
            }

            throw new errors.InvalidDataError('Error while parsing the data. ' + 'This could be caused by incorrect data or incorrect data format. ' + 'Possible formats: json-ld, microdata, rdfa');

          case 18:
            return _context8.abrupt("return", res);

          case 19:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _stringToQuads.apply(this, arguments);
}

module.exports = {
  parseJsonLd: parseJsonLd,
  parseMicrodata: parseMicrodata,
  parseRdfa: parseRdfa,
  parseNQuads: parseNQuads,
  parseTurtle: parseTurtle,
  stringToQuads: stringToQuads
};

},{"./errors.js":1,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30,"jsonld":107,"microdata-rdf-streaming-parser":114,"n3":135,"rdfa-streaming-parser":163,"stream":191}],198:[function(require,module,exports){
"use strict";

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
module.exports = {
  stringToQuads: require('./parser').stringToQuads,
  parseJsonLd: require('./parser').parseJsonLd,
  parseMicrodata: require('./parser').parseMicrodata,
  parseRdfa: require('./parser').parseRdfa,
  parseNQuads: require('./parser').parseNQuads,
  randomUrl: require('./util').randomUrl,
  quadsToShapes: require('./util').quadsToShapes
};

},{"./parser":197,"./util":199}],199:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var fs = require('fs');

var axios = require('axios');

var jsonld = require('jsonld');

var n3 = require('n3');

var Store = n3.Store;

var RdfaParser = require('rdfa-streaming-parser').RdfaParser;

var errors = require('./errors');
/**
 * Loads related data (shapes, context, etc.) from remote or local source
 * @param {string} link url to the remote source or local path
 * @return {*}
 */


function loadData(_x) {
  return _loadData.apply(this, arguments);
}
/**
 * Removes duplicates from objects array
 * @param {[object]} items
 * @param {[string]} keys
 * @returns {[object]}
 */


function _loadData() {
  _loadData = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(link) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!link.match("^https?://")) {
              _context.next = 4;
              break;
            }

            _context.next = 3;
            return axios.get(link);

          case 3:
            return _context.abrupt("return", _context.sent.data);

          case 4:
            return _context.abrupt("return", fs.readFileSync(link).toString());

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadData.apply(this, arguments);
}

function uniqueBy(items, keys) {
  var seen = {};
  return items.filter(function (item) {
    var val = '';
    keys.forEach(function (key) {
      return val += item[key];
    });
    return seen.hasOwnProperty(val) ? false : seen[val] = true;
  });
}
/**
 *  Generates random URL as base
 *  @param {number} length
 *  @return {string}
 */


function randomUrl() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  var result = 'https://example.org/';
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }

  return result;
}
/**
 * Finds strongly connected components in the data graph
 * @param {Store} store
 * @return {Map<string, number>} - map from subject uris to
 * component ids
 */


function stronglyConnectedComponents(store) {
  var nodes = (0, _toConsumableArray2["default"])(new Set(store.getSubjects().map(function (x) {
    return x.id;
  })));
  var order = [];
  var component = [];
  var componentIdx = 0;
  var components = new Map();
  var used = new Map();

  var forwardDfs = function forwardDfs(v) {
    used.set(v, true);

    var _iterator = _createForOfIteratorHelper(store.getQuads(v, undefined, undefined)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var quad = _step.value;
        if (nodes.includes(quad.object.id) && !used.get(quad.object.id)) forwardDfs(quad.object.id);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    order.push(v);
  };

  var backwardDfs = function backwardDfs(v) {
    used.set(v, true);
    component.push(v);

    var _iterator2 = _createForOfIteratorHelper(store.getQuads(undefined, undefined, v)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var quad = _step2.value;
        if (!used.get(quad.subject.id)) backwardDfs(quad.subject.id);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  };

  var _iterator3 = _createForOfIteratorHelper(nodes),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _node = _step3.value;
      used.set(_node, false);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  var _iterator4 = _createForOfIteratorHelper(nodes),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _node2 = _step4.value;
      if (!used.get(_node2)) forwardDfs(_node2);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  var _iterator5 = _createForOfIteratorHelper(nodes),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _node3 = _step5.value;
      used.set(_node3, false);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  for (var i = 0; i < nodes.length; i++) {
    var node = order[nodes.length - 1 - i];

    if (!used.get(node)) {
      backwardDfs(node);
      component.forEach(function (x) {
        return components.set(x, componentIdx);
      });
      componentIdx++;
      component = [];
    }
  }

  return components;
}
/**
 * Parses quads to multiple stores which represent root nodes
 * in the data graph
 * @param {Store} store
 */


function quadsToShapes(store) {
  var components = stronglyConnectedComponents(store);
  var notRoot = new Set();

  var _iterator6 = _createForOfIteratorHelper(store.getQuads()),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var quad = _step6.value;

      if (components.has(quad.subject.id) && components.has(quad.object.id) && components.get(quad.subject.id) !== components.get(quad.object.id)) {
        notRoot.add(components.get(quad.object.id));
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  var shapes = new Map();

  var _iterator7 = _createForOfIteratorHelper(components.entries()),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _step7$value = (0, _slicedToArray2["default"])(_step7.value, 2),
          node = _step7$value[0],
          component = _step7$value[1];

      if (!notRoot.has(component)) {
        shapes.set(node, getShape(node, store, shapes, []));
        notRoot.add(component);
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return shapes;
}
/**
 * Recursively gets all triples, related to the shape
 * @param {any} id - id of the constructed shape
 * @param {Store} store - store, containing all the triples
 * @param {Map<any, Store>} shapes - map [id -> shape Store]
 * @param {Array<any>} parsed - array for tracking recursive loops
 */


function getShape(id, store, shapes, parsed) {
  var shapeQuads = store.getQuads(id, undefined, undefined);
  if (shapeQuads.length === 0) return;
  parsed.push(id);

  var _iterator8 = _createForOfIteratorHelper(store.getQuads(id, undefined, undefined)),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var quad = _step8.value;

      if (parsed.includes(quad.object.id)) {
        shapeQuads.push(quad);
        continue;
      }

      var nestedStore = void 0;

      if (shapes.get(quad.object)) {
        nestedStore = shapes.get(quad.object.id);
      } else {
        nestedStore = getShape(quad.object.id, store, shapes, parsed);
      }

      if (nestedStore && nestedStore.getQuads().length > 0) {
        shapeQuads.push.apply(shapeQuads, (0, _toConsumableArray2["default"])(nestedStore.getQuads()));
      }
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  var shapeStore = new Store();

  var _iterator9 = _createForOfIteratorHelper(shapeQuads),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var _quad = _step9.value;
      shapeStore.addQuad(_quad);
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  return shapeStore;
}

module.exports = {
  randomUrl: randomUrl,
  loadData: loadData,
  uniqueBy: uniqueBy,
  quadsToShapes: quadsToShapes
};

},{"./errors":1,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/toConsumableArray":26,"@babel/runtime/regenerator":30,"axios":31,"fs":59,"jsonld":107,"n3":135,"rdfa-streaming-parser":163}]},{},[198])(198)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJlcnJvcnMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm9uaWNhbGl6ZS9saWIvY2Fub25pY2FsaXplLmpzIiwibm9kZV9tb2R1bGVzL2RvbS1zZXJpYWxpemVyL2xpYi9mb3JlaWduTmFtZXMuanMiLCJub2RlX21vZHVsZXMvZG9tLXNlcmlhbGl6ZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbWVsZW1lbnR0eXBlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb21oYW5kbGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb21oYW5kbGVyL2xpYi9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb211dGlscy9saWIvbGVnYWN5LmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9tYW5pcHVsYXRpb24uanMiLCJub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL3F1ZXJ5aW5nLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL3RhZ3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi90cmF2ZXJzYWwuanMiLCJub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZGVjb2RlX2NvZGVwb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvbWFwcy9kZWNvZGUuanNvbiIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9tYXBzL2xlZ2FjeS5qc29uIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9tYXBzL3htbC5qc29uIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL0ZlZWRIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9QYXJzZXIuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL1Rva2VuaXplci5qcyIsIm5vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvQ29udGV4dFJlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvSnNvbkxkRXJyb3IuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9Kc29uTGRQcm9jZXNzb3IuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9OUXVhZHMuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9SZGZhLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvUmVxdWVzdFF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvUmVzb2x2ZWRDb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvY29tcGFjdC5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL2NvbnRleHQuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9kb2N1bWVudExvYWRlcnMvbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL2RvY3VtZW50TG9hZGVycy94aHIuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9leHBhbmQuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvZnJhbWUuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9mcm9tUmRmLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvZ3JhcGhUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL2pzb25sZC5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL25vZGVNYXAuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi90b1JkZi5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvdXJsLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9kYXRhLXJkZi1zdHJlYW1pbmctcGFyc2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvSUh0bWxQYXJzZUxpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvSUl0ZW1TY29wZS5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb2RhdGEtcmRmLXN0cmVhbWluZy1wYXJzZXIvbGliL0lWb2NhYlJlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvTWljcm9kYXRhUmRmUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb2RhdGEtcmRmLXN0cmVhbWluZy1wYXJzZXIvbGliL3Byb3BlcnR5aGFuZGxlci9JSXRlbVByb3BlcnR5SGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb2RhdGEtcmRmLXN0cmVhbWluZy1wYXJzZXIvbGliL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyQ29udGVudC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb2RhdGEtcmRmLXN0cmVhbWluZy1wYXJzZXIvbGliL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwuanMiLCJub2RlX21vZHVsZXMvbWljcm9kYXRhLXJkZi1zdHJlYW1pbmctcGFyc2VyL2xpYi92b2NhYi1yZWdpc3RyeS1kZWZhdWx0Lmpzb24iLCJub2RlX21vZHVsZXMvbjMvbGliL0lSSXMuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL04zRGF0YUZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL04zTGV4ZXIuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL04zUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL24zL2xpYi9OM1N0b3JlLmpzIiwibm9kZV9tb2R1bGVzL24zL2xpYi9OM1N0cmVhbVBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9uMy9saWIvTjNTdHJlYW1Xcml0ZXIuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL04zVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9uMy9saWIvTjNXcml0ZXIuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Jhc2VOLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2ZvcmdlLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21kLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTEuanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhMjU2LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXVlLW1pY3JvdGFzay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL0FzeW5jQWxnb3JpdGhtLmpzIiwibm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvSWRlbnRpZmllcklzc3Vlci5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL01lc3NhZ2VEaWdlc3QtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL05RdWFkcy5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL1Blcm11dGF0b3IuanMiLCJub2RlX21vZHVsZXMvcmRmLWNhbm9uaXplL2xpYi9VUkROQTIwMTUuanMiLCJub2RlX21vZHVsZXMvcmRmLWNhbm9uaXplL2xpYi9VUkROQTIwMTVTeW5jLmpzIiwibm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvVVJHTkEyMDEyLmpzIiwibm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvVVJHTkEyMDEyU3luYy5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JkZi1kYXRhLWZhY3RvcnkvbGliL0JsYW5rTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2xpYi9EYXRhRmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2xpYi9EZWZhdWx0R3JhcGguanMiLCJub2RlX21vZHVsZXMvcmRmLWRhdGEtZmFjdG9yeS9saWIvTGl0ZXJhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2xpYi9OYW1lZE5vZGUuanMiLCJub2RlX21vZHVsZXMvcmRmLWRhdGEtZmFjdG9yeS9saWIvUXVhZC5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2xpYi9WYXJpYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZGZhLXN0cmVhbWluZy1wYXJzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmRmYS1zdHJlYW1pbmctcGFyc2VyL2xpYi9JQWN0aXZlVGFnLmpzIiwibm9kZV9tb2R1bGVzL3JkZmEtc3RyZWFtaW5nLXBhcnNlci9saWIvSVJkZmFQYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL3JkZmEtc3RyZWFtaW5nLXBhcnNlci9saWIvUmRmYVBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9yZGZhLXN0cmVhbWluZy1wYXJzZXIvbGliL1JkZmFQcm9maWxlLmpzIiwibm9kZV9tb2R1bGVzL3JkZmEtc3RyZWFtaW5nLXBhcnNlci9saWIvVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9yZGZhLXN0cmVhbWluZy1wYXJzZXIvbGliL2luaXRpYWwtY29udGV4dC14aHRtbC5qc29uIiwibm9kZV9tb2R1bGVzL3JkZmEtc3RyZWFtaW5nLXBhcnNlci9saWIvaW5pdGlhbC1jb250ZXh0Lmpzb24iLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL3JlbGF0aXZlLXRvLWFic29sdXRlLWlyaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWxhdGl2ZS10by1hYnNvbHV0ZS1pcmkvbGliL1Jlc29sdmUuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy95YWxsaXN0L2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsInBhcnNlci5qcyIsInBhcnNpbmctaW5kZXguanMiLCJ1dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ00sZ0I7Ozs7O0FBQ0YsNEJBQVksT0FBWixFQUFxQjtBQUFBOztBQUFBO0FBQ2pCLDhCQUFNLE9BQU47QUFDQSxVQUFLLElBQUwsR0FBWSxrQkFBWjtBQUZpQjtBQUdwQjs7O2tEQUowQixLOztJQU96QixtQjs7Ozs7QUFDRiwrQkFBWSxPQUFaLEVBQXFCO0FBQUE7O0FBQUE7QUFDakIsZ0NBQU0sT0FBTjtBQUNBLFdBQUssSUFBTCxHQUFZLHFCQUFaO0FBRmlCO0FBR3BCOzs7a0RBSjZCLEs7O0FBT2xDLE1BQU0sQ0FBQyxPQUFQLEdBQWlCO0FBQ2IsRUFBQSxnQkFBZ0IsRUFBRSxnQkFETDtBQUViLEVBQUEsbUJBQW1CLEVBQUU7QUFGUixDQUFqQjs7Ozs7QUM3QkEsU0FBUyxp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QUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRztBQUFoQyxDQUFuQztBQUNBLElBQUksa0JBQWtCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUEvQztBQUNBLElBQUksa0JBQWtCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUEvQztBQUNBLElBQUksa0JBQWtCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUEvQztBQUNBLElBQUksa0JBQWtCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUEvQztBQUNBLElBQUksaUJBQWlCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRTtBQUEvQixDQUFuQztBQUNBLElBQUksaUJBQWlCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRTtBQUEvQixDQUFuQztBQUNBLElBQUksaUJBQWlCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRTtBQUEvQixDQUFuQztBQUNBLElBQUksaUJBQWlCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRTtBQUEvQixDQUFuQztBQUNBLElBQUksaUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUE5QztBQUNBLElBQUksaUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUE5QztBQUNBLElBQUksaUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUE5QztBQUNBLElBQUksZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7QUFBRTtBQUE5QixDQUFsQztBQUNBLElBQUksZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7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c0JBQTdCLENBQW9ELE1BQXBELEVBQTRELE1BQTVELENBSHdDLEVBSXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE9BQXBELEVBQTZELEtBQTdELENBSndDLEVBS3hDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE9BQXBELEVBQTZELEtBQTdELENBTHdDLEVBTXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELFFBQXBELEVBQThELEtBQTlELENBTndDLEVBT3hDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELEtBQXBELEVBQTJELEtBQTNELENBUHdDLEVBUXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE1BQXBELEVBQTRELE1BQTVELENBUndDLEVBU3hDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELFFBQXBELEVBQThELE1BQTlELENBVHdDLEVBVXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELFFBQXBELEVBQThELEtBQTlELENBVndDLEVBV3hDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE9BQXBELEVBQTZELEtBQTdELENBWHdDLEVBWXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE9BQXBELEVBQTZELEtBQTdELENBWndDLEVBYXhDLElBQUksMkJBQTJCLENBQUMseUJBQWhDLENBQTBELE1BQTFELEVBQWtFLE9BQWxFLENBYndDLEVBY3hDLElBQUksMkJBQTJCLENBQUMseUJBQWhDLENBQTBELE9BQTFELEVBQW1FLE9BQW5FLENBZHdDLEVBZXhDLElBQUkseUJBQXlCLENBQUMsdUJBQTlCLEVBZndDLENBQTVDOzs7QUNwYUE7Ozs7Ozs7Ozs7QUFDQSxNQUFNLENBQUMsY0FBUCxDQUFzQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFLEVBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7QUFDQSxPQUFPLENBQUMsSUFBUixHQUFlLEtBQUssQ0FBcEI7O0FBQ0EsSUFBTSxrQkFBa0IsR0FBRyxPQUFP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LFFBQUEsV0FBVyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTCxDQUFZLEVBQWIsRUFBaUIsS0FBakIsRUFBd0IsTUFBeEIsRUFBZ0MsTUFBaEMsQ0FBdEI7QUFDSDs7QUFDRCxVQUFJLFdBQVcsSUFBSSxXQUFXLENBQUMsUUFBWixHQUF1QixNQUF2QixHQUFnQyxDQUFuRCxFQUFzRDtBQUNsRCxRQUFBLFVBQVUsQ0FBQyxJQUFYLE9BQUEsVUFBVSxzQ0FBUyxXQUFXLENBQUMsUUFBWixFQUFULEVBQVY7QUFDSDtBQUNKO0FBbEJ3QztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW1CekMsTUFBTSxVQUFVLEdBQUcsSUFBSSxLQUFKLEVBQW5COztBQW5CeUMsOENBb0J0QixVQXBCc0I7QUFBQTs7QUFBQTtBQW9CekMsMkRBQStCO0FBQUEsVUFBcEIsS0FBb0I7QUFDM0IsTUFBQSxVQUFVLENBQUMsT0FBWCxDQUFtQixLQUFuQjtBQUNIO0FBdEJ3QztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXVCekMsU0FBTyxVQUFQO0FBQ0g7O0FBR0QsTUFBTSxDQUFDLE9BQVAsR0FBaUI7QUFDYixFQUFBLFNBQVMsRUFBRSxTQURFO0FBRWIsRUFBQSxRQUFRLEVBQUUsUUFGRztBQUdiLEVBQUEsUUFBUSxFQUFFLFFBSEc7QUFJYixFQUFBLGFBQWEsRUFBRTtBQUpGLENBQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEludmFsaWREYXRhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkRGF0YUVycm9yXCI7XG4gICAgfVxufVxuXG5jbGFzcyBTaGV4VmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiU2hleFZhbGlkYXRpb25FcnJvclwiO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgSW52YWxpZERhdGFFcnJvcjogSW52YWxpZERhdGFFcnJvcixcbiAgICBTaGV4VmFsaWRhdGlvbkVycm9yOiBTaGV4VmFsaWRhdGlvbkVycm9yLFxufSIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbnZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3RcIik7XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwiZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVGdW5jdGlvbjsiLCJmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJ2YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IHJlcXVpcmUoXCIuL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIik7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXM7IiwiZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2U7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3RcIik7XG5cbmZ1bmN0aW9uIF90b0FycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0FycmF5OyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZlwiKTtcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbnZhciBpc05hdGl2ZUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vaXNOYXRpdmVGdW5jdGlvblwiKTtcblxudmFyIGNvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdFwiKTtcblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIWlzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIGdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIGlmIChcbiAgICAgICh1dGlscy5pc0Jsb2IocmVxdWVzdERhdGEpIHx8IHV0aWxzLmlzRmlsZShyZXF1ZXN0RGF0YSkpICYmXG4gICAgICByZXF1ZXN0RGF0YS50eXBlXG4gICAgKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IodGltZW91dEVycm9yTWVzc2FnZSwgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdkYXRhJ107XG4gIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5JywgJ3BhcmFtcyddO1xuICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgJ2Jhc2VVUkwnLCAndHJhbnNmb3JtUmVxdWVzdCcsICd0cmFuc2Zvcm1SZXNwb25zZScsICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAndGltZW91dCcsICd0aW1lb3V0TWVzc2FnZScsICd3aXRoQ3JlZGVudGlhbHMnLCAnYWRhcHRlcicsICdyZXNwb25zZVR5cGUnLCAneHNyZkNvb2tpZU5hbWUnLFxuICAgICd4c3JmSGVhZGVyTmFtZScsICdvblVwbG9hZFByb2dyZXNzJywgJ29uRG93bmxvYWRQcm9ncmVzcycsICdkZWNvbXByZXNzJyxcbiAgICAnbWF4Q29udGVudExlbmd0aCcsICdtYXhCb2R5TGVuZ3RoJywgJ21heFJlZGlyZWN0cycsICd0cmFuc3BvcnQnLCAnaHR0cEFnZW50JyxcbiAgICAnaHR0cHNBZ2VudCcsICdjYW5jZWxUb2tlbicsICdzb2NrZXRQYXRoJywgJ3Jlc3BvbnNlRW5jb2RpbmcnXG4gIF07XG4gIHZhciBkaXJlY3RNZXJnZUtleXMgPSBbJ3ZhbGlkYXRlU3RhdHVzJ107XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB1dGlscy5mb3JFYWNoKHZhbHVlRnJvbUNvbmZpZzJLZXlzLCBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgdXRpbHMuZm9yRWFjaChkZWZhdWx0VG9Db25maWcyS2V5cywgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goZGlyZWN0TWVyZ2VLZXlzLCBmdW5jdGlvbiBtZXJnZShwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAuY29uY2F0KG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzKVxuICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpXG4gICAgLmNvbmNhdChkaXJlY3RNZXJnZUtleXMpO1xuXG4gIHZhciBvdGhlcktleXMgPSBPYmplY3RcbiAgICAua2V5cyhjb25maWcxKVxuICAgIC5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpXG4gICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiWFgwPSIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG4vKiBqc2xpbnQgbm9kZTogdHJ1ZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZShvYmplY3QpO1xuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZSAob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JyB8fCBvYmplY3QudG9KU09OICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmplY3QpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpICYmIG9iamVjdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnW10nO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpICYmIG9iamVjdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiAnWycgKyBzZXJpYWxpemUob2JqZWN0WzBdKSArICddJztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgcmV0dXJuICdbJyArIG9iamVjdC5yZWR1Y2UoKHQsIGN2LCBjaSkgPT4ge1xuICAgICAgICB0ID0gKGNpID09PSAxID8gc2VyaWFsaXplKHQpIDogdCk7XG4gICAgICAgIHJldHVybiB0ICsgJywnICsgc2VyaWFsaXplKGN2KTtcbiAgICAgIH0pICsgJ10nO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAne30nO1xuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiAneycgKyBzZXJpYWxpemUoa2V5c1swXSkgKyAnOicgKyBzZXJpYWxpemUob2JqZWN0W2tleXNbMF1dKSArICd9JztcbiAgICB9XG4gICAgcmV0dXJuICd7JyArIGtleXMuc29ydCgpLnJlZHVjZSgodCwgY3YsIGNpKSA9PiB7XG4gICAgICB0ID0gKGNpID09PSAxID8gc2VyaWFsaXplKHQpICsgJzonICsgc2VyaWFsaXplKG9iamVjdFt0XSkgOiB0KTtcbiAgICAgIHJldHVybiB0ICsgJywnICsgc2VyaWFsaXplKGN2KSArICc6JyArIHNlcmlhbGl6ZShvYmplY3RbY3ZdKTtcbiAgICB9KSArICd9JztcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hdHRyaWJ1dGVOYW1lcyA9IGV4cG9ydHMuZWxlbWVudE5hbWVzID0gdm9pZCAwO1xuZXhwb3J0cy5lbGVtZW50TmFtZXMgPSBuZXcgTWFwKFtcbiAgICBbXCJhbHRnbHlwaFwiLCBcImFsdEdseXBoXCJdLFxuICAgIFtcImFsdGdseXBoZGVmXCIsIFwiYWx0R2x5cGhEZWZcIl0sXG4gICAgW1wiYWx0Z2x5cGhpdGVtXCIsIFwiYWx0R2x5cGhJdGVtXCJdLFxuICAgIFtcImFuaW1hdGVjb2xvclwiLCBcImFuaW1hdGVDb2xvclwiXSxcbiAgICBbXCJhbmltYXRlbW90aW9uXCIsIFwiYW5pbWF0ZU1vdGlvblwiXSxcbiAgICBbXCJhbmltYXRldHJhbnNmb3JtXCIsIFwiYW5pbWF0ZVRyYW5zZm9ybVwiXSxcbiAgICBbXCJjbGlwcGF0aFwiLCBcImNsaXBQYXRoXCJdLFxuICAgIFtcImZlYmxlbmRcIiwgXCJmZUJsZW5kXCJdLFxuICAgIFtcImZlY29sb3JtYXRyaXhcIiwgXCJmZUNvbG9yTWF0cml4XCJdLFxuICAgIFtcImZlY29tcG9uZW50dHJhbnNmZXJcIiwgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCJdLFxuICAgIFtcImZlY29tcG9zaXRlXCIsIFwiZmVDb21wb3NpdGVcIl0sXG4gICAgW1wiZmVjb252b2x2ZW1hdHJpeFwiLCBcImZlQ29udm9sdmVNYXRyaXhcIl0sXG4gICAgW1wiZmVkaWZmdXNlbGlnaHRpbmdcIiwgXCJmZURpZmZ1c2VMaWdodGluZ1wiXSxcbiAgICBbXCJmZWRpc3BsYWNlbWVudG1hcFwiLCBcImZlRGlzcGxhY2VtZW50TWFwXCJdLFxuICAgIFtcImZlZGlzdGFudGxpZ2h0XCIsIFwiZmVEaXN0YW50TGlnaHRcIl0sXG4gICAgW1wiZmVkcm9wc2hhZG93XCIsIFwiZmVEcm9wU2hhZG93XCJdLFxuICAgIFtcImZlZmxvb2RcIiwgXCJmZUZsb29kXCJdLFxuICAgIFtcImZlZnVuY2FcIiwgXCJmZUZ1bmNBXCJdLFxuICAgIFtcImZlZnVuY2JcIiwgXCJmZUZ1bmNCXCJdLFxuICAgIFtcImZlZnVuY2dcIiwgXCJmZUZ1bmNHXCJdLFxuICAgIFtcImZlZnVuY3JcIiwgXCJmZUZ1bmNSXCJdLFxuICAgIFtcImZlZ2F1c3NpYW5ibHVyXCIsIFwiZmVHYXVzc2lhbkJsdXJcIl0sXG4gICAgW1wiZmVpbWFnZVwiLCBcImZlSW1hZ2VcIl0sXG4gICAgW1wiZmVtZXJnZVwiLCBcImZlTWVyZ2VcIl0sXG4gICAgW1wiZmVtZXJnZW5vZGVcIiwgXCJmZU1lcmdlTm9kZVwiXSxcbiAgICBbXCJmZW1vcnBob2xvZ3lcIiwgXCJmZU1vcnBob2xvZ3lcIl0sXG4gICAgW1wiZmVvZmZzZXRcIiwgXCJmZU9mZnNldFwiXSxcbiAgICBbXCJmZXBvaW50bGlnaHRcIiwgXCJmZVBvaW50TGlnaHRcIl0sXG4gICAgW1wiZmVzcGVjdWxhcmxpZ2h0aW5nXCIsIFwiZmVTcGVjdWxhckxpZ2h0aW5nXCJdLFxuICAgIFtcImZlc3BvdGxpZ2h0XCIsIFwiZmVTcG90TGlnaHRcIl0sXG4gICAgW1wiZmV0aWxlXCIsIFwiZmVUaWxlXCJdLFxuICAgIFtcImZldHVyYnVsZW5jZVwiLCBcImZlVHVyYnVsZW5jZVwiXSxcbiAgICBbXCJmb3JlaWdub2JqZWN0XCIsIFwiZm9yZWlnbk9iamVjdFwiXSxcbiAgICBbXCJnbHlwaHJlZlwiLCBcImdseXBoUmVmXCJdLFxuICAgIFtcImxpbmVhcmdyYWRpZW50XCIsIFwibGluZWFyR3JhZGllbnRcIl0sXG4gICAgW1wicmFkaWFsZ3JhZGllbnRcIiwgXCJyYWRpYWxHcmFkaWVudFwiXSxcbiAgICBbXCJ0ZXh0cGF0aFwiLCBcInRleHRQYXRoXCJdLFxuXSk7XG5leHBvcnRzLmF0dHJpYnV0ZU5hbWVzID0gbmV3IE1hcChbXG4gICAgW1wiZGVmaW5pdGlvbnVybFwiLCBcImRlZmluaXRpb25VUkxcIl0sXG4gICAgW1wiYXR0cmlidXRlbmFtZVwiLCBcImF0dHJpYnV0ZU5hbWVcIl0sXG4gICAgW1wiYXR0cmlidXRldHlwZVwiLCBcImF0dHJpYnV0ZVR5cGVcIl0sXG4gICAgW1wiYmFzZWZyZXF1ZW5jeVwiLCBcImJhc2VGcmVxdWVuY3lcIl0sXG4gICAgW1wiYmFzZXByb2ZpbGVcIiwgXCJiYXNlUHJvZmlsZVwiXSxcbiAgICBbXCJjYWxjbW9kZVwiLCBcImNhbGNNb2RlXCJdLFxuICAgIFtcImNsaXBwYXRodW5pdHNcIiwgXCJjbGlwUGF0aFVuaXRzXCJdLFxuICAgIFtcImRpZmZ1c2Vjb25zdGFudFwiLCBcImRpZmZ1c2VDb25zdGFudFwiXSxcbiAgICBbXCJlZGdlbW9kZVwiLCBcImVkZ2VNb2RlXCJdLFxuICAgIFtcImZpbHRlcnVuaXRzXCIsIFwiZmlsdGVyVW5pdHNcIl0sXG4gICAgW1wiZ2x5cGhyZWZcIiwgXCJnbHlwaFJlZlwiXSxcbiAgICBbXCJncmFkaWVudHRyYW5zZm9ybVwiLCBcImdyYWRpZW50VHJhbnNmb3JtXCJdLFxuICAgIFtcImdyYWRpZW50dW5pdHNcIiwgXCJncmFkaWVudFVuaXRzXCJdLFxuICAgIFtcImtlcm5lbG1hdHJpeFwiLCBcImtlcm5lbE1hdHJpeFwiXSxcbiAgICBbXCJrZXJuZWx1bml0bGVuZ3RoXCIsIFwia2VybmVsVW5pdExlbmd0aFwiXSxcbiAgICBbXCJrZXlwb2ludHNcIiwgXCJrZXlQb2ludHNcIl0sXG4gICAgW1wia2V5c3BsaW5lc1wiLCBcImtleVNwbGluZXNcIl0sXG4gICAgW1wia2V5dGltZXNcIiwgXCJrZXlUaW1lc1wiXSxcbiAgICBbXCJsZW5ndGhhZGp1c3RcIiwgXCJsZW5ndGhBZGp1c3RcIl0sXG4gICAgW1wibGltaXRpbmdjb25lYW5nbGVcIiwgXCJsaW1pdGluZ0NvbmVBbmdsZVwiXSxcbiAgICBbXCJtYXJrZXJoZWlnaHRcIiwgXCJtYXJrZXJIZWlnaHRcIl0sXG4gICAgW1wibWFya2VydW5pdHNcIiwgXCJtYXJrZXJVbml0c1wiXSxcbiAgICBbXCJtYXJrZXJ3aWR0aFwiLCBcIm1hcmtlcldpZHRoXCJdLFxuICAgIFtcIm1hc2tjb250ZW50dW5pdHNcIiwgXCJtYXNrQ29udGVudFVuaXRzXCJdLFxuICAgIFtcIm1hc2t1bml0c1wiLCBcIm1hc2tVbml0c1wiXSxcbiAgICBbXCJudW1vY3RhdmVzXCIsIFwibnVtT2N0YXZlc1wiXSxcbiAgICBbXCJwYXRobGVuZ3RoXCIsIFwicGF0aExlbmd0aFwiXSxcbiAgICBbXCJwYXR0ZXJuY29udGVudHVuaXRzXCIsIFwicGF0dGVybkNvbnRlbnRVbml0c1wiXSxcbiAgICBbXCJwYXR0ZXJudHJhbnNmb3JtXCIsIFwicGF0dGVyblRyYW5zZm9ybVwiXSxcbiAgICBbXCJwYXR0ZXJudW5pdHNcIiwgXCJwYXR0ZXJuVW5pdHNcIl0sXG4gICAgW1wicG9pbnRzYXR4XCIsIFwicG9pbnRzQXRYXCJdLFxuICAgIFtcInBvaW50c2F0eVwiLCBcInBvaW50c0F0WVwiXSxcbiAgICBbXCJwb2ludHNhdHpcIiwgXCJwb2ludHNBdFpcIl0sXG4gICAgW1wicHJlc2VydmVhbHBoYVwiLCBcInByZXNlcnZlQWxwaGFcIl0sXG4gICAgW1wicHJlc2VydmVhc3BlY3RyYXRpb1wiLCBcInByZXNlcnZlQXNwZWN0UmF0aW9cIl0sXG4gICAgW1wicHJpbWl0aXZldW5pdHNcIiwgXCJwcmltaXRpdmVVbml0c1wiXSxcbiAgICBbXCJyZWZ4XCIsIFwicmVmWFwiXSxcbiAgICBbXCJyZWZ5XCIsIFwicmVmWVwiXSxcbiAgICBbXCJyZXBlYXRjb3VudFwiLCBcInJlcGVhdENvdW50XCJdLFxuICAgIFtcInJlcGVhdGR1clwiLCBcInJlcGVhdER1clwiXSxcbiAgICBbXCJyZXF1aXJlZGV4dGVuc2lvbnNcIiwgXCJyZXF1aXJlZEV4dGVuc2lvbnNcIl0sXG4gICAgW1wicmVxdWlyZWRmZWF0dXJlc1wiLCBcInJlcXVpcmVkRmVhdHVyZXNcIl0sXG4gICAgW1wic3BlY3VsYXJjb25zdGFudFwiLCBcInNwZWN1bGFyQ29uc3RhbnRcIl0sXG4gICAgW1wic3BlY3VsYXJleHBvbmVudFwiLCBcInNwZWN1bGFyRXhwb25lbnRcIl0sXG4gICAgW1wic3ByZWFkbWV0aG9kXCIsIFwic3ByZWFkTWV0aG9kXCJdLFxuICAgIFtcInN0YXJ0b2Zmc2V0XCIsIFwic3RhcnRPZmZzZXRcIl0sXG4gICAgW1wic3RkZGV2aWF0aW9uXCIsIFwic3RkRGV2aWF0aW9uXCJdLFxuICAgIFtcInN0aXRjaHRpbGVzXCIsIFwic3RpdGNoVGlsZXNcIl0sXG4gICAgW1wic3VyZmFjZXNjYWxlXCIsIFwic3VyZmFjZVNjYWxlXCJdLFxuICAgIFtcInN5c3RlbWxhbmd1YWdlXCIsIFwic3lzdGVtTGFuZ3VhZ2VcIl0sXG4gICAgW1widGFibGV2YWx1ZXNcIiwgXCJ0YWJsZVZhbHVlc1wiXSxcbiAgICBbXCJ0YXJnZXR4XCIsIFwidGFyZ2V0WFwiXSxcbiAgICBbXCJ0YXJnZXR5XCIsIFwidGFyZ2V0WVwiXSxcbiAgICBbXCJ0ZXh0bGVuZ3RoXCIsIFwidGV4dExlbmd0aFwiXSxcbiAgICBbXCJ2aWV3Ym94XCIsIFwidmlld0JveFwiXSxcbiAgICBbXCJ2aWV3dGFyZ2V0XCIsIFwidmlld1RhcmdldFwiXSxcbiAgICBbXCJ4Y2hhbm5lbHNlbGVjdG9yXCIsIFwieENoYW5uZWxTZWxlY3RvclwiXSxcbiAgICBbXCJ5Y2hhbm5lbHNlbGVjdG9yXCIsIFwieUNoYW5uZWxTZWxlY3RvclwiXSxcbiAgICBbXCJ6b29tYW5kcGFuXCIsIFwiem9vbUFuZFBhblwiXSxcbl0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG52YXIgRWxlbWVudFR5cGUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpKTtcbnZhciBlbnRpdGllc18xID0gcmVxdWlyZShcImVudGl0aWVzXCIpO1xuLypcbiAqIE1peGVkLWNhc2UgU1ZHIGFuZCBNYXRoTUwgdGFncyAmIGF0dHJpYnV0ZXNcbiAqIHJlY29nbml6ZWQgYnkgdGhlIEhUTUwgcGFyc2VyLCBzZWVcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNwYXJzaW5nLW1haW4taW5mb3JlaWduXG4gKi9cbnZhciBmb3JlaWduTmFtZXNfMSA9IHJlcXVpcmUoXCIuL2ZvcmVpZ25OYW1lc1wiKTtcbnZhciB1bmVuY29kZWRFbGVtZW50cyA9IG5ldyBTZXQoW1xuICAgIFwic3R5bGVcIixcbiAgICBcInNjcmlwdFwiLFxuICAgIFwieG1wXCIsXG4gICAgXCJpZnJhbWVcIixcbiAgICBcIm5vZW1iZWRcIixcbiAgICBcIm5vZnJhbWVzXCIsXG4gICAgXCJwbGFpbnRleHRcIixcbiAgICBcIm5vc2NyaXB0XCIsXG5dKTtcbi8qKlxuICogRm9ybWF0IGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBvcHRzKSB7XG4gICAgaWYgKCFhdHRyaWJ1dGVzKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgdmFsdWUgPSAoX2EgPSBhdHRyaWJ1dGVzW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIGlmIChvcHRzLnhtbE1vZGUgPT09IFwiZm9yZWlnblwiKSB7XG4gICAgICAgICAgICAvKiBGaXggdXAgbWl4ZWQtY2FzZSBhdHRyaWJ1dGUgbmFtZXMgKi9cbiAgICAgICAgICAgIGtleSA9IChfYiA9IGZvcmVpZ25OYW1lc18xLmF0dHJpYnV0ZU5hbWVzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLmVtcHR5QXR0cnMgJiYgIW9wdHMueG1sTW9kZSAmJiB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5ICsgXCI9XFxcIlwiICsgKG9wdHMuZGVjb2RlRW50aXRpZXMgPyBlbnRpdGllc18xLmVuY29kZVhNTCh2YWx1ZSkgOiB2YWx1ZS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKSkgKyBcIlxcXCJcIjtcbiAgICB9KVxuICAgICAgICAuam9pbihcIiBcIik7XG59XG4vKipcbiAqIFNlbGYtZW5jbG9zaW5nIHRhZ3NcbiAqL1xudmFyIHNpbmdsZVRhZyA9IG5ldyBTZXQoW1xuICAgIFwiYXJlYVwiLFxuICAgIFwiYmFzZVwiLFxuICAgIFwiYmFzZWZvbnRcIixcbiAgICBcImJyXCIsXG4gICAgXCJjb2xcIixcbiAgICBcImNvbW1hbmRcIixcbiAgICBcImVtYmVkXCIsXG4gICAgXCJmcmFtZVwiLFxuICAgIFwiaHJcIixcbiAgICBcImltZ1wiLFxuICAgIFwiaW5wdXRcIixcbiAgICBcImlzaW5kZXhcIixcbiAgICBcImtleWdlblwiLFxuICAgIFwibGlua1wiLFxuICAgIFwibWV0YVwiLFxuICAgIFwicGFyYW1cIixcbiAgICBcInNvdXJjZVwiLFxuICAgIFwidHJhY2tcIixcbiAgICBcIndiclwiLFxuXSk7XG4vKipcbiAqIFJlbmRlcnMgYSBET00gbm9kZSBvciBhbiBhcnJheSBvZiBET00gbm9kZXMgdG8gYSBzdHJpbmcuXG4gKlxuICogQ2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIGVxdWl2YWxlbnQgb2YgdGhlIGBvdXRlckhUTUxgIG9mIHRoZSBwYXNzZWQgbm9kZShzKS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGJlIHJlbmRlcmVkLlxuICogQHBhcmFtIG9wdGlvbnMgQ2hhbmdlcyBzZXJpYWxpemF0aW9uIGJlaGF2aW9yXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcihub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAvLyBUT0RPOiBUaGlzIGlzIGEgYml0IGhhY2t5LlxuICAgIHZhciBub2RlcyA9IEFycmF5LmlzQXJyYXkobm9kZSkgfHwgbm9kZS5jaGVlcmlvID8gbm9kZSA6IFtub2RlXTtcbiAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dHB1dCArPSByZW5kZXJOb2RlKG5vZGVzW2ldLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHJlbmRlcjtcbmZ1bmN0aW9uIHJlbmRlck5vZGUobm9kZSwgb3B0aW9ucykge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyKG5vZGUuY2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlLkRpcmVjdGl2ZTpcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJEaXJlY3RpdmUobm9kZSk7XG4gICAgICAgIGNhc2UgRWxlbWVudFR5cGUuQ29tbWVudDpcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJDb21tZW50KG5vZGUpO1xuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlLkNEQVRBOlxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlckNkYXRhKG5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlLmlzVGFnKG5vZGUpXG4gICAgICAgICAgICAgICAgPyByZW5kZXJUYWcobm9kZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHJlbmRlclRleHQobm9kZSwgb3B0aW9ucyk7XG4gICAgfVxufVxudmFyIGZvcmVpZ25Nb2RlSW50ZWdyYXRpb25Qb2ludHMgPSBuZXcgU2V0KFtcbiAgICBcIm1pXCIsXG4gICAgXCJtb1wiLFxuICAgIFwibW5cIixcbiAgICBcIm1zXCIsXG4gICAgXCJtdGV4dFwiLFxuICAgIFwiYW5ub3RhdGlvbi14bWxcIixcbiAgICBcImZvcmVpZ25PYmplY3RcIixcbiAgICBcImRlc2NcIixcbiAgICBcInRpdGxlXCIsXG5dKTtcbnZhciBmb3JlaWduRWxlbWVudHMgPSBuZXcgU2V0KFtcInN2Z1wiLCBcIm1hdGhcIl0pO1xuZnVuY3Rpb24gcmVuZGVyVGFnKGVsZW0sIG9wdHMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gSGFuZGxlIFNWRyAvIE1hdGhNTCBpbiBIVE1MXG4gICAgaWYgKG9wdHMueG1sTW9kZSA9PT0gXCJmb3JlaWduXCIpIHtcbiAgICAgICAgLyogRml4IHVwIG1peGVkLWNhc2UgZWxlbWVudCBuYW1lcyAqL1xuICAgICAgICBlbGVtLm5hbWUgPSAoX2EgPSBmb3JlaWduTmFtZXNfMS5lbGVtZW50TmFtZXMuZ2V0KGVsZW0ubmFtZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVsZW0ubmFtZTtcbiAgICAgICAgLyogRXhpdCBmb3JlaWduIG1vZGUgYXQgaW50ZWdyYXRpb24gcG9pbnRzICovXG4gICAgICAgIGlmIChlbGVtLnBhcmVudCAmJlxuICAgICAgICAgICAgZm9yZWlnbk1vZGVJbnRlZ3JhdGlvblBvaW50cy5oYXMoZWxlbS5wYXJlbnQubmFtZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0cyksIHsgeG1sTW9kZTogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRzLnhtbE1vZGUgJiYgZm9yZWlnbkVsZW1lbnRzLmhhcyhlbGVtLm5hbWUpKSB7XG4gICAgICAgIG9wdHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0cyksIHsgeG1sTW9kZTogXCJmb3JlaWduXCIgfSk7XG4gICAgfVxuICAgIHZhciB0YWcgPSBcIjxcIiArIGVsZW0ubmFtZTtcbiAgICB2YXIgYXR0cmlicyA9IGZvcm1hdEF0dHJpYnV0ZXMoZWxlbS5hdHRyaWJzLCBvcHRzKTtcbiAgICBpZiAoYXR0cmlicykge1xuICAgICAgICB0YWcgKz0gXCIgXCIgKyBhdHRyaWJzO1xuICAgIH1cbiAgICBpZiAoZWxlbS5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgKG9wdHMueG1sTW9kZVxuICAgICAgICAgICAgPyAvLyBJbiBYTUwgbW9kZSBvciBmb3JlaWduIG1vZGUsIGFuZCB1c2VyIGhhc24ndCBleHBsaWNpdGx5IHR1cm5lZCBvZmYgc2VsZi1jbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgICAgICBvcHRzLnNlbGZDbG9zaW5nVGFncyAhPT0gZmFsc2VcbiAgICAgICAgICAgIDogLy8gVXNlciBleHBsaWNpdGx5IGFza2VkIGZvciBzZWxmLWNsb3NpbmcgdGFncywgZXZlbiBpbiBIVE1MIG1vZGVcbiAgICAgICAgICAgICAgICBvcHRzLnNlbGZDbG9zaW5nVGFncyAmJiBzaW5nbGVUYWcuaGFzKGVsZW0ubmFtZSkpKSB7XG4gICAgICAgIGlmICghb3B0cy54bWxNb2RlKVxuICAgICAgICAgICAgdGFnICs9IFwiIFwiO1xuICAgICAgICB0YWcgKz0gXCIvPlwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFnICs9IFwiPlwiO1xuICAgICAgICBpZiAoZWxlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0YWcgKz0gcmVuZGVyKGVsZW0uY2hpbGRyZW4sIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnhtbE1vZGUgfHwgIXNpbmdsZVRhZy5oYXMoZWxlbS5uYW1lKSkge1xuICAgICAgICAgICAgdGFnICs9IFwiPC9cIiArIGVsZW0ubmFtZSArIFwiPlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5mdW5jdGlvbiByZW5kZXJEaXJlY3RpdmUoZWxlbSkge1xuICAgIHJldHVybiBcIjxcIiArIGVsZW0uZGF0YSArIFwiPlwiO1xufVxuZnVuY3Rpb24gcmVuZGVyVGV4dChlbGVtLCBvcHRzKSB7XG4gICAgdmFyIGRhdGEgPSBlbGVtLmRhdGEgfHwgXCJcIjtcbiAgICAvLyBJZiBlbnRpdGllcyB3ZXJlbid0IGRlY29kZWQsIG5vIG5lZWQgdG8gZW5jb2RlIHRoZW0gYmFja1xuICAgIGlmIChvcHRzLmRlY29kZUVudGl0aWVzICYmXG4gICAgICAgICEoZWxlbS5wYXJlbnQgJiYgdW5lbmNvZGVkRWxlbWVudHMuaGFzKGVsZW0ucGFyZW50Lm5hbWUpKSkge1xuICAgICAgICBkYXRhID0gZW50aXRpZXNfMS5lbmNvZGVYTUwoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gcmVuZGVyQ2RhdGEoZWxlbSkge1xuICAgIHJldHVybiBcIjwhW0NEQVRBW1wiICsgZWxlbS5jaGlsZHJlblswXS5kYXRhICsgXCJdXT5cIjtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbW1lbnQoZWxlbSkge1xuICAgIHJldHVybiBcIjwhLS1cIiArIGVsZW0uZGF0YSArIFwiLS0+XCI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRG9jdHlwZSA9IGV4cG9ydHMuQ0RBVEEgPSBleHBvcnRzLlRhZyA9IGV4cG9ydHMuU3R5bGUgPSBleHBvcnRzLlNjcmlwdCA9IGV4cG9ydHMuQ29tbWVudCA9IGV4cG9ydHMuRGlyZWN0aXZlID0gZXhwb3J0cy5UZXh0ID0gZXhwb3J0cy5pc1RhZyA9IHZvaWQgMDtcbi8qKlxuICogVGVzdHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGEgdGFnIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gZWxlbSBFbGVtZW50IHRvIHRlc3RcbiAqL1xuZnVuY3Rpb24gaXNUYWcoZWxlbSkge1xuICAgIHJldHVybiAoZWxlbS50eXBlID09PSBcInRhZ1wiIC8qIFRhZyAqLyB8fFxuICAgICAgICBlbGVtLnR5cGUgPT09IFwic2NyaXB0XCIgLyogU2NyaXB0ICovIHx8XG4gICAgICAgIGVsZW0udHlwZSA9PT0gXCJzdHlsZVwiIC8qIFN0eWxlICovKTtcbn1cbmV4cG9ydHMuaXNUYWcgPSBpc1RhZztcbi8vIEV4cG9ydHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4vKiogVHlwZSBmb3IgVGV4dCAqL1xuZXhwb3J0cy5UZXh0ID0gXCJ0ZXh0XCIgLyogVGV4dCAqLztcbi8qKiBUeXBlIGZvciA8PyAuLi4gPz4gKi9cbmV4cG9ydHMuRGlyZWN0aXZlID0gXCJkaXJlY3RpdmVcIiAvKiBEaXJlY3RpdmUgKi87XG4vKiogVHlwZSBmb3IgPCEtLSAuLi4gLS0+ICovXG5leHBvcnRzLkNvbW1lbnQgPSBcImNvbW1lbnRcIiAvKiBDb21tZW50ICovO1xuLyoqIFR5cGUgZm9yIDxzY3JpcHQ+IHRhZ3MgKi9cbmV4cG9ydHMuU2NyaXB0ID0gXCJzY3JpcHRcIiAvKiBTY3JpcHQgKi87XG4vKiogVHlwZSBmb3IgPHN0eWxlPiB0YWdzICovXG5leHBvcnRzLlN0eWxlID0gXCJzdHlsZVwiIC8qIFN0eWxlICovO1xuLyoqIFR5cGUgZm9yIEFueSB0YWcgKi9cbmV4cG9ydHMuVGFnID0gXCJ0YWdcIiAvKiBUYWcgKi87XG4vKiogVHlwZSBmb3IgPCFbQ0RBVEFbIC4uLiBdXT4gKi9cbmV4cG9ydHMuQ0RBVEEgPSBcImNkYXRhXCIgLyogQ0RBVEEgKi87XG4vKiogVHlwZSBmb3IgPCFkb2N0eXBlIC4uLj4gKi9cbmV4cG9ydHMuRG9jdHlwZSA9IFwiZG9jdHlwZVwiIC8qIERvY3R5cGUgKi87XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Eb21IYW5kbGVyID0gdm9pZCAwO1xudmFyIG5vZGVfMSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbm9kZVwiKSwgZXhwb3J0cyk7XG52YXIgcmVXaGl0ZXNwYWNlID0gL1xccysvZztcbi8vIERlZmF1bHQgb3B0aW9uc1xudmFyIGRlZmF1bHRPcHRzID0ge1xuICAgIG5vcm1hbGl6ZVdoaXRlc3BhY2U6IGZhbHNlLFxuICAgIHdpdGhTdGFydEluZGljZXM6IGZhbHNlLFxuICAgIHdpdGhFbmRJbmRpY2VzOiBmYWxzZSxcbn07XG52YXIgRG9tSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGVkIG9uY2UgcGFyc2luZyBoYXMgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFNldHRpbmdzIGZvciB0aGUgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gZWxlbWVudENCIENhbGxiYWNrIHdoZW5ldmVyIGEgdGFnIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEb21IYW5kbGVyKGNhbGxiYWNrLCBvcHRpb25zLCBlbGVtZW50Q0IpIHtcbiAgICAgICAgLyoqIFRoZSBjb25zdHJ1Y3RlZCBET00gKi9cbiAgICAgICAgdGhpcy5kb20gPSBbXTtcbiAgICAgICAgLyoqIEluZGljYXRlZCB3aGV0aGVyIHBhcnNpbmcgaGFzIGJlZW4gY29tcGxldGVkLiAqL1xuICAgICAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgICAgIC8qKiBTdGFjayBvZiBvcGVuIHRhZ3MuICovXG4gICAgICAgIHRoaXMuX3RhZ1N0YWNrID0gW107XG4gICAgICAgIC8qKiBBIGRhdGEgbm9kZSB0aGF0IGlzIHN0aWxsIGJlaW5nIHdyaXR0ZW4gdG8uICovXG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gbnVsbDtcbiAgICAgICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgcGFyc2VyIGluc3RhbmNlLiBVc2VkIGZvciBsb2NhdGlvbiBpbmZvcm1hdGlvbi4gKi9cbiAgICAgICAgdGhpcy5fcGFyc2VyID0gbnVsbDtcbiAgICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBza2lwIGFyZ3VtZW50cywgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBlbGVtZW50Q0IgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2sgIT09IG51bGwgJiYgY2FsbGJhY2sgIT09IHZvaWQgMCA/IGNhbGxiYWNrIDogbnVsbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IGRlZmF1bHRPcHRzO1xuICAgICAgICB0aGlzLl9lbGVtZW50Q0IgPSBlbGVtZW50Q0IgIT09IG51bGwgJiYgZWxlbWVudENCICE9PSB2b2lkIDAgPyBlbGVtZW50Q0IgOiBudWxsO1xuICAgIH1cbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbnBhcnNlcmluaXQgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IHBhcnNlcjtcbiAgICB9O1xuICAgIC8vIFJlc2V0cyB0aGUgaGFuZGxlciBiYWNrIHRvIHN0YXJ0aW5nIHN0YXRlXG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmRvbSA9IFtdO1xuICAgICAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RhZ1N0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyc2VyID0gKF9hID0gdGhpcy5fcGFyc2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH07XG4gICAgLy8gU2lnbmFscyB0aGUgaGFuZGxlciB0aGF0IHBhcnNpbmcgaXMgZG9uZVxuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZG9uZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2FsbGJhY2sobnVsbCk7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2FsbGJhY2soZXJyb3IpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25jbG9zZXRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSBudWxsO1xuICAgICAgICB2YXIgZWxlbSA9IHRoaXMuX3RhZ1N0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIWVsZW0gfHwgIXRoaXMuX3BhcnNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLndpdGhFbmRJbmRpY2VzKSB7XG4gICAgICAgICAgICBlbGVtLmVuZEluZGV4ID0gdGhpcy5fcGFyc2VyLmVuZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50Q0IpXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50Q0IoZWxlbSk7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbm9wZW50YWcgPSBmdW5jdGlvbiAobmFtZSwgYXR0cmlicykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IG5ldyBub2RlXzEuRWxlbWVudChuYW1lLCBhdHRyaWJzKTtcbiAgICAgICAgdGhpcy5hZGROb2RlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl90YWdTdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub250ZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZSA9IHRoaXMuX29wdGlvbnMubm9ybWFsaXplV2hpdGVzcGFjZTtcbiAgICAgICAgdmFyIF9sYXN0Tm9kZSA9IHRoaXMuX2xhc3ROb2RlO1xuICAgICAgICBpZiAoX2xhc3ROb2RlICYmIF9sYXN0Tm9kZS50eXBlID09PSBcInRleHRcIiAvKiBUZXh0ICovKSB7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgX2xhc3ROb2RlLmRhdGEgPSAoX2xhc3ROb2RlLmRhdGEgKyBkYXRhKS5yZXBsYWNlKHJlV2hpdGVzcGFjZSwgXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX2xhc3ROb2RlLmRhdGEgKz0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKHJlV2hpdGVzcGFjZSwgXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgbm9kZV8xLlRleHQoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmFkZE5vZGUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY29tbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0Tm9kZSAmJiB0aGlzLl9sYXN0Tm9kZS50eXBlID09PSBcImNvbW1lbnRcIiAvKiBDb21tZW50ICovKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Tm9kZS5kYXRhICs9IGRhdGE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgbm9kZV8xLkNvbW1lbnQoZGF0YSk7XG4gICAgICAgIHRoaXMuYWRkTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSBub2RlO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25jb21tZW50ZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IG51bGw7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbmNkYXRhc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IG5vZGVfMS5UZXh0KFwiXCIpO1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBub2RlXzEuTm9kZVdpdGhDaGlsZHJlbihcImNkYXRhXCIgLyogQ0RBVEEgKi8sIFt0ZXh0XSk7XG4gICAgICAgIHRoaXMuYWRkTm9kZShub2RlKTtcbiAgICAgICAgdGV4dC5wYXJlbnQgPSBub2RlO1xuICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IHRleHQ7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbmNkYXRhZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IG51bGw7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IG5vZGVfMS5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obmFtZSwgZGF0YSk7XG4gICAgICAgIHRoaXMuYWRkTm9kZShub2RlKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUNhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2soZXJyb3IsIHRoaXMuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fdGFnU3RhY2tbdGhpcy5fdGFnU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBzaWJsaW5ncyA9IHBhcmVudCA/IHBhcmVudC5jaGlsZHJlbiA6IHRoaXMuZG9tO1xuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gc2libGluZ3Nbc2libGluZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLl9wYXJzZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLndpdGhTdGFydEluZGljZXMpIHtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXJ0SW5kZXggPSB0aGlzLl9wYXJzZXIuc3RhcnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLndpdGhFbmRJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5lbmRJbmRleCA9IHRoaXMuX3BhcnNlci5lbmRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5ncy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAocHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgICBub2RlLnByZXYgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcubmV4dCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSBudWxsO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuYWRkRGF0YU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmFkZE5vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBEb21IYW5kbGVyO1xufSgpKTtcbmV4cG9ydHMuRG9tSGFuZGxlciA9IERvbUhhbmRsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBEb21IYW5kbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2xvbmVOb2RlID0gZXhwb3J0cy5FbGVtZW50ID0gZXhwb3J0cy5Ob2RlV2l0aENoaWxkcmVuID0gZXhwb3J0cy5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSBleHBvcnRzLkNvbW1lbnQgPSBleHBvcnRzLlRleHQgPSBleHBvcnRzLkRhdGFOb2RlID0gZXhwb3J0cy5Ob2RlID0gdm9pZCAwO1xudmFyIG5vZGVUeXBlcyA9IG5ldyBNYXAoW1xuICAgIFtcInRhZ1wiIC8qIFRhZyAqLywgMV0sXG4gICAgW1wic2NyaXB0XCIgLyogU2NyaXB0ICovLCAxXSxcbiAgICBbXCJzdHlsZVwiIC8qIFN0eWxlICovLCAxXSxcbiAgICBbXCJkaXJlY3RpdmVcIiAvKiBEaXJlY3RpdmUgKi8sIDFdLFxuICAgIFtcInRleHRcIiAvKiBUZXh0ICovLCAzXSxcbiAgICBbXCJjZGF0YVwiIC8qIENEQVRBICovLCA0XSxcbiAgICBbXCJjb21tZW50XCIgLyogQ29tbWVudCAqLywgOF0sXG5dKTtcbi8qKlxuICogVGhpcyBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIHRoZSBwcm90b3R5cGUgZm9yIE5vZGVzIHdoZW4gY3JlYXRpbmcgYVxuICogRE9NLUxldmVsLTEtY29tcGxpYW50IHN0cnVjdHVyZS5cbiAqL1xudmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOb2RlKHR5cGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLyoqIFBhcmVudCBvZiB0aGUgbm9kZSAqL1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIC8qKiBQcmV2aW91cyBzaWJsaW5nICovXG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgICAgIC8qKiBOZXh0IHNpYmxpbmcgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBzdGFydCBpbmRleCBvZiB0aGUgbm9kZS4gUmVxdWlyZXMgYHdpdGhTdGFydEluZGljZXNgIG9uIHRoZSBoYW5kbGVyIHRvIGJlIGB0cnVlLiAqL1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSBudWxsO1xuICAgICAgICAvKiogVGhlIGVuZCBpbmRleCBvZiB0aGUgbm9kZS4gUmVxdWlyZXMgYHdpdGhFbmRJbmRpY2VzYCBvbiB0aGUgaGFuZGxlciB0byBiZSBgdHJ1ZS4gKi9cbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgXCJub2RlVHlwZVwiLCB7XG4gICAgICAgIC8vIFJlYWQtb25seSBhbGlhc2VzXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IG5vZGVUeXBlcy5nZXQodGhpcy50eXBlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgXCJwYXJlbnROb2RlXCIsIHtcbiAgICAgICAgLy8gUmVhZC13cml0ZSBhbGlhc2VzIGZvciBwcm9wZXJ0aWVzXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCBcInByZXZpb3VzU2libGluZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocHJldikge1xuICAgICAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgXCJuZXh0U2libGluZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENsb25lIHRoaXMgbm9kZSwgYW5kIG9wdGlvbmFsbHkgaXRzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlY3Vyc2l2ZSBDbG9uZSBjaGlsZCBub2RlcyBhcyB3ZWxsLlxuICAgICAqIEByZXR1cm5zIEEgY2xvbmUgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgTm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlID0gZnVuY3Rpb24gKHJlY3Vyc2l2ZSkge1xuICAgICAgICBpZiAocmVjdXJzaXZlID09PSB2b2lkIDApIHsgcmVjdXJzaXZlID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIGNsb25lTm9kZSh0aGlzLCByZWN1cnNpdmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbnZhciBEYXRhTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0YU5vZGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgY29udGVudCBvZiB0aGUgZGF0YSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YU5vZGUodHlwZSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcIm5vZGVWYWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBEYXRhTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5EYXRhTm9kZSA9IERhdGFOb2RlO1xudmFyIFRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dChkYXRhKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcInRleHRcIiAvKiBUZXh0ICovLCBkYXRhKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGV4dDtcbn0oRGF0YU5vZGUpKTtcbmV4cG9ydHMuVGV4dCA9IFRleHQ7XG52YXIgQ29tbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21tZW50KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiY29tbWVudFwiIC8qIENvbW1lbnQgKi8sIGRhdGEpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21tZW50O1xufShEYXRhTm9kZSkpO1xuZXhwb3J0cy5Db21tZW50ID0gQ29tbWVudDtcbnZhciBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcImRpcmVjdGl2ZVwiIC8qIERpcmVjdGl2ZSAqLywgZGF0YSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFByb2Nlc3NpbmdJbnN0cnVjdGlvbjtcbn0oRGF0YU5vZGUpKTtcbmV4cG9ydHMuUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xudmFyIE5vZGVXaXRoQ2hpbGRyZW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vZGVXaXRoQ2hpbGRyZW4sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSBUeXBlIG9mIHRoZSBub2RlLlxuICAgICAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiBvZiB0aGUgbm9kZS4gT25seSBjZXJ0YWluIG5vZGUgdHlwZXMgY2FuIGhhdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9kZVdpdGhDaGlsZHJlbih0eXBlLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlV2l0aENoaWxkcmVuLnByb3RvdHlwZSwgXCJmaXJzdENoaWxkXCIsIHtcbiAgICAgICAgLy8gQWxpYXNlc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNoaWxkcmVuWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGVXaXRoQ2hpbGRyZW4ucHJvdG90eXBlLCBcImxhc3RDaGlsZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGVXaXRoQ2hpbGRyZW4ucHJvdG90eXBlLCBcImNoaWxkTm9kZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE5vZGVXaXRoQ2hpbGRyZW47XG59KE5vZGUpKTtcbmV4cG9ydHMuTm9kZVdpdGhDaGlsZHJlbiA9IE5vZGVXaXRoQ2hpbGRyZW47XG52YXIgRWxlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWxlbWVudCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB0YWcsIGVnLiBgZGl2YCwgYHNwYW5gLlxuICAgICAqIEBwYXJhbSBhdHRyaWJzIE9iamVjdCBtYXBwaW5nIGF0dHJpYnV0ZSBuYW1lcyB0byBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiBvZiB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50KG5hbWUsIGF0dHJpYnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSA9PT0gXCJzY3JpcHRcIlxuICAgICAgICAgICAgPyBcInNjcmlwdFwiIC8qIFNjcmlwdCAqL1xuICAgICAgICAgICAgOiBuYW1lID09PSBcInN0eWxlXCJcbiAgICAgICAgICAgICAgICA/IFwic3R5bGVcIiAvKiBTdHlsZSAqL1xuICAgICAgICAgICAgICAgIDogXCJ0YWdcIiAvKiBUYWcgKi8sIGNoaWxkcmVuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYXR0cmlicyA9IGF0dHJpYnM7XG4gICAgICAgIF90aGlzLmF0dHJpYnMgPSBhdHRyaWJzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbGVtZW50LnByb3RvdHlwZSwgXCJ0YWdOYW1lXCIsIHtcbiAgICAgICAgLy8gRE9NIExldmVsIDEgYWxpYXNlc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudC5wcm90b3R5cGUsIFwiYXR0cmlidXRlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5hdHRyaWJzW25hbWVdLFxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEVsZW1lbnQ7XG59KE5vZGVXaXRoQ2hpbGRyZW4pKTtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG4vKipcbiAqIENsb25lIGEgbm9kZSwgYW5kIG9wdGlvbmFsbHkgaXRzIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSByZWN1cnNpdmUgQ2xvbmUgY2hpbGQgbm9kZXMgYXMgd2VsbC5cbiAqIEByZXR1cm5zIEEgY2xvbmUgb2YgdGhlIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlLCByZWN1cnNpdmUpIHtcbiAgICBpZiAocmVjdXJzaXZlID09PSB2b2lkIDApIHsgcmVjdXJzaXZlID0gZmFsc2U7IH1cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dFwiIC8qIFRleHQgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHQobm9kZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcImRpcmVjdGl2ZVwiIC8qIERpcmVjdGl2ZSAqLzoge1xuICAgICAgICAgICAgdmFyIGluc3RyID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvY2Vzc2luZ0luc3RydWN0aW9uKGluc3RyLm5hbWUsIGluc3RyLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjb21tZW50XCIgLyogQ29tbWVudCAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tbWVudChub2RlLmRhdGEpO1xuICAgICAgICBjYXNlIFwidGFnXCIgLyogVGFnICovOlxuICAgICAgICBjYXNlIFwic2NyaXB0XCIgLyogU2NyaXB0ICovOlxuICAgICAgICBjYXNlIFwic3R5bGVcIiAvKiBTdHlsZSAqLzoge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBub2RlO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gcmVjdXJzaXZlID8gY2xvbmVDaGlsZHJlbihlbGVtLmNoaWxkcmVuKSA6IFtdO1xuICAgICAgICAgICAgdmFyIGNsb25lXzEgPSBuZXcgRWxlbWVudChlbGVtLm5hbWUsIF9fYXNzaWduKHt9LCBlbGVtLmF0dHJpYnMpLCBjaGlsZHJlbik7XG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gKGNoaWxkLnBhcmVudCA9IGNsb25lXzEpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZV8xO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjZGF0YVwiIC8qIENEQVRBICovOiB7XG4gICAgICAgICAgICB2YXIgY2RhdGEgPSBub2RlO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gcmVjdXJzaXZlID8gY2xvbmVDaGlsZHJlbihjZGF0YS5jaGlsZHJlbikgOiBbXTtcbiAgICAgICAgICAgIHZhciBjbG9uZV8yID0gbmV3IE5vZGVXaXRoQ2hpbGRyZW4oXCJjZGF0YVwiIC8qIENEQVRBICovLCBjaGlsZHJlbik7XG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gKGNoaWxkLnBhcmVudCA9IGNsb25lXzIpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZV8yO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkb2N0eXBlXCIgLyogRG9jdHlwZSAqLzoge1xuICAgICAgICAgICAgLy8gVGhpcyB0eXBlIGlzbid0IHVzZWQgeWV0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkIHlldDogRWxlbWVudFR5cGUuRG9jdHlwZSBjYXNlXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jbG9uZU5vZGUgPSBjbG9uZU5vZGU7XG5mdW5jdGlvbiBjbG9uZUNoaWxkcmVuKGNoaWxkcykge1xuICAgIHZhciBjaGlsZHJlbiA9IGNoaWxkcy5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjbG9uZU5vZGUoY2hpbGQsIHRydWUpOyB9KTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLnByZXYgPSBjaGlsZHJlbltpIC0gMV07XG4gICAgICAgIGNoaWxkcmVuW2kgLSAxXS5uZXh0ID0gY2hpbGRyZW5baV07XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmlxdWVTb3J0ID0gZXhwb3J0cy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA9IGV4cG9ydHMucmVtb3ZlU3Vic2V0cyA9IHZvaWQgMDtcbnZhciB0YWd0eXBlc18xID0gcmVxdWlyZShcIi4vdGFndHlwZXNcIik7XG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIG5vZGVzLCByZW1vdmUgYW55IG1lbWJlciB0aGF0IGlzIGNvbnRhaW5lZCBieSBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSBub2RlcyBOb2RlcyB0byBmaWx0ZXIuXG4gKiBAcmV0dXJucyBSZW1haW5pbmcgbm9kZXMgdGhhdCBhcmVuJ3Qgc3VidHJlZXMgb2YgZWFjaCBvdGhlci5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU3Vic2V0cyhub2Rlcykge1xuICAgIHZhciBpZHggPSBub2Rlcy5sZW5ndGg7XG4gICAgLypcbiAgICAgKiBDaGVjayBpZiBlYWNoIG5vZGUgKG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzKSBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGVcbiAgICAgKiBhcnJheS5cbiAgICAgKi9cbiAgICB3aGlsZSAoLS1pZHggPj0gMCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2lkeF07XG4gICAgICAgIC8qXG4gICAgICAgICAqIFJlbW92ZSB0aGUgbm9kZSBpZiBpdCBpcyBub3QgdW5pcXVlLlxuICAgICAgICAgKiBXZSBhcmUgZ29pbmcgdGhyb3VnaCB0aGUgYXJyYXkgZnJvbSB0aGUgZW5kLCBzbyB3ZSBvbmx5XG4gICAgICAgICAqIGhhdmUgdG8gY2hlY2sgbm9kZXMgdGhhdCBwcmVjZWVkIHRoZSBub2RlIHVuZGVyIGNvbnNpZGVyYXRpb24gaW4gdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlkeCA+IDAgJiYgbm9kZXMubGFzdEluZGV4T2Yobm9kZSwgaWR4IC0gMSkgPj0gMCkge1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBhbmNlc3RvciA9IG5vZGUucGFyZW50OyBhbmNlc3RvcjsgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmNsdWRlcyhhbmNlc3RvcikpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5leHBvcnRzLnJlbW92ZVN1YnNldHMgPSByZW1vdmVTdWJzZXRzO1xuLyoqXG4gKiBDb21wYXJlIHRoZSBwb3NpdGlvbiBvZiBvbmUgbm9kZSBhZ2FpbnN0IGFub3RoZXIgbm9kZSBpbiBhbnkgb3RoZXIgZG9jdW1lbnQuXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGEgYml0bWFzayB3aXRoIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICpcbiAqIERvY3VtZW50IG9yZGVyOlxuICogPiBUaGVyZSBpcyBhbiBvcmRlcmluZywgZG9jdW1lbnQgb3JkZXIsIGRlZmluZWQgb24gYWxsIHRoZSBub2RlcyBpbiB0aGVcbiAqID4gZG9jdW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGVcbiAqID4gWE1MIHJlcHJlc2VudGF0aW9uIG9mIGVhY2ggbm9kZSBvY2N1cnMgaW4gdGhlIFhNTCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAqID4gZG9jdW1lbnQgYWZ0ZXIgZXhwYW5zaW9uIG9mIGdlbmVyYWwgZW50aXRpZXMuIFRodXMsIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gKiA+IG5vZGUgd2lsbCBiZSB0aGUgZmlyc3Qgbm9kZS4gRWxlbWVudCBub2RlcyBvY2N1ciBiZWZvcmUgdGhlaXIgY2hpbGRyZW4uXG4gKiA+IFRodXMsIGRvY3VtZW50IG9yZGVyIG9yZGVycyBlbGVtZW50IG5vZGVzIGluIG9yZGVyIG9mIHRoZSBvY2N1cnJlbmNlIG9mXG4gKiA+IHRoZWlyIHN0YXJ0LXRhZyBpbiB0aGUgWE1MIChhZnRlciBleHBhbnNpb24gb2YgZW50aXRpZXMpLiBUaGUgYXR0cmlidXRlXG4gKiA+IG5vZGVzIG9mIGFuIGVsZW1lbnQgb2NjdXIgYWZ0ZXIgdGhlIGVsZW1lbnQgYW5kIGJlZm9yZSBpdHMgY2hpbGRyZW4uIFRoZVxuICogPiByZWxhdGl2ZSBvcmRlciBvZiBhdHRyaWJ1dGUgbm9kZXMgaXMgaW1wbGVtZW50YXRpb24tZGVwZW5kZW50Li9cbiAqXG4gKiBTb3VyY2U6XG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2dsb3NzYXJ5Lmh0bWwjZHQtZG9jdW1lbnQtb3JkZXJcbiAqXG4gKiBAcGFyYW0gbm9kZUEgVGhlIGZpcnN0IG5vZGUgdG8gdXNlIGluIHRoZSBjb21wYXJpc29uXG4gKiBAcGFyYW0gbm9kZUIgVGhlIHNlY29uZCBub2RlIHRvIHVzZSBpbiB0aGUgY29tcGFyaXNvblxuICogQHJldHVybnMgQSBiaXRtYXNrIGRlc2NyaWJpbmcgdGhlIGlucHV0IG5vZGVzJyByZWxhdGl2ZSBwb3NpdGlvbi5cbiAqXG4gKiBTZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ub2RlLWNvbXBhcmVkb2N1bWVudHBvc2l0aW9uIGZvclxuICogYSBkZXNjcmlwdGlvbiBvZiB0aGVzZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGVBLCBub2RlQikge1xuICAgIHZhciBhUGFyZW50cyA9IFtdO1xuICAgIHZhciBiUGFyZW50cyA9IFtdO1xuICAgIGlmIChub2RlQSA9PT0gbm9kZUIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gdGFndHlwZXNfMS5oYXNDaGlsZHJlbihub2RlQSkgPyBub2RlQSA6IG5vZGVBLnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBhUGFyZW50cy51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQgPSB0YWd0eXBlc18xLmhhc0NoaWxkcmVuKG5vZGVCKSA/IG5vZGVCIDogbm9kZUIucGFyZW50O1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIGJQYXJlbnRzLnVuc2hpZnQoY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgdmFyIG1heElkeCA9IE1hdGgubWluKGFQYXJlbnRzLmxlbmd0aCwgYlBhcmVudHMubGVuZ3RoKTtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB3aGlsZSAoaWR4IDwgbWF4SWR4ICYmIGFQYXJlbnRzW2lkeF0gPT09IGJQYXJlbnRzW2lkeF0pIHtcbiAgICAgICAgaWR4Kys7XG4gICAgfVxuICAgIGlmIChpZHggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIH1cbiAgICB2YXIgc2hhcmVkUGFyZW50ID0gYVBhcmVudHNbaWR4IC0gMV07XG4gICAgdmFyIHNpYmxpbmdzID0gc2hhcmVkUGFyZW50LmNoaWxkcmVuO1xuICAgIHZhciBhU2libGluZyA9IGFQYXJlbnRzW2lkeF07XG4gICAgdmFyIGJTaWJsaW5nID0gYlBhcmVudHNbaWR4XTtcbiAgICBpZiAoc2libGluZ3MuaW5kZXhPZihhU2libGluZykgPiBzaWJsaW5ncy5pbmRleE9mKGJTaWJsaW5nKSkge1xuICAgICAgICBpZiAoc2hhcmVkUGFyZW50ID09PSBub2RlQikge1xuICAgICAgICAgICAgcmV0dXJuIDQgLyogRk9MTE9XSU5HICovIHwgMTYgLyogQ09OVEFJTkVEX0JZICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiA0IC8qIEZPTExPV0lORyAqLztcbiAgICB9XG4gICAgaWYgKHNoYXJlZFBhcmVudCA9PT0gbm9kZUEpIHtcbiAgICAgICAgcmV0dXJuIDIgLyogUFJFQ0VESU5HICovIHwgOCAvKiBDT05UQUlOUyAqLztcbiAgICB9XG4gICAgcmV0dXJuIDIgLyogUFJFQ0VESU5HICovO1xufVxuZXhwb3J0cy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA9IGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuLyoqXG4gKiBTb3J0IGFuIGFycmF5IG9mIG5vZGVzIGJhc2VkIG9uIHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBhbmRcbiAqIHJlbW92ZSBhbnkgZHVwbGljYXRlIG5vZGVzLiBJZiB0aGUgYXJyYXkgY29udGFpbnMgbm9kZXMgdGhhdCBkbyBub3QgYmVsb25nXG4gKiB0byB0aGUgc2FtZSBkb2N1bWVudCwgc29ydCBvcmRlciBpcyB1bnNwZWNpZmllZC5cbiAqXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2YgRE9NIG5vZGVzLlxuICogQHJldHVybnMgQ29sbGVjdGlvbiBvZiB1bmlxdWUgbm9kZXMsIHNvcnRlZCBpbiBkb2N1bWVudCBvcmRlci5cbiAqL1xuZnVuY3Rpb24gdW5pcXVlU29ydChub2Rlcykge1xuICAgIG5vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlLCBpLCBhcnIpIHsgcmV0dXJuICFhcnIuaW5jbHVkZXMobm9kZSwgaSArIDEpOyB9KTtcbiAgICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGEsIGIpO1xuICAgICAgICBpZiAocmVsYXRpdmUgJiAyIC8qIFBSRUNFRElORyAqLykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbGF0aXZlICYgNCAvKiBGT0xMT1dJTkcgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcztcbn1cbmV4cG9ydHMudW5pcXVlU29ydCA9IHVuaXF1ZVNvcnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cmluZ2lmeVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhdmVyc2FsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tYW5pcHVsYXRpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3F1ZXJ5aW5nXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sZWdhY3lcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RhZ3R5cGVzXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnVHlwZSA9IGV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBleHBvcnRzLmdldEVsZW1lbnRCeUlkID0gZXhwb3J0cy5nZXRFbGVtZW50cyA9IGV4cG9ydHMudGVzdEVsZW1lbnQgPSB2b2lkIDA7XG52YXIgcXVlcnlpbmdfMSA9IHJlcXVpcmUoXCIuL3F1ZXJ5aW5nXCIpO1xudmFyIHRhZ3R5cGVzXzEgPSByZXF1aXJlKFwiLi90YWd0eXBlc1wiKTtcbnZhciBDaGVja3MgPSB7XG4gICAgdGFnX25hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWcoZWxlbSkgJiYgbmFtZShlbGVtLm5hbWUpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFndHlwZXNfMS5pc1RhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWcoZWxlbSkgJiYgZWxlbS5uYW1lID09PSBuYW1lOyB9O1xuICAgIH0sXG4gICAgdGFnX3R5cGU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHR5cGUoZWxlbS50eXBlKTsgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW0udHlwZSA9PT0gdHlwZTsgfTtcbiAgICB9LFxuICAgIHRhZ19jb250YWluczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGFndHlwZXNfMS5pc1RleHQoZWxlbSkgJiYgZGF0YShlbGVtLmRhdGEpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGFndHlwZXNfMS5pc1RleHQoZWxlbSkgJiYgZWxlbS5kYXRhID09PSBkYXRhOyB9O1xuICAgIH0sXG59O1xuLyoqXG4gKiBAcGFyYW0gYXR0cmliIEF0dHJpYnV0ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUgdG8gbG9vayBmb3IuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGEgbm9kZSBoYXMgYW4gYXR0cmlidXRlIHdpdGggYSBwYXJ0aWN1bGFyIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJDaGVjayhhdHRyaWIsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGFndHlwZXNfMS5pc1RhZyhlbGVtKSAmJiB2YWx1ZShlbGVtLmF0dHJpYnNbYXR0cmliXSk7IH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGFndHlwZXNfMS5pc1RhZyhlbGVtKSAmJiBlbGVtLmF0dHJpYnNbYXR0cmliXSA9PT0gdmFsdWU7IH07XG59XG4vKipcbiAqIEBwYXJhbSBhIEZpcnN0IGZ1bmN0aW9uIHRvIGNvbWJpbmUuXG4gKiBAcGFyYW0gYiBTZWNvbmQgZnVuY3Rpb24gdG8gY29tYmluZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGFraW5nIGEgbm9kZSBhbmQgcmV0dXJuaW5nIGB0cnVlYCBpZiBlaXRoZXJcbiAqIG9mIHRoZSBpbnB1dCBmdW5jdGlvbnMgcmV0dXJucyBgdHJ1ZWAgZm9yIHRoZSBub2RlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lRnVuY3MoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gYShlbGVtKSB8fCBiKGVsZW0pOyB9O1xufVxuLyoqXG4gKiBAcGFyYW0gb3B0aW9ucyBBbiBvYmplY3QgZGVzY3JpYmluZyBub2RlcyB0byBsb29rIGZvci5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gZXhlY3V0aW5nIGFsbCBjaGVja3MgaW4gYG9wdGlvbnNgIGFuZCByZXR1cm5pbmcgYHRydWVgXG4gKiBpZiBhbnkgb2YgdGhlbSBtYXRjaCBhIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVUZXN0KG9wdGlvbnMpIHtcbiAgICB2YXIgZnVuY3MgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgIHJldHVybiBrZXkgaW4gQ2hlY2tzXG4gICAgICAgICAgICA/IENoZWNrc1trZXldKHZhbHVlKVxuICAgICAgICAgICAgOiBnZXRBdHRyaWJDaGVjayhrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3MubGVuZ3RoID09PSAwID8gbnVsbCA6IGZ1bmNzLnJlZHVjZShjb21iaW5lRnVuY3MpO1xufVxuLyoqXG4gKiBAcGFyYW0gb3B0aW9ucyBBbiBvYmplY3QgZGVzY3JpYmluZyBub2RlcyB0byBsb29rIGZvci5cbiAqIEBwYXJhbSBub2RlIFRoZSBlbGVtZW50IHRvIHRlc3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhlIGRlc2NyaXB0aW9uIGluIGBvcHRpb25zYC5cbiAqL1xuZnVuY3Rpb24gdGVzdEVsZW1lbnQob3B0aW9ucywgbm9kZSkge1xuICAgIHZhciB0ZXN0ID0gY29tcGlsZVRlc3Qob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRlc3QgPyB0ZXN0KG5vZGUpIDogdHJ1ZTtcbn1cbmV4cG9ydHMudGVzdEVsZW1lbnQgPSB0ZXN0RWxlbWVudDtcbi8qKlxuICogQHBhcmFtIG9wdGlvbnMgQW4gb2JqZWN0IGRlc2NyaWJpbmcgbm9kZXMgdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0gbm9kZXMgTm9kZXMgdG8gc2VhcmNoIHRocm91Z2guXG4gKiBAcGFyYW0gcmVjdXJzZSBBbHNvIGNvbnNpZGVyIGNoaWxkIG5vZGVzLlxuICogQHBhcmFtIGxpbWl0IE1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIHJldHVybi5cbiAqIEByZXR1cm5zIEFsbCBub2RlcyB0aGF0IG1hdGNoIGBvcHRpb25zYC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudHMob3B0aW9ucywgbm9kZXMsIHJlY3Vyc2UsIGxpbWl0KSB7XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIHZhciB0ZXN0ID0gY29tcGlsZVRlc3Qob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRlc3QgPyBxdWVyeWluZ18xLmZpbHRlcih0ZXN0LCBub2RlcywgcmVjdXJzZSwgbGltaXQpIDogW107XG59XG5leHBvcnRzLmdldEVsZW1lbnRzID0gZ2V0RWxlbWVudHM7XG4vKipcbiAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIElEIGF0dHJpYnV0ZSB2YWx1ZSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSBub2RlcyBOb2RlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQsIG5vZGVzLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpXG4gICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICByZXR1cm4gcXVlcnlpbmdfMS5maW5kT25lKGdldEF0dHJpYkNoZWNrKFwiaWRcIiwgaWQpLCBub2RlcywgcmVjdXJzZSk7XG59XG5leHBvcnRzLmdldEVsZW1lbnRCeUlkID0gZ2V0RWxlbWVudEJ5SWQ7XG4vKipcbiAqIEBwYXJhbSB0YWdOYW1lIFRhZyBuYW1lIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0gbm9kZXMgTm9kZXMgdG8gc2VhcmNoIHRocm91Z2guXG4gKiBAcGFyYW0gcmVjdXJzZSBBbHNvIGNvbnNpZGVyIGNoaWxkIG5vZGVzLlxuICogQHBhcmFtIGxpbWl0IE1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIHJldHVybi5cbiAqIEByZXR1cm5zIEFsbCBub2RlcyB3aXRoIHRoZSBzdXBwbGllZCBgdGFnTmFtZWAuXG4gKi9cbmZ1bmN0aW9uIGdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUsIG5vZGVzLCByZWN1cnNlLCBsaW1pdCkge1xuICAgIGlmIChyZWN1cnNlID09PSB2b2lkIDApIHsgcmVjdXJzZSA9IHRydWU7IH1cbiAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IEluZmluaXR5OyB9XG4gICAgcmV0dXJuIHF1ZXJ5aW5nXzEuZmlsdGVyKENoZWNrcy50YWdfbmFtZSh0YWdOYW1lKSwgbm9kZXMsIHJlY3Vyc2UsIGxpbWl0KTtcbn1cbmV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBnZXRFbGVtZW50c0J5VGFnTmFtZTtcbi8qKlxuICogQHBhcmFtIHR5cGUgRWxlbWVudCB0eXBlIHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIG5vZGVzIE5vZGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBBbGwgbm9kZXMgd2l0aCB0aGUgc3VwcGxpZWQgYHR5cGVgLlxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnVHlwZSh0eXBlLCBub2RlcywgcmVjdXJzZSwgbGltaXQpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIHJldHVybiBxdWVyeWluZ18xLmZpbHRlcihDaGVja3MudGFnX3R5cGUodHlwZSksIG5vZGVzLCByZWN1cnNlLCBsaW1pdCk7XG59XG5leHBvcnRzLmdldEVsZW1lbnRzQnlUYWdUeXBlID0gZ2V0RWxlbWVudHNCeVRhZ1R5cGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJlcGVuZCA9IGV4cG9ydHMucHJlcGVuZENoaWxkID0gZXhwb3J0cy5hcHBlbmQgPSBleHBvcnRzLmFwcGVuZENoaWxkID0gZXhwb3J0cy5yZXBsYWNlRWxlbWVudCA9IGV4cG9ydHMucmVtb3ZlRWxlbWVudCA9IHZvaWQgMDtcbi8qKlxuICogUmVtb3ZlIGFuIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gKlxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gYmUgcmVtb3ZlZFxuICovXG5mdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW0pIHtcbiAgICBpZiAoZWxlbS5wcmV2KVxuICAgICAgICBlbGVtLnByZXYubmV4dCA9IGVsZW0ubmV4dDtcbiAgICBpZiAoZWxlbS5uZXh0KVxuICAgICAgICBlbGVtLm5leHQucHJldiA9IGVsZW0ucHJldjtcbiAgICBpZiAoZWxlbS5wYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkcyA9IGVsZW0ucGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjaGlsZHMuc3BsaWNlKGNoaWxkcy5sYXN0SW5kZXhPZihlbGVtKSwgMSk7XG4gICAgfVxufVxuZXhwb3J0cy5yZW1vdmVFbGVtZW50ID0gcmVtb3ZlRWxlbWVudDtcbi8qKlxuICogUmVwbGFjZSBhbiBlbGVtZW50IGluIHRoZSBkb21cbiAqXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBiZSByZXBsYWNlZFxuICogQHBhcmFtIHJlcGxhY2VtZW50IFRoZSBlbGVtZW50IHRvIGJlIGFkZGVkXG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VFbGVtZW50KGVsZW0sIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHByZXYgPSAocmVwbGFjZW1lbnQucHJldiA9IGVsZW0ucHJldik7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgICAgcHJldi5uZXh0ID0gcmVwbGFjZW1lbnQ7XG4gICAgfVxuICAgIHZhciBuZXh0ID0gKHJlcGxhY2VtZW50Lm5leHQgPSBlbGVtLm5leHQpO1xuICAgIGlmIChuZXh0KSB7XG4gICAgICAgIG5leHQucHJldiA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gKHJlcGxhY2VtZW50LnBhcmVudCA9IGVsZW0ucGFyZW50KTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZHMgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNoaWxkc1tjaGlsZHMubGFzdEluZGV4T2YoZWxlbSldID0gcmVwbGFjZW1lbnQ7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBsYWNlRWxlbWVudCA9IHJlcGxhY2VFbGVtZW50O1xuLyoqXG4gKiBBcHBlbmQgYSBjaGlsZCB0byBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGFwcGVuZCB0by5cbiAqIEBwYXJhbSBjaGlsZCBUaGUgZWxlbWVudCB0byBiZSBhZGRlZCBhcyBhIGNoaWxkLlxuICovXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChlbGVtLCBjaGlsZCkge1xuICAgIHJlbW92ZUVsZW1lbnQoY2hpbGQpO1xuICAgIGNoaWxkLm5leHQgPSBudWxsO1xuICAgIGNoaWxkLnBhcmVudCA9IGVsZW07XG4gICAgaWYgKGVsZW0uY2hpbGRyZW4ucHVzaChjaGlsZCkgPiAxKSB7XG4gICAgICAgIHZhciBzaWJsaW5nID0gZWxlbS5jaGlsZHJlbltlbGVtLmNoaWxkcmVuLmxlbmd0aCAtIDJdO1xuICAgICAgICBzaWJsaW5nLm5leHQgPSBjaGlsZDtcbiAgICAgICAgY2hpbGQucHJldiA9IHNpYmxpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZC5wcmV2ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmFwcGVuZENoaWxkID0gYXBwZW5kQ2hpbGQ7XG4vKipcbiAqIEFwcGVuZCBhbiBlbGVtZW50IGFmdGVyIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gYXBwZW5kIGFmdGVyLlxuICogQHBhcmFtIG5leHQgVGhlIGVsZW1lbnQgYmUgYWRkZWQuXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZChlbGVtLCBuZXh0KSB7XG4gICAgcmVtb3ZlRWxlbWVudChuZXh0KTtcbiAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnQ7XG4gICAgdmFyIGN1cnJOZXh0ID0gZWxlbS5uZXh0O1xuICAgIG5leHQubmV4dCA9IGN1cnJOZXh0O1xuICAgIG5leHQucHJldiA9IGVsZW07XG4gICAgZWxlbS5uZXh0ID0gbmV4dDtcbiAgICBuZXh0LnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAoY3Vyck5leHQpIHtcbiAgICAgICAgY3Vyck5leHQucHJldiA9IG5leHQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHMgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICBjaGlsZHMuc3BsaWNlKGNoaWxkcy5sYXN0SW5kZXhPZihjdXJyTmV4dCksIDAsIG5leHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChuZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLmFwcGVuZCA9IGFwcGVuZDtcbi8qKlxuICogUHJlcGVuZCBhIGNoaWxkIHRvIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gcHJlcGVuZCBiZWZvcmUuXG4gKiBAcGFyYW0gY2hpbGQgVGhlIGVsZW1lbnQgdG8gYmUgYWRkZWQgYXMgYSBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gcHJlcGVuZENoaWxkKGVsZW0sIGNoaWxkKSB7XG4gICAgcmVtb3ZlRWxlbWVudChjaGlsZCk7XG4gICAgY2hpbGQucGFyZW50ID0gZWxlbTtcbiAgICBjaGlsZC5wcmV2ID0gbnVsbDtcbiAgICBpZiAoZWxlbS5jaGlsZHJlbi51bnNoaWZ0KGNoaWxkKSAhPT0gMSkge1xuICAgICAgICB2YXIgc2libGluZyA9IGVsZW0uY2hpbGRyZW5bMV07XG4gICAgICAgIHNpYmxpbmcucHJldiA9IGNoaWxkO1xuICAgICAgICBjaGlsZC5uZXh0ID0gc2libGluZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoaWxkLm5leHQgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMucHJlcGVuZENoaWxkID0gcHJlcGVuZENoaWxkO1xuLyoqXG4gKiBQcmVwZW5kIGFuIGVsZW1lbnQgYmVmb3JlIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gcHJlcGVuZCBiZWZvcmUuXG4gKiBAcGFyYW0gcHJldiBUaGUgZWxlbWVudCBiZSBhZGRlZC5cbiAqL1xuZnVuY3Rpb24gcHJlcGVuZChlbGVtLCBwcmV2KSB7XG4gICAgcmVtb3ZlRWxlbWVudChwcmV2KTtcbiAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGRzID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjaGlsZHMuc3BsaWNlKGNoaWxkcy5pbmRleE9mKGVsZW0pLCAwLCBwcmV2KTtcbiAgICB9XG4gICAgaWYgKGVsZW0ucHJldikge1xuICAgICAgICBlbGVtLnByZXYubmV4dCA9IHByZXY7XG4gICAgfVxuICAgIHByZXYucGFyZW50ID0gcGFyZW50O1xuICAgIHByZXYucHJldiA9IGVsZW0ucHJldjtcbiAgICBwcmV2Lm5leHQgPSBlbGVtO1xuICAgIGVsZW0ucHJldiA9IHByZXY7XG59XG5leHBvcnRzLnByZXBlbmQgPSBwcmVwZW5kO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZpbmRBbGwgPSBleHBvcnRzLmV4aXN0c09uZSA9IGV4cG9ydHMuZmluZE9uZSA9IGV4cG9ydHMuZmluZE9uZUNoaWxkID0gZXhwb3J0cy5maW5kID0gZXhwb3J0cy5maWx0ZXIgPSB2b2lkIDA7XG52YXIgdGFndHlwZXNfMSA9IHJlcXVpcmUoXCIuL3RhZ3R5cGVzXCIpO1xuLyoqXG4gKiBTZWFyY2ggYSBub2RlIGFuZCBpdHMgY2hpbGRyZW4gZm9yIG5vZGVzIHBhc3NpbmcgYSB0ZXN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB0ZXN0IEZ1bmN0aW9uIHRvIHRlc3Qgbm9kZXMgb24uXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIHNlYXJjaC4gV2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldCBpZiBpdCBtYXRjaGVzLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBBbGwgbm9kZXMgcGFzc2luZyBgdGVzdGAuXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcih0ZXN0LCBub2RlLCByZWN1cnNlLCBsaW1pdCkge1xuICAgIGlmIChyZWN1cnNlID09PSB2b2lkIDApIHsgcmVjdXJzZSA9IHRydWU7IH1cbiAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IEluZmluaXR5OyB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUpKVxuICAgICAgICBub2RlID0gW25vZGVdO1xuICAgIHJldHVybiBmaW5kKHRlc3QsIG5vZGUsIHJlY3Vyc2UsIGxpbWl0KTtcbn1cbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuLyoqXG4gKiBTZWFyY2ggYW4gYXJyYXkgb2Ygbm9kZSBhbmQgaXRzIGNoaWxkcmVuIGZvciBub2RlcyBwYXNzaW5nIGEgdGVzdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0gbGltaXQgTWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgQWxsIG5vZGVzIHBhc3NpbmcgYHRlc3RgLlxuICovXG5mdW5jdGlvbiBmaW5kKHRlc3QsIG5vZGVzLCByZWN1cnNlLCBsaW1pdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIG5vZGVzXzEgPSBub2RlczsgX2kgPCBub2Rlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZWxlbSA9IG5vZGVzXzFbX2ldO1xuICAgICAgICBpZiAodGVzdChlbGVtKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbSk7XG4gICAgICAgICAgICBpZiAoLS1saW1pdCA8PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN1cnNlICYmIHRhZ3R5cGVzXzEuaGFzQ2hpbGRyZW4oZWxlbSkgJiYgZWxlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBmaW5kKHRlc3QsIGVsZW0uY2hpbGRyZW4sIHJlY3Vyc2UsIGxpbWl0KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgbGltaXQgLT0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBlbGVtZW50IGluc2lkZSBvZiBhbiBhcnJheSB0aGF0IG1hdGNoZXMgYSB0ZXN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB0ZXN0IEZ1bmN0aW9uIHRvIHRlc3Qgbm9kZXMgb24uXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdG8gc2VhcmNoLlxuICogQHJldHVybnMgVGhlIGZpcnN0IG5vZGUgaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIGB0ZXN0YC5cbiAqL1xuZnVuY3Rpb24gZmluZE9uZUNoaWxkKHRlc3QsIG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLmZpbmQodGVzdCk7XG59XG5leHBvcnRzLmZpbmRPbmVDaGlsZCA9IGZpbmRPbmVDaGlsZDtcbi8qKlxuICogRmluZHMgb25lIGVsZW1lbnQgaW4gYSB0cmVlIHRoYXQgcGFzc2VzIGEgdGVzdC5cbiAqXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgZmlyc3QgY2hpbGQgbm9kZSB0aGF0IHBhc3NlcyBgdGVzdGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmRPbmUodGVzdCwgbm9kZXMsIHJlY3Vyc2UpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgdmFyIGVsZW0gPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoICYmICFlbGVtOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZWQgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKCF0YWd0eXBlc18xLmlzVGFnKGNoZWNrZWQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXN0KGNoZWNrZWQpKSB7XG4gICAgICAgICAgICBlbGVtID0gY2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWN1cnNlICYmIGNoZWNrZWQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZWxlbSA9IGZpbmRPbmUodGVzdCwgY2hlY2tlZC5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW07XG59XG5leHBvcnRzLmZpbmRPbmUgPSBmaW5kT25lO1xuLyoqXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgYSB0cmVlIG9mIG5vZGVzIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBub2RlIHBhc3NpbmcgYSB0ZXN0LlxuICovXG5mdW5jdGlvbiBleGlzdHNPbmUodGVzdCwgbm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMuc29tZShmdW5jdGlvbiAoY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gdGFndHlwZXNfMS5pc1RhZyhjaGVja2VkKSAmJlxuICAgICAgICAgICAgKHRlc3QoY2hlY2tlZCkgfHxcbiAgICAgICAgICAgICAgICAoY2hlY2tlZC5jaGlsZHJlbi5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0c09uZSh0ZXN0LCBjaGVja2VkLmNoaWxkcmVuKSkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5leGlzdHNPbmUgPSBleGlzdHNPbmU7XG4vKipcbiAqIFNlYXJjaCBhbmQgYXJyYXkgb2Ygbm9kZXMgYW5kIGl0cyBjaGlsZHJlbiBmb3Igbm9kZXMgcGFzc2luZyBhIHRlc3QgZnVuY3Rpb24uXG4gKlxuICogU2FtZSBhcyBgZmluZGAsIG9ubHkgd2l0aCBsZXNzIG9wdGlvbnMsIGxlYWRpbmcgdG8gcmVkdWNlZCBjb21wbGV4aXR5LlxuICpcbiAqIEBwYXJhbSB0ZXN0IEZ1bmN0aW9uIHRvIHRlc3Qgbm9kZXMgb24uXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdG8gc2VhcmNoLlxuICogQHJldHVybnMgQWxsIG5vZGVzIHBhc3NpbmcgYHRlc3RgLlxuICovXG5mdW5jdGlvbiBmaW5kQWxsKHRlc3QsIG5vZGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc3RhY2sgPSBub2Rlcy5maWx0ZXIodGFndHlwZXNfMS5pc1RhZyk7XG4gICAgdmFyIGVsZW07XG4gICAgd2hpbGUgKChlbGVtID0gc3RhY2suc2hpZnQoKSkpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gKF9hID0gZWxlbS5jaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcih0YWd0eXBlc18xLmlzVGFnKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQuYXBwbHkoc3RhY2ssIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVzdChlbGVtKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5maW5kQWxsID0gZmluZEFsbDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRUZXh0ID0gZXhwb3J0cy5nZXRJbm5lckhUTUwgPSBleHBvcnRzLmdldE91dGVySFRNTCA9IHZvaWQgMDtcbnZhciB0YWd0eXBlc18xID0gcmVxdWlyZShcIi4vdGFndHlwZXNcIik7XG52YXIgZG9tX3NlcmlhbGl6ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG9tLXNlcmlhbGl6ZXJcIikpO1xuLyoqXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGdldCB0aGUgb3V0ZXIgSFRNTCBvZi5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHNlcmlhbGl6YXRpb24uXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBkb20tc2VyaWFsaXplcmAgbW9kdWxlIGRpcmVjdGx5LlxuICogQHJldHVybnMgYG5vZGVgJ3Mgb3V0ZXIgSFRNTC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZG9tX3NlcmlhbGl6ZXJfMS5kZWZhdWx0KG5vZGUsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5nZXRPdXRlckhUTUwgPSBnZXRPdXRlckhUTUw7XG4vKipcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gZ2V0IHRoZSBpbm5lciBIVE1MIG9mLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3Igc2VyaWFsaXphdGlvbi5cbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYGRvbS1zZXJpYWxpemVyYCBtb2R1bGUgZGlyZWN0bHkuXG4gKiBAcmV0dXJucyBgbm9kZWAncyBpbm5lciBIVE1MLlxuICovXG5mdW5jdGlvbiBnZXRJbm5lckhUTUwobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0YWd0eXBlc18xLmhhc0NoaWxkcmVuKG5vZGUpXG4gICAgICAgID8gbm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGdldE91dGVySFRNTChub2RlLCBvcHRpb25zKTsgfSkuam9pbihcIlwiKVxuICAgICAgICA6IFwiXCI7XG59XG5leHBvcnRzLmdldElubmVySFRNTCA9IGdldElubmVySFRNTDtcbi8qKlxuICogR2V0IGEgbm9kZSdzIGlubmVyIHRleHQuXG4gKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBnZXQgdGhlIGlubmVyIHRleHQgb2YuXG4gKiBAcmV0dXJucyBgbm9kZWAncyBpbm5lciB0ZXh0LlxuICovXG5mdW5jdGlvbiBnZXRUZXh0KG5vZGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSlcbiAgICAgICAgcmV0dXJuIG5vZGUubWFwKGdldFRleHQpLmpvaW4oXCJcIik7XG4gICAgaWYgKHRhZ3R5cGVzXzEuaXNUYWcobm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlLm5hbWUgPT09IFwiYnJcIiA/IFwiXFxuXCIgOiBnZXRUZXh0KG5vZGUuY2hpbGRyZW4pO1xuICAgIGlmICh0YWd0eXBlc18xLmlzQ0RBVEEobm9kZSkpXG4gICAgICAgIHJldHVybiBnZXRUZXh0KG5vZGUuY2hpbGRyZW4pO1xuICAgIGlmICh0YWd0eXBlc18xLmlzVGV4dChub2RlKSlcbiAgICAgICAgcmV0dXJuIG5vZGUuZGF0YTtcbiAgICByZXR1cm4gXCJcIjtcbn1cbmV4cG9ydHMuZ2V0VGV4dCA9IGdldFRleHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzQ2hpbGRyZW4gPSBleHBvcnRzLmlzQ29tbWVudCA9IGV4cG9ydHMuaXNUZXh0ID0gZXhwb3J0cy5pc0NEQVRBID0gZXhwb3J0cy5pc1RhZyA9IHZvaWQgMDtcbnZhciBkb21lbGVtZW50dHlwZV8xID0gcmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpO1xuLyoqXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBub2RlIGlzIGEgYEVsZW1lbnRgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNUYWcobm9kZSkge1xuICAgIHJldHVybiBkb21lbGVtZW50dHlwZV8xLmlzVGFnKG5vZGUpO1xufVxuZXhwb3J0cy5pc1RhZyA9IGlzVGFnO1xuLyoqXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBub2RlIGlzIGEgYE5vZGVXaXRoQ2hpbGRyZW5gLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNDREFUQShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJjZGF0YVwiIC8qIENEQVRBICovO1xufVxuZXhwb3J0cy5pc0NEQVRBID0gaXNDREFUQTtcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbm9kZSBpcyBhIGBEYXRhTm9kZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1RleHQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwidGV4dFwiIC8qIFRleHQgKi87XG59XG5leHBvcnRzLmlzVGV4dCA9IGlzVGV4dDtcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbm9kZSBpcyBhIGBEYXRhTm9kZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0NvbW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiY29tbWVudFwiIC8qIENvbW1lbnQgKi87XG59XG5leHBvcnRzLmlzQ29tbWVudCA9IGlzQ29tbWVudDtcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbm9kZSBpcyBhIGBOb2RlV2l0aENoaWxkcmVuYCAoaGFzIGNoaWxkcmVuKSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGhhc0NoaWxkcmVuKG5vZGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIFwiY2hpbGRyZW5cIik7XG59XG5leHBvcnRzLmhhc0NoaWxkcmVuID0gaGFzQ2hpbGRyZW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV4dEVsZW1lbnRTaWJsaW5nID0gZXhwb3J0cy5nZXROYW1lID0gZXhwb3J0cy5oYXNBdHRyaWIgPSBleHBvcnRzLmdldEF0dHJpYnV0ZVZhbHVlID0gZXhwb3J0cy5nZXRTaWJsaW5ncyA9IGV4cG9ydHMuZ2V0UGFyZW50ID0gZXhwb3J0cy5nZXRDaGlsZHJlbiA9IHZvaWQgMDtcbnZhciB0YWd0eXBlc18xID0gcmVxdWlyZShcIi4vdGFndHlwZXNcIik7XG52YXIgZW1wdHlBcnJheSA9IFtdO1xuLyoqXG4gKiBHZXQgYSBub2RlJ3MgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIGVsZW0gTm9kZSB0byBnZXQgdGhlIGNoaWxkcmVuIG9mLlxuICogQHJldHVybnMgYGVsZW1gJ3MgY2hpbGRyZW4sIG9yIGFuIGVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBnZXRDaGlsZHJlbihlbGVtKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBlbGVtLmNoaWxkcmVuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlbXB0eUFycmF5O1xufVxuZXhwb3J0cy5nZXRDaGlsZHJlbiA9IGdldENoaWxkcmVuO1xuLyoqXG4gKiBHZXQgYSBub2RlJ3MgcGFyZW50LlxuICpcbiAqIEBwYXJhbSBlbGVtIE5vZGUgdG8gZ2V0IHRoZSBwYXJlbnQgb2YuXG4gKiBAcmV0dXJucyBgZWxlbWAncyBwYXJlbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50KGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5wYXJlbnQgfHwgbnVsbDtcbn1cbmV4cG9ydHMuZ2V0UGFyZW50ID0gZ2V0UGFyZW50O1xuLyoqXG4gKiBHZXRzIGFuIGVsZW1lbnRzIHNpYmxpbmdzLCBpbmNsdWRpbmcgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEF0dGVtcHRzIHRvIGdldCB0aGUgY2hpbGRyZW4gdGhyb3VnaCB0aGUgZWxlbWVudCdzIHBhcmVudCBmaXJzdC5cbiAqIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQgKHRoZSBlbGVtZW50IGlzIGEgcm9vdCBub2RlKSxcbiAqIHdlIHdhbGsgdGhlIGVsZW1lbnQncyBgcHJldmAgJiBgbmV4dGAgdG8gZ2V0IGFsbCByZW1haW5pbmcgbm9kZXMuXG4gKlxuICogQHBhcmFtIGVsZW0gRWxlbWVudCB0byBnZXQgdGhlIHNpYmxpbmdzIG9mLlxuICogQHJldHVybnMgYGVsZW1gJ3Mgc2libGluZ3MuXG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdzKGVsZW0pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQoZWxlbSk7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKVxuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4ocGFyZW50KTtcbiAgICB2YXIgc2libGluZ3MgPSBbZWxlbV07XG4gICAgdmFyIHByZXYgPSBlbGVtLnByZXYsIG5leHQgPSBlbGVtLm5leHQ7XG4gICAgd2hpbGUgKHByZXYgIT0gbnVsbCkge1xuICAgICAgICBzaWJsaW5ncy51bnNoaWZ0KHByZXYpO1xuICAgICAgICAoX2EgPSBwcmV2LCBwcmV2ID0gX2EucHJldik7XG4gICAgfVxuICAgIHdoaWxlIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2libGluZ3MucHVzaChuZXh0KTtcbiAgICAgICAgKF9iID0gbmV4dCwgbmV4dCA9IF9iLm5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gc2libGluZ3M7XG59XG5leHBvcnRzLmdldFNpYmxpbmdzID0gZ2V0U2libGluZ3M7XG4vKipcbiAqIEdldHMgYW4gYXR0cmlidXRlIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gZWxlbSBFbGVtZW50IHRvIGNoZWNrLlxuICogQHBhcmFtIG5hbWUgQXR0cmlidXRlIG5hbWUgdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IGVsZW0uYXR0cmlicykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW25hbWVdO1xufVxuZXhwb3J0cy5nZXRBdHRyaWJ1dGVWYWx1ZSA9IGdldEF0dHJpYnV0ZVZhbHVlO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGhhcyBhbiBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIGVsZW0gRWxlbWVudCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIEF0dHJpYnV0ZSBuYW1lIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgUmV0dXJucyB3aGV0aGVyIGBlbGVtYCBoYXMgdGhlIGF0dHJpYnV0ZSBgbmFtZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc0F0dHJpYihlbGVtLCBuYW1lKSB7XG4gICAgcmV0dXJuIChlbGVtLmF0dHJpYnMgIT0gbnVsbCAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWxlbS5hdHRyaWJzLCBuYW1lKSAmJlxuICAgICAgICBlbGVtLmF0dHJpYnNbbmFtZV0gIT0gbnVsbCk7XG59XG5leHBvcnRzLmhhc0F0dHJpYiA9IGhhc0F0dHJpYjtcbi8qKlxuICogR2V0IHRoZSB0YWcgbmFtZSBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGdldCB0aGUgbmFtZSBmb3IuXG4gKiBAcmV0dXJucyBUaGUgdGFnIG5hbWUgb2YgYGVsZW1gLlxuICovXG5mdW5jdGlvbiBnZXROYW1lKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5uYW1lO1xufVxuZXhwb3J0cy5nZXROYW1lID0gZ2V0TmFtZTtcbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBlbGVtZW50IHNpYmxpbmcgb2YgYSBub2RlLlxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGdldCB0aGUgbmV4dCBzaWJsaW5nIG9mLlxuICogQHJldHVybnMgYGVsZW1gJ3MgbmV4dCBzaWJsaW5nIHRoYXQgaXMgYSB0YWcuXG4gKi9cbmZ1bmN0aW9uIG5leHRFbGVtZW50U2libGluZyhlbGVtKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBuZXh0ID0gZWxlbS5uZXh0O1xuICAgIHdoaWxlIChuZXh0ICE9PSBudWxsICYmICF0YWd0eXBlc18xLmlzVGFnKG5leHQpKVxuICAgICAgICAoX2EgPSBuZXh0LCBuZXh0ID0gX2EubmV4dCk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5leHBvcnRzLm5leHRFbGVtZW50U2libGluZyA9IG5leHRFbGVtZW50U2libGluZztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVIVE1MID0gZXhwb3J0cy5kZWNvZGVIVE1MU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVYTUwgPSB2b2lkIDA7XG52YXIgZW50aXRpZXNfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hcHMvZW50aXRpZXMuanNvblwiKSk7XG52YXIgbGVnYWN5X2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL2xlZ2FjeS5qc29uXCIpKTtcbnZhciB4bWxfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hcHMveG1sLmpzb25cIikpO1xudmFyIGRlY29kZV9jb2RlcG9pbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9kZWNvZGVfY29kZXBvaW50XCIpKTtcbmV4cG9ydHMuZGVjb2RlWE1MID0gZ2V0U3RyaWN0RGVjb2Rlcih4bWxfanNvbl8xLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWNvZGVIVE1MU3RyaWN0ID0gZ2V0U3RyaWN0RGVjb2RlcihlbnRpdGllc19qc29uXzEuZGVmYXVsdCk7XG5mdW5jdGlvbiBnZXRTdHJpY3REZWNvZGVyKG1hcCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobWFwKS5qb2luKFwifFwiKTtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKG1hcCk7XG4gICAga2V5cyArPSBcInwjW3hYXVtcXFxcZGEtZkEtRl0rfCNcXFxcZCtcIjtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cyArIFwiKTtcIiwgXCJnXCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHJlLCByZXBsYWNlKTsgfTtcbn1cbnZhciBzb3J0ZXIgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGEgPCBiID8gMSA6IC0xKTsgfTtcbmV4cG9ydHMuZGVjb2RlSFRNTCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlZ2FjeSA9IE9iamVjdC5rZXlzKGxlZ2FjeV9qc29uXzEuZGVmYXVsdCkuc29ydChzb3J0ZXIpO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZW50aXRpZXNfanNvbl8xLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZWdhY3lbal0gPT09IGtleXNbaV0pIHtcbiAgICAgICAgICAgIGtleXNbaV0gKz0gXCI7P1wiO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5c1tpXSArPSBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cy5qb2luKFwifFwiKSArIFwifCNbeFhdW1xcXFxkYS1mQS1GXSs7P3wjXFxcXGQrOz8pXCIsIFwiZ1wiKTtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKGVudGl0aWVzX2pzb25fMS5kZWZhdWx0KTtcbiAgICBmdW5jdGlvbiByZXBsYWNlcihzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5zdWJzdHIoLTEpICE9PSBcIjtcIilcbiAgICAgICAgICAgIHN0ciArPSBcIjtcIjtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2Uoc3RyKTtcbiAgICB9XG4gICAgLy8gVE9ETyBjb25zaWRlciBjcmVhdGluZyBhIG1lcmdlZCBtYXBcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShyZSwgcmVwbGFjZXIpOyB9O1xufSkoKTtcbmZ1bmN0aW9uIGdldFJlcGxhY2VyKG1hcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKHN0cikge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdCgxKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBzZWNvbmRDaGFyID0gc3RyLmNoYXJBdCgyKTtcbiAgICAgICAgICAgIGlmIChzZWNvbmRDaGFyID09PSBcIlhcIiB8fCBzZWNvbmRDaGFyID09PSBcInhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVfY29kZXBvaW50XzEuZGVmYXVsdChwYXJzZUludChzdHIuc3Vic3RyKDMpLCAxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZV9jb2RlcG9pbnRfMS5kZWZhdWx0KHBhcnNlSW50KHN0ci5zdWJzdHIoMiksIDEwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcFtzdHIuc2xpY2UoMSwgLTEpXTtcbiAgICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVjb2RlX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL2RlY29kZS5qc29uXCIpKTtcbi8vIE1vZGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvaGUvYmxvYi9tYXN0ZXIvc3JjL2hlLmpzI0w5NC1MMTE5XG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG4gICAgaWYgKChjb2RlUG9pbnQgPj0gMHhkODAwICYmIGNvZGVQb2ludCA8PSAweGRmZmYpIHx8IGNvZGVQb2ludCA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHJldHVybiBcIlxcdUZGRkRcIjtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCBpbiBkZWNvZGVfanNvbl8xLmRlZmF1bHQpIHtcbiAgICAgICAgY29kZVBvaW50ID0gZGVjb2RlX2pzb25fMS5kZWZhdWx0W2NvZGVQb2ludF07XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgIGlmIChjb2RlUG9pbnQgPiAweGZmZmYpIHtcbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+PiAxMCkgJiAweDNmZikgfCAweGQ4MDApO1xuICAgICAgICBjb2RlUG9pbnQgPSAweGRjMDAgfCAoY29kZVBvaW50ICYgMHgzZmYpO1xuICAgIH1cbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWNvZGVDb2RlUG9pbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXNjYXBlID0gZXhwb3J0cy5lbmNvZGVIVE1MID0gZXhwb3J0cy5lbmNvZGVYTUwgPSB2b2lkIDA7XG52YXIgeG1sX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL3htbC5qc29uXCIpKTtcbnZhciBpbnZlcnNlWE1MID0gZ2V0SW52ZXJzZU9iaih4bWxfanNvbl8xLmRlZmF1bHQpO1xudmFyIHhtbFJlcGxhY2VyID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VYTUwpO1xuZXhwb3J0cy5lbmNvZGVYTUwgPSBnZXRJbnZlcnNlKGludmVyc2VYTUwsIHhtbFJlcGxhY2VyKTtcbnZhciBlbnRpdGllc19qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy9lbnRpdGllcy5qc29uXCIpKTtcbnZhciBpbnZlcnNlSFRNTCA9IGdldEludmVyc2VPYmooZW50aXRpZXNfanNvbl8xLmRlZmF1bHQpO1xudmFyIGh0bWxSZXBsYWNlciA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlSFRNTCk7XG5leHBvcnRzLmVuY29kZUhUTUwgPSBnZXRJbnZlcnNlKGludmVyc2VIVE1MLCBodG1sUmVwbGFjZXIpO1xuZnVuY3Rpb24gZ2V0SW52ZXJzZU9iaihvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGludmVyc2UsIG5hbWUpIHtcbiAgICAgICAgaW52ZXJzZVtvYmpbbmFtZV1dID0gXCImXCIgKyBuYW1lICsgXCI7XCI7XG4gICAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlKSB7XG4gICAgdmFyIHNpbmdsZSA9IFtdO1xuICAgIHZhciBtdWx0aXBsZSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhpbnZlcnNlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgIGlmIChrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gQWRkIHZhbHVlIHRvIHNpbmdsZSBhcnJheVxuICAgICAgICAgICAgc2luZ2xlLnB1c2goXCJcXFxcXCIgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZSB0byBtdWx0aXBsZSBhcnJheVxuICAgICAgICAgICAgbXVsdGlwbGUucHVzaChrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgcmFuZ2VzIHRvIHNpbmdsZSBjaGFyYWN0ZXJzLlxuICAgIHNpbmdsZS5zb3J0KCk7XG4gICAgZm9yICh2YXIgc3RhcnQgPSAwOyBzdGFydCA8IHNpbmdsZS5sZW5ndGggLSAxOyBzdGFydCsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGVuZCBvZiBhIHJ1biBvZiBjaGFyYWN0ZXJzXG4gICAgICAgIHZhciBlbmQgPSBzdGFydDtcbiAgICAgICAgd2hpbGUgKGVuZCA8IHNpbmdsZS5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICBzaW5nbGVbZW5kXS5jaGFyQ29kZUF0KDEpICsgMSA9PT0gc2luZ2xlW2VuZCArIDFdLmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgICAgIGVuZCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IDEgKyBlbmQgLSBzdGFydDtcbiAgICAgICAgLy8gV2Ugd2FudCB0byByZXBsYWNlIGF0IGxlYXN0IHRocmVlIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKGNvdW50IDwgMylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzaW5nbGUuc3BsaWNlKHN0YXJ0LCBjb3VudCwgc2luZ2xlW3N0YXJ0XSArIFwiLVwiICsgc2luZ2xlW2VuZF0pO1xuICAgIH1cbiAgICBtdWx0aXBsZS51bnNoaWZ0KFwiW1wiICsgc2luZ2xlLmpvaW4oXCJcIikgKyBcIl1cIik7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAobXVsdGlwbGUuam9pbihcInxcIiksIFwiZ1wiKTtcbn1cbnZhciByZU5vbkFTQ0lJID0gLyg/OltcXHg4MC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS9nO1xuZnVuY3Rpb24gc2luZ2xlQ2hhclJlcGxhY2VyKGMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIHJldHVybiBcIiYjeFwiICsgYy5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiO1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52ZXJzZShpbnZlcnNlLCByZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpbnZlcnNlW25hbWVdOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UocmVOb25BU0NJSSwgc2luZ2xlQ2hhclJlcGxhY2VyKTtcbiAgICB9O1xufVxudmFyIHJlWG1sQ2hhcnMgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZVhNTCk7XG5mdW5jdGlvbiBlc2NhcGUoZGF0YSkge1xuICAgIHJldHVybiBkYXRhXG4gICAgICAgIC5yZXBsYWNlKHJlWG1sQ2hhcnMsIHNpbmdsZUNoYXJSZXBsYWNlcilcbiAgICAgICAgLnJlcGxhY2UocmVOb25BU0NJSSwgc2luZ2xlQ2hhclJlcGxhY2VyKTtcbn1cbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVhNTFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDVTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw0U3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNSA9IGV4cG9ydHMuZGVjb2RlSFRNTDQgPSBleHBvcnRzLmRlY29kZUhUTUxTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUwgPSBleHBvcnRzLmRlY29kZVhNTCA9IGV4cG9ydHMuZW5jb2RlSFRNTDUgPSBleHBvcnRzLmVuY29kZUhUTUw0ID0gZXhwb3J0cy5lc2NhcGUgPSBleHBvcnRzLmVuY29kZUhUTUwgPSBleHBvcnRzLmVuY29kZVhNTCA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGVTdHJpY3QgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbnZhciBkZWNvZGVfMSA9IHJlcXVpcmUoXCIuL2RlY29kZVwiKTtcbnZhciBlbmNvZGVfMSA9IHJlcXVpcmUoXCIuL2VuY29kZVwiKTtcbi8qKlxuICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICovXG5mdW5jdGlvbiBkZWNvZGUoZGF0YSwgbGV2ZWwpIHtcbiAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlXzEuZGVjb2RlWE1MIDogZGVjb2RlXzEuZGVjb2RlSFRNTCkoZGF0YSk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKlxuICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLiBEb2VzIG5vdCBhbGxvdyBtaXNzaW5nIHRyYWlsaW5nIHNlbWljb2xvbnMgZm9yIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICovXG5mdW5jdGlvbiBkZWNvZGVTdHJpY3QoZGF0YSwgbGV2ZWwpIHtcbiAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlXzEuZGVjb2RlWE1MIDogZGVjb2RlXzEuZGVjb2RlSFRNTFN0cmljdCkoZGF0YSk7XG59XG5leHBvcnRzLmRlY29kZVN0cmljdCA9IGRlY29kZVN0cmljdDtcbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZW5jb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICovXG5mdW5jdGlvbiBlbmNvZGUoZGF0YSwgbGV2ZWwpIHtcbiAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZW5jb2RlXzEuZW5jb2RlWE1MIDogZW5jb2RlXzEuZW5jb2RlSFRNTCkoZGF0YSk7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbnZhciBlbmNvZGVfMiA9IHJlcXVpcmUoXCIuL2VuY29kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVhNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlWE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlSFRNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZXNjYXBlOyB9IH0pO1xuLy8gTGVnYWN5IGFsaWFzZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUw0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlSFRNTDVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZUhUTUw7IH0gfSk7XG52YXIgZGVjb2RlXzIgPSByZXF1aXJlKFwiLi9kZWNvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVYTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZVhNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MU3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuLy8gTGVnYWN5IGFsaWFzZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTFN0cmljdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1U3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlWE1MU3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVYTUw7IH0gfSk7XG4iLCJtb2R1bGUuZXhwb3J0cz17XCIwXCI6NjU1MzMsXCIxMjhcIjo4MzY0LFwiMTMwXCI6ODIxOCxcIjEzMVwiOjQwMixcIjEzMlwiOjgyMjIsXCIxMzNcIjo4MjMwLFwiMTM0XCI6ODIyNCxcIjEzNVwiOjgyMjUsXCIxMzZcIjo3MTAsXCIxMzdcIjo4MjQwLFwiMTM4XCI6MzUyLFwiMTM5XCI6ODI0OSxcIjE0MFwiOjMzOCxcIjE0MlwiOjM4MSxcIjE0NVwiOjgyMTYsXCIxNDZcIjo4MjE3LFwiMTQ3XCI6ODIyMCxcIjE0OFwiOjgyMjEsXCIxNDlcIjo4MjI2LFwiMTUwXCI6ODIxMSxcIjE1MVwiOjgyMTIsXCIxNTJcIjo3MzIsXCIxNTNcIjo4NDgyLFwiMTU0XCI6MzUzLFwiMTU1XCI6ODI1MCxcIjE1NlwiOjMzOSxcIjE1OFwiOjM4MixcIjE1OVwiOjM3Nn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcIkFhY3V0ZVwiOlwiw4FcIixcImFhY3V0ZVwiOlwiw6FcIixcIkFicmV2ZVwiOlwixIJcIixcImFicmV2ZVwiOlwixINcIixcImFjXCI6XCLiiL5cIixcImFjZFwiOlwi4oi/XCIsXCJhY0VcIjpcIuKIvsyzXCIsXCJBY2lyY1wiOlwiw4JcIixcImFjaXJjXCI6XCLDolwiLFwiYWN1dGVcIjpcIsK0XCIsXCJBY3lcIjpcItCQXCIsXCJhY3lcIjpcItCwXCIsXCJBRWxpZ1wiOlwiw4ZcIixcImFlbGlnXCI6XCLDplwiLFwiYWZcIjpcIuKBoVwiLFwiQWZyXCI6XCLwnZSEXCIsXCJhZnJcIjpcIvCdlJ5cIixcIkFncmF2ZVwiOlwiw4BcIixcImFncmF2ZVwiOlwiw6BcIixcImFsZWZzeW1cIjpcIuKEtVwiLFwiYWxlcGhcIjpcIuKEtVwiLFwiQWxwaGFcIjpcIs6RXCIsXCJhbHBoYVwiOlwizrFcIixcIkFtYWNyXCI6XCLEgFwiLFwiYW1hY3JcIjpcIsSBXCIsXCJhbWFsZ1wiOlwi4qi/XCIsXCJhbXBcIjpcIiZcIixcIkFNUFwiOlwiJlwiLFwiYW5kYW5kXCI6XCLiqZVcIixcIkFuZFwiOlwi4qmTXCIsXCJhbmRcIjpcIuKIp1wiLFwiYW5kZFwiOlwi4qmcXCIsXCJhbmRzbG9wZVwiOlwi4qmYXCIsXCJhbmR2XCI6XCLiqZpcIixcImFuZ1wiOlwi4oigXCIsXCJhbmdlXCI6XCLipqRcIixcImFuZ2xlXCI6XCLiiKBcIixcImFuZ21zZGFhXCI6XCLipqhcIixcImFuZ21zZGFiXCI6XCLipqlcIixcImFuZ21zZGFjXCI6XCLipqpcIixcImFuZ21zZGFkXCI6XCLipqtcIixcImFuZ21zZGFlXCI6XCLipqxcIixcImFuZ21zZGFmXCI6XCLipq1cIixcImFuZ21zZGFnXCI6XCLipq5cIixcImFuZ21zZGFoXCI6XCLipq9cIixcImFuZ21zZFwiOlwi4oihXCIsXCJhbmdydFwiOlwi4oifXCIsXCJhbmdydHZiXCI6XCLiir5cIixcImFuZ3J0dmJkXCI6XCLipp1cIixcImFuZ3NwaFwiOlwi4oiiXCIsXCJhbmdzdFwiOlwiw4VcIixcImFuZ3phcnJcIjpcIuKNvFwiLFwiQW9nb25cIjpcIsSEXCIsXCJhb2dvblwiOlwixIVcIixcIkFvcGZcIjpcIvCdlLhcIixcImFvcGZcIjpcIvCdlZJcIixcImFwYWNpclwiOlwi4qmvXCIsXCJhcFwiOlwi4omIXCIsXCJhcEVcIjpcIuKpsFwiLFwiYXBlXCI6XCLiiYpcIixcImFwaWRcIjpcIuKJi1wiLFwiYXBvc1wiOlwiJ1wiLFwiQXBwbHlGdW5jdGlvblwiOlwi4oGhXCIsXCJhcHByb3hcIjpcIuKJiFwiLFwiYXBwcm94ZXFcIjpcIuKJilwiLFwiQXJpbmdcIjpcIsOFXCIsXCJhcmluZ1wiOlwiw6VcIixcIkFzY3JcIjpcIvCdkpxcIixcImFzY3JcIjpcIvCdkrZcIixcIkFzc2lnblwiOlwi4omUXCIsXCJhc3RcIjpcIipcIixcImFzeW1wXCI6XCLiiYhcIixcImFzeW1wZXFcIjpcIuKJjVwiLFwiQXRpbGRlXCI6XCLDg1wiLFwiYXRpbGRlXCI6XCLDo1wiLFwiQXVtbFwiOlwiw4RcIixcImF1bWxcIjpcIsOkXCIsXCJhd2NvbmludFwiOlwi4oizXCIsXCJhd2ludFwiOlwi4qiRXCIsXCJiYWNrY29uZ1wiOlwi4omMXCIsXCJiYWNrZXBzaWxvblwiOlwiz7ZcIixcImJhY2twcmltZVwiOlwi4oC1XCIsXCJiYWNrc2ltXCI6XCLiiL1cIixcImJhY2tzaW1lcVwiOlwi4ouNXCIsXCJCYWNrc2xhc2hcIjpcIuKIllwiLFwiQmFydlwiOlwi4qunXCIsXCJiYXJ2ZWVcIjpcIuKKvVwiLFwiYmFyd2VkXCI6XCLijIVcIixcIkJhcndlZFwiOlwi4oyGXCIsXCJiYXJ3ZWRnZVwiOlwi4oyFXCIsXCJiYnJrXCI6XCLijrVcIixcImJicmt0YnJrXCI6XCLijrZcIixcImJjb25nXCI6XCLiiYxcIixcIkJjeVwiOlwi0JFcIixcImJjeVwiOlwi0LFcIixcImJkcXVvXCI6XCLigJ5cIixcImJlY2F1c1wiOlwi4oi1XCIsXCJiZWNhdXNlXCI6XCLiiLVcIixcIkJlY2F1c2VcIjpcIuKItVwiLFwiYmVtcHR5dlwiOlwi4qawXCIsXCJiZXBzaVwiOlwiz7ZcIixcImJlcm5vdVwiOlwi4oSsXCIsXCJCZXJub3VsbGlzXCI6XCLihKxcIixcIkJldGFcIjpcIs6SXCIsXCJiZXRhXCI6XCLOslwiLFwiYmV0aFwiOlwi4oS2XCIsXCJiZXR3ZWVuXCI6XCLiiaxcIixcIkJmclwiOlwi8J2UhVwiLFwiYmZyXCI6XCLwnZSfXCIsXCJiaWdjYXBcIjpcIuKLglwiLFwiYmlnY2lyY1wiOlwi4pevXCIsXCJiaWdjdXBcIjpcIuKLg1wiLFwiYmlnb2RvdFwiOlwi4qiAXCIsXCJiaWdvcGx1c1wiOlwi4qiBXCIsXCJiaWdvdGltZXNcIjpcIuKoglwiLFwiYmlnc3FjdXBcIjpcIuKohlwiLFwiYmlnc3RhclwiOlwi4piFXCIsXCJiaWd0cmlhbmdsZWRvd25cIjpcIuKWvVwiLFwiYmlndHJpYW5nbGV1cFwiOlwi4pazXCIsXCJiaWd1cGx1c1wiOlwi4qiEXCIsXCJiaWd2ZWVcIjpcIuKLgVwiLFwiYmlnd2VkZ2VcIjpcIuKLgFwiLFwiYmthcm93XCI6XCLipI1cIixcImJsYWNrbG96ZW5nZVwiOlwi4qerXCIsXCJibGFja3NxdWFyZVwiOlwi4paqXCIsXCJibGFja3RyaWFuZ2xlXCI6XCLilrRcIixcImJsYWNrdHJpYW5nbGVkb3duXCI6XCLilr5cIixcImJsYWNrdHJpYW5nbGVsZWZ0XCI6XCLil4JcIixcImJsYWNrdHJpYW5nbGVyaWdodFwiOlwi4pa4XCIsXCJibGFua1wiOlwi4pCjXCIsXCJibGsxMlwiOlwi4paSXCIsXCJibGsxNFwiOlwi4paRXCIsXCJibGszNFwiOlwi4paTXCIsXCJibG9ja1wiOlwi4paIXCIsXCJibmVcIjpcIj3ig6VcIixcImJuZXF1aXZcIjpcIuKJoeKDpVwiLFwiYk5vdFwiOlwi4qutXCIsXCJibm90XCI6XCLijJBcIixcIkJvcGZcIjpcIvCdlLlcIixcImJvcGZcIjpcIvCdlZNcIixcImJvdFwiOlwi4oqlXCIsXCJib3R0b21cIjpcIuKKpVwiLFwiYm93dGllXCI6XCLii4hcIixcImJveGJveFwiOlwi4qeJXCIsXCJib3hkbFwiOlwi4pSQXCIsXCJib3hkTFwiOlwi4pWVXCIsXCJib3hEbFwiOlwi4pWWXCIsXCJib3hETFwiOlwi4pWXXCIsXCJib3hkclwiOlwi4pSMXCIsXCJib3hkUlwiOlwi4pWSXCIsXCJib3hEclwiOlwi4pWTXCIsXCJib3hEUlwiOlwi4pWUXCIsXCJib3hoXCI6XCLilIBcIixcImJveEhcIjpcIuKVkFwiLFwiYm94aGRcIjpcIuKUrFwiLFwiYm94SGRcIjpcIuKVpFwiLFwiYm94aERcIjpcIuKVpVwiLFwiYm94SERcIjpcIuKVplwiLFwiYm94aHVcIjpcIuKUtFwiLFwiYm94SHVcIjpcIuKVp1wiLFwiYm94aFVcIjpcIuKVqFwiLFwiYm94SFVcIjpcIuKVqVwiLFwiYm94bWludXNcIjpcIuKKn1wiLFwiYm94cGx1c1wiOlwi4oqeXCIsXCJib3h0aW1lc1wiOlwi4oqgXCIsXCJib3h1bFwiOlwi4pSYXCIsXCJib3h1TFwiOlwi4pWbXCIsXCJib3hVbFwiOlwi4pWcXCIsXCJib3hVTFwiOlwi4pWdXCIsXCJib3h1clwiOlwi4pSUXCIsXCJib3h1UlwiOlwi4pWYXCIsXCJib3hVclwiOlwi4pWZXCIsXCJib3hVUlwiOlwi4pWaXCIsXCJib3h2XCI6XCLilIJcIixcImJveFZcIjpcIuKVkVwiLFwiYm94dmhcIjpcIuKUvFwiLFwiYm94dkhcIjpcIuKVqlwiLFwiYm94VmhcIjpcIuKVq1wiLFwiYm94VkhcIjpcIuKVrFwiLFwiYm94dmxcIjpcIuKUpFwiLFwiYm94dkxcIjpcIuKVoVwiLFwiYm94VmxcIjpcIuKVolwiLFwiYm94VkxcIjpcIuKVo1wiLFwiYm94dnJcIjpcIuKUnFwiLFwiYm94dlJcIjpcIuKVnlwiLFwiYm94VnJcIjpcIuKVn1wiLFwiYm94VlJcIjpcIuKVoFwiLFwiYnByaW1lXCI6XCLigLVcIixcImJyZXZlXCI6XCLLmFwiLFwiQnJldmVcIjpcIsuYXCIsXCJicnZiYXJcIjpcIsKmXCIsXCJic2NyXCI6XCLwnZK3XCIsXCJCc2NyXCI6XCLihKxcIixcImJzZW1pXCI6XCLigY9cIixcImJzaW1cIjpcIuKIvVwiLFwiYnNpbWVcIjpcIuKLjVwiLFwiYnNvbGJcIjpcIuKnhVwiLFwiYnNvbFwiOlwiXFxcXFwiLFwiYnNvbGhzdWJcIjpcIuKfiFwiLFwiYnVsbFwiOlwi4oCiXCIsXCJidWxsZXRcIjpcIuKAolwiLFwiYnVtcFwiOlwi4omOXCIsXCJidW1wRVwiOlwi4qquXCIsXCJidW1wZVwiOlwi4omPXCIsXCJCdW1wZXFcIjpcIuKJjlwiLFwiYnVtcGVxXCI6XCLiiY9cIixcIkNhY3V0ZVwiOlwixIZcIixcImNhY3V0ZVwiOlwixIdcIixcImNhcGFuZFwiOlwi4qmEXCIsXCJjYXBicmN1cFwiOlwi4qmJXCIsXCJjYXBjYXBcIjpcIuKpi1wiLFwiY2FwXCI6XCLiiKlcIixcIkNhcFwiOlwi4ouSXCIsXCJjYXBjdXBcIjpcIuKph1wiLFwiY2FwZG90XCI6XCLiqYBcIixcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6XCLihYVcIixcImNhcHNcIjpcIuKIqe+4gFwiLFwiY2FyZXRcIjpcIuKBgVwiLFwiY2Fyb25cIjpcIsuHXCIsXCJDYXlsZXlzXCI6XCLihK1cIixcImNjYXBzXCI6XCLiqY1cIixcIkNjYXJvblwiOlwixIxcIixcImNjYXJvblwiOlwixI1cIixcIkNjZWRpbFwiOlwiw4dcIixcImNjZWRpbFwiOlwiw6dcIixcIkNjaXJjXCI6XCLEiFwiLFwiY2NpcmNcIjpcIsSJXCIsXCJDY29uaW50XCI6XCLiiLBcIixcImNjdXBzXCI6XCLiqYxcIixcImNjdXBzc21cIjpcIuKpkFwiLFwiQ2RvdFwiOlwixIpcIixcImNkb3RcIjpcIsSLXCIsXCJjZWRpbFwiOlwiwrhcIixcIkNlZGlsbGFcIjpcIsK4XCIsXCJjZW1wdHl2XCI6XCLiprJcIixcImNlbnRcIjpcIsKiXCIsXCJjZW50ZXJkb3RcIjpcIsK3XCIsXCJDZW50ZXJEb3RcIjpcIsK3XCIsXCJjZnJcIjpcIvCdlKBcIixcIkNmclwiOlwi4oStXCIsXCJDSGN5XCI6XCLQp1wiLFwiY2hjeVwiOlwi0YdcIixcImNoZWNrXCI6XCLinJNcIixcImNoZWNrbWFya1wiOlwi4pyTXCIsXCJDaGlcIjpcIs6nXCIsXCJjaGlcIjpcIs+HXCIsXCJjaXJjXCI6XCLLhlwiLFwiY2lyY2VxXCI6XCLiiZdcIixcImNpcmNsZWFycm93bGVmdFwiOlwi4oa6XCIsXCJjaXJjbGVhcnJvd3JpZ2h0XCI6XCLihrtcIixcImNpcmNsZWRhc3RcIjpcIuKKm1wiLFwiY2lyY2xlZGNpcmNcIjpcIuKKmlwiLFwiY2lyY2xlZGRhc2hcIjpcIuKKnVwiLFwiQ2lyY2xlRG90XCI6XCLiiplcIixcImNpcmNsZWRSXCI6XCLCrlwiLFwiY2lyY2xlZFNcIjpcIuKTiFwiLFwiQ2lyY2xlTWludXNcIjpcIuKKllwiLFwiQ2lyY2xlUGx1c1wiOlwi4oqVXCIsXCJDaXJjbGVUaW1lc1wiOlwi4oqXXCIsXCJjaXJcIjpcIuKXi1wiLFwiY2lyRVwiOlwi4qeDXCIsXCJjaXJlXCI6XCLiiZdcIixcImNpcmZuaW50XCI6XCLiqJBcIixcImNpcm1pZFwiOlwi4quvXCIsXCJjaXJzY2lyXCI6XCLip4JcIixcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiyXCIsXCJDbG9zZUN1cmx5RG91YmxlUXVvdGVcIjpcIuKAnVwiLFwiQ2xvc2VDdXJseVF1b3RlXCI6XCLigJlcIixcImNsdWJzXCI6XCLimaNcIixcImNsdWJzdWl0XCI6XCLimaNcIixcImNvbG9uXCI6XCI6XCIsXCJDb2xvblwiOlwi4oi3XCIsXCJDb2xvbmVcIjpcIuKptFwiLFwiY29sb25lXCI6XCLiiZRcIixcImNvbG9uZXFcIjpcIuKJlFwiLFwiY29tbWFcIjpcIixcIixcImNvbW1hdFwiOlwiQFwiLFwiY29tcFwiOlwi4oiBXCIsXCJjb21wZm5cIjpcIuKImFwiLFwiY29tcGxlbWVudFwiOlwi4oiBXCIsXCJjb21wbGV4ZXNcIjpcIuKEglwiLFwiY29uZ1wiOlwi4omFXCIsXCJjb25nZG90XCI6XCLiqa1cIixcIkNvbmdydWVudFwiOlwi4omhXCIsXCJjb25pbnRcIjpcIuKIrlwiLFwiQ29uaW50XCI6XCLiiK9cIixcIkNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiuXCIsXCJjb3BmXCI6XCLwnZWUXCIsXCJDb3BmXCI6XCLihIJcIixcImNvcHJvZFwiOlwi4oiQXCIsXCJDb3Byb2R1Y3RcIjpcIuKIkFwiLFwiY29weVwiOlwiwqlcIixcIkNPUFlcIjpcIsKpXCIsXCJjb3B5c3JcIjpcIuKEl1wiLFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oizXCIsXCJjcmFyclwiOlwi4oa1XCIsXCJjcm9zc1wiOlwi4pyXXCIsXCJDcm9zc1wiOlwi4qivXCIsXCJDc2NyXCI6XCLwnZKeXCIsXCJjc2NyXCI6XCLwnZK4XCIsXCJjc3ViXCI6XCLiq49cIixcImNzdWJlXCI6XCLiq5FcIixcImNzdXBcIjpcIuKrkFwiLFwiY3N1cGVcIjpcIuKrklwiLFwiY3Rkb3RcIjpcIuKLr1wiLFwiY3VkYXJybFwiOlwi4qS4XCIsXCJjdWRhcnJyXCI6XCLipLVcIixcImN1ZXByXCI6XCLii55cIixcImN1ZXNjXCI6XCLii59cIixcImN1bGFyclwiOlwi4oa2XCIsXCJjdWxhcnJwXCI6XCLipL1cIixcImN1cGJyY2FwXCI6XCLiqYhcIixcImN1cGNhcFwiOlwi4qmGXCIsXCJDdXBDYXBcIjpcIuKJjVwiLFwiY3VwXCI6XCLiiKpcIixcIkN1cFwiOlwi4ouTXCIsXCJjdXBjdXBcIjpcIuKpilwiLFwiY3VwZG90XCI6XCLiio1cIixcImN1cG9yXCI6XCLiqYVcIixcImN1cHNcIjpcIuKIqu+4gFwiLFwiY3VyYXJyXCI6XCLihrdcIixcImN1cmFycm1cIjpcIuKkvFwiLFwiY3VybHllcXByZWNcIjpcIuKLnlwiLFwiY3VybHllcXN1Y2NcIjpcIuKLn1wiLFwiY3VybHl2ZWVcIjpcIuKLjlwiLFwiY3VybHl3ZWRnZVwiOlwi4ouPXCIsXCJjdXJyZW5cIjpcIsKkXCIsXCJjdXJ2ZWFycm93bGVmdFwiOlwi4oa2XCIsXCJjdXJ2ZWFycm93cmlnaHRcIjpcIuKGt1wiLFwiY3V2ZWVcIjpcIuKLjlwiLFwiY3V3ZWRcIjpcIuKLj1wiLFwiY3djb25pbnRcIjpcIuKIslwiLFwiY3dpbnRcIjpcIuKIsVwiLFwiY3lsY3R5XCI6XCLijK1cIixcImRhZ2dlclwiOlwi4oCgXCIsXCJEYWdnZXJcIjpcIuKAoVwiLFwiZGFsZXRoXCI6XCLihLhcIixcImRhcnJcIjpcIuKGk1wiLFwiRGFyclwiOlwi4oahXCIsXCJkQXJyXCI6XCLih5NcIixcImRhc2hcIjpcIuKAkFwiLFwiRGFzaHZcIjpcIuKrpFwiLFwiZGFzaHZcIjpcIuKKo1wiLFwiZGJrYXJvd1wiOlwi4qSPXCIsXCJkYmxhY1wiOlwiy51cIixcIkRjYXJvblwiOlwixI5cIixcImRjYXJvblwiOlwixI9cIixcIkRjeVwiOlwi0JRcIixcImRjeVwiOlwi0LRcIixcImRkYWdnZXJcIjpcIuKAoVwiLFwiZGRhcnJcIjpcIuKHilwiLFwiRERcIjpcIuKFhVwiLFwiZGRcIjpcIuKFhlwiLFwiRERvdHJhaGRcIjpcIuKkkVwiLFwiZGRvdHNlcVwiOlwi4qm3XCIsXCJkZWdcIjpcIsKwXCIsXCJEZWxcIjpcIuKIh1wiLFwiRGVsdGFcIjpcIs6UXCIsXCJkZWx0YVwiOlwizrRcIixcImRlbXB0eXZcIjpcIuKmsVwiLFwiZGZpc2h0XCI6XCLipb9cIixcIkRmclwiOlwi8J2Uh1wiLFwiZGZyXCI6XCLwnZShXCIsXCJkSGFyXCI6XCLipaVcIixcImRoYXJsXCI6XCLih4NcIixcImRoYXJyXCI6XCLih4JcIixcIkRpYWNyaXRpY2FsQWN1dGVcIjpcIsK0XCIsXCJEaWFjcml0aWNhbERvdFwiOlwiy5lcIixcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjpcIsudXCIsXCJEaWFjcml0aWNhbEdyYXZlXCI6XCJgXCIsXCJEaWFjcml0aWNhbFRpbGRlXCI6XCLLnFwiLFwiZGlhbVwiOlwi4ouEXCIsXCJkaWFtb25kXCI6XCLii4RcIixcIkRpYW1vbmRcIjpcIuKLhFwiLFwiZGlhbW9uZHN1aXRcIjpcIuKZplwiLFwiZGlhbXNcIjpcIuKZplwiLFwiZGllXCI6XCLCqFwiLFwiRGlmZmVyZW50aWFsRFwiOlwi4oWGXCIsXCJkaWdhbW1hXCI6XCLPnVwiLFwiZGlzaW5cIjpcIuKLslwiLFwiZGl2XCI6XCLDt1wiLFwiZGl2aWRlXCI6XCLDt1wiLFwiZGl2aWRlb250aW1lc1wiOlwi4ouHXCIsXCJkaXZvbnhcIjpcIuKLh1wiLFwiREpjeVwiOlwi0IJcIixcImRqY3lcIjpcItGSXCIsXCJkbGNvcm5cIjpcIuKMnlwiLFwiZGxjcm9wXCI6XCLijI1cIixcImRvbGxhclwiOlwiJFwiLFwiRG9wZlwiOlwi8J2Uu1wiLFwiZG9wZlwiOlwi8J2VlVwiLFwiRG90XCI6XCLCqFwiLFwiZG90XCI6XCLLmVwiLFwiRG90RG90XCI6XCLig5xcIixcImRvdGVxXCI6XCLiiZBcIixcImRvdGVxZG90XCI6XCLiiZFcIixcIkRvdEVxdWFsXCI6XCLiiZBcIixcImRvdG1pbnVzXCI6XCLiiLhcIixcImRvdHBsdXNcIjpcIuKIlFwiLFwiZG90c3F1YXJlXCI6XCLiiqFcIixcImRvdWJsZWJhcndlZGdlXCI6XCLijIZcIixcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oivXCIsXCJEb3VibGVEb3RcIjpcIsKoXCIsXCJEb3VibGVEb3duQXJyb3dcIjpcIuKHk1wiLFwiRG91YmxlTGVmdEFycm93XCI6XCLih5BcIixcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6XCLih5RcIixcIkRvdWJsZUxlZnRUZWVcIjpcIuKrpFwiLFwiRG91YmxlTG9uZ0xlZnRBcnJvd1wiOlwi4p+4XCIsXCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIuKfulwiLFwiRG91YmxlTG9uZ1JpZ2h0QXJyb3dcIjpcIuKfuVwiLFwiRG91YmxlUmlnaHRBcnJvd1wiOlwi4oeSXCIsXCJEb3VibGVSaWdodFRlZVwiOlwi4oqoXCIsXCJEb3VibGVVcEFycm93XCI6XCLih5FcIixcIkRvdWJsZVVwRG93bkFycm93XCI6XCLih5VcIixcIkRvdWJsZVZlcnRpY2FsQmFyXCI6XCLiiKVcIixcIkRvd25BcnJvd0JhclwiOlwi4qSTXCIsXCJkb3duYXJyb3dcIjpcIuKGk1wiLFwiRG93bkFycm93XCI6XCLihpNcIixcIkRvd25hcnJvd1wiOlwi4oeTXCIsXCJEb3duQXJyb3dVcEFycm93XCI6XCLih7VcIixcIkRvd25CcmV2ZVwiOlwizJFcIixcImRvd25kb3duYXJyb3dzXCI6XCLih4pcIixcImRvd25oYXJwb29ubGVmdFwiOlwi4oeDXCIsXCJkb3duaGFycG9vbnJpZ2h0XCI6XCLih4JcIixcIkRvd25MZWZ0UmlnaHRWZWN0b3JcIjpcIuKlkFwiLFwiRG93bkxlZnRUZWVWZWN0b3JcIjpcIuKlnlwiLFwiRG93bkxlZnRWZWN0b3JCYXJcIjpcIuKlllwiLFwiRG93bkxlZnRWZWN0b3JcIjpcIuKGvVwiLFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6XCLipZ9cIixcIkRvd25SaWdodFZlY3RvckJhclwiOlwi4qWXXCIsXCJEb3duUmlnaHRWZWN0b3JcIjpcIuKHgVwiLFwiRG93blRlZUFycm93XCI6XCLihqdcIixcIkRvd25UZWVcIjpcIuKKpFwiLFwiZHJia2Fyb3dcIjpcIuKkkFwiLFwiZHJjb3JuXCI6XCLijJ9cIixcImRyY3JvcFwiOlwi4oyMXCIsXCJEc2NyXCI6XCLwnZKfXCIsXCJkc2NyXCI6XCLwnZK5XCIsXCJEU2N5XCI6XCLQhVwiLFwiZHNjeVwiOlwi0ZVcIixcImRzb2xcIjpcIuKntlwiLFwiRHN0cm9rXCI6XCLEkFwiLFwiZHN0cm9rXCI6XCLEkVwiLFwiZHRkb3RcIjpcIuKLsVwiLFwiZHRyaVwiOlwi4pa/XCIsXCJkdHJpZlwiOlwi4pa+XCIsXCJkdWFyclwiOlwi4oe1XCIsXCJkdWhhclwiOlwi4qWvXCIsXCJkd2FuZ2xlXCI6XCLipqZcIixcIkRaY3lcIjpcItCPXCIsXCJkemN5XCI6XCLRn1wiLFwiZHppZ3JhcnJcIjpcIuKfv1wiLFwiRWFjdXRlXCI6XCLDiVwiLFwiZWFjdXRlXCI6XCLDqVwiLFwiZWFzdGVyXCI6XCLiqa5cIixcIkVjYXJvblwiOlwixJpcIixcImVjYXJvblwiOlwixJtcIixcIkVjaXJjXCI6XCLDilwiLFwiZWNpcmNcIjpcIsOqXCIsXCJlY2lyXCI6XCLiiZZcIixcImVjb2xvblwiOlwi4omVXCIsXCJFY3lcIjpcItCtXCIsXCJlY3lcIjpcItGNXCIsXCJlRERvdFwiOlwi4qm3XCIsXCJFZG90XCI6XCLEllwiLFwiZWRvdFwiOlwixJdcIixcImVEb3RcIjpcIuKJkVwiLFwiZWVcIjpcIuKFh1wiLFwiZWZEb3RcIjpcIuKJklwiLFwiRWZyXCI6XCLwnZSIXCIsXCJlZnJcIjpcIvCdlKJcIixcImVnXCI6XCLiqppcIixcIkVncmF2ZVwiOlwiw4hcIixcImVncmF2ZVwiOlwiw6hcIixcImVnc1wiOlwi4qqWXCIsXCJlZ3Nkb3RcIjpcIuKqmFwiLFwiZWxcIjpcIuKqmVwiLFwiRWxlbWVudFwiOlwi4oiIXCIsXCJlbGludGVyc1wiOlwi4o+nXCIsXCJlbGxcIjpcIuKEk1wiLFwiZWxzXCI6XCLiqpVcIixcImVsc2RvdFwiOlwi4qqXXCIsXCJFbWFjclwiOlwixJJcIixcImVtYWNyXCI6XCLEk1wiLFwiZW1wdHlcIjpcIuKIhVwiLFwiZW1wdHlzZXRcIjpcIuKIhVwiLFwiRW1wdHlTbWFsbFNxdWFyZVwiOlwi4pe7XCIsXCJlbXB0eXZcIjpcIuKIhVwiLFwiRW1wdHlWZXJ5U21hbGxTcXVhcmVcIjpcIuKWq1wiLFwiZW1zcDEzXCI6XCLigIRcIixcImVtc3AxNFwiOlwi4oCFXCIsXCJlbXNwXCI6XCLigINcIixcIkVOR1wiOlwixYpcIixcImVuZ1wiOlwixYtcIixcImVuc3BcIjpcIuKAglwiLFwiRW9nb25cIjpcIsSYXCIsXCJlb2dvblwiOlwixJlcIixcIkVvcGZcIjpcIvCdlLxcIixcImVvcGZcIjpcIvCdlZZcIixcImVwYXJcIjpcIuKLlVwiLFwiZXBhcnNsXCI6XCLip6NcIixcImVwbHVzXCI6XCLiqbFcIixcImVwc2lcIjpcIs61XCIsXCJFcHNpbG9uXCI6XCLOlVwiLFwiZXBzaWxvblwiOlwizrVcIixcImVwc2l2XCI6XCLPtVwiLFwiZXFjaXJjXCI6XCLiiZZcIixcImVxY29sb25cIjpcIuKJlVwiLFwiZXFzaW1cIjpcIuKJglwiLFwiZXFzbGFudGd0clwiOlwi4qqWXCIsXCJlcXNsYW50bGVzc1wiOlwi4qqVXCIsXCJFcXVhbFwiOlwi4qm1XCIsXCJlcXVhbHNcIjpcIj1cIixcIkVxdWFsVGlsZGVcIjpcIuKJglwiLFwiZXF1ZXN0XCI6XCLiiZ9cIixcIkVxdWlsaWJyaXVtXCI6XCLih4xcIixcImVxdWl2XCI6XCLiiaFcIixcImVxdWl2RERcIjpcIuKpuFwiLFwiZXF2cGFyc2xcIjpcIuKnpVwiLFwiZXJhcnJcIjpcIuKlsVwiLFwiZXJEb3RcIjpcIuKJk1wiLFwiZXNjclwiOlwi4oSvXCIsXCJFc2NyXCI6XCLihLBcIixcImVzZG90XCI6XCLiiZBcIixcIkVzaW1cIjpcIuKps1wiLFwiZXNpbVwiOlwi4omCXCIsXCJFdGFcIjpcIs6XXCIsXCJldGFcIjpcIs63XCIsXCJFVEhcIjpcIsOQXCIsXCJldGhcIjpcIsOwXCIsXCJFdW1sXCI6XCLDi1wiLFwiZXVtbFwiOlwiw6tcIixcImV1cm9cIjpcIuKCrFwiLFwiZXhjbFwiOlwiIVwiLFwiZXhpc3RcIjpcIuKIg1wiLFwiRXhpc3RzXCI6XCLiiINcIixcImV4cGVjdGF0aW9uXCI6XCLihLBcIixcImV4cG9uZW50aWFsZVwiOlwi4oWHXCIsXCJFeHBvbmVudGlhbEVcIjpcIuKFh1wiLFwiZmFsbGluZ2RvdHNlcVwiOlwi4omSXCIsXCJGY3lcIjpcItCkXCIsXCJmY3lcIjpcItGEXCIsXCJmZW1hbGVcIjpcIuKZgFwiLFwiZmZpbGlnXCI6XCLvrINcIixcImZmbGlnXCI6XCLvrIBcIixcImZmbGxpZ1wiOlwi76yEXCIsXCJGZnJcIjpcIvCdlIlcIixcImZmclwiOlwi8J2Uo1wiLFwiZmlsaWdcIjpcIu+sgVwiLFwiRmlsbGVkU21hbGxTcXVhcmVcIjpcIuKXvFwiLFwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlXCI6XCLilqpcIixcImZqbGlnXCI6XCJmalwiLFwiZmxhdFwiOlwi4pmtXCIsXCJmbGxpZ1wiOlwi76yCXCIsXCJmbHRuc1wiOlwi4paxXCIsXCJmbm9mXCI6XCLGklwiLFwiRm9wZlwiOlwi8J2UvVwiLFwiZm9wZlwiOlwi8J2Vl1wiLFwiZm9yYWxsXCI6XCLiiIBcIixcIkZvckFsbFwiOlwi4oiAXCIsXCJmb3JrXCI6XCLii5RcIixcImZvcmt2XCI6XCLiq5lcIixcIkZvdXJpZXJ0cmZcIjpcIuKEsVwiLFwiZnBhcnRpbnRcIjpcIuKojVwiLFwiZnJhYzEyXCI6XCLCvVwiLFwiZnJhYzEzXCI6XCLihZNcIixcImZyYWMxNFwiOlwiwrxcIixcImZyYWMxNVwiOlwi4oWVXCIsXCJmcmFjMTZcIjpcIuKFmVwiLFwiZnJhYzE4XCI6XCLihZtcIixcImZyYWMyM1wiOlwi4oWUXCIsXCJmcmFjMjVcIjpcIuKFllwiLFwiZnJhYzM0XCI6XCLCvlwiLFwiZnJhYzM1XCI6XCLihZdcIixcImZyYWMzOFwiOlwi4oWcXCIsXCJmcmFjNDVcIjpcIuKFmFwiLFwiZnJhYzU2XCI6XCLihZpcIixcImZyYWM1OFwiOlwi4oWdXCIsXCJmcmFjNzhcIjpcIuKFnlwiLFwiZnJhc2xcIjpcIuKBhFwiLFwiZnJvd25cIjpcIuKMolwiLFwiZnNjclwiOlwi8J2Su1wiLFwiRnNjclwiOlwi4oSxXCIsXCJnYWN1dGVcIjpcIse1XCIsXCJHYW1tYVwiOlwizpNcIixcImdhbW1hXCI6XCLOs1wiLFwiR2FtbWFkXCI6XCLPnFwiLFwiZ2FtbWFkXCI6XCLPnVwiLFwiZ2FwXCI6XCLiqoZcIixcIkdicmV2ZVwiOlwixJ5cIixcImdicmV2ZVwiOlwixJ9cIixcIkdjZWRpbFwiOlwixKJcIixcIkdjaXJjXCI6XCLEnFwiLFwiZ2NpcmNcIjpcIsSdXCIsXCJHY3lcIjpcItCTXCIsXCJnY3lcIjpcItCzXCIsXCJHZG90XCI6XCLEoFwiLFwiZ2RvdFwiOlwixKFcIixcImdlXCI6XCLiiaVcIixcImdFXCI6XCLiiadcIixcImdFbFwiOlwi4qqMXCIsXCJnZWxcIjpcIuKLm1wiLFwiZ2VxXCI6XCLiiaVcIixcImdlcXFcIjpcIuKJp1wiLFwiZ2Vxc2xhbnRcIjpcIuKpvlwiLFwiZ2VzY2NcIjpcIuKqqVwiLFwiZ2VzXCI6XCLiqb5cIixcImdlc2RvdFwiOlwi4qqAXCIsXCJnZXNkb3RvXCI6XCLiqoJcIixcImdlc2RvdG9sXCI6XCLiqoRcIixcImdlc2xcIjpcIuKLm++4gFwiLFwiZ2VzbGVzXCI6XCLiqpRcIixcIkdmclwiOlwi8J2UilwiLFwiZ2ZyXCI6XCLwnZSkXCIsXCJnZ1wiOlwi4omrXCIsXCJHZ1wiOlwi4ouZXCIsXCJnZ2dcIjpcIuKLmVwiLFwiZ2ltZWxcIjpcIuKEt1wiLFwiR0pjeVwiOlwi0INcIixcImdqY3lcIjpcItGTXCIsXCJnbGFcIjpcIuKqpVwiLFwiZ2xcIjpcIuKJt1wiLFwiZ2xFXCI6XCLiqpJcIixcImdsalwiOlwi4qqkXCIsXCJnbmFwXCI6XCLiqopcIixcImduYXBwcm94XCI6XCLiqopcIixcImduZVwiOlwi4qqIXCIsXCJnbkVcIjpcIuKJqVwiLFwiZ25lcVwiOlwi4qqIXCIsXCJnbmVxcVwiOlwi4ompXCIsXCJnbnNpbVwiOlwi4ounXCIsXCJHb3BmXCI6XCLwnZS+XCIsXCJnb3BmXCI6XCLwnZWYXCIsXCJncmF2ZVwiOlwiYFwiLFwiR3JlYXRlckVxdWFsXCI6XCLiiaVcIixcIkdyZWF0ZXJFcXVhbExlc3NcIjpcIuKLm1wiLFwiR3JlYXRlckZ1bGxFcXVhbFwiOlwi4omnXCIsXCJHcmVhdGVyR3JlYXRlclwiOlwi4qqiXCIsXCJHcmVhdGVyTGVzc1wiOlwi4om3XCIsXCJHcmVhdGVyU2xhbnRFcXVhbFwiOlwi4qm+XCIsXCJHcmVhdGVyVGlsZGVcIjpcIuKJs1wiLFwiR3NjclwiOlwi8J2SolwiLFwiZ3NjclwiOlwi4oSKXCIsXCJnc2ltXCI6XCLiibNcIixcImdzaW1lXCI6XCLiqo5cIixcImdzaW1sXCI6XCLiqpBcIixcImd0Y2NcIjpcIuKqp1wiLFwiZ3RjaXJcIjpcIuKpulwiLFwiZ3RcIjpcIj5cIixcIkdUXCI6XCI+XCIsXCJHdFwiOlwi4omrXCIsXCJndGRvdFwiOlwi4ouXXCIsXCJndGxQYXJcIjpcIuKmlVwiLFwiZ3RxdWVzdFwiOlwi4qm8XCIsXCJndHJhcHByb3hcIjpcIuKqhlwiLFwiZ3RyYXJyXCI6XCLipbhcIixcImd0cmRvdFwiOlwi4ouXXCIsXCJndHJlcWxlc3NcIjpcIuKLm1wiLFwiZ3RyZXFxbGVzc1wiOlwi4qqMXCIsXCJndHJsZXNzXCI6XCLiibdcIixcImd0cnNpbVwiOlwi4omzXCIsXCJndmVydG5lcXFcIjpcIuKJqe+4gFwiLFwiZ3ZuRVwiOlwi4omp77iAXCIsXCJIYWNla1wiOlwiy4dcIixcImhhaXJzcFwiOlwi4oCKXCIsXCJoYWxmXCI6XCLCvVwiLFwiaGFtaWx0XCI6XCLihItcIixcIkhBUkRjeVwiOlwi0KpcIixcImhhcmRjeVwiOlwi0YpcIixcImhhcnJjaXJcIjpcIuKliFwiLFwiaGFyclwiOlwi4oaUXCIsXCJoQXJyXCI6XCLih5RcIixcImhhcnJ3XCI6XCLihq1cIixcIkhhdFwiOlwiXlwiLFwiaGJhclwiOlwi4oSPXCIsXCJIY2lyY1wiOlwixKRcIixcImhjaXJjXCI6XCLEpVwiLFwiaGVhcnRzXCI6XCLimaVcIixcImhlYXJ0c3VpdFwiOlwi4pmlXCIsXCJoZWxsaXBcIjpcIuKAplwiLFwiaGVyY29uXCI6XCLiirlcIixcImhmclwiOlwi8J2UpVwiLFwiSGZyXCI6XCLihIxcIixcIkhpbGJlcnRTcGFjZVwiOlwi4oSLXCIsXCJoa3NlYXJvd1wiOlwi4qSlXCIsXCJoa3N3YXJvd1wiOlwi4qSmXCIsXCJob2FyclwiOlwi4oe/XCIsXCJob210aHRcIjpcIuKIu1wiLFwiaG9va2xlZnRhcnJvd1wiOlwi4oapXCIsXCJob29rcmlnaHRhcnJvd1wiOlwi4oaqXCIsXCJob3BmXCI6XCLwnZWZXCIsXCJIb3BmXCI6XCLihI1cIixcImhvcmJhclwiOlwi4oCVXCIsXCJIb3Jpem9udGFsTGluZVwiOlwi4pSAXCIsXCJoc2NyXCI6XCLwnZK9XCIsXCJIc2NyXCI6XCLihItcIixcImhzbGFzaFwiOlwi4oSPXCIsXCJIc3Ryb2tcIjpcIsSmXCIsXCJoc3Ryb2tcIjpcIsSnXCIsXCJIdW1wRG93bkh1bXBcIjpcIuKJjlwiLFwiSHVtcEVxdWFsXCI6XCLiiY9cIixcImh5YnVsbFwiOlwi4oGDXCIsXCJoeXBoZW5cIjpcIuKAkFwiLFwiSWFjdXRlXCI6XCLDjVwiLFwiaWFjdXRlXCI6XCLDrVwiLFwiaWNcIjpcIuKBo1wiLFwiSWNpcmNcIjpcIsOOXCIsXCJpY2lyY1wiOlwiw65cIixcIkljeVwiOlwi0JhcIixcImljeVwiOlwi0LhcIixcIklkb3RcIjpcIsSwXCIsXCJJRWN5XCI6XCLQlVwiLFwiaWVjeVwiOlwi0LVcIixcImlleGNsXCI6XCLCoVwiLFwiaWZmXCI6XCLih5RcIixcImlmclwiOlwi8J2UplwiLFwiSWZyXCI6XCLihJFcIixcIklncmF2ZVwiOlwiw4xcIixcImlncmF2ZVwiOlwiw6xcIixcImlpXCI6XCLihYhcIixcImlpaWludFwiOlwi4qiMXCIsXCJpaWludFwiOlwi4oitXCIsXCJpaW5maW5cIjpcIuKnnFwiLFwiaWlvdGFcIjpcIuKEqVwiLFwiSUpsaWdcIjpcIsSyXCIsXCJpamxpZ1wiOlwixLNcIixcIkltYWNyXCI6XCLEqlwiLFwiaW1hY3JcIjpcIsSrXCIsXCJpbWFnZVwiOlwi4oSRXCIsXCJJbWFnaW5hcnlJXCI6XCLihYhcIixcImltYWdsaW5lXCI6XCLihJBcIixcImltYWdwYXJ0XCI6XCLihJFcIixcImltYXRoXCI6XCLEsVwiLFwiSW1cIjpcIuKEkVwiLFwiaW1vZlwiOlwi4oq3XCIsXCJpbXBlZFwiOlwixrVcIixcIkltcGxpZXNcIjpcIuKHklwiLFwiaW5jYXJlXCI6XCLihIVcIixcImluXCI6XCLiiIhcIixcImluZmluXCI6XCLiiJ5cIixcImluZmludGllXCI6XCLip51cIixcImlub2RvdFwiOlwixLFcIixcImludGNhbFwiOlwi4oq6XCIsXCJpbnRcIjpcIuKIq1wiLFwiSW50XCI6XCLiiKxcIixcImludGVnZXJzXCI6XCLihKRcIixcIkludGVncmFsXCI6XCLiiKtcIixcImludGVyY2FsXCI6XCLiirpcIixcIkludGVyc2VjdGlvblwiOlwi4ouCXCIsXCJpbnRsYXJoa1wiOlwi4qiXXCIsXCJpbnRwcm9kXCI6XCLiqLxcIixcIkludmlzaWJsZUNvbW1hXCI6XCLigaNcIixcIkludmlzaWJsZVRpbWVzXCI6XCLigaJcIixcIklPY3lcIjpcItCBXCIsXCJpb2N5XCI6XCLRkVwiLFwiSW9nb25cIjpcIsSuXCIsXCJpb2dvblwiOlwixK9cIixcIklvcGZcIjpcIvCdlYBcIixcImlvcGZcIjpcIvCdlZpcIixcIklvdGFcIjpcIs6ZXCIsXCJpb3RhXCI6XCLOuVwiLFwiaXByb2RcIjpcIuKovFwiLFwiaXF1ZXN0XCI6XCLCv1wiLFwiaXNjclwiOlwi8J2SvlwiLFwiSXNjclwiOlwi4oSQXCIsXCJpc2luXCI6XCLiiIhcIixcImlzaW5kb3RcIjpcIuKLtVwiLFwiaXNpbkVcIjpcIuKLuVwiLFwiaXNpbnNcIjpcIuKLtFwiLFwiaXNpbnN2XCI6XCLii7NcIixcImlzaW52XCI6XCLiiIhcIixcIml0XCI6XCLigaJcIixcIkl0aWxkZVwiOlwixKhcIixcIml0aWxkZVwiOlwixKlcIixcIkl1a2N5XCI6XCLQhlwiLFwiaXVrY3lcIjpcItGWXCIsXCJJdW1sXCI6XCLDj1wiLFwiaXVtbFwiOlwiw69cIixcIkpjaXJjXCI6XCLEtFwiLFwiamNpcmNcIjpcIsS1XCIsXCJKY3lcIjpcItCZXCIsXCJqY3lcIjpcItC5XCIsXCJKZnJcIjpcIvCdlI1cIixcImpmclwiOlwi8J2Up1wiLFwiam1hdGhcIjpcIsi3XCIsXCJKb3BmXCI6XCLwnZWBXCIsXCJqb3BmXCI6XCLwnZWbXCIsXCJKc2NyXCI6XCLwnZKlXCIsXCJqc2NyXCI6XCLwnZK/XCIsXCJKc2VyY3lcIjpcItCIXCIsXCJqc2VyY3lcIjpcItGYXCIsXCJKdWtjeVwiOlwi0IRcIixcImp1a2N5XCI6XCLRlFwiLFwiS2FwcGFcIjpcIs6aXCIsXCJrYXBwYVwiOlwizrpcIixcImthcHBhdlwiOlwiz7BcIixcIktjZWRpbFwiOlwixLZcIixcImtjZWRpbFwiOlwixLdcIixcIktjeVwiOlwi0JpcIixcImtjeVwiOlwi0LpcIixcIktmclwiOlwi8J2UjlwiLFwia2ZyXCI6XCLwnZSoXCIsXCJrZ3JlZW5cIjpcIsS4XCIsXCJLSGN5XCI6XCLQpVwiLFwia2hjeVwiOlwi0YVcIixcIktKY3lcIjpcItCMXCIsXCJramN5XCI6XCLRnFwiLFwiS29wZlwiOlwi8J2VglwiLFwia29wZlwiOlwi8J2VnFwiLFwiS3NjclwiOlwi8J2SplwiLFwia3NjclwiOlwi8J2TgFwiLFwibEFhcnJcIjpcIuKHmlwiLFwiTGFjdXRlXCI6XCLEuVwiLFwibGFjdXRlXCI6XCLEulwiLFwibGFlbXB0eXZcIjpcIuKmtFwiLFwibGFncmFuXCI6XCLihJJcIixcIkxhbWJkYVwiOlwizptcIixcImxhbWJkYVwiOlwizrtcIixcImxhbmdcIjpcIuKfqFwiLFwiTGFuZ1wiOlwi4p+qXCIsXCJsYW5nZFwiOlwi4qaRXCIsXCJsYW5nbGVcIjpcIuKfqFwiLFwibGFwXCI6XCLiqoVcIixcIkxhcGxhY2V0cmZcIjpcIuKEklwiLFwibGFxdW9cIjpcIsKrXCIsXCJsYXJyYlwiOlwi4oekXCIsXCJsYXJyYmZzXCI6XCLipJ9cIixcImxhcnJcIjpcIuKGkFwiLFwiTGFyclwiOlwi4oaeXCIsXCJsQXJyXCI6XCLih5BcIixcImxhcnJmc1wiOlwi4qSdXCIsXCJsYXJyaGtcIjpcIuKGqVwiLFwibGFycmxwXCI6XCLihqtcIixcImxhcnJwbFwiOlwi4qS5XCIsXCJsYXJyc2ltXCI6XCLipbNcIixcImxhcnJ0bFwiOlwi4oaiXCIsXCJsYXRhaWxcIjpcIuKkmVwiLFwibEF0YWlsXCI6XCLipJtcIixcImxhdFwiOlwi4qqrXCIsXCJsYXRlXCI6XCLiqq1cIixcImxhdGVzXCI6XCLiqq3vuIBcIixcImxiYXJyXCI6XCLipIxcIixcImxCYXJyXCI6XCLipI5cIixcImxiYnJrXCI6XCLinbJcIixcImxicmFjZVwiOlwie1wiLFwibGJyYWNrXCI6XCJbXCIsXCJsYnJrZVwiOlwi4qaLXCIsXCJsYnJrc2xkXCI6XCLipo9cIixcImxicmtzbHVcIjpcIuKmjVwiLFwiTGNhcm9uXCI6XCLEvVwiLFwibGNhcm9uXCI6XCLEvlwiLFwiTGNlZGlsXCI6XCLEu1wiLFwibGNlZGlsXCI6XCLEvFwiLFwibGNlaWxcIjpcIuKMiFwiLFwibGN1YlwiOlwie1wiLFwiTGN5XCI6XCLQm1wiLFwibGN5XCI6XCLQu1wiLFwibGRjYVwiOlwi4qS2XCIsXCJsZHF1b1wiOlwi4oCcXCIsXCJsZHF1b3JcIjpcIuKAnlwiLFwibGRyZGhhclwiOlwi4qWnXCIsXCJsZHJ1c2hhclwiOlwi4qWLXCIsXCJsZHNoXCI6XCLihrJcIixcImxlXCI6XCLiiaRcIixcImxFXCI6XCLiiaZcIixcIkxlZnRBbmdsZUJyYWNrZXRcIjpcIuKfqFwiLFwiTGVmdEFycm93QmFyXCI6XCLih6RcIixcImxlZnRhcnJvd1wiOlwi4oaQXCIsXCJMZWZ0QXJyb3dcIjpcIuKGkFwiLFwiTGVmdGFycm93XCI6XCLih5BcIixcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjpcIuKHhlwiLFwibGVmdGFycm93dGFpbFwiOlwi4oaiXCIsXCJMZWZ0Q2VpbGluZ1wiOlwi4oyIXCIsXCJMZWZ0RG91YmxlQnJhY2tldFwiOlwi4p+mXCIsXCJMZWZ0RG93blRlZVZlY3RvclwiOlwi4qWhXCIsXCJMZWZ0RG93blZlY3RvckJhclwiOlwi4qWZXCIsXCJMZWZ0RG93blZlY3RvclwiOlwi4oeDXCIsXCJMZWZ0Rmxvb3JcIjpcIuKMilwiLFwibGVmdGhhcnBvb25kb3duXCI6XCLihr1cIixcImxlZnRoYXJwb29udXBcIjpcIuKGvFwiLFwibGVmdGxlZnRhcnJvd3NcIjpcIuKHh1wiLFwibGVmdHJpZ2h0YXJyb3dcIjpcIuKGlFwiLFwiTGVmdFJpZ2h0QXJyb3dcIjpcIuKGlFwiLFwiTGVmdHJpZ2h0YXJyb3dcIjpcIuKHlFwiLFwibGVmdHJpZ2h0YXJyb3dzXCI6XCLih4ZcIixcImxlZnRyaWdodGhhcnBvb25zXCI6XCLih4tcIixcImxlZnRyaWdodHNxdWlnYXJyb3dcIjpcIuKGrVwiLFwiTGVmdFJpZ2h0VmVjdG9yXCI6XCLipY5cIixcIkxlZnRUZWVBcnJvd1wiOlwi4oakXCIsXCJMZWZ0VGVlXCI6XCLiiqNcIixcIkxlZnRUZWVWZWN0b3JcIjpcIuKlmlwiLFwibGVmdHRocmVldGltZXNcIjpcIuKLi1wiLFwiTGVmdFRyaWFuZ2xlQmFyXCI6XCLip49cIixcIkxlZnRUcmlhbmdsZVwiOlwi4oqyXCIsXCJMZWZ0VHJpYW5nbGVFcXVhbFwiOlwi4oq0XCIsXCJMZWZ0VXBEb3duVmVjdG9yXCI6XCLipZFcIixcIkxlZnRVcFRlZVZlY3RvclwiOlwi4qWgXCIsXCJMZWZ0VXBWZWN0b3JCYXJcIjpcIuKlmFwiLFwiTGVmdFVwVmVjdG9yXCI6XCLihr9cIixcIkxlZnRWZWN0b3JCYXJcIjpcIuKlklwiLFwiTGVmdFZlY3RvclwiOlwi4oa8XCIsXCJsRWdcIjpcIuKqi1wiLFwibGVnXCI6XCLii5pcIixcImxlcVwiOlwi4omkXCIsXCJsZXFxXCI6XCLiiaZcIixcImxlcXNsYW50XCI6XCLiqb1cIixcImxlc2NjXCI6XCLiqqhcIixcImxlc1wiOlwi4qm9XCIsXCJsZXNkb3RcIjpcIuKpv1wiLFwibGVzZG90b1wiOlwi4qqBXCIsXCJsZXNkb3RvclwiOlwi4qqDXCIsXCJsZXNnXCI6XCLii5rvuIBcIixcImxlc2dlc1wiOlwi4qqTXCIsXCJsZXNzYXBwcm94XCI6XCLiqoVcIixcImxlc3Nkb3RcIjpcIuKLllwiLFwibGVzc2VxZ3RyXCI6XCLii5pcIixcImxlc3NlcXFndHJcIjpcIuKqi1wiLFwiTGVzc0VxdWFsR3JlYXRlclwiOlwi4ouaXCIsXCJMZXNzRnVsbEVxdWFsXCI6XCLiiaZcIixcIkxlc3NHcmVhdGVyXCI6XCLiibZcIixcImxlc3NndHJcIjpcIuKJtlwiLFwiTGVzc0xlc3NcIjpcIuKqoVwiLFwibGVzc3NpbVwiOlwi4omyXCIsXCJMZXNzU2xhbnRFcXVhbFwiOlwi4qm9XCIsXCJMZXNzVGlsZGVcIjpcIuKJslwiLFwibGZpc2h0XCI6XCLipbxcIixcImxmbG9vclwiOlwi4oyKXCIsXCJMZnJcIjpcIvCdlI9cIixcImxmclwiOlwi8J2UqVwiLFwibGdcIjpcIuKJtlwiLFwibGdFXCI6XCLiqpFcIixcImxIYXJcIjpcIuKlolwiLFwibGhhcmRcIjpcIuKGvVwiLFwibGhhcnVcIjpcIuKGvFwiLFwibGhhcnVsXCI6XCLipapcIixcImxoYmxrXCI6XCLiloRcIixcIkxKY3lcIjpcItCJXCIsXCJsamN5XCI6XCLRmVwiLFwibGxhcnJcIjpcIuKHh1wiLFwibGxcIjpcIuKJqlwiLFwiTGxcIjpcIuKLmFwiLFwibGxjb3JuZXJcIjpcIuKMnlwiLFwiTGxlZnRhcnJvd1wiOlwi4oeaXCIsXCJsbGhhcmRcIjpcIuKlq1wiLFwibGx0cmlcIjpcIuKXulwiLFwiTG1pZG90XCI6XCLEv1wiLFwibG1pZG90XCI6XCLFgFwiLFwibG1vdXN0YWNoZVwiOlwi4o6wXCIsXCJsbW91c3RcIjpcIuKOsFwiLFwibG5hcFwiOlwi4qqJXCIsXCJsbmFwcHJveFwiOlwi4qqJXCIsXCJsbmVcIjpcIuKqh1wiLFwibG5FXCI6XCLiiahcIixcImxuZXFcIjpcIuKqh1wiLFwibG5lcXFcIjpcIuKJqFwiLFwibG5zaW1cIjpcIuKLplwiLFwibG9hbmdcIjpcIuKfrFwiLFwibG9hcnJcIjpcIuKHvVwiLFwibG9icmtcIjpcIuKfplwiLFwibG9uZ2xlZnRhcnJvd1wiOlwi4p+1XCIsXCJMb25nTGVmdEFycm93XCI6XCLin7VcIixcIkxvbmdsZWZ0YXJyb3dcIjpcIuKfuFwiLFwibG9uZ2xlZnRyaWdodGFycm93XCI6XCLin7dcIixcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwi4p+3XCIsXCJMb25nbGVmdHJpZ2h0YXJyb3dcIjpcIuKfulwiLFwibG9uZ21hcHN0b1wiOlwi4p+8XCIsXCJsb25ncmlnaHRhcnJvd1wiOlwi4p+2XCIsXCJMb25nUmlnaHRBcnJvd1wiOlwi4p+2XCIsXCJMb25ncmlnaHRhcnJvd1wiOlwi4p+5XCIsXCJsb29wYXJyb3dsZWZ0XCI6XCLihqtcIixcImxvb3BhcnJvd3JpZ2h0XCI6XCLihqxcIixcImxvcGFyXCI6XCLipoVcIixcIkxvcGZcIjpcIvCdlYNcIixcImxvcGZcIjpcIvCdlZ1cIixcImxvcGx1c1wiOlwi4qitXCIsXCJsb3RpbWVzXCI6XCLiqLRcIixcImxvd2FzdFwiOlwi4oiXXCIsXCJsb3diYXJcIjpcIl9cIixcIkxvd2VyTGVmdEFycm93XCI6XCLihplcIixcIkxvd2VyUmlnaHRBcnJvd1wiOlwi4oaYXCIsXCJsb3pcIjpcIuKXilwiLFwibG96ZW5nZVwiOlwi4peKXCIsXCJsb3pmXCI6XCLip6tcIixcImxwYXJcIjpcIihcIixcImxwYXJsdFwiOlwi4qaTXCIsXCJscmFyclwiOlwi4oeGXCIsXCJscmNvcm5lclwiOlwi4oyfXCIsXCJscmhhclwiOlwi4oeLXCIsXCJscmhhcmRcIjpcIuKlrVwiLFwibHJtXCI6XCLigI5cIixcImxydHJpXCI6XCLiir9cIixcImxzYXF1b1wiOlwi4oC5XCIsXCJsc2NyXCI6XCLwnZOBXCIsXCJMc2NyXCI6XCLihJJcIixcImxzaFwiOlwi4oawXCIsXCJMc2hcIjpcIuKGsFwiLFwibHNpbVwiOlwi4omyXCIsXCJsc2ltZVwiOlwi4qqNXCIsXCJsc2ltZ1wiOlwi4qqPXCIsXCJsc3FiXCI6XCJbXCIsXCJsc3F1b1wiOlwi4oCYXCIsXCJsc3F1b3JcIjpcIuKAmlwiLFwiTHN0cm9rXCI6XCLFgVwiLFwibHN0cm9rXCI6XCLFglwiLFwibHRjY1wiOlwi4qqmXCIsXCJsdGNpclwiOlwi4qm5XCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIkx0XCI6XCLiiapcIixcImx0ZG90XCI6XCLii5ZcIixcImx0aHJlZVwiOlwi4ouLXCIsXCJsdGltZXNcIjpcIuKLiVwiLFwibHRsYXJyXCI6XCLipbZcIixcImx0cXVlc3RcIjpcIuKpu1wiLFwibHRyaVwiOlwi4peDXCIsXCJsdHJpZVwiOlwi4oq0XCIsXCJsdHJpZlwiOlwi4peCXCIsXCJsdHJQYXJcIjpcIuKmllwiLFwibHVyZHNoYXJcIjpcIuKlilwiLFwibHVydWhhclwiOlwi4qWmXCIsXCJsdmVydG5lcXFcIjpcIuKJqO+4gFwiLFwibHZuRVwiOlwi4omo77iAXCIsXCJtYWNyXCI6XCLCr1wiLFwibWFsZVwiOlwi4pmCXCIsXCJtYWx0XCI6XCLinKBcIixcIm1hbHRlc2VcIjpcIuKcoFwiLFwiTWFwXCI6XCLipIVcIixcIm1hcFwiOlwi4oamXCIsXCJtYXBzdG9cIjpcIuKGplwiLFwibWFwc3RvZG93blwiOlwi4oanXCIsXCJtYXBzdG9sZWZ0XCI6XCLihqRcIixcIm1hcHN0b3VwXCI6XCLihqVcIixcIm1hcmtlclwiOlwi4pauXCIsXCJtY29tbWFcIjpcIuKoqVwiLFwiTWN5XCI6XCLQnFwiLFwibWN5XCI6XCLQvFwiLFwibWRhc2hcIjpcIuKAlFwiLFwibUREb3RcIjpcIuKIulwiLFwibWVhc3VyZWRhbmdsZVwiOlwi4oihXCIsXCJNZWRpdW1TcGFjZVwiOlwi4oGfXCIsXCJNZWxsaW50cmZcIjpcIuKEs1wiLFwiTWZyXCI6XCLwnZSQXCIsXCJtZnJcIjpcIvCdlKpcIixcIm1ob1wiOlwi4oSnXCIsXCJtaWNyb1wiOlwiwrVcIixcIm1pZGFzdFwiOlwiKlwiLFwibWlkY2lyXCI6XCLiq7BcIixcIm1pZFwiOlwi4oijXCIsXCJtaWRkb3RcIjpcIsK3XCIsXCJtaW51c2JcIjpcIuKKn1wiLFwibWludXNcIjpcIuKIklwiLFwibWludXNkXCI6XCLiiLhcIixcIm1pbnVzZHVcIjpcIuKoqlwiLFwiTWludXNQbHVzXCI6XCLiiJNcIixcIm1sY3BcIjpcIuKrm1wiLFwibWxkclwiOlwi4oCmXCIsXCJtbnBsdXNcIjpcIuKIk1wiLFwibW9kZWxzXCI6XCLiiqdcIixcIk1vcGZcIjpcIvCdlYRcIixcIm1vcGZcIjpcIvCdlZ5cIixcIm1wXCI6XCLiiJNcIixcIm1zY3JcIjpcIvCdk4JcIixcIk1zY3JcIjpcIuKEs1wiLFwibXN0cG9zXCI6XCLiiL5cIixcIk11XCI6XCLOnFwiLFwibXVcIjpcIs68XCIsXCJtdWx0aW1hcFwiOlwi4oq4XCIsXCJtdW1hcFwiOlwi4oq4XCIsXCJuYWJsYVwiOlwi4oiHXCIsXCJOYWN1dGVcIjpcIsWDXCIsXCJuYWN1dGVcIjpcIsWEXCIsXCJuYW5nXCI6XCLiiKDig5JcIixcIm5hcFwiOlwi4omJXCIsXCJuYXBFXCI6XCLiqbDMuFwiLFwibmFwaWRcIjpcIuKJi8y4XCIsXCJuYXBvc1wiOlwixYlcIixcIm5hcHByb3hcIjpcIuKJiVwiLFwibmF0dXJhbFwiOlwi4pmuXCIsXCJuYXR1cmFsc1wiOlwi4oSVXCIsXCJuYXR1clwiOlwi4pmuXCIsXCJuYnNwXCI6XCLCoFwiLFwibmJ1bXBcIjpcIuKJjsy4XCIsXCJuYnVtcGVcIjpcIuKJj8y4XCIsXCJuY2FwXCI6XCLiqYNcIixcIk5jYXJvblwiOlwixYdcIixcIm5jYXJvblwiOlwixYhcIixcIk5jZWRpbFwiOlwixYVcIixcIm5jZWRpbFwiOlwixYZcIixcIm5jb25nXCI6XCLiiYdcIixcIm5jb25nZG90XCI6XCLiqa3MuFwiLFwibmN1cFwiOlwi4qmCXCIsXCJOY3lcIjpcItCdXCIsXCJuY3lcIjpcItC9XCIsXCJuZGFzaFwiOlwi4oCTXCIsXCJuZWFyaGtcIjpcIuKkpFwiLFwibmVhcnJcIjpcIuKGl1wiLFwibmVBcnJcIjpcIuKHl1wiLFwibmVhcnJvd1wiOlwi4oaXXCIsXCJuZVwiOlwi4omgXCIsXCJuZWRvdFwiOlwi4omQzLhcIixcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVUaGlja1NwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVGhpblNwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOlwi4oCLXCIsXCJuZXF1aXZcIjpcIuKJolwiLFwibmVzZWFyXCI6XCLipKhcIixcIm5lc2ltXCI6XCLiiYLMuFwiLFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIuKJq1wiLFwiTmVzdGVkTGVzc0xlc3NcIjpcIuKJqlwiLFwiTmV3TGluZVwiOlwiXFxuXCIsXCJuZXhpc3RcIjpcIuKIhFwiLFwibmV4aXN0c1wiOlwi4oiEXCIsXCJOZnJcIjpcIvCdlJFcIixcIm5mclwiOlwi8J2Uq1wiLFwibmdFXCI6XCLiiafMuFwiLFwibmdlXCI6XCLiibFcIixcIm5nZXFcIjpcIuKJsVwiLFwibmdlcXFcIjpcIuKJp8y4XCIsXCJuZ2Vxc2xhbnRcIjpcIuKpvsy4XCIsXCJuZ2VzXCI6XCLiqb7MuFwiLFwibkdnXCI6XCLii5nMuFwiLFwibmdzaW1cIjpcIuKJtVwiLFwibkd0XCI6XCLiiavig5JcIixcIm5ndFwiOlwi4omvXCIsXCJuZ3RyXCI6XCLiia9cIixcIm5HdHZcIjpcIuKJq8y4XCIsXCJuaGFyclwiOlwi4oauXCIsXCJuaEFyclwiOlwi4oeOXCIsXCJuaHBhclwiOlwi4quyXCIsXCJuaVwiOlwi4oiLXCIsXCJuaXNcIjpcIuKLvFwiLFwibmlzZFwiOlwi4ou6XCIsXCJuaXZcIjpcIuKIi1wiLFwiTkpjeVwiOlwi0IpcIixcIm5qY3lcIjpcItGaXCIsXCJubGFyclwiOlwi4oaaXCIsXCJubEFyclwiOlwi4oeNXCIsXCJubGRyXCI6XCLigKVcIixcIm5sRVwiOlwi4ommzLhcIixcIm5sZVwiOlwi4omwXCIsXCJubGVmdGFycm93XCI6XCLihppcIixcIm5MZWZ0YXJyb3dcIjpcIuKHjVwiLFwibmxlZnRyaWdodGFycm93XCI6XCLihq5cIixcIm5MZWZ0cmlnaHRhcnJvd1wiOlwi4oeOXCIsXCJubGVxXCI6XCLiibBcIixcIm5sZXFxXCI6XCLiiabMuFwiLFwibmxlcXNsYW50XCI6XCLiqb3MuFwiLFwibmxlc1wiOlwi4qm9zLhcIixcIm5sZXNzXCI6XCLiia5cIixcIm5MbFwiOlwi4ouYzLhcIixcIm5sc2ltXCI6XCLiibRcIixcIm5MdFwiOlwi4omq4oOSXCIsXCJubHRcIjpcIuKJrlwiLFwibmx0cmlcIjpcIuKLqlwiLFwibmx0cmllXCI6XCLii6xcIixcIm5MdHZcIjpcIuKJqsy4XCIsXCJubWlkXCI6XCLiiKRcIixcIk5vQnJlYWtcIjpcIuKBoFwiLFwiTm9uQnJlYWtpbmdTcGFjZVwiOlwiwqBcIixcIm5vcGZcIjpcIvCdlZ9cIixcIk5vcGZcIjpcIuKElVwiLFwiTm90XCI6XCLiq6xcIixcIm5vdFwiOlwiwqxcIixcIk5vdENvbmdydWVudFwiOlwi4omiXCIsXCJOb3RDdXBDYXBcIjpcIuKJrVwiLFwiTm90RG91YmxlVmVydGljYWxCYXJcIjpcIuKIplwiLFwiTm90RWxlbWVudFwiOlwi4oiJXCIsXCJOb3RFcXVhbFwiOlwi4omgXCIsXCJOb3RFcXVhbFRpbGRlXCI6XCLiiYLMuFwiLFwiTm90RXhpc3RzXCI6XCLiiIRcIixcIk5vdEdyZWF0ZXJcIjpcIuKJr1wiLFwiTm90R3JlYXRlckVxdWFsXCI6XCLiibFcIixcIk5vdEdyZWF0ZXJGdWxsRXF1YWxcIjpcIuKJp8y4XCIsXCJOb3RHcmVhdGVyR3JlYXRlclwiOlwi4omrzLhcIixcIk5vdEdyZWF0ZXJMZXNzXCI6XCLiiblcIixcIk5vdEdyZWF0ZXJTbGFudEVxdWFsXCI6XCLiqb7MuFwiLFwiTm90R3JlYXRlclRpbGRlXCI6XCLiibVcIixcIk5vdEh1bXBEb3duSHVtcFwiOlwi4omOzLhcIixcIk5vdEh1bXBFcXVhbFwiOlwi4omPzLhcIixcIm5vdGluXCI6XCLiiIlcIixcIm5vdGluZG90XCI6XCLii7XMuFwiLFwibm90aW5FXCI6XCLii7nMuFwiLFwibm90aW52YVwiOlwi4oiJXCIsXCJub3RpbnZiXCI6XCLii7dcIixcIm5vdGludmNcIjpcIuKLtlwiLFwiTm90TGVmdFRyaWFuZ2xlQmFyXCI6XCLip4/MuFwiLFwiTm90TGVmdFRyaWFuZ2xlXCI6XCLii6pcIixcIk5vdExlZnRUcmlhbmdsZUVxdWFsXCI6XCLii6xcIixcIk5vdExlc3NcIjpcIuKJrlwiLFwiTm90TGVzc0VxdWFsXCI6XCLiibBcIixcIk5vdExlc3NHcmVhdGVyXCI6XCLiibhcIixcIk5vdExlc3NMZXNzXCI6XCLiiarMuFwiLFwiTm90TGVzc1NsYW50RXF1YWxcIjpcIuKpvcy4XCIsXCJOb3RMZXNzVGlsZGVcIjpcIuKJtFwiLFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIuKqosy4XCIsXCJOb3ROZXN0ZWRMZXNzTGVzc1wiOlwi4qqhzLhcIixcIm5vdG5pXCI6XCLiiIxcIixcIm5vdG5pdmFcIjpcIuKIjFwiLFwibm90bml2YlwiOlwi4ou+XCIsXCJub3RuaXZjXCI6XCLii71cIixcIk5vdFByZWNlZGVzXCI6XCLiioBcIixcIk5vdFByZWNlZGVzRXF1YWxcIjpcIuKqr8y4XCIsXCJOb3RQcmVjZWRlc1NsYW50RXF1YWxcIjpcIuKLoFwiLFwiTm90UmV2ZXJzZUVsZW1lbnRcIjpcIuKIjFwiLFwiTm90UmlnaHRUcmlhbmdsZUJhclwiOlwi4qeQzLhcIixcIk5vdFJpZ2h0VHJpYW5nbGVcIjpcIuKLq1wiLFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsXCI6XCLii61cIixcIk5vdFNxdWFyZVN1YnNldFwiOlwi4oqPzLhcIixcIk5vdFNxdWFyZVN1YnNldEVxdWFsXCI6XCLii6JcIixcIk5vdFNxdWFyZVN1cGVyc2V0XCI6XCLiipDMuFwiLFwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwi4oujXCIsXCJOb3RTdWJzZXRcIjpcIuKKguKDklwiLFwiTm90U3Vic2V0RXF1YWxcIjpcIuKKiFwiLFwiTm90U3VjY2VlZHNcIjpcIuKKgVwiLFwiTm90U3VjY2VlZHNFcXVhbFwiOlwi4qqwzLhcIixcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwi4ouhXCIsXCJOb3RTdWNjZWVkc1RpbGRlXCI6XCLiib/MuFwiLFwiTm90U3VwZXJzZXRcIjpcIuKKg+KDklwiLFwiTm90U3VwZXJzZXRFcXVhbFwiOlwi4oqJXCIsXCJOb3RUaWxkZVwiOlwi4omBXCIsXCJOb3RUaWxkZUVxdWFsXCI6XCLiiYRcIixcIk5vdFRpbGRlRnVsbEVxdWFsXCI6XCLiiYdcIixcIk5vdFRpbGRlVGlsZGVcIjpcIuKJiVwiLFwiTm90VmVydGljYWxCYXJcIjpcIuKIpFwiLFwibnBhcmFsbGVsXCI6XCLiiKZcIixcIm5wYXJcIjpcIuKIplwiLFwibnBhcnNsXCI6XCLiq73ig6VcIixcIm5wYXJ0XCI6XCLiiILMuFwiLFwibnBvbGludFwiOlwi4qiUXCIsXCJucHJcIjpcIuKKgFwiLFwibnByY3VlXCI6XCLii6BcIixcIm5wcmVjXCI6XCLiioBcIixcIm5wcmVjZXFcIjpcIuKqr8y4XCIsXCJucHJlXCI6XCLiqq/MuFwiLFwibnJhcnJjXCI6XCLipLPMuFwiLFwibnJhcnJcIjpcIuKGm1wiLFwibnJBcnJcIjpcIuKHj1wiLFwibnJhcnJ3XCI6XCLihp3MuFwiLFwibnJpZ2h0YXJyb3dcIjpcIuKGm1wiLFwiblJpZ2h0YXJyb3dcIjpcIuKHj1wiLFwibnJ0cmlcIjpcIuKLq1wiLFwibnJ0cmllXCI6XCLii61cIixcIm5zY1wiOlwi4oqBXCIsXCJuc2NjdWVcIjpcIuKLoVwiLFwibnNjZVwiOlwi4qqwzLhcIixcIk5zY3JcIjpcIvCdkqlcIixcIm5zY3JcIjpcIvCdk4NcIixcIm5zaG9ydG1pZFwiOlwi4oikXCIsXCJuc2hvcnRwYXJhbGxlbFwiOlwi4oimXCIsXCJuc2ltXCI6XCLiiYFcIixcIm5zaW1lXCI6XCLiiYRcIixcIm5zaW1lcVwiOlwi4omEXCIsXCJuc21pZFwiOlwi4oikXCIsXCJuc3BhclwiOlwi4oimXCIsXCJuc3FzdWJlXCI6XCLii6JcIixcIm5zcXN1cGVcIjpcIuKLo1wiLFwibnN1YlwiOlwi4oqEXCIsXCJuc3ViRVwiOlwi4quFzLhcIixcIm5zdWJlXCI6XCLiiohcIixcIm5zdWJzZXRcIjpcIuKKguKDklwiLFwibnN1YnNldGVxXCI6XCLiiohcIixcIm5zdWJzZXRlcXFcIjpcIuKrhcy4XCIsXCJuc3VjY1wiOlwi4oqBXCIsXCJuc3VjY2VxXCI6XCLiqrDMuFwiLFwibnN1cFwiOlwi4oqFXCIsXCJuc3VwRVwiOlwi4quGzLhcIixcIm5zdXBlXCI6XCLiiolcIixcIm5zdXBzZXRcIjpcIuKKg+KDklwiLFwibnN1cHNldGVxXCI6XCLiiolcIixcIm5zdXBzZXRlcXFcIjpcIuKrhsy4XCIsXCJudGdsXCI6XCLiiblcIixcIk50aWxkZVwiOlwiw5FcIixcIm50aWxkZVwiOlwiw7FcIixcIm50bGdcIjpcIuKJuFwiLFwibnRyaWFuZ2xlbGVmdFwiOlwi4ouqXCIsXCJudHJpYW5nbGVsZWZ0ZXFcIjpcIuKLrFwiLFwibnRyaWFuZ2xlcmlnaHRcIjpcIuKLq1wiLFwibnRyaWFuZ2xlcmlnaHRlcVwiOlwi4outXCIsXCJOdVwiOlwizp1cIixcIm51XCI6XCLOvVwiLFwibnVtXCI6XCIjXCIsXCJudW1lcm9cIjpcIuKEllwiLFwibnVtc3BcIjpcIuKAh1wiLFwibnZhcFwiOlwi4omN4oOSXCIsXCJudmRhc2hcIjpcIuKKrFwiLFwibnZEYXNoXCI6XCLiiq1cIixcIm5WZGFzaFwiOlwi4oquXCIsXCJuVkRhc2hcIjpcIuKKr1wiLFwibnZnZVwiOlwi4oml4oOSXCIsXCJudmd0XCI6XCI+4oOSXCIsXCJudkhhcnJcIjpcIuKkhFwiLFwibnZpbmZpblwiOlwi4qeeXCIsXCJudmxBcnJcIjpcIuKkglwiLFwibnZsZVwiOlwi4omk4oOSXCIsXCJudmx0XCI6XCI84oOSXCIsXCJudmx0cmllXCI6XCLiirTig5JcIixcIm52ckFyclwiOlwi4qSDXCIsXCJudnJ0cmllXCI6XCLiirXig5JcIixcIm52c2ltXCI6XCLiiLzig5JcIixcIm53YXJoa1wiOlwi4qSjXCIsXCJud2FyclwiOlwi4oaWXCIsXCJud0FyclwiOlwi4oeWXCIsXCJud2Fycm93XCI6XCLihpZcIixcIm53bmVhclwiOlwi4qSnXCIsXCJPYWN1dGVcIjpcIsOTXCIsXCJvYWN1dGVcIjpcIsOzXCIsXCJvYXN0XCI6XCLiiptcIixcIk9jaXJjXCI6XCLDlFwiLFwib2NpcmNcIjpcIsO0XCIsXCJvY2lyXCI6XCLiippcIixcIk9jeVwiOlwi0J5cIixcIm9jeVwiOlwi0L5cIixcIm9kYXNoXCI6XCLiip1cIixcIk9kYmxhY1wiOlwixZBcIixcIm9kYmxhY1wiOlwixZFcIixcIm9kaXZcIjpcIuKouFwiLFwib2RvdFwiOlwi4oqZXCIsXCJvZHNvbGRcIjpcIuKmvFwiLFwiT0VsaWdcIjpcIsWSXCIsXCJvZWxpZ1wiOlwixZNcIixcIm9mY2lyXCI6XCLipr9cIixcIk9mclwiOlwi8J2UklwiLFwib2ZyXCI6XCLwnZSsXCIsXCJvZ29uXCI6XCLLm1wiLFwiT2dyYXZlXCI6XCLDklwiLFwib2dyYXZlXCI6XCLDslwiLFwib2d0XCI6XCLip4FcIixcIm9oYmFyXCI6XCLiprVcIixcIm9obVwiOlwizqlcIixcIm9pbnRcIjpcIuKIrlwiLFwib2xhcnJcIjpcIuKGulwiLFwib2xjaXJcIjpcIuKmvlwiLFwib2xjcm9zc1wiOlwi4qa7XCIsXCJvbGluZVwiOlwi4oC+XCIsXCJvbHRcIjpcIuKngFwiLFwiT21hY3JcIjpcIsWMXCIsXCJvbWFjclwiOlwixY1cIixcIk9tZWdhXCI6XCLOqVwiLFwib21lZ2FcIjpcIs+JXCIsXCJPbWljcm9uXCI6XCLOn1wiLFwib21pY3JvblwiOlwizr9cIixcIm9taWRcIjpcIuKmtlwiLFwib21pbnVzXCI6XCLiipZcIixcIk9vcGZcIjpcIvCdlYZcIixcIm9vcGZcIjpcIvCdlaBcIixcIm9wYXJcIjpcIuKmt1wiLFwiT3BlbkN1cmx5RG91YmxlUXVvdGVcIjpcIuKAnFwiLFwiT3BlbkN1cmx5UXVvdGVcIjpcIuKAmFwiLFwib3BlcnBcIjpcIuKmuVwiLFwib3BsdXNcIjpcIuKKlVwiLFwib3JhcnJcIjpcIuKGu1wiLFwiT3JcIjpcIuKplFwiLFwib3JcIjpcIuKIqFwiLFwib3JkXCI6XCLiqZ1cIixcIm9yZGVyXCI6XCLihLRcIixcIm9yZGVyb2ZcIjpcIuKEtFwiLFwib3JkZlwiOlwiwqpcIixcIm9yZG1cIjpcIsK6XCIsXCJvcmlnb2ZcIjpcIuKKtlwiLFwib3JvclwiOlwi4qmWXCIsXCJvcnNsb3BlXCI6XCLiqZdcIixcIm9ydlwiOlwi4qmbXCIsXCJvU1wiOlwi4pOIXCIsXCJPc2NyXCI6XCLwnZKqXCIsXCJvc2NyXCI6XCLihLRcIixcIk9zbGFzaFwiOlwiw5hcIixcIm9zbGFzaFwiOlwiw7hcIixcIm9zb2xcIjpcIuKKmFwiLFwiT3RpbGRlXCI6XCLDlVwiLFwib3RpbGRlXCI6XCLDtVwiLFwib3RpbWVzYXNcIjpcIuKotlwiLFwiT3RpbWVzXCI6XCLiqLdcIixcIm90aW1lc1wiOlwi4oqXXCIsXCJPdW1sXCI6XCLDllwiLFwib3VtbFwiOlwiw7ZcIixcIm92YmFyXCI6XCLijL1cIixcIk92ZXJCYXJcIjpcIuKAvlwiLFwiT3ZlckJyYWNlXCI6XCLij55cIixcIk92ZXJCcmFja2V0XCI6XCLijrRcIixcIk92ZXJQYXJlbnRoZXNpc1wiOlwi4o+cXCIsXCJwYXJhXCI6XCLCtlwiLFwicGFyYWxsZWxcIjpcIuKIpVwiLFwicGFyXCI6XCLiiKVcIixcInBhcnNpbVwiOlwi4quzXCIsXCJwYXJzbFwiOlwi4qu9XCIsXCJwYXJ0XCI6XCLiiIJcIixcIlBhcnRpYWxEXCI6XCLiiIJcIixcIlBjeVwiOlwi0J9cIixcInBjeVwiOlwi0L9cIixcInBlcmNudFwiOlwiJVwiLFwicGVyaW9kXCI6XCIuXCIsXCJwZXJtaWxcIjpcIuKAsFwiLFwicGVycFwiOlwi4oqlXCIsXCJwZXJ0ZW5rXCI6XCLigLFcIixcIlBmclwiOlwi8J2Uk1wiLFwicGZyXCI6XCLwnZStXCIsXCJQaGlcIjpcIs6mXCIsXCJwaGlcIjpcIs+GXCIsXCJwaGl2XCI6XCLPlVwiLFwicGhtbWF0XCI6XCLihLNcIixcInBob25lXCI6XCLimI5cIixcIlBpXCI6XCLOoFwiLFwicGlcIjpcIs+AXCIsXCJwaXRjaGZvcmtcIjpcIuKLlFwiLFwicGl2XCI6XCLPllwiLFwicGxhbmNrXCI6XCLihI9cIixcInBsYW5ja2hcIjpcIuKEjlwiLFwicGxhbmt2XCI6XCLihI9cIixcInBsdXNhY2lyXCI6XCLiqKNcIixcInBsdXNiXCI6XCLiip5cIixcInBsdXNjaXJcIjpcIuKoolwiLFwicGx1c1wiOlwiK1wiLFwicGx1c2RvXCI6XCLiiJRcIixcInBsdXNkdVwiOlwi4qilXCIsXCJwbHVzZVwiOlwi4qmyXCIsXCJQbHVzTWludXNcIjpcIsKxXCIsXCJwbHVzbW5cIjpcIsKxXCIsXCJwbHVzc2ltXCI6XCLiqKZcIixcInBsdXN0d29cIjpcIuKop1wiLFwicG1cIjpcIsKxXCIsXCJQb2luY2FyZXBsYW5lXCI6XCLihIxcIixcInBvaW50aW50XCI6XCLiqJVcIixcInBvcGZcIjpcIvCdlaFcIixcIlBvcGZcIjpcIuKEmVwiLFwicG91bmRcIjpcIsKjXCIsXCJwcmFwXCI6XCLiqrdcIixcIlByXCI6XCLiqrtcIixcInByXCI6XCLiibpcIixcInByY3VlXCI6XCLiibxcIixcInByZWNhcHByb3hcIjpcIuKqt1wiLFwicHJlY1wiOlwi4om6XCIsXCJwcmVjY3VybHllcVwiOlwi4om8XCIsXCJQcmVjZWRlc1wiOlwi4om6XCIsXCJQcmVjZWRlc0VxdWFsXCI6XCLiqq9cIixcIlByZWNlZGVzU2xhbnRFcXVhbFwiOlwi4om8XCIsXCJQcmVjZWRlc1RpbGRlXCI6XCLiib5cIixcInByZWNlcVwiOlwi4qqvXCIsXCJwcmVjbmFwcHJveFwiOlwi4qq5XCIsXCJwcmVjbmVxcVwiOlwi4qq1XCIsXCJwcmVjbnNpbVwiOlwi4ouoXCIsXCJwcmVcIjpcIuKqr1wiLFwicHJFXCI6XCLiqrNcIixcInByZWNzaW1cIjpcIuKJvlwiLFwicHJpbWVcIjpcIuKAslwiLFwiUHJpbWVcIjpcIuKAs1wiLFwicHJpbWVzXCI6XCLihJlcIixcInBybmFwXCI6XCLiqrlcIixcInBybkVcIjpcIuKqtVwiLFwicHJuc2ltXCI6XCLii6hcIixcInByb2RcIjpcIuKIj1wiLFwiUHJvZHVjdFwiOlwi4oiPXCIsXCJwcm9mYWxhclwiOlwi4oyuXCIsXCJwcm9mbGluZVwiOlwi4oySXCIsXCJwcm9mc3VyZlwiOlwi4oyTXCIsXCJwcm9wXCI6XCLiiJ1cIixcIlByb3BvcnRpb25hbFwiOlwi4oidXCIsXCJQcm9wb3J0aW9uXCI6XCLiiLdcIixcInByb3B0b1wiOlwi4oidXCIsXCJwcnNpbVwiOlwi4om+XCIsXCJwcnVyZWxcIjpcIuKKsFwiLFwiUHNjclwiOlwi8J2Sq1wiLFwicHNjclwiOlwi8J2ThVwiLFwiUHNpXCI6XCLOqFwiLFwicHNpXCI6XCLPiFwiLFwicHVuY3NwXCI6XCLigIhcIixcIlFmclwiOlwi8J2UlFwiLFwicWZyXCI6XCLwnZSuXCIsXCJxaW50XCI6XCLiqIxcIixcInFvcGZcIjpcIvCdlaJcIixcIlFvcGZcIjpcIuKEmlwiLFwicXByaW1lXCI6XCLigZdcIixcIlFzY3JcIjpcIvCdkqxcIixcInFzY3JcIjpcIvCdk4ZcIixcInF1YXRlcm5pb25zXCI6XCLihI1cIixcInF1YXRpbnRcIjpcIuKollwiLFwicXVlc3RcIjpcIj9cIixcInF1ZXN0ZXFcIjpcIuKJn1wiLFwicXVvdFwiOlwiXFxcIlwiLFwiUVVPVFwiOlwiXFxcIlwiLFwickFhcnJcIjpcIuKHm1wiLFwicmFjZVwiOlwi4oi9zLFcIixcIlJhY3V0ZVwiOlwixZRcIixcInJhY3V0ZVwiOlwixZVcIixcInJhZGljXCI6XCLiiJpcIixcInJhZW1wdHl2XCI6XCLiprNcIixcInJhbmdcIjpcIuKfqVwiLFwiUmFuZ1wiOlwi4p+rXCIsXCJyYW5nZFwiOlwi4qaSXCIsXCJyYW5nZVwiOlwi4qalXCIsXCJyYW5nbGVcIjpcIuKfqVwiLFwicmFxdW9cIjpcIsK7XCIsXCJyYXJyYXBcIjpcIuKltVwiLFwicmFycmJcIjpcIuKHpVwiLFwicmFycmJmc1wiOlwi4qSgXCIsXCJyYXJyY1wiOlwi4qSzXCIsXCJyYXJyXCI6XCLihpJcIixcIlJhcnJcIjpcIuKGoFwiLFwickFyclwiOlwi4oeSXCIsXCJyYXJyZnNcIjpcIuKknlwiLFwicmFycmhrXCI6XCLihqpcIixcInJhcnJscFwiOlwi4oasXCIsXCJyYXJycGxcIjpcIuKlhVwiLFwicmFycnNpbVwiOlwi4qW0XCIsXCJSYXJydGxcIjpcIuKkllwiLFwicmFycnRsXCI6XCLihqNcIixcInJhcnJ3XCI6XCLihp1cIixcInJhdGFpbFwiOlwi4qSaXCIsXCJyQXRhaWxcIjpcIuKknFwiLFwicmF0aW9cIjpcIuKItlwiLFwicmF0aW9uYWxzXCI6XCLihJpcIixcInJiYXJyXCI6XCLipI1cIixcInJCYXJyXCI6XCLipI9cIixcIlJCYXJyXCI6XCLipJBcIixcInJiYnJrXCI6XCLinbNcIixcInJicmFjZVwiOlwifVwiLFwicmJyYWNrXCI6XCJdXCIsXCJyYnJrZVwiOlwi4qaMXCIsXCJyYnJrc2xkXCI6XCLipo5cIixcInJicmtzbHVcIjpcIuKmkFwiLFwiUmNhcm9uXCI6XCLFmFwiLFwicmNhcm9uXCI6XCLFmVwiLFwiUmNlZGlsXCI6XCLFllwiLFwicmNlZGlsXCI6XCLFl1wiLFwicmNlaWxcIjpcIuKMiVwiLFwicmN1YlwiOlwifVwiLFwiUmN5XCI6XCLQoFwiLFwicmN5XCI6XCLRgFwiLFwicmRjYVwiOlwi4qS3XCIsXCJyZGxkaGFyXCI6XCLipalcIixcInJkcXVvXCI6XCLigJ1cIixcInJkcXVvclwiOlwi4oCdXCIsXCJyZHNoXCI6XCLihrNcIixcInJlYWxcIjpcIuKEnFwiLFwicmVhbGluZVwiOlwi4oSbXCIsXCJyZWFscGFydFwiOlwi4oScXCIsXCJyZWFsc1wiOlwi4oSdXCIsXCJSZVwiOlwi4oScXCIsXCJyZWN0XCI6XCLilq1cIixcInJlZ1wiOlwiwq5cIixcIlJFR1wiOlwiwq5cIixcIlJldmVyc2VFbGVtZW50XCI6XCLiiItcIixcIlJldmVyc2VFcXVpbGlicml1bVwiOlwi4oeLXCIsXCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOlwi4qWvXCIsXCJyZmlzaHRcIjpcIuKlvVwiLFwicmZsb29yXCI6XCLijItcIixcInJmclwiOlwi8J2Ur1wiLFwiUmZyXCI6XCLihJxcIixcInJIYXJcIjpcIuKlpFwiLFwicmhhcmRcIjpcIuKHgVwiLFwicmhhcnVcIjpcIuKHgFwiLFwicmhhcnVsXCI6XCLipaxcIixcIlJob1wiOlwizqFcIixcInJob1wiOlwiz4FcIixcInJob3ZcIjpcIs+xXCIsXCJSaWdodEFuZ2xlQnJhY2tldFwiOlwi4p+pXCIsXCJSaWdodEFycm93QmFyXCI6XCLih6VcIixcInJpZ2h0YXJyb3dcIjpcIuKGklwiLFwiUmlnaHRBcnJvd1wiOlwi4oaSXCIsXCJSaWdodGFycm93XCI6XCLih5JcIixcIlJpZ2h0QXJyb3dMZWZ0QXJyb3dcIjpcIuKHhFwiLFwicmlnaHRhcnJvd3RhaWxcIjpcIuKGo1wiLFwiUmlnaHRDZWlsaW5nXCI6XCLijIlcIixcIlJpZ2h0RG91YmxlQnJhY2tldFwiOlwi4p+nXCIsXCJSaWdodERvd25UZWVWZWN0b3JcIjpcIuKlnVwiLFwiUmlnaHREb3duVmVjdG9yQmFyXCI6XCLipZVcIixcIlJpZ2h0RG93blZlY3RvclwiOlwi4oeCXCIsXCJSaWdodEZsb29yXCI6XCLijItcIixcInJpZ2h0aGFycG9vbmRvd25cIjpcIuKHgVwiLFwicmlnaHRoYXJwb29udXBcIjpcIuKHgFwiLFwicmlnaHRsZWZ0YXJyb3dzXCI6XCLih4RcIixcInJpZ2h0bGVmdGhhcnBvb25zXCI6XCLih4xcIixcInJpZ2h0cmlnaHRhcnJvd3NcIjpcIuKHiVwiLFwicmlnaHRzcXVpZ2Fycm93XCI6XCLihp1cIixcIlJpZ2h0VGVlQXJyb3dcIjpcIuKGplwiLFwiUmlnaHRUZWVcIjpcIuKKolwiLFwiUmlnaHRUZWVWZWN0b3JcIjpcIuKlm1wiLFwicmlnaHR0aHJlZXRpbWVzXCI6XCLii4xcIixcIlJpZ2h0VHJpYW5nbGVCYXJcIjpcIuKnkFwiLFwiUmlnaHRUcmlhbmdsZVwiOlwi4oqzXCIsXCJSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIuKKtVwiLFwiUmlnaHRVcERvd25WZWN0b3JcIjpcIuKlj1wiLFwiUmlnaHRVcFRlZVZlY3RvclwiOlwi4qWcXCIsXCJSaWdodFVwVmVjdG9yQmFyXCI6XCLipZRcIixcIlJpZ2h0VXBWZWN0b3JcIjpcIuKGvlwiLFwiUmlnaHRWZWN0b3JCYXJcIjpcIuKlk1wiLFwiUmlnaHRWZWN0b3JcIjpcIuKHgFwiLFwicmluZ1wiOlwiy5pcIixcInJpc2luZ2RvdHNlcVwiOlwi4omTXCIsXCJybGFyclwiOlwi4oeEXCIsXCJybGhhclwiOlwi4oeMXCIsXCJybG1cIjpcIuKAj1wiLFwicm1vdXN0YWNoZVwiOlwi4o6xXCIsXCJybW91c3RcIjpcIuKOsVwiLFwicm5taWRcIjpcIuKrrlwiLFwicm9hbmdcIjpcIuKfrVwiLFwicm9hcnJcIjpcIuKHvlwiLFwicm9icmtcIjpcIuKfp1wiLFwicm9wYXJcIjpcIuKmhlwiLFwicm9wZlwiOlwi8J2Vo1wiLFwiUm9wZlwiOlwi4oSdXCIsXCJyb3BsdXNcIjpcIuKorlwiLFwicm90aW1lc1wiOlwi4qi1XCIsXCJSb3VuZEltcGxpZXNcIjpcIuKlsFwiLFwicnBhclwiOlwiKVwiLFwicnBhcmd0XCI6XCLippRcIixcInJwcG9saW50XCI6XCLiqJJcIixcInJyYXJyXCI6XCLih4lcIixcIlJyaWdodGFycm93XCI6XCLih5tcIixcInJzYXF1b1wiOlwi4oC6XCIsXCJyc2NyXCI6XCLwnZOHXCIsXCJSc2NyXCI6XCLihJtcIixcInJzaFwiOlwi4oaxXCIsXCJSc2hcIjpcIuKGsVwiLFwicnNxYlwiOlwiXVwiLFwicnNxdW9cIjpcIuKAmVwiLFwicnNxdW9yXCI6XCLigJlcIixcInJ0aHJlZVwiOlwi4ouMXCIsXCJydGltZXNcIjpcIuKLilwiLFwicnRyaVwiOlwi4pa5XCIsXCJydHJpZVwiOlwi4oq1XCIsXCJydHJpZlwiOlwi4pa4XCIsXCJydHJpbHRyaVwiOlwi4qeOXCIsXCJSdWxlRGVsYXllZFwiOlwi4qe0XCIsXCJydWx1aGFyXCI6XCLipahcIixcInJ4XCI6XCLihJ5cIixcIlNhY3V0ZVwiOlwixZpcIixcInNhY3V0ZVwiOlwixZtcIixcInNicXVvXCI6XCLigJpcIixcInNjYXBcIjpcIuKquFwiLFwiU2Nhcm9uXCI6XCLFoFwiLFwic2Nhcm9uXCI6XCLFoVwiLFwiU2NcIjpcIuKqvFwiLFwic2NcIjpcIuKJu1wiLFwic2NjdWVcIjpcIuKJvVwiLFwic2NlXCI6XCLiqrBcIixcInNjRVwiOlwi4qq0XCIsXCJTY2VkaWxcIjpcIsWeXCIsXCJzY2VkaWxcIjpcIsWfXCIsXCJTY2lyY1wiOlwixZxcIixcInNjaXJjXCI6XCLFnVwiLFwic2NuYXBcIjpcIuKqulwiLFwic2NuRVwiOlwi4qq2XCIsXCJzY25zaW1cIjpcIuKLqVwiLFwic2Nwb2xpbnRcIjpcIuKok1wiLFwic2NzaW1cIjpcIuKJv1wiLFwiU2N5XCI6XCLQoVwiLFwic2N5XCI6XCLRgVwiLFwic2RvdGJcIjpcIuKKoVwiLFwic2RvdFwiOlwi4ouFXCIsXCJzZG90ZVwiOlwi4qmmXCIsXCJzZWFyaGtcIjpcIuKkpVwiLFwic2VhcnJcIjpcIuKGmFwiLFwic2VBcnJcIjpcIuKHmFwiLFwic2VhcnJvd1wiOlwi4oaYXCIsXCJzZWN0XCI6XCLCp1wiLFwic2VtaVwiOlwiO1wiLFwic2Vzd2FyXCI6XCLipKlcIixcInNldG1pbnVzXCI6XCLiiJZcIixcInNldG1uXCI6XCLiiJZcIixcInNleHRcIjpcIuKctlwiLFwiU2ZyXCI6XCLwnZSWXCIsXCJzZnJcIjpcIvCdlLBcIixcInNmcm93blwiOlwi4oyiXCIsXCJzaGFycFwiOlwi4pmvXCIsXCJTSENIY3lcIjpcItCpXCIsXCJzaGNoY3lcIjpcItGJXCIsXCJTSGN5XCI6XCLQqFwiLFwic2hjeVwiOlwi0YhcIixcIlNob3J0RG93bkFycm93XCI6XCLihpNcIixcIlNob3J0TGVmdEFycm93XCI6XCLihpBcIixcInNob3J0bWlkXCI6XCLiiKNcIixcInNob3J0cGFyYWxsZWxcIjpcIuKIpVwiLFwiU2hvcnRSaWdodEFycm93XCI6XCLihpJcIixcIlNob3J0VXBBcnJvd1wiOlwi4oaRXCIsXCJzaHlcIjpcIsKtXCIsXCJTaWdtYVwiOlwizqNcIixcInNpZ21hXCI6XCLPg1wiLFwic2lnbWFmXCI6XCLPglwiLFwic2lnbWF2XCI6XCLPglwiLFwic2ltXCI6XCLiiLxcIixcInNpbWRvdFwiOlwi4qmqXCIsXCJzaW1lXCI6XCLiiYNcIixcInNpbWVxXCI6XCLiiYNcIixcInNpbWdcIjpcIuKqnlwiLFwic2ltZ0VcIjpcIuKqoFwiLFwic2ltbFwiOlwi4qqdXCIsXCJzaW1sRVwiOlwi4qqfXCIsXCJzaW1uZVwiOlwi4omGXCIsXCJzaW1wbHVzXCI6XCLiqKRcIixcInNpbXJhcnJcIjpcIuKlslwiLFwic2xhcnJcIjpcIuKGkFwiLFwiU21hbGxDaXJjbGVcIjpcIuKImFwiLFwic21hbGxzZXRtaW51c1wiOlwi4oiWXCIsXCJzbWFzaHBcIjpcIuKos1wiLFwic21lcGFyc2xcIjpcIuKnpFwiLFwic21pZFwiOlwi4oijXCIsXCJzbWlsZVwiOlwi4oyjXCIsXCJzbXRcIjpcIuKqqlwiLFwic210ZVwiOlwi4qqsXCIsXCJzbXRlc1wiOlwi4qqs77iAXCIsXCJTT0ZUY3lcIjpcItCsXCIsXCJzb2Z0Y3lcIjpcItGMXCIsXCJzb2xiYXJcIjpcIuKMv1wiLFwic29sYlwiOlwi4qeEXCIsXCJzb2xcIjpcIi9cIixcIlNvcGZcIjpcIvCdlYpcIixcInNvcGZcIjpcIvCdlaRcIixcInNwYWRlc1wiOlwi4pmgXCIsXCJzcGFkZXN1aXRcIjpcIuKZoFwiLFwic3BhclwiOlwi4oilXCIsXCJzcWNhcFwiOlwi4oqTXCIsXCJzcWNhcHNcIjpcIuKKk++4gFwiLFwic3FjdXBcIjpcIuKKlFwiLFwic3FjdXBzXCI6XCLiipTvuIBcIixcIlNxcnRcIjpcIuKImlwiLFwic3FzdWJcIjpcIuKKj1wiLFwic3FzdWJlXCI6XCLiipFcIixcInNxc3Vic2V0XCI6XCLiio9cIixcInNxc3Vic2V0ZXFcIjpcIuKKkVwiLFwic3FzdXBcIjpcIuKKkFwiLFwic3FzdXBlXCI6XCLiipJcIixcInNxc3Vwc2V0XCI6XCLiipBcIixcInNxc3Vwc2V0ZXFcIjpcIuKKklwiLFwic3F1YXJlXCI6XCLilqFcIixcIlNxdWFyZVwiOlwi4pahXCIsXCJTcXVhcmVJbnRlcnNlY3Rpb25cIjpcIuKKk1wiLFwiU3F1YXJlU3Vic2V0XCI6XCLiio9cIixcIlNxdWFyZVN1YnNldEVxdWFsXCI6XCLiipFcIixcIlNxdWFyZVN1cGVyc2V0XCI6XCLiipBcIixcIlNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIuKKklwiLFwiU3F1YXJlVW5pb25cIjpcIuKKlFwiLFwic3F1YXJmXCI6XCLilqpcIixcInNxdVwiOlwi4pahXCIsXCJzcXVmXCI6XCLilqpcIixcInNyYXJyXCI6XCLihpJcIixcIlNzY3JcIjpcIvCdkq5cIixcInNzY3JcIjpcIvCdk4hcIixcInNzZXRtblwiOlwi4oiWXCIsXCJzc21pbGVcIjpcIuKMo1wiLFwic3N0YXJmXCI6XCLii4ZcIixcIlN0YXJcIjpcIuKLhlwiLFwic3RhclwiOlwi4piGXCIsXCJzdGFyZlwiOlwi4piFXCIsXCJzdHJhaWdodGVwc2lsb25cIjpcIs+1XCIsXCJzdHJhaWdodHBoaVwiOlwiz5VcIixcInN0cm5zXCI6XCLCr1wiLFwic3ViXCI6XCLiioJcIixcIlN1YlwiOlwi4ouQXCIsXCJzdWJkb3RcIjpcIuKqvVwiLFwic3ViRVwiOlwi4quFXCIsXCJzdWJlXCI6XCLiioZcIixcInN1YmVkb3RcIjpcIuKrg1wiLFwic3VibXVsdFwiOlwi4quBXCIsXCJzdWJuRVwiOlwi4quLXCIsXCJzdWJuZVwiOlwi4oqKXCIsXCJzdWJwbHVzXCI6XCLiqr9cIixcInN1YnJhcnJcIjpcIuKluVwiLFwic3Vic2V0XCI6XCLiioJcIixcIlN1YnNldFwiOlwi4ouQXCIsXCJzdWJzZXRlcVwiOlwi4oqGXCIsXCJzdWJzZXRlcXFcIjpcIuKrhVwiLFwiU3Vic2V0RXF1YWxcIjpcIuKKhlwiLFwic3Vic2V0bmVxXCI6XCLiiopcIixcInN1YnNldG5lcXFcIjpcIuKri1wiLFwic3Vic2ltXCI6XCLiq4dcIixcInN1YnN1YlwiOlwi4quVXCIsXCJzdWJzdXBcIjpcIuKrk1wiLFwic3VjY2FwcHJveFwiOlwi4qq4XCIsXCJzdWNjXCI6XCLiibtcIixcInN1Y2NjdXJseWVxXCI6XCLiib1cIixcIlN1Y2NlZWRzXCI6XCLiibtcIixcIlN1Y2NlZWRzRXF1YWxcIjpcIuKqsFwiLFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6XCLiib1cIixcIlN1Y2NlZWRzVGlsZGVcIjpcIuKJv1wiLFwic3VjY2VxXCI6XCLiqrBcIixcInN1Y2NuYXBwcm94XCI6XCLiqrpcIixcInN1Y2NuZXFxXCI6XCLiqrZcIixcInN1Y2Nuc2ltXCI6XCLii6lcIixcInN1Y2NzaW1cIjpcIuKJv1wiLFwiU3VjaFRoYXRcIjpcIuKIi1wiLFwic3VtXCI6XCLiiJFcIixcIlN1bVwiOlwi4oiRXCIsXCJzdW5nXCI6XCLimapcIixcInN1cDFcIjpcIsK5XCIsXCJzdXAyXCI6XCLCslwiLFwic3VwM1wiOlwiwrNcIixcInN1cFwiOlwi4oqDXCIsXCJTdXBcIjpcIuKLkVwiLFwic3VwZG90XCI6XCLiqr5cIixcInN1cGRzdWJcIjpcIuKrmFwiLFwic3VwRVwiOlwi4quGXCIsXCJzdXBlXCI6XCLiiodcIixcInN1cGVkb3RcIjpcIuKrhFwiLFwiU3VwZXJzZXRcIjpcIuKKg1wiLFwiU3VwZXJzZXRFcXVhbFwiOlwi4oqHXCIsXCJzdXBoc29sXCI6XCLin4lcIixcInN1cGhzdWJcIjpcIuKrl1wiLFwic3VwbGFyclwiOlwi4qW7XCIsXCJzdXBtdWx0XCI6XCLiq4JcIixcInN1cG5FXCI6XCLiq4xcIixcInN1cG5lXCI6XCLiiotcIixcInN1cHBsdXNcIjpcIuKrgFwiLFwic3Vwc2V0XCI6XCLiioNcIixcIlN1cHNldFwiOlwi4ouRXCIsXCJzdXBzZXRlcVwiOlwi4oqHXCIsXCJzdXBzZXRlcXFcIjpcIuKrhlwiLFwic3Vwc2V0bmVxXCI6XCLiiotcIixcInN1cHNldG5lcXFcIjpcIuKrjFwiLFwic3Vwc2ltXCI6XCLiq4hcIixcInN1cHN1YlwiOlwi4quUXCIsXCJzdXBzdXBcIjpcIuKrllwiLFwic3dhcmhrXCI6XCLipKZcIixcInN3YXJyXCI6XCLihplcIixcInN3QXJyXCI6XCLih5lcIixcInN3YXJyb3dcIjpcIuKGmVwiLFwic3dud2FyXCI6XCLipKpcIixcInN6bGlnXCI6XCLDn1wiLFwiVGFiXCI6XCJcXHRcIixcInRhcmdldFwiOlwi4oyWXCIsXCJUYXVcIjpcIs6kXCIsXCJ0YXVcIjpcIs+EXCIsXCJ0YnJrXCI6XCLijrRcIixcIlRjYXJvblwiOlwixaRcIixcInRjYXJvblwiOlwixaVcIixcIlRjZWRpbFwiOlwixaJcIixcInRjZWRpbFwiOlwixaNcIixcIlRjeVwiOlwi0KJcIixcInRjeVwiOlwi0YJcIixcInRkb3RcIjpcIuKDm1wiLFwidGVscmVjXCI6XCLijJVcIixcIlRmclwiOlwi8J2Ul1wiLFwidGZyXCI6XCLwnZSxXCIsXCJ0aGVyZTRcIjpcIuKItFwiLFwidGhlcmVmb3JlXCI6XCLiiLRcIixcIlRoZXJlZm9yZVwiOlwi4oi0XCIsXCJUaGV0YVwiOlwizphcIixcInRoZXRhXCI6XCLOuFwiLFwidGhldGFzeW1cIjpcIs+RXCIsXCJ0aGV0YXZcIjpcIs+RXCIsXCJ0aGlja2FwcHJveFwiOlwi4omIXCIsXCJ0aGlja3NpbVwiOlwi4oi8XCIsXCJUaGlja1NwYWNlXCI6XCLigZ/igIpcIixcIlRoaW5TcGFjZVwiOlwi4oCJXCIsXCJ0aGluc3BcIjpcIuKAiVwiLFwidGhrYXBcIjpcIuKJiFwiLFwidGhrc2ltXCI6XCLiiLxcIixcIlRIT1JOXCI6XCLDnlwiLFwidGhvcm5cIjpcIsO+XCIsXCJ0aWxkZVwiOlwiy5xcIixcIlRpbGRlXCI6XCLiiLxcIixcIlRpbGRlRXF1YWxcIjpcIuKJg1wiLFwiVGlsZGVGdWxsRXF1YWxcIjpcIuKJhVwiLFwiVGlsZGVUaWxkZVwiOlwi4omIXCIsXCJ0aW1lc2JhclwiOlwi4qixXCIsXCJ0aW1lc2JcIjpcIuKKoFwiLFwidGltZXNcIjpcIsOXXCIsXCJ0aW1lc2RcIjpcIuKosFwiLFwidGludFwiOlwi4oitXCIsXCJ0b2VhXCI6XCLipKhcIixcInRvcGJvdFwiOlwi4oy2XCIsXCJ0b3BjaXJcIjpcIuKrsVwiLFwidG9wXCI6XCLiiqRcIixcIlRvcGZcIjpcIvCdlYtcIixcInRvcGZcIjpcIvCdlaVcIixcInRvcGZvcmtcIjpcIuKrmlwiLFwidG9zYVwiOlwi4qSpXCIsXCJ0cHJpbWVcIjpcIuKAtFwiLFwidHJhZGVcIjpcIuKEolwiLFwiVFJBREVcIjpcIuKEolwiLFwidHJpYW5nbGVcIjpcIuKWtVwiLFwidHJpYW5nbGVkb3duXCI6XCLilr9cIixcInRyaWFuZ2xlbGVmdFwiOlwi4peDXCIsXCJ0cmlhbmdsZWxlZnRlcVwiOlwi4oq0XCIsXCJ0cmlhbmdsZXFcIjpcIuKJnFwiLFwidHJpYW5nbGVyaWdodFwiOlwi4pa5XCIsXCJ0cmlhbmdsZXJpZ2h0ZXFcIjpcIuKKtVwiLFwidHJpZG90XCI6XCLil6xcIixcInRyaWVcIjpcIuKJnFwiLFwidHJpbWludXNcIjpcIuKoulwiLFwiVHJpcGxlRG90XCI6XCLig5tcIixcInRyaXBsdXNcIjpcIuKouVwiLFwidHJpc2JcIjpcIuKnjVwiLFwidHJpdGltZVwiOlwi4qi7XCIsXCJ0cnBleml1bVwiOlwi4o+iXCIsXCJUc2NyXCI6XCLwnZKvXCIsXCJ0c2NyXCI6XCLwnZOJXCIsXCJUU2N5XCI6XCLQplwiLFwidHNjeVwiOlwi0YZcIixcIlRTSGN5XCI6XCLQi1wiLFwidHNoY3lcIjpcItGbXCIsXCJUc3Ryb2tcIjpcIsWmXCIsXCJ0c3Ryb2tcIjpcIsWnXCIsXCJ0d2l4dFwiOlwi4omsXCIsXCJ0d29oZWFkbGVmdGFycm93XCI6XCLihp5cIixcInR3b2hlYWRyaWdodGFycm93XCI6XCLihqBcIixcIlVhY3V0ZVwiOlwiw5pcIixcInVhY3V0ZVwiOlwiw7pcIixcInVhcnJcIjpcIuKGkVwiLFwiVWFyclwiOlwi4oafXCIsXCJ1QXJyXCI6XCLih5FcIixcIlVhcnJvY2lyXCI6XCLipYlcIixcIlVicmN5XCI6XCLQjlwiLFwidWJyY3lcIjpcItGeXCIsXCJVYnJldmVcIjpcIsWsXCIsXCJ1YnJldmVcIjpcIsWtXCIsXCJVY2lyY1wiOlwiw5tcIixcInVjaXJjXCI6XCLDu1wiLFwiVWN5XCI6XCLQo1wiLFwidWN5XCI6XCLRg1wiLFwidWRhcnJcIjpcIuKHhVwiLFwiVWRibGFjXCI6XCLFsFwiLFwidWRibGFjXCI6XCLFsVwiLFwidWRoYXJcIjpcIuKlrlwiLFwidWZpc2h0XCI6XCLipb5cIixcIlVmclwiOlwi8J2UmFwiLFwidWZyXCI6XCLwnZSyXCIsXCJVZ3JhdmVcIjpcIsOZXCIsXCJ1Z3JhdmVcIjpcIsO5XCIsXCJ1SGFyXCI6XCLipaNcIixcInVoYXJsXCI6XCLihr9cIixcInVoYXJyXCI6XCLihr5cIixcInVoYmxrXCI6XCLiloBcIixcInVsY29yblwiOlwi4oycXCIsXCJ1bGNvcm5lclwiOlwi4oycXCIsXCJ1bGNyb3BcIjpcIuKMj1wiLFwidWx0cmlcIjpcIuKXuFwiLFwiVW1hY3JcIjpcIsWqXCIsXCJ1bWFjclwiOlwixatcIixcInVtbFwiOlwiwqhcIixcIlVuZGVyQmFyXCI6XCJfXCIsXCJVbmRlckJyYWNlXCI6XCLij59cIixcIlVuZGVyQnJhY2tldFwiOlwi4o61XCIsXCJVbmRlclBhcmVudGhlc2lzXCI6XCLij51cIixcIlVuaW9uXCI6XCLii4NcIixcIlVuaW9uUGx1c1wiOlwi4oqOXCIsXCJVb2dvblwiOlwixbJcIixcInVvZ29uXCI6XCLFs1wiLFwiVW9wZlwiOlwi8J2VjFwiLFwidW9wZlwiOlwi8J2VplwiLFwiVXBBcnJvd0JhclwiOlwi4qSSXCIsXCJ1cGFycm93XCI6XCLihpFcIixcIlVwQXJyb3dcIjpcIuKGkVwiLFwiVXBhcnJvd1wiOlwi4oeRXCIsXCJVcEFycm93RG93bkFycm93XCI6XCLih4VcIixcInVwZG93bmFycm93XCI6XCLihpVcIixcIlVwRG93bkFycm93XCI6XCLihpVcIixcIlVwZG93bmFycm93XCI6XCLih5VcIixcIlVwRXF1aWxpYnJpdW1cIjpcIuKlrlwiLFwidXBoYXJwb29ubGVmdFwiOlwi4oa/XCIsXCJ1cGhhcnBvb25yaWdodFwiOlwi4oa+XCIsXCJ1cGx1c1wiOlwi4oqOXCIsXCJVcHBlckxlZnRBcnJvd1wiOlwi4oaWXCIsXCJVcHBlclJpZ2h0QXJyb3dcIjpcIuKGl1wiLFwidXBzaVwiOlwiz4VcIixcIlVwc2lcIjpcIs+SXCIsXCJ1cHNpaFwiOlwiz5JcIixcIlVwc2lsb25cIjpcIs6lXCIsXCJ1cHNpbG9uXCI6XCLPhVwiLFwiVXBUZWVBcnJvd1wiOlwi4oalXCIsXCJVcFRlZVwiOlwi4oqlXCIsXCJ1cHVwYXJyb3dzXCI6XCLih4hcIixcInVyY29yblwiOlwi4oydXCIsXCJ1cmNvcm5lclwiOlwi4oydXCIsXCJ1cmNyb3BcIjpcIuKMjlwiLFwiVXJpbmdcIjpcIsWuXCIsXCJ1cmluZ1wiOlwixa9cIixcInVydHJpXCI6XCLil7lcIixcIlVzY3JcIjpcIvCdkrBcIixcInVzY3JcIjpcIvCdk4pcIixcInV0ZG90XCI6XCLii7BcIixcIlV0aWxkZVwiOlwixahcIixcInV0aWxkZVwiOlwixalcIixcInV0cmlcIjpcIuKWtVwiLFwidXRyaWZcIjpcIuKWtFwiLFwidXVhcnJcIjpcIuKHiFwiLFwiVXVtbFwiOlwiw5xcIixcInV1bWxcIjpcIsO8XCIsXCJ1d2FuZ2xlXCI6XCLipqdcIixcInZhbmdydFwiOlwi4qacXCIsXCJ2YXJlcHNpbG9uXCI6XCLPtVwiLFwidmFya2FwcGFcIjpcIs+wXCIsXCJ2YXJub3RoaW5nXCI6XCLiiIVcIixcInZhcnBoaVwiOlwiz5VcIixcInZhcnBpXCI6XCLPllwiLFwidmFycHJvcHRvXCI6XCLiiJ1cIixcInZhcnJcIjpcIuKGlVwiLFwidkFyclwiOlwi4oeVXCIsXCJ2YXJyaG9cIjpcIs+xXCIsXCJ2YXJzaWdtYVwiOlwiz4JcIixcInZhcnN1YnNldG5lcVwiOlwi4oqK77iAXCIsXCJ2YXJzdWJzZXRuZXFxXCI6XCLiq4vvuIBcIixcInZhcnN1cHNldG5lcVwiOlwi4oqL77iAXCIsXCJ2YXJzdXBzZXRuZXFxXCI6XCLiq4zvuIBcIixcInZhcnRoZXRhXCI6XCLPkVwiLFwidmFydHJpYW5nbGVsZWZ0XCI6XCLiirJcIixcInZhcnRyaWFuZ2xlcmlnaHRcIjpcIuKKs1wiLFwidkJhclwiOlwi4quoXCIsXCJWYmFyXCI6XCLiq6tcIixcInZCYXJ2XCI6XCLiq6lcIixcIlZjeVwiOlwi0JJcIixcInZjeVwiOlwi0LJcIixcInZkYXNoXCI6XCLiiqJcIixcInZEYXNoXCI6XCLiiqhcIixcIlZkYXNoXCI6XCLiiqlcIixcIlZEYXNoXCI6XCLiiqtcIixcIlZkYXNobFwiOlwi4qumXCIsXCJ2ZWViYXJcIjpcIuKKu1wiLFwidmVlXCI6XCLiiKhcIixcIlZlZVwiOlwi4ouBXCIsXCJ2ZWVlcVwiOlwi4omaXCIsXCJ2ZWxsaXBcIjpcIuKLrlwiLFwidmVyYmFyXCI6XCJ8XCIsXCJWZXJiYXJcIjpcIuKAllwiLFwidmVydFwiOlwifFwiLFwiVmVydFwiOlwi4oCWXCIsXCJWZXJ0aWNhbEJhclwiOlwi4oijXCIsXCJWZXJ0aWNhbExpbmVcIjpcInxcIixcIlZlcnRpY2FsU2VwYXJhdG9yXCI6XCLinZhcIixcIlZlcnRpY2FsVGlsZGVcIjpcIuKJgFwiLFwiVmVyeVRoaW5TcGFjZVwiOlwi4oCKXCIsXCJWZnJcIjpcIvCdlJlcIixcInZmclwiOlwi8J2Us1wiLFwidmx0cmlcIjpcIuKKslwiLFwidm5zdWJcIjpcIuKKguKDklwiLFwidm5zdXBcIjpcIuKKg+KDklwiLFwiVm9wZlwiOlwi8J2VjVwiLFwidm9wZlwiOlwi8J2Vp1wiLFwidnByb3BcIjpcIuKInVwiLFwidnJ0cmlcIjpcIuKKs1wiLFwiVnNjclwiOlwi8J2SsVwiLFwidnNjclwiOlwi8J2Ti1wiLFwidnN1Ym5FXCI6XCLiq4vvuIBcIixcInZzdWJuZVwiOlwi4oqK77iAXCIsXCJ2c3VwbkVcIjpcIuKrjO+4gFwiLFwidnN1cG5lXCI6XCLiiovvuIBcIixcIlZ2ZGFzaFwiOlwi4oqqXCIsXCJ2emlnemFnXCI6XCLipppcIixcIldjaXJjXCI6XCLFtFwiLFwid2NpcmNcIjpcIsW1XCIsXCJ3ZWRiYXJcIjpcIuKpn1wiLFwid2VkZ2VcIjpcIuKIp1wiLFwiV2VkZ2VcIjpcIuKLgFwiLFwid2VkZ2VxXCI6XCLiiZlcIixcIndlaWVycFwiOlwi4oSYXCIsXCJXZnJcIjpcIvCdlJpcIixcIndmclwiOlwi8J2UtFwiLFwiV29wZlwiOlwi8J2VjlwiLFwid29wZlwiOlwi8J2VqFwiLFwid3BcIjpcIuKEmFwiLFwid3JcIjpcIuKJgFwiLFwid3JlYXRoXCI6XCLiiYBcIixcIldzY3JcIjpcIvCdkrJcIixcIndzY3JcIjpcIvCdk4xcIixcInhjYXBcIjpcIuKLglwiLFwieGNpcmNcIjpcIuKXr1wiLFwieGN1cFwiOlwi4ouDXCIsXCJ4ZHRyaVwiOlwi4pa9XCIsXCJYZnJcIjpcIvCdlJtcIixcInhmclwiOlwi8J2UtVwiLFwieGhhcnJcIjpcIuKft1wiLFwieGhBcnJcIjpcIuKfulwiLFwiWGlcIjpcIs6eXCIsXCJ4aVwiOlwizr5cIixcInhsYXJyXCI6XCLin7VcIixcInhsQXJyXCI6XCLin7hcIixcInhtYXBcIjpcIuKfvFwiLFwieG5pc1wiOlwi4ou7XCIsXCJ4b2RvdFwiOlwi4qiAXCIsXCJYb3BmXCI6XCLwnZWPXCIsXCJ4b3BmXCI6XCLwnZWpXCIsXCJ4b3BsdXNcIjpcIuKogVwiLFwieG90aW1lXCI6XCLiqIJcIixcInhyYXJyXCI6XCLin7ZcIixcInhyQXJyXCI6XCLin7lcIixcIlhzY3JcIjpcIvCdkrNcIixcInhzY3JcIjpcIvCdk41cIixcInhzcWN1cFwiOlwi4qiGXCIsXCJ4dXBsdXNcIjpcIuKohFwiLFwieHV0cmlcIjpcIuKWs1wiLFwieHZlZVwiOlwi4ouBXCIsXCJ4d2VkZ2VcIjpcIuKLgFwiLFwiWWFjdXRlXCI6XCLDnVwiLFwieWFjdXRlXCI6XCLDvVwiLFwiWUFjeVwiOlwi0K9cIixcInlhY3lcIjpcItGPXCIsXCJZY2lyY1wiOlwixbZcIixcInljaXJjXCI6XCLFt1wiLFwiWWN5XCI6XCLQq1wiLFwieWN5XCI6XCLRi1wiLFwieWVuXCI6XCLCpVwiLFwiWWZyXCI6XCLwnZScXCIsXCJ5ZnJcIjpcIvCdlLZcIixcIllJY3lcIjpcItCHXCIsXCJ5aWN5XCI6XCLRl1wiLFwiWW9wZlwiOlwi8J2VkFwiLFwieW9wZlwiOlwi8J2VqlwiLFwiWXNjclwiOlwi8J2StFwiLFwieXNjclwiOlwi8J2TjlwiLFwiWVVjeVwiOlwi0K5cIixcInl1Y3lcIjpcItGOXCIsXCJ5dW1sXCI6XCLDv1wiLFwiWXVtbFwiOlwixbhcIixcIlphY3V0ZVwiOlwixblcIixcInphY3V0ZVwiOlwixbpcIixcIlpjYXJvblwiOlwixb1cIixcInpjYXJvblwiOlwixb5cIixcIlpjeVwiOlwi0JdcIixcInpjeVwiOlwi0LdcIixcIlpkb3RcIjpcIsW7XCIsXCJ6ZG90XCI6XCLFvFwiLFwiemVldHJmXCI6XCLihKhcIixcIlplcm9XaWR0aFNwYWNlXCI6XCLigItcIixcIlpldGFcIjpcIs6WXCIsXCJ6ZXRhXCI6XCLOtlwiLFwiemZyXCI6XCLwnZS3XCIsXCJaZnJcIjpcIuKEqFwiLFwiWkhjeVwiOlwi0JZcIixcInpoY3lcIjpcItC2XCIsXCJ6aWdyYXJyXCI6XCLih51cIixcInpvcGZcIjpcIvCdlatcIixcIlpvcGZcIjpcIuKEpFwiLFwiWnNjclwiOlwi8J2StVwiLFwienNjclwiOlwi8J2Tj1wiLFwiendqXCI6XCLigI1cIixcInp3bmpcIjpcIuKAjFwifVxuIiwibW9kdWxlLmV4cG9ydHM9e1wiQWFjdXRlXCI6XCLDgVwiLFwiYWFjdXRlXCI6XCLDoVwiLFwiQWNpcmNcIjpcIsOCXCIsXCJhY2lyY1wiOlwiw6JcIixcImFjdXRlXCI6XCLCtFwiLFwiQUVsaWdcIjpcIsOGXCIsXCJhZWxpZ1wiOlwiw6ZcIixcIkFncmF2ZVwiOlwiw4BcIixcImFncmF2ZVwiOlwiw6BcIixcImFtcFwiOlwiJlwiLFwiQU1QXCI6XCImXCIsXCJBcmluZ1wiOlwiw4VcIixcImFyaW5nXCI6XCLDpVwiLFwiQXRpbGRlXCI6XCLDg1wiLFwiYXRpbGRlXCI6XCLDo1wiLFwiQXVtbFwiOlwiw4RcIixcImF1bWxcIjpcIsOkXCIsXCJicnZiYXJcIjpcIsKmXCIsXCJDY2VkaWxcIjpcIsOHXCIsXCJjY2VkaWxcIjpcIsOnXCIsXCJjZWRpbFwiOlwiwrhcIixcImNlbnRcIjpcIsKiXCIsXCJjb3B5XCI6XCLCqVwiLFwiQ09QWVwiOlwiwqlcIixcImN1cnJlblwiOlwiwqRcIixcImRlZ1wiOlwiwrBcIixcImRpdmlkZVwiOlwiw7dcIixcIkVhY3V0ZVwiOlwiw4lcIixcImVhY3V0ZVwiOlwiw6lcIixcIkVjaXJjXCI6XCLDilwiLFwiZWNpcmNcIjpcIsOqXCIsXCJFZ3JhdmVcIjpcIsOIXCIsXCJlZ3JhdmVcIjpcIsOoXCIsXCJFVEhcIjpcIsOQXCIsXCJldGhcIjpcIsOwXCIsXCJFdW1sXCI6XCLDi1wiLFwiZXVtbFwiOlwiw6tcIixcImZyYWMxMlwiOlwiwr1cIixcImZyYWMxNFwiOlwiwrxcIixcImZyYWMzNFwiOlwiwr5cIixcImd0XCI6XCI+XCIsXCJHVFwiOlwiPlwiLFwiSWFjdXRlXCI6XCLDjVwiLFwiaWFjdXRlXCI6XCLDrVwiLFwiSWNpcmNcIjpcIsOOXCIsXCJpY2lyY1wiOlwiw65cIixcImlleGNsXCI6XCLCoVwiLFwiSWdyYXZlXCI6XCLDjFwiLFwiaWdyYXZlXCI6XCLDrFwiLFwiaXF1ZXN0XCI6XCLCv1wiLFwiSXVtbFwiOlwiw49cIixcIml1bWxcIjpcIsOvXCIsXCJsYXF1b1wiOlwiwqtcIixcImx0XCI6XCI8XCIsXCJMVFwiOlwiPFwiLFwibWFjclwiOlwiwq9cIixcIm1pY3JvXCI6XCLCtVwiLFwibWlkZG90XCI6XCLCt1wiLFwibmJzcFwiOlwiwqBcIixcIm5vdFwiOlwiwqxcIixcIk50aWxkZVwiOlwiw5FcIixcIm50aWxkZVwiOlwiw7FcIixcIk9hY3V0ZVwiOlwiw5NcIixcIm9hY3V0ZVwiOlwiw7NcIixcIk9jaXJjXCI6XCLDlFwiLFwib2NpcmNcIjpcIsO0XCIsXCJPZ3JhdmVcIjpcIsOSXCIsXCJvZ3JhdmVcIjpcIsOyXCIsXCJvcmRmXCI6XCLCqlwiLFwib3JkbVwiOlwiwrpcIixcIk9zbGFzaFwiOlwiw5hcIixcIm9zbGFzaFwiOlwiw7hcIixcIk90aWxkZVwiOlwiw5VcIixcIm90aWxkZVwiOlwiw7VcIixcIk91bWxcIjpcIsOWXCIsXCJvdW1sXCI6XCLDtlwiLFwicGFyYVwiOlwiwrZcIixcInBsdXNtblwiOlwiwrFcIixcInBvdW5kXCI6XCLCo1wiLFwicXVvdFwiOlwiXFxcIlwiLFwiUVVPVFwiOlwiXFxcIlwiLFwicmFxdW9cIjpcIsK7XCIsXCJyZWdcIjpcIsKuXCIsXCJSRUdcIjpcIsKuXCIsXCJzZWN0XCI6XCLCp1wiLFwic2h5XCI6XCLCrVwiLFwic3VwMVwiOlwiwrlcIixcInN1cDJcIjpcIsKyXCIsXCJzdXAzXCI6XCLCs1wiLFwic3psaWdcIjpcIsOfXCIsXCJUSE9STlwiOlwiw55cIixcInRob3JuXCI6XCLDvlwiLFwidGltZXNcIjpcIsOXXCIsXCJVYWN1dGVcIjpcIsOaXCIsXCJ1YWN1dGVcIjpcIsO6XCIsXCJVY2lyY1wiOlwiw5tcIixcInVjaXJjXCI6XCLDu1wiLFwiVWdyYXZlXCI6XCLDmVwiLFwidWdyYXZlXCI6XCLDuVwiLFwidW1sXCI6XCLCqFwiLFwiVXVtbFwiOlwiw5xcIixcInV1bWxcIjpcIsO8XCIsXCJZYWN1dGVcIjpcIsOdXCIsXCJ5YWN1dGVcIjpcIsO9XCIsXCJ5ZW5cIjpcIsKlXCIsXCJ5dW1sXCI6XCLDv1wifVxuIiwibW9kdWxlLmV4cG9ydHM9e1wiYW1wXCI6XCImXCIsXCJhcG9zXCI6XCInXCIsXCJndFwiOlwiPlwiLFwibHRcIjpcIjxcIixcInF1b3RcIjpcIlxcXCJcIn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICBpZiAoZXJyb3JMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICB2YXIgZXJyb3JMaXN0ZW5lcjtcblxuICAgIC8vIEFkZGluZyBhbiBlcnJvciBsaXN0ZW5lciBpcyBub3Qgb3B0aW9uYWwgYmVjYXVzZVxuICAgIC8vIGlmIGFuIGVycm9yIGlzIHRocm93biBvbiBhbiBldmVudCBlbWl0dGVyIHdlIGNhbm5vdFxuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBhY3R1YWwgZXZlbnQgd2UgYXJlIHdhaXRpbmcgd2lsbFxuICAgIC8vIGJlIGZpcmVkLiBUaGUgcmVzdWx0IGNvdWxkIGJlIGEgc2lsZW50IHdheSB0byBjcmVhdGVcbiAgICAvLyBtZW1vcnkgb3IgZmlsZSBkZXNjcmlwdG9yIGxlYWtzLCB3aGljaCBpcyBzb21ldGhpbmdcbiAgICAvLyB3ZSBzaG91bGQgYXZvaWQuXG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH07XG5cbiAgICAgIGVtaXR0ZXIub25jZSgnZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBlbWl0dGVyLm9uY2UobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlRmVlZCA9IGV4cG9ydHMuRmVlZEhhbmRsZXIgPSB2b2lkIDA7XG52YXIgZG9taGFuZGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpKTtcbnZhciBEb21VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZG9tdXRpbHNcIikpO1xudmFyIFBhcnNlcl8xID0gcmVxdWlyZShcIi4vUGFyc2VyXCIpO1xudmFyIEZlZWRJdGVtTWVkaWFNZWRpdW07XG4oZnVuY3Rpb24gKEZlZWRJdGVtTWVkaWFNZWRpdW0pIHtcbiAgICBGZWVkSXRlbU1lZGlhTWVkaXVtW0ZlZWRJdGVtTWVkaWFNZWRpdW1bXCJpbWFnZVwiXSA9IDBdID0gXCJpbWFnZVwiO1xuICAgIEZlZWRJdGVtTWVkaWFNZWRpdW1bRmVlZEl0ZW1NZWRpYU1lZGl1bVtcImF1ZGlvXCJdID0gMV0gPSBcImF1ZGlvXCI7XG4gICAgRmVlZEl0ZW1NZWRpYU1lZGl1bVtGZWVkSXRlbU1lZGlhTWVkaXVtW1widmlkZW9cIl0gPSAyXSA9IFwidmlkZW9cIjtcbiAgICBGZWVkSXRlbU1lZGlhTWVkaXVtW0ZlZWRJdGVtTWVkaWFNZWRpdW1bXCJkb2N1bWVudFwiXSA9IDNdID0gXCJkb2N1bWVudFwiO1xuICAgIEZlZWRJdGVtTWVkaWFNZWRpdW1bRmVlZEl0ZW1NZWRpYU1lZGl1bVtcImV4ZWN1dGFibGVcIl0gPSA0XSA9IFwiZXhlY3V0YWJsZVwiO1xufSkoRmVlZEl0ZW1NZWRpYU1lZGl1bSB8fCAoRmVlZEl0ZW1NZWRpYU1lZGl1bSA9IHt9KSk7XG52YXIgRmVlZEl0ZW1NZWRpYUV4cHJlc3Npb247XG4oZnVuY3Rpb24gKEZlZWRJdGVtTWVkaWFFeHByZXNzaW9uKSB7XG4gICAgRmVlZEl0ZW1NZWRpYUV4cHJlc3Npb25bRmVlZEl0ZW1NZWRpYUV4cHJlc3Npb25bXCJzYW1wbGVcIl0gPSAwXSA9IFwic2FtcGxlXCI7XG4gICAgRmVlZEl0ZW1NZWRpYUV4cHJlc3Npb25bRmVlZEl0ZW1NZWRpYUV4cHJlc3Npb25bXCJmdWxsXCJdID0gMV0gPSBcImZ1bGxcIjtcbiAgICBGZWVkSXRlbU1lZGlhRXhwcmVzc2lvbltGZWVkSXRlbU1lZGlhRXhwcmVzc2lvbltcIm5vbnN0b3BcIl0gPSAyXSA9IFwibm9uc3RvcFwiO1xufSkoRmVlZEl0ZW1NZWRpYUV4cHJlc3Npb24gfHwgKEZlZWRJdGVtTWVkaWFFeHByZXNzaW9uID0ge30pKTtcbi8vIFRPRE86IENvbnN1bWUgZGF0YSBhcyBpdCBpcyBjb21pbmcgaW5cbnZhciBGZWVkSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmVlZEhhbmRsZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZlZWRIYW5kbGVyKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2FsbGJhY2ssIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmVlZEhhbmRsZXIucHJvdG90eXBlLm9uZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgZmVlZCA9IHt9O1xuICAgICAgICB2YXIgZmVlZFJvb3QgPSBnZXRPbmVFbGVtZW50KGlzVmFsaWRGZWVkLCB0aGlzLmRvbSk7XG4gICAgICAgIGlmIChmZWVkUm9vdCkge1xuICAgICAgICAgICAgaWYgKGZlZWRSb290Lm5hbWUgPT09IFwiZmVlZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcyA9IGZlZWRSb290LmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGZlZWQudHlwZSA9IFwiYXRvbVwiO1xuICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJpZFwiLCBcImlkXCIsIGNoaWxkcyk7XG4gICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcInRpdGxlXCIsIFwidGl0bGVcIiwgY2hpbGRzKTtcbiAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IGdldEF0dHJpYnV0ZShcImhyZWZcIiwgZ2V0T25lRWxlbWVudChcImxpbmtcIiwgY2hpbGRzKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZC5saW5rID0gaHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImRlc2NyaXB0aW9uXCIsIFwic3VidGl0bGVcIiwgY2hpbGRzKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZCA9IGZldGNoKFwidXBkYXRlZFwiLCBjaGlsZHMpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWQudXBkYXRlZCA9IG5ldyBEYXRlKHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiYXV0aG9yXCIsIFwiZW1haWxcIiwgY2hpbGRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBmZWVkLml0ZW1zID0gZ2V0RWxlbWVudHMoXCJlbnRyeVwiLCBjaGlsZHMpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJpZFwiLCBcImlkXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJ0aXRsZVwiLCBcInRpdGxlXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBnZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGdldE9uZUVsZW1lbnQoXCJsaW5rXCIsIGNoaWxkcmVuKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5saW5rID0gaHJlZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBmZXRjaChcInN1bW1hcnlcIiwgY2hpbGRyZW4pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaChcImNvbnRlbnRcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHB1YkRhdGUgPSBmZXRjaChcInVwZGF0ZWRcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHViRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucHViRGF0ZSA9IG5ldyBEYXRlKHB1YkRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5Lm1lZGlhID0gZ2V0TWVkaWFFbGVtZW50cyhjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHMgPSAoX2IgPSAoX2EgPSBnZXRPbmVFbGVtZW50KFwiY2hhbm5lbFwiLCBmZWVkUm9vdC5jaGlsZHJlbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGlsZHJlbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgICAgICAgICAgZmVlZC50eXBlID0gZmVlZFJvb3QubmFtZS5zdWJzdHIoMCwgMyk7XG4gICAgICAgICAgICAgICAgZmVlZC5pZCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcInRpdGxlXCIsIFwidGl0bGVcIiwgY2hpbGRzKTtcbiAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwibGlua1wiLCBcImxpbmtcIiwgY2hpbGRzKTtcbiAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiZGVzY3JpcHRpb25cIiwgXCJkZXNjcmlwdGlvblwiLCBjaGlsZHMpO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkID0gZmV0Y2goXCJsYXN0QnVpbGREYXRlXCIsIGNoaWxkcyk7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZC51cGRhdGVkID0gbmV3IERhdGUodXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJhdXRob3JcIiwgXCJtYW5hZ2luZ0VkaXRvclwiLCBjaGlsZHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIGZlZWQuaXRlbXMgPSBnZXRFbGVtZW50cyhcIml0ZW1cIiwgZmVlZFJvb3QuY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJpZFwiLCBcImd1aWRcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGVudHJ5LCBcInRpdGxlXCIsIFwidGl0bGVcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGVudHJ5LCBcImxpbmtcIiwgXCJsaW5rXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJkZXNjcmlwdGlvblwiLCBcImRlc2NyaXB0aW9uXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB1YkRhdGUgPSBmZXRjaChcInB1YkRhdGVcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHViRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnB1YkRhdGUgPSBuZXcgRGF0ZShwdWJEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkubWVkaWEgPSBnZXRNZWRpYUVsZW1lbnRzKGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmVlZCA9IGZlZWQ7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2FsbGJhY2soZmVlZFJvb3QgPyBudWxsIDogRXJyb3IoXCJjb3VsZG4ndCBmaW5kIHJvb3Qgb2YgZmVlZFwiKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmVlZEhhbmRsZXI7XG59KGRvbWhhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLkZlZWRIYW5kbGVyID0gRmVlZEhhbmRsZXI7XG5mdW5jdGlvbiBnZXRNZWRpYUVsZW1lbnRzKHdoZXJlKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRzKFwibWVkaWE6Y29udGVudFwiLCB3aGVyZSkubWFwKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHtcbiAgICAgICAgICAgIG1lZGl1bTogZWxlbS5hdHRyaWJzLm1lZGl1bSxcbiAgICAgICAgICAgIGlzRGVmYXVsdDogISFlbGVtLmF0dHJpYnMuaXNEZWZhdWx0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZWxlbS5hdHRyaWJzLnVybCkge1xuICAgICAgICAgICAgbWVkaWEudXJsID0gZWxlbS5hdHRyaWJzLnVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS5hdHRyaWJzLmZpbGVTaXplKSB7XG4gICAgICAgICAgICBtZWRpYS5maWxlU2l6ZSA9IHBhcnNlSW50KGVsZW0uYXR0cmlicy5maWxlU2l6ZSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLmF0dHJpYnMudHlwZSkge1xuICAgICAgICAgICAgbWVkaWEudHlwZSA9IGVsZW0uYXR0cmlicy50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLmF0dHJpYnMuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgbWVkaWEuZXhwcmVzc2lvbiA9IGVsZW0uYXR0cmlic1xuICAgICAgICAgICAgICAgIC5leHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLmF0dHJpYnMuYml0cmF0ZSkge1xuICAgICAgICAgICAgbWVkaWEuYml0cmF0ZSA9IHBhcnNlSW50KGVsZW0uYXR0cmlicy5iaXRyYXRlLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW0uYXR0cmlicy5mcmFtZXJhdGUpIHtcbiAgICAgICAgICAgIG1lZGlhLmZyYW1lcmF0ZSA9IHBhcnNlSW50KGVsZW0uYXR0cmlicy5mcmFtZXJhdGUsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS5hdHRyaWJzLnNhbXBsaW5ncmF0ZSkge1xuICAgICAgICAgICAgbWVkaWEuc2FtcGxpbmdyYXRlID0gcGFyc2VJbnQoZWxlbS5hdHRyaWJzLnNhbXBsaW5ncmF0ZSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLmF0dHJpYnMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIG1lZGlhLmNoYW5uZWxzID0gcGFyc2VJbnQoZWxlbS5hdHRyaWJzLmNoYW5uZWxzLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW0uYXR0cmlicy5kdXJhdGlvbikge1xuICAgICAgICAgICAgbWVkaWEuZHVyYXRpb24gPSBwYXJzZUludChlbGVtLmF0dHJpYnMuZHVyYXRpb24sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS5hdHRyaWJzLmhlaWdodCkge1xuICAgICAgICAgICAgbWVkaWEuaGVpZ2h0ID0gcGFyc2VJbnQoZWxlbS5hdHRyaWJzLmhlaWdodCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLmF0dHJpYnMud2lkdGgpIHtcbiAgICAgICAgICAgIG1lZGlhLndpZHRoID0gcGFyc2VJbnQoZWxlbS5hdHRyaWJzLndpZHRoLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW0uYXR0cmlicy5sYW5nKSB7XG4gICAgICAgICAgICBtZWRpYS5sYW5nID0gZWxlbS5hdHRyaWJzLmxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lZGlhO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudHModGFnTmFtZSwgd2hlcmUpIHtcbiAgICByZXR1cm4gRG9tVXRpbHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSwgd2hlcmUsIHRydWUpO1xufVxuZnVuY3Rpb24gZ2V0T25lRWxlbWVudCh0YWdOYW1lLCBub2RlKSB7XG4gICAgcmV0dXJuIERvbVV0aWxzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUsIG5vZGUsIHRydWUsIDEpWzBdO1xufVxuZnVuY3Rpb24gZmV0Y2godGFnTmFtZSwgd2hlcmUsIHJlY3Vyc2UpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSBmYWxzZTsgfVxuICAgIHJldHVybiBEb21VdGlscy5nZXRUZXh0KERvbVV0aWxzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUsIHdoZXJlLCByZWN1cnNlLCAxKSkudHJpbSgpO1xufVxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5hbWUsIGVsZW0pIHtcbiAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhdHRyaWJzID0gZWxlbS5hdHRyaWJzO1xuICAgIHJldHVybiBhdHRyaWJzW25hbWVdO1xufVxuZnVuY3Rpb24gYWRkQ29uZGl0aW9uYWxseShvYmosIHByb3AsIHdoYXQsIHdoZXJlLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gZmFsc2U7IH1cbiAgICB2YXIgdG1wID0gZmV0Y2god2hhdCwgd2hlcmUsIHJlY3Vyc2UpO1xuICAgIGlmICh0bXApXG4gICAgICAgIG9ialtwcm9wXSA9IHRtcDtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRGZWVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBcInJzc1wiIHx8IHZhbHVlID09PSBcImZlZWRcIiB8fCB2YWx1ZSA9PT0gXCJyZGY6UkRGXCI7XG59XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7IHhtbE1vZGU6IHRydWUgfTtcbi8qKlxuICogUGFyc2UgYSBmZWVkLlxuICpcbiAqIEBwYXJhbSBmZWVkIFRoZSBmZWVkIHRoYXQgc2hvdWxkIGJlIHBhcnNlZCwgYXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbGx5LCBvcHRpb25zIGZvciBwYXJzaW5nLiBXaGVuIHVzaW5nIHRoaXMgb3B0aW9uLCB5b3UgcHJvYmFibHkgd2FudCB0byBzZXQgYHhtbE1vZGVgIHRvIGB0cnVlYC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VGZWVkKGZlZWQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9uczsgfVxuICAgIHZhciBoYW5kbGVyID0gbmV3IEZlZWRIYW5kbGVyKG9wdGlvbnMpO1xuICAgIG5ldyBQYXJzZXJfMS5QYXJzZXIoaGFuZGxlciwgb3B0aW9ucykuZW5kKGZlZWQpO1xuICAgIHJldHVybiBoYW5kbGVyLmZlZWQ7XG59XG5leHBvcnRzLnBhcnNlRmVlZCA9IHBhcnNlRmVlZDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJzZXIgPSB2b2lkIDA7XG52YXIgVG9rZW5pemVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vVG9rZW5pemVyXCIpKTtcbnZhciBmb3JtVGFncyA9IG5ldyBTZXQoW1xuICAgIFwiaW5wdXRcIixcbiAgICBcIm9wdGlvblwiLFxuICAgIFwib3B0Z3JvdXBcIixcbiAgICBcInNlbGVjdFwiLFxuICAgIFwiYnV0dG9uXCIsXG4gICAgXCJkYXRhbGlzdFwiLFxuICAgIFwidGV4dGFyZWFcIixcbl0pO1xudmFyIHBUYWcgPSBuZXcgU2V0KFtcInBcIl0pO1xudmFyIG9wZW5JbXBsaWVzQ2xvc2UgPSB7XG4gICAgdHI6IG5ldyBTZXQoW1widHJcIiwgXCJ0aFwiLCBcInRkXCJdKSxcbiAgICB0aDogbmV3IFNldChbXCJ0aFwiXSksXG4gICAgdGQ6IG5ldyBTZXQoW1widGhlYWRcIiwgXCJ0aFwiLCBcInRkXCJdKSxcbiAgICBib2R5OiBuZXcgU2V0KFtcImhlYWRcIiwgXCJsaW5rXCIsIFwic2NyaXB0XCJdKSxcbiAgICBsaTogbmV3IFNldChbXCJsaVwiXSksXG4gICAgcDogcFRhZyxcbiAgICBoMTogcFRhZyxcbiAgICBoMjogcFRhZyxcbiAgICBoMzogcFRhZyxcbiAgICBoNDogcFRhZyxcbiAgICBoNTogcFRhZyxcbiAgICBoNjogcFRhZyxcbiAgICBzZWxlY3Q6IGZvcm1UYWdzLFxuICAgIGlucHV0OiBmb3JtVGFncyxcbiAgICBvdXRwdXQ6IGZvcm1UYWdzLFxuICAgIGJ1dHRvbjogZm9ybVRhZ3MsXG4gICAgZGF0YWxpc3Q6IGZvcm1UYWdzLFxuICAgIHRleHRhcmVhOiBmb3JtVGFncyxcbiAgICBvcHRpb246IG5ldyBTZXQoW1wib3B0aW9uXCJdKSxcbiAgICBvcHRncm91cDogbmV3IFNldChbXCJvcHRncm91cFwiLCBcIm9wdGlvblwiXSksXG4gICAgZGQ6IG5ldyBTZXQoW1wiZHRcIiwgXCJkZFwiXSksXG4gICAgZHQ6IG5ldyBTZXQoW1wiZHRcIiwgXCJkZFwiXSksXG4gICAgYWRkcmVzczogcFRhZyxcbiAgICBhcnRpY2xlOiBwVGFnLFxuICAgIGFzaWRlOiBwVGFnLFxuICAgIGJsb2NrcXVvdGU6IHBUYWcsXG4gICAgZGV0YWlsczogcFRhZyxcbiAgICBkaXY6IHBUYWcsXG4gICAgZGw6IHBUYWcsXG4gICAgZmllbGRzZXQ6IHBUYWcsXG4gICAgZmlnY2FwdGlvbjogcFRhZyxcbiAgICBmaWd1cmU6IHBUYWcsXG4gICAgZm9vdGVyOiBwVGFnLFxuICAgIGZvcm06IHBUYWcsXG4gICAgaGVhZGVyOiBwVGFnLFxuICAgIGhyOiBwVGFnLFxuICAgIG1haW46IHBUYWcsXG4gICAgbmF2OiBwVGFnLFxuICAgIG9sOiBwVGFnLFxuICAgIHByZTogcFRhZyxcbiAgICBzZWN0aW9uOiBwVGFnLFxuICAgIHRhYmxlOiBwVGFnLFxuICAgIHVsOiBwVGFnLFxuICAgIHJ0OiBuZXcgU2V0KFtcInJ0XCIsIFwicnBcIl0pLFxuICAgIHJwOiBuZXcgU2V0KFtcInJ0XCIsIFwicnBcIl0pLFxuICAgIHRib2R5OiBuZXcgU2V0KFtcInRoZWFkXCIsIFwidGJvZHlcIl0pLFxuICAgIHRmb290OiBuZXcgU2V0KFtcInRoZWFkXCIsIFwidGJvZHlcIl0pLFxufTtcbnZhciB2b2lkRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICBcImFyZWFcIixcbiAgICBcImJhc2VcIixcbiAgICBcImJhc2Vmb250XCIsXG4gICAgXCJiclwiLFxuICAgIFwiY29sXCIsXG4gICAgXCJjb21tYW5kXCIsXG4gICAgXCJlbWJlZFwiLFxuICAgIFwiZnJhbWVcIixcbiAgICBcImhyXCIsXG4gICAgXCJpbWdcIixcbiAgICBcImlucHV0XCIsXG4gICAgXCJpc2luZGV4XCIsXG4gICAgXCJrZXlnZW5cIixcbiAgICBcImxpbmtcIixcbiAgICBcIm1ldGFcIixcbiAgICBcInBhcmFtXCIsXG4gICAgXCJzb3VyY2VcIixcbiAgICBcInRyYWNrXCIsXG4gICAgXCJ3YnJcIixcbl0pO1xudmFyIGZvcmVpZ25Db250ZXh0RWxlbWVudHMgPSBuZXcgU2V0KFtcIm1hdGhcIiwgXCJzdmdcIl0pO1xudmFyIGh0bWxJbnRlZ3JhdGlvbkVsZW1lbnRzID0gbmV3IFNldChbXG4gICAgXCJtaVwiLFxuICAgIFwibW9cIixcbiAgICBcIm1uXCIsXG4gICAgXCJtc1wiLFxuICAgIFwibXRleHRcIixcbiAgICBcImFubm90YXRpb24teG1sXCIsXG4gICAgXCJmb3JlaWduT2JqZWN0XCIsXG4gICAgXCJkZXNjXCIsXG4gICAgXCJ0aXRsZVwiLFxuXSk7XG52YXIgcmVOYW1lRW5kID0gL1xcc3xcXC8vO1xudmFyIFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIoY2JzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIC8qKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGxhc3QgZXZlbnQuICovXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgZW5kIGluZGV4IG9mIHRoZSBsYXN0IGV2ZW50LiAqL1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWduYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5hdHRyaWJuYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5hdHRyaWJ2YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlicyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dCA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNicyA9IGNicyAhPT0gbnVsbCAmJiBjYnMgIT09IHZvaWQgMCA/IGNicyA6IHt9O1xuICAgICAgICB0aGlzLmxvd2VyQ2FzZVRhZ05hbWVzID0gKF9hID0gb3B0aW9ucy5sb3dlckNhc2VUYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAhb3B0aW9ucy54bWxNb2RlO1xuICAgICAgICB0aGlzLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzID0gKF9iID0gb3B0aW9ucy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogIW9wdGlvbnMueG1sTW9kZTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSBuZXcgKChfYyA9IG9wdGlvbnMuVG9rZW5pemVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBUb2tlbml6ZXJfMS5kZWZhdWx0KSh0aGlzLm9wdGlvbnMsIHRoaXMpO1xuICAgICAgICAoX2UgPSAoX2QgPSB0aGlzLmNicykub25wYXJzZXJpbml0KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCwgdGhpcyk7XG4gICAgfVxuICAgIFBhcnNlci5wcm90b3R5cGUudXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoaW5pdGlhbE9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5lbmRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLnNlY3Rpb25TdGFydCA8PSBpbml0aWFsT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHRoaXMudG9rZW5pemVyLnNlY3Rpb25TdGFydCAtIGluaXRpYWxPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSB0aGlzLmVuZEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZEluZGV4ID0gdGhpcy50b2tlbml6ZXIuZ2V0QWJzb2x1dGVJbmRleCgpO1xuICAgIH07XG4gICAgLy8gVG9rZW5pemVyIGV2ZW50IGhhbmRsZXJzXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbnRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKDEpO1xuICAgICAgICB0aGlzLmVuZEluZGV4LS07XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBkYXRhKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25vcGVudGFnbmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmxvd2VyQ2FzZVRhZ05hbWVzKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IG5hbWU7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnhtbE1vZGUgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcGVuSW1wbGllc0Nsb3NlLCBuYW1lKSkge1xuICAgICAgICAgICAgdmFyIGVsID0gdm9pZCAwO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIG9wZW5JbXBsaWVzQ2xvc2VbbmFtZV0uaGFzKChlbCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNsb3NldGFnKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnhtbE1vZGUgfHwgIXZvaWRFbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChuYW1lKTtcbiAgICAgICAgICAgIGlmIChmb3JlaWduQ29udGV4dEVsZW1lbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQucHVzaCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGh0bWxJbnRlZ3JhdGlvbkVsZW1lbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9ub3BlbnRhZ25hbWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuY2JzLm9ub3BlbnRhZylcbiAgICAgICAgICAgIHRoaXMuYXR0cmlicyA9IHt9O1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbm9wZW50YWdlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oMSk7XG4gICAgICAgIGlmICh0aGlzLmF0dHJpYnMpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbm9wZW50YWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzLnRhZ25hbWUsIHRoaXMuYXR0cmlicyk7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnhtbE1vZGUgJiZcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY2xvc2V0YWcgJiZcbiAgICAgICAgICAgIHZvaWRFbGVtZW50cy5oYXModGhpcy50YWduYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25jbG9zZXRhZyh0aGlzLnRhZ25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IFwiXCI7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9uY2xvc2V0YWcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKDEpO1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yZWlnbkNvbnRleHRFbGVtZW50cy5oYXMobmFtZSkgfHxcbiAgICAgICAgICAgIGh0bWxJbnRlZ3JhdGlvbkVsZW1lbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggJiZcbiAgICAgICAgICAgICh0aGlzLm9wdGlvbnMueG1sTW9kZSB8fCAhdm9pZEVsZW1lbnRzLmhhcyhuYW1lKSkpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnN0YWNrLmxhc3RJbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYnMub25jbG9zZXRhZykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIHBvcztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBvcy0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBzdGFjayBoYXMgc3VmZmljaWVudCBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uY2xvc2V0YWcodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09IFwicFwiICYmICF0aGlzLm9wdGlvbnMueG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25vcGVudGFnbmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQ3VycmVudFRhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMueG1sTW9kZSAmJiAobmFtZSA9PT0gXCJiclwiIHx8IG5hbWUgPT09IFwicFwiKSkge1xuICAgICAgICAgICAgdGhpcy5vbm9wZW50YWduYW1lKG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUN1cnJlbnRUYWcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbnNlbGZjbG9zaW5ndGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnhtbE1vZGUgfHxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZWNvZ25pemVTZWxmQ2xvc2luZyB8fFxuICAgICAgICAgICAgdGhpcy5mb3JlaWduQ29udGV4dFt0aGlzLmZvcmVpZ25Db250ZXh0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQ3VycmVudFRhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbm9wZW50YWdlbmQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5jbG9zZUN1cnJlbnRUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy50YWduYW1lO1xuICAgICAgICB0aGlzLm9ub3BlbnRhZ2VuZCgpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBTZWxmLWNsb3NpbmcgdGFncyB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgICAqIChjaGVhcGVyIGNoZWNrIHRoYW4gaW4gb25jbG9zZXRhZylcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmNsb3NldGFnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbmFtZSk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9uYXR0cmlibmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0cmlibmFtZSA9IG5hbWU7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9uYXR0cmliZGF0YSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmF0dHJpYnZhbHVlICs9IHZhbHVlO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYmVuZCA9IGZ1bmN0aW9uIChxdW90ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25hdHRyaWJ1dGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzLmF0dHJpYm5hbWUsIHRoaXMuYXR0cmlidmFsdWUsIHF1b3RlKTtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlicyAmJlxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnMsIHRoaXMuYXR0cmlibmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlic1t0aGlzLmF0dHJpYm5hbWVdID0gdGhpcy5hdHRyaWJ2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHJpYm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnZhbHVlID0gXCJcIjtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuZ2V0SW5zdHJ1Y3Rpb25OYW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpZHggPSB2YWx1ZS5zZWFyY2gocmVOYW1lRW5kKTtcbiAgICAgICAgdmFyIG5hbWUgPSBpZHggPCAwID8gdmFsdWUgOiB2YWx1ZS5zdWJzdHIoMCwgaWR4KTtcbiAgICAgICAgaWYgKHRoaXMubG93ZXJDYXNlVGFnTmFtZXMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9uZGVjbGFyYXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5nZXRJbnN0cnVjdGlvbk5hbWUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24oXCIhXCIgKyBuYW1lXzEsIFwiIVwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdmFyIG5hbWVfMiA9IHRoaXMuZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKFwiP1wiICsgbmFtZV8yLCBcIj9cIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmNvbW1lbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKDQpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jb21tZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdmFsdWUpO1xuICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub25jb21tZW50ZW5kKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9uY2RhdGEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oMSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMueG1sTW9kZSB8fCB0aGlzLm9wdGlvbnMucmVjb2duaXplQ0RBVEEpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmNkYXRhc3RhcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2JzKS5vbnRleHQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCB2YWx1ZSk7XG4gICAgICAgICAgICAoX2YgPSAoX2UgPSB0aGlzLmNicykub25jZGF0YWVuZCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbmNvbW1lbnQoXCJbQ0RBVEFbXCIgKyB2YWx1ZSArIFwiXV1cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlcnIpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuY2JzLm9uY2xvc2V0YWcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnN0YWNrLmxlbmd0aDsgaSA+IDA7IHRoaXMuY2JzLm9uY2xvc2V0YWcodGhpcy5zdGFja1stLWldKSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uZW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHBhcnNlciB0byBhIGJsYW5rIHN0YXRlLCByZWFkeSB0byBwYXJzZSBhIG5ldyBIVE1MIGRvY3VtZW50XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25yZXNldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0aGlzLnRva2VuaXplci5yZXNldCgpO1xuICAgICAgICB0aGlzLnRhZ25hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2JzKS5vbnBhcnNlcmluaXQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNvbXBsZXRlIGRvY3VtZW50IGFuZCBwdXNoZXMgaXQgdG8gdGhlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBEb2N1bWVudCB0byBwYXJzZS5cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcGxldGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZW5kKGRhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgY2h1bmsgb2YgZGF0YSBhbmQgY2FsbHMgdGhlIGNvcnJlc3BvbmRpbmcgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIENodW5rIHRvIHBhcnNlLlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIud3JpdGUoY2h1bmspO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBhbmQgY2xlYXJzIHRoZSBzdGFjaywgY2FsbHMgb25lbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2h1bmsgT3B0aW9uYWwgZmluYWwgY2h1bmsgdG8gcGFyc2UuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIuZW5kKGNodW5rKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhdXNlcyBwYXJzaW5nLiBUaGUgcGFyc2VyIHdvbid0IGVtaXQgZXZlbnRzIHVudGlsIGByZXN1bWVgIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRva2VuaXplci5wYXVzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBwYXJzaW5nIGFmdGVyIGBwYXVzZWAgd2FzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIucmVzdW1lKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBgd3JpdGVgLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2h1bmsgQ2h1bmsgdG8gcGFyc2UuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBgZW5kYCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIE9wdGlvbmFsIGZpbmFsIGNodW5rIHRvIHBhcnNlLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW5kKGNodW5rKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZWNvZGVfY29kZXBvaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVudGl0aWVzL2xpYi9kZWNvZGVfY29kZXBvaW50XCIpKTtcbnZhciBlbnRpdGllc19qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVudGl0aWVzL2xpYi9tYXBzL2VudGl0aWVzLmpzb25cIikpO1xudmFyIGxlZ2FjeV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVudGl0aWVzL2xpYi9tYXBzL2xlZ2FjeS5qc29uXCIpKTtcbnZhciB4bWxfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvbWFwcy94bWwuanNvblwiKSk7XG5mdW5jdGlvbiB3aGl0ZXNwYWNlKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcdFwiIHx8IGMgPT09IFwiXFxmXCIgfHwgYyA9PT0gXCJcXHJcIjtcbn1cbmZ1bmN0aW9uIGlzQVNDSUlBbHBoYShjKSB7XG4gICAgcmV0dXJuIChjID49IFwiYVwiICYmIGMgPD0gXCJ6XCIpIHx8IChjID49IFwiQVwiICYmIGMgPD0gXCJaXCIpO1xufVxuZnVuY3Rpb24gaWZFbHNlU3RhdGUodXBwZXIsIFNVQ0NFU1MsIEZBSUxVUkUpIHtcbiAgICB2YXIgbG93ZXIgPSB1cHBlci50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh1cHBlciA9PT0gbG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBjKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gbG93ZXIpIHtcbiAgICAgICAgICAgICAgICB0Ll9zdGF0ZSA9IFNVQ0NFU1M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0Ll9zdGF0ZSA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgdC5faW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBjKSB7XG4gICAgICAgIGlmIChjID09PSBsb3dlciB8fCBjID09PSB1cHBlcikge1xuICAgICAgICAgICAgdC5fc3RhdGUgPSBTVUNDRVNTO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdC5fc3RhdGUgPSBGQUlMVVJFO1xuICAgICAgICAgICAgdC5faW5kZXgtLTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKHVwcGVyLCBORVhUX1NUQVRFKSB7XG4gICAgdmFyIGxvd2VyID0gdXBwZXIudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGMpIHtcbiAgICAgICAgaWYgKGMgPT09IGxvd2VyIHx8IGMgPT09IHVwcGVyKSB7XG4gICAgICAgICAgICB0Ll9zdGF0ZSA9IE5FWFRfU1RBVEU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0Ll9zdGF0ZSA9IDMgLyogSW5UYWdOYW1lICovO1xuICAgICAgICAgICAgdC5faW5kZXgtLTsgLy8gQ29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cbiAgICAgICAgfVxuICAgIH07XG59XG52YXIgc3RhdGVCZWZvcmVDZGF0YTEgPSBpZkVsc2VTdGF0ZShcIkNcIiwgMjQgLyogQmVmb3JlQ2RhdGEyICovLCAxNiAvKiBJbkRlY2xhcmF0aW9uICovKTtcbnZhciBzdGF0ZUJlZm9yZUNkYXRhMiA9IGlmRWxzZVN0YXRlKFwiRFwiLCAyNSAvKiBCZWZvcmVDZGF0YTMgKi8sIDE2IC8qIEluRGVjbGFyYXRpb24gKi8pO1xudmFyIHN0YXRlQmVmb3JlQ2RhdGEzID0gaWZFbHNlU3RhdGUoXCJBXCIsIDI2IC8qIEJlZm9yZUNkYXRhNCAqLywgMTYgLyogSW5EZWNsYXJhdGlvbiAqLyk7XG52YXIgc3RhdGVCZWZvcmVDZGF0YTQgPSBpZkVsc2VTdGF0ZShcIlRcIiwgMjcgLyogQmVmb3JlQ2RhdGE1ICovLCAxNiAvKiBJbkRlY2xhcmF0aW9uICovKTtcbnZhciBzdGF0ZUJlZm9yZUNkYXRhNSA9IGlmRWxzZVN0YXRlKFwiQVwiLCAyOCAvKiBCZWZvcmVDZGF0YTYgKi8sIDE2IC8qIEluRGVjbGFyYXRpb24gKi8pO1xudmFyIHN0YXRlQmVmb3JlU2NyaXB0MSA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJSXCIsIDM1IC8qIEJlZm9yZVNjcmlwdDIgKi8pO1xudmFyIHN0YXRlQmVmb3JlU2NyaXB0MiA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJJXCIsIDM2IC8qIEJlZm9yZVNjcmlwdDMgKi8pO1xudmFyIHN0YXRlQmVmb3JlU2NyaXB0MyA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJQXCIsIDM3IC8qIEJlZm9yZVNjcmlwdDQgKi8pO1xudmFyIHN0YXRlQmVmb3JlU2NyaXB0NCA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJUXCIsIDM4IC8qIEJlZm9yZVNjcmlwdDUgKi8pO1xudmFyIHN0YXRlQWZ0ZXJTY3JpcHQxID0gaWZFbHNlU3RhdGUoXCJSXCIsIDQwIC8qIEFmdGVyU2NyaXB0MiAqLywgMSAvKiBUZXh0ICovKTtcbnZhciBzdGF0ZUFmdGVyU2NyaXB0MiA9IGlmRWxzZVN0YXRlKFwiSVwiLCA0MSAvKiBBZnRlclNjcmlwdDMgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVBZnRlclNjcmlwdDMgPSBpZkVsc2VTdGF0ZShcIlBcIiwgNDIgLyogQWZ0ZXJTY3JpcHQ0ICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQWZ0ZXJTY3JpcHQ0ID0gaWZFbHNlU3RhdGUoXCJUXCIsIDQzIC8qIEFmdGVyU2NyaXB0NSAqLywgMSAvKiBUZXh0ICovKTtcbnZhciBzdGF0ZUJlZm9yZVN0eWxlMSA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJZXCIsIDQ1IC8qIEJlZm9yZVN0eWxlMiAqLyk7XG52YXIgc3RhdGVCZWZvcmVTdHlsZTIgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiTFwiLCA0NiAvKiBCZWZvcmVTdHlsZTMgKi8pO1xudmFyIHN0YXRlQmVmb3JlU3R5bGUzID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIkVcIiwgNDcgLyogQmVmb3JlU3R5bGU0ICovKTtcbnZhciBzdGF0ZUFmdGVyU3R5bGUxID0gaWZFbHNlU3RhdGUoXCJZXCIsIDQ5IC8qIEFmdGVyU3R5bGUyICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQWZ0ZXJTdHlsZTIgPSBpZkVsc2VTdGF0ZShcIkxcIiwgNTAgLyogQWZ0ZXJTdHlsZTMgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVBZnRlclN0eWxlMyA9IGlmRWxzZVN0YXRlKFwiRVwiLCA1MSAvKiBBZnRlclN0eWxlNCAqLywgMSAvKiBUZXh0ICovKTtcbnZhciBzdGF0ZUJlZm9yZVNwZWNpYWxUID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIklcIiwgNTQgLyogQmVmb3JlVGl0bGUxICovKTtcbnZhciBzdGF0ZUJlZm9yZVRpdGxlMSA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJUXCIsIDU1IC8qIEJlZm9yZVRpdGxlMiAqLyk7XG52YXIgc3RhdGVCZWZvcmVUaXRsZTIgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiTFwiLCA1NiAvKiBCZWZvcmVUaXRsZTMgKi8pO1xudmFyIHN0YXRlQmVmb3JlVGl0bGUzID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIkVcIiwgNTcgLyogQmVmb3JlVGl0bGU0ICovKTtcbnZhciBzdGF0ZUFmdGVyU3BlY2lhbFRFbmQgPSBpZkVsc2VTdGF0ZShcIklcIiwgNTggLyogQWZ0ZXJUaXRsZTEgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVBZnRlclRpdGxlMSA9IGlmRWxzZVN0YXRlKFwiVFwiLCA1OSAvKiBBZnRlclRpdGxlMiAqLywgMSAvKiBUZXh0ICovKTtcbnZhciBzdGF0ZUFmdGVyVGl0bGUyID0gaWZFbHNlU3RhdGUoXCJMXCIsIDYwIC8qIEFmdGVyVGl0bGUzICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQWZ0ZXJUaXRsZTMgPSBpZkVsc2VTdGF0ZShcIkVcIiwgNjEgLyogQWZ0ZXJUaXRsZTQgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVCZWZvcmVFbnRpdHkgPSBpZkVsc2VTdGF0ZShcIiNcIiwgNjMgLyogQmVmb3JlTnVtZXJpY0VudGl0eSAqLywgNjQgLyogSW5OYW1lZEVudGl0eSAqLyk7XG52YXIgc3RhdGVCZWZvcmVOdW1lcmljRW50aXR5ID0gaWZFbHNlU3RhdGUoXCJYXCIsIDY2IC8qIEluSGV4RW50aXR5ICovLCA2NSAvKiBJbk51bWVyaWNFbnRpdHkgKi8pO1xudmFyIFRva2VuaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZXIob3B0aW9ucywgY2JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50IHN0YXRlIHRoZSB0b2tlbml6ZXIgaXMgaW4uICovXG4gICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAvKiogVGhlIHJlYWQgYnVmZmVyLiAqL1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIC8qKiBUaGUgYmVnaW5uaW5nIG9mIHRoZSBzZWN0aW9uIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHJlYWQuICovXG4gICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgLyoqIFRoZSBpbmRleCB3aXRoaW4gdGhlIGJ1ZmZlciB0aGF0IHdlIGFyZSBjdXJyZW50bHkgbG9va2luZyBhdC4gKi9cbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBidWZmZXIgb2NjYXNpb25hbGx5LlxuICAgICAgICAgKiBgX2J1ZmZlck9mZnNldGAga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgY2hhcmFjdGVycyBoYXZlIGJlZW4gcmVtb3ZlZCwgdG8gbWFrZSBzdXJlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGlzIGFjY3VyYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5idWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAvKiogU29tZSBiZWhhdmlvciwgZWcuIHdoZW4gZGVjb2RpbmcgZW50aXRpZXMsIGlzIGRvbmUgd2hpbGUgd2UgYXJlIGluIGFub3RoZXIgc3RhdGUuIFRoaXMga2VlcHMgdHJhY2sgb2YgdGhlIG90aGVyIHN0YXRlIHR5cGUuICovXG4gICAgICAgIHRoaXMuYmFzZVN0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAvKiogRm9yIHNwZWNpYWwgcGFyc2luZyBiZWhhdmlvciBpbnNpZGUgb2Ygc2NyaXB0IGFuZCBzdHlsZSB0YWdzLiAqL1xuICAgICAgICB0aGlzLnNwZWNpYWwgPSAxIC8qIE5vbmUgKi87XG4gICAgICAgIC8qKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdG9rZW5pemVyIGhhcyBiZWVuIHBhdXNlZC4gKi9cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0b2tlbml6ZXIgaGFzIGZpbmlzaGVkIHJ1bm5pbmcgLyBgLmVuZGAgaGFzIGJlZW4gY2FsbGVkLiAqL1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2JzID0gY2JzO1xuICAgICAgICB0aGlzLnhtbE1vZGUgPSAhIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueG1sTW9kZSk7XG4gICAgICAgIHRoaXMuZGVjb2RlRW50aXRpZXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVjb2RlRW50aXRpZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgfVxuICAgIFRva2VuaXplci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVN0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICB0aGlzLnNwZWNpYWwgPSAxIC8qIE5vbmUgKi87XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICAgICAgICB0aGlzLmNicy5vbmVycm9yKEVycm9yKFwiLndyaXRlKCkgYWZ0ZXIgZG9uZSFcIikpO1xuICAgICAgICB0aGlzLmJ1ZmZlciArPSBjaHVuaztcbiAgICAgICAgdGhpcy5wYXJzZSgpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICAgICAgICB0aGlzLmNicy5vbmVycm9yKEVycm9yKFwiLmVuZCgpIGFmdGVyIGRvbmUhXCIpKTtcbiAgICAgICAgaWYgKGNodW5rKVxuICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKVxuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBpbmRleCB3aXRoaW4gYWxsIG9mIHRoZSB3cml0dGVuIGRhdGEuXG4gICAgICovXG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5nZXRBYnNvbHV0ZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJPZmZzZXQgKyB0aGlzLl9pbmRleDtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVUZXh0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPiB0aGlzLnNlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLmdldFNlY3Rpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDIgLyogQmVmb3JlVGFnTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNvZGVFbnRpdGllcyAmJlxuICAgICAgICAgICAgYyA9PT0gXCImXCIgJiZcbiAgICAgICAgICAgICh0aGlzLnNwZWNpYWwgPT09IDEgLyogTm9uZSAqLyB8fCB0aGlzLnNwZWNpYWwgPT09IDQgLyogVGl0bGUgKi8pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPiB0aGlzLnNlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLmdldFNlY3Rpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJhc2VTdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNjIgLyogQmVmb3JlRW50aXR5ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZVRhZ05hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNSAvKiBCZWZvcmVDbG9zaW5nVGFnTmFtZSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBcIjxcIikge1xuICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuZ2V0U2VjdGlvbigpKTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI+XCIgfHxcbiAgICAgICAgICAgIHRoaXMuc3BlY2lhbCAhPT0gMSAvKiBOb25lICovIHx8XG4gICAgICAgICAgICB3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBcIiFcIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxNSAvKiBCZWZvcmVEZWNsYXJhdGlvbiAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDE3IC8qIEluUHJvY2Vzc2luZ0luc3RydWN0aW9uICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzQVNDSUlBbHBoYShjKSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9XG4gICAgICAgICAgICAgICAgIXRoaXMueG1sTW9kZSAmJiAoYyA9PT0gXCJzXCIgfHwgYyA9PT0gXCJTXCIpXG4gICAgICAgICAgICAgICAgICAgID8gMzIgLyogQmVmb3JlU3BlY2lhbFMgKi9cbiAgICAgICAgICAgICAgICAgICAgOiAhdGhpcy54bWxNb2RlICYmIChjID09PSBcInRcIiB8fCBjID09PSBcIlRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gNTIgLyogQmVmb3JlU3BlY2lhbFQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogMyAvKiBJblRhZ05hbWUgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5UYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFRva2VuKFwib25vcGVudGFnbmFtZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gOCAvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNwZWNpYWwgIT09IDEgLyogTm9uZSAqLykge1xuICAgICAgICAgICAgaWYgKGMgPT09IFwic1wiIHx8IGMgPT09IFwiU1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAzMyAvKiBCZWZvcmVTcGVjaWFsU0VuZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwidFwiIHx8IGMgPT09IFwiVFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA1MyAvKiBCZWZvcmVTcGVjaWFsVEVuZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzQVNDSUlBbHBoYShjKSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAyMCAvKiBJblNwZWNpYWxDb21tZW50ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNiAvKiBJbkNsb3NpbmdUYWdOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluQ2xvc2luZ1RhZ05hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0VG9rZW4oXCJvbmNsb3NldGFnXCIpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA3IC8qIEFmdGVyQ2xvc2luZ1RhZ05hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQWZ0ZXJDbG9zaW5nVGFnTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIFNraXAgZXZlcnl0aGluZyB1bnRpbCBcIj5cIlxuICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbm9wZW50YWdlbmQoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNCAvKiBJblNlbGZDbG9zaW5nVGFnICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDkgLyogSW5BdHRyaWJ1dGVOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluU2VsZkNsb3NpbmdUYWcgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uc2VsZmNsb3Npbmd0YWcoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgICAgICB0aGlzLnNwZWNpYWwgPSAxIC8qIE5vbmUgKi87IC8vIFJlc2V0IHNwZWNpYWwgc3RhdGUsIGluIGNhc2Ugb2Ygc2VsZi1jbG9zaW5nIHNwZWNpYWwgdGFnc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDggLyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI9XCIgfHwgYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJuYW1lKHRoaXMuZ2V0U2VjdGlvbigpKTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEwIC8qIEFmdGVyQXR0cmlidXRlTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVBZnRlckF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTEgLyogQmVmb3JlQXR0cmlidXRlVmFsdWUgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDggLyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDkgLyogSW5BdHRyaWJ1dGVOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTIgLyogSW5BdHRyaWJ1dGVWYWx1ZURxICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTMgLyogSW5BdHRyaWJ1dGVWYWx1ZVNxICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTQgLyogSW5BdHRyaWJ1dGVWYWx1ZU5xICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07IC8vIFJlY29uc3VtZSB0b2tlblxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmhhbmRsZUluQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoYywgcXVvdGUpIHtcbiAgICAgICAgaWYgKGMgPT09IHF1b3RlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKHF1b3RlKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gOCAvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO1xuICAgICAgICAgICAgdGhpcy5iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNjIgLyogQmVmb3JlRW50aXR5ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluQXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZXMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLmhhbmRsZUluQXR0cmlidXRlVmFsdWUoYywgJ1wiJyk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlcyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5BdHRyaWJ1dGVWYWx1ZShjLCBcIidcIik7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2UoYykgfHwgYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJlbmQobnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDggLyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNvZGVFbnRpdGllcyAmJiBjID09PSBcIiZcIikge1xuICAgICAgICAgICAgdGhpcy5lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7XG4gICAgICAgICAgICB0aGlzLmJhc2VTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA2MiAvKiBCZWZvcmVFbnRpdHkgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9XG4gICAgICAgICAgICBjID09PSBcIltcIlxuICAgICAgICAgICAgICAgID8gMjMgLyogQmVmb3JlQ2RhdGExICovXG4gICAgICAgICAgICAgICAgOiBjID09PSBcIi1cIlxuICAgICAgICAgICAgICAgICAgICA/IDE4IC8qIEJlZm9yZUNvbW1lbnQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiAxNiAvKiBJbkRlY2xhcmF0aW9uICovO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uZGVjbGFyYXRpb24odGhpcy5nZXRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbih0aGlzLmdldFNlY3Rpb24oKSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlQ29tbWVudCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIi1cIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxOSAvKiBJbkNvbW1lbnQgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTYgLyogSW5EZWNsYXJhdGlvbiAqLztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluQ29tbWVudCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIi1cIilcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMjEgLyogQWZ0ZXJDb21tZW50MSAqLztcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJblNwZWNpYWxDb21tZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmNvbW1lbnQodGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLl9pbmRleCkpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUFmdGVyQ29tbWVudDEgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMjIgLyogQWZ0ZXJDb21tZW50MiAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTkgLyogSW5Db21tZW50ICovO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQWZ0ZXJDb21tZW50MiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIDIgdHJhaWxpbmcgY2hhcnNcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY29tbWVudCh0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuX2luZGV4IC0gMikpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxOSAvKiBJbkNvbW1lbnQgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZTogc3RheSBpbiBBRlRFUl9DT01NRU5UXzIgKGAtLS0+YClcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVDZGF0YTYgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMjkgLyogSW5DZGF0YSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxNiAvKiBJbkRlY2xhcmF0aW9uICovO1xuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluQ2RhdGEgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCJdXCIpXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDMwIC8qIEFmdGVyQ2RhdGExICovO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUFmdGVyQ2RhdGExID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiXVwiKVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAzMSAvKiBBZnRlckNkYXRhMiAqLztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAyOSAvKiBJbkNkYXRhICovO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUFmdGVyQ2RhdGEyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgMiB0cmFpbGluZyBjaGFyc1xuICAgICAgICAgICAgdGhpcy5jYnMub25jZGF0YSh0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuX2luZGV4IC0gMikpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjICE9PSBcIl1cIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAyOSAvKiBJbkNkYXRhICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2U6IHN0YXkgaW4gQUZURVJfQ0RBVEFfMiAoYF1dXT5gKVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZVNwZWNpYWxTID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiY1wiIHx8IGMgPT09IFwiQ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDM0IC8qIEJlZm9yZVNjcmlwdDEgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCJ0XCIgfHwgYyA9PT0gXCJUXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNDQgLyogQmVmb3JlU3R5bGUxICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAzIC8qIEluVGFnTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07IC8vIENvbnN1bWUgdGhlIHRva2VuIGFnYWluXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVTcGVjaWFsU0VuZCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWNpYWwgPT09IDIgLyogU2NyaXB0ICovICYmIChjID09PSBcImNcIiB8fCBjID09PSBcIkNcIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMzkgLyogQWZ0ZXJTY3JpcHQxICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3BlY2lhbCA9PT0gMyAvKiBTdHlsZSAqLyAmJiAoYyA9PT0gXCJ0XCIgfHwgYyA9PT0gXCJUXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDQ4IC8qIEFmdGVyU3R5bGUxICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZVNwZWNpYWxMYXN0ID0gZnVuY3Rpb24gKGMsIHNwZWNpYWwpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY2lhbCA9IHNwZWNpYWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUgPSAzIC8qIEluVGFnTmFtZSAqLztcbiAgICAgICAgdGhpcy5faW5kZXgtLTsgLy8gQ29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVBZnRlclNwZWNpYWxMYXN0ID0gZnVuY3Rpb24gKGMsIHNlY3Rpb25TdGFydE9mZnNldCkge1xuICAgICAgICBpZiAoYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5zcGVjaWFsID0gMSAvKiBOb25lICovO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA2IC8qIEluQ2xvc2luZ1RhZ05hbWUgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4IC0gc2VjdGlvblN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTsgLy8gUmVjb25zdW1lIHRoZSB0b2tlblxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgIH07XG4gICAgLy8gRm9yIGVudGl0aWVzIHRlcm1pbmF0ZWQgd2l0aCBhIHNlbWljb2xvblxuICAgIFRva2VuaXplci5wcm90b3R5cGUucGFyc2VGaXhlZEVudGl0eSA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7IG1hcCA9IHRoaXMueG1sTW9kZSA/IHhtbF9qc29uXzEuZGVmYXVsdCA6IGVudGl0aWVzX2pzb25fMS5kZWZhdWx0OyB9XG4gICAgICAgIC8vIE9mZnNldCA9IDFcbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0ICsgMSA8IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMuc2VjdGlvblN0YXJ0ICsgMSwgdGhpcy5faW5kZXgpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGVudGl0eSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRQYXJ0aWFsKG1hcFtlbnRpdHldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUGFyc2VzIGxlZ2FjeSBlbnRpdGllcyAod2l0aG91dCB0cmFpbGluZyBzZW1pY29sb24pXG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5wYXJzZUxlZ2FjeUVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zZWN0aW9uU3RhcnQgKyAxO1xuICAgICAgICAvLyBUaGUgbWF4IGxlbmd0aCBvZiBsZWdhY3kgZW50aXRpZXMgaXMgNlxuICAgICAgICB2YXIgbGltaXQgPSBNYXRoLm1pbih0aGlzLl9pbmRleCAtIHN0YXJ0LCA2KTtcbiAgICAgICAgd2hpbGUgKGxpbWl0ID49IDIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBtaW4gbGVuZ3RoIG9mIGxlZ2FjeSBlbnRpdGllcyBpcyAyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gdGhpcy5idWZmZXIuc3Vic3RyKHN0YXJ0LCBsaW1pdCk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxlZ2FjeV9qc29uXzEuZGVmYXVsdCwgZW50aXR5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFBhcnRpYWwobGVnYWN5X2pzb25fMS5kZWZhdWx0W2VudGl0eV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ICs9IGxpbWl0ICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5OYW1lZEVudGl0eSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIjtcIikge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUZpeGVkRW50aXR5KCk7XG4gICAgICAgICAgICAvLyBSZXRyeSBhcyBsZWdhY3kgZW50aXR5IGlmIGVudGl0eSB3YXNuJ3QgcGFyc2VkXG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlU3RhdGUgPT09IDEgLyogVGV4dCAqLyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ICsgMSA8IHRoaXMuX2luZGV4ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMueG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VMZWdhY3lFbnRpdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5iYXNlU3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgPCBcIjBcIiB8fCBjID4gXCI5XCIpICYmICFpc0FTQ0lJQWxwaGEoYykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnhtbE1vZGUgfHwgdGhpcy5zZWN0aW9uU3RhcnQgKyAxID09PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5iYXNlU3RhdGUgIT09IDEgLyogVGV4dCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjICE9PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBhcyBsZWdhY3kgZW50aXR5LCB3aXRob3V0IGFsbG93aW5nIGFkZGl0aW9uYWwgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUZpeGVkRW50aXR5KGxlZ2FjeV9qc29uXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUxlZ2FjeUVudGl0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLmJhc2VTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZGVjb2RlTnVtZXJpY0VudGl0eSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJhc2UsIHN0cmljdCkge1xuICAgICAgICB2YXIgc2VjdGlvblN0YXJ0ID0gdGhpcy5zZWN0aW9uU3RhcnQgKyBvZmZzZXQ7XG4gICAgICAgIGlmIChzZWN0aW9uU3RhcnQgIT09IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBlbnRpdHlcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcoc2VjdGlvblN0YXJ0LCB0aGlzLl9pbmRleCk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoZW50aXR5LCBiYXNlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFBhcnRpYWwoZGVjb2RlX2NvZGVwb2ludF8xLmRlZmF1bHQocGFyc2VkKSk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHN0cmljdCA/IHRoaXMuX2luZGV4ICsgMSA6IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5iYXNlU3RhdGU7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5OdW1lcmljRW50aXR5ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU51bWVyaWNFbnRpdHkoMiwgMTAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCBcIjBcIiB8fCBjID4gXCI5XCIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy54bWxNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVOdW1lcmljRW50aXR5KDIsIDEwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluSGV4RW50aXR5ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU51bWVyaWNFbnRpdHkoMywgMTYsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjIDwgXCJhXCIgfHwgYyA+IFwiZlwiKSAmJlxuICAgICAgICAgICAgKGMgPCBcIkFcIiB8fCBjID4gXCJGXCIpICYmXG4gICAgICAgICAgICAoYyA8IFwiMFwiIHx8IGMgPiBcIjlcIikpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy54bWxNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVOdW1lcmljRW50aXR5KDMsIDE2LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCArPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMSAvKiBUZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0ICE9PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5idWZmZXIuc3Vic3RyKHRoaXMuc2VjdGlvblN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlck9mZnNldCArPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNlY3Rpb25TdGFydCA9PT0gdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VjdGlvbiBqdXN0IHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnNlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggLT0gdGhpcy5zZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJPZmZzZXQgKz0gdGhpcy5zZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGJ1ZmZlciwgY2FsbGluZyB0aGUgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFN0YXRlcyB0aGF0IGFyZSBtb3JlIGxpa2VseSB0byBiZSBoaXQgYXJlIGhpZ2hlciB1cCwgYXMgYSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC5cbiAgICAgKi9cbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5faW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGggJiYgdGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuYnVmZmVyLmNoYXJBdCh0aGlzLl9pbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDEgLyogVGV4dCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUZXh0KGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDEyIC8qIEluQXR0cmlidXRlVmFsdWVEcSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDkgLyogSW5BdHRyaWJ1dGVOYW1lICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxOSAvKiBJbkNvbW1lbnQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5Db21tZW50KGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDIwIC8qIEluU3BlY2lhbENvbW1lbnQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5TcGVjaWFsQ29tbWVudChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA4IC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzIC8qIEluVGFnTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNiAvKiBJbkNsb3NpbmdUYWdOYW1lICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMiAvKiBCZWZvcmVUYWdOYW1lICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVRhZ05hbWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTAgLyogQWZ0ZXJBdHRyaWJ1dGVOYW1lICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxMyAvKiBJbkF0dHJpYnV0ZVZhbHVlU3EgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlcyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxMSAvKiBCZWZvcmVBdHRyaWJ1dGVWYWx1ZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1IC8qIEJlZm9yZUNsb3NpbmdUYWdOYW1lICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDcgLyogQWZ0ZXJDbG9zaW5nVGFnTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDMyIC8qIEJlZm9yZVNwZWNpYWxTICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVNwZWNpYWxTKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDIxIC8qIEFmdGVyQ29tbWVudDEgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJDb21tZW50MShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxNCAvKiBJbkF0dHJpYnV0ZVZhbHVlTnEgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQgLyogSW5TZWxmQ2xvc2luZ1RhZyAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblNlbGZDbG9zaW5nVGFnKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDE2IC8qIEluRGVjbGFyYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5EZWNsYXJhdGlvbihjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxNSAvKiBCZWZvcmVEZWNsYXJhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAyMiAvKiBBZnRlckNvbW1lbnQyICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ29tbWVudDIoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTggLyogQmVmb3JlQ29tbWVudCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVDb21tZW50KGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDMzIC8qIEJlZm9yZVNwZWNpYWxTRW5kICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVNwZWNpYWxTRW5kKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDUzIC8qIEJlZm9yZVNwZWNpYWxURW5kICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVBZnRlclNwZWNpYWxURW5kKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDM5IC8qIEFmdGVyU2NyaXB0MSAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJTY3JpcHQxKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQwIC8qIEFmdGVyU2NyaXB0MiAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJTY3JpcHQyKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQxIC8qIEFmdGVyU2NyaXB0MyAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJTY3JpcHQzKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDM0IC8qIEJlZm9yZVNjcmlwdDEgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVNjcmlwdDEodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMzUgLyogQmVmb3JlU2NyaXB0MiAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlU2NyaXB0Mih0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzNiAvKiBCZWZvcmVTY3JpcHQzICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVTY3JpcHQzKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDM3IC8qIEJlZm9yZVNjcmlwdDQgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVNjcmlwdDQodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMzggLyogQmVmb3JlU2NyaXB0NSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVTcGVjaWFsTGFzdChjLCAyIC8qIFNjcmlwdCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNDIgLyogQWZ0ZXJTY3JpcHQ0ICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVBZnRlclNjcmlwdDQodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNDMgLyogQWZ0ZXJTY3JpcHQ1ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyU3BlY2lhbExhc3QoYywgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNDQgLyogQmVmb3JlU3R5bGUxICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVTdHlsZTEodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjkgLyogSW5DZGF0YSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkNkYXRhKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQ1IC8qIEJlZm9yZVN0eWxlMiAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlU3R5bGUyKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQ2IC8qIEJlZm9yZVN0eWxlMyAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlU3R5bGUzKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQ3IC8qIEJlZm9yZVN0eWxlNCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVTcGVjaWFsTGFzdChjLCAzIC8qIFN0eWxlICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0OCAvKiBBZnRlclN0eWxlMSAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJTdHlsZTEodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNDkgLyogQWZ0ZXJTdHlsZTIgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyU3R5bGUyKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDUwIC8qIEFmdGVyU3R5bGUzICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVBZnRlclN0eWxlMyh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1MSAvKiBBZnRlclN0eWxlNCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVBZnRlclNwZWNpYWxMYXN0KGMsIDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDUyIC8qIEJlZm9yZVNwZWNpYWxUICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVTcGVjaWFsVCh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1NCAvKiBCZWZvcmVUaXRsZTEgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVRpdGxlMSh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1NSAvKiBCZWZvcmVUaXRsZTIgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVRpdGxlMih0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1NiAvKiBCZWZvcmVUaXRsZTMgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVRpdGxlMyh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1NyAvKiBCZWZvcmVUaXRsZTQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3BlY2lhbExhc3QoYywgNCAvKiBUaXRsZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTggLyogQWZ0ZXJUaXRsZTEgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyVGl0bGUxKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDU5IC8qIEFmdGVyVGl0bGUyICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVBZnRlclRpdGxlMih0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA2MCAvKiBBZnRlclRpdGxlMyAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJUaXRsZTModGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjEgLyogQWZ0ZXJUaXRsZTQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJTcGVjaWFsTGFzdChjLCA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxNyAvKiBJblByb2Nlc3NpbmdJbnN0cnVjdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJblByb2Nlc3NpbmdJbnN0cnVjdGlvbihjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA2NCAvKiBJbk5hbWVkRW50aXR5ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluTmFtZWRFbnRpdHkoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjMgLyogQmVmb3JlQ2RhdGExICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVDZGF0YTEodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjIgLyogQmVmb3JlRW50aXR5ICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVFbnRpdHkodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjQgLyogQmVmb3JlQ2RhdGEyICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVDZGF0YTIodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjUgLyogQmVmb3JlQ2RhdGEzICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVDZGF0YTModGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMzAgLyogQWZ0ZXJDZGF0YTEgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJDZGF0YTEoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMzEgLyogQWZ0ZXJDZGF0YTIgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJDZGF0YTIoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjYgLyogQmVmb3JlQ2RhdGE0ICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVDZGF0YTQodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjcgLyogQmVmb3JlQ2RhdGE1ICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVDZGF0YTUodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjggLyogQmVmb3JlQ2RhdGE2ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUNkYXRhNihjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA2NiAvKiBJbkhleEVudGl0eSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkhleEVudGl0eShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA2NSAvKiBJbk51bWVyaWNFbnRpdHkgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5OdW1lcmljRW50aXR5KGMpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjMgLyogQmVmb3JlTnVtZXJpY0VudGl0eSAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlTnVtZXJpY0VudGl0eSh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2JzLm9uZXJyb3IoRXJyb3IoXCJ1bmtub3duIF9zdGF0ZVwiKSwgdGhpcy5fc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyByZW1haW5pbmcgZGF0YSwgZW1pdCBpdCBpbiBhIHJlYXNvbmFibGUgd2F5XG4gICAgICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCA8IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsaW5nRGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2JzLm9uZW5kKCk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmhhbmRsZVRyYWlsaW5nRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmJ1ZmZlci5zdWJzdHIodGhpcy5zZWN0aW9uU3RhcnQpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDI5IC8qIEluQ2RhdGEgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID09PSAzMCAvKiBBZnRlckNkYXRhMSAqLyB8fFxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPT09IDMxIC8qIEFmdGVyQ2RhdGEyICovKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmNkYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxOSAvKiBJbkNvbW1lbnQgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID09PSAyMSAvKiBBZnRlckNvbW1lbnQxICovIHx8XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gMjIgLyogQWZ0ZXJDb21tZW50MiAqLykge1xuICAgICAgICAgICAgdGhpcy5jYnMub25jb21tZW50KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA2NCAvKiBJbk5hbWVkRW50aXR5ICovICYmICF0aGlzLnhtbE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VMZWdhY3lFbnRpdHkoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCA8IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLmJhc2VTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsaW5nRGF0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA2NSAvKiBJbk51bWVyaWNFbnRpdHkgKi8gJiYgIXRoaXMueG1sTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVOdW1lcmljRW50aXR5KDIsIDEwLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5iYXNlU3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGluZ0RhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjYgLyogSW5IZXhFbnRpdHkgKi8gJiYgIXRoaXMueG1sTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVOdW1lcmljRW50aXR5KDMsIDE2LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5iYXNlU3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGluZ0RhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gMyAvKiBJblRhZ05hbWUgKi8gJiZcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlICE9PSA4IC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi8gJiZcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlICE9PSAxMSAvKiBCZWZvcmVBdHRyaWJ1dGVWYWx1ZSAqLyAmJlxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgIT09IDEwIC8qIEFmdGVyQXR0cmlidXRlTmFtZSAqLyAmJlxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgIT09IDkgLyogSW5BdHRyaWJ1dGVOYW1lICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gMTMgLyogSW5BdHRyaWJ1dGVWYWx1ZVNxICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gMTIgLyogSW5BdHRyaWJ1dGVWYWx1ZURxICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gMTQgLyogSW5BdHRyaWJ1dGVWYWx1ZU5xICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gNiAvKiBJbkNsb3NpbmdUYWdOYW1lICovKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbnRleHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogRWxzZSwgaWdub3JlIHJlbWFpbmluZyBkYXRhXG4gICAgICAgICAqIFRPRE8gYWRkIGEgd2F5IHRvIHJlbW92ZSBjdXJyZW50IHRhZ1xuICAgICAgICAgKi9cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZ2V0U2VjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5faW5kZXgpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5lbWl0VG9rZW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmNic1tuYW1lXSh0aGlzLmdldFNlY3Rpb24oKSk7XG4gICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmVtaXRQYXJ0aWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VTdGF0ZSAhPT0gMSAvKiBUZXh0ICovKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmRhdGEodmFsdWUpOyAvLyBUT0RPIGltcGxlbWVudCB0aGUgbmV3IGV2ZW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVG9rZW5pemVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRva2VuaXplcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Sc3NIYW5kbGVyID0gZXhwb3J0cy5EZWZhdWx0SGFuZGxlciA9IGV4cG9ydHMuRG9tVXRpbHMgPSBleHBvcnRzLkVsZW1lbnRUeXBlID0gZXhwb3J0cy5Ub2tlbml6ZXIgPSBleHBvcnRzLmNyZWF0ZURvbVN0cmVhbSA9IGV4cG9ydHMucGFyc2VET00gPSBleHBvcnRzLkRvbUhhbmRsZXIgPSBleHBvcnRzLlBhcnNlciA9IHZvaWQgMDtcbnZhciBQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL1BhcnNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcnNlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUGFyc2VyXzEuUGFyc2VyOyB9IH0pO1xudmFyIGRvbWhhbmRsZXJfMSA9IHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9tSGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9taGFuZGxlcl8xLkRvbUhhbmRsZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWZhdWx0SGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9taGFuZGxlcl8xLkRvbUhhbmRsZXI7IH0gfSk7XG4vLyBIZWxwZXIgbWV0aG9kc1xuLyoqXG4gKiBQYXJzZXMgZGF0YSwgcmV0dXJucyB0aGUgcmVzdWx0aW5nIERPTS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0aGF0IHNob3VsZCBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciB0aGUgcGFyc2VyIGFuZCBET00gYnVpbGRlci5cbiAqL1xuZnVuY3Rpb24gcGFyc2VET00oZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBoYW5kbGVyID0gbmV3IGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyKHZvaWQgMCwgb3B0aW9ucyk7XG4gICAgbmV3IFBhcnNlcl8xLlBhcnNlcihoYW5kbGVyLCBvcHRpb25zKS5lbmQoZGF0YSk7XG4gICAgcmV0dXJuIGhhbmRsZXIuZG9tO1xufVxuZXhwb3J0cy5wYXJzZURPTSA9IHBhcnNlRE9NO1xuLyoqXG4gKiBDcmVhdGVzIGEgcGFyc2VyIGluc3RhbmNlLCB3aXRoIGFuIGF0dGFjaGVkIERPTSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSBjYiBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBwYXJzaW5nIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXIgYW5kIERPTSBidWlsZGVyLlxuICogQHBhcmFtIGVsZW1lbnRDYiBBbiBvcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgYSB0YWcgaGFzIGJlZW4gY29tcGxldGVkIGluc2lkZSBvZiB0aGUgRE9NLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEb21TdHJlYW0oY2IsIG9wdGlvbnMsIGVsZW1lbnRDYikge1xuICAgIHZhciBoYW5kbGVyID0gbmV3IGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyKGNiLCBvcHRpb25zLCBlbGVtZW50Q2IpO1xuICAgIHJldHVybiBuZXcgUGFyc2VyXzEuUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVEb21TdHJlYW0gPSBjcmVhdGVEb21TdHJlYW07XG52YXIgVG9rZW5pemVyXzEgPSByZXF1aXJlKFwiLi9Ub2tlbml6ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2tlbml6ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChUb2tlbml6ZXJfMSkuZGVmYXVsdDsgfSB9KTtcbnZhciBFbGVtZW50VHlwZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZG9tZWxlbWVudHR5cGVcIikpO1xuZXhwb3J0cy5FbGVtZW50VHlwZSA9IEVsZW1lbnRUeXBlO1xuLypcbiAqIEFsbCBvZiB0aGUgZm9sbG93aW5nIGV4cG9ydHMgZXhpc3QgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuICogVGhleSBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZCBldmVudHVhbGx5LlxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRmVlZEhhbmRsZXJcIiksIGV4cG9ydHMpO1xuZXhwb3J0cy5Eb21VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZG9tdXRpbHNcIikpO1xudmFyIEZlZWRIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9GZWVkSGFuZGxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJzc0hhbmRsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZlZWRIYW5kbGVyXzEuRmVlZEhhbmRsZXI7IH0gfSk7XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgaXNBcnJheTogX2lzQXJyYXksXG4gIGlzT2JqZWN0OiBfaXNPYmplY3QsXG4gIGlzU3RyaW5nOiBfaXNTdHJpbmcsXG59ID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3Qge1xuICBhc0FycmF5OiBfYXNBcnJheVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3Qge3ByZXBlbmRCYXNlfSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcbmNvbnN0IFJlc29sdmVkQ29udGV4dCA9IHJlcXVpcmUoJy4vUmVzb2x2ZWRDb250ZXh0Jyk7XG5cbmNvbnN0IE1BWF9DT05URVhUX1VSTFMgPSAxMDtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDb250ZXh0UmVzb2x2ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIENvbnRleHRSZXNvbHZlci5cbiAgICpcbiAgICogQHBhcmFtIHNoYXJlZENhY2hlIGEgc2hhcmVkIExSVSBjYWNoZSB3aXRoIGBnZXRgIGFuZCBgc2V0YCBBUElzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe3NoYXJlZENhY2hlfSkge1xuICAgIHRoaXMucGVyT3BDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnNoYXJlZENhY2hlID0gc2hhcmVkQ2FjaGU7XG4gIH1cblxuICBhc3luYyByZXNvbHZlKHtcbiAgICBhY3RpdmVDdHgsIGNvbnRleHQsIGRvY3VtZW50TG9hZGVyLCBiYXNlLCBjeWNsZXMgPSBuZXcgU2V0KClcbiAgfSkge1xuICAgIC8vIHByb2Nlc3MgYEBjb250ZXh0YFxuICAgIGlmKGNvbnRleHQgJiYgX2lzT2JqZWN0KGNvbnRleHQpICYmIGNvbnRleHRbJ0Bjb250ZXh0J10pIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0WydAY29udGV4dCddO1xuICAgIH1cblxuICAgIC8vIGNvbnRleHQgaXMgb25lIG9yIG1vcmUgY29udGV4dHNcbiAgICBjb250ZXh0ID0gX2FzQXJyYXkoY29udGV4dCk7XG5cbiAgICAvLyByZXNvbHZlIGVhY2ggY29udGV4dCBpbiB0aGUgYXJyYXlcbiAgICBjb25zdCBhbGxSZXNvbHZlZCA9IFtdO1xuICAgIGZvcihjb25zdCBjdHggb2YgY29udGV4dCkge1xuICAgICAgaWYoX2lzU3RyaW5nKGN0eCkpIHtcbiAgICAgICAgLy8gc2VlIGlmIGBjdHhgIGhhcyBiZWVuIHJlc29sdmVkIGJlZm9yZS4uLlxuICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLl9nZXQoY3R4KTtcbiAgICAgICAgaWYoIXJlc29sdmVkKSB7XG4gICAgICAgICAgLy8gbm90IHJlc29sdmVkIHlldCwgcmVzb2x2ZVxuICAgICAgICAgIHJlc29sdmVkID0gYXdhaXQgdGhpcy5fcmVzb2x2ZVJlbW90ZUNvbnRleHQoXG4gICAgICAgICAgICB7YWN0aXZlQ3R4LCB1cmw6IGN0eCwgZG9jdW1lbnRMb2FkZXIsIGJhc2UsIGN5Y2xlc30pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIG91dHB1dCBhbmQgY29udGludWVcbiAgICAgICAgaWYoX2lzQXJyYXkocmVzb2x2ZWQpKSB7XG4gICAgICAgICAgYWxsUmVzb2x2ZWQucHVzaCguLi5yZXNvbHZlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxsUmVzb2x2ZWQucHVzaChyZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZihjdHggPT09IG51bGwpIHtcbiAgICAgICAgLy8gaGFuZGxlIGBudWxsYCBjb250ZXh0LCBub3RoaW5nIHRvIGNhY2hlXG4gICAgICAgIGFsbFJlc29sdmVkLnB1c2gobmV3IFJlc29sdmVkQ29udGV4dCh7ZG9jdW1lbnQ6IG51bGx9KSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYoIV9pc09iamVjdChjdHgpKSB7XG4gICAgICAgIF90aHJvd0ludmFsaWRMb2NhbENvbnRleHQoY29udGV4dCk7XG4gICAgICB9XG4gICAgICAvLyBjb250ZXh0IGlzIGFuIG9iamVjdCwgZ2V0L2NyZWF0ZSBgUmVzb2x2ZWRDb250ZXh0YCBmb3IgaXRcbiAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGN0eCk7XG4gICAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLl9nZXQoa2V5KTtcbiAgICAgIGlmKCFyZXNvbHZlZCkge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgc3RhdGljIGBSZXNvbHZlZENvbnRleHRgIGFuZCBjYWNoZSBpdFxuICAgICAgICByZXNvbHZlZCA9IG5ldyBSZXNvbHZlZENvbnRleHQoe2RvY3VtZW50OiBjdHh9KTtcbiAgICAgICAgdGhpcy5fY2FjaGVSZXNvbHZlZENvbnRleHQoe2tleSwgcmVzb2x2ZWQsIHRhZzogJ3N0YXRpYyd9KTtcbiAgICAgIH1cbiAgICAgIGFsbFJlc29sdmVkLnB1c2gocmVzb2x2ZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBhbGxSZXNvbHZlZDtcbiAgfVxuXG4gIF9nZXQoa2V5KSB7XG4gICAgLy8gZ2V0IGtleSBmcm9tIHBlciBvcGVyYXRpb24gY2FjaGU7IG5vIGB0YWdgIGlzIHVzZWQgd2l0aCB0aGlzIGNhY2hlIHNvXG4gICAgLy8gYW55IHJldHJpZXZlZCBjb250ZXh0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGR1cmluZyBhIHNpbmdsZSBvcGVyYXRpb25cbiAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLnBlck9wQ2FjaGUuZ2V0KGtleSk7XG4gICAgaWYoIXJlc29sdmVkKSB7XG4gICAgICAvLyBzZWUgaWYgdGhlIHNoYXJlZCBjYWNoZSBoYXMgYSBgc3RhdGljYCBlbnRyeSBmb3IgdGhpcyBVUkxcbiAgICAgIGNvbnN0IHRhZ01hcCA9IHRoaXMuc2hhcmVkQ2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZih0YWdNYXApIHtcbiAgICAgICAgcmVzb2x2ZWQgPSB0YWdNYXAuZ2V0KCdzdGF0aWMnKTtcbiAgICAgICAgaWYocmVzb2x2ZWQpIHtcbiAgICAgICAgICB0aGlzLnBlck9wQ2FjaGUuc2V0KGtleSwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfVxuXG4gIF9jYWNoZVJlc29sdmVkQ29udGV4dCh7a2V5LCByZXNvbHZlZCwgdGFnfSkge1xuICAgIHRoaXMucGVyT3BDYWNoZS5zZXQoa2V5LCByZXNvbHZlZCk7XG4gICAgaWYodGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB0YWdNYXAgPSB0aGlzLnNoYXJlZENhY2hlLmdldChrZXkpO1xuICAgICAgaWYoIXRhZ01hcCkge1xuICAgICAgICB0YWdNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2hhcmVkQ2FjaGUuc2V0KGtleSwgdGFnTWFwKTtcbiAgICAgIH1cbiAgICAgIHRhZ01hcC5zZXQodGFnLCByZXNvbHZlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfVxuXG4gIGFzeW5jIF9yZXNvbHZlUmVtb3RlQ29udGV4dCh7YWN0aXZlQ3R4LCB1cmwsIGRvY3VtZW50TG9hZGVyLCBiYXNlLCBjeWNsZXN9KSB7XG4gICAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBVUkwgYW5kIGZldGNoIGNvbnRleHRcbiAgICB1cmwgPSBwcmVwZW5kQmFzZShiYXNlLCB1cmwpO1xuICAgIGNvbnN0IHtjb250ZXh0LCByZW1vdGVEb2N9ID0gYXdhaXQgdGhpcy5fZmV0Y2hDb250ZXh0KFxuICAgICAge2FjdGl2ZUN0eCwgdXJsLCBkb2N1bWVudExvYWRlciwgY3ljbGVzfSk7XG5cbiAgICAvLyB1cGRhdGUgYmFzZSBhY2NvcmRpbmcgdG8gcmVtb3RlIGRvY3VtZW50IGFuZCByZXNvbHZlIGFueSByZWxhdGl2ZSBVUkxzXG4gICAgYmFzZSA9IHJlbW90ZURvYy5kb2N1bWVudFVybCB8fCB1cmw7XG4gICAgX3Jlc29sdmVDb250ZXh0VXJscyh7Y29udGV4dCwgYmFzZX0pO1xuXG4gICAgLy8gcmVzb2x2ZSwgY2FjaGUsIGFuZCByZXR1cm4gY29udGV4dFxuICAgIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgdGhpcy5yZXNvbHZlKFxuICAgICAge2FjdGl2ZUN0eCwgY29udGV4dCwgZG9jdW1lbnRMb2FkZXIsIGJhc2UsIGN5Y2xlc30pO1xuICAgIHRoaXMuX2NhY2hlUmVzb2x2ZWRDb250ZXh0KHtrZXk6IHVybCwgcmVzb2x2ZWQsIHRhZzogcmVtb3RlRG9jLnRhZ30pO1xuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfVxuXG4gIGFzeW5jIF9mZXRjaENvbnRleHQoe2FjdGl2ZUN0eCwgdXJsLCBkb2N1bWVudExvYWRlciwgY3ljbGVzfSkge1xuICAgIC8vIGNoZWNrIGZvciBtYXggY29udGV4dCBVUkxzIGZldGNoZWQgZHVyaW5nIGEgcmVzb2x2ZSBvcGVyYXRpb25cbiAgICBpZihjeWNsZXMuc2l6ZSA+IE1BWF9DT05URVhUX1VSTFMpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ01heGltdW0gbnVtYmVyIG9mIEBjb250ZXh0IFVSTHMgZXhjZWVkZWQuJyxcbiAgICAgICAgJ2pzb25sZC5Db250ZXh0VXJsRXJyb3InLFxuICAgICAgICB7XG4gICAgICAgICAgY29kZTogYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlID09PSAnanNvbi1sZC0xLjAnID9cbiAgICAgICAgICAgICdsb2FkaW5nIHJlbW90ZSBjb250ZXh0IGZhaWxlZCcgOlxuICAgICAgICAgICAgJ2NvbnRleHQgb3ZlcmZsb3cnLFxuICAgICAgICAgIG1heDogTUFYX0NPTlRFWFRfVVJMU1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgY29udGV4dCBVUkwgY3ljbGVcbiAgICAvLyBzaG9ydGN1dCB0byBhdm9pZCBleHRyYSB3b3JrIHRoYXQgd291bGQgZXZlbnR1YWxseSBoaXQgdGhlIG1heCBhYm92ZVxuICAgIGlmKGN5Y2xlcy5oYXModXJsKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnQ3ljbGljYWwgQGNvbnRleHQgVVJMcyBkZXRlY3RlZC4nLFxuICAgICAgICAnanNvbmxkLkNvbnRleHRVcmxFcnJvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBjb2RlOiBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgPT09ICdqc29uLWxkLTEuMCcgP1xuICAgICAgICAgICAgJ3JlY3Vyc2l2ZSBjb250ZXh0IGluY2x1c2lvbicgOlxuICAgICAgICAgICAgJ2NvbnRleHQgb3ZlcmZsb3cnLFxuICAgICAgICAgIHVybFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB0cmFjayBjeWNsZXNcbiAgICBjeWNsZXMuYWRkKHVybCk7XG5cbiAgICBsZXQgY29udGV4dDtcbiAgICBsZXQgcmVtb3RlRG9jO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlbW90ZURvYyA9IGF3YWl0IGRvY3VtZW50TG9hZGVyKHVybCk7XG4gICAgICBjb250ZXh0ID0gcmVtb3RlRG9jLmRvY3VtZW50IHx8IG51bGw7XG4gICAgICAvLyBwYXJzZSBzdHJpbmcgY29udGV4dCBhcyBKU09OXG4gICAgICBpZihfaXNTdHJpbmcoY29udGV4dCkpIHtcbiAgICAgICAgY29udGV4dCA9IEpTT04ucGFyc2UoY29udGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdEZXJlZmVyZW5jaW5nIGEgVVJMIGRpZCBub3QgcmVzdWx0IGluIGEgdmFsaWQgSlNPTi1MRCBvYmplY3QuICcgK1xuICAgICAgICAnUG9zc2libGUgY2F1c2VzIGFyZSBhbiBpbmFjY2Vzc2libGUgVVJMIHBlcmhhcHMgZHVlIHRvICcgK1xuICAgICAgICAnYSBzYW1lLW9yaWdpbiBwb2xpY3kgKGVuc3VyZSB0aGUgc2VydmVyIHVzZXMgQ09SUyBpZiB5b3UgYXJlICcgK1xuICAgICAgICAndXNpbmcgY2xpZW50LXNpZGUgSmF2YVNjcmlwdCksIHRvbyBtYW55IHJlZGlyZWN0cywgYSAnICtcbiAgICAgICAgJ25vbi1KU09OIHJlc3BvbnNlLCBvciBtb3JlIHRoYW4gb25lIEhUVFAgTGluayBIZWFkZXIgd2FzICcgK1xuICAgICAgICAncHJvdmlkZWQgZm9yIGEgcmVtb3RlIGNvbnRleHQuJyxcbiAgICAgICAgJ2pzb25sZC5JbnZhbGlkVXJsJyxcbiAgICAgICAge2NvZGU6ICdsb2FkaW5nIHJlbW90ZSBjb250ZXh0IGZhaWxlZCcsIHVybCwgY2F1c2U6IGV9KTtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgY3R4IGlzIGFuIG9iamVjdFxuICAgIGlmKCFfaXNPYmplY3QoY29udGV4dCkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0RlcmVmZXJlbmNpbmcgYSBVUkwgZGlkIG5vdCByZXN1bHQgaW4gYSBKU09OIG9iamVjdC4gVGhlICcgK1xuICAgICAgICAncmVzcG9uc2Ugd2FzIHZhbGlkIEpTT04sIGJ1dCBpdCB3YXMgbm90IGEgSlNPTiBvYmplY3QuJyxcbiAgICAgICAgJ2pzb25sZC5JbnZhbGlkVXJsJywge2NvZGU6ICdpbnZhbGlkIHJlbW90ZSBjb250ZXh0JywgdXJsfSk7XG4gICAgfVxuXG4gICAgLy8gdXNlIGVtcHR5IGNvbnRleHQgaWYgbm8gQGNvbnRleHQga2V5IGlzIHByZXNlbnRcbiAgICBpZighKCdAY29udGV4dCcgaW4gY29udGV4dCkpIHtcbiAgICAgIGNvbnRleHQgPSB7J0Bjb250ZXh0Jzoge319O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0geydAY29udGV4dCc6IGNvbnRleHRbJ0Bjb250ZXh0J119O1xuICAgIH1cblxuICAgIC8vIGFwcGVuZCBAY29udGV4dCBVUkwgdG8gY29udGV4dCBpZiBnaXZlblxuICAgIGlmKHJlbW90ZURvYy5jb250ZXh0VXJsKSB7XG4gICAgICBpZighX2lzQXJyYXkoY29udGV4dFsnQGNvbnRleHQnXSkpIHtcbiAgICAgICAgY29udGV4dFsnQGNvbnRleHQnXSA9IFtjb250ZXh0WydAY29udGV4dCddXTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHRbJ0Bjb250ZXh0J10ucHVzaChyZW1vdGVEb2MuY29udGV4dFVybCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtjb250ZXh0LCByZW1vdGVEb2N9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBfdGhyb3dJbnZhbGlkTG9jYWxDb250ZXh0KGN0eCkge1xuICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBjb250ZXh0IG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtcbiAgICAgIGNvZGU6ICdpbnZhbGlkIGxvY2FsIGNvbnRleHQnLCBjb250ZXh0OiBjdHhcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFsbCByZWxhdGl2ZSBgQGNvbnRleHRgIFVSTHMgaW4gdGhlIGdpdmVuIGNvbnRleHQgYnkgaW5saW5lXG4gKiByZXBsYWNpbmcgdGhlbSB3aXRoIGFic29sdXRlIFVSTHMuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgdGhlIGNvbnRleHQuXG4gKiBAcGFyYW0gYmFzZSB0aGUgYmFzZSBJUkkgdG8gdXNlIHRvIHJlc29sdmUgcmVsYXRpdmUgSVJJcy5cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVDb250ZXh0VXJscyh7Y29udGV4dCwgYmFzZX0pIHtcbiAgaWYoIWNvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjdHggPSBjb250ZXh0WydAY29udGV4dCddO1xuXG4gIGlmKF9pc1N0cmluZyhjdHgpKSB7XG4gICAgY29udGV4dFsnQGNvbnRleHQnXSA9IHByZXBlbmRCYXNlKGJhc2UsIGN0eCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYoX2lzQXJyYXkoY3R4KSkge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjdHgubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBjdHhbaV07XG4gICAgICBpZihfaXNTdHJpbmcoZWxlbWVudCkpIHtcbiAgICAgICAgY3R4W2ldID0gcHJlcGVuZEJhc2UoYmFzZSwgZWxlbWVudCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYoX2lzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgIF9yZXNvbHZlQ29udGV4dFVybHMoe2NvbnRleHQ6IHsnQGNvbnRleHQnOiBlbGVtZW50fSwgYmFzZX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZighX2lzT2JqZWN0KGN0eCkpIHtcbiAgICAvLyBubyBAY29udGV4dCBVUkxzIGNhbiBiZSBmb3VuZCBpbiBub24tb2JqZWN0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY3R4IGlzIGFuIG9iamVjdCwgcmVzb2x2ZSBhbnkgY29udGV4dCBVUkxzIGluIHRlcm1zXG4gIGZvcihjb25zdCB0ZXJtIGluIGN0eCkge1xuICAgIF9yZXNvbHZlQ29udGV4dFVybHMoe2NvbnRleHQ6IGN0eFt0ZXJtXSwgYmFzZX0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBKc29uTGRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBKU09OLUxEIEVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgZXJyb3IgdHlwZS5cbiAgICogQHBhcmFtIGRldGFpbHMgdGhlIGVycm9yIGRldGFpbHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlID0gJ0FuIHVuc3BlY2lmaWVkIEpTT04tTEQgZXJyb3Igb2NjdXJyZWQuJyxcbiAgICBuYW1lID0gJ2pzb25sZC5FcnJvcicsXG4gICAgZGV0YWlscyA9IHt9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBqc29ubGQgPT4ge1xuICBjbGFzcyBKc29uTGRQcm9jZXNzb3Ige1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdbb2JqZWN0IEpzb25MZFByb2Nlc3Nvcl0nO1xuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSnNvbkxkUHJvY2Vzc29yLCAncHJvdG90eXBlJywge1xuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEpzb25MZFByb2Nlc3Nvci5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IEpzb25MZFByb2Nlc3NvclxuICB9KTtcblxuICAvLyBUaGUgV2ViIElETCB0ZXN0IGhhcm5lc3Mgd2lsbCBjaGVjayB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgZGVmaW5lZCBpblxuICAvLyB0aGUgZnVuY3Rpb25zIGJlbG93LiBUaGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgbXVzdCBleGFjdGx5IG1hdGNoIHRoZVxuICAvLyByZXF1aXJlZCAobm9uLW9wdGlvbmFsKSBwYXJhbWV0ZXJzIG9mIHRoZSBKc29uTGRQcm9jZXNzb3IgaW50ZXJmYWNlIGFzXG4gIC8vIGRlZmluZWQgaGVyZTpcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2pzb24tbGQtYXBpLyN0aGUtanNvbmxkcHJvY2Vzc29yLWludGVyZmFjZVxuXG4gIEpzb25MZFByb2Nlc3Nvci5jb21wYWN0ID0gZnVuY3Rpb24oaW5wdXQsIGN0eCkge1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjb21wYWN0LCB0b28gZmV3IGFyZ3VtZW50cy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBqc29ubGQuY29tcGFjdChpbnB1dCwgY3R4KTtcbiAgfTtcbiAgSnNvbkxkUHJvY2Vzc29yLmV4cGFuZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGV4cGFuZCwgdG9vIGZldyBhcmd1bWVudHMuJykpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbmxkLmV4cGFuZChpbnB1dCk7XG4gIH07XG4gIEpzb25MZFByb2Nlc3Nvci5mbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgZmxhdHRlbiwgdG9vIGZldyBhcmd1bWVudHMuJykpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbmxkLmZsYXR0ZW4oaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBKc29uTGRQcm9jZXNzb3I7XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRPRE86IG1vdmUgYE5RdWFkc2AgdG8gaXRzIG93biBwYWNrYWdlXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3JkZi1jYW5vbml6ZScpLk5RdWFkcztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuLyogZ2xvYmFsIE5vZGUsIFhNTFNlcmlhbGl6ZXIgKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuICBSREZfTEFOR1NUUklORyxcbiAgUkRGX1BMQUlOX0xJVEVSQUwsXG4gIFJERl9PQkpFQ1QsXG4gIFJERl9YTUxfTElURVJBTCxcbiAgWFNEX1NUUklORyxcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5sZXQgX05vZGU7XG5pZih0eXBlb2YgTm9kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgX05vZGUgPSBOb2RlO1xufSBlbHNlIHtcbiAgX05vZGUgPSB7XG4gICAgRUxFTUVOVF9OT0RFOiAxLFxuICAgIEFUVFJJQlVURV9OT0RFOiAyLFxuICAgIFRFWFRfTk9ERTogMyxcbiAgICBDREFUQV9TRUNUSU9OX05PREU6IDQsXG4gICAgRU5USVRZX1JFRkVSRU5DRV9OT0RFOiA1LFxuICAgIEVOVElUWV9OT0RFOiA2LFxuICAgIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTogNyxcbiAgICBDT01NRU5UX05PREU6IDgsXG4gICAgRE9DVU1FTlRfTk9ERTogOSxcbiAgICBET0NVTUVOVF9UWVBFX05PREU6IDEwLFxuICAgIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6IDExLFxuICAgIE5PVEFUSU9OX05PREU6IDEyXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmRmYSB7XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIFJERiBkYXRhc2V0IGZvdW5kIHZpYSB0aGUgZGF0YSBvYmplY3QgZnJvbSB0aGUgUkRGYSBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBSREZhIEFQSSBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgUkRGIGRhdGFzZXQuXG4gICAqL1xuICBwYXJzZShkYXRhKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHt9O1xuICAgIGRhdGFzZXRbJ0BkZWZhdWx0J10gPSBbXTtcblxuICAgIGNvbnN0IHN1YmplY3RzID0gZGF0YS5nZXRTdWJqZWN0cygpO1xuICAgIGZvcihsZXQgc2kgPSAwOyBzaSA8IHN1YmplY3RzLmxlbmd0aDsgKytzaSkge1xuICAgICAgY29uc3Qgc3ViamVjdCA9IHN1YmplY3RzW3NpXTtcbiAgICAgIGlmKHN1YmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBhbGwgcmVsYXRlZCB0cmlwbGVzXG4gICAgICBjb25zdCB0cmlwbGVzID0gZGF0YS5nZXRTdWJqZWN0VHJpcGxlcyhzdWJqZWN0KTtcbiAgICAgIGlmKHRyaXBsZXMgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmVkaWNhdGVzID0gdHJpcGxlcy5wcmVkaWNhdGVzO1xuICAgICAgZm9yKGNvbnN0IHByZWRpY2F0ZSBpbiBwcmVkaWNhdGVzKSB7XG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBvYmplY3RzXG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSBwcmVkaWNhdGVzW3ByZWRpY2F0ZV0ub2JqZWN0cztcbiAgICAgICAgZm9yKGxldCBvaSA9IDA7IG9pIDwgb2JqZWN0cy5sZW5ndGg7ICsrb2kpIHtcbiAgICAgICAgICBjb25zdCBvYmplY3QgPSBvYmplY3RzW29pXTtcblxuICAgICAgICAgIC8vIGNyZWF0ZSBSREYgdHJpcGxlXG4gICAgICAgICAgY29uc3QgdHJpcGxlID0ge307XG5cbiAgICAgICAgICAvLyBhZGQgc3ViamVjdFxuICAgICAgICAgIGlmKHN1YmplY3QuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgICAgICAgdHJpcGxlLnN1YmplY3QgPSB7dHlwZTogJ2JsYW5rIG5vZGUnLCB2YWx1ZTogc3ViamVjdH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyaXBsZS5zdWJqZWN0ID0ge3R5cGU6ICdJUkknLCB2YWx1ZTogc3ViamVjdH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHByZWRpY2F0ZVxuICAgICAgICAgIGlmKHByZWRpY2F0ZS5pbmRleE9mKCdfOicpID09PSAwKSB7XG4gICAgICAgICAgICB0cmlwbGUucHJlZGljYXRlID0ge3R5cGU6ICdibGFuayBub2RlJywgdmFsdWU6IHByZWRpY2F0ZX07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyaXBsZS5wcmVkaWNhdGUgPSB7dHlwZTogJ0lSSScsIHZhbHVlOiBwcmVkaWNhdGV9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNlcmlhbGl6ZSBYTUwgbGl0ZXJhbFxuICAgICAgICAgIGxldCB2YWx1ZSA9IG9iamVjdC52YWx1ZTtcbiAgICAgICAgICBpZihvYmplY3QudHlwZSA9PT0gUkRGX1hNTF9MSVRFUkFMKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIFhNTFNlcmlhbGl6ZXJcbiAgICAgICAgICAgIGNvbnN0IFhNTFNlcmlhbGl6ZXIgPSBnZXRYTUxTZXJpYWxpemVyQ2xhc3MoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGZvcihsZXQgeCA9IDA7IHggPCBvYmplY3QudmFsdWUubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgaWYob2JqZWN0LnZhbHVlW3hdLm5vZGVUeXBlID09PSBfTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKG9iamVjdC52YWx1ZVt4XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZihvYmplY3QudmFsdWVbeF0ubm9kZVR5cGUgPT09IF9Ob2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IG9iamVjdC52YWx1ZVt4XS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhZGQgb2JqZWN0XG4gICAgICAgICAgdHJpcGxlLm9iamVjdCA9IHt9O1xuXG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIElSSVxuICAgICAgICAgIGlmKG9iamVjdC50eXBlID09PSBSREZfT0JKRUNUKSB7XG4gICAgICAgICAgICBpZihvYmplY3QudmFsdWUuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgICAgICAgICB0cmlwbGUub2JqZWN0LnR5cGUgPSAnYmxhbmsgbm9kZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cmlwbGUub2JqZWN0LnR5cGUgPSAnSVJJJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb2JqZWN0IGlzIGEgbGl0ZXJhbFxuICAgICAgICAgICAgdHJpcGxlLm9iamVjdC50eXBlID0gJ2xpdGVyYWwnO1xuICAgICAgICAgICAgaWYob2JqZWN0LnR5cGUgPT09IFJERl9QTEFJTl9MSVRFUkFMKSB7XG4gICAgICAgICAgICAgIGlmKG9iamVjdC5sYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIHRyaXBsZS5vYmplY3QuZGF0YXR5cGUgPSBSREZfTEFOR1NUUklORztcbiAgICAgICAgICAgICAgICB0cmlwbGUub2JqZWN0Lmxhbmd1YWdlID0gb2JqZWN0Lmxhbmd1YWdlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyaXBsZS5vYmplY3QuZGF0YXR5cGUgPSBYU0RfU1RSSU5HO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cmlwbGUub2JqZWN0LmRhdGF0eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyaXBsZS5vYmplY3QudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgIC8vIGFkZCB0cmlwbGUgdG8gZGF0YXNldCBpbiBkZWZhdWx0IGdyYXBoXG4gICAgICAgICAgZGF0YXNldFsnQGRlZmF1bHQnXS5wdXNoKHRyaXBsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YXNldDtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0WE1MU2VyaWFsaXplckNsYXNzKCkge1xuICBpZih0eXBlb2YgWE1MU2VyaWFsaXplciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgneG1sZG9tJykuWE1MU2VyaWFsaXplcjtcbiAgfVxuICByZXR1cm4gWE1MU2VyaWFsaXplcjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOSBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmVxdWVzdFF1ZXVlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaW1wbGUgcXVldWUgZm9yIHJlcXVlc3RpbmcgZG9jdW1lbnRzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSB7fTtcbiAgfVxuXG4gIHdyYXBMb2FkZXIobG9hZGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5fbG9hZGVyID0gbG9hZGVyO1xuICAgIHJldHVybiBmdW5jdGlvbigvKiB1cmwgKi8pIHtcbiAgICAgIHJldHVybiBzZWxmLmFkZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBhc3luYyBhZGQodXJsKSB7XG4gICAgbGV0IHByb21pc2UgPSB0aGlzLl9yZXF1ZXN0c1t1cmxdO1xuICAgIGlmKHByb21pc2UpIHtcbiAgICAgIC8vIFVSTCBhbHJlYWR5IHF1ZXVlZCwgd2FpdCBmb3IgaXQgdG8gbG9hZFxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9taXNlKTtcbiAgICB9XG5cbiAgICAvLyBxdWV1ZSBVUkwgYW5kIGxvYWQgaXRcbiAgICBwcm9taXNlID0gdGhpcy5fcmVxdWVzdHNbdXJsXSA9IHRoaXMuX2xvYWRlcih1cmwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZWxldGUgdGhpcy5fcmVxdWVzdHNbdXJsXTtcbiAgICB9XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XG5cbmNvbnN0IE1BWF9BQ1RJVkVfQ09OVEVYVFMgPSAxMDtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZXNvbHZlZENvbnRleHQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlc29sdmVkQ29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe2RvY3VtZW50fSkge1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAvLyBUT0RPOiBlbmFibGUgY3VzdG9taXphdGlvbiBvZiBwcm9jZXNzZWQgY29udGV4dCBjYWNoZVxuICAgIC8vIFRPRE86IGxpbWl0IGJhc2VkIG9uIHNpemUgb2YgcHJvY2Vzc2VkIGNvbnRleHRzIHZzLiBudW1iZXIgb2YgdGhlbVxuICAgIHRoaXMuY2FjaGUgPSBuZXcgTFJVKHttYXg6IE1BWF9BQ1RJVkVfQ09OVEVYVFN9KTtcbiAgfVxuXG4gIGdldFByb2Nlc3NlZChhY3RpdmVDdHgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoYWN0aXZlQ3R4KTtcbiAgfVxuXG4gIHNldFByb2Nlc3NlZChhY3RpdmVDdHgsIHByb2Nlc3NlZEN0eCkge1xuICAgIHRoaXMuY2FjaGUuc2V0KGFjdGl2ZUN0eCwgcHJvY2Vzc2VkQ3R4KTtcbiAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcblxuY29uc3Qge1xuICBpc0FycmF5OiBfaXNBcnJheSxcbiAgaXNPYmplY3Q6IF9pc09iamVjdCxcbiAgaXNTdHJpbmc6IF9pc1N0cmluZyxcbiAgaXNVbmRlZmluZWQ6IF9pc1VuZGVmaW5lZFxufSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuY29uc3Qge1xuICBpc0xpc3Q6IF9pc0xpc3QsXG4gIGlzVmFsdWU6IF9pc1ZhbHVlLFxuICBpc0dyYXBoOiBfaXNHcmFwaCxcbiAgaXNTaW1wbGVHcmFwaDogX2lzU2ltcGxlR3JhcGgsXG4gIGlzU3ViamVjdFJlZmVyZW5jZTogX2lzU3ViamVjdFJlZmVyZW5jZVxufSA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuXG5jb25zdCB7XG4gIGV4cGFuZElyaTogX2V4cGFuZElyaSxcbiAgZ2V0Q29udGV4dFZhbHVlOiBfZ2V0Q29udGV4dFZhbHVlLFxuICBpc0tleXdvcmQ6IF9pc0tleXdvcmQsXG4gIHByb2Nlc3M6IF9wcm9jZXNzQ29udGV4dCxcbiAgcHJvY2Vzc2luZ01vZGU6IF9wcm9jZXNzaW5nTW9kZVxufSA9IHJlcXVpcmUoJy4vY29udGV4dCcpO1xuXG5jb25zdCB7XG4gIHJlbW92ZUJhc2U6IF9yZW1vdmVCYXNlLFxuICBwcmVwZW5kQmFzZTogX3ByZXBlbmRCYXNlXG59ID0gcmVxdWlyZSgnLi91cmwnKTtcblxuY29uc3Qge1xuICBhZGRWYWx1ZTogX2FkZFZhbHVlLFxuICBhc0FycmF5OiBfYXNBcnJheSxcbiAgY29tcGFyZVNob3J0ZXN0TGVhc3Q6IF9jb21wYXJlU2hvcnRlc3RMZWFzdFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNvbXBhY3RzIGFuIGVsZW1lbnQgdXNpbmcgdGhlIGdpdmVuIGFjdGl2ZSBjb250ZXh0LiBBbGwgdmFsdWVzXG4gKiBtdXN0IGJlIGluIGV4cGFuZGVkIGZvcm0gYmVmb3JlIHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBhY3RpdmUgY29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0gYWN0aXZlUHJvcGVydHkgdGhlIGNvbXBhY3RlZCBwcm9wZXJ0eSBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqICAgICAgICAgIHRvIGNvbXBhY3QsIG51bGwgZm9yIG5vbmUuXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBjb21wYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIGNvbXBhY3Rpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBjb21wYWN0aW9uTWFwIHRoZSBjb21wYWN0aW9uIG1hcCB0byB1c2UuXG4gKlxuICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY29tcGFjdGVkIHZhbHVlLlxuICovXG5hcGkuY29tcGFjdCA9IGFzeW5jICh7XG4gIGFjdGl2ZUN0eCxcbiAgYWN0aXZlUHJvcGVydHkgPSBudWxsLFxuICBlbGVtZW50LFxuICBvcHRpb25zID0ge30sXG4gIGNvbXBhY3Rpb25NYXAgPSAoKSA9PiB1bmRlZmluZWRcbn0pID0+IHtcbiAgLy8gcmVjdXJzaXZlbHkgY29tcGFjdCBhcnJheVxuICBpZihfaXNBcnJheShlbGVtZW50KSkge1xuICAgIGxldCBydmFsID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIGNvbXBhY3QsIGRyb3BwaW5nIGFueSBudWxsIHZhbHVlcyB1bmxlc3MgY3VzdG9tIG1hcHBlZFxuICAgICAgbGV0IGNvbXBhY3RlZCA9IGF3YWl0IGFwaS5jb21wYWN0KHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudFtpXSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY29tcGFjdGlvbk1hcFxuICAgICAgfSk7XG4gICAgICBpZihjb21wYWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgY29tcGFjdGVkID0gYXdhaXQgY29tcGFjdGlvbk1hcCh7XG4gICAgICAgICAgdW5tYXBwZWRWYWx1ZTogZWxlbWVudFtpXSxcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgICAgcGFyZW50OiBlbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGNvbXBhY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaChjb21wYWN0ZWQpO1xuICAgIH1cbiAgICBpZihvcHRpb25zLmNvbXBhY3RBcnJheXMgJiYgcnZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHVzZSBzaW5nbGUgZWxlbWVudCBpZiBubyBjb250YWluZXIgaXMgc3BlY2lmaWVkXG4gICAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICBhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuICAgICAgaWYoY29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBydmFsID0gcnZhbFswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cblxuICAvLyB1c2UgYW55IHNjb3BlZCBjb250ZXh0IG9uIGFjdGl2ZVByb3BlcnR5XG4gIGNvbnN0IGN0eCA9IF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0Bjb250ZXh0Jyk7XG4gIGlmKCFfaXNVbmRlZmluZWQoY3R4KSkge1xuICAgIGFjdGl2ZUN0eCA9IGF3YWl0IF9wcm9jZXNzQ29udGV4dCh7XG4gICAgICBhY3RpdmVDdHgsXG4gICAgICBsb2NhbEN0eDogY3R4LFxuICAgICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgICAgb3ZlcnJpZGVQcm90ZWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICAvLyByZWN1cnNpdmVseSBjb21wYWN0IG9iamVjdFxuICBpZihfaXNPYmplY3QoZWxlbWVudCkpIHtcbiAgICBpZihvcHRpb25zLmxpbmsgJiYgJ0BpZCcgaW4gZWxlbWVudCAmJlxuICAgICAgb3B0aW9ucy5saW5rLmhhc093blByb3BlcnR5KGVsZW1lbnRbJ0BpZCddKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIGEgbGlua2VkIGVsZW1lbnQgdG8gcmV1c2VcbiAgICAgIGNvbnN0IGxpbmtlZCA9IG9wdGlvbnMubGlua1tlbGVtZW50WydAaWQnXV07XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGlua2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmKGxpbmtlZFtpXS5leHBhbmRlZCA9PT0gZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBsaW5rZWRbaV0uY29tcGFjdGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZG8gdmFsdWUgY29tcGFjdGlvbiBvbiBAdmFsdWVzIGFuZCBzdWJqZWN0IHJlZmVyZW5jZXNcbiAgICBpZihfaXNWYWx1ZShlbGVtZW50KSB8fCBfaXNTdWJqZWN0UmVmZXJlbmNlKGVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBydmFsID1cbiAgICAgICAgYXBpLmNvbXBhY3RWYWx1ZSh7YWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgdmFsdWU6IGVsZW1lbnQsIG9wdGlvbnN9KTtcbiAgICAgIGlmKG9wdGlvbnMubGluayAmJiBfaXNTdWJqZWN0UmVmZXJlbmNlKGVsZW1lbnQpKSB7XG4gICAgICAgIC8vIHN0b3JlIGxpbmtlZCBlbGVtZW50XG4gICAgICAgIGlmKCEob3B0aW9ucy5saW5rLmhhc093blByb3BlcnR5KGVsZW1lbnRbJ0BpZCddKSkpIHtcbiAgICAgICAgICBvcHRpb25zLmxpbmtbZWxlbWVudFsnQGlkJ11dID0gW107XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5saW5rW2VsZW1lbnRbJ0BpZCddXS5wdXNoKHtleHBhbmRlZDogZWxlbWVudCwgY29tcGFjdGVkOiBydmFsfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG5cbiAgICAvLyBpZiBleHBhbmRlZCBwcm9wZXJ0eSBpcyBAbGlzdCBhbmQgd2UncmUgY29udGFpbmVkIHdpdGhpbiBhIGxpc3RcbiAgICAvLyBjb250YWluZXIsIHJlY3Vyc2l2ZWx5IGNvbXBhY3QgdGhpcyBpdGVtIHRvIGFuIGFycmF5XG4gICAgaWYoX2lzTGlzdChlbGVtZW50KSkge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gX2dldENvbnRleHRWYWx1ZShcbiAgICAgICAgYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0Bjb250YWluZXInKSB8fCBbXTtcbiAgICAgIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGxpc3QnKSkge1xuICAgICAgICByZXR1cm4gYXBpLmNvbXBhY3Qoe1xuICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50WydAbGlzdCddLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgY29tcGFjdGlvbk1hcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGSVhNRTogYXZvaWQgbWlzdXNlIG9mIGFjdGl2ZSBwcm9wZXJ0eSBhcyBhbiBleHBhbmRlZCBwcm9wZXJ0eT9cbiAgICBjb25zdCBpbnNpZGVSZXZlcnNlID0gKGFjdGl2ZVByb3BlcnR5ID09PSAnQHJldmVyc2UnKTtcblxuICAgIGNvbnN0IHJ2YWwgPSB7fTtcblxuICAgIC8vIG9yaWdpbmFsIGNvbnRleHQgYmVmb3JlIGFwcGx5aW5nIHByb3BlcnR5LXNjb3BlZCBhbmQgbG9jYWwgY29udGV4dHNcbiAgICBjb25zdCBpbnB1dEN0eCA9IGFjdGl2ZUN0eDtcblxuICAgIC8vIHJldmVydCB0byBwcmV2aW91cyBjb250ZXh0LCBpZiB0aGVyZSBpcyBvbmUsXG4gICAgLy8gYW5kIGVsZW1lbnQgaXMgbm90IGEgdmFsdWUgb2JqZWN0IG9yIGEgbm9kZSByZWZlcmVuY2VcbiAgICBpZighX2lzVmFsdWUoZWxlbWVudCkgJiYgIV9pc1N1YmplY3RSZWZlcmVuY2UoZWxlbWVudCkpIHtcbiAgICAgIGFjdGl2ZUN0eCA9IGFjdGl2ZUN0eC5yZXZlcnRUb1ByZXZpb3VzQ29udGV4dCgpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IHByb3BlcnR5LXNjb3BlZCBjb250ZXh0IGFmdGVyIHJldmVydGluZyB0ZXJtLXNjb3BlZCBjb250ZXh0XG4gICAgY29uc3QgcHJvcGVydHlTY29wZWRDdHggPVxuICAgICAgX2dldENvbnRleHRWYWx1ZShpbnB1dEN0eCwgYWN0aXZlUHJvcGVydHksICdAY29udGV4dCcpO1xuICAgIGlmKCFfaXNVbmRlZmluZWQocHJvcGVydHlTY29wZWRDdHgpKSB7XG4gICAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGxvY2FsQ3R4OiBwcm9wZXJ0eVNjb3BlZEN0eCxcbiAgICAgICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgICAgICBvdmVycmlkZVByb3RlY3RlZDogdHJ1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYob3B0aW9ucy5saW5rICYmICdAaWQnIGluIGVsZW1lbnQpIHtcbiAgICAgIC8vIHN0b3JlIGxpbmtlZCBlbGVtZW50XG4gICAgICBpZighb3B0aW9ucy5saW5rLmhhc093blByb3BlcnR5KGVsZW1lbnRbJ0BpZCddKSkge1xuICAgICAgICBvcHRpb25zLmxpbmtbZWxlbWVudFsnQGlkJ11dID0gW107XG4gICAgICB9XG4gICAgICBvcHRpb25zLmxpbmtbZWxlbWVudFsnQGlkJ11dLnB1c2goe2V4cGFuZGVkOiBlbGVtZW50LCBjb21wYWN0ZWQ6IHJ2YWx9KTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgY29udGV4dCBkZWZpbmVkIG9uIGFuIGFsaWFzIG9mIEB0eXBlXG4gICAgLy8gaWYga2V5IGlzIEB0eXBlIGFuZCBhbnkgY29tcGFjdGVkIHZhbHVlIGlzIGEgdGVybSBoYXZpbmcgYSBsb2NhbFxuICAgIC8vIGNvbnRleHQsIG92ZXJsYXkgdGhhdCBjb250ZXh0XG4gICAgbGV0IHR5cGVzID0gZWxlbWVudFsnQHR5cGUnXSB8fCBbXTtcbiAgICBpZih0eXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0eXBlcyA9IEFycmF5LmZyb20odHlwZXMpLnNvcnQoKTtcbiAgICB9XG4gICAgLy8gZmluZCBhbGwgdHlwZS1zY29wZWQgY29udGV4dHMgYmFzZWQgb24gY3VycmVudCBjb250ZXh0LCBwcmlvciB0b1xuICAgIC8vIHVwZGF0aW5nIGl0XG4gICAgY29uc3QgdHlwZUNvbnRleHQgPSBhY3RpdmVDdHg7XG4gICAgZm9yKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgIGNvbnN0IGNvbXBhY3RlZFR5cGUgPSBhcGkuY29tcGFjdElyaShcbiAgICAgICAge2FjdGl2ZUN0eDogdHlwZUNvbnRleHQsIGlyaTogdHlwZSwgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuXG4gICAgICAvLyBVc2UgYW55IHR5cGUtc2NvcGVkIGNvbnRleHQgZGVmaW5lZCBvbiB0aGlzIHZhbHVlXG4gICAgICBjb25zdCBjdHggPSBfZ2V0Q29udGV4dFZhbHVlKGlucHV0Q3R4LCBjb21wYWN0ZWRUeXBlLCAnQGNvbnRleHQnKTtcbiAgICAgIGlmKCFfaXNVbmRlZmluZWQoY3R4KSkge1xuICAgICAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICBsb2NhbEN0eDogY3R4LFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgcHJvcGFnYXRlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcm9jZXNzIGVsZW1lbnQga2V5cyBpbiBvcmRlclxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50KS5zb3J0KCk7XG4gICAgZm9yKGNvbnN0IGV4cGFuZGVkUHJvcGVydHkgb2Yga2V5cykge1xuICAgICAgY29uc3QgZXhwYW5kZWRWYWx1ZSA9IGVsZW1lbnRbZXhwYW5kZWRQcm9wZXJ0eV07XG5cbiAgICAgIC8vIGNvbXBhY3QgQGlkXG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGlkJykge1xuICAgICAgICBsZXQgY29tcGFjdGVkVmFsdWUgPSBfYXNBcnJheShleHBhbmRlZFZhbHVlKS5tYXAoXG4gICAgICAgICAgZXhwYW5kZWRJcmkgPT4gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgaXJpOiBleHBhbmRlZElyaSxcbiAgICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogZmFsc2V9LFxuICAgICAgICAgICAgYmFzZTogb3B0aW9ucy5iYXNlXG4gICAgICAgICAgfSkpO1xuICAgICAgICBpZihjb21wYWN0ZWRWYWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjb21wYWN0ZWRWYWx1ZSA9IGNvbXBhY3RlZFZhbHVlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIGtleXdvcmQgYWxpYXMgYW5kIGFkZCB2YWx1ZVxuICAgICAgICBjb25zdCBhbGlhcyA9IGFwaS5jb21wYWN0SXJpKFxuICAgICAgICAgIHthY3RpdmVDdHgsIGlyaTogJ0BpZCcsIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX19KTtcblxuICAgICAgICBydmFsW2FsaWFzXSA9IGNvbXBhY3RlZFZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcGFjdCBAdHlwZShzKVxuICAgICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0B0eXBlJykge1xuICAgICAgICAvLyByZXNvbHZlIHR5cGUgdmFsdWVzIGFnYWluc3QgcHJldmlvdXMgY29udGV4dFxuICAgICAgICBsZXQgY29tcGFjdGVkVmFsdWUgPSBfYXNBcnJheShleHBhbmRlZFZhbHVlKS5tYXAoXG4gICAgICAgICAgZXhwYW5kZWRJcmkgPT4gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgYWN0aXZlQ3R4OiBpbnB1dEN0eCxcbiAgICAgICAgICAgIGlyaTogZXhwYW5kZWRJcmksXG4gICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgICAgfSkpO1xuICAgICAgICBpZihjb21wYWN0ZWRWYWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjb21wYWN0ZWRWYWx1ZSA9IGNvbXBhY3RlZFZhbHVlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIGtleXdvcmQgYWxpYXMgYW5kIGFkZCB2YWx1ZVxuICAgICAgICBjb25zdCBhbGlhcyA9IGFwaS5jb21wYWN0SXJpKFxuICAgICAgICAgIHthY3RpdmVDdHgsIGlyaTogJ0B0eXBlJywgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICAgIGFjdGl2ZUN0eCwgYWxpYXMsICdAY29udGFpbmVyJykgfHwgW107XG5cbiAgICAgICAgLy8gdHJlYXQgYXMgYXJyYXkgZm9yIEB0eXBlIGlmIEBjb250YWluZXIgaW5jbHVkZXMgQHNldFxuICAgICAgICBjb25zdCB0eXBlQXNTZXQgPVxuICAgICAgICAgIGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpICYmXG4gICAgICAgICAgX3Byb2Nlc3NpbmdNb2RlKGFjdGl2ZUN0eCwgMS4xKTtcbiAgICAgICAgY29uc3QgaXNBcnJheSA9XG4gICAgICAgICAgdHlwZUFzU2V0IHx8IChfaXNBcnJheShjb21wYWN0ZWRWYWx1ZSkgJiYgZXhwYW5kZWRWYWx1ZS5sZW5ndGggPT09IDApO1xuICAgICAgICBfYWRkVmFsdWUocnZhbCwgYWxpYXMsIGNvbXBhY3RlZFZhbHVlLCB7cHJvcGVydHlJc0FycmF5OiBpc0FycmF5fSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgQHJldmVyc2VcbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAcmV2ZXJzZScpIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgY29tcGFjdCBleHBhbmRlZCB2YWx1ZVxuICAgICAgICBjb25zdCBjb21wYWN0ZWRWYWx1ZSA9IGF3YWl0IGFwaS5jb21wYWN0KHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgYWN0aXZlUHJvcGVydHk6ICdAcmV2ZXJzZScsXG4gICAgICAgICAgZWxlbWVudDogZXhwYW5kZWRWYWx1ZSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGNvbXBhY3Rpb25NYXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGRvdWJsZS1yZXZlcnNlZCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvcihjb25zdCBjb21wYWN0ZWRQcm9wZXJ0eSBpbiBjb21wYWN0ZWRWYWx1ZSkge1xuICAgICAgICAgIGlmKGFjdGl2ZUN0eC5tYXBwaW5ncy5oYXMoY29tcGFjdGVkUHJvcGVydHkpICYmXG4gICAgICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KGNvbXBhY3RlZFByb3BlcnR5KS5yZXZlcnNlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbXBhY3RlZFZhbHVlW2NvbXBhY3RlZFByb3BlcnR5XTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRDb250ZXh0VmFsdWUoXG4gICAgICAgICAgICAgIGFjdGl2ZUN0eCwgY29tcGFjdGVkUHJvcGVydHksICdAY29udGFpbmVyJykgfHwgW107XG4gICAgICAgICAgICBjb25zdCB1c2VBcnJheSA9IChcbiAgICAgICAgICAgICAgY29udGFpbmVyLmluY2x1ZGVzKCdAc2V0JykgfHwgIW9wdGlvbnMuY29tcGFjdEFycmF5cyk7XG4gICAgICAgICAgICBfYWRkVmFsdWUoXG4gICAgICAgICAgICAgIHJ2YWwsIGNvbXBhY3RlZFByb3BlcnR5LCB2YWx1ZSwge3Byb3BlcnR5SXNBcnJheTogdXNlQXJyYXl9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb21wYWN0ZWRWYWx1ZVtjb21wYWN0ZWRQcm9wZXJ0eV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoT2JqZWN0LmtleXMoY29tcGFjdGVkVmFsdWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyB1c2Uga2V5d29yZCBhbGlhcyBhbmQgYWRkIHZhbHVlXG4gICAgICAgICAgY29uc3QgYWxpYXMgPSBhcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgICBpcmk6IGV4cGFuZGVkUHJvcGVydHksXG4gICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX2FkZFZhbHVlKHJ2YWwsIGFsaWFzLCBjb21wYWN0ZWRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BwcmVzZXJ2ZScpIHtcbiAgICAgICAgLy8gY29tcGFjdCB1c2luZyBhY3RpdmVQcm9wZXJ0eVxuICAgICAgICBjb25zdCBjb21wYWN0ZWRWYWx1ZSA9IGF3YWl0IGFwaS5jb21wYWN0KHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgICAgZWxlbWVudDogZXhwYW5kZWRWYWx1ZSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGNvbXBhY3Rpb25NYXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIShfaXNBcnJheShjb21wYWN0ZWRWYWx1ZSkgJiYgY29tcGFjdGVkVmFsdWUubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgIF9hZGRWYWx1ZShydmFsLCBleHBhbmRlZFByb3BlcnR5LCBjb21wYWN0ZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBAaW5kZXggcHJvcGVydHlcbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAaW5kZXgnKSB7XG4gICAgICAgIC8vIGRyb3AgQGluZGV4IGlmIGluc2lkZSBhbiBAaW5kZXggY29udGFpbmVyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRDb250ZXh0VmFsdWUoXG4gICAgICAgICAgYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0Bjb250YWluZXInKSB8fCBbXTtcbiAgICAgICAgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAaW5kZXgnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIGtleXdvcmQgYWxpYXMgYW5kIGFkZCB2YWx1ZVxuICAgICAgICBjb25zdCBhbGlhcyA9IGFwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgaXJpOiBleHBhbmRlZFByb3BlcnR5LFxuICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgICAgfSk7XG4gICAgICAgIF9hZGRWYWx1ZShydmFsLCBhbGlhcywgZXhwYW5kZWRWYWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwIGFycmF5IHByb2Nlc3NpbmcgZm9yIGtleXdvcmRzIHRoYXQgYXJlbid0XG4gICAgICAvLyBAZ3JhcGgsIEBsaXN0LCBvciBAaW5jbHVkZWRcbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgIT09ICdAZ3JhcGgnICYmIGV4cGFuZGVkUHJvcGVydHkgIT09ICdAbGlzdCcgJiZcbiAgICAgICAgZXhwYW5kZWRQcm9wZXJ0eSAhPT0gJ0BpbmNsdWRlZCcgJiZcbiAgICAgICAgX2lzS2V5d29yZChleHBhbmRlZFByb3BlcnR5KSkge1xuICAgICAgICAvLyB1c2Uga2V5d29yZCBhbGlhcyBhbmQgYWRkIHZhbHVlIGFzIGlzXG4gICAgICAgIGNvbnN0IGFsaWFzID0gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICBpcmk6IGV4cGFuZGVkUHJvcGVydHksXG4gICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICB9KTtcbiAgICAgICAgX2FkZFZhbHVlKHJ2YWwsIGFsaWFzLCBleHBhbmRlZFZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdGU6IGV4cGFuZGVkIHZhbHVlIG11c3QgYmUgYW4gYXJyYXkgZHVlIHRvIGV4cGFuc2lvbiBhbGdvcml0aG0uXG4gICAgICBpZighX2lzQXJyYXkoZXhwYW5kZWRWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdKU09OLUxEIGV4cGFuc2lvbiBlcnJvcjsgZXhwYW5kZWQgdmFsdWUgbXVzdCBiZSBhbiBhcnJheS4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJlc2VydmUgZW1wdHkgYXJyYXlzXG4gICAgICBpZihleHBhbmRlZFZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBpdGVtQWN0aXZlUHJvcGVydHkgPSBhcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGlyaTogZXhwYW5kZWRQcm9wZXJ0eSxcbiAgICAgICAgICB2YWx1ZTogZXhwYW5kZWRWYWx1ZSxcbiAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9LFxuICAgICAgICAgIHJldmVyc2U6IGluc2lkZVJldmVyc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5lc3RQcm9wZXJ0eSA9IGFjdGl2ZUN0eC5tYXBwaW5ncy5oYXMoaXRlbUFjdGl2ZVByb3BlcnR5KSA/XG4gICAgICAgICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldChpdGVtQWN0aXZlUHJvcGVydHkpWydAbmVzdCddIDogbnVsbDtcbiAgICAgICAgbGV0IG5lc3RSZXN1bHQgPSBydmFsO1xuICAgICAgICBpZihuZXN0UHJvcGVydHkpIHtcbiAgICAgICAgICBfY2hlY2tOZXN0UHJvcGVydHkoYWN0aXZlQ3R4LCBuZXN0UHJvcGVydHksIG9wdGlvbnMpO1xuICAgICAgICAgIGlmKCFfaXNPYmplY3QocnZhbFtuZXN0UHJvcGVydHldKSkge1xuICAgICAgICAgICAgcnZhbFtuZXN0UHJvcGVydHldID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lc3RSZXN1bHQgPSBydmFsW25lc3RQcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgIG5lc3RSZXN1bHQsIGl0ZW1BY3RpdmVQcm9wZXJ0eSwgZXhwYW5kZWRWYWx1ZSwge1xuICAgICAgICAgICAgcHJvcGVydHlJc0FycmF5OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlY3VzaXZlbHkgcHJvY2VzcyBhcnJheSB2YWx1ZXNcbiAgICAgIGZvcihjb25zdCBleHBhbmRlZEl0ZW0gb2YgZXhwYW5kZWRWYWx1ZSkge1xuICAgICAgICAvLyBjb21wYWN0IHByb3BlcnR5IGFuZCBnZXQgY29udGFpbmVyIHR5cGVcbiAgICAgICAgY29uc3QgaXRlbUFjdGl2ZVByb3BlcnR5ID0gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICBpcmk6IGV4cGFuZGVkUHJvcGVydHksXG4gICAgICAgICAgdmFsdWU6IGV4cGFuZGVkSXRlbSxcbiAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9LFxuICAgICAgICAgIHJldmVyc2U6IGluc2lkZVJldmVyc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgaXRlbUFjdGl2ZVByb3BlcnR5IGlzIGEgQG5lc3QgcHJvcGVydHksIGFkZCB2YWx1ZXMgdG8gbmVzdFJlc3VsdCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHJ2YWxcbiAgICAgICAgY29uc3QgbmVzdFByb3BlcnR5ID0gYWN0aXZlQ3R4Lm1hcHBpbmdzLmhhcyhpdGVtQWN0aXZlUHJvcGVydHkpID9cbiAgICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KGl0ZW1BY3RpdmVQcm9wZXJ0eSlbJ0BuZXN0J10gOiBudWxsO1xuICAgICAgICBsZXQgbmVzdFJlc3VsdCA9IHJ2YWw7XG4gICAgICAgIGlmKG5lc3RQcm9wZXJ0eSkge1xuICAgICAgICAgIF9jaGVja05lc3RQcm9wZXJ0eShhY3RpdmVDdHgsIG5lc3RQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYoIV9pc09iamVjdChydmFsW25lc3RQcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICBydmFsW25lc3RQcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmVzdFJlc3VsdCA9IHJ2YWxbbmVzdFByb3BlcnR5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRDb250ZXh0VmFsdWUoXG4gICAgICAgICAgYWN0aXZlQ3R4LCBpdGVtQWN0aXZlUHJvcGVydHksICdAY29udGFpbmVyJykgfHwgW107XG5cbiAgICAgICAgLy8gZ2V0IHNpbXBsZSBAZ3JhcGggb3IgQGxpc3QgdmFsdWUgaWYgYXBwcm9wcmlhdGVcbiAgICAgICAgY29uc3QgaXNHcmFwaCA9IF9pc0dyYXBoKGV4cGFuZGVkSXRlbSk7XG4gICAgICAgIGNvbnN0IGlzTGlzdCA9IF9pc0xpc3QoZXhwYW5kZWRJdGVtKTtcbiAgICAgICAgbGV0IGlubmVyO1xuICAgICAgICBpZihpc0xpc3QpIHtcbiAgICAgICAgICBpbm5lciA9IGV4cGFuZGVkSXRlbVsnQGxpc3QnXTtcbiAgICAgICAgfSBlbHNlIGlmKGlzR3JhcGgpIHtcbiAgICAgICAgICBpbm5lciA9IGV4cGFuZGVkSXRlbVsnQGdyYXBoJ107XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBjb21wYWN0IGV4cGFuZGVkIGl0ZW1cbiAgICAgICAgbGV0IGNvbXBhY3RlZEl0ZW0gPSBhd2FpdCBhcGkuY29tcGFjdCh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGFjdGl2ZVByb3BlcnR5OiBpdGVtQWN0aXZlUHJvcGVydHksXG4gICAgICAgICAgZWxlbWVudDogKGlzTGlzdCB8fCBpc0dyYXBoKSA/IGlubmVyIDogZXhwYW5kZWRJdGVtLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgY29tcGFjdGlvbk1hcFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBoYW5kbGUgQGxpc3RcbiAgICAgICAgaWYoaXNMaXN0KSB7XG4gICAgICAgICAgLy8gZW5zdXJlIEBsaXN0IHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICAgICAgaWYoIV9pc0FycmF5KGNvbXBhY3RlZEl0ZW0pKSB7XG4gICAgICAgICAgICBjb21wYWN0ZWRJdGVtID0gW2NvbXBhY3RlZEl0ZW1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFjb250YWluZXIuaW5jbHVkZXMoJ0BsaXN0JykpIHtcbiAgICAgICAgICAgIC8vIHdyYXAgdXNpbmcgQGxpc3QgYWxpYXNcbiAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW0gPSB7XG4gICAgICAgICAgICAgIFthcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICAgIGlyaTogJ0BsaXN0JyxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgICAgICAgIH0pXTogY29tcGFjdGVkSXRlbVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaW5jbHVkZSBAaW5kZXggZnJvbSBleHBhbmRlZCBAbGlzdCwgaWYgYW55XG4gICAgICAgICAgICBpZignQGluZGV4JyBpbiBleHBhbmRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbVthcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICAgIGlyaTogJ0BpbmRleCcsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgICAgICB9KV0gPSBleHBhbmRlZEl0ZW1bJ0BpbmRleCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfYWRkVmFsdWUobmVzdFJlc3VsdCwgaXRlbUFjdGl2ZVByb3BlcnR5LCBjb21wYWN0ZWRJdGVtLCB7XG4gICAgICAgICAgICAgIHZhbHVlSXNBcnJheTogdHJ1ZSxcbiAgICAgICAgICAgICAgYWxsb3dEdXBsaWNhdGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR3JhcGggb2JqZWN0IGNvbXBhY3Rpb24gY2FzZXNcbiAgICAgICAgaWYoaXNHcmFwaCkge1xuICAgICAgICAgIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGdyYXBoJykgJiYgKGNvbnRhaW5lci5pbmNsdWRlcygnQGlkJykgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbmNsdWRlcygnQGluZGV4JykgJiYgX2lzU2ltcGxlR3JhcGgoZXhwYW5kZWRJdGVtKSkpIHtcbiAgICAgICAgICAgIC8vIGdldCBvciBjcmVhdGUgdGhlIG1hcCBvYmplY3RcbiAgICAgICAgICAgIGxldCBtYXBPYmplY3Q7XG4gICAgICAgICAgICBpZihuZXN0UmVzdWx0Lmhhc093blByb3BlcnR5KGl0ZW1BY3RpdmVQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgbWFwT2JqZWN0ID0gbmVzdFJlc3VsdFtpdGVtQWN0aXZlUHJvcGVydHldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVzdFJlc3VsdFtpdGVtQWN0aXZlUHJvcGVydHldID0gbWFwT2JqZWN0ID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluZGV4IG9uIEBpZCBvciBAaW5kZXggb3IgYWxpYXMgb2YgQG5vbmVcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IChjb250YWluZXIuaW5jbHVkZXMoJ0BpZCcpID9cbiAgICAgICAgICAgICAgZXhwYW5kZWRJdGVtWydAaWQnXSA6IGV4cGFuZGVkSXRlbVsnQGluZGV4J10pIHx8XG4gICAgICAgICAgICAgIGFwaS5jb21wYWN0SXJpKHthY3RpdmVDdHgsIGlyaTogJ0Bub25lJyxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9fSk7XG4gICAgICAgICAgICAvLyBhZGQgY29tcGFjdGVkSXRlbSB0byBtYXAsIHVzaW5nIHZhbHVlIG9mIGBAaWRgIG9yIGEgbmV3IGJsYW5rXG4gICAgICAgICAgICAvLyBub2RlIGlkZW50aWZpZXJcblxuICAgICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgICBtYXBPYmplY3QsIGtleSwgY29tcGFjdGVkSXRlbSwge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5SXNBcnJheTpcbiAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5jb21wYWN0QXJyYXlzIHx8IGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAZ3JhcGgnKSAmJlxuICAgICAgICAgICAgX2lzU2ltcGxlR3JhcGgoZXhwYW5kZWRJdGVtKSkge1xuICAgICAgICAgICAgLy8gY29udGFpbmVyIGluY2x1ZGVzIEBncmFwaCBidXQgbm90IEBpZCBvciBAaW5kZXggYW5kIHZhbHVlIGlzIGFcbiAgICAgICAgICAgIC8vIHNpbXBsZSBncmFwaCBvYmplY3QgYWRkIGNvbXBhY3QgdmFsdWVcbiAgICAgICAgICAgIC8vIGlmIGNvbXBhY3RlZEl0ZW0gY29udGFpbnMgbXVsdGlwbGUgdmFsdWVzLCBpdCBpcyB3cmFwcGVkIGluXG4gICAgICAgICAgICAvLyBgQGluY2x1ZGVkYFxuICAgICAgICAgICAgaWYoX2lzQXJyYXkoY29tcGFjdGVkSXRlbSkgJiYgY29tcGFjdGVkSXRlbS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW0gPSB7J0BpbmNsdWRlZCc6IGNvbXBhY3RlZEl0ZW19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgICBuZXN0UmVzdWx0LCBpdGVtQWN0aXZlUHJvcGVydHksIGNvbXBhY3RlZEl0ZW0sIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUlzQXJyYXk6XG4gICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuY29tcGFjdEFycmF5cyB8fCBjb250YWluZXIuaW5jbHVkZXMoJ0BzZXQnKSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdyYXAgdXNpbmcgQGdyYXBoIGFsaWFzLCByZW1vdmUgYXJyYXkgaWYgb25seSBvbmUgaXRlbSBhbmRcbiAgICAgICAgICAgIC8vIGNvbXBhY3RBcnJheXMgbm90IHNldFxuICAgICAgICAgICAgaWYoX2lzQXJyYXkoY29tcGFjdGVkSXRlbSkgJiYgY29tcGFjdGVkSXRlbS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21wYWN0QXJyYXlzKSB7XG4gICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW0gPSBjb21wYWN0ZWRJdGVtWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcGFjdGVkSXRlbSA9IHtcbiAgICAgICAgICAgICAgW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgICAgICAgaXJpOiAnQGdyYXBoJyxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgICAgICAgIH0pXTogY29tcGFjdGVkSXRlbVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaW5jbHVkZSBAaWQgZnJvbSBleHBhbmRlZCBncmFwaCwgaWYgYW55XG4gICAgICAgICAgICBpZignQGlkJyBpbiBleHBhbmRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbVthcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICAgIGlyaTogJ0BpZCcsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgICAgICB9KV0gPSBleHBhbmRlZEl0ZW1bJ0BpZCddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmNsdWRlIEBpbmRleCBmcm9tIGV4cGFuZGVkIGdyYXBoLCBpZiBhbnlcbiAgICAgICAgICAgIGlmKCdAaW5kZXgnIGluIGV4cGFuZGVkSXRlbSkge1xuICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgICAgICAgaXJpOiAnQGluZGV4JyxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgICAgICAgIH0pXSA9IGV4cGFuZGVkSXRlbVsnQGluZGV4J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYWRkVmFsdWUoXG4gICAgICAgICAgICAgIG5lc3RSZXN1bHQsIGl0ZW1BY3RpdmVQcm9wZXJ0eSwgY29tcGFjdGVkSXRlbSwge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5SXNBcnJheTpcbiAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5jb21wYWN0QXJyYXlzIHx8IGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BsYW5ndWFnZScpIHx8XG4gICAgICAgICAgY29udGFpbmVyLmluY2x1ZGVzKCdAaW5kZXgnKSB8fCBjb250YWluZXIuaW5jbHVkZXMoJ0BpZCcpIHx8XG4gICAgICAgICAgY29udGFpbmVyLmluY2x1ZGVzKCdAdHlwZScpKSB7XG4gICAgICAgICAgLy8gaGFuZGxlIGxhbmd1YWdlIGFuZCBpbmRleCBtYXBzXG4gICAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgbWFwIG9iamVjdFxuICAgICAgICAgIGxldCBtYXBPYmplY3Q7XG4gICAgICAgICAgaWYobmVzdFJlc3VsdC5oYXNPd25Qcm9wZXJ0eShpdGVtQWN0aXZlUHJvcGVydHkpKSB7XG4gICAgICAgICAgICBtYXBPYmplY3QgPSBuZXN0UmVzdWx0W2l0ZW1BY3RpdmVQcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lc3RSZXN1bHRbaXRlbUFjdGl2ZVByb3BlcnR5XSA9IG1hcE9iamVjdCA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAbGFuZ3VhZ2UnKSkge1xuICAgICAgICAgIC8vIGlmIGNvbnRhaW5lciBpcyBhIGxhbmd1YWdlIG1hcCwgc2ltcGxpZnkgY29tcGFjdGVkIHZhbHVlIHRvXG4gICAgICAgICAgLy8gYSBzaW1wbGUgc3RyaW5nXG4gICAgICAgICAgICBpZihfaXNWYWx1ZShjb21wYWN0ZWRJdGVtKSkge1xuICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtID0gY29tcGFjdGVkSXRlbVsnQHZhbHVlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBleHBhbmRlZEl0ZW1bJ0BsYW5ndWFnZSddO1xuICAgICAgICAgIH0gZWxzZSBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BpbmRleCcpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEtleSA9IF9nZXRDb250ZXh0VmFsdWUoXG4gICAgICAgICAgICAgIGFjdGl2ZUN0eCwgaXRlbUFjdGl2ZVByb3BlcnR5LCAnQGluZGV4JykgfHwgJ0BpbmRleCc7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJLZXkgPSBhcGkuY29tcGFjdElyaShcbiAgICAgICAgICAgICAge2FjdGl2ZUN0eCwgaXJpOiBpbmRleEtleSwgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuICAgICAgICAgICAgaWYoaW5kZXhLZXkgPT09ICdAaW5kZXgnKSB7XG4gICAgICAgICAgICAgIGtleSA9IGV4cGFuZGVkSXRlbVsnQGluZGV4J107XG4gICAgICAgICAgICAgIGRlbGV0ZSBjb21wYWN0ZWRJdGVtW2NvbnRhaW5lcktleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQgb3RoZXJzO1xuICAgICAgICAgICAgICBba2V5LCAuLi5vdGhlcnNdID0gX2FzQXJyYXkoY29tcGFjdGVkSXRlbVtpbmRleEtleV0gfHwgW10pO1xuICAgICAgICAgICAgICBpZighX2lzU3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaWxsIHVzZSBAbm9uZSBpZiBpdCBpc24ndCBhIHN0cmluZy5cbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaChvdGhlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wYWN0ZWRJdGVtW2luZGV4S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW1baW5kZXhLZXldID0gb3RoZXJzWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW1baW5kZXhLZXldID0gb3RoZXJzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAaWQnKSkge1xuICAgICAgICAgICAgY29uc3QgaWRLZXkgPSBhcGkuY29tcGFjdElyaSh7YWN0aXZlQ3R4LCBpcmk6ICdAaWQnLFxuICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9fSk7XG4gICAgICAgICAgICBrZXkgPSBjb21wYWN0ZWRJdGVtW2lkS2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb21wYWN0ZWRJdGVtW2lkS2V5XTtcbiAgICAgICAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAdHlwZScpKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlS2V5ID0gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgICAgIGlyaTogJ0B0eXBlJyxcbiAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgdHlwZXM7XG4gICAgICAgICAgICBba2V5LCAuLi50eXBlc10gPSBfYXNBcnJheShjb21wYWN0ZWRJdGVtW3R5cGVLZXldIHx8IFtdKTtcbiAgICAgICAgICAgIHN3aXRjaCh0eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wYWN0ZWRJdGVtW3R5cGVLZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbVt0eXBlS2V5XSA9IHR5cGVzWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW1bdHlwZUtleV0gPSB0eXBlcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgY29tcGFjdGVkSXRlbSBjb250YWlucyBhIHNpbmdsZSBlbnRyeVxuICAgICAgICAgICAgLy8gd2hvc2Uga2V5IG1hcHMgdG8gQGlkLCByZWNvbXBhY3Qgd2l0aG91dCBAdHlwZVxuICAgICAgICAgICAgaWYoT2JqZWN0LmtleXMoY29tcGFjdGVkSXRlbSkubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICdAaWQnIGluIGV4cGFuZGVkSXRlbSkge1xuICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtID0gYXdhaXQgYXBpLmNvbXBhY3Qoe1xuICAgICAgICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICAgICAgICBhY3RpdmVQcm9wZXJ0eTogaXRlbUFjdGl2ZVByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHsnQGlkJzogZXhwYW5kZWRJdGVtWydAaWQnXX0sXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjb21wYWN0aW9uTWFwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIGNvbXBhY3RpbmcgdGhpcyB2YWx1ZSB3aGljaCBoYXMgbm8ga2V5LCBpbmRleCBvbiBAbm9uZVxuICAgICAgICAgIGlmKCFrZXkpIHtcbiAgICAgICAgICAgIGtleSA9IGFwaS5jb21wYWN0SXJpKHthY3RpdmVDdHgsIGlyaTogJ0Bub25lJyxcbiAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhZGQgY29tcGFjdCB2YWx1ZSB0byBtYXAgb2JqZWN0IHVzaW5nIGtleSBmcm9tIGV4cGFuZGVkIHZhbHVlXG4gICAgICAgICAgLy8gYmFzZWQgb24gdGhlIGNvbnRhaW5lciB0eXBlXG4gICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgbWFwT2JqZWN0LCBrZXksIGNvbXBhY3RlZEl0ZW0sIHtcbiAgICAgICAgICAgICAgcHJvcGVydHlJc0FycmF5OiBjb250YWluZXIuaW5jbHVkZXMoJ0BzZXQnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIGFuIGFycmF5IGlmOiBjb21wYWN0QXJyYXlzIGZsYWcgaXMgZmFsc2UsXG4gICAgICAgICAgLy8gQGNvbnRhaW5lciBpcyBAc2V0IG9yIEBsaXN0ICwgdmFsdWUgaXMgYW4gZW1wdHlcbiAgICAgICAgICAvLyBhcnJheSwgb3Iga2V5IGlzIEBncmFwaFxuICAgICAgICAgIGNvbnN0IGlzQXJyYXkgPSAoIW9wdGlvbnMuY29tcGFjdEFycmF5cyB8fFxuICAgICAgICAgICAgY29udGFpbmVyLmluY2x1ZGVzKCdAc2V0JykgfHwgY29udGFpbmVyLmluY2x1ZGVzKCdAbGlzdCcpIHx8XG4gICAgICAgICAgICAoX2lzQXJyYXkoY29tcGFjdGVkSXRlbSkgJiYgY29tcGFjdGVkSXRlbS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICBleHBhbmRlZFByb3BlcnR5ID09PSAnQGxpc3QnIHx8IGV4cGFuZGVkUHJvcGVydHkgPT09ICdAZ3JhcGgnKTtcblxuICAgICAgICAgIC8vIGFkZCBjb21wYWN0IHZhbHVlXG4gICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgbmVzdFJlc3VsdCwgaXRlbUFjdGl2ZVByb3BlcnR5LCBjb21wYWN0ZWRJdGVtLFxuICAgICAgICAgICAge3Byb3BlcnR5SXNBcnJheTogaXNBcnJheX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cblxuICAvLyBvbmx5IHByaW1pdGl2ZXMgcmVtYWluIHdoaWNoIGFyZSBhbHJlYWR5IGNvbXBhY3RcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENvbXBhY3RzIGFuIElSSSBvciBrZXl3b3JkIGludG8gYSB0ZXJtIG9yIHByZWZpeCBpZiBpdCBjYW4gYmUuIElmIHRoZVxuICogSVJJIGhhcyBhbiBhc3NvY2lhdGVkIHZhbHVlIGl0IG1heSBiZSBwYXNzZWQuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgYWN0aXZlIGNvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIGlyaSB0aGUgSVJJIHRvIGNvbXBhY3QuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGNoZWNrIG9yIG51bGwuXG4gKiBAcGFyYW0gcmVsYXRpdmVUbyBvcHRpb25zIGZvciBob3cgdG8gY29tcGFjdCBJUklzOlxuICogICAgICAgICAgdm9jYWI6IHRydWUgdG8gc3BsaXQgYWZ0ZXIgQHZvY2FiLCBmYWxzZSBub3QgdG8uXG4gKiBAcGFyYW0gcmV2ZXJzZSB0cnVlIGlmIGEgcmV2ZXJzZSBwcm9wZXJ0eSBpcyBiZWluZyBjb21wYWN0ZWQsIGZhbHNlIGlmIG5vdC5cbiAqIEBwYXJhbSBiYXNlIHRoZSBhYnNvbHV0ZSBVUkwgdG8gdXNlIGZvciBjb21wYWN0aW5nIGRvY3VtZW50LXJlbGF0aXZlIElSSXMuXG4gKlxuICogQHJldHVybiB0aGUgY29tcGFjdGVkIHRlcm0sIHByZWZpeCwga2V5d29yZCBhbGlhcywgb3IgdGhlIG9yaWdpbmFsIElSSS5cbiAqL1xuYXBpLmNvbXBhY3RJcmkgPSAoe1xuICBhY3RpdmVDdHgsXG4gIGlyaSxcbiAgdmFsdWUgPSBudWxsLFxuICByZWxhdGl2ZVRvID0ge3ZvY2FiOiBmYWxzZX0sXG4gIHJldmVyc2UgPSBmYWxzZSxcbiAgYmFzZSA9IG51bGxcbn0pID0+IHtcbiAgLy8gY2FuJ3QgY29tcGFjdCBudWxsXG4gIGlmKGlyaSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBpcmk7XG4gIH1cblxuICAvLyBpZiBjb250ZXh0IGlzIGZyb20gYSBwcm9wZXJ0eSB0ZXJtIHNjb3BlZCBjb250ZXh0IGNvbXBvc2VkIHdpdGggYVxuICAvLyB0eXBlLXNjb3BlZCBjb250ZXh0LCB0aGVuIHVzZSB0aGUgcHJldmlvdXMgY29udGV4dCBpbnN0ZWFkXG4gIGlmKGFjdGl2ZUN0eC5pc1Byb3BlcnR5VGVybVNjb3BlZCAmJiBhY3RpdmVDdHgucHJldmlvdXNDb250ZXh0KSB7XG4gICAgYWN0aXZlQ3R4ID0gYWN0aXZlQ3R4LnByZXZpb3VzQ29udGV4dDtcbiAgfVxuXG4gIGNvbnN0IGludmVyc2VDdHggPSBhY3RpdmVDdHguZ2V0SW52ZXJzZSgpO1xuXG4gIC8vIGlmIHRlcm0gaXMgYSBrZXl3b3JkLCBpdCBtYXkgYmUgY29tcGFjdGVkIHRvIGEgc2ltcGxlIGFsaWFzXG4gIGlmKF9pc0tleXdvcmQoaXJpKSAmJlxuICAgIGlyaSBpbiBpbnZlcnNlQ3R4ICYmXG4gICAgJ0Bub25lJyBpbiBpbnZlcnNlQ3R4W2lyaV0gJiZcbiAgICAnQHR5cGUnIGluIGludmVyc2VDdHhbaXJpXVsnQG5vbmUnXSAmJlxuICAgICdAbm9uZScgaW4gaW52ZXJzZUN0eFtpcmldWydAbm9uZSddWydAdHlwZSddKSB7XG4gICAgcmV0dXJuIGludmVyc2VDdHhbaXJpXVsnQG5vbmUnXVsnQHR5cGUnXVsnQG5vbmUnXTtcbiAgfVxuXG4gIC8vIHVzZSBpbnZlcnNlIGNvbnRleHQgdG8gcGljayBhIHRlcm0gaWYgaXJpIGlzIHJlbGF0aXZlIHRvIHZvY2FiXG4gIGlmKHJlbGF0aXZlVG8udm9jYWIgJiYgaXJpIGluIGludmVyc2VDdHgpIHtcbiAgICBjb25zdCBkZWZhdWx0TGFuZ3VhZ2UgPSBhY3RpdmVDdHhbJ0BsYW5ndWFnZSddIHx8ICdAbm9uZSc7XG5cbiAgICAvLyBwcmVmZXIgQGluZGV4IGlmIGF2YWlsYWJsZSBpbiB2YWx1ZVxuICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBbXTtcbiAgICBpZihfaXNPYmplY3QodmFsdWUpICYmICdAaW5kZXgnIGluIHZhbHVlICYmICEoJ0BncmFwaCcgaW4gdmFsdWUpKSB7XG4gICAgICBjb250YWluZXJzLnB1c2goJ0BpbmRleCcsICdAaW5kZXhAc2V0Jyk7XG4gICAgfVxuXG4gICAgLy8gaWYgdmFsdWUgaXMgYSBwcmVzZXJ2ZSBvYmplY3QsIHVzZSBpdHMgdmFsdWVcbiAgICBpZihfaXNPYmplY3QodmFsdWUpICYmICdAcHJlc2VydmUnIGluIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlWydAcHJlc2VydmUnXVswXTtcbiAgICB9XG5cbiAgICAvLyBwcmVmZXIgbW9zdCBzcGVjaWZpYyBjb250YWluZXIgaW5jbHVkaW5nIEBncmFwaCwgcHJlZmVyaW5nIEBzZXRcbiAgICAvLyB2YXJpYXRpb25zXG4gICAgaWYoX2lzR3JhcGgodmFsdWUpKSB7XG4gICAgICAvLyBmYXZvciBpbmRleG1hcCBpZiB0aGUgZ3JhcGggaXMgaW5kZXhlZFxuICAgICAgaWYoJ0BpbmRleCcgaW4gdmFsdWUpIHtcbiAgICAgICAgY29udGFpbmVycy5wdXNoKFxuICAgICAgICAgICdAZ3JhcGhAaW5kZXgnLCAnQGdyYXBoQGluZGV4QHNldCcsICdAaW5kZXgnLCAnQGluZGV4QHNldCcpO1xuICAgICAgfVxuICAgICAgLy8gZmF2b3IgaWRtYXAgaWYgdGhlIGdyYXBoIGlzIGhhcyBhbiBAaWRcbiAgICAgIGlmKCdAaWQnIGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnRhaW5lcnMucHVzaChcbiAgICAgICAgICAnQGdyYXBoQGlkJywgJ0BncmFwaEBpZEBzZXQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lcnMucHVzaCgnQGdyYXBoJywgJ0BncmFwaEBzZXQnLCAnQHNldCcpO1xuICAgICAgLy8gYWxsb3cgaW5kZXhtYXAgaWYgdGhlIGdyYXBoIGlzIG5vdCBpbmRleGVkXG4gICAgICBpZighKCdAaW5kZXgnIGluIHZhbHVlKSkge1xuICAgICAgICBjb250YWluZXJzLnB1c2goXG4gICAgICAgICAgJ0BncmFwaEBpbmRleCcsICdAZ3JhcGhAaW5kZXhAc2V0JywgJ0BpbmRleCcsICdAaW5kZXhAc2V0Jyk7XG4gICAgICB9XG4gICAgICAvLyBhbGxvdyBpZG1hcCBpZiB0aGUgZ3JhcGggZG9lcyBub3QgaGF2ZSBhbiBAaWRcbiAgICAgIGlmKCEoJ0BpZCcgaW4gdmFsdWUpKSB7XG4gICAgICAgIGNvbnRhaW5lcnMucHVzaCgnQGdyYXBoQGlkJywgJ0BncmFwaEBpZEBzZXQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoX2lzT2JqZWN0KHZhbHVlKSAmJiAhX2lzVmFsdWUodmFsdWUpKSB7XG4gICAgICBjb250YWluZXJzLnB1c2goJ0BpZCcsICdAaWRAc2V0JywgJ0B0eXBlJywgJ0BzZXRAdHlwZScpO1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHRzIGZvciB0ZXJtIHNlbGVjdGlvbiBiYXNlZCBvbiB0eXBlL2xhbmd1YWdlXG4gICAgbGV0IHR5cGVPckxhbmd1YWdlID0gJ0BsYW5ndWFnZSc7XG4gICAgbGV0IHR5cGVPckxhbmd1YWdlVmFsdWUgPSAnQG51bGwnO1xuXG4gICAgaWYocmV2ZXJzZSkge1xuICAgICAgdHlwZU9yTGFuZ3VhZ2UgPSAnQHR5cGUnO1xuICAgICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9ICdAcmV2ZXJzZSc7XG4gICAgICBjb250YWluZXJzLnB1c2goJ0BzZXQnKTtcbiAgICB9IGVsc2UgaWYoX2lzTGlzdCh2YWx1ZSkpIHtcbiAgICAgIC8vIGNob29zZSB0aGUgbW9zdCBzcGVjaWZpYyB0ZXJtIHRoYXQgd29ya3MgZm9yIGFsbCBlbGVtZW50cyBpbiBAbGlzdFxuICAgICAgLy8gb25seSBzZWxlY3QgQGxpc3QgY29udGFpbmVycyBpZiBAaW5kZXggaXMgTk9UIGluIHZhbHVlXG4gICAgICBpZighKCdAaW5kZXgnIGluIHZhbHVlKSkge1xuICAgICAgICBjb250YWluZXJzLnB1c2goJ0BsaXN0Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0ID0gdmFsdWVbJ0BsaXN0J107XG4gICAgICBpZihsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBhbnkgZW1wdHkgbGlzdCBjYW4gYmUgbWF0Y2hlZCBhZ2FpbnN0IGFueSB0ZXJtIHRoYXQgdXNlcyB0aGVcbiAgICAgICAgLy8gQGxpc3QgY29udGFpbmVyIHJlZ2FyZGxlc3Mgb2YgQHR5cGUgb3IgQGxhbmd1YWdlXG4gICAgICAgIHR5cGVPckxhbmd1YWdlID0gJ0BhbnknO1xuICAgICAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gJ0Bub25lJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb21tb25MYW5ndWFnZSA9IChsaXN0Lmxlbmd0aCA9PT0gMCkgPyBkZWZhdWx0TGFuZ3VhZ2UgOiBudWxsO1xuICAgICAgICBsZXQgY29tbW9uVHlwZSA9IG51bGw7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgbGV0IGl0ZW1MYW5ndWFnZSA9ICdAbm9uZSc7XG4gICAgICAgICAgbGV0IGl0ZW1UeXBlID0gJ0Bub25lJztcbiAgICAgICAgICBpZihfaXNWYWx1ZShpdGVtKSkge1xuICAgICAgICAgICAgaWYoJ0BkaXJlY3Rpb24nIGluIGl0ZW0pIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFuZyA9IChpdGVtWydAbGFuZ3VhZ2UnXSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgY29uc3QgZGlyID0gaXRlbVsnQGRpcmVjdGlvbiddO1xuICAgICAgICAgICAgICBpdGVtTGFuZ3VhZ2UgPSBgJHtsYW5nfV8ke2Rpcn1gO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCdAbGFuZ3VhZ2UnIGluIGl0ZW0pIHtcbiAgICAgICAgICAgICAgaXRlbUxhbmd1YWdlID0gaXRlbVsnQGxhbmd1YWdlJ10udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZignQHR5cGUnIGluIGl0ZW0pIHtcbiAgICAgICAgICAgICAgaXRlbVR5cGUgPSBpdGVtWydAdHlwZSddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcGxhaW4gbGl0ZXJhbFxuICAgICAgICAgICAgICBpdGVtTGFuZ3VhZ2UgPSAnQG51bGwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtVHlwZSA9ICdAaWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihjb21tb25MYW5ndWFnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbW9uTGFuZ3VhZ2UgPSBpdGVtTGFuZ3VhZ2U7XG4gICAgICAgICAgfSBlbHNlIGlmKGl0ZW1MYW5ndWFnZSAhPT0gY29tbW9uTGFuZ3VhZ2UgJiYgX2lzVmFsdWUoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbW1vbkxhbmd1YWdlID0gJ0Bub25lJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoY29tbW9uVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbW9uVHlwZSA9IGl0ZW1UeXBlO1xuICAgICAgICAgIH0gZWxzZSBpZihpdGVtVHlwZSAhPT0gY29tbW9uVHlwZSkge1xuICAgICAgICAgICAgY29tbW9uVHlwZSA9ICdAbm9uZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHRoZXJlIGFyZSBkaWZmZXJlbnQgbGFuZ3VhZ2VzIGFuZCB0eXBlcyBpbiB0aGUgbGlzdCwgc28gY2hvb3NlXG4gICAgICAgICAgLy8gdGhlIG1vc3QgZ2VuZXJpYyB0ZXJtLCBubyBuZWVkIHRvIGtlZXAgaXRlcmF0aW5nIHRoZSBsaXN0XG4gICAgICAgICAgaWYoY29tbW9uTGFuZ3VhZ2UgPT09ICdAbm9uZScgJiYgY29tbW9uVHlwZSA9PT0gJ0Bub25lJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbW1vbkxhbmd1YWdlID0gY29tbW9uTGFuZ3VhZ2UgfHwgJ0Bub25lJztcbiAgICAgICAgY29tbW9uVHlwZSA9IGNvbW1vblR5cGUgfHwgJ0Bub25lJztcbiAgICAgICAgaWYoY29tbW9uVHlwZSAhPT0gJ0Bub25lJykge1xuICAgICAgICAgIHR5cGVPckxhbmd1YWdlID0gJ0B0eXBlJztcbiAgICAgICAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gY29tbW9uVHlwZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gY29tbW9uTGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoX2lzVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGlmKCdAbGFuZ3VhZ2UnIGluIHZhbHVlICYmICEoJ0BpbmRleCcgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgY29udGFpbmVycy5wdXNoKCdAbGFuZ3VhZ2UnLCAnQGxhbmd1YWdlQHNldCcpO1xuICAgICAgICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSB2YWx1ZVsnQGxhbmd1YWdlJ107XG4gICAgICAgICAgY29uc3QgZGlyID0gdmFsdWVbJ0BkaXJlY3Rpb24nXTtcbiAgICAgICAgICBpZihkaXIpIHtcbiAgICAgICAgICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSBgJHt0eXBlT3JMYW5ndWFnZVZhbHVlfV8ke2Rpcn1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCdAZGlyZWN0aW9uJyBpbiB2YWx1ZSAmJiAhKCdAaW5kZXgnIGluIHZhbHVlKSkge1xuICAgICAgICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSBgXyR7dmFsdWVbJ0BkaXJlY3Rpb24nXX1gO1xuICAgICAgICB9IGVsc2UgaWYoJ0B0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgICAgIHR5cGVPckxhbmd1YWdlID0gJ0B0eXBlJztcbiAgICAgICAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gdmFsdWVbJ0B0eXBlJ107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVPckxhbmd1YWdlID0gJ0B0eXBlJztcbiAgICAgICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9ICdAaWQnO1xuICAgICAgfVxuICAgICAgY29udGFpbmVycy5wdXNoKCdAc2V0Jyk7XG4gICAgfVxuXG4gICAgLy8gZG8gdGVybSBzZWxlY3Rpb25cbiAgICBjb250YWluZXJzLnB1c2goJ0Bub25lJyk7XG5cbiAgICAvLyBhbiBpbmRleCBtYXAgY2FuIGJlIHVzZWQgdG8gaW5kZXggdmFsdWVzIHVzaW5nIEBub25lLCBzbyBhZGQgYXMgYSBsb3dcbiAgICAvLyBwcmlvcml0eVxuICAgIGlmKF9pc09iamVjdCh2YWx1ZSkgJiYgISgnQGluZGV4JyBpbiB2YWx1ZSkpIHtcbiAgICAgIC8vIGFsbG93IGluZGV4aW5nIGV2ZW4gaWYgbm8gQGluZGV4IHByZXNlbnRcbiAgICAgIGNvbnRhaW5lcnMucHVzaCgnQGluZGV4JywgJ0BpbmRleEBzZXQnKTtcbiAgICB9XG5cbiAgICAvLyB2YWx1ZXMgd2l0aG91dCB0eXBlIG9yIGxhbmd1YWdlIGNhbiB1c2UgQGxhbmd1YWdlIG1hcFxuICAgIGlmKF9pc1ZhbHVlKHZhbHVlKSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBhbGxvdyBpbmRleGluZyBldmVuIGlmIG5vIEBpbmRleCBwcmVzZW50XG4gICAgICBjb250YWluZXJzLnB1c2goJ0BsYW5ndWFnZScsICdAbGFuZ3VhZ2VAc2V0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGVybSA9IF9zZWxlY3RUZXJtKFxuICAgICAgYWN0aXZlQ3R4LCBpcmksIHZhbHVlLCBjb250YWluZXJzLCB0eXBlT3JMYW5ndWFnZSwgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSk7XG4gICAgaWYodGVybSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRlcm07XG4gICAgfVxuICB9XG5cbiAgLy8gbm8gdGVybSBtYXRjaCwgdXNlIEB2b2NhYiBpZiBhdmFpbGFibGVcbiAgaWYocmVsYXRpdmVUby52b2NhYikge1xuICAgIGlmKCdAdm9jYWInIGluIGFjdGl2ZUN0eCkge1xuICAgICAgLy8gZGV0ZXJtaW5lIGlmIHZvY2FiIGlzIGEgcHJlZml4IG9mIHRoZSBpcmlcbiAgICAgIGNvbnN0IHZvY2FiID0gYWN0aXZlQ3R4WydAdm9jYWInXTtcbiAgICAgIGlmKGlyaS5pbmRleE9mKHZvY2FiKSA9PT0gMCAmJiBpcmkgIT09IHZvY2FiKSB7XG4gICAgICAgIC8vIHVzZSBzdWZmaXggYXMgcmVsYXRpdmUgaXJpIGlmIGl0IGlzIG5vdCBhIHRlcm0gaW4gdGhlIGFjdGl2ZSBjb250ZXh0XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGlyaS5zdWJzdHIodm9jYWIubGVuZ3RoKTtcbiAgICAgICAgaWYoIWFjdGl2ZUN0eC5tYXBwaW5ncy5oYXMoc3VmZml4KSkge1xuICAgICAgICAgIHJldHVybiBzdWZmaXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBubyB0ZXJtIG9yIEB2b2NhYiBtYXRjaCwgY2hlY2sgZm9yIHBvc3NpYmxlIENVUklFc1xuICBsZXQgY2hvaWNlID0gbnVsbDtcbiAgLy8gVE9ETzogbWFrZSBGYXN0Q3VyaWVNYXAgYSBjbGFzcyB3aXRoIGEgbWV0aG9kIHRvIGRvIHRoaXMgbG9va3VwXG4gIGNvbnN0IHBhcnRpYWxNYXRjaGVzID0gW107XG4gIGxldCBpcmlNYXAgPSBhY3RpdmVDdHguZmFzdEN1cmllTWFwO1xuICAvLyBjaGVjayBmb3IgcGFydGlhbCBtYXRjaGVzIG9mIGFnYWluc3QgYGlyaWAsIHdoaWNoIG1lYW5zIGxvb2sgdW50aWxcbiAgLy8gaXJpLmxlbmd0aCAtIDEsIG5vdCBmdWxsIGxlbmd0aFxuICBjb25zdCBtYXhQYXJ0aWFsTGVuZ3RoID0gaXJpLmxlbmd0aCAtIDE7XG4gIGZvcihsZXQgaSA9IDA7IGkgPCBtYXhQYXJ0aWFsTGVuZ3RoICYmIGlyaVtpXSBpbiBpcmlNYXA7ICsraSkge1xuICAgIGlyaU1hcCA9IGlyaU1hcFtpcmlbaV1dO1xuICAgIGlmKCcnIGluIGlyaU1hcCkge1xuICAgICAgcGFydGlhbE1hdGNoZXMucHVzaChpcmlNYXBbJyddWzBdKTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgcGFydGlhbCBtYXRjaGVzIGluIHJldmVyc2Ugb3JkZXIgdG8gcHJlZmVyIGxvbmdlc3Qgb25lcyBmaXJzdFxuICBmb3IobGV0IGkgPSBwYXJ0aWFsTWF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGNvbnN0IGVudHJ5ID0gcGFydGlhbE1hdGNoZXNbaV07XG4gICAgY29uc3QgdGVybXMgPSBlbnRyeS50ZXJtcztcbiAgICBmb3IoY29uc3QgdGVybSBvZiB0ZXJtcykge1xuICAgICAgLy8gYSBDVVJJRSBpcyB1c2FibGUgaWY6XG4gICAgICAvLyAxLiBpdCBoYXMgbm8gbWFwcGluZywgT1JcbiAgICAgIC8vIDIuIHZhbHVlIGlzIG51bGwsIHdoaWNoIG1lYW5zIHdlJ3JlIG5vdCBjb21wYWN0aW5nIGFuIEB2YWx1ZSwgQU5EXG4gICAgICAvLyAgIHRoZSBtYXBwaW5nIG1hdGNoZXMgdGhlIElSSVxuICAgICAgY29uc3QgY3VyaWUgPSB0ZXJtICsgJzonICsgaXJpLnN1YnN0cihlbnRyeS5pcmkubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGlzVXNhYmxlQ3VyaWUgPSAoYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldCh0ZXJtKS5fcHJlZml4ICYmXG4gICAgICAgICghYWN0aXZlQ3R4Lm1hcHBpbmdzLmhhcyhjdXJpZSkgfHxcbiAgICAgICAgKHZhbHVlID09PSBudWxsICYmIGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQoY3VyaWUpWydAaWQnXSA9PT0gaXJpKSkpO1xuXG4gICAgICAvLyBzZWxlY3QgY3VyaWUgaWYgaXQgaXMgc2hvcnRlciBvciB0aGUgc2FtZSBsZW5ndGggYnV0IGxleGljb2dyYXBoaWNhbGx5XG4gICAgICAvLyBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgY2hvaWNlXG4gICAgICBpZihpc1VzYWJsZUN1cmllICYmIChjaG9pY2UgPT09IG51bGwgfHxcbiAgICAgICAgX2NvbXBhcmVTaG9ydGVzdExlYXN0KGN1cmllLCBjaG9pY2UpIDwgMCkpIHtcbiAgICAgICAgY2hvaWNlID0gY3VyaWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJuIGNob3NlbiBjdXJpZVxuICBpZihjaG9pY2UgIT09IG51bGwpIHtcbiAgICByZXR1cm4gY2hvaWNlO1xuICB9XG5cbiAgLy8gSWYgaXJpIGNvdWxkIGJlIGNvbmZ1c2VkIHdpdGggYSBjb21wYWN0IElSSSB1c2luZyBhIHRlcm0gaW4gdGhpcyBjb250ZXh0LFxuICAvLyBzaWduYWwgYW4gZXJyb3JcbiAgZm9yKGNvbnN0IFt0ZXJtLCB0ZF0gb2YgYWN0aXZlQ3R4Lm1hcHBpbmdzKSB7XG4gICAgaWYodGQgJiYgdGQuX3ByZWZpeCAmJiBpcmkuc3RhcnRzV2l0aCh0ZXJtICsgJzonKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICBgQWJzb2x1dGUgSVJJIFwiJHtpcml9XCIgY29uZnVzZWQgd2l0aCBwcmVmaXggXCIke3Rlcm19XCIuYCxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnSVJJIGNvbmZ1c2VkIHdpdGggcHJlZml4JywgY29udGV4dDogYWN0aXZlQ3R4fSk7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcGFjdCBJUkkgcmVsYXRpdmUgdG8gYmFzZVxuICBpZighcmVsYXRpdmVUby52b2NhYikge1xuICAgIGlmKCdAYmFzZScgaW4gYWN0aXZlQ3R4KSB7XG4gICAgICBpZighYWN0aXZlQ3R4WydAYmFzZSddKSB7XG4gICAgICAgIC8vIFRoZSBOb25lIGNhc2UgcHJlc2VydmVzIHJ2YWwgYXMgcG90ZW50aWFsbHkgcmVsYXRpdmVcbiAgICAgICAgcmV0dXJuIGlyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfcmVtb3ZlQmFzZShfcHJlcGVuZEJhc2UoYmFzZSwgYWN0aXZlQ3R4WydAYmFzZSddKSwgaXJpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9yZW1vdmVCYXNlKGJhc2UsIGlyaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJuIElSSSBhcyBpc1xuICByZXR1cm4gaXJpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyB2YWx1ZSBjb21wYWN0aW9uIG9uIGFuIG9iamVjdCB3aXRoICdAdmFsdWUnIG9yICdAaWQnIGFzIHRoZSBvbmx5XG4gKiBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSBhY3RpdmVQcm9wZXJ0eSB0aGUgYWN0aXZlIHByb3BlcnR5IHRoYXQgcG9pbnRzIHRvIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gY29tcGFjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBwcm9jZXNzaW5nIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB0aGUgY29tcGFjdGlvbiByZXN1bHQuXG4gKi9cbmFwaS5jb21wYWN0VmFsdWUgPSAoe2FjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHZhbHVlLCBvcHRpb25zfSkgPT4ge1xuICAvLyB2YWx1ZSBpcyBhIEB2YWx1ZVxuICBpZihfaXNWYWx1ZSh2YWx1ZSkpIHtcbiAgICAvLyBnZXQgY29udGV4dCBydWxlc1xuICAgIGNvbnN0IHR5cGUgPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAdHlwZScpO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGxhbmd1YWdlJyk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGRpcmVjdGlvbicpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9XG4gICAgICBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAY29udGFpbmVyJykgfHwgW107XG5cbiAgICAvLyB3aGV0aGVyIG9yIG5vdCB0aGUgdmFsdWUgaGFzIGFuIEBpbmRleCB0aGF0IG11c3QgYmUgcHJlc2VydmVkXG4gICAgY29uc3QgcHJlc2VydmVJbmRleCA9ICdAaW5kZXgnIGluIHZhbHVlICYmICFjb250YWluZXIuaW5jbHVkZXMoJ0BpbmRleCcpO1xuXG4gICAgLy8gaWYgdGhlcmUncyBubyBAaW5kZXggdG8gcHJlc2VydmUgLi4uXG4gICAgaWYoIXByZXNlcnZlSW5kZXggJiYgdHlwZSAhPT0gJ0Bub25lJykge1xuICAgICAgLy8gbWF0Y2hpbmcgQHR5cGUgb3IgQGxhbmd1YWdlIHNwZWNpZmllZCBpbiBjb250ZXh0LCBjb21wYWN0IHZhbHVlXG4gICAgICBpZih2YWx1ZVsnQHR5cGUnXSA9PT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbJ0B2YWx1ZSddO1xuICAgICAgfVxuICAgICAgaWYoJ0BsYW5ndWFnZScgaW4gdmFsdWUgJiYgdmFsdWVbJ0BsYW5ndWFnZSddID09PSBsYW5ndWFnZSAmJlxuICAgICAgICAgJ0BkaXJlY3Rpb24nIGluIHZhbHVlICYmIHZhbHVlWydAZGlyZWN0aW9uJ10gPT09IGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gdmFsdWVbJ0B2YWx1ZSddO1xuICAgICAgfVxuICAgICAgaWYoJ0BsYW5ndWFnZScgaW4gdmFsdWUgJiYgdmFsdWVbJ0BsYW5ndWFnZSddID09PSBsYW5ndWFnZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbJ0B2YWx1ZSddO1xuICAgICAgfVxuICAgICAgaWYoJ0BkaXJlY3Rpb24nIGluIHZhbHVlICYmIHZhbHVlWydAZGlyZWN0aW9uJ10gPT09IGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gdmFsdWVbJ0B2YWx1ZSddO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBqdXN0IHRoZSB2YWx1ZSBvZiBAdmFsdWUgaWYgYWxsIGFyZSB0cnVlOlxuICAgIC8vIDEuIEB2YWx1ZSBpcyB0aGUgb25seSBrZXkgb3IgQGluZGV4IGlzbid0IGJlaW5nIHByZXNlcnZlZFxuICAgIC8vIDIuIHRoZXJlIGlzIG5vIGRlZmF1bHQgbGFuZ3VhZ2Ugb3IgQHZhbHVlIGlzIG5vdCBhIHN0cmluZyBvclxuICAgIC8vICAgdGhlIGtleSBoYXMgYSBtYXBwaW5nIHdpdGggYSBudWxsIEBsYW5ndWFnZVxuICAgIGNvbnN0IGtleUNvdW50ID0gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICBjb25zdCBpc1ZhbHVlT25seUtleSA9IChrZXlDb3VudCA9PT0gMSB8fFxuICAgICAgKGtleUNvdW50ID09PSAyICYmICdAaW5kZXgnIGluIHZhbHVlICYmICFwcmVzZXJ2ZUluZGV4KSk7XG4gICAgY29uc3QgaGFzRGVmYXVsdExhbmd1YWdlID0gKCdAbGFuZ3VhZ2UnIGluIGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgaXNWYWx1ZVN0cmluZyA9IF9pc1N0cmluZyh2YWx1ZVsnQHZhbHVlJ10pO1xuICAgIGNvbnN0IGhhc051bGxNYXBwaW5nID0gKGFjdGl2ZUN0eC5tYXBwaW5ncy5oYXMoYWN0aXZlUHJvcGVydHkpICYmXG4gICAgICBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KGFjdGl2ZVByb3BlcnR5KVsnQGxhbmd1YWdlJ10gPT09IG51bGwpO1xuICAgIGlmKGlzVmFsdWVPbmx5S2V5ICYmXG4gICAgICB0eXBlICE9PSAnQG5vbmUnICYmXG4gICAgICAoIWhhc0RlZmF1bHRMYW5ndWFnZSB8fCAhaXNWYWx1ZVN0cmluZyB8fCBoYXNOdWxsTWFwcGluZykpIHtcbiAgICAgIHJldHVybiB2YWx1ZVsnQHZhbHVlJ107XG4gICAgfVxuXG4gICAgY29uc3QgcnZhbCA9IHt9O1xuXG4gICAgLy8gcHJlc2VydmUgQGluZGV4XG4gICAgaWYocHJlc2VydmVJbmRleCkge1xuICAgICAgcnZhbFthcGkuY29tcGFjdElyaSh7XG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgaXJpOiAnQGluZGV4JyxcbiAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgfSldID0gdmFsdWVbJ0BpbmRleCddO1xuICAgIH1cblxuICAgIGlmKCdAdHlwZScgaW4gdmFsdWUpIHtcbiAgICAgIC8vIGNvbXBhY3QgQHR5cGUgSVJJXG4gICAgICBydmFsW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBpcmk6ICdAdHlwZScsXG4gICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgIH0pXSA9IGFwaS5jb21wYWN0SXJpKFxuICAgICAgICB7YWN0aXZlQ3R4LCBpcmk6IHZhbHVlWydAdHlwZSddLCByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9fSk7XG4gICAgfSBlbHNlIGlmKCdAbGFuZ3VhZ2UnIGluIHZhbHVlKSB7XG4gICAgICAvLyBhbGlhcyBAbGFuZ3VhZ2VcbiAgICAgIHJ2YWxbYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGlyaTogJ0BsYW5ndWFnZScsXG4gICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgIH0pXSA9IHZhbHVlWydAbGFuZ3VhZ2UnXTtcbiAgICB9XG5cbiAgICBpZignQGRpcmVjdGlvbicgaW4gdmFsdWUpIHtcbiAgICAgIC8vIGFsaWFzIEBkaXJlY3Rpb25cbiAgICAgIHJ2YWxbYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGlyaTogJ0BkaXJlY3Rpb24nLFxuICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICB9KV0gPSB2YWx1ZVsnQGRpcmVjdGlvbiddO1xuICAgIH1cblxuICAgIC8vIGFsaWFzIEB2YWx1ZVxuICAgIHJ2YWxbYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgYWN0aXZlQ3R4LFxuICAgICAgaXJpOiAnQHZhbHVlJyxcbiAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICB9KV0gPSB2YWx1ZVsnQHZhbHVlJ107XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfVxuXG4gIC8vIHZhbHVlIGlzIGEgc3ViamVjdCByZWZlcmVuY2VcbiAgY29uc3QgZXhwYW5kZWRQcm9wZXJ0eSA9IF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwge3ZvY2FiOiB0cnVlfSxcbiAgICBvcHRpb25zKTtcbiAgY29uc3QgdHlwZSA9IF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0B0eXBlJyk7XG4gIGNvbnN0IGNvbXBhY3RlZCA9IGFwaS5jb21wYWN0SXJpKHtcbiAgICBhY3RpdmVDdHgsXG4gICAgaXJpOiB2YWx1ZVsnQGlkJ10sXG4gICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0eXBlID09PSAnQHZvY2FiJ30sXG4gICAgYmFzZTogb3B0aW9ucy5iYXNlfSk7XG5cbiAgLy8gY29tcGFjdCB0byBzY2FsYXJcbiAgaWYodHlwZSA9PT0gJ0BpZCcgfHwgdHlwZSA9PT0gJ0B2b2NhYicgfHwgZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BncmFwaCcpIHtcbiAgICByZXR1cm4gY29tcGFjdGVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBbYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgYWN0aXZlQ3R4LFxuICAgICAgaXJpOiAnQGlkJyxcbiAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICB9KV06IGNvbXBhY3RlZFxuICB9O1xufTtcblxuLyoqXG4gKiBQaWNrcyB0aGUgcHJlZmVycmVkIGNvbXBhY3Rpb24gdGVybSBmcm9tIHRoZSBnaXZlbiBpbnZlcnNlIGNvbnRleHQgZW50cnkuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0gaXJpIHRoZSBJUkkgdG8gcGljayB0aGUgdGVybSBmb3IuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHBpY2sgdGhlIHRlcm0gZm9yLlxuICogQHBhcmFtIGNvbnRhaW5lcnMgdGhlIHByZWZlcnJlZCBjb250YWluZXJzLlxuICogQHBhcmFtIHR5cGVPckxhbmd1YWdlIGVpdGhlciAnQHR5cGUnIG9yICdAbGFuZ3VhZ2UnLlxuICogQHBhcmFtIHR5cGVPckxhbmd1YWdlVmFsdWUgdGhlIHByZWZlcnJlZCB2YWx1ZSBmb3IgJ0B0eXBlJyBvciAnQGxhbmd1YWdlJy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwcmVmZXJyZWQgdGVybS5cbiAqL1xuZnVuY3Rpb24gX3NlbGVjdFRlcm0oXG4gIGFjdGl2ZUN0eCwgaXJpLCB2YWx1ZSwgY29udGFpbmVycywgdHlwZU9yTGFuZ3VhZ2UsIHR5cGVPckxhbmd1YWdlVmFsdWUpIHtcbiAgaWYodHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9PT0gbnVsbCkge1xuICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSAnQG51bGwnO1xuICB9XG5cbiAgLy8gcHJlZmVyZW5jZXMgZm9yIHRoZSB2YWx1ZSBvZiBAdHlwZSBvciBAbGFuZ3VhZ2VcbiAgY29uc3QgcHJlZnMgPSBbXTtcblxuICAvLyBkZXRlcm1pbmUgcHJlZnMgZm9yIEBpZCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCB2YWx1ZSBjb21wYWN0cyB0byBhIHRlcm1cbiAgaWYoKHR5cGVPckxhbmd1YWdlVmFsdWUgPT09ICdAaWQnIHx8IHR5cGVPckxhbmd1YWdlVmFsdWUgPT09ICdAcmV2ZXJzZScpICYmXG4gICAgX2lzT2JqZWN0KHZhbHVlKSAmJiAnQGlkJyBpbiB2YWx1ZSkge1xuICAgIC8vIHByZWZlciBAcmV2ZXJzZSBmaXJzdFxuICAgIGlmKHR5cGVPckxhbmd1YWdlVmFsdWUgPT09ICdAcmV2ZXJzZScpIHtcbiAgICAgIHByZWZzLnB1c2goJ0ByZXZlcnNlJyk7XG4gICAgfVxuICAgIC8vIHRyeSB0byBjb21wYWN0IHZhbHVlIHRvIGEgdGVybVxuICAgIGNvbnN0IHRlcm0gPSBhcGkuY29tcGFjdElyaShcbiAgICAgIHthY3RpdmVDdHgsIGlyaTogdmFsdWVbJ0BpZCddLCByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9fSk7XG4gICAgaWYoYWN0aXZlQ3R4Lm1hcHBpbmdzLmhhcyh0ZXJtKSAmJlxuICAgICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldCh0ZXJtKSAmJlxuICAgICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldCh0ZXJtKVsnQGlkJ10gPT09IHZhbHVlWydAaWQnXSkge1xuICAgICAgLy8gcHJlZmVyIEB2b2NhYlxuICAgICAgcHJlZnMucHVzaC5hcHBseShwcmVmcywgWydAdm9jYWInLCAnQGlkJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwcmVmZXIgQGlkXG4gICAgICBwcmVmcy5wdXNoLmFwcGx5KHByZWZzLCBbJ0BpZCcsICdAdm9jYWInXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByZWZzLnB1c2godHlwZU9yTGFuZ3VhZ2VWYWx1ZSk7XG5cbiAgICAvLyBjb25zaWRlciBkaXJlY3Rpb24gb25seVxuICAgIGNvbnN0IGxhbmdEaXIgPSBwcmVmcy5maW5kKGVsID0+IGVsLmluY2x1ZGVzKCdfJykpO1xuICAgIGlmKGxhbmdEaXIpIHtcbiAgICAgIC8vIGNvbnNpZGVyIF9kaXIgcG9ydGlvblxuICAgICAgcHJlZnMucHVzaChsYW5nRGlyLnJlcGxhY2UoL15bXl9dK18vLCAnXycpKTtcbiAgICB9XG4gIH1cbiAgcHJlZnMucHVzaCgnQG5vbmUnKTtcblxuICBjb25zdCBjb250YWluZXJNYXAgPSBhY3RpdmVDdHguaW52ZXJzZVtpcmldO1xuICBmb3IoY29uc3QgY29udGFpbmVyIG9mIGNvbnRhaW5lcnMpIHtcbiAgICAvLyBpZiBjb250YWluZXIgbm90IGF2YWlsYWJsZSBpbiB0aGUgbWFwLCBjb250aW51ZVxuICAgIGlmKCEoY29udGFpbmVyIGluIGNvbnRhaW5lck1hcCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGVPckxhbmd1YWdlVmFsdWVNYXAgPSBjb250YWluZXJNYXBbY29udGFpbmVyXVt0eXBlT3JMYW5ndWFnZV07XG4gICAgZm9yKGNvbnN0IHByZWYgb2YgcHJlZnMpIHtcbiAgICAgIC8vIGlmIHR5cGUvbGFuZ3VhZ2Ugb3B0aW9uIG5vdCBhdmFpbGFibGUgaW4gdGhlIG1hcCwgY29udGludWVcbiAgICAgIGlmKCEocHJlZiBpbiB0eXBlT3JMYW5ndWFnZVZhbHVlTWFwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc2VsZWN0IHRlcm1cbiAgICAgIHJldHVybiB0eXBlT3JMYW5ndWFnZVZhbHVlTWFwW3ByZWZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoZSB2YWx1ZSBvZiBgQG5lc3RgIGluIHRoZSB0ZXJtIGRlZmluaXRpb24gbXVzdCBlaXRoZXIgYmUgYEBuZXN0YCwgb3IgYSB0ZXJtXG4gKiB3aGljaCByZXNvbHZlcyB0byBgQG5lc3RgLlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGFjdGl2ZSBjb250ZXh0LlxuICogQHBhcmFtIG5lc3RQcm9wZXJ0eSBhIHRlcm0gaW4gdGhlIGFjdGl2ZSBjb250ZXh0IG9yIGBAbmVzdGAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcHJvY2Vzc2luZyBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBfY2hlY2tOZXN0UHJvcGVydHkoYWN0aXZlQ3R4LCBuZXN0UHJvcGVydHksIG9wdGlvbnMpIHtcbiAgaWYoX2V4cGFuZElyaShhY3RpdmVDdHgsIG5lc3RQcm9wZXJ0eSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucykgIT09ICdAbmVzdCcpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnSlNPTi1MRCBjb21wYWN0IGVycm9yOyBuZXN0ZWQgcHJvcGVydHkgbXVzdCBoYXZlIGFuIEBuZXN0IHZhbHVlICcgK1xuICAgICAgJ3Jlc29sdmluZyB0byBAbmVzdC4nLFxuICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAbmVzdCB2YWx1ZSd9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJERiA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjJztcbmNvbnN0IFhTRCA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSMnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gVE9ETzogRGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGxhdGVyLiBVc2UgTElOS19IRUFERVJfQ09OVEVYVC5cbiAgTElOS19IRUFERVJfUkVMOiAnaHR0cDovL3d3dy53My5vcmcvbnMvanNvbi1sZCNjb250ZXh0JyxcblxuICBMSU5LX0hFQURFUl9DT05URVhUOiAnaHR0cDovL3d3dy53My5vcmcvbnMvanNvbi1sZCNjb250ZXh0JyxcblxuICBSREYsXG4gIFJERl9MSVNUOiBSREYgKyAnTGlzdCcsXG4gIFJERl9GSVJTVDogUkRGICsgJ2ZpcnN0JyxcbiAgUkRGX1JFU1Q6IFJERiArICdyZXN0JyxcbiAgUkRGX05JTDogUkRGICsgJ25pbCcsXG4gIFJERl9UWVBFOiBSREYgKyAndHlwZScsXG4gIFJERl9QTEFJTl9MSVRFUkFMOiBSREYgKyAnUGxhaW5MaXRlcmFsJyxcbiAgUkRGX1hNTF9MSVRFUkFMOiBSREYgKyAnWE1MTGl0ZXJhbCcsXG4gIFJERl9KU09OX0xJVEVSQUw6IFJERiArICdKU09OJyxcbiAgUkRGX09CSkVDVDogUkRGICsgJ29iamVjdCcsXG4gIFJERl9MQU5HU1RSSU5HOiBSREYgKyAnbGFuZ1N0cmluZycsXG5cbiAgWFNELFxuICBYU0RfQk9PTEVBTjogWFNEICsgJ2Jvb2xlYW4nLFxuICBYU0RfRE9VQkxFOiBYU0QgKyAnZG91YmxlJyxcbiAgWFNEX0lOVEVHRVI6IFhTRCArICdpbnRlZ2VyJyxcbiAgWFNEX1NUUklORzogWFNEICsgJ3N0cmluZycsXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDE5IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5cbmNvbnN0IHtcbiAgaXNBcnJheTogX2lzQXJyYXksXG4gIGlzT2JqZWN0OiBfaXNPYmplY3QsXG4gIGlzU3RyaW5nOiBfaXNTdHJpbmcsXG4gIGlzVW5kZWZpbmVkOiBfaXNVbmRlZmluZWRcbn0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IHtcbiAgaXNBYnNvbHV0ZTogX2lzQWJzb2x1dGVJcmksXG4gIGlzUmVsYXRpdmU6IF9pc1JlbGF0aXZlSXJpLFxuICBwcmVwZW5kQmFzZSxcbiAgcGFyc2U6IHBhcnNlVXJsXG59ID0gcmVxdWlyZSgnLi91cmwnKTtcblxuY29uc3Qge1xuICBhc0FycmF5OiBfYXNBcnJheSxcbiAgY29tcGFyZVNob3J0ZXN0TGVhc3Q6IF9jb21wYXJlU2hvcnRlc3RMZWFzdFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCBJTklUSUFMX0NPTlRFWFRfQ0FDSEUgPSBuZXcgTWFwKCk7XG5jb25zdCBJTklUSUFMX0NPTlRFWFRfQ0FDSEVfTUFYX1NJWkUgPSAxMDAwMDtcbmNvbnN0IEtFWVdPUkRfUEFUVEVSTiA9IC9eQFthLXpBLVpdKyQvO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhIGxvY2FsIGNvbnRleHQgYW5kIHJldHVybnMgYSBuZXcgYWN0aXZlIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY3VycmVudCBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSBsb2NhbEN0eCB0aGUgbG9jYWwgY29udGV4dCB0byBwcm9jZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIGNvbnRleHQgcHJvY2Vzc2luZyBvcHRpb25zLlxuICogQHBhcmFtIHByb3BhZ2F0ZSBgdHJ1ZWAgaWYgYGZhbHNlYCwgcmV0YWlucyBhbnkgcHJldmlvdXNseSBkZWZpbmVkIHRlcm0sXG4gKiAgIHdoaWNoIGNhbiBiZSByb2xsZWQgYmFjayB3aGVuIHRoZSBkZXNjZW5kaW5nIGludG8gYSBuZXcgbm9kZSBvYmplY3QuXG4gKiBAcGFyYW0gb3ZlcnJpZGVQcm90ZWN0ZWQgYGZhbHNlYCBhbGxvd3MgcHJvdGVjdGVkIHRlcm1zIHRvIGJlIG1vZGlmaWVkLlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5ldyBhY3RpdmUgY29udGV4dC5cbiAqL1xuYXBpLnByb2Nlc3MgPSBhc3luYyAoe1xuICBhY3RpdmVDdHgsIGxvY2FsQ3R4LCBvcHRpb25zLFxuICBwcm9wYWdhdGUgPSB0cnVlLFxuICBvdmVycmlkZVByb3RlY3RlZCA9IGZhbHNlLFxuICBjeWNsZXMgPSBuZXcgU2V0KClcbn0pID0+IHtcbiAgLy8gbm9ybWFsaXplIGxvY2FsIGNvbnRleHQgdG8gYW4gYXJyYXkgb2YgQGNvbnRleHQgb2JqZWN0c1xuICBpZihfaXNPYmplY3QobG9jYWxDdHgpICYmICdAY29udGV4dCcgaW4gbG9jYWxDdHggJiZcbiAgICBfaXNBcnJheShsb2NhbEN0eFsnQGNvbnRleHQnXSkpIHtcbiAgICBsb2NhbEN0eCA9IGxvY2FsQ3R4WydAY29udGV4dCddO1xuICB9XG4gIGNvbnN0IGN0eHMgPSBfYXNBcnJheShsb2NhbEN0eCk7XG5cbiAgLy8gbm8gY29udGV4dHMgaW4gYXJyYXksIHJldHVybiBjdXJyZW50IGFjdGl2ZSBjb250ZXh0IHcvbyBjaGFuZ2VzXG4gIGlmKGN0eHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUN0eDtcbiAgfVxuXG4gIC8vIHJlc29sdmUgY29udGV4dHNcbiAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCBvcHRpb25zLmNvbnRleHRSZXNvbHZlci5yZXNvbHZlKHtcbiAgICBhY3RpdmVDdHgsXG4gICAgY29udGV4dDogbG9jYWxDdHgsXG4gICAgZG9jdW1lbnRMb2FkZXI6IG9wdGlvbnMuZG9jdW1lbnRMb2FkZXIsXG4gICAgYmFzZTogb3B0aW9ucy5iYXNlXG4gIH0pO1xuXG4gIC8vIG92ZXJyaWRlIHByb3BhZ2F0ZSBpZiBmaXJzdCByZXNvbHZlZCBjb250ZXh0IGhhcyBgQHByb3BhZ2F0ZWBcbiAgaWYoX2lzT2JqZWN0KHJlc29sdmVkWzBdLmRvY3VtZW50KSAmJlxuICAgIHR5cGVvZiByZXNvbHZlZFswXS5kb2N1bWVudFsnQHByb3BhZ2F0ZSddID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyByZXRyaWV2ZSBlYXJseSwgZXJyb3IgY2hlY2tpbmcgZG9uZSBsYXRlclxuICAgIHByb3BhZ2F0ZSA9IHJlc29sdmVkWzBdLmRvY3VtZW50WydAcHJvcGFnYXRlJ107XG4gIH1cblxuICAvLyBwcm9jZXNzIGVhY2ggY29udGV4dCBpbiBvcmRlciwgdXBkYXRlIGFjdGl2ZSBjb250ZXh0XG4gIC8vIG9uIGVhY2ggaXRlcmF0aW9uIHRvIGVuc3VyZSBwcm9wZXIgY2FjaGluZ1xuICBsZXQgcnZhbCA9IGFjdGl2ZUN0eDtcblxuICAvLyB0cmFjayB0aGUgcHJldmlvdXMgY29udGV4dFxuICAvLyBpZiBub3QgcHJvcGFnYXRpbmcsIG1ha2Ugc3VyZSBydmFsIGhhcyBhIHByZXZpb3VzIGNvbnRleHRcbiAgaWYoIXByb3BhZ2F0ZSAmJiAhcnZhbC5wcmV2aW91c0NvbnRleHQpIHtcbiAgICAvLyBjbG9uZSBgcnZhbGAgY29udGV4dCBiZWZvcmUgdXBkYXRpbmdcbiAgICBydmFsID0gcnZhbC5jbG9uZSgpO1xuICAgIHJ2YWwucHJldmlvdXNDb250ZXh0ID0gYWN0aXZlQ3R4O1xuICB9XG5cbiAgZm9yKGNvbnN0IHJlc29sdmVkQ29udGV4dCBvZiByZXNvbHZlZCkge1xuICAgIGxldCB7ZG9jdW1lbnQ6IGN0eH0gPSByZXNvbHZlZENvbnRleHQ7XG5cbiAgICAvLyB1cGRhdGUgYWN0aXZlIGNvbnRleHQgdG8gb25lIGNvbXB1dGVkIGZyb20gbGFzdCBpdGVyYXRpb25cbiAgICBhY3RpdmVDdHggPSBydmFsO1xuXG4gICAgLy8gcmVzZXQgdG8gaW5pdGlhbCBjb250ZXh0XG4gICAgaWYoY3R4ID09PSBudWxsKSB7XG4gICAgICAvLyBXZSBjYW4ndCBudWxsaWZ5IGlmIHRoZXJlIGFyZSBwcm90ZWN0ZWQgdGVybXMgYW5kIHdlJ3JlXG4gICAgICAvLyBub3QgYWxsb3dpbmcgb3ZlcnJpZGVzIChlLmcuIHByb2Nlc3NpbmcgYSBwcm9wZXJ0eSB0ZXJtIHNjb3BlZCBjb250ZXh0KVxuICAgICAgaWYoIW92ZXJyaWRlUHJvdGVjdGVkICYmXG4gICAgICAgIE9iamVjdC5rZXlzKGFjdGl2ZUN0eC5wcm90ZWN0ZWQpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBwcm90ZWN0ZWRNb2RlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wcm90ZWN0ZWRNb2RlKSB8fCAnZXJyb3InO1xuICAgICAgICBpZihwcm90ZWN0ZWRNb2RlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ1RyaWVkIHRvIG51bGxpZnkgYSBjb250ZXh0IHdpdGggcHJvdGVjdGVkIHRlcm1zIG91dHNpZGUgb2YgJyArXG4gICAgICAgICAgICAnYSB0ZXJtIGRlZmluaXRpb24uJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRleHQgbnVsbGlmaWNhdGlvbid9KTtcbiAgICAgICAgfSBlbHNlIGlmKHByb3RlY3RlZE1vZGUgPT09ICd3YXJuJykge1xuICAgICAgICAgIC8vIEZJWE1FOiByZW1vdmUgbG9nZ2luZyBhbmQgdXNlIGEgaGFuZGxlclxuICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogaW52YWxpZCBjb250ZXh0IG51bGxpZmljYXRpb24nKTtcblxuICAgICAgICAgIC8vIGdldCBwcm9jZXNzZWQgY29udGV4dCBmcm9tIGNhY2hlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IHJlc29sdmVkQ29udGV4dC5nZXRQcm9jZXNzZWQoYWN0aXZlQ3R4KTtcbiAgICAgICAgICBpZihwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIHJ2YWwgPSBhY3RpdmVDdHggPSBwcm9jZXNzZWQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvbGRBY3RpdmVDdHggPSBhY3RpdmVDdHg7XG4gICAgICAgICAgLy8gY29weSBhbGwgcHJvdGVjdGVkIHRlcm0gZGVmaW5pdGlvbnMgdG8gZnJlc2ggaW5pdGlhbCBjb250ZXh0XG4gICAgICAgICAgcnZhbCA9IGFjdGl2ZUN0eCA9IGFwaS5nZXRJbml0aWFsQ29udGV4dChvcHRpb25zKS5jbG9uZSgpO1xuICAgICAgICAgIGZvcihjb25zdCBbdGVybSwgX3Byb3RlY3RlZF0gb2ZcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG9sZEFjdGl2ZUN0eC5wcm90ZWN0ZWQpKSB7XG4gICAgICAgICAgICBpZihfcHJvdGVjdGVkKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUN0eC5tYXBwaW5nc1t0ZXJtXSA9XG4gICAgICAgICAgICAgICAgdXRpbC5jbG9uZShvbGRBY3RpdmVDdHgubWFwcGluZ3NbdGVybV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmVDdHgucHJvdGVjdGVkID0gdXRpbC5jbG9uZShvbGRBY3RpdmVDdHgucHJvdGVjdGVkKTtcblxuICAgICAgICAgIC8vIGNhY2hlIHByb2Nlc3NlZCByZXN1bHRcbiAgICAgICAgICByZXNvbHZlZENvbnRleHQuc2V0UHJvY2Vzc2VkKG9sZEFjdGl2ZUN0eCwgcnZhbCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIHByb3RlY3RlZE1vZGUuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgcHJvdGVjdGVkIG1vZGUnLCBjb250ZXh0OiBsb2NhbEN0eCwgcHJvdGVjdGVkTW9kZX0pO1xuICAgICAgfVxuICAgICAgcnZhbCA9IGFjdGl2ZUN0eCA9IGFwaS5nZXRJbml0aWFsQ29udGV4dChvcHRpb25zKS5jbG9uZSgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHByb2Nlc3NlZCBjb250ZXh0IGZyb20gY2FjaGUgaWYgYXZhaWxhYmxlXG4gICAgY29uc3QgcHJvY2Vzc2VkID0gcmVzb2x2ZWRDb250ZXh0LmdldFByb2Nlc3NlZChhY3RpdmVDdHgpO1xuICAgIGlmKHByb2Nlc3NlZCkge1xuICAgICAgcnZhbCA9IGFjdGl2ZUN0eCA9IHByb2Nlc3NlZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlcmVmZXJlbmNlIEBjb250ZXh0IGtleSBpZiBwcmVzZW50XG4gICAgaWYoX2lzT2JqZWN0KGN0eCkgJiYgJ0Bjb250ZXh0JyBpbiBjdHgpIHtcbiAgICAgIGN0eCA9IGN0eFsnQGNvbnRleHQnXTtcbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IG11c3QgYmUgYW4gb2JqZWN0IGJ5IG5vdywgYWxsIFVSTHMgcmV0cmlldmVkIGJlZm9yZSB0aGlzIGNhbGxcbiAgICBpZighX2lzT2JqZWN0KGN0eCkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBjb250ZXh0IG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgbG9jYWwgY29udGV4dCcsIGNvbnRleHQ6IGN0eH0pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRoZXJlIGlzIGxpa2VseSBhIGBwcmV2aW91c0NvbnRleHRgIGNsb25pbmcgb3B0aW1pemF0aW9uIHRoYXRcbiAgICAvLyBjb3VsZCBiZSBhcHBsaWVkIGhlcmUgKG5vIG5lZWQgdG8gY29weSBpdCB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMpXG5cbiAgICAvLyBjbG9uZSBjb250ZXh0IGJlZm9yZSB1cGRhdGluZyBpdFxuICAgIHJ2YWwgPSBydmFsLmNsb25lKCk7XG5cbiAgICAvLyBkZWZpbmUgY29udGV4dCBtYXBwaW5ncyBmb3Iga2V5cyBpbiBsb2NhbCBjb250ZXh0XG4gICAgY29uc3QgZGVmaW5lZCA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGhhbmRsZSBAdmVyc2lvblxuICAgIGlmKCdAdmVyc2lvbicgaW4gY3R4KSB7XG4gICAgICBpZihjdHhbJ0B2ZXJzaW9uJ10gIT09IDEuMSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIEpTT04tTEQgdmVyc2lvbjogJyArIGN0eFsnQHZlcnNpb24nXSxcbiAgICAgICAgICAnanNvbmxkLlVuc3VwcG9ydGVkVmVyc2lvbicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIEB2ZXJzaW9uIHZhbHVlJywgY29udGV4dDogY3R4fSk7XG4gICAgICB9XG4gICAgICBpZihhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgJiZcbiAgICAgICAgYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlID09PSAnanNvbi1sZC0xLjAnKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnQHZlcnNpb246ICcgKyBjdHhbJ0B2ZXJzaW9uJ10gKyAnIG5vdCBjb21wYXRpYmxlIHdpdGggJyArXG4gICAgICAgICAgYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlLFxuICAgICAgICAgICdqc29ubGQuUHJvY2Vzc2luZ01vZGVDb25mbGljdCcsXG4gICAgICAgICAge2NvZGU6ICdwcm9jZXNzaW5nIG1vZGUgY29uZmxpY3QnLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH1cbiAgICAgIHJ2YWwucHJvY2Vzc2luZ01vZGUgPSAnanNvbi1sZC0xLjEnO1xuICAgICAgcnZhbFsnQHZlcnNpb24nXSA9IGN0eFsnQHZlcnNpb24nXTtcbiAgICAgIGRlZmluZWQuc2V0KCdAdmVyc2lvbicsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGlmIG5vdCBzZXQgZXhwbGljaXRseSwgc2V0IHByb2Nlc3NpbmdNb2RlIHRvIFwianNvbi1sZC0xLjFcIlxuICAgIHJ2YWwucHJvY2Vzc2luZ01vZGUgPVxuICAgICAgcnZhbC5wcm9jZXNzaW5nTW9kZSB8fCBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGU7XG5cbiAgICAvLyBoYW5kbGUgQGJhc2VcbiAgICBpZignQGJhc2UnIGluIGN0eCkge1xuICAgICAgbGV0IGJhc2UgPSBjdHhbJ0BiYXNlJ107XG5cbiAgICAgIGlmKGJhc2UgPT09IG51bGwgfHwgX2lzQWJzb2x1dGVJcmkoYmFzZSkpIHtcbiAgICAgICAgLy8gbm8gYWN0aW9uXG4gICAgICB9IGVsc2UgaWYoX2lzUmVsYXRpdmVJcmkoYmFzZSkpIHtcbiAgICAgICAgYmFzZSA9IHByZXBlbmRCYXNlKHJ2YWxbJ0BiYXNlJ10sIGJhc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyB0aGUgdmFsdWUgb2YgXCJAYmFzZVwiIGluIGEgJyArXG4gICAgICAgICAgJ0Bjb250ZXh0IG11c3QgYmUgYW4gYWJzb2x1dGUgSVJJLCBhIHJlbGF0aXZlIElSSSwgb3IgbnVsbC4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgYmFzZSBJUkknLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH1cblxuICAgICAgcnZhbFsnQGJhc2UnXSA9IGJhc2U7XG4gICAgICBkZWZpbmVkLnNldCgnQGJhc2UnLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgQHZvY2FiXG4gICAgaWYoJ0B2b2NhYicgaW4gY3R4KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN0eFsnQHZvY2FiJ107XG4gICAgICBpZih2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgcnZhbFsnQHZvY2FiJ107XG4gICAgICB9IGVsc2UgaWYoIV9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyB0aGUgdmFsdWUgb2YgXCJAdm9jYWJcIiBpbiBhICcgK1xuICAgICAgICAgICdAY29udGV4dCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIHZvY2FiIG1hcHBpbmcnLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH0gZWxzZSBpZighX2lzQWJzb2x1dGVJcmkodmFsdWUpICYmIGFwaS5wcm9jZXNzaW5nTW9kZShydmFsLCAxLjApKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgdGhlIHZhbHVlIG9mIFwiQHZvY2FiXCIgaW4gYSAnICtcbiAgICAgICAgICAnQGNvbnRleHQgbXVzdCBiZSBhbiBhYnNvbHV0ZSBJUkkuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIHZvY2FiIG1hcHBpbmcnLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWxbJ0B2b2NhYiddID0gX2V4cGFuZElyaShydmFsLCB2YWx1ZSwge3ZvY2FiOiB0cnVlLCBiYXNlOiB0cnVlfSxcbiAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBkZWZpbmVkLnNldCgnQHZvY2FiJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIEBsYW5ndWFnZVxuICAgIGlmKCdAbGFuZ3VhZ2UnIGluIGN0eCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjdHhbJ0BsYW5ndWFnZSddO1xuICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHJ2YWxbJ0BsYW5ndWFnZSddO1xuICAgICAgfSBlbHNlIGlmKCFfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgdGhlIHZhbHVlIG9mIFwiQGxhbmd1YWdlXCIgaW4gYSAnICtcbiAgICAgICAgICAnQGNvbnRleHQgbXVzdCBiZSBhIHN0cmluZyBvciBudWxsLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGRlZmF1bHQgbGFuZ3VhZ2UnLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWxbJ0BsYW5ndWFnZSddID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZWQuc2V0KCdAbGFuZ3VhZ2UnLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgQGRpcmVjdGlvblxuICAgIGlmKCdAZGlyZWN0aW9uJyBpbiBjdHgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3R4WydAZGlyZWN0aW9uJ107XG4gICAgICBpZihhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgPT09ICdqc29uLWxkLTEuMCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAZGlyZWN0aW9uIG5vdCBjb21wYXRpYmxlIHdpdGggJyArXG4gICAgICAgICAgYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBjb250ZXh0IG1lbWJlcicsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfVxuICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHJ2YWxbJ0BkaXJlY3Rpb24nXTtcbiAgICAgIH0gZWxzZSBpZih2YWx1ZSAhPT0gJ2x0cicgJiYgdmFsdWUgIT09ICdydGwnKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgdGhlIHZhbHVlIG9mIFwiQGRpcmVjdGlvblwiIGluIGEgJyArXG4gICAgICAgICAgJ0Bjb250ZXh0IG11c3QgYmUgbnVsbCwgXCJsdHJcIiwgb3IgXCJydGxcIi4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBiYXNlIGRpcmVjdGlvbicsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbFsnQGRpcmVjdGlvbiddID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBkZWZpbmVkLnNldCgnQGRpcmVjdGlvbicsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBAcHJvcGFnYXRlXG4gICAgLy8gbm90ZTogd2UndmUgYWxyZWFkeSBleHRyYWN0ZWQgaXQsIGhlcmUgd2UganVzdCBkbyBlcnJvciBjaGVja2luZ1xuICAgIGlmKCdAcHJvcGFnYXRlJyBpbiBjdHgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3R4WydAcHJvcGFnYXRlJ107XG4gICAgICBpZihhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgPT09ICdqc29uLWxkLTEuMCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAcHJvcGFnYXRlIG5vdCBjb21wYXRpYmxlIHdpdGggJyArXG4gICAgICAgICAgYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBjb250ZXh0IGVudHJ5JywgY29udGV4dDogY3R4fSk7XG4gICAgICB9XG4gICAgICBpZih0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBwcm9wYWdhdGUgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgQHByb3BhZ2F0ZSB2YWx1ZScsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICB9XG4gICAgICBkZWZpbmVkLnNldCgnQHByb3BhZ2F0ZScsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBAaW1wb3J0XG4gICAgaWYoJ0BpbXBvcnQnIGluIGN0eCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjdHhbJ0BpbXBvcnQnXTtcbiAgICAgIGlmKGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSA9PT0gJ2pzb24tbGQtMS4wJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBpbXBvcnQgbm90IGNvbXBhdGlibGUgd2l0aCAnICtcbiAgICAgICAgICBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRleHQgZW50cnknLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH1cbiAgICAgIGlmKCFfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGltcG9ydCBtdXN0IGJlIGEgc3RyaW5nLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIEBpbXBvcnQgdmFsdWUnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZXNvbHZlIGNvbnRleHRzXG4gICAgICBjb25zdCByZXNvbHZlZEltcG9ydCA9IGF3YWl0IG9wdGlvbnMuY29udGV4dFJlc29sdmVyLnJlc29sdmUoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGNvbnRleHQ6IHZhbHVlLFxuICAgICAgICBkb2N1bWVudExvYWRlcjogb3B0aW9ucy5kb2N1bWVudExvYWRlcixcbiAgICAgICAgYmFzZTogb3B0aW9ucy5iYXNlXG4gICAgICB9KTtcbiAgICAgIGlmKHJlc29sdmVkSW1wb3J0Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBpbXBvcnQgbXVzdCByZWZlcmVuY2UgYSBzaW5nbGUgY29udGV4dC4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCByZW1vdGUgY29udGV4dCcsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9jZXNzZWRJbXBvcnQgPSByZXNvbHZlZEltcG9ydFswXS5nZXRQcm9jZXNzZWQoYWN0aXZlQ3R4KTtcbiAgICAgIGlmKHByb2Nlc3NlZEltcG9ydCkge1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGUgc2FtZSBjb250ZXh0IHdlcmUgdXNlZCBpbiB0aGlzIGFjdGl2ZSBjb250ZXh0XG4gICAgICAgIC8vIGFzIGEgcmVmZXJlbmNlIGNvbnRleHQsIHRoZW4gcHJvY2Vzc2VkX2lucHV0IG1pZ2h0IG5vdFxuICAgICAgICAvLyBiZSBhIGRpY3QuXG4gICAgICAgIGN0eCA9IHByb2Nlc3NlZEltcG9ydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGltcG9ydEN0eCA9IHJlc29sdmVkSW1wb3J0WzBdLmRvY3VtZW50O1xuICAgICAgICBpZignQGltcG9ydCcgaW4gaW1wb3J0Q3R4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg6ICcgK1xuICAgICAgICAgICAgJ2ltcG9ydGVkIGNvbnRleHQgbXVzdCBub3QgaW5jbHVkZSBAaW1wb3J0LicsXG4gICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBjb250ZXh0IGVudHJ5JywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1lcmdlIGN0eCBpbnRvIGltcG9ydEN0eCBhbmQgcmVwbGFjZSBydmFsIHdpdGggdGhlIHJlc3VsdFxuICAgICAgICBmb3IoY29uc3Qga2V5IGluIGltcG9ydEN0eCkge1xuICAgICAgICAgIGlmKCFjdHguaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY3R4W2tleV0gPSBpbXBvcnRDdHhba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlOiB0aGlzIGNvdWxkIHBvdGVuaWFsbHkgY29uZmxpY3QgaWYgdGhlIGltcG9ydFxuICAgICAgICAvLyB3ZXJlIHVzZWQgaW4gdGhlIHNhbWUgYWN0aXZlIGNvbnRleHQgYXMgYSByZWZlcmVuY2VkXG4gICAgICAgIC8vIGNvbnRleHQgYW5kIGFuIGltcG9ydC4gSW4gdGhpcyBjYXNlLCB3ZVxuICAgICAgICAvLyBjb3VsZCBvdmVycmlkZSB0aGUgY2FjaGVkIHJlc3VsdCwgYnV0IHNlZW1zIHVubGlrZWx5LlxuICAgICAgICByZXNvbHZlZEltcG9ydFswXS5zZXRQcm9jZXNzZWQoYWN0aXZlQ3R4LCBjdHgpO1xuICAgICAgfVxuXG4gICAgICBkZWZpbmVkLnNldCgnQGltcG9ydCcsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBAcHJvdGVjdGVkOyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIHN1Yi1jb250ZXh0IGlzIGRlY2xhcmluZ1xuICAgIC8vIGFsbCBpdHMgdGVybXMgdG8gYmUgXCJwcm90ZWN0ZWRcIiAoZXhjZXB0aW9ucyBjYW4gYmUgbWFkZSBvbiBhXG4gICAgLy8gcGVyLWRlZmluaXRpb24gYmFzaXMpXG4gICAgZGVmaW5lZC5zZXQoJ0Bwcm90ZWN0ZWQnLCBjdHhbJ0Bwcm90ZWN0ZWQnXSB8fCBmYWxzZSk7XG5cbiAgICAvLyBwcm9jZXNzIGFsbCBvdGhlciBrZXlzXG4gICAgZm9yKGNvbnN0IGtleSBpbiBjdHgpIHtcbiAgICAgIGFwaS5jcmVhdGVUZXJtRGVmaW5pdGlvbih7XG4gICAgICAgIGFjdGl2ZUN0eDogcnZhbCxcbiAgICAgICAgbG9jYWxDdHg6IGN0eCxcbiAgICAgICAgdGVybToga2V5LFxuICAgICAgICBkZWZpbmVkLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBvdmVycmlkZVByb3RlY3RlZFxuICAgICAgfSk7XG5cbiAgICAgIGlmKF9pc09iamVjdChjdHhba2V5XSkgJiYgJ0Bjb250ZXh0JyBpbiBjdHhba2V5XSkge1xuICAgICAgICBjb25zdCBrZXlDdHggPSBjdHhba2V5XVsnQGNvbnRleHQnXTtcbiAgICAgICAgbGV0IHByb2Nlc3MgPSB0cnVlO1xuICAgICAgICBpZihfaXNTdHJpbmcoa2V5Q3R4KSkge1xuICAgICAgICAgIGNvbnN0IHVybCA9IHByZXBlbmRCYXNlKG9wdGlvbnMuYmFzZSwga2V5Q3R4KTtcbiAgICAgICAgICAvLyB0cmFjayBwcm9jZXNzZWQgY29udGV4dHMgdG8gYXZvaWQgc2NvcGVkIGNvbnRleHQgcmVjdXJzaW9uXG4gICAgICAgICAgaWYoY3ljbGVzLmhhcyh1cmwpKSB7XG4gICAgICAgICAgICBwcm9jZXNzID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5Y2xlcy5hZGQodXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFyc2UgY29udGV4dCB0byB2YWxpZGF0ZVxuICAgICAgICBpZihwcm9jZXNzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGFwaS5wcm9jZXNzKHtcbiAgICAgICAgICAgICAgYWN0aXZlQ3R4OiBydmFsLmNsb25lKCksXG4gICAgICAgICAgICAgIGxvY2FsQ3R4OiBjdHhba2V5XVsnQGNvbnRleHQnXSxcbiAgICAgICAgICAgICAgb3ZlcnJpZGVQcm90ZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIGN5Y2xlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBpbnZhbGlkIHNjb3BlZCBjb250ZXh0LicsXG4gICAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29kZTogJ2ludmFsaWQgc2NvcGVkIGNvbnRleHQnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGN0eFtrZXldWydAY29udGV4dCddLFxuICAgICAgICAgICAgICAgIHRlcm06IGtleVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWNoZSBwcm9jZXNzZWQgcmVzdWx0XG4gICAgcmVzb2x2ZWRDb250ZXh0LnNldFByb2Nlc3NlZChhY3RpdmVDdHgsIHJ2YWwpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXJtIGRlZmluaXRpb24gZHVyaW5nIGNvbnRleHQgcHJvY2Vzc2luZy5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBjdXJyZW50IGFjdGl2ZSBjb250ZXh0LlxuICogQHBhcmFtIGxvY2FsQ3R4IHRoZSBsb2NhbCBjb250ZXh0IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB0ZXJtIHRoZSB0ZXJtIGluIHRoZSBsb2NhbCBjb250ZXh0IHRvIGRlZmluZSB0aGUgbWFwcGluZyBmb3IuXG4gKiBAcGFyYW0gZGVmaW5lZCBhIG1hcCBvZiBkZWZpbmluZy9kZWZpbmVkIGtleXMgdG8gZGV0ZWN0IGN5Y2xlcyBhbmQgcHJldmVudFxuICogICAgICAgICAgZG91YmxlIGRlZmluaXRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGNyZWF0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvdGVjdGVkTW9kZT1cImVycm9yXCJdIC0gXCJlcnJvclwiIHRvIHRocm93IGVycm9yXG4gKiAgIG9uIGBAcHJvdGVjdGVkYCBjb25zdHJhaW50IHZpb2xhdGlvbiwgXCJ3YXJuXCIgdG8gYWxsb3cgdmlvbGF0aW9ucyBhbmRcbiAqICAgc2lnbmFsIGEgd2FybmluZy5cbiAqIEBwYXJhbSBvdmVycmlkZVByb3RlY3RlZCBgZmFsc2VgIGFsbG93cyBwcm90ZWN0ZWQgdGVybXMgdG8gYmUgbW9kaWZpZWQuXG4gKi9cbmFwaS5jcmVhdGVUZXJtRGVmaW5pdGlvbiA9ICh7XG4gIGFjdGl2ZUN0eCxcbiAgbG9jYWxDdHgsXG4gIHRlcm0sXG4gIGRlZmluZWQsXG4gIG9wdGlvbnMsXG4gIG92ZXJyaWRlUHJvdGVjdGVkID0gZmFsc2UsXG59KSA9PiB7XG4gIGlmKGRlZmluZWQuaGFzKHRlcm0pKSB7XG4gICAgLy8gdGVybSBhbHJlYWR5IGRlZmluZWRcbiAgICBpZihkZWZpbmVkLmdldCh0ZXJtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjeWNsZSBkZXRlY3RlZFxuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdDeWNsaWNhbCBjb250ZXh0IGRlZmluaXRpb24gZGV0ZWN0ZWQuJyxcbiAgICAgICdqc29ubGQuQ3ljbGljYWxDb250ZXh0JyxcbiAgICAgIHtjb2RlOiAnY3ljbGljIElSSSBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHgsIHRlcm19KTtcbiAgfVxuXG4gIC8vIG5vdyBkZWZpbmluZyB0ZXJtXG4gIGRlZmluZWQuc2V0KHRlcm0sIGZhbHNlKTtcblxuICAvLyBnZXQgY29udGV4dCB0ZXJtIHZhbHVlXG4gIGxldCB2YWx1ZTtcbiAgaWYobG9jYWxDdHguaGFzT3duUHJvcGVydHkodGVybSkpIHtcbiAgICB2YWx1ZSA9IGxvY2FsQ3R4W3Rlcm1dO1xuICB9XG5cbiAgaWYodGVybSA9PT0gJ0B0eXBlJyAmJlxuICAgICBfaXNPYmplY3QodmFsdWUpICYmXG4gICAgICh2YWx1ZVsnQGNvbnRhaW5lciddIHx8ICdAc2V0JykgPT09ICdAc2V0JyAmJlxuICAgICBhcGkucHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpKSB7XG5cbiAgICBjb25zdCB2YWxpZEtleXMgPSBbJ0Bjb250YWluZXInLCAnQGlkJywgJ0Bwcm90ZWN0ZWQnXTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGlmKGtleXMubGVuZ3RoID09PSAwIHx8IGtleXMuc29tZShrID0+ICF2YWxpZEtleXMuaW5jbHVkZXMoaykpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBrZXl3b3JkcyBjYW5ub3QgYmUgb3ZlcnJpZGRlbi4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdrZXl3b3JkIHJlZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4LCB0ZXJtfSk7XG4gICAgfVxuICB9IGVsc2UgaWYoYXBpLmlzS2V5d29yZCh0ZXJtKSkge1xuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBrZXl3b3JkcyBjYW5ub3QgYmUgb3ZlcnJpZGRlbi4nLFxuICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICB7Y29kZTogJ2tleXdvcmQgcmVkZWZpbml0aW9uJywgY29udGV4dDogbG9jYWxDdHgsIHRlcm19KTtcbiAgfSBlbHNlIGlmKHRlcm0ubWF0Y2goS0VZV09SRF9QQVRURVJOKSkge1xuICAgIC8vIEZJWE1FOiByZW1vdmUgbG9nZ2luZyBhbmQgdXNlIGEgaGFuZGxlclxuICAgIGNvbnNvbGUud2FybignV0FSTklORzogdGVybXMgYmVnaW5uaW5nIHdpdGggXCJAXCIgYXJlIHJlc2VydmVkJyArXG4gICAgICAnIGZvciBmdXR1cmUgdXNlIGFuZCBpZ25vcmVkJywge3Rlcm19KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZih0ZXJtID09PSAnJykge1xuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIHRlcm0gY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZy4nLFxuICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICB7Y29kZTogJ2ludmFsaWQgdGVybSBkZWZpbml0aW9uJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgfVxuXG4gIC8vIGtlZXAgcmVmZXJlbmNlIHRvIHByZXZpb3VzIG1hcHBpbmcgZm9yIHBvdGVudGlhbCBgQHByb3RlY3RlZGAgY2hlY2tcbiAgY29uc3QgcHJldmlvdXNNYXBwaW5nID0gYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldCh0ZXJtKTtcblxuICAvLyByZW1vdmUgb2xkIG1hcHBpbmdcbiAgaWYoYWN0aXZlQ3R4Lm1hcHBpbmdzLmhhcyh0ZXJtKSkge1xuICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5kZWxldGUodGVybSk7XG4gIH1cblxuICAvLyBjb252ZXJ0IHNob3J0LWhhbmQgdmFsdWUgdG8gb2JqZWN0IHcvQGlkXG4gIGxldCBzaW1wbGVUZXJtID0gZmFsc2U7XG4gIGlmKF9pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICBzaW1wbGVUZXJtID0gdHJ1ZTtcbiAgICB2YWx1ZSA9IHsnQGlkJzogdmFsdWV9O1xuICB9XG5cbiAgaWYoIV9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgdGVybSB2YWx1ZXMgbXVzdCBiZSAnICtcbiAgICAgICdzdHJpbmdzIG9yIG9iamVjdHMuJyxcbiAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAge2NvZGU6ICdpbnZhbGlkIHRlcm0gZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gIH1cblxuICAvLyBjcmVhdGUgbmV3IG1hcHBpbmdcbiAgY29uc3QgbWFwcGluZyA9IHt9O1xuICBhY3RpdmVDdHgubWFwcGluZ3Muc2V0KHRlcm0sIG1hcHBpbmcpO1xuICBtYXBwaW5nLnJldmVyc2UgPSBmYWxzZTtcblxuICAvLyBtYWtlIHN1cmUgdGVybSBkZWZpbml0aW9uIG9ubHkgaGFzIGV4cGVjdGVkIGtleXdvcmRzXG4gIGNvbnN0IHZhbGlkS2V5cyA9IFsnQGNvbnRhaW5lcicsICdAaWQnLCAnQGxhbmd1YWdlJywgJ0ByZXZlcnNlJywgJ0B0eXBlJ107XG5cbiAgLy8gSlNPTi1MRCAxLjEgc3VwcG9ydFxuICBpZihhcGkucHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpKSB7XG4gICAgdmFsaWRLZXlzLnB1c2goXG4gICAgICAnQGNvbnRleHQnLCAnQGRpcmVjdGlvbicsICdAaW5kZXgnLCAnQG5lc3QnLCAnQHByZWZpeCcsICdAcHJvdGVjdGVkJyk7XG4gIH1cblxuICBmb3IoY29uc3Qga3cgaW4gdmFsdWUpIHtcbiAgICBpZighdmFsaWRLZXlzLmluY2x1ZGVzKGt3KSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYSB0ZXJtIGRlZmluaXRpb24gbXVzdCBub3QgY29udGFpbiAnICsga3csXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgdGVybSBkZWZpbml0aW9uJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gIH1cblxuICAvLyBhbHdheXMgY29tcHV0ZSB3aGV0aGVyIHRlcm0gaGFzIGEgY29sb24gYXMgYW4gb3B0aW1pemF0aW9uIGZvclxuICAvLyBfY29tcGFjdElyaVxuICBjb25zdCBjb2xvbiA9IHRlcm0uaW5kZXhPZignOicpO1xuICBtYXBwaW5nLl90ZXJtSGFzQ29sb24gPSAoY29sb24gPiAwKTtcblxuICBpZignQHJldmVyc2UnIGluIHZhbHVlKSB7XG4gICAgaWYoJ0BpZCcgaW4gdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEgQHJldmVyc2UgdGVybSBkZWZpbml0aW9uIG11c3Qgbm90ICcgK1xuICAgICAgICAnY29udGFpbiBAaWQuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCByZXZlcnNlIHByb3BlcnR5JywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gICAgaWYoJ0BuZXN0JyBpbiB2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYSBAcmV2ZXJzZSB0ZXJtIGRlZmluaXRpb24gbXVzdCBub3QgJyArXG4gICAgICAgICdjb250YWluIEBuZXN0LicsICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgcmV2ZXJzZSBwcm9wZXJ0eScsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuICAgIGNvbnN0IHJldmVyc2UgPSB2YWx1ZVsnQHJldmVyc2UnXTtcbiAgICBpZighX2lzU3RyaW5nKHJldmVyc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIEBjb250ZXh0IEByZXZlcnNlIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBJUkkgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuXG4gICAgaWYoIWFwaS5pc0tleXdvcmQocmV2ZXJzZSkgJiYgcmV2ZXJzZS5tYXRjaChLRVlXT1JEX1BBVFRFUk4pKSB7XG4gICAgICAvLyBGSVhNRTogcmVtb3ZlIGxvZ2dpbmcgYW5kIHVzZSBhIGhhbmRsZXJcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogdmFsdWVzIGJlZ2lubmluZyB3aXRoIFwiQFwiIGFyZSByZXNlcnZlZCcgK1xuICAgICAgICAnIGZvciBmdXR1cmUgdXNlIGFuZCBpZ25vcmVkJywge3JldmVyc2V9KTtcbiAgICAgIGlmKHByZXZpb3VzTWFwcGluZykge1xuICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3Muc2V0KHRlcm0sIHByZXZpb3VzTWFwcGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3MuZGVsZXRlKHRlcm0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4cGFuZCBhbmQgYWRkIEBpZCBtYXBwaW5nXG4gICAgY29uc3QgaWQgPSBfZXhwYW5kSXJpKFxuICAgICAgYWN0aXZlQ3R4LCByZXZlcnNlLCB7dm9jYWI6IHRydWUsIGJhc2U6IGZhbHNlfSwgbG9jYWxDdHgsIGRlZmluZWQsXG4gICAgICBvcHRpb25zKTtcbiAgICBpZighX2lzQWJzb2x1dGVJcmkoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIEBjb250ZXh0IEByZXZlcnNlIHZhbHVlIG11c3QgYmUgYW4gJyArXG4gICAgICAgICdhYnNvbHV0ZSBJUkkgb3IgYSBibGFuayBub2RlIGlkZW50aWZpZXIuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBJUkkgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuXG4gICAgbWFwcGluZ1snQGlkJ10gPSBpZDtcbiAgICBtYXBwaW5nLnJldmVyc2UgPSB0cnVlO1xuICB9IGVsc2UgaWYoJ0BpZCcgaW4gdmFsdWUpIHtcbiAgICBsZXQgaWQgPSB2YWx1ZVsnQGlkJ107XG4gICAgaWYoaWQgJiYgIV9pc1N0cmluZyhpZCkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEgQGNvbnRleHQgQGlkIHZhbHVlIG11c3QgYmUgYW4gYXJyYXkgJyArXG4gICAgICAgICdvZiBzdHJpbmdzIG9yIGEgc3RyaW5nLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgSVJJIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBpZihpZCA9PT0gbnVsbCkge1xuICAgICAgLy8gcmVzZXJ2ZSBhIG51bGwgdGVybSwgd2hpY2ggbWF5IGJlIHByb3RlY3RlZFxuICAgICAgbWFwcGluZ1snQGlkJ10gPSBudWxsO1xuICAgIH0gZWxzZSBpZighYXBpLmlzS2V5d29yZChpZCkgJiYgaWQubWF0Y2goS0VZV09SRF9QQVRURVJOKSkge1xuICAgICAgLy8gRklYTUU6IHJlbW92ZSBsb2dnaW5nIGFuZCB1c2UgYSBoYW5kbGVyXG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IHZhbHVlcyBiZWdpbm5pbmcgd2l0aCBcIkBcIiBhcmUgcmVzZXJ2ZWQnICtcbiAgICAgICAgJyBmb3IgZnV0dXJlIHVzZSBhbmQgaWdub3JlZCcsIHtpZH0pO1xuICAgICAgaWYocHJldmlvdXNNYXBwaW5nKSB7XG4gICAgICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5zZXQodGVybSwgcHJldmlvdXNNYXBwaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5kZWxldGUodGVybSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmKGlkICE9PSB0ZXJtKSB7XG4gICAgICAvLyBleHBhbmQgYW5kIGFkZCBAaWQgbWFwcGluZ1xuICAgICAgaWQgPSBfZXhwYW5kSXJpKFxuICAgICAgICBhY3RpdmVDdHgsIGlkLCB7dm9jYWI6IHRydWUsIGJhc2U6IGZhbHNlfSwgbG9jYWxDdHgsIGRlZmluZWQsIG9wdGlvbnMpO1xuICAgICAgaWYoIV9pc0Fic29sdXRlSXJpKGlkKSAmJiAhYXBpLmlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIEBjb250ZXh0IEBpZCB2YWx1ZSBtdXN0IGJlIGFuICcgK1xuICAgICAgICAgICdhYnNvbHV0ZSBJUkksIGEgYmxhbmsgbm9kZSBpZGVudGlmaWVyLCBvciBhIGtleXdvcmQuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgSVJJIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0ZXJtIGhhcyB0aGUgZm9ybSBvZiBhbiBJUkkgaXQgbXVzdCBtYXAgdGhlIHNhbWVcbiAgICAgIGlmKHRlcm0ubWF0Y2goLyg/OjpbXjpdKXxcXC8vKSkge1xuICAgICAgICBjb25zdCB0ZXJtRGVmaW5lZCA9IG5ldyBNYXAoZGVmaW5lZCkuc2V0KHRlcm0sIHRydWUpO1xuICAgICAgICBjb25zdCB0ZXJtSXJpID0gX2V4cGFuZElyaShcbiAgICAgICAgICBhY3RpdmVDdHgsIHRlcm0sIHt2b2NhYjogdHJ1ZSwgYmFzZTogZmFsc2V9LFxuICAgICAgICAgIGxvY2FsQ3R4LCB0ZXJtRGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgIGlmKHRlcm1JcmkgIT09IGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IHRlcm0gaW4gZm9ybSBvZiBJUkkgbXVzdCAnICtcbiAgICAgICAgICAgICdleHBhbmQgdG8gZGVmaW5pdGlvbi4nLFxuICAgICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgSVJJIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hcHBpbmdbJ0BpZCddID0gaWQ7XG4gICAgICAvLyBpbmRpY2F0ZSBpZiB0aGlzIHRlcm0gbWF5IGJlIHVzZWQgYXMgYSBjb21wYWN0IElSSSBwcmVmaXhcbiAgICAgIG1hcHBpbmcuX3ByZWZpeCA9IChzaW1wbGVUZXJtICYmXG4gICAgICAgICFtYXBwaW5nLl90ZXJtSGFzQ29sb24gJiZcbiAgICAgICAgaWQubWF0Y2goL1s6XFwvXFw/I1xcW1xcXUBdJC8pKTtcbiAgICB9XG4gIH1cblxuICBpZighKCdAaWQnIGluIG1hcHBpbmcpKSB7XG4gICAgLy8gc2VlIGlmIHRoZSB0ZXJtIGhhcyBhIHByZWZpeFxuICAgIGlmKG1hcHBpbmcuX3Rlcm1IYXNDb2xvbikge1xuICAgICAgY29uc3QgcHJlZml4ID0gdGVybS5zdWJzdHIoMCwgY29sb24pO1xuICAgICAgaWYobG9jYWxDdHguaGFzT3duUHJvcGVydHkocHJlZml4KSkge1xuICAgICAgICAvLyBkZWZpbmUgcGFyZW50IHByZWZpeFxuICAgICAgICBhcGkuY3JlYXRlVGVybURlZmluaXRpb24oe1xuICAgICAgICAgIGFjdGl2ZUN0eCwgbG9jYWxDdHgsIHRlcm06IHByZWZpeCwgZGVmaW5lZCwgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYoYWN0aXZlQ3R4Lm1hcHBpbmdzLmhhcyhwcmVmaXgpKSB7XG4gICAgICAgIC8vIHNldCBAaWQgYmFzZWQgb24gcHJlZml4IHBhcmVudFxuICAgICAgICBjb25zdCBzdWZmaXggPSB0ZXJtLnN1YnN0cihjb2xvbiArIDEpO1xuICAgICAgICBtYXBwaW5nWydAaWQnXSA9IGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQocHJlZml4KVsnQGlkJ10gKyBzdWZmaXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZXJtIGlzIGFuIGFic29sdXRlIElSSVxuICAgICAgICBtYXBwaW5nWydAaWQnXSA9IHRlcm07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHRlcm0gPT09ICdAdHlwZScpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSwgd2VyZSB3ZSd2ZSBwcmV2aW91c2x5IGRldGVybWluZWQgdGhhdCBjb250YWluZXIgaXMgQHNldFxuICAgICAgbWFwcGluZ1snQGlkJ10gPSB0ZXJtO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub24tSVJJcyAqbXVzdCogZGVmaW5lIEBpZHMgaWYgQHZvY2FiIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgIGlmKCEoJ0B2b2NhYicgaW4gYWN0aXZlQ3R4KSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBjb250ZXh0IHRlcm1zIG11c3QgZGVmaW5lIGFuIEBpZC4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBJUkkgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4LCB0ZXJtfSk7XG4gICAgICB9XG4gICAgICAvLyBwcmVwZW5kIHZvY2FiIHRvIHRlcm1cbiAgICAgIG1hcHBpbmdbJ0BpZCddID0gYWN0aXZlQ3R4WydAdm9jYWInXSArIHRlcm07XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHRlcm0gcHJvdGVjdGlvblxuICBpZih2YWx1ZVsnQHByb3RlY3RlZCddID09PSB0cnVlIHx8XG4gICAgKGRlZmluZWQuZ2V0KCdAcHJvdGVjdGVkJykgPT09IHRydWUgJiYgdmFsdWVbJ0Bwcm90ZWN0ZWQnXSAhPT0gZmFsc2UpKSB7XG4gICAgYWN0aXZlQ3R4LnByb3RlY3RlZFt0ZXJtXSA9IHRydWU7XG4gICAgbWFwcGluZy5wcm90ZWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gSVJJIG1hcHBpbmcgbm93IGRlZmluZWRcbiAgZGVmaW5lZC5zZXQodGVybSwgdHJ1ZSk7XG5cbiAgaWYoJ0B0eXBlJyBpbiB2YWx1ZSkge1xuICAgIGxldCB0eXBlID0gdmFsdWVbJ0B0eXBlJ107XG4gICAgaWYoIV9pc1N0cmluZyh0eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYW4gQGNvbnRleHQgQHR5cGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHR5cGUgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuXG4gICAgaWYoKHR5cGUgPT09ICdAanNvbicgfHwgdHlwZSA9PT0gJ0Bub25lJykpIHtcbiAgICAgIGlmKGFwaS5wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhbiBAY29udGV4dCBAdHlwZSB2YWx1ZSBtdXN0IG5vdCBiZSAnICtcbiAgICAgICAgICBgXCIke3R5cGV9XCIgaW4gSlNPTi1MRCAxLjAgbW9kZS5gLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCB0eXBlIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlICE9PSAnQGlkJyAmJiB0eXBlICE9PSAnQHZvY2FiJykge1xuICAgICAgLy8gZXhwYW5kIEB0eXBlIHRvIGZ1bGwgSVJJXG4gICAgICB0eXBlID0gX2V4cGFuZElyaShcbiAgICAgICAgYWN0aXZlQ3R4LCB0eXBlLCB7dm9jYWI6IHRydWUsIGJhc2U6IGZhbHNlfSwgbG9jYWxDdHgsIGRlZmluZWQsXG4gICAgICAgIG9wdGlvbnMpO1xuICAgICAgaWYoIV9pc0Fic29sdXRlSXJpKHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYW4gQGNvbnRleHQgQHR5cGUgdmFsdWUgbXVzdCBiZSBhbiAnICtcbiAgICAgICAgICAnYWJzb2x1dGUgSVJJLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIHR5cGUgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICB9XG4gICAgICBpZih0eXBlLmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhbiBAY29udGV4dCBAdHlwZSB2YWx1ZSBtdXN0IGJlIGFuIElSSSwgJyArXG4gICAgICAgICAgJ25vdCBhIGJsYW5rIG5vZGUgaWRlbnRpZmllci4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCB0eXBlIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBAdHlwZSB0byBtYXBwaW5nXG4gICAgbWFwcGluZ1snQHR5cGUnXSA9IHR5cGU7XG4gIH1cblxuICBpZignQGNvbnRhaW5lcicgaW4gdmFsdWUpIHtcbiAgICAvLyBub3JtYWxpemUgY29udGFpbmVyIHRvIGFuIGFycmF5IGZvcm1cbiAgICBjb25zdCBjb250YWluZXIgPSBfaXNTdHJpbmcodmFsdWVbJ0Bjb250YWluZXInXSkgP1xuICAgICAgW3ZhbHVlWydAY29udGFpbmVyJ11dIDogKHZhbHVlWydAY29udGFpbmVyJ10gfHwgW10pO1xuICAgIGNvbnN0IHZhbGlkQ29udGFpbmVycyA9IFsnQGxpc3QnLCAnQHNldCcsICdAaW5kZXgnLCAnQGxhbmd1YWdlJ107XG4gICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgIGNvbnN0IGhhc1NldCA9IGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpO1xuXG4gICAgLy8gSlNPTi1MRCAxLjEgc3VwcG9ydFxuICAgIGlmKGFwaS5wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSkpIHtcbiAgICAgIHZhbGlkQ29udGFpbmVycy5wdXNoKCdAZ3JhcGgnLCAnQGlkJywgJ0B0eXBlJyk7XG5cbiAgICAgIC8vIGNoZWNrIGNvbnRhaW5lciBsZW5ndGhcbiAgICAgIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGxpc3QnKSkge1xuICAgICAgICBpZihjb250YWluZXIubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBjb250ZXh0IEBjb250YWluZXIgd2l0aCBAbGlzdCBtdXN0ICcgK1xuICAgICAgICAgICAgJ2hhdmUgbm8gb3RoZXIgdmFsdWVzJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRhaW5lciBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGdyYXBoJykpIHtcbiAgICAgICAgaWYoY29udGFpbmVyLnNvbWUoa2V5ID0+XG4gICAgICAgICAga2V5ICE9PSAnQGdyYXBoJyAmJiBrZXkgIT09ICdAaWQnICYmIGtleSAhPT0gJ0BpbmRleCcgJiZcbiAgICAgICAgICBrZXkgIT09ICdAc2V0JykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgQGNvbnRhaW5lciB3aXRoIEBncmFwaCBtdXN0ICcgK1xuICAgICAgICAgICAgJ2hhdmUgbm8gb3RoZXIgdmFsdWVzIG90aGVyIHRoYW4gQGlkLCBAaW5kZXgsIGFuZCBAc2V0JyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRhaW5lciBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBjb250YWluZXIgbWF5IGFsc28gaW5jbHVkZSBAc2V0XG4gICAgICAgIGlzVmFsaWQgJj0gY29udGFpbmVyLmxlbmd0aCA8PSAoaGFzU2V0ID8gMiA6IDEpO1xuICAgICAgfVxuXG4gICAgICBpZihjb250YWluZXIuaW5jbHVkZXMoJ0B0eXBlJykpIHtcbiAgICAgICAgLy8gSWYgbWFwcGluZyBkb2VzIG5vdCBoYXZlIGFuIEB0eXBlLFxuICAgICAgICAvLyBzZXQgaXQgdG8gQGlkXG4gICAgICAgIG1hcHBpbmdbJ0B0eXBlJ10gPSBtYXBwaW5nWydAdHlwZSddIHx8ICdAaWQnO1xuXG4gICAgICAgIC8vIHR5cGUgbWFwcGluZyBtdXN0IGJlIGVpdGhlciBAaWQgb3IgQHZvY2FiXG4gICAgICAgIGlmKCFbJ0BpZCcsICdAdm9jYWInXS5pbmNsdWRlcyhtYXBwaW5nWydAdHlwZSddKSkge1xuICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBjb250YWluZXI6IEB0eXBlIHJlcXVpcmVzIEB0eXBlIHRvIGJlICcgK1xuICAgICAgICAgICAgJ0BpZCBvciBAdm9jYWIuJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIHR5cGUgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gSlNPTi1MRCAxLjAsIGNvbnRhaW5lciBtdXN0IG5vdCBiZSBhbiBhcnJheSAoaXQgbXVzdCBiZSBhIHN0cmluZyxcbiAgICAgIC8vIHdoaWNoIGlzIG9uZSBvZiB0aGUgdmFsaWRDb250YWluZXJzKVxuICAgICAgaXNWYWxpZCAmPSAhX2lzQXJyYXkodmFsdWVbJ0Bjb250YWluZXInXSk7XG5cbiAgICAgIC8vIGNoZWNrIGNvbnRhaW5lciBsZW5ndGhcbiAgICAgIGlzVmFsaWQgJj0gY29udGFpbmVyLmxlbmd0aCA8PSAxO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGFnYWluc3QgdmFsaWQgY29udGFpbmVyc1xuICAgIGlzVmFsaWQgJj0gY29udGFpbmVyLmV2ZXJ5KGMgPT4gdmFsaWRDb250YWluZXJzLmluY2x1ZGVzKGMpKTtcblxuICAgIC8vIEBzZXQgbm90IGFsbG93ZWQgd2l0aCBAbGlzdFxuICAgIGlzVmFsaWQgJj0gIShoYXNTZXQgJiYgY29udGFpbmVyLmluY2x1ZGVzKCdAbGlzdCcpKTtcblxuICAgIGlmKCFpc1ZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBAY29udGFpbmVyIHZhbHVlIG11c3QgYmUgJyArXG4gICAgICAgICdvbmUgb2YgdGhlIGZvbGxvd2luZzogJyArIHZhbGlkQ29udGFpbmVycy5qb2luKCcsICcpLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRhaW5lciBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG5cbiAgICBpZihtYXBwaW5nLnJldmVyc2UgJiZcbiAgICAgICFjb250YWluZXIuZXZlcnkoYyA9PiBbJ0BpbmRleCcsICdAc2V0J10uaW5jbHVkZXMoYykpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBAY29udGFpbmVyIHZhbHVlIGZvciBhIEByZXZlcnNlICcgK1xuICAgICAgICAndHlwZSBkZWZpbml0aW9uIG11c3QgYmUgQGluZGV4IG9yIEBzZXQuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCByZXZlcnNlIHByb3BlcnR5JywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgQGNvbnRhaW5lciB0byBtYXBwaW5nXG4gICAgbWFwcGluZ1snQGNvbnRhaW5lciddID0gY29udGFpbmVyO1xuICB9XG5cbiAgLy8gcHJvcGVydHkgaW5kZXhpbmdcbiAgaWYoJ0BpbmRleCcgaW4gdmFsdWUpIHtcbiAgICBpZighKCdAY29udGFpbmVyJyBpbiB2YWx1ZSkgfHwgIW1hcHBpbmdbJ0Bjb250YWluZXInXS5pbmNsdWRlcygnQGluZGV4JykpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBpbmRleCB3aXRob3V0IEBpbmRleCBpbiBAY29udGFpbmVyOiAnICtcbiAgICAgICAgYFwiJHt2YWx1ZVsnQGluZGV4J119XCIgb24gdGVybSBcIiR7dGVybX1cIi5gLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHRlcm0gZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuICAgIGlmKCFfaXNTdHJpbmcodmFsdWVbJ0BpbmRleCddKSB8fCB2YWx1ZVsnQGluZGV4J10uaW5kZXhPZignQCcpID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAaW5kZXggbXVzdCBleHBhbmQgdG8gYW4gSVJJOiAnICtcbiAgICAgICAgYFwiJHt2YWx1ZVsnQGluZGV4J119XCIgb24gdGVybSBcIiR7dGVybX1cIi5gLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHRlcm0gZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuICAgIG1hcHBpbmdbJ0BpbmRleCddID0gdmFsdWVbJ0BpbmRleCddO1xuICB9XG5cbiAgLy8gc2NvcGVkIGNvbnRleHRzXG4gIGlmKCdAY29udGV4dCcgaW4gdmFsdWUpIHtcbiAgICBtYXBwaW5nWydAY29udGV4dCddID0gdmFsdWVbJ0Bjb250ZXh0J107XG4gIH1cblxuICBpZignQGxhbmd1YWdlJyBpbiB2YWx1ZSAmJiAhKCdAdHlwZScgaW4gdmFsdWUpKSB7XG4gICAgbGV0IGxhbmd1YWdlID0gdmFsdWVbJ0BsYW5ndWFnZSddO1xuICAgIGlmKGxhbmd1YWdlICE9PSBudWxsICYmICFfaXNTdHJpbmcobGFuZ3VhZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBAbGFuZ3VhZ2UgdmFsdWUgbXVzdCBiZSAnICtcbiAgICAgICAgJ2Egc3RyaW5nIG9yIG51bGwuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCBsYW5ndWFnZSBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgQGxhbmd1YWdlIHRvIG1hcHBpbmdcbiAgICBpZihsYW5ndWFnZSAhPT0gbnVsbCkge1xuICAgICAgbGFuZ3VhZ2UgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBtYXBwaW5nWydAbGFuZ3VhZ2UnXSA9IGxhbmd1YWdlO1xuICB9XG5cbiAgLy8gdGVybSBtYXkgYmUgdXNlZCBhcyBhIHByZWZpeFxuICBpZignQHByZWZpeCcgaW4gdmFsdWUpIHtcbiAgICBpZih0ZXJtLm1hdGNoKC86fFxcLy8pKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBAcHJlZml4IHVzZWQgb24gYSBjb21wYWN0IElSSSB0ZXJtJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB0ZXJtIGRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBpZihhcGkuaXNLZXl3b3JkKG1hcHBpbmdbJ0BpZCddKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsga2V5d29yZHMgbWF5IG5vdCBiZSB1c2VkIGFzIHByZWZpeGVzJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB0ZXJtIGRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBpZih0eXBlb2YgdmFsdWVbJ0BwcmVmaXgnXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBtYXBwaW5nLl9wcmVmaXggPSB2YWx1ZVsnQHByZWZpeCddID09PSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCB2YWx1ZSBmb3IgQHByZWZpeCBtdXN0IGJlIGJvb2xlYW4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIEBwcmVmaXggdmFsdWUnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmKCdAZGlyZWN0aW9uJyBpbiB2YWx1ZSkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHZhbHVlWydAZGlyZWN0aW9uJ107XG4gICAgaWYoZGlyZWN0aW9uICE9PSBudWxsICYmIGRpcmVjdGlvbiAhPT0gJ2x0cicgJiYgZGlyZWN0aW9uICE9PSAncnRsJykge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGRpcmVjdGlvbiB2YWx1ZSBtdXN0IGJlICcgK1xuICAgICAgICAnbnVsbCwgXCJsdHJcIiwgb3IgXCJydGxcIi4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIGJhc2UgZGlyZWN0aW9uJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gICAgbWFwcGluZ1snQGRpcmVjdGlvbiddID0gZGlyZWN0aW9uO1xuICB9XG5cbiAgaWYoJ0BuZXN0JyBpbiB2YWx1ZSkge1xuICAgIGNvbnN0IG5lc3QgPSB2YWx1ZVsnQG5lc3QnXTtcbiAgICBpZighX2lzU3RyaW5nKG5lc3QpIHx8IChuZXN0ICE9PSAnQG5lc3QnICYmIG5lc3QuaW5kZXhPZignQCcpID09PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgQG5lc3QgdmFsdWUgbXVzdCBiZSAnICtcbiAgICAgICAgJ2Egc3RyaW5nIHdoaWNoIGlzIG5vdCBhIGtleXdvcmQgb3RoZXIgdGhhbiBAbmVzdC4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIEBuZXN0IHZhbHVlJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gICAgbWFwcGluZ1snQG5lc3QnXSA9IG5lc3Q7XG4gIH1cblxuICAvLyBkaXNhbGxvdyBhbGlhc2luZyBAY29udGV4dCBhbmQgQHByZXNlcnZlXG4gIGNvbnN0IGlkID0gbWFwcGluZ1snQGlkJ107XG4gIGlmKGlkID09PSAnQGNvbnRleHQnIHx8IGlkID09PSAnQHByZXNlcnZlJykge1xuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBhbmQgQHByZXNlcnZlIGNhbm5vdCBiZSBhbGlhc2VkLicsXG4gICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIGtleXdvcmQgYWxpYXMnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIG92ZXJyaWRpbmcgcHJvdGVjdGVkIHRlcm1zXG4gIGlmKHByZXZpb3VzTWFwcGluZyAmJiBwcmV2aW91c01hcHBpbmcucHJvdGVjdGVkICYmICFvdmVycmlkZVByb3RlY3RlZCkge1xuICAgIC8vIGZvcmNlIG5ldyB0ZXJtIHRvIGNvbnRpbnVlIHRvIGJlIHByb3RlY3RlZCBhbmQgc2VlIGlmIHRoZSBtYXBwaW5ncyB3b3VsZFxuICAgIC8vIGJlIGVxdWFsXG4gICAgYWN0aXZlQ3R4LnByb3RlY3RlZFt0ZXJtXSA9IHRydWU7XG4gICAgbWFwcGluZy5wcm90ZWN0ZWQgPSB0cnVlO1xuICAgIGlmKCFfZGVlcENvbXBhcmUocHJldmlvdXNNYXBwaW5nLCBtYXBwaW5nKSkge1xuICAgICAgY29uc3QgcHJvdGVjdGVkTW9kZSA9IChvcHRpb25zICYmIG9wdGlvbnMucHJvdGVjdGVkTW9kZSkgfHwgJ2Vycm9yJztcbiAgICAgIGlmKHByb3RlY3RlZE1vZGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyB0cmllZCB0byByZWRlZmluZSBhIHByb3RlY3RlZCB0ZXJtLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdwcm90ZWN0ZWQgdGVybSByZWRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eCwgdGVybX0pO1xuICAgICAgfSBlbHNlIGlmKHByb3RlY3RlZE1vZGUgPT09ICd3YXJuJykge1xuICAgICAgICAvLyBGSVhNRTogcmVtb3ZlIGxvZ2dpbmcgYW5kIHVzZSBhIGhhbmRsZXJcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBwcm90ZWN0ZWQgdGVybSByZWRlZmluaXRpb24nLCB7dGVybX0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIHByb3RlY3RlZE1vZGUuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCBwcm90ZWN0ZWQgbW9kZScsIGNvbnRleHQ6IGxvY2FsQ3R4LCB0ZXJtLFxuICAgICAgICAgIHByb3RlY3RlZE1vZGV9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXhwYW5kcyBhIHN0cmluZyB0byBhIGZ1bGwgSVJJLiBUaGUgc3RyaW5nIG1heSBiZSBhIHRlcm0sIGEgcHJlZml4LCBhXG4gKiByZWxhdGl2ZSBJUkksIG9yIGFuIGFic29sdXRlIElSSS4gVGhlIGFzc29jaWF0ZWQgYWJzb2x1dGUgSVJJIHdpbGwgYmVcbiAqIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGN1cnJlbnQgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHN0cmluZyB0byBleHBhbmQuXG4gKiBAcGFyYW0gcmVsYXRpdmVUbyBvcHRpb25zIGZvciBob3cgdG8gcmVzb2x2ZSByZWxhdGl2ZSBJUklzOlxuICogICAgICAgICAgYmFzZTogdHJ1ZSB0byByZXNvbHZlIGFnYWluc3QgdGhlIGJhc2UgSVJJLCBmYWxzZSBub3QgdG8uXG4gKiAgICAgICAgICB2b2NhYjogdHJ1ZSB0byBjb25jYXRlbmF0ZSBhZnRlciBAdm9jYWIsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBwcm9jZXNzaW5nIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB0aGUgZXhwYW5kZWQgdmFsdWUuXG4gKi9cbmFwaS5leHBhbmRJcmkgPSAoYWN0aXZlQ3R4LCB2YWx1ZSwgcmVsYXRpdmVUbywgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gX2V4cGFuZElyaShhY3RpdmVDdHgsIHZhbHVlLCByZWxhdGl2ZVRvLCB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhwYW5kcyBhIHN0cmluZyB0byBhIGZ1bGwgSVJJLiBUaGUgc3RyaW5nIG1heSBiZSBhIHRlcm0sIGEgcHJlZml4LCBhXG4gKiByZWxhdGl2ZSBJUkksIG9yIGFuIGFic29sdXRlIElSSS4gVGhlIGFzc29jaWF0ZWQgYWJzb2x1dGUgSVJJIHdpbGwgYmVcbiAqIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGN1cnJlbnQgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHN0cmluZyB0byBleHBhbmQuXG4gKiBAcGFyYW0gcmVsYXRpdmVUbyBvcHRpb25zIGZvciBob3cgdG8gcmVzb2x2ZSByZWxhdGl2ZSBJUklzOlxuICogICAgICAgICAgYmFzZTogdHJ1ZSB0byByZXNvbHZlIGFnYWluc3QgdGhlIGJhc2UgSVJJLCBmYWxzZSBub3QgdG8uXG4gKiAgICAgICAgICB2b2NhYjogdHJ1ZSB0byBjb25jYXRlbmF0ZSBhZnRlciBAdm9jYWIsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSBsb2NhbEN0eCB0aGUgbG9jYWwgY29udGV4dCBiZWluZyBwcm9jZXNzZWQgKG9ubHkgZ2l2ZW4gaWYgY2FsbGVkXG4gKiAgICAgICAgICBkdXJpbmcgY29udGV4dCBwcm9jZXNzaW5nKS5cbiAqIEBwYXJhbSBkZWZpbmVkIGEgbWFwIGZvciB0cmFja2luZyBjeWNsZXMgaW4gY29udGV4dCBkZWZpbml0aW9ucyAob25seSBnaXZlblxuICogICAgICAgICAgaWYgY2FsbGVkIGR1cmluZyBjb250ZXh0IHByb2Nlc3NpbmcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHByb2Nlc3Npbmcgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gX2V4cGFuZElyaShhY3RpdmVDdHgsIHZhbHVlLCByZWxhdGl2ZVRvLCBsb2NhbEN0eCwgZGVmaW5lZCwgb3B0aW9ucykge1xuICAvLyBhbHJlYWR5IGV4cGFuZGVkXG4gIGlmKHZhbHVlID09PSBudWxsIHx8ICFfaXNTdHJpbmcodmFsdWUpIHx8IGFwaS5pc0tleXdvcmQodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gaWdub3JlIG5vbi1rZXl3b3JkIHRoaW5ncyB0aGF0IGxvb2sgbGlrZSBhIGtleXdvcmRcbiAgaWYodmFsdWUubWF0Y2goS0VZV09SRF9QQVRURVJOKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gZGVmaW5lIHRlcm0gZGVwZW5kZW5jeSBpZiBub3QgZGVmaW5lZFxuICBpZihsb2NhbEN0eCAmJiBsb2NhbEN0eC5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiZcbiAgICBkZWZpbmVkLmdldCh2YWx1ZSkgIT09IHRydWUpIHtcbiAgICBhcGkuY3JlYXRlVGVybURlZmluaXRpb24oe1xuICAgICAgYWN0aXZlQ3R4LCBsb2NhbEN0eCwgdGVybTogdmFsdWUsIGRlZmluZWQsIG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJlbGF0aXZlVG8gPSByZWxhdGl2ZVRvIHx8IHt9O1xuICBpZihyZWxhdGl2ZVRvLnZvY2FiKSB7XG4gICAgY29uc3QgbWFwcGluZyA9IGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQodmFsdWUpO1xuXG4gICAgLy8gdmFsdWUgaXMgZXhwbGljaXRseSBpZ25vcmVkIHdpdGggYSBudWxsIG1hcHBpbmdcbiAgICBpZihtYXBwaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZihfaXNPYmplY3QobWFwcGluZykgJiYgJ0BpZCcgaW4gbWFwcGluZykge1xuICAgICAgLy8gdmFsdWUgaXMgYSB0ZXJtXG4gICAgICByZXR1cm4gbWFwcGluZ1snQGlkJ107XG4gICAgfVxuICB9XG5cbiAgLy8gc3BsaXQgdmFsdWUgaW50byBwcmVmaXg6c3VmZml4XG4gIGNvbnN0IGNvbG9uID0gdmFsdWUuaW5kZXhPZignOicpO1xuICBpZihjb2xvbiA+IDApIHtcbiAgICBjb25zdCBwcmVmaXggPSB2YWx1ZS5zdWJzdHIoMCwgY29sb24pO1xuICAgIGNvbnN0IHN1ZmZpeCA9IHZhbHVlLnN1YnN0cihjb2xvbiArIDEpO1xuXG4gICAgLy8gZG8gbm90IGV4cGFuZCBibGFuayBub2RlcyAocHJlZml4IG9mICdfJykgb3IgYWxyZWFkeS1hYnNvbHV0ZVxuICAgIC8vIElSSXMgKHN1ZmZpeCBvZiAnLy8nKVxuICAgIGlmKHByZWZpeCA9PT0gJ18nIHx8IHN1ZmZpeC5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gcHJlZml4IGRlcGVuZGVuY3kgbm90IGRlZmluZWQsIGRlZmluZSBpdFxuICAgIGlmKGxvY2FsQ3R4ICYmIGxvY2FsQ3R4Lmhhc093blByb3BlcnR5KHByZWZpeCkpIHtcbiAgICAgIGFwaS5jcmVhdGVUZXJtRGVmaW5pdGlvbih7XG4gICAgICAgIGFjdGl2ZUN0eCwgbG9jYWxDdHgsIHRlcm06IHByZWZpeCwgZGVmaW5lZCwgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdXNlIG1hcHBpbmcgaWYgcHJlZml4IGlzIGRlZmluZWRcbiAgICBjb25zdCBtYXBwaW5nID0gYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldChwcmVmaXgpO1xuICAgIGlmKG1hcHBpbmcgJiYgbWFwcGluZy5fcHJlZml4KSB7XG4gICAgICByZXR1cm4gbWFwcGluZ1snQGlkJ10gKyBzdWZmaXg7XG4gICAgfVxuXG4gICAgLy8gYWxyZWFkeSBhYnNvbHV0ZSBJUklcbiAgICBpZihfaXNBYnNvbHV0ZUlyaSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBwcmVwZW5kIHZvY2FiXG4gIGlmKHJlbGF0aXZlVG8udm9jYWIgJiYgJ0B2b2NhYicgaW4gYWN0aXZlQ3R4KSB7XG4gICAgcmV0dXJuIGFjdGl2ZUN0eFsnQHZvY2FiJ10gKyB2YWx1ZTtcbiAgfVxuXG4gIC8vIHByZXBlbmQgYmFzZVxuICBpZihyZWxhdGl2ZVRvLmJhc2UgJiYgJ0BiYXNlJyBpbiBhY3RpdmVDdHgpIHtcbiAgICBpZihhY3RpdmVDdHhbJ0BiYXNlJ10pIHtcbiAgICAgIC8vIFRoZSBudWxsIGNhc2UgcHJlc2VydmVzIHZhbHVlIGFzIHBvdGVudGlhbGx5IHJlbGF0aXZlXG4gICAgICByZXR1cm4gcHJlcGVuZEJhc2UocHJlcGVuZEJhc2Uob3B0aW9ucy5iYXNlLCBhY3RpdmVDdHhbJ0BiYXNlJ10pLCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYocmVsYXRpdmVUby5iYXNlKSB7XG4gICAgcmV0dXJuIHByZXBlbmRCYXNlKG9wdGlvbnMuYmFzZSwgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluaXRpYWwgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGRvY3VtZW50IGJhc2UgSVJJLlxuICpcbiAqIEByZXR1cm4gdGhlIGluaXRpYWwgY29udGV4dC5cbiAqL1xuYXBpLmdldEluaXRpYWxDb250ZXh0ID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHtwcm9jZXNzaW5nTW9kZTogb3B0aW9ucy5wcm9jZXNzaW5nTW9kZX0pO1xuICBjb25zdCBjYWNoZWQgPSBJTklUSUFMX0NPTlRFWFRfQ0FDSEUuZ2V0KGtleSk7XG4gIGlmKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cblxuICBjb25zdCBpbml0aWFsQ29udGV4dCA9IHtcbiAgICBwcm9jZXNzaW5nTW9kZTogb3B0aW9ucy5wcm9jZXNzaW5nTW9kZSxcbiAgICBtYXBwaW5nczogbmV3IE1hcCgpLFxuICAgIGludmVyc2U6IG51bGwsXG4gICAgZ2V0SW52ZXJzZTogX2NyZWF0ZUludmVyc2VDb250ZXh0LFxuICAgIGNsb25lOiBfY2xvbmVBY3RpdmVDb250ZXh0LFxuICAgIHJldmVydFRvUHJldmlvdXNDb250ZXh0OiBfcmV2ZXJ0VG9QcmV2aW91c0NvbnRleHQsXG4gICAgcHJvdGVjdGVkOiB7fVxuICB9O1xuICAvLyBUT0RPOiBjb25zaWRlciB1c2luZyBMUlUgY2FjaGUgaW5zdGVhZFxuICBpZihJTklUSUFMX0NPTlRFWFRfQ0FDSEUuc2l6ZSA9PT0gSU5JVElBTF9DT05URVhUX0NBQ0hFX01BWF9TSVpFKSB7XG4gICAgLy8gY2xlYXIgd2hvbGUgY2FjaGUgLS0gYXNzdW1lcyBzY2VuYXJpbyB3aGVyZSB0aGUgY2FjaGUgZmlsbHMgbWVhbnNcbiAgICAvLyB0aGUgY2FjaGUgaXNuJ3QgYmVpbmcgdXNlZCB2ZXJ5IGVmZmljaWVudGx5IGFueXdheVxuICAgIElOSVRJQUxfQ09OVEVYVF9DQUNIRS5jbGVhcigpO1xuICB9XG4gIElOSVRJQUxfQ09OVEVYVF9DQUNIRS5zZXQoa2V5LCBpbml0aWFsQ29udGV4dCk7XG4gIHJldHVybiBpbml0aWFsQ29udGV4dDtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGludmVyc2UgY29udGV4dCBmb3IgdXNlIGluIHRoZSBjb21wYWN0aW9uIGFsZ29yaXRobSwgaWZcbiAgICogbm90IGFscmVhZHkgZ2VuZXJhdGVkIGZvciB0aGUgZ2l2ZW4gYWN0aXZlIGNvbnRleHQuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGludmVyc2UgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIF9jcmVhdGVJbnZlcnNlQ29udGV4dCgpIHtcbiAgICBjb25zdCBhY3RpdmVDdHggPSB0aGlzO1xuXG4gICAgLy8gbGF6aWx5IGNyZWF0ZSBpbnZlcnNlXG4gICAgaWYoYWN0aXZlQ3R4LmludmVyc2UpIHtcbiAgICAgIHJldHVybiBhY3RpdmVDdHguaW52ZXJzZTtcbiAgICB9XG4gICAgY29uc3QgaW52ZXJzZSA9IGFjdGl2ZUN0eC5pbnZlcnNlID0ge307XG5cbiAgICAvLyB2YXJpYWJsZXMgZm9yIGJ1aWxkaW5nIGZhc3QgQ1VSSUUgbWFwXG4gICAgY29uc3QgZmFzdEN1cmllTWFwID0gYWN0aXZlQ3R4LmZhc3RDdXJpZU1hcCA9IHt9O1xuICAgIGNvbnN0IGlyaXNUb1Rlcm1zID0ge307XG5cbiAgICAvLyBoYW5kbGUgZGVmYXVsdCBsYW5ndWFnZVxuICAgIGNvbnN0IGRlZmF1bHRMYW5ndWFnZSA9IChhY3RpdmVDdHhbJ0BsYW5ndWFnZSddIHx8ICdAbm9uZScpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBoYW5kbGUgZGVmYXVsdCBkaXJlY3Rpb25cbiAgICBjb25zdCBkZWZhdWx0RGlyZWN0aW9uID0gYWN0aXZlQ3R4WydAZGlyZWN0aW9uJ107XG5cbiAgICAvLyBjcmVhdGUgdGVybSBzZWxlY3Rpb25zIGZvciBlYWNoIG1hcHBpbmcgaW4gdGhlIGNvbnRleHQsIG9yZGVyZWQgYnlcbiAgICAvLyBzaG9ydGVzdCBhbmQgdGhlbiBsZXhpY29ncmFwaGljYWxseSBsZWFzdFxuICAgIGNvbnN0IG1hcHBpbmdzID0gYWN0aXZlQ3R4Lm1hcHBpbmdzO1xuICAgIGNvbnN0IHRlcm1zID0gWy4uLm1hcHBpbmdzLmtleXMoKV0uc29ydChfY29tcGFyZVNob3J0ZXN0TGVhc3QpO1xuICAgIGZvcihjb25zdCB0ZXJtIG9mIHRlcm1zKSB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gbWFwcGluZ3MuZ2V0KHRlcm0pO1xuICAgICAgaWYobWFwcGluZyA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGNvbnRhaW5lciA9IG1hcHBpbmdbJ0Bjb250YWluZXInXSB8fCAnQG5vbmUnO1xuICAgICAgY29udGFpbmVyID0gW10uY29uY2F0KGNvbnRhaW5lcikuc29ydCgpLmpvaW4oJycpO1xuXG4gICAgICBpZihtYXBwaW5nWydAaWQnXSA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBldmVyeSBJUkkgaW4gdGhlIG1hcHBpbmdcbiAgICAgIGNvbnN0IGlkcyA9IF9hc0FycmF5KG1hcHBpbmdbJ0BpZCddKTtcbiAgICAgIGZvcihjb25zdCBpcmkgb2YgaWRzKSB7XG4gICAgICAgIGxldCBlbnRyeSA9IGludmVyc2VbaXJpXTtcbiAgICAgICAgY29uc3QgaXNLZXl3b3JkID0gYXBpLmlzS2V5d29yZChpcmkpO1xuXG4gICAgICAgIGlmKCFlbnRyeSkge1xuICAgICAgICAgIC8vIGluaXRpYWxpemUgZW50cnlcbiAgICAgICAgICBpbnZlcnNlW2lyaV0gPSBlbnRyeSA9IHt9O1xuXG4gICAgICAgICAgaWYoIWlzS2V5d29yZCAmJiAhbWFwcGluZy5fdGVybUhhc0NvbG9uKSB7XG4gICAgICAgICAgICAvLyBpbml0IElSSSB0byB0ZXJtIG1hcCBhbmQgZmFzdCBDVVJJRSBwcmVmaXhlc1xuICAgICAgICAgICAgaXJpc1RvVGVybXNbaXJpXSA9IFt0ZXJtXTtcbiAgICAgICAgICAgIGNvbnN0IGZhc3RDdXJpZUVudHJ5ID0ge2lyaSwgdGVybXM6IGlyaXNUb1Rlcm1zW2lyaV19O1xuICAgICAgICAgICAgaWYoaXJpWzBdIGluIGZhc3RDdXJpZU1hcCkge1xuICAgICAgICAgICAgICBmYXN0Q3VyaWVNYXBbaXJpWzBdXS5wdXNoKGZhc3RDdXJpZUVudHJ5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZhc3RDdXJpZU1hcFtpcmlbMF1dID0gW2Zhc3RDdXJpZUVudHJ5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZighaXNLZXl3b3JkICYmICFtYXBwaW5nLl90ZXJtSGFzQ29sb24pIHtcbiAgICAgICAgICAvLyBhZGQgSVJJIHRvIHRlcm0gbWF0Y2hcbiAgICAgICAgICBpcmlzVG9UZXJtc1tpcmldLnB1c2godGVybSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgbmV3IGVudHJ5XG4gICAgICAgIGlmKCFlbnRyeVtjb250YWluZXJdKSB7XG4gICAgICAgICAgZW50cnlbY29udGFpbmVyXSA9IHtcbiAgICAgICAgICAgICdAbGFuZ3VhZ2UnOiB7fSxcbiAgICAgICAgICAgICdAdHlwZSc6IHt9LFxuICAgICAgICAgICAgJ0BhbnknOiB7fVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZW50cnkgPSBlbnRyeVtjb250YWluZXJdO1xuICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGFueSddLCAnQG5vbmUnKTtcblxuICAgICAgICBpZihtYXBwaW5nLnJldmVyc2UpIHtcbiAgICAgICAgICAvLyB0ZXJtIGlzIHByZWZlcnJlZCBmb3IgdmFsdWVzIHVzaW5nIEByZXZlcnNlXG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0B0eXBlJ10sICdAcmV2ZXJzZScpO1xuICAgICAgICB9IGVsc2UgaWYobWFwcGluZ1snQHR5cGUnXSA9PT0gJ0Bub25lJykge1xuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAYW55J10sICdAbm9uZScpO1xuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSwgJ0Bub25lJyk7XG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0B0eXBlJ10sICdAbm9uZScpO1xuICAgICAgICB9IGVsc2UgaWYoJ0B0eXBlJyBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgLy8gdGVybSBpcyBwcmVmZXJyZWQgZm9yIHZhbHVlcyB1c2luZyBzcGVjaWZpYyB0eXBlXG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0B0eXBlJ10sIG1hcHBpbmdbJ0B0eXBlJ10pO1xuICAgICAgICB9IGVsc2UgaWYoJ0BsYW5ndWFnZScgaW4gbWFwcGluZyAmJiAnQGRpcmVjdGlvbicgaW4gbWFwcGluZykge1xuICAgICAgICAgIC8vIHRlcm0gaXMgcHJlZmVycmVkIGZvciB2YWx1ZXMgdXNpbmcgc3BlY2lmaWMgbGFuZ3VhZ2UgYW5kIGRpcmVjdGlvblxuICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gbWFwcGluZ1snQGxhbmd1YWdlJ107XG4gICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gbWFwcGluZ1snQGRpcmVjdGlvbiddO1xuICAgICAgICAgIGlmKGxhbmd1YWdlICYmIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLFxuICAgICAgICAgICAgICBgJHtsYW5ndWFnZX1fJHtkaXJlY3Rpb259YC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSwgbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLCBgXyR7ZGlyZWN0aW9ufWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sICdAbnVsbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCdAbGFuZ3VhZ2UnIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sXG4gICAgICAgICAgICAobWFwcGluZ1snQGxhbmd1YWdlJ10gfHwgJ0BudWxsJykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH0gZWxzZSBpZignQGRpcmVjdGlvbicgaW4gbWFwcGluZykge1xuICAgICAgICAgIGlmKG1hcHBpbmdbJ0BkaXJlY3Rpb24nXSkge1xuICAgICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLFxuICAgICAgICAgICAgICBgXyR7bWFwcGluZ1snQGRpcmVjdGlvbiddfWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sICdAbm9uZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGRlZmF1bHREaXJlY3Rpb24pIHtcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sIGBfJHtkZWZhdWx0RGlyZWN0aW9ufWApO1xuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSwgJ0Bub25lJyk7XG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0B0eXBlJ10sICdAbm9uZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFkZCBlbnRyaWVzIGZvciBubyB0eXBlIGFuZCBubyBsYW5ndWFnZVxuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSwgZGVmYXVsdExhbmd1YWdlKTtcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sICdAbm9uZScpO1xuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAdHlwZSddLCAnQG5vbmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJ1aWxkIGZhc3QgQ1VSSUUgbWFwXG4gICAgZm9yKGNvbnN0IGtleSBpbiBmYXN0Q3VyaWVNYXApIHtcbiAgICAgIF9idWlsZElyaU1hcChmYXN0Q3VyaWVNYXAsIGtleSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludmVyc2U7XG4gIH1cblxuICAvKipcbiAgICogUnVucyBhIHJlY3Vyc2l2ZSBhbGdvcml0aG0gdG8gYnVpbGQgYSBsb29rdXAgbWFwIGZvciBxdWlja2x5IGZpbmRpbmdcbiAgICogcG90ZW50aWFsIENVUklFcy5cbiAgICpcbiAgICogQHBhcmFtIGlyaU1hcCB0aGUgbWFwIHRvIGJ1aWxkLlxuICAgKiBAcGFyYW0ga2V5IHRoZSBjdXJyZW50IGtleSBpbiB0aGUgbWFwIHRvIHdvcmsgb24uXG4gICAqIEBwYXJhbSBpZHggdGhlIGluZGV4IGludG8gdGhlIElSSSB0byBjb21wYXJlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2J1aWxkSXJpTWFwKGlyaU1hcCwga2V5LCBpZHgpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gaXJpTWFwW2tleV07XG4gICAgY29uc3QgbmV4dCA9IGlyaU1hcFtrZXldID0ge307XG5cbiAgICBsZXQgaXJpO1xuICAgIGxldCBsZXR0ZXI7XG4gICAgZm9yKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIGlyaSA9IGVudHJ5LmlyaTtcbiAgICAgIGlmKGlkeCA+PSBpcmkubGVuZ3RoKSB7XG4gICAgICAgIGxldHRlciA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0dGVyID0gaXJpW2lkeF07XG4gICAgICB9XG4gICAgICBpZihsZXR0ZXIgaW4gbmV4dCkge1xuICAgICAgICBuZXh0W2xldHRlcl0ucHVzaChlbnRyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0W2xldHRlcl0gPSBbZW50cnldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvcihjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgICAgaWYoa2V5ID09PSAnJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIF9idWlsZElyaU1hcChuZXh0LCBrZXksIGlkeCArIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSB0ZXJtIGZvciB0aGUgZ2l2ZW4gZW50cnkgaWYgbm90IGFscmVhZHkgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB0ZXJtIHRoZSB0ZXJtIHRvIGFkZC5cbiAgICogQHBhcmFtIGVudHJ5IHRoZSBpbnZlcnNlIGNvbnRleHQgdHlwZU9yTGFuZ3VhZ2UgZW50cnkgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0gdHlwZU9yTGFuZ3VhZ2VWYWx1ZSB0aGUga2V5IGluIHRoZSBlbnRyeSB0byBhZGQgdG8uXG4gICAqL1xuICBmdW5jdGlvbiBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeSwgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSkge1xuICAgIGlmKCFlbnRyeS5oYXNPd25Qcm9wZXJ0eSh0eXBlT3JMYW5ndWFnZVZhbHVlKSkge1xuICAgICAgZW50cnlbdHlwZU9yTGFuZ3VhZ2VWYWx1ZV0gPSB0ZXJtO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgYW4gYWN0aXZlIGNvbnRleHQsIGNyZWF0aW5nIGEgY2hpbGQgYWN0aXZlIGNvbnRleHQuXG4gICAqXG4gICAqIEByZXR1cm4gYSBjbG9uZSAoY2hpbGQpIG9mIHRoZSBhY3RpdmUgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIF9jbG9uZUFjdGl2ZUNvbnRleHQoKSB7XG4gICAgY29uc3QgY2hpbGQgPSB7fTtcbiAgICBjaGlsZC5tYXBwaW5ncyA9IHV0aWwuY2xvbmUodGhpcy5tYXBwaW5ncyk7XG4gICAgY2hpbGQuY2xvbmUgPSB0aGlzLmNsb25lO1xuICAgIGNoaWxkLmludmVyc2UgPSBudWxsO1xuICAgIGNoaWxkLmdldEludmVyc2UgPSB0aGlzLmdldEludmVyc2U7XG4gICAgY2hpbGQucHJvdGVjdGVkID0gdXRpbC5jbG9uZSh0aGlzLnByb3RlY3RlZCk7XG4gICAgaWYodGhpcy5wcmV2aW91c0NvbnRleHQpIHtcbiAgICAgIGNoaWxkLnByZXZpb3VzQ29udGV4dCA9IHRoaXMucHJldmlvdXNDb250ZXh0LmNsb25lKCk7XG4gICAgfVxuICAgIGNoaWxkLnJldmVydFRvUHJldmlvdXNDb250ZXh0ID0gdGhpcy5yZXZlcnRUb1ByZXZpb3VzQ29udGV4dDtcbiAgICBpZignQGJhc2UnIGluIHRoaXMpIHtcbiAgICAgIGNoaWxkWydAYmFzZSddID0gdGhpc1snQGJhc2UnXTtcbiAgICB9XG4gICAgaWYoJ0BsYW5ndWFnZScgaW4gdGhpcykge1xuICAgICAgY2hpbGRbJ0BsYW5ndWFnZSddID0gdGhpc1snQGxhbmd1YWdlJ107XG4gICAgfVxuICAgIGlmKCdAdm9jYWInIGluIHRoaXMpIHtcbiAgICAgIGNoaWxkWydAdm9jYWInXSA9IHRoaXNbJ0B2b2NhYiddO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICAvKipcbiAgICogUmV2ZXJ0cyBhbnkgdHlwZS1zY29wZWQgY29udGV4dCBpbiB0aGlzIGFjdGl2ZSBjb250ZXh0IHRvIHRoZSBwcmV2aW91c1xuICAgKiBjb250ZXh0LlxuICAgKi9cbiAgZnVuY3Rpb24gX3JldmVydFRvUHJldmlvdXNDb250ZXh0KCkge1xuICAgIGlmKCF0aGlzLnByZXZpb3VzQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZpb3VzQ29udGV4dC5jbG9uZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gYWN0aXZlIGNvbnRleHQga2V5IGFuZCB0eXBlLCBudWxsIGlmIG5vbmUgaXNcbiAqIHNldCBvciB1bmRlZmluZWQgaWYgbm9uZSBpcyBzZXQgYW5kIHR5cGUgaXMgJ0Bjb250ZXh0Jy5cbiAqXG4gKiBAcGFyYW0gY3R4IHRoZSBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSBrZXkgdGhlIGNvbnRleHQga2V5LlxuICogQHBhcmFtIFt0eXBlXSB0aGUgdHlwZSBvZiB2YWx1ZSB0byBnZXQgKGVnOiAnQGlkJywgJ0B0eXBlJyksIGlmIG5vdFxuICogICAgICAgICAgc3BlY2lmaWVkIGdldHMgdGhlIGVudGlyZSBlbnRyeSBmb3IgYSBrZXksIG51bGwgaWYgbm90IGZvdW5kLlxuICpcbiAqIEByZXR1cm4gdGhlIHZhbHVlLCBudWxsLCBvciB1bmRlZmluZWQuXG4gKi9cbmFwaS5nZXRDb250ZXh0VmFsdWUgPSAoY3R4LCBrZXksIHR5cGUpID0+IHtcbiAgLy8gaW52YWxpZCBrZXlcbiAgaWYoa2V5ID09PSBudWxsKSB7XG4gICAgaWYodHlwZSA9PT0gJ0Bjb250ZXh0Jykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBnZXQgc3BlY2lmaWMgZW50cnkgaW5mb3JtYXRpb25cbiAgaWYoY3R4Lm1hcHBpbmdzLmhhcyhrZXkpKSB7XG4gICAgY29uc3QgZW50cnkgPSBjdHgubWFwcGluZ3MuZ2V0KGtleSk7XG5cbiAgICBpZihfaXNVbmRlZmluZWQodHlwZSkpIHtcbiAgICAgIC8vIHJldHVybiB3aG9sZSBlbnRyeVxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgICBpZihlbnRyeS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgLy8gcmV0dXJuIGVudHJ5IHZhbHVlIGZvciB0eXBlXG4gICAgICByZXR1cm4gZW50cnlbdHlwZV07XG4gICAgfVxuICB9XG5cbiAgLy8gZ2V0IGRlZmF1bHQgbGFuZ3VhZ2VcbiAgaWYodHlwZSA9PT0gJ0BsYW5ndWFnZScgJiYgdHlwZSBpbiBjdHgpIHtcbiAgICByZXR1cm4gY3R4W3R5cGVdO1xuICB9XG5cbiAgLy8gZ2V0IGRlZmF1bHQgZGlyZWN0aW9uXG4gIGlmKHR5cGUgPT09ICdAZGlyZWN0aW9uJyAmJiB0eXBlIGluIGN0eCkge1xuICAgIHJldHVybiBjdHhbdHlwZV07XG4gIH1cblxuICBpZih0eXBlID09PSAnQGNvbnRleHQnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogUHJvY2Vzc2luZyBNb2RlIGNoZWNrLlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGN1cnJlbnQgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0gdmVyc2lvbiB0aGUgc3RyaW5nIG9yIG51bWVyaWMgdmVyc2lvbiB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIGJvb2xlYW4uXG4gKi9cbmFwaS5wcm9jZXNzaW5nTW9kZSA9IChhY3RpdmVDdHgsIHZlcnNpb24pID0+IHtcbiAgaWYodmVyc2lvbi50b1N0cmluZygpID49ICcxLjEnKSB7XG4gICAgcmV0dXJuICFhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgfHxcbiAgICAgIGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSA+PSAnanNvbi1sZC0nICsgdmVyc2lvbi50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgPT09ICdqc29uLWxkLTEuMCc7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEga2V5d29yZCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNLZXl3b3JkID0gdiA9PiB7XG4gIGlmKCFfaXNTdHJpbmcodikgfHwgdlswXSAhPT0gJ0AnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN3aXRjaCh2KSB7XG4gICAgY2FzZSAnQGJhc2UnOlxuICAgIGNhc2UgJ0Bjb250YWluZXInOlxuICAgIGNhc2UgJ0Bjb250ZXh0JzpcbiAgICBjYXNlICdAZGVmYXVsdCc6XG4gICAgY2FzZSAnQGRpcmVjdGlvbic6XG4gICAgY2FzZSAnQGVtYmVkJzpcbiAgICBjYXNlICdAZXhwbGljaXQnOlxuICAgIGNhc2UgJ0BncmFwaCc6XG4gICAgY2FzZSAnQGlkJzpcbiAgICBjYXNlICdAaW5jbHVkZWQnOlxuICAgIGNhc2UgJ0BpbmRleCc6XG4gICAgY2FzZSAnQGpzb24nOlxuICAgIGNhc2UgJ0BsYW5ndWFnZSc6XG4gICAgY2FzZSAnQGxpc3QnOlxuICAgIGNhc2UgJ0BuZXN0JzpcbiAgICBjYXNlICdAbm9uZSc6XG4gICAgY2FzZSAnQG9taXREZWZhdWx0JzpcbiAgICBjYXNlICdAcHJlZml4JzpcbiAgICBjYXNlICdAcHJlc2VydmUnOlxuICAgIGNhc2UgJ0Bwcm90ZWN0ZWQnOlxuICAgIGNhc2UgJ0ByZXF1aXJlQWxsJzpcbiAgICBjYXNlICdAcmV2ZXJzZSc6XG4gICAgY2FzZSAnQHNldCc6XG4gICAgY2FzZSAnQHR5cGUnOlxuICAgIGNhc2UgJ0B2YWx1ZSc6XG4gICAgY2FzZSAnQHZlcnNpb24nOlxuICAgIGNhc2UgJ0B2b2NhYic6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBfZGVlcENvbXBhcmUoeDEsIHgyKSB7XG4gIC8vIGNvbXBhcmUgYG51bGxgIG9yIHByaW1pdGl2ZSB0eXBlcyBkaXJlY3RseVxuICBpZigoISh4MSAmJiB0eXBlb2YgeDEgPT09ICdvYmplY3QnKSkgfHxcbiAgICAgKCEoeDIgJiYgdHlwZW9mIHgyID09PSAnb2JqZWN0JykpKSB7XG4gICAgcmV0dXJuIHgxID09PSB4MjtcbiAgfVxuICAvLyB4MSBhbmQgeDIgYXJlIG9iamVjdHMgKGFsc28gcG90ZW50aWFsbHkgYXJyYXlzKVxuICBjb25zdCB4MUFycmF5ID0gQXJyYXkuaXNBcnJheSh4MSk7XG4gIGlmKHgxQXJyYXkgIT09IEFycmF5LmlzQXJyYXkoeDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmKHgxQXJyYXkpIHtcbiAgICBpZih4MS5sZW5ndGggIT09IHgyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgeDEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKCFfZGVlcENvbXBhcmUoeDFbaV0sIHgyW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIHgxIGFuZCB4MiBhcmUgbm9uLWFycmF5IG9iamVjdHNcbiAgY29uc3QgazFzID0gT2JqZWN0LmtleXMoeDEpO1xuICBjb25zdCBrMnMgPSBPYmplY3Qua2V5cyh4Mik7XG4gIGlmKGsxcy5sZW5ndGggIT09IGsycy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yKGNvbnN0IGsxIGluIHgxKSB7XG4gICAgbGV0IHYxID0geDFbazFdO1xuICAgIGxldCB2MiA9IHgyW2sxXTtcbiAgICAvLyBzcGVjaWFsIGNhc2U6IGBAY29udGFpbmVyYCBjYW4gYmUgaW4gYW55IG9yZGVyXG4gICAgaWYoazEgPT09ICdAY29udGFpbmVyJykge1xuICAgICAgaWYoQXJyYXkuaXNBcnJheSh2MSkgJiYgQXJyYXkuaXNBcnJheSh2MikpIHtcbiAgICAgICAgdjEgPSB2MS5zbGljZSgpLnNvcnQoKTtcbiAgICAgICAgdjIgPSB2Mi5zbGljZSgpLnNvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoIV9kZWVwQ29tcGFyZSh2MSwgdjIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtwYXJzZUxpbmtIZWFkZXIsIGJ1aWxkSGVhZGVyc30gPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCB7TElOS19IRUFERVJfQ09OVEVYVH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcbmNvbnN0IEpzb25MZEVycm9yID0gcmVxdWlyZSgnLi4vSnNvbkxkRXJyb3InKTtcbmNvbnN0IFJlcXVlc3RRdWV1ZSA9IHJlcXVpcmUoJy4uL1JlcXVlc3RRdWV1ZScpO1xuY29uc3Qge3ByZXBlbmRCYXNlfSA9IHJlcXVpcmUoJy4uL3VybCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBidWlsdC1pbiBub2RlIGRvY3VtZW50IGxvYWRlci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBzZWN1cmU6IHJlcXVpcmUgYWxsIFVSTHMgdG8gdXNlIEhUVFBTLlxuICogICAgICAgICAgc3RyaWN0U1NMOiB0cnVlIHRvIHJlcXVpcmUgU1NMIGNlcnRpZmljYXRlcyB0byBiZSB2YWxpZCxcbiAqICAgICAgICAgICAgZmFsc2Ugbm90IHRvIChkZWZhdWx0OiB0cnVlKS5cbiAqICAgICAgICAgIG1heFJlZGlyZWN0czogdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0cyB0byBwZXJtaXQsIG5vbmUgYnlcbiAqICAgICAgICAgICAgZGVmYXVsdC5cbiAqICAgICAgICAgIHJlcXVlc3Q6IHRoZSBvYmplY3Qgd2hpY2ggd2lsbCBtYWtlIHRoZSByZXF1ZXN0LCBkZWZhdWx0IGlzXG4gKiAgICAgICAgICAgIHByb3ZpZGVkIGJ5IGBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9yZXF1ZXN0YC5cbiAqICAgICAgICAgIGhlYWRlcnM6IGFuIG9iamVjdCAobWFwKSBvZiBoZWFkZXJzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGFzIHJlcXVlc3RcbiAqICAgICAgICAgICAgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3RlZCBkb2N1bWVudC4gQWNjZXB0IGlzIG5vdCBhbGxvd2VkLlxuICpcbiAqIEByZXR1cm4gdGhlIG5vZGUgZG9jdW1lbnQgbG9hZGVyLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICh7XG4gIHNlY3VyZSxcbiAgc3RyaWN0U1NMID0gdHJ1ZSxcbiAgbWF4UmVkaXJlY3RzID0gLTEsXG4gIHJlcXVlc3QsXG4gIGhlYWRlcnMgPSB7fVxufSA9IHtzdHJpY3RTU0w6IHRydWUsIG1heFJlZGlyZWN0czogLTEsIGhlYWRlcnM6IHt9fSkgPT4ge1xuICBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKGhlYWRlcnMpO1xuICAvLyBUT0RPOiB1c2UgYGF4aW9zYFxuICByZXF1ZXN0ID0gcmVxdWVzdCB8fCByZXF1aXJlKCdyZXF1ZXN0Jyk7XG4gIGNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5cbiAgY29uc3QgcXVldWUgPSBuZXcgUmVxdWVzdFF1ZXVlKCk7XG4gIHJldHVybiBxdWV1ZS53cmFwTG9hZGVyKGZ1bmN0aW9uKHVybCkge1xuICAgIHJldHVybiBsb2FkRG9jdW1lbnQodXJsLCBbXSk7XG4gIH0pO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWREb2N1bWVudCh1cmwsIHJlZGlyZWN0cykge1xuICAgIGlmKHVybC5pbmRleE9mKCdodHRwOicpICE9PSAwICYmIHVybC5pbmRleE9mKCdodHRwczonKSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQ7IG9ubHkgXCJodHRwXCIgYW5kIFwiaHR0cHNcIiBVUkxzIGFyZSAnICtcbiAgICAgICAgJ3N1cHBvcnRlZC4nLFxuICAgICAgICAnanNvbmxkLkludmFsaWRVcmwnLCB7Y29kZTogJ2xvYWRpbmcgZG9jdW1lbnQgZmFpbGVkJywgdXJsfSk7XG4gICAgfVxuICAgIGlmKHNlY3VyZSAmJiB1cmwuaW5kZXhPZignaHR0cHMnKSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQ7IHNlY3VyZSBtb2RlIGlzIGVuYWJsZWQgYW5kICcgK1xuICAgICAgICAndGhlIFVSTFxcJ3Mgc2NoZW1lIGlzIG5vdCBcImh0dHBzXCIuJyxcbiAgICAgICAgJ2pzb25sZC5JbnZhbGlkVXJsJywge2NvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsIHVybH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBkaXNhYmxlIGNhY2hlIHVudGlsIEhUVFAgY2FjaGluZyBpbXBsZW1lbnRlZFxuICAgIGxldCBkb2MgPSBudWxsOy8vY2FjaGUuZ2V0KHVybCk7XG4gICAgaWYoZG9jICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZG9jO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGFsdGVybmF0ZSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IF9yZXF1ZXN0KHJlcXVlc3QsIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzdHJpY3RTU0wsXG4gICAgICAgIGZvbGxvd1JlZGlyZWN0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdVUkwgY291bGQgbm90IGJlIGRlcmVmZXJlbmNlZCwgYW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICAgJ2pzb25sZC5Mb2FkRG9jdW1lbnRFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLCB1cmwsIGNhdXNlOiBlfSk7XG4gICAgfVxuXG4gICAgY29uc3Qge3JlcywgYm9keX0gPSByZXN1bHQ7XG5cbiAgICBkb2MgPSB7Y29udGV4dFVybDogbnVsbCwgZG9jdW1lbnRVcmw6IHVybCwgZG9jdW1lbnQ6IGJvZHkgfHwgbnVsbH07XG5cbiAgICAvLyBoYW5kbGUgZXJyb3JcbiAgICBjb25zdCBzdGF0dXNUZXh0ID0gaHR0cC5TVEFUVVNfQ09ERVNbcmVzLnN0YXR1c0NvZGVdO1xuICAgIGlmKHJlcy5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICBgVVJMIFwiJHt1cmx9XCIgY291bGQgbm90IGJlIGRlcmVmZXJlbmNlZDogJHtzdGF0dXNUZXh0fWAsXG4gICAgICAgICdqc29ubGQuSW52YWxpZFVybCcsIHtcbiAgICAgICAgICBjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVzLnN0YXR1c0NvZGVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIExpbmsgSGVhZGVyXG4gICAgaWYocmVzLmhlYWRlcnMubGluayAmJlxuICAgICAgcmVzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddICE9PSAnYXBwbGljYXRpb24vbGQranNvbicpIHtcbiAgICAgIC8vIG9ubHkgMSByZWxhdGVkIGxpbmsgaGVhZGVyIHBlcm1pdHRlZFxuICAgICAgY29uc3QgbGlua0hlYWRlcnMgPSBwYXJzZUxpbmtIZWFkZXIocmVzLmhlYWRlcnMubGluayk7XG4gICAgICBjb25zdCBsaW5rZWRDb250ZXh0ID0gbGlua0hlYWRlcnNbTElOS19IRUFERVJfQ09OVEVYVF07XG4gICAgICBpZihBcnJheS5pc0FycmF5KGxpbmtlZENvbnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQsIGl0IGhhcyBtb3JlIHRoYW4gb25lIGFzc29jaWF0ZWQgJyArXG4gICAgICAgICAgJ0hUVFAgTGluayBIZWFkZXIuJyxcbiAgICAgICAgICAnanNvbmxkLkludmFsaWRVcmwnLFxuICAgICAgICAgIHtjb2RlOiAnbXVsdGlwbGUgY29udGV4dCBsaW5rIGhlYWRlcnMnLCB1cmx9KTtcbiAgICAgIH1cbiAgICAgIGlmKGxpbmtlZENvbnRleHQpIHtcbiAgICAgICAgZG9jLmNvbnRleHRVcmwgPSBsaW5rZWRDb250ZXh0LnRhcmdldDtcbiAgICAgIH1cblxuICAgICAgLy8gXCJhbHRlcm5hdGVcIiBsaW5rIGhlYWRlciBpcyBhIHJlZGlyZWN0XG4gICAgICBhbHRlcm5hdGUgPSBsaW5rSGVhZGVyc1snYWx0ZXJuYXRlJ107XG4gICAgICBpZihhbHRlcm5hdGUgJiZcbiAgICAgICAgYWx0ZXJuYXRlLnR5cGUgPT0gJ2FwcGxpY2F0aW9uL2xkK2pzb24nICYmXG4gICAgICAgICEocmVzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnKVxuICAgICAgICAgIC5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvKFxcdypcXCspP2pzb24kLykpIHtcbiAgICAgICAgcmVzLmhlYWRlcnMubG9jYXRpb24gPSBwcmVwZW5kQmFzZSh1cmwsIGFsdGVybmF0ZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSByZWRpcmVjdFxuICAgIGlmKChhbHRlcm5hdGUgfHxcbiAgICAgIHJlcy5zdGF0dXNDb2RlID49IDMwMCAmJiByZXMuc3RhdHVzQ29kZSA8IDQwMCkgJiYgcmVzLmhlYWRlcnMubG9jYXRpb24pIHtcbiAgICAgIGlmKHJlZGlyZWN0cy5sZW5ndGggPT09IG1heFJlZGlyZWN0cykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkOyB0aGVyZSB3ZXJlIHRvbyBtYW55IHJlZGlyZWN0cy4nLFxuICAgICAgICAgICdqc29ubGQuVG9vTWFueVJlZGlyZWN0cycsIHtcbiAgICAgICAgICAgIGNvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICByZWRpcmVjdHNcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmKHJlZGlyZWN0cy5pbmRleE9mKHVybCkgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQ7IGluZmluaXRlIHJlZGlyZWN0aW9uIHdhcyBkZXRlY3RlZC4nLFxuICAgICAgICAgICdqc29ubGQuSW5maW5pdGVSZWRpcmVjdERldGVjdGVkJywge1xuICAgICAgICAgICAgY29kZTogJ3JlY3Vyc2l2ZSBjb250ZXh0IGluY2x1c2lvbicsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICByZWRpcmVjdHNcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlZGlyZWN0cy5wdXNoKHVybCk7XG4gICAgICByZXR1cm4gbG9hZERvY3VtZW50KHJlcy5oZWFkZXJzLmxvY2F0aW9uLCByZWRpcmVjdHMpO1xuICAgIH1cblxuICAgIC8vIGNhY2hlIGZvciBlYWNoIHJlZGlyZWN0ZWQgVVJMXG4gICAgcmVkaXJlY3RzLnB1c2godXJsKTtcbiAgICAvLyBUT0RPOiBkaXNhYmxlIGNhY2hlIHVudGlsIEhUVFAgY2FjaGluZyBpbXBsZW1lbnRlZFxuICAgIC8qXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHJlZGlyZWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgY2FjaGUuc2V0KFxuICAgICAgICByZWRpcmVjdHNbaV0sXG4gICAgICAgIHtjb250ZXh0VXJsOiBudWxsLCBkb2N1bWVudFVybDogcmVkaXJlY3RzW2ldLCBkb2N1bWVudDogYm9keX0pO1xuICAgIH1cbiAgICAqL1xuXG4gICAgcmV0dXJuIGRvYztcbiAgfVxufTtcblxuZnVuY3Rpb24gX3JlcXVlc3QocmVxdWVzdCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcXVlc3Qob3B0aW9ucywgKGVyciwgcmVzLCBib2R5KSA9PiB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHtyZXMsIGJvZHl9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qge3BhcnNlTGlua0hlYWRlciwgYnVpbGRIZWFkZXJzfSA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IHtMSU5LX0hFQURFUl9DT05URVhUfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuLi9Kc29uTGRFcnJvcicpO1xuY29uc3QgUmVxdWVzdFF1ZXVlID0gcmVxdWlyZSgnLi4vUmVxdWVzdFF1ZXVlJyk7XG5jb25zdCB7cHJlcGVuZEJhc2V9ID0gcmVxdWlyZSgnLi4vdXJsJyk7XG5cbmNvbnN0IFJFR0VYX0xJTktfSEVBREVSID0gLyhefChcXHJcXG4pKWxpbms6L2k7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJ1aWx0LWluIFhNTEh0dHBSZXF1ZXN0IGRvY3VtZW50IGxvYWRlci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBzZWN1cmU6IHJlcXVpcmUgYWxsIFVSTHMgdG8gdXNlIEhUVFBTLlxuICogICAgICAgICAgaGVhZGVyczogYW4gb2JqZWN0IChtYXApIG9mIGhlYWRlcnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYXMgcmVxdWVzdFxuICogICAgICAgICAgICBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdGVkIGRvY3VtZW50LiBBY2NlcHQgaXMgbm90IGFsbG93ZWQuXG4gKiAgICAgICAgICBbeGhyXTogdGhlIFhNTEh0dHBSZXF1ZXN0IEFQSSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgWE1MSHR0cFJlcXVlc3QgZG9jdW1lbnQgbG9hZGVyLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICh7XG4gIHNlY3VyZSxcbiAgaGVhZGVycyA9IHt9LFxuICB4aHJcbn0gPSB7aGVhZGVyczoge319KSA9PiB7XG4gIGhlYWRlcnMgPSBidWlsZEhlYWRlcnMoaGVhZGVycyk7XG4gIGNvbnN0IHF1ZXVlID0gbmV3IFJlcXVlc3RRdWV1ZSgpO1xuICByZXR1cm4gcXVldWUud3JhcExvYWRlcihsb2FkZXIpO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRlcih1cmwpIHtcbiAgICBpZih1cmwuaW5kZXhPZignaHR0cDonKSAhPT0gMCAmJiB1cmwuaW5kZXhPZignaHR0cHM6JykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkOyBvbmx5IFwiaHR0cFwiIGFuZCBcImh0dHBzXCIgVVJMcyBhcmUgJyArXG4gICAgICAgICdzdXBwb3J0ZWQuJyxcbiAgICAgICAgJ2pzb25sZC5JbnZhbGlkVXJsJywge2NvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsIHVybH0pO1xuICAgIH1cbiAgICBpZihzZWN1cmUgJiYgdXJsLmluZGV4T2YoJ2h0dHBzJykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkOyBzZWN1cmUgbW9kZSBpcyBlbmFibGVkIGFuZCAnICtcbiAgICAgICAgJ3RoZSBVUkxcXCdzIHNjaGVtZSBpcyBub3QgXCJodHRwc1wiLicsXG4gICAgICAgICdqc29ubGQuSW52YWxpZFVybCcsIHtjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLCB1cmx9KTtcbiAgICB9XG5cbiAgICBsZXQgcmVxO1xuICAgIHRyeSB7XG4gICAgICByZXEgPSBhd2FpdCBfZ2V0KHhociwgdXJsLCBoZWFkZXJzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkLCBhbiBlcnJvciBvY2N1cnJlZC4nLFxuICAgICAgICAnanNvbmxkLkxvYWREb2N1bWVudEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsIHVybCwgY2F1c2U6IGV9KTtcbiAgICB9XG5cbiAgICBpZihyZXEuc3RhdHVzID49IDQwMCkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQ6ICcgKyByZXEuc3RhdHVzVGV4dCxcbiAgICAgICAgJ2pzb25sZC5Mb2FkRG9jdW1lbnRFcnJvcicsIHtcbiAgICAgICAgICBjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVxLnN0YXR1c1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgZG9jID0ge2NvbnRleHRVcmw6IG51bGwsIGRvY3VtZW50VXJsOiB1cmwsIGRvY3VtZW50OiByZXEucmVzcG9uc2V9O1xuICAgIGxldCBhbHRlcm5hdGUgPSBudWxsO1xuXG4gICAgLy8gaGFuZGxlIExpbmsgSGVhZGVyIChhdm9pZCB1bnNhZmUgaGVhZGVyIHdhcm5pbmcgYnkgZXhpc3RlbmNlIHRlc3RpbmcpXG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXEuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgIGxldCBsaW5rSGVhZGVyO1xuICAgIGlmKFJFR0VYX0xJTktfSEVBREVSLnRlc3QocmVxLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgbGlua0hlYWRlciA9IHJlcS5nZXRSZXNwb25zZUhlYWRlcignTGluaycpO1xuICAgIH1cbiAgICBpZihsaW5rSGVhZGVyICYmIGNvbnRlbnRUeXBlICE9PSAnYXBwbGljYXRpb24vbGQranNvbicpIHtcbiAgICAgIC8vIG9ubHkgMSByZWxhdGVkIGxpbmsgaGVhZGVyIHBlcm1pdHRlZFxuICAgICAgY29uc3QgbGlua0hlYWRlcnMgPSBwYXJzZUxpbmtIZWFkZXIobGlua0hlYWRlcik7XG4gICAgICBjb25zdCBsaW5rZWRDb250ZXh0ID0gbGlua0hlYWRlcnNbTElOS19IRUFERVJfQ09OVEVYVF07XG4gICAgICBpZihBcnJheS5pc0FycmF5KGxpbmtlZENvbnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQsIGl0IGhhcyBtb3JlIHRoYW4gb25lICcgK1xuICAgICAgICAgICdhc3NvY2lhdGVkIEhUVFAgTGluayBIZWFkZXIuJyxcbiAgICAgICAgICAnanNvbmxkLkludmFsaWRVcmwnLFxuICAgICAgICAgIHtjb2RlOiAnbXVsdGlwbGUgY29udGV4dCBsaW5rIGhlYWRlcnMnLCB1cmx9KTtcbiAgICAgIH1cbiAgICAgIGlmKGxpbmtlZENvbnRleHQpIHtcbiAgICAgICAgZG9jLmNvbnRleHRVcmwgPSBsaW5rZWRDb250ZXh0LnRhcmdldDtcbiAgICAgIH1cblxuICAgICAgLy8gXCJhbHRlcm5hdGVcIiBsaW5rIGhlYWRlciBpcyBhIHJlZGlyZWN0XG4gICAgICBhbHRlcm5hdGUgPSBsaW5rSGVhZGVyc1snYWx0ZXJuYXRlJ107XG4gICAgICBpZihhbHRlcm5hdGUgJiZcbiAgICAgICAgYWx0ZXJuYXRlLnR5cGUgPT0gJ2FwcGxpY2F0aW9uL2xkK2pzb24nICYmXG4gICAgICAgICEoY29udGVudFR5cGUgfHwgJycpLm1hdGNoKC9eYXBwbGljYXRpb25cXC8oXFx3KlxcKyk/anNvbiQvKSkge1xuICAgICAgICBkb2MgPSBhd2FpdCBsb2FkZXIocHJlcGVuZEJhc2UodXJsLCBhbHRlcm5hdGUudGFyZ2V0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvYztcbiAgfVxufTtcblxuZnVuY3Rpb24gX2dldCh4aHIsIHVybCwgaGVhZGVycykge1xuICB4aHIgPSB4aHIgfHwgWE1MSHR0cFJlcXVlc3Q7XG4gIGNvbnN0IHJlcSA9IG5ldyB4aHIoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXEub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZXEpO1xuICAgIHJlcS5vbmVycm9yID0gZXJyID0+IHJlamVjdChlcnIpO1xuICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIGZvcihjb25zdCBrIGluIGhlYWRlcnMpIHtcbiAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGssIGhlYWRlcnNba10pO1xuICAgIH1cbiAgICByZXEuc2VuZCgpO1xuICB9KTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcblxuY29uc3Qge1xuICBpc0FycmF5OiBfaXNBcnJheSxcbiAgaXNPYmplY3Q6IF9pc09iamVjdCxcbiAgaXNFbXB0eU9iamVjdDogX2lzRW1wdHlPYmplY3QsXG4gIGlzU3RyaW5nOiBfaXNTdHJpbmcsXG4gIGlzVW5kZWZpbmVkOiBfaXNVbmRlZmluZWRcbn0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IHtcbiAgaXNMaXN0OiBfaXNMaXN0LFxuICBpc1ZhbHVlOiBfaXNWYWx1ZSxcbiAgaXNHcmFwaDogX2lzR3JhcGgsXG4gIGlzU3ViamVjdDogX2lzU3ViamVjdFxufSA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuXG5jb25zdCB7XG4gIGV4cGFuZElyaTogX2V4cGFuZElyaSxcbiAgZ2V0Q29udGV4dFZhbHVlOiBfZ2V0Q29udGV4dFZhbHVlLFxuICBpc0tleXdvcmQ6IF9pc0tleXdvcmQsXG4gIHByb2Nlc3M6IF9wcm9jZXNzQ29udGV4dCxcbiAgcHJvY2Vzc2luZ01vZGU6IF9wcm9jZXNzaW5nTW9kZVxufSA9IHJlcXVpcmUoJy4vY29udGV4dCcpO1xuXG5jb25zdCB7XG4gIGlzQWJzb2x1dGU6IF9pc0Fic29sdXRlSXJpXG59ID0gcmVxdWlyZSgnLi91cmwnKTtcblxuY29uc3Qge1xuICBhZGRWYWx1ZTogX2FkZFZhbHVlLFxuICBhc0FycmF5OiBfYXNBcnJheSxcbiAgZ2V0VmFsdWVzOiBfZ2V0VmFsdWVzLFxuICB2YWxpZGF0ZVR5cGVWYWx1ZTogX3ZhbGlkYXRlVHlwZVZhbHVlXG59ID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5jb25zdCBSRUdFWF9CQ1A0NyA9IC9eW2EtekEtWl17MSw4fSgtW2EtekEtWjAtOV17MSw4fSkqJC87XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZXhwYW5kcyBhbiBlbGVtZW50IHVzaW5nIHRoZSBnaXZlbiBjb250ZXh0LiBBbnkgY29udGV4dCBpblxuICogdGhlIGVsZW1lbnQgd2lsbCBiZSByZW1vdmVkLiBBbGwgY29udGV4dCBVUkxzIG11c3QgaGF2ZSBiZWVuIHJldHJpZXZlZFxuICogYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0gYWN0aXZlUHJvcGVydHkgdGhlIHByb3BlcnR5IGZvciB0aGUgZWxlbWVudCwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGV4cGFuZC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBleHBhbnNpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBpbnNpZGVMaXN0IHRydWUgaWYgdGhlIGVsZW1lbnQgaXMgYSBsaXN0LCBmYWxzZSBpZiBub3QuXG4gKiBAcGFyYW0gaW5zaWRlSW5kZXggdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYW4gaW5kZXggY29udGFpbmVyLFxuICogICAgICAgICAgZmFsc2UgaWYgbm90LlxuICogQHBhcmFtIHR5cGVTY29wZWRDb250ZXh0IGFuIG9wdGlvbmFsIHR5cGUtc2NvcGVkIGFjdGl2ZSBjb250ZXh0IGZvclxuICogICAgICAgICAgZXhwYW5kaW5nIHZhbHVlcyBvZiBub2RlcyB0aGF0IHdlcmUgZXhwcmVzc2VkIGFjY29yZGluZyB0b1xuICogICAgICAgICAgYSB0eXBlLXNjb3BlZCBjb250ZXh0LlxuICogQHBhcmFtIGV4cGFuc2lvbk1hcChpbmZvKSBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3VzdG9tIG1hcFxuICogICAgICAgICAgdW5tYXBwYWJsZSB2YWx1ZXMgKG9yIHRvIHRocm93IGFuIGVycm9yIHdoZW4gdGhleSBhcmUgZGV0ZWN0ZWQpO1xuICogICAgICAgICAgaWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIHRoZW4gdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAqICAgICAgICAgIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBleHBhbmRlZCB2YWx1ZS5cbiAqL1xuYXBpLmV4cGFuZCA9IGFzeW5jICh7XG4gIGFjdGl2ZUN0eCxcbiAgYWN0aXZlUHJvcGVydHkgPSBudWxsLFxuICBlbGVtZW50LFxuICBvcHRpb25zID0ge30sXG4gIGluc2lkZUxpc3QgPSBmYWxzZSxcbiAgaW5zaWRlSW5kZXggPSBmYWxzZSxcbiAgdHlwZVNjb3BlZENvbnRleHQgPSBudWxsLFxuICBleHBhbnNpb25NYXAgPSAoKSA9PiB1bmRlZmluZWRcbn0pID0+IHtcbiAgLy8gbm90aGluZyB0byBleHBhbmRcbiAgaWYoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGRpc2FibGUgZnJhbWluZyBpZiBhY3RpdmVQcm9wZXJ0eSBpcyBAZGVmYXVsdFxuICBpZihhY3RpdmVQcm9wZXJ0eSA9PT0gJ0BkZWZhdWx0Jykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7aXNGcmFtZTogZmFsc2V9KTtcbiAgfVxuXG4gIGlmKCFfaXNBcnJheShlbGVtZW50KSAmJiAhX2lzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgLy8gZHJvcCBmcmVlLWZsb2F0aW5nIHNjYWxhcnMgdGhhdCBhcmUgbm90IGluIGxpc3RzIHVubGVzcyBjdXN0b20gbWFwcGVkXG4gICAgaWYoIWluc2lkZUxpc3QgJiYgKGFjdGl2ZVByb3BlcnR5ID09PSBudWxsIHx8XG4gICAgICBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHt2b2NhYjogdHJ1ZX0sXG4gICAgICAgIG9wdGlvbnMpID09PSAnQGdyYXBoJykpIHtcbiAgICAgIGNvbnN0IG1hcHBlZCA9IGF3YWl0IGV4cGFuc2lvbk1hcCh7XG4gICAgICAgIHVubWFwcGVkVmFsdWU6IGVsZW1lbnQsXG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGluc2lkZUxpc3RcbiAgICAgIH0pO1xuICAgICAgaWYobWFwcGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH1cblxuICAgIC8vIGV4cGFuZCBlbGVtZW50IGFjY29yZGluZyB0byB2YWx1ZSBleHBhbnNpb24gcnVsZXNcbiAgICByZXR1cm4gX2V4cGFuZFZhbHVlKHthY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCB2YWx1ZTogZWxlbWVudCwgb3B0aW9uc30pO1xuICB9XG5cbiAgLy8gcmVjdXJzaXZlbHkgZXhwYW5kIGFycmF5XG4gIGlmKF9pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgbGV0IHJ2YWwgPSBbXTtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0Bjb250YWluZXInKSB8fCBbXTtcbiAgICBpbnNpZGVMaXN0ID0gaW5zaWRlTGlzdCB8fCBjb250YWluZXIuaW5jbHVkZXMoJ0BsaXN0Jyk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIGV4cGFuZCBlbGVtZW50XG4gICAgICBsZXQgZSA9IGF3YWl0IGFwaS5leHBhbmQoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50W2ldLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBleHBhbnNpb25NYXAsXG4gICAgICAgIGluc2lkZUluZGV4LFxuICAgICAgICB0eXBlU2NvcGVkQ29udGV4dFxuICAgICAgfSk7XG4gICAgICBpZihpbnNpZGVMaXN0ICYmIF9pc0FycmF5KGUpKSB7XG4gICAgICAgIGUgPSB7J0BsaXN0JzogZX07XG4gICAgICB9XG5cbiAgICAgIGlmKGUgPT09IG51bGwpIHtcbiAgICAgICAgZSA9IGF3YWl0IGV4cGFuc2lvbk1hcCh7XG4gICAgICAgICAgdW5tYXBwZWRWYWx1ZTogZWxlbWVudFtpXSxcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgICAgcGFyZW50OiBlbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgZXhwYW5kZWRQYXJlbnQ6IHJ2YWwsXG4gICAgICAgICAgaW5zaWRlTGlzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoX2lzQXJyYXkoZSkpIHtcbiAgICAgICAgcnZhbCA9IHJ2YWwuY29uY2F0KGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbC5wdXNoKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfVxuXG4gIC8vIHJlY3Vyc2l2ZWx5IGV4cGFuZCBvYmplY3Q6XG5cbiAgLy8gZmlyc3QsIGV4cGFuZCB0aGUgYWN0aXZlIHByb3BlcnR5XG4gIGNvbnN0IGV4cGFuZGVkQWN0aXZlUHJvcGVydHkgPSBfZXhwYW5kSXJpKFxuICAgIGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gIC8vIEdldCBhbnkgcHJvcGVydHktc2NvcGVkIGNvbnRleHQgZm9yIGFjdGl2ZVByb3BlcnR5XG4gIGNvbnN0IHByb3BlcnR5U2NvcGVkQ3R4ID1cbiAgICBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAY29udGV4dCcpO1xuXG4gIC8vIHNlY29uZCwgZGV0ZXJtaW5lIGlmIGFueSB0eXBlLXNjb3BlZCBjb250ZXh0IHNob3VsZCBiZSByZXZlcnRlZDsgaXRcbiAgLy8gc2hvdWxkIG9ubHkgYmUgcmV2ZXJ0ZWQgd2hlbiB0aGUgZm9sbG93aW5nIGFyZSBhbGwgdHJ1ZTpcbiAgLy8gMS4gYGVsZW1lbnRgIGlzIG5vdCBhIHZhbHVlIG9yIHN1YmplY3QgcmVmZXJlbmNlXG4gIC8vIDIuIGBpbnNpZGVJbmRleGAgaXMgZmFsc2VcbiAgdHlwZVNjb3BlZENvbnRleHQgPSB0eXBlU2NvcGVkQ29udGV4dCB8fFxuICAgIChhY3RpdmVDdHgucHJldmlvdXNDb250ZXh0ID8gYWN0aXZlQ3R4IDogbnVsbCk7XG4gIGxldCBrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudCkuc29ydCgpO1xuICBsZXQgbXVzdFJldmVydCA9ICFpbnNpZGVJbmRleDtcbiAgaWYobXVzdFJldmVydCAmJiB0eXBlU2NvcGVkQ29udGV4dCAmJiBrZXlzLmxlbmd0aCA8PSAyICYmXG4gICAgIWtleXMuaW5jbHVkZXMoJ0Bjb250ZXh0JykpIHtcbiAgICBmb3IoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGNvbnN0IGV4cGFuZGVkUHJvcGVydHkgPSBfZXhwYW5kSXJpKFxuICAgICAgICB0eXBlU2NvcGVkQ29udGV4dCwga2V5LCB7dm9jYWI6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAdmFsdWUnKSB7XG4gICAgICAgIC8vIHZhbHVlIGZvdW5kLCBlbnN1cmUgdHlwZS1zY29wZWQgY29udGV4dCBpcyB1c2VkIHRvIGV4cGFuZCBpdFxuICAgICAgICBtdXN0UmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgIGFjdGl2ZUN0eCA9IHR5cGVTY29wZWRDb250ZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAaWQnICYmIGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHN1YmplY3QgcmVmZXJlbmNlIGZvdW5kLCBkbyBub3QgcmV2ZXJ0XG4gICAgICAgIG11c3RSZXZlcnQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYobXVzdFJldmVydCkge1xuICAgIC8vIHJldmVydCB0eXBlIHNjb3BlZCBjb250ZXh0XG4gICAgYWN0aXZlQ3R4ID0gYWN0aXZlQ3R4LnJldmVydFRvUHJldmlvdXNDb250ZXh0KCk7XG4gIH1cblxuICAvLyBhcHBseSBwcm9wZXJ0eS1zY29wZWQgY29udGV4dCBhZnRlciByZXZlcnRpbmcgdGVybS1zY29wZWQgY29udGV4dFxuICBpZighX2lzVW5kZWZpbmVkKHByb3BlcnR5U2NvcGVkQ3R4KSkge1xuICAgIGFjdGl2ZUN0eCA9IGF3YWl0IF9wcm9jZXNzQ29udGV4dCh7XG4gICAgICBhY3RpdmVDdHgsXG4gICAgICBsb2NhbEN0eDogcHJvcGVydHlTY29wZWRDdHgsXG4gICAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgICBvdmVycmlkZVByb3RlY3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGlmIGVsZW1lbnQgaGFzIGEgY29udGV4dCwgcHJvY2VzcyBpdFxuICBpZignQGNvbnRleHQnIGluIGVsZW1lbnQpIHtcbiAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoXG4gICAgICB7YWN0aXZlQ3R4LCBsb2NhbEN0eDogZWxlbWVudFsnQGNvbnRleHQnXSwgb3B0aW9uc30pO1xuICB9XG5cbiAgLy8gc2V0IHRoZSB0eXBlLXNjb3BlZCBjb250ZXh0IHRvIHRoZSBjb250ZXh0IG9uIGlucHV0LCBmb3IgdXNlIGxhdGVyXG4gIHR5cGVTY29wZWRDb250ZXh0ID0gYWN0aXZlQ3R4O1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBmaXJzdCBrZXkgZm91bmQgZXhwYW5kaW5nIHRvIEB0eXBlXG4gIGxldCB0eXBlS2V5ID0gbnVsbDtcblxuICAvLyBsb29rIGZvciBzY29wZWQgY29udGV4dHMgb24gYEB0eXBlYFxuICBmb3IoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBleHBhbmRlZFByb3BlcnR5ID0gX2V4cGFuZElyaShhY3RpdmVDdHgsIGtleSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0B0eXBlJykge1xuICAgICAgLy8gc2V0IHNjb3BlZCBjb250ZXh0cyBmcm9tIEB0eXBlXG4gICAgICAvLyBhdm9pZCBzb3J0aW5nIGlmIHBvc3NpYmxlXG4gICAgICB0eXBlS2V5ID0gdHlwZUtleSB8fCBrZXk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnRba2V5XTtcbiAgICAgIGNvbnN0IHR5cGVzID1cbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgP1xuICAgICAgICAgICh2YWx1ZS5sZW5ndGggPiAxID8gdmFsdWUuc2xpY2UoKS5zb3J0KCkgOiB2YWx1ZSkgOiBbdmFsdWVdO1xuICAgICAgZm9yKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gX2dldENvbnRleHRWYWx1ZSh0eXBlU2NvcGVkQ29udGV4dCwgdHlwZSwgJ0Bjb250ZXh0Jyk7XG4gICAgICAgIGlmKCFfaXNVbmRlZmluZWQoY3R4KSkge1xuICAgICAgICAgIGFjdGl2ZUN0eCA9IGF3YWl0IF9wcm9jZXNzQ29udGV4dCh7XG4gICAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgICBsb2NhbEN0eDogY3R4LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHByb3BhZ2F0ZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHByb2Nlc3MgZWFjaCBrZXkgYW5kIHZhbHVlIGluIGVsZW1lbnQsIGlnbm9yaW5nIEBuZXN0IGNvbnRlbnRcbiAgbGV0IHJ2YWwgPSB7fTtcbiAgYXdhaXQgX2V4cGFuZE9iamVjdCh7XG4gICAgYWN0aXZlQ3R4LFxuICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgIGV4cGFuZGVkQWN0aXZlUHJvcGVydHksXG4gICAgZWxlbWVudCxcbiAgICBleHBhbmRlZFBhcmVudDogcnZhbCxcbiAgICBvcHRpb25zLFxuICAgIGluc2lkZUxpc3QsXG4gICAgdHlwZUtleSxcbiAgICB0eXBlU2NvcGVkQ29udGV4dCxcbiAgICBleHBhbnNpb25NYXB9KTtcblxuICAvLyBnZXQgcHJvcGVydHkgY291bnQgb24gZXhwYW5kZWQgb3V0cHV0XG4gIGtleXMgPSBPYmplY3Qua2V5cyhydmFsKTtcbiAgbGV0IGNvdW50ID0ga2V5cy5sZW5ndGg7XG5cbiAgaWYoJ0B2YWx1ZScgaW4gcnZhbCkge1xuICAgIC8vIEB2YWx1ZSBtdXN0IG9ubHkgaGF2ZSBAbGFuZ3VhZ2Ugb3IgQHR5cGVcbiAgICBpZignQHR5cGUnIGluIHJ2YWwgJiYgKCdAbGFuZ3VhZ2UnIGluIHJ2YWwgfHwgJ0BkaXJlY3Rpb24nIGluIHJ2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhbiBlbGVtZW50IGNvbnRhaW5pbmcgXCJAdmFsdWVcIiBtYXkgbm90ICcgK1xuICAgICAgICAnY29udGFpbiBib3RoIFwiQHR5cGVcIiBhbmQgZWl0aGVyIFwiQGxhbmd1YWdlXCIgb3IgXCJAZGlyZWN0aW9uXCIuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCB2YWx1ZSBvYmplY3QnLCBlbGVtZW50OiBydmFsfSk7XG4gICAgfVxuICAgIGxldCB2YWxpZENvdW50ID0gY291bnQgLSAxO1xuICAgIGlmKCdAdHlwZScgaW4gcnZhbCkge1xuICAgICAgdmFsaWRDb3VudCAtPSAxO1xuICAgIH1cbiAgICBpZignQGluZGV4JyBpbiBydmFsKSB7XG4gICAgICB2YWxpZENvdW50IC09IDE7XG4gICAgfVxuICAgIGlmKCdAbGFuZ3VhZ2UnIGluIHJ2YWwpIHtcbiAgICAgIHZhbGlkQ291bnQgLT0gMTtcbiAgICB9XG4gICAgaWYoJ0BkaXJlY3Rpb24nIGluIHJ2YWwpIHtcbiAgICAgIHZhbGlkQ291bnQgLT0gMTtcbiAgICB9XG4gICAgaWYodmFsaWRDb3VudCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYW4gZWxlbWVudCBjb250YWluaW5nIFwiQHZhbHVlXCIgbWF5IG9ubHkgJyArXG4gICAgICAgICdoYXZlIGFuIFwiQGluZGV4XCIgcHJvcGVydHkgYW5kIGVpdGhlciBcIkB0eXBlXCIgJyArXG4gICAgICAgICdvciBlaXRoZXIgb3IgYm90aCBcIkBsYW5ndWFnZVwiIG9yIFwiQGRpcmVjdGlvblwiLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgdmFsdWUgb2JqZWN0JywgZWxlbWVudDogcnZhbH0pO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSBydmFsWydAdmFsdWUnXSA9PT0gbnVsbCA/IFtdIDogX2FzQXJyYXkocnZhbFsnQHZhbHVlJ10pO1xuICAgIGNvbnN0IHR5cGVzID0gX2dldFZhbHVlcyhydmFsLCAnQHR5cGUnKTtcblxuICAgIC8vIGRyb3AgbnVsbCBAdmFsdWVzIHVubGVzcyBjdXN0b20gbWFwcGVkXG4gICAgaWYoX3Byb2Nlc3NpbmdNb2RlKGFjdGl2ZUN0eCwgMS4xKSAmJiB0eXBlcy5pbmNsdWRlcygnQGpzb24nKSAmJlxuICAgICAgdHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBBbnkgdmFsdWUgb2YgQHZhbHVlIGlzIG9rYXkgaWYgQHR5cGU6IEBqc29uXG4gICAgfSBlbHNlIGlmKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IG1hcHBlZCA9IGF3YWl0IGV4cGFuc2lvbk1hcCh7XG4gICAgICAgIHVubWFwcGVkVmFsdWU6IHJ2YWwsXG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGluc2lkZUxpc3RcbiAgICAgIH0pO1xuICAgICAgaWYobWFwcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcnZhbCA9IG1hcHBlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZighdmFsdWVzLmV2ZXJ5KHYgPT4gKF9pc1N0cmluZyh2KSB8fCBfaXNFbXB0eU9iamVjdCh2KSkpICYmXG4gICAgICAnQGxhbmd1YWdlJyBpbiBydmFsKSB7XG4gICAgICAvLyBpZiBAbGFuZ3VhZ2UgaXMgcHJlc2VudCwgQHZhbHVlIG11c3QgYmUgYSBzdHJpbmdcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IG9ubHkgc3RyaW5ncyBtYXkgYmUgbGFuZ3VhZ2UtdGFnZ2VkLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgbGFuZ3VhZ2UtdGFnZ2VkIHZhbHVlJywgZWxlbWVudDogcnZhbH0pO1xuICAgIH0gZWxzZSBpZighdHlwZXMuZXZlcnkodCA9PlxuICAgICAgKF9pc0Fic29sdXRlSXJpKHQpICYmICEoX2lzU3RyaW5nKHQpICYmIHQuaW5kZXhPZignXzonKSA9PT0gMCkgfHxcbiAgICAgIF9pc0VtcHR5T2JqZWN0KHQpKSkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGFuIGVsZW1lbnQgY29udGFpbmluZyBcIkB2YWx1ZVwiIGFuZCBcIkB0eXBlXCIgJyArXG4gICAgICAgICdtdXN0IGhhdmUgYW4gYWJzb2x1dGUgSVJJIGZvciB0aGUgdmFsdWUgb2YgXCJAdHlwZVwiLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgdHlwZWQgdmFsdWUnLCBlbGVtZW50OiBydmFsfSk7XG4gICAgfVxuICB9IGVsc2UgaWYoJ0B0eXBlJyBpbiBydmFsICYmICFfaXNBcnJheShydmFsWydAdHlwZSddKSkge1xuICAgIC8vIGNvbnZlcnQgQHR5cGUgdG8gYW4gYXJyYXlcbiAgICBydmFsWydAdHlwZSddID0gW3J2YWxbJ0B0eXBlJ11dO1xuICB9IGVsc2UgaWYoJ0BzZXQnIGluIHJ2YWwgfHwgJ0BsaXN0JyBpbiBydmFsKSB7XG4gICAgLy8gaGFuZGxlIEBzZXQgYW5kIEBsaXN0XG4gICAgaWYoY291bnQgPiAxICYmICEoY291bnQgPT09IDIgJiYgJ0BpbmRleCcgaW4gcnZhbCkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGlmIGFuIGVsZW1lbnQgaGFzIHRoZSBwcm9wZXJ0eSBcIkBzZXRcIiAnICtcbiAgICAgICAgJ29yIFwiQGxpc3RcIiwgdGhlbiBpdCBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBvdGhlciBwcm9wZXJ0eSB0aGF0IGlzICcgK1xuICAgICAgICAnXCJAaW5kZXhcIi4nLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHNldCBvciBsaXN0IG9iamVjdCcsIGVsZW1lbnQ6IHJ2YWx9KTtcbiAgICB9XG4gICAgLy8gb3B0aW1pemUgYXdheSBAc2V0XG4gICAgaWYoJ0BzZXQnIGluIHJ2YWwpIHtcbiAgICAgIHJ2YWwgPSBydmFsWydAc2V0J107XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMocnZhbCk7XG4gICAgICBjb3VudCA9IGtleXMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmKGNvdW50ID09PSAxICYmICdAbGFuZ3VhZ2UnIGluIHJ2YWwpIHtcbiAgICAvLyBkcm9wIG9iamVjdHMgd2l0aCBvbmx5IEBsYW5ndWFnZSB1bmxlc3MgY3VzdG9tIG1hcHBlZFxuICAgIGNvbnN0IG1hcHBlZCA9IGF3YWl0IGV4cGFuc2lvbk1hcChydmFsLCB7XG4gICAgICB1bm1hcHBlZFZhbHVlOiBydmFsLFxuICAgICAgYWN0aXZlQ3R4LFxuICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICBlbGVtZW50LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGluc2lkZUxpc3RcbiAgICB9KTtcbiAgICBpZihtYXBwZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcnZhbCA9IG1hcHBlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcnZhbCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gZHJvcCBjZXJ0YWluIHRvcC1sZXZlbCBvYmplY3RzIHRoYXQgZG8gbm90IG9jY3VyIGluIGxpc3RzLCB1bmxlc3MgY3VzdG9tXG4gIC8vIG1hcHBlZFxuICBpZihfaXNPYmplY3QocnZhbCkgJiZcbiAgICAhb3B0aW9ucy5rZWVwRnJlZUZsb2F0aW5nTm9kZXMgJiYgIWluc2lkZUxpc3QgJiZcbiAgICAoYWN0aXZlUHJvcGVydHkgPT09IG51bGwgfHwgZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSA9PT0gJ0BncmFwaCcpKSB7XG4gICAgLy8gZHJvcCBlbXB0eSBvYmplY3QsIHRvcC1sZXZlbCBAdmFsdWUvQGxpc3QsIG9yIG9iamVjdCB3aXRoIG9ubHkgQGlkXG4gICAgaWYoY291bnQgPT09IDAgfHwgJ0B2YWx1ZScgaW4gcnZhbCB8fCAnQGxpc3QnIGluIHJ2YWwgfHxcbiAgICAgIChjb3VudCA9PT0gMSAmJiAnQGlkJyBpbiBydmFsKSkge1xuICAgICAgY29uc3QgbWFwcGVkID0gYXdhaXQgZXhwYW5zaW9uTWFwKHtcbiAgICAgICAgdW5tYXBwZWRWYWx1ZTogcnZhbCxcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaW5zaWRlTGlzdFxuICAgICAgfSk7XG4gICAgICBpZihtYXBwZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBydmFsID0gbWFwcGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEV4cGFuZCBlYWNoIGtleSBhbmQgdmFsdWUgb2YgZWxlbWVudCBhZGRpbmcgdG8gcmVzdWx0XG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0gYWN0aXZlUHJvcGVydHkgdGhlIHByb3BlcnR5IGZvciB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSBleHBhbmRlZEFjdGl2ZVByb3BlcnR5IHRoZSBleHBhbnNpb24gb2YgYWN0aXZlUHJvcGVydHlcbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGV4cGFuZC5cbiAqIEBwYXJhbSBleHBhbmRlZFBhcmVudCB0aGUgZXhwYW5kZWQgcmVzdWx0IGludG8gd2hpY2ggdG8gYWRkIHZhbHVlcy5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBleHBhbnNpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBpbnNpZGVMaXN0IHRydWUgaWYgdGhlIGVsZW1lbnQgaXMgYSBsaXN0LCBmYWxzZSBpZiBub3QuXG4gKiBAcGFyYW0gdHlwZUtleSBmaXJzdCBrZXkgZm91bmQgZXhwYW5kaW5nIHRvIEB0eXBlLlxuICogQHBhcmFtIHR5cGVTY29wZWRDb250ZXh0IHRoZSBjb250ZXh0IGJlZm9yZSByZXZlcnRpbmcuXG4gKiBAcGFyYW0gZXhwYW5zaW9uTWFwKGluZm8pIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjdXN0b20gbWFwXG4gKiAgICAgICAgICB1bm1hcHBhYmxlIHZhbHVlcyAob3IgdG8gdGhyb3cgYW4gZXJyb3Igd2hlbiB0aGV5IGFyZSBkZXRlY3RlZCk7XG4gKiAgICAgICAgICBpZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgdGhlbiB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICogICAgICAgICAgd2lsbCBiZSB1c2VkLlxuICovXG5hc3luYyBmdW5jdGlvbiBfZXhwYW5kT2JqZWN0KHtcbiAgYWN0aXZlQ3R4LFxuICBhY3RpdmVQcm9wZXJ0eSxcbiAgZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSxcbiAgZWxlbWVudCxcbiAgZXhwYW5kZWRQYXJlbnQsXG4gIG9wdGlvbnMgPSB7fSxcbiAgaW5zaWRlTGlzdCxcbiAgdHlwZUtleSxcbiAgdHlwZVNjb3BlZENvbnRleHQsXG4gIGV4cGFuc2lvbk1hcFxufSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudCkuc29ydCgpO1xuICBjb25zdCBuZXN0cyA9IFtdO1xuICBsZXQgdW5leHBhbmRlZFZhbHVlO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgdGhpcyBpcyB0aGUgdHlwZSBmb3IgYSBKU09OIGxpdGVyYWxcbiAgY29uc3QgaXNKc29uVHlwZSA9IGVsZW1lbnRbdHlwZUtleV0gJiZcbiAgICBfZXhwYW5kSXJpKGFjdGl2ZUN0eCxcbiAgICAgIChfaXNBcnJheShlbGVtZW50W3R5cGVLZXldKSA/IGVsZW1lbnRbdHlwZUtleV1bMF0gOiBlbGVtZW50W3R5cGVLZXldKSxcbiAgICAgIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpID09PSAnQGpzb24nO1xuXG4gIGZvcihjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGxldCB2YWx1ZSA9IGVsZW1lbnRba2V5XTtcbiAgICBsZXQgZXhwYW5kZWRWYWx1ZTtcblxuICAgIC8vIHNraXAgQGNvbnRleHRcbiAgICBpZihrZXkgPT09ICdAY29udGV4dCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGV4cGFuZCBwcm9wZXJ0eVxuICAgIGxldCBleHBhbmRlZFByb3BlcnR5ID0gX2V4cGFuZElyaShhY3RpdmVDdHgsIGtleSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBkcm9wIG5vbi1hYnNvbHV0ZSBJUkkga2V5cyB0aGF0IGFyZW4ndCBrZXl3b3JkcyB1bmxlc3MgY3VzdG9tIG1hcHBlZFxuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09IG51bGwgfHxcbiAgICAgICEoX2lzQWJzb2x1dGVJcmkoZXhwYW5kZWRQcm9wZXJ0eSkgfHwgX2lzS2V5d29yZChleHBhbmRlZFByb3BlcnR5KSkpIHtcbiAgICAgIC8vIFRPRE86IHVzZSBgYXdhaXRgIHRvIHN1cHBvcnQgYXN5bmNcbiAgICAgIGV4cGFuZGVkUHJvcGVydHkgPSBleHBhbnNpb25NYXAoe1xuICAgICAgICB1bm1hcHBlZFByb3BlcnR5OiBrZXksXG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgIHBhcmVudDogZWxlbWVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaW5zaWRlTGlzdCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGV4cGFuZGVkUGFyZW50XG4gICAgICB9KTtcbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihfaXNLZXl3b3JkKGV4cGFuZGVkUHJvcGVydHkpKSB7XG4gICAgICBpZihleHBhbmRlZEFjdGl2ZVByb3BlcnR5ID09PSAnQHJldmVyc2UnKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYSBrZXl3b3JkIGNhbm5vdCBiZSB1c2VkIGFzIGEgQHJldmVyc2UgJyArXG4gICAgICAgICAgJ3Byb3BlcnR5LicsICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCByZXZlcnNlIHByb3BlcnR5IG1hcCcsIHZhbHVlfSk7XG4gICAgICB9XG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5IGluIGV4cGFuZGVkUGFyZW50ICYmXG4gICAgICAgICBleHBhbmRlZFByb3BlcnR5ICE9PSAnQGluY2x1ZGVkJyAmJlxuICAgICAgICAgZXhwYW5kZWRQcm9wZXJ0eSAhPT0gJ0B0eXBlJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGNvbGxpZGluZyBrZXl3b3JkcyBkZXRlY3RlZC4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnY29sbGlkaW5nIGtleXdvcmRzJywga2V5d29yZDogZXhwYW5kZWRQcm9wZXJ0eX0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN5bnRheCBlcnJvciBpZiBAaWQgaXMgbm90IGEgc3RyaW5nXG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BpZCcpIHtcbiAgICAgIGlmKCFfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGlmKCFvcHRpb25zLmlzRnJhbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAaWRcIiB2YWx1ZSBtdXN0IGEgc3RyaW5nLicsXG4gICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIEBpZCB2YWx1ZScsIHZhbHVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoX2lzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIC8vIGVtcHR5IG9iamVjdCBpcyBhIHdpbGRjYXJkXG4gICAgICAgICAgaWYoIV9pc0VtcHR5T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAaWRcIiB2YWx1ZSBhbiBlbXB0eSBvYmplY3Qgb3IgYXJyYXkgJyArXG4gICAgICAgICAgICAgICdvZiBzdHJpbmdzLCBpZiBmcmFtaW5nJyxcbiAgICAgICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAaWQgdmFsdWUnLCB2YWx1ZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKF9pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmKCF2YWx1ZS5ldmVyeSh2ID0+IF9pc1N0cmluZyh2KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGlkXCIgdmFsdWUgYW4gZW1wdHkgb2JqZWN0IG9yIGFycmF5ICcgK1xuICAgICAgICAgICAgICAnb2Ygc3RyaW5ncywgaWYgZnJhbWluZycsXG4gICAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQGlkIHZhbHVlJywgdmFsdWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGlkXCIgdmFsdWUgYW4gZW1wdHkgb2JqZWN0IG9yIGFycmF5ICcgK1xuICAgICAgICAgICAgJ29mIHN0cmluZ3MsIGlmIGZyYW1pbmcnLFxuICAgICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAaWQgdmFsdWUnLCB2YWx1ZX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgZXhwYW5kZWRQYXJlbnQsICdAaWQnLFxuICAgICAgICBfYXNBcnJheSh2YWx1ZSkubWFwKHYgPT5cbiAgICAgICAgICBfaXNTdHJpbmcodikgPyBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgdiwge2Jhc2U6IHRydWV9LCBvcHRpb25zKSA6IHYpLFxuICAgICAgICB7cHJvcGVydHlJc0FycmF5OiBvcHRpb25zLmlzRnJhbWV9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAdHlwZScpIHtcbiAgICAgIC8vIGlmIGZyYW1pbmcsIGNhbiBiZSBhIGRlZmF1bHQgb2JqZWN0LCBidXQgbmVlZCB0byBleHBhbmRcbiAgICAgIC8vIGtleSB0byBkZXRlcm1pbmUgdGhhdFxuICAgICAgaWYoX2lzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbaywgdl0pID0+IFtcbiAgICAgICAgICBfZXhwYW5kSXJpKHR5cGVTY29wZWRDb250ZXh0LCBrLCB7dm9jYWI6IHRydWV9KSxcbiAgICAgICAgICBfYXNBcnJheSh2KS5tYXAodnYgPT5cbiAgICAgICAgICAgIF9leHBhbmRJcmkodHlwZVNjb3BlZENvbnRleHQsIHZ2LCB7YmFzZTogdHJ1ZSwgdm9jYWI6IHRydWV9KVxuICAgICAgICAgIClcbiAgICAgICAgXSkpO1xuICAgICAgfVxuICAgICAgX3ZhbGlkYXRlVHlwZVZhbHVlKHZhbHVlLCBvcHRpb25zLmlzRnJhbWUpO1xuICAgICAgX2FkZFZhbHVlKFxuICAgICAgICBleHBhbmRlZFBhcmVudCwgJ0B0eXBlJyxcbiAgICAgICAgX2FzQXJyYXkodmFsdWUpLm1hcCh2ID0+XG4gICAgICAgICAgX2lzU3RyaW5nKHYpID9cbiAgICAgICAgICAgIF9leHBhbmRJcmkodHlwZVNjb3BlZENvbnRleHQsIHYsXG4gICAgICAgICAgICAgIHtiYXNlOiB0cnVlLCB2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpIDogdiksXG4gICAgICAgIHtwcm9wZXJ0eUlzQXJyYXk6IG9wdGlvbnMuaXNGcmFtZX0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSW5jbHVkZWQgYmxvY2tzIGFyZSB0cmVhdGVkIGFzIGFuIGFycmF5IG9mIHNlcGFyYXRlIG9iamVjdCBub2RlcyBzaGFyaW5nXG4gICAgLy8gdGhlIHNhbWUgcmVmZXJlbmNpbmcgYWN0aXZlX3Byb3BlcnR5LlxuICAgIC8vIEZvciAxLjAsIGl0IGlzIHNraXBwZWQgYXMgYXJlIG90aGVyIHVua25vd24ga2V5d29yZHNcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGluY2x1ZGVkJyAmJiBfcHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpKSB7XG4gICAgICBjb25zdCBpbmNsdWRlZFJlc3VsdCA9IF9hc0FycmF5KGF3YWl0IGFwaS5leHBhbmQoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICBlbGVtZW50OiB2YWx1ZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZXhwYW5zaW9uTWFwXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIEV4cGFuZGVkIHZhbHVlcyBtdXN0IGJlIG5vZGUgb2JqZWN0c1xuICAgICAgaWYoIWluY2x1ZGVkUmVzdWx0LmV2ZXJ5KHYgPT4gX2lzU3ViamVjdCh2KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyAnICtcbiAgICAgICAgICAndmFsdWVzIG9mIEBpbmNsdWRlZCBtdXN0IGV4cGFuZCB0byBub2RlIG9iamVjdHMuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIEBpbmNsdWRlZCB2YWx1ZScsIHZhbHVlfSk7XG4gICAgICB9XG5cbiAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgZXhwYW5kZWRQYXJlbnQsICdAaW5jbHVkZWQnLCBpbmNsdWRlZFJlc3VsdCwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQGdyYXBoIG11c3QgYmUgYW4gYXJyYXkgb3IgYW4gb2JqZWN0XG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BncmFwaCcgJiZcbiAgICAgICEoX2lzT2JqZWN0KHZhbHVlKSB8fCBfaXNBcnJheSh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkBncmFwaFwiIHZhbHVlIG11c3Qgbm90IGJlIGFuICcgK1xuICAgICAgICAnb2JqZWN0IG9yIGFuIGFycmF5LicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQGdyYXBoIHZhbHVlJywgdmFsdWV9KTtcbiAgICB9XG5cbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQHZhbHVlJykge1xuICAgICAgLy8gY2FwdHVyZSB2YWx1ZSBmb3IgbGF0ZXJcbiAgICAgIC8vIFwiY29sbGlkaW5nIGtleXdvcmRzXCIgY2hlY2sgcHJldmVudHMgdGhpcyBmcm9tIGJlaW5nIHNldCB0d2ljZVxuICAgICAgdW5leHBhbmRlZFZhbHVlID0gdmFsdWU7XG4gICAgICBpZihpc0pzb25UeXBlICYmIF9wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSkpIHtcbiAgICAgICAgLy8gbm8gY29lcmNpb24gdG8gYXJyYXksIGFuZCByZXRhaW4gYWxsIHZhbHVlc1xuICAgICAgICBleHBhbmRlZFBhcmVudFsnQHZhbHVlJ10gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgICBleHBhbmRlZFBhcmVudCwgJ0B2YWx1ZScsIHZhbHVlLCB7cHJvcGVydHlJc0FycmF5OiBvcHRpb25zLmlzRnJhbWV9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEBsYW5ndWFnZSBtdXN0IGJlIGEgc3RyaW5nXG4gICAgLy8gaXQgc2hvdWxkIG1hdGNoIEJDUDQ3XG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BsYW5ndWFnZScpIHtcbiAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIC8vIGRyb3AgbnVsbCBAbGFuZ3VhZ2UgdmFsdWVzLCB0aGV5IGV4cGFuZCBhcyBpZiB0aGV5IGRpZG4ndCBleGlzdFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKCFfaXNTdHJpbmcodmFsdWUpICYmICFvcHRpb25zLmlzRnJhbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkBsYW5ndWFnZVwiIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgbGFuZ3VhZ2UtdGFnZ2VkIHN0cmluZycsIHZhbHVlfSk7XG4gICAgICB9XG4gICAgICAvLyBlbnN1cmUgbGFuZ3VhZ2UgdmFsdWUgaXMgbG93ZXJjYXNlXG4gICAgICB2YWx1ZSA9IF9hc0FycmF5KHZhbHVlKS5tYXAodiA9PiBfaXNTdHJpbmcodikgPyB2LnRvTG93ZXJDYXNlKCkgOiB2KTtcblxuICAgICAgLy8gZW5zdXJlIGxhbmd1YWdlIHRhZyBtYXRjaGVzIEJDUDQ3XG4gICAgICBmb3IoY29uc3QgbGFuZyBvZiB2YWx1ZSkge1xuICAgICAgICBpZihfaXNTdHJpbmcobGFuZykgJiYgIWxhbmcubWF0Y2goUkVHRVhfQkNQNDcpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBAbGFuZ3VhZ2UgbXVzdCBiZSB2YWxpZCBCQ1A0NzogJHtsYW5nfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgZXhwYW5kZWRQYXJlbnQsICdAbGFuZ3VhZ2UnLCB2YWx1ZSwge3Byb3BlcnR5SXNBcnJheTogb3B0aW9ucy5pc0ZyYW1lfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBAZGlyZWN0aW9uIG11c3QgYmUgXCJsdHJcIiBvciBcInJ0bFwiXG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BkaXJlY3Rpb24nKSB7XG4gICAgICBpZighX2lzU3RyaW5nKHZhbHVlKSAmJiAhb3B0aW9ucy5pc0ZyYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAZGlyZWN0aW9uXCIgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBiYXNlIGRpcmVjdGlvbicsIHZhbHVlfSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gX2FzQXJyYXkodmFsdWUpO1xuXG4gICAgICAvLyBlbnN1cmUgZGlyZWN0aW9uIGlzIFwibHRyXCIgb3IgXCJydGxcIlxuICAgICAgZm9yKGNvbnN0IGRpciBvZiB2YWx1ZSkge1xuICAgICAgICBpZihfaXNTdHJpbmcoZGlyKSAmJiBkaXIgIT09ICdsdHInICYmIGRpciAhPT0gJ3J0bCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAZGlyZWN0aW9uXCIgbXVzdCBiZSBcImx0clwiIG9yIFwicnRsXCIuJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGJhc2UgZGlyZWN0aW9uJywgdmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfYWRkVmFsdWUoXG4gICAgICAgIGV4cGFuZGVkUGFyZW50LCAnQGRpcmVjdGlvbicsIHZhbHVlLFxuICAgICAgICB7cHJvcGVydHlJc0FycmF5OiBvcHRpb25zLmlzRnJhbWV9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEBpbmRleCBtdXN0IGJlIGEgc3RyaW5nXG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BpbmRleCcpIHtcbiAgICAgIGlmKCFfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAaW5kZXhcIiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIEBpbmRleCB2YWx1ZScsIHZhbHVlfSk7XG4gICAgICB9XG4gICAgICBfYWRkVmFsdWUoZXhwYW5kZWRQYXJlbnQsICdAaW5kZXgnLCB2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBAcmV2ZXJzZSBtdXN0IGJlIGFuIG9iamVjdFxuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAcmV2ZXJzZScpIHtcbiAgICAgIGlmKCFfaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAcmV2ZXJzZVwiIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAcmV2ZXJzZSB2YWx1ZScsIHZhbHVlfSk7XG4gICAgICB9XG5cbiAgICAgIGV4cGFuZGVkVmFsdWUgPSBhd2FpdCBhcGkuZXhwYW5kKHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eTpcbiAgICAgICAgJ0ByZXZlcnNlJyxcbiAgICAgICAgZWxlbWVudDogdmFsdWUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGV4cGFuc2lvbk1hcFxuICAgICAgfSk7XG4gICAgICAvLyBwcm9wZXJ0aWVzIGRvdWJsZS1yZXZlcnNlZFxuICAgICAgaWYoJ0ByZXZlcnNlJyBpbiBleHBhbmRlZFZhbHVlKSB7XG4gICAgICAgIGZvcihjb25zdCBwcm9wZXJ0eSBpbiBleHBhbmRlZFZhbHVlWydAcmV2ZXJzZSddKSB7XG4gICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgZXhwYW5kZWRQYXJlbnQsIHByb3BlcnR5LCBleHBhbmRlZFZhbHVlWydAcmV2ZXJzZSddW3Byb3BlcnR5XSxcbiAgICAgICAgICAgIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGSVhNRTogY2FuIHRoaXMgYmUgbWVyZ2VkIHdpdGggY29kZSBiZWxvdyB0byBzaW1wbGlmeT9cbiAgICAgIC8vIG1lcmdlIGluIGFsbCByZXZlcnNlZCBwcm9wZXJ0aWVzXG4gICAgICBsZXQgcmV2ZXJzZU1hcCA9IGV4cGFuZGVkUGFyZW50WydAcmV2ZXJzZSddIHx8IG51bGw7XG4gICAgICBmb3IoY29uc3QgcHJvcGVydHkgaW4gZXhwYW5kZWRWYWx1ZSkge1xuICAgICAgICBpZihwcm9wZXJ0eSA9PT0gJ0ByZXZlcnNlJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHJldmVyc2VNYXAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXZlcnNlTWFwID0gZXhwYW5kZWRQYXJlbnRbJ0ByZXZlcnNlJ10gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBfYWRkVmFsdWUocmV2ZXJzZU1hcCwgcHJvcGVydHksIFtdLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gZXhwYW5kZWRWYWx1ZVtwcm9wZXJ0eV07XG4gICAgICAgIGZvcihsZXQgaWkgPSAwOyBpaSA8IGl0ZW1zLmxlbmd0aDsgKytpaSkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpaV07XG4gICAgICAgICAgaWYoX2lzVmFsdWUoaXRlbSkgfHwgX2lzTGlzdChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAcmV2ZXJzZVwiIHZhbHVlIG11c3Qgbm90IGJlIGEgJyArXG4gICAgICAgICAgICAgICdAdmFsdWUgb3IgYW4gQGxpc3QuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCByZXZlcnNlIHByb3BlcnR5IHZhbHVlJywgdmFsdWU6IGV4cGFuZGVkVmFsdWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2FkZFZhbHVlKHJldmVyc2VNYXAsIHByb3BlcnR5LCBpdGVtLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbmVzdGVkIGtleXNcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQG5lc3QnKSB7XG4gICAgICBuZXN0cy5wdXNoKGtleSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB1c2UgcG90ZW50aWFsIHNjb3BlZCBjb250ZXh0IGZvciBrZXlcbiAgICBsZXQgdGVybUN0eCA9IGFjdGl2ZUN0eDtcbiAgICBjb25zdCBjdHggPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwga2V5LCAnQGNvbnRleHQnKTtcbiAgICBpZighX2lzVW5kZWZpbmVkKGN0eCkpIHtcbiAgICAgIHRlcm1DdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGxvY2FsQ3R4OiBjdHgsXG4gICAgICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICAgICAgb3ZlcnJpZGVQcm90ZWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRDb250ZXh0VmFsdWUodGVybUN0eCwga2V5LCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuXG4gICAgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAbGFuZ3VhZ2UnKSAmJiBfaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBfZ2V0Q29udGV4dFZhbHVlKHRlcm1DdHgsIGtleSwgJ0BkaXJlY3Rpb24nKTtcbiAgICAgIC8vIGhhbmRsZSBsYW5ndWFnZSBtYXAgY29udGFpbmVyIChza2lwIGlmIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QpXG4gICAgICBleHBhbmRlZFZhbHVlID0gX2V4cGFuZExhbmd1YWdlTWFwKHRlcm1DdHgsIHZhbHVlLCBkaXJlY3Rpb24sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BpbmRleCcpICYmIF9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIC8vIGhhbmRsZSBpbmRleCBjb250YWluZXIgKHNraXAgaWYgdmFsdWUgaXMgbm90IGFuIG9iamVjdClcbiAgICAgIGNvbnN0IGFzR3JhcGggPSBjb250YWluZXIuaW5jbHVkZXMoJ0BncmFwaCcpO1xuICAgICAgY29uc3QgaW5kZXhLZXkgPSBfZ2V0Q29udGV4dFZhbHVlKHRlcm1DdHgsIGtleSwgJ0BpbmRleCcpIHx8ICdAaW5kZXgnO1xuICAgICAgY29uc3QgcHJvcGVydHlJbmRleCA9IGluZGV4S2V5ICE9PSAnQGluZGV4JyAmJlxuICAgICAgICBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgaW5kZXhLZXksIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgICBleHBhbmRlZFZhbHVlID0gYXdhaXQgX2V4cGFuZEluZGV4TWFwKHtcbiAgICAgICAgYWN0aXZlQ3R4OiB0ZXJtQ3R4LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eToga2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZXhwYW5zaW9uTWFwLFxuICAgICAgICBhc0dyYXBoLFxuICAgICAgICBpbmRleEtleSxcbiAgICAgICAgcHJvcGVydHlJbmRleFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGlkJykgJiYgX2lzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gaGFuZGxlIGlkIGNvbnRhaW5lciAoc2tpcCBpZiB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0KVxuICAgICAgY29uc3QgYXNHcmFwaCA9IGNvbnRhaW5lci5pbmNsdWRlcygnQGdyYXBoJyk7XG4gICAgICBleHBhbmRlZFZhbHVlID0gYXdhaXQgX2V4cGFuZEluZGV4TWFwKHtcbiAgICAgICAgYWN0aXZlQ3R4OiB0ZXJtQ3R4LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eToga2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZXhwYW5zaW9uTWFwLFxuICAgICAgICBhc0dyYXBoLFxuICAgICAgICBpbmRleEtleTogJ0BpZCdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZihjb250YWluZXIuaW5jbHVkZXMoJ0B0eXBlJykgJiYgX2lzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gaGFuZGxlIHR5cGUgY29udGFpbmVyIChza2lwIGlmIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QpXG4gICAgICBleHBhbmRlZFZhbHVlID0gYXdhaXQgX2V4cGFuZEluZGV4TWFwKHtcbiAgICAgICAgLy8gc2luY2UgY29udGFpbmVyIGlzIGBAdHlwZWAsIHJldmVydCB0eXBlIHNjb3BlZCBjb250ZXh0IHdoZW4gZXhwYW5kaW5nXG4gICAgICAgIGFjdGl2ZUN0eDogdGVybUN0eC5yZXZlcnRUb1ByZXZpb3VzQ29udGV4dCgpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eToga2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZXhwYW5zaW9uTWFwLFxuICAgICAgICBhc0dyYXBoOiBmYWxzZSxcbiAgICAgICAgaW5kZXhLZXk6ICdAdHlwZSdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWN1cnNlIGludG8gQGxpc3Qgb3IgQHNldFxuICAgICAgY29uc3QgaXNMaXN0ID0gKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAbGlzdCcpO1xuICAgICAgaWYoaXNMaXN0IHx8IGV4cGFuZGVkUHJvcGVydHkgPT09ICdAc2V0Jykge1xuICAgICAgICBsZXQgbmV4dEFjdGl2ZVByb3BlcnR5ID0gYWN0aXZlUHJvcGVydHk7XG4gICAgICAgIGlmKGlzTGlzdCAmJiBleHBhbmRlZEFjdGl2ZVByb3BlcnR5ID09PSAnQGdyYXBoJykge1xuICAgICAgICAgIG5leHRBY3RpdmVQcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXhwYW5kZWRWYWx1ZSA9IGF3YWl0IGFwaS5leHBhbmQoe1xuICAgICAgICAgIGFjdGl2ZUN0eDogdGVybUN0eCxcbiAgICAgICAgICBhY3RpdmVQcm9wZXJ0eTogbmV4dEFjdGl2ZVByb3BlcnR5LFxuICAgICAgICAgIGVsZW1lbnQ6IHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaW5zaWRlTGlzdDogaXNMaXN0LFxuICAgICAgICAgIGV4cGFuc2lvbk1hcFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZihcbiAgICAgICAgX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGtleSwgJ0B0eXBlJykgPT09ICdAanNvbicpIHtcbiAgICAgICAgZXhwYW5kZWRWYWx1ZSA9IHtcbiAgICAgICAgICAnQHR5cGUnOiAnQGpzb24nLFxuICAgICAgICAgICdAdmFsdWUnOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZXhwYW5kIHZhbHVlIHdpdGgga2V5IGFzIG5ldyBhY3RpdmUgcHJvcGVydHlcbiAgICAgICAgZXhwYW5kZWRWYWx1ZSA9IGF3YWl0IGFwaS5leHBhbmQoe1xuICAgICAgICAgIGFjdGl2ZUN0eDogdGVybUN0eCxcbiAgICAgICAgICBhY3RpdmVQcm9wZXJ0eToga2V5LFxuICAgICAgICAgIGVsZW1lbnQ6IHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaW5zaWRlTGlzdDogZmFsc2UsXG4gICAgICAgICAgZXhwYW5zaW9uTWFwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRyb3AgbnVsbCB2YWx1ZXMgaWYgcHJvcGVydHkgaXMgbm90IEB2YWx1ZVxuICAgIGlmKGV4cGFuZGVkVmFsdWUgPT09IG51bGwgJiYgZXhwYW5kZWRQcm9wZXJ0eSAhPT0gJ0B2YWx1ZScpIHtcbiAgICAgIC8vIFRPRE86IHVzZSBgYXdhaXRgIHRvIHN1cHBvcnQgYXN5bmNcbiAgICAgIGV4cGFuZGVkVmFsdWUgPSBleHBhbnNpb25NYXAoe1xuICAgICAgICB1bm1hcHBlZFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZXhwYW5kZWRQcm9wZXJ0eSxcbiAgICAgICAgYWN0aXZlQ3R4OiB0ZXJtQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgcGFyZW50OiBlbGVtZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpbnNpZGVMaXN0LFxuICAgICAgICBrZXksXG4gICAgICAgIGV4cGFuZGVkUGFyZW50XG4gICAgICB9KTtcbiAgICAgIGlmKGV4cGFuZGVkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGV4cGFuZGVkIHZhbHVlIHRvIEBsaXN0IGlmIGNvbnRhaW5lciBzcGVjaWZpZXMgaXRcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ICE9PSAnQGxpc3QnICYmICFfaXNMaXN0KGV4cGFuZGVkVmFsdWUpICYmXG4gICAgICBjb250YWluZXIuaW5jbHVkZXMoJ0BsaXN0JykpIHtcbiAgICAgIC8vIGVuc3VyZSBleHBhbmRlZCB2YWx1ZSBpbiBAbGlzdCBpcyBhbiBhcnJheVxuICAgICAgZXhwYW5kZWRWYWx1ZSA9IHsnQGxpc3QnOiBfYXNBcnJheShleHBhbmRlZFZhbHVlKX07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBleHBhbmRlZCB2YWx1ZSB0byBAZ3JhcGggaWYgY29udGFpbmVyIHNwZWNpZmllcyBpdFxuICAgIC8vIGFuZCB2YWx1ZSBpcyBub3QsIGl0c2VsZiwgYSBncmFwaFxuICAgIC8vIGluZGV4IGNhc2VzIGhhbmRsZWQgYWJvdmVcbiAgICBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BncmFwaCcpICYmXG4gICAgICAhY29udGFpbmVyLnNvbWUoa2V5ID0+IGtleSA9PT0gJ0BpZCcgfHwga2V5ID09PSAnQGluZGV4JykpIHtcbiAgICAgIC8vIGVuc3VyZSBleHBhbmRlZCB2YWx1ZXMgYXJlIGFycmF5c1xuICAgICAgZXhwYW5kZWRWYWx1ZSA9IF9hc0FycmF5KGV4cGFuZGVkVmFsdWUpXG4gICAgICAgIC5tYXAodiA9PiAoeydAZ3JhcGgnOiBfYXNBcnJheSh2KX0pKTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogY2FuIHRoaXMgYmUgbWVyZ2VkIHdpdGggY29kZSBhYm92ZSB0byBzaW1wbGlmeT9cbiAgICAvLyBtZXJnZSBpbiByZXZlcnNlIHByb3BlcnRpZXNcbiAgICBpZih0ZXJtQ3R4Lm1hcHBpbmdzLmhhcyhrZXkpICYmIHRlcm1DdHgubWFwcGluZ3MuZ2V0KGtleSkucmV2ZXJzZSkge1xuICAgICAgY29uc3QgcmV2ZXJzZU1hcCA9XG4gICAgICAgIGV4cGFuZGVkUGFyZW50WydAcmV2ZXJzZSddID0gZXhwYW5kZWRQYXJlbnRbJ0ByZXZlcnNlJ10gfHwge307XG4gICAgICBleHBhbmRlZFZhbHVlID0gX2FzQXJyYXkoZXhwYW5kZWRWYWx1ZSk7XG4gICAgICBmb3IobGV0IGlpID0gMDsgaWkgPCBleHBhbmRlZFZhbHVlLmxlbmd0aDsgKytpaSkge1xuICAgICAgICBjb25zdCBpdGVtID0gZXhwYW5kZWRWYWx1ZVtpaV07XG4gICAgICAgIGlmKF9pc1ZhbHVlKGl0ZW0pIHx8IF9pc0xpc3QoaXRlbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAcmV2ZXJzZVwiIHZhbHVlIG11c3Qgbm90IGJlIGEgJyArXG4gICAgICAgICAgICAnQHZhbHVlIG9yIGFuIEBsaXN0LicsICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIHJldmVyc2UgcHJvcGVydHkgdmFsdWUnLCB2YWx1ZTogZXhwYW5kZWRWYWx1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIF9hZGRWYWx1ZShyZXZlcnNlTWFwLCBleHBhbmRlZFByb3BlcnR5LCBpdGVtLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdmFsdWUgZm9yIHByb3BlcnR5XG4gICAgLy8gc3BlY2lhbCBrZXl3b3JkcyBoYW5kbGVkIGFib3ZlXG4gICAgX2FkZFZhbHVlKGV4cGFuZGVkUGFyZW50LCBleHBhbmRlZFByb3BlcnR5LCBleHBhbmRlZFZhbHVlLCB7XG4gICAgICBwcm9wZXJ0eUlzQXJyYXk6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEB2YWx1ZSBtdXN0IG5vdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgKHVubGVzcyBmcmFtaW5nKSBvciBpZiBAdHlwZSBpc1xuICAvLyBAanNvblxuICBpZignQHZhbHVlJyBpbiBleHBhbmRlZFBhcmVudCkge1xuICAgIGlmKGV4cGFuZGVkUGFyZW50WydAdHlwZSddID09PSAnQGpzb24nICYmIF9wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSkpIHtcbiAgICAgIC8vIGFsbG93IGFueSB2YWx1ZSwgdG8gYmUgdmVyaWZpZWQgd2hlbiB0aGUgb2JqZWN0IGlzIGZ1bGx5IGV4cGFuZGVkIGFuZFxuICAgICAgLy8gdGhlIEB0eXBlIGlzIEBqc29uLlxuICAgIH0gZWxzZSBpZigoX2lzT2JqZWN0KHVuZXhwYW5kZWRWYWx1ZSkgfHwgX2lzQXJyYXkodW5leHBhbmRlZFZhbHVlKSkgJiZcbiAgICAgICFvcHRpb25zLmlzRnJhbWUpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQHZhbHVlXCIgdmFsdWUgbXVzdCBub3QgYmUgYW4gJyArXG4gICAgICAgICdvYmplY3Qgb3IgYW4gYXJyYXkuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB2YWx1ZSBvYmplY3QgdmFsdWUnLCB2YWx1ZTogdW5leHBhbmRlZFZhbHVlfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwYW5kIGVhY2ggbmVzdGVkIGtleVxuICBmb3IoY29uc3Qga2V5IG9mIG5lc3RzKSB7XG4gICAgY29uc3QgbmVzdGVkVmFsdWVzID0gX2lzQXJyYXkoZWxlbWVudFtrZXldKSA/IGVsZW1lbnRba2V5XSA6IFtlbGVtZW50W2tleV1dO1xuICAgIGZvcihjb25zdCBudiBvZiBuZXN0ZWRWYWx1ZXMpIHtcbiAgICAgIGlmKCFfaXNPYmplY3QobnYpIHx8IE9iamVjdC5rZXlzKG52KS5zb21lKGsgPT5cbiAgICAgICAgX2V4cGFuZElyaShhY3RpdmVDdHgsIGssIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpID09PSAnQHZhbHVlJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBuZXN0ZWQgdmFsdWUgbXVzdCBiZSBhIG5vZGUgb2JqZWN0LicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIEBuZXN0IHZhbHVlJywgdmFsdWU6IG52fSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBfZXhwYW5kT2JqZWN0KHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZWxlbWVudDogbnYsXG4gICAgICAgIGV4cGFuZGVkUGFyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpbnNpZGVMaXN0LFxuICAgICAgICB0eXBlU2NvcGVkQ29udGV4dCxcbiAgICAgICAgdHlwZUtleSxcbiAgICAgICAgZXhwYW5zaW9uTWFwfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhwYW5kcyB0aGUgZ2l2ZW4gdmFsdWUgYnkgdXNpbmcgdGhlIGNvZXJjaW9uIGFuZCBrZXl3b3JkIHJ1bGVzIGluIHRoZVxuICogZ2l2ZW4gY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBhY3RpdmUgY29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0gYWN0aXZlUHJvcGVydHkgdGhlIGFjdGl2ZSBwcm9wZXJ0eSB0aGUgdmFsdWUgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBleHBhbmQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcHJvY2Vzc2luZyBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBfZXhwYW5kVmFsdWUoe2FjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHZhbHVlLCBvcHRpb25zfSkge1xuICAvLyBub3RoaW5nIHRvIGV4cGFuZFxuICBpZih2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBzcGVjaWFsLWNhc2UgZXhwYW5kIEBpZCBhbmQgQHR5cGUgKHNraXBzICdAaWQnIGV4cGFuc2lvbilcbiAgY29uc3QgZXhwYW5kZWRQcm9wZXJ0eSA9IF9leHBhbmRJcmkoXG4gICAgYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucyk7XG4gIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAaWQnKSB7XG4gICAgcmV0dXJuIF9leHBhbmRJcmkoYWN0aXZlQ3R4LCB2YWx1ZSwge2Jhc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAdHlwZScpIHtcbiAgICByZXR1cm4gX2V4cGFuZElyaShhY3RpdmVDdHgsIHZhbHVlLCB7dm9jYWI6IHRydWUsIGJhc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGdldCB0eXBlIGRlZmluaXRpb24gZnJvbSBjb250ZXh0XG4gIGNvbnN0IHR5cGUgPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAdHlwZScpO1xuXG4gIC8vIGRvIEBpZCBleHBhbnNpb24gKGF1dG9tYXRpYyBmb3IgQGdyYXBoKVxuICBpZigodHlwZSA9PT0gJ0BpZCcgfHwgZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BncmFwaCcpICYmIF9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4geydAaWQnOiBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgdmFsdWUsIHtiYXNlOiB0cnVlfSwgb3B0aW9ucyl9O1xuICB9XG4gIC8vIGRvIEBpZCBleHBhbnNpb24gdy92b2NhYlxuICBpZih0eXBlID09PSAnQHZvY2FiJyAmJiBfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdAaWQnOiBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgdmFsdWUsIHt2b2NhYjogdHJ1ZSwgYmFzZTogdHJ1ZX0sIG9wdGlvbnMpXG4gICAgfTtcbiAgfVxuXG4gIC8vIGRvIG5vdCBleHBhbmQga2V5d29yZCB2YWx1ZXNcbiAgaWYoX2lzS2V5d29yZChleHBhbmRlZFByb3BlcnR5KSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IHJ2YWwgPSB7fTtcblxuICBpZih0eXBlICYmICFbJ0BpZCcsICdAdm9jYWInLCAnQG5vbmUnXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgIC8vIG90aGVyIHR5cGVcbiAgICBydmFsWydAdHlwZSddID0gdHlwZTtcbiAgfSBlbHNlIGlmKF9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAvLyBjaGVjayBmb3IgbGFuZ3VhZ2UgdGFnZ2luZyBmb3Igc3RyaW5nc1xuICAgIGNvbnN0IGxhbmd1YWdlID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGxhbmd1YWdlJyk7XG4gICAgaWYobGFuZ3VhZ2UgIT09IG51bGwpIHtcbiAgICAgIHJ2YWxbJ0BsYW5ndWFnZSddID0gbGFuZ3VhZ2U7XG4gICAgfVxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0BkaXJlY3Rpb24nKTtcbiAgICBpZihkaXJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIHJ2YWxbJ0BkaXJlY3Rpb24nXSA9IGRpcmVjdGlvbjtcbiAgICB9XG4gIH1cbiAgLy8gZG8gY29udmVyc2lvbiBvZiB2YWx1ZXMgdGhhdCBhcmVuJ3QgYmFzaWMgSlNPTiB0eXBlcyB0byBzdHJpbmdzXG4gIGlmKCFbJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcnZhbFsnQHZhbHVlJ10gPSB2YWx1ZTtcblxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBFeHBhbmRzIGEgbGFuZ3VhZ2UgbWFwLlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGFjdGl2ZSBjb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSBsYW5ndWFnZU1hcCB0aGUgbGFuZ3VhZ2UgbWFwIHRvIGV4cGFuZC5cbiAqIEBwYXJhbSBkaXJlY3Rpb24gdGhlIGRpcmVjdGlvbiB0byBhcHBseSB0byB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcHJvY2Vzc2luZyBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIGxhbmd1YWdlIG1hcC5cbiAqL1xuZnVuY3Rpb24gX2V4cGFuZExhbmd1YWdlTWFwKGFjdGl2ZUN0eCwgbGFuZ3VhZ2VNYXAsIGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICBjb25zdCBydmFsID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsYW5ndWFnZU1hcCkuc29ydCgpO1xuICBmb3IoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBleHBhbmRlZEtleSA9IF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBrZXksIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgIGxldCB2YWwgPSBsYW5ndWFnZU1hcFtrZXldO1xuICAgIGlmKCFfaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwgPSBbdmFsXTtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGl0ZW0gb2YgdmFsKSB7XG4gICAgICBpZihpdGVtID09PSBudWxsKSB7XG4gICAgICAgIC8vIG51bGwgdmFsdWVzIGFyZSBhbGxvd2VkICg4LjUpIGJ1dCBpZ25vcmVkICgzLjEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYoIV9pc1N0cmluZyhpdGVtKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGxhbmd1YWdlIG1hcCB2YWx1ZXMgbXVzdCBiZSBzdHJpbmdzLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGxhbmd1YWdlIG1hcCB2YWx1ZScsIGxhbmd1YWdlTWFwfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWwgPSB7J0B2YWx1ZSc6IGl0ZW19O1xuICAgICAgaWYoZXhwYW5kZWRLZXkgIT09ICdAbm9uZScpIHtcbiAgICAgICAgdmFsWydAbGFuZ3VhZ2UnXSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgaWYoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhbFsnQGRpcmVjdGlvbiddID0gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfZXhwYW5kSW5kZXhNYXAoXG4gIHthY3RpdmVDdHgsIG9wdGlvbnMsIGFjdGl2ZVByb3BlcnR5LCB2YWx1ZSwgZXhwYW5zaW9uTWFwLCBhc0dyYXBoLFxuICAgIGluZGV4S2V5LCBwcm9wZXJ0eUluZGV4fSkge1xuICBjb25zdCBydmFsID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgpO1xuICBjb25zdCBpc1R5cGVJbmRleCA9IGluZGV4S2V5ID09PSAnQHR5cGUnO1xuICBmb3IobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgLy8gaWYgaW5kZXhLZXkgaXMgQHR5cGUsIHRoZXJlIG1heSBiZSBhIGNvbnRleHQgZGVmaW5lZCBmb3IgaXRcbiAgICBpZihpc1R5cGVJbmRleCkge1xuICAgICAgY29uc3QgY3R4ID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGtleSwgJ0Bjb250ZXh0Jyk7XG4gICAgICBpZighX2lzVW5kZWZpbmVkKGN0eCkpIHtcbiAgICAgICAgYWN0aXZlQ3R4ID0gYXdhaXQgX3Byb2Nlc3NDb250ZXh0KHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgbG9jYWxDdHg6IGN0eCxcbiAgICAgICAgICBwcm9wYWdhdGU6IGZhbHNlLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHZhbCA9IHZhbHVlW2tleV07XG4gICAgaWYoIV9pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbCA9IFt2YWxdO1xuICAgIH1cblxuICAgIHZhbCA9IGF3YWl0IGFwaS5leHBhbmQoe1xuICAgICAgYWN0aXZlQ3R4LFxuICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICBlbGVtZW50OiB2YWwsXG4gICAgICBvcHRpb25zLFxuICAgICAgaW5zaWRlTGlzdDogZmFsc2UsXG4gICAgICBpbnNpZGVJbmRleDogdHJ1ZSxcbiAgICAgIGV4cGFuc2lvbk1hcFxuICAgIH0pO1xuXG4gICAgLy8gZXhwYW5kIGZvciBAdHlwZSwgYnV0IGFsc28gZm9yIEBub25lXG4gICAgbGV0IGV4cGFuZGVkS2V5O1xuICAgIGlmKHByb3BlcnR5SW5kZXgpIHtcbiAgICAgIGlmKGtleSA9PT0gJ0Bub25lJykge1xuICAgICAgICBleHBhbmRlZEtleSA9ICdAbm9uZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHBhbmRlZEtleSA9IF9leHBhbmRWYWx1ZShcbiAgICAgICAgICB7YWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eTogaW5kZXhLZXksIHZhbHVlOiBrZXksIG9wdGlvbnN9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXhwYW5kZWRLZXkgPSBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwga2V5LCB7dm9jYWI6IHRydWV9LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZihpbmRleEtleSA9PT0gJ0BpZCcpIHtcbiAgICAgIC8vIGV4cGFuZCBkb2N1bWVudCByZWxhdGl2ZVxuICAgICAga2V5ID0gX2V4cGFuZElyaShhY3RpdmVDdHgsIGtleSwge2Jhc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYoaXNUeXBlSW5kZXgpIHtcbiAgICAgIGtleSA9IGV4cGFuZGVkS2V5O1xuICAgIH1cblxuICAgIGZvcihsZXQgaXRlbSBvZiB2YWwpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYWxzbyBhIEBncmFwaCBjb250YWluZXIsIHR1cm4gaXRlbXMgaW50byBncmFwaHNcbiAgICAgIGlmKGFzR3JhcGggJiYgIV9pc0dyYXBoKGl0ZW0pKSB7XG4gICAgICAgIGl0ZW0gPSB7J0BncmFwaCc6IFtpdGVtXX07XG4gICAgICB9XG4gICAgICBpZihpbmRleEtleSA9PT0gJ0B0eXBlJykge1xuICAgICAgICBpZihleHBhbmRlZEtleSA9PT0gJ0Bub25lJykge1xuICAgICAgICAgIC8vIGlnbm9yZSBAbm9uZVxuICAgICAgICB9IGVsc2UgaWYoaXRlbVsnQHR5cGUnXSkge1xuICAgICAgICAgIGl0ZW1bJ0B0eXBlJ10gPSBba2V5XS5jb25jYXQoaXRlbVsnQHR5cGUnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsnQHR5cGUnXSA9IFtrZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoX2lzVmFsdWUoaXRlbSkgJiZcbiAgICAgICAgIVsnQGxhbmd1YWdlJywgJ0B0eXBlJywgJ0BpbmRleCddLmluY2x1ZGVzKGluZGV4S2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEF0dGVtcHQgdG8gYWRkIGlsbGVnYWwga2V5IHRvIHZhbHVlICcgK1xuICAgICAgICAgIGBvYmplY3Q6IFwiJHtpbmRleEtleX1cIi5gLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCB2YWx1ZSBvYmplY3QnLCB2YWx1ZTogaXRlbX0pO1xuICAgICAgfSBlbHNlIGlmKHByb3BlcnR5SW5kZXgpIHtcbiAgICAgICAgLy8gaW5kZXggaXMgYSBwcm9wZXJ0eSB0byBiZSBleHBhbmRlZCwgYW5kIHZhbHVlcyBpbnRlcnByZXRlZCBmb3IgdGhhdFxuICAgICAgICAvLyBwcm9wZXJ0eVxuICAgICAgICBpZihleHBhbmRlZEtleSAhPT0gJ0Bub25lJykge1xuICAgICAgICAgIC8vIGV4cGFuZCBrZXkgYXMgYSB2YWx1ZVxuICAgICAgICAgIF9hZGRWYWx1ZShpdGVtLCBwcm9wZXJ0eUluZGV4LCBleHBhbmRlZEtleSwge1xuICAgICAgICAgICAgcHJvcGVydHlJc0FycmF5OiB0cnVlLFxuICAgICAgICAgICAgcHJlcGVuZFZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihleHBhbmRlZEtleSAhPT0gJ0Bub25lJyAmJiAhKGluZGV4S2V5IGluIGl0ZW0pKSB7XG4gICAgICAgIGl0ZW1baW5kZXhLZXldID0ga2V5O1xuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG4gIGlzU3ViamVjdFJlZmVyZW5jZTogX2lzU3ViamVjdFJlZmVyZW5jZVxufSA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuXG5jb25zdCB7XG4gIGNyZWF0ZU1lcmdlZE5vZGVNYXA6IF9jcmVhdGVNZXJnZWROb2RlTWFwXG59ID0gcmVxdWlyZSgnLi9ub2RlTWFwJyk7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8qKlxuICogUGVyZm9ybXMgSlNPTi1MRCBmbGF0dGVuaW5nLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgZXhwYW5kZWQgSlNPTi1MRCB0byBmbGF0dGVuLlxuICpcbiAqIEByZXR1cm4gdGhlIGZsYXR0ZW5lZCBvdXRwdXQuXG4gKi9cbmFwaS5mbGF0dGVuID0gaW5wdXQgPT4ge1xuICBjb25zdCBkZWZhdWx0R3JhcGggPSBfY3JlYXRlTWVyZ2VkTm9kZU1hcChpbnB1dCk7XG5cbiAgLy8gcHJvZHVjZSBmbGF0dGVuZWQgb3V0cHV0XG4gIGNvbnN0IGZsYXR0ZW5lZCA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdEdyYXBoKS5zb3J0KCk7XG4gIGZvcihsZXQga2kgPSAwOyBraSA8IGtleXMubGVuZ3RoOyArK2tpKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRlZmF1bHRHcmFwaFtrZXlzW2tpXV07XG4gICAgLy8gb25seSBhZGQgZnVsbCBzdWJqZWN0cyB0byB0b3AtbGV2ZWxcbiAgICBpZighX2lzU3ViamVjdFJlZmVyZW5jZShub2RlKSkge1xuICAgICAgZmxhdHRlbmVkLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmbGF0dGVuZWQ7XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtpc0tleXdvcmR9ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG5jb25zdCBncmFwaFR5cGVzID0gcmVxdWlyZSgnLi9ncmFwaFR5cGVzJyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcbmNvbnN0IHtcbiAgY3JlYXRlTm9kZU1hcDogX2NyZWF0ZU5vZGVNYXAsXG4gIG1lcmdlTm9kZU1hcEdyYXBoczogX21lcmdlTm9kZU1hcEdyYXBoc1xufSA9IHJlcXVpcmUoJy4vbm9kZU1hcCcpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIFBlcmZvcm1zIEpTT04tTEQgYG1lcmdlZGAgZnJhbWluZy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGV4cGFuZGVkIEpTT04tTEQgdG8gZnJhbWUuXG4gKiBAcGFyYW0gZnJhbWUgdGhlIGV4cGFuZGVkIEpTT04tTEQgZnJhbWUgdG8gdXNlLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIGZyYW1pbmcgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBmcmFtZWQgb3V0cHV0LlxuICovXG5hcGkuZnJhbWVNZXJnZWRPckRlZmF1bHQgPSAoaW5wdXQsIGZyYW1lLCBvcHRpb25zKSA9PiB7XG4gIC8vIGNyZWF0ZSBmcmFtaW5nIHN0YXRlXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIG9wdGlvbnMsXG4gICAgZW1iZWRkZWQ6IGZhbHNlLFxuICAgIGdyYXBoOiAnQGRlZmF1bHQnLFxuICAgIGdyYXBoTWFwOiB7J0BkZWZhdWx0Jzoge319LFxuICAgIHN1YmplY3RTdGFjazogW10sXG4gICAgbGluazoge30sXG4gICAgYm5vZGVNYXA6IHt9XG4gIH07XG5cbiAgLy8gcHJvZHVjZSBhIG1hcCBvZiBhbGwgZ3JhcGhzIGFuZCBuYW1lIGVhY2ggYm5vZGVcbiAgLy8gRklYTUU6IGN1cnJlbnRseSB1c2VzIHN1YmplY3RzIGZyb20gQG1lcmdlZCBncmFwaCBvbmx5XG4gIGNvbnN0IGlzc3VlciA9IG5ldyB1dGlsLklkZW50aWZpZXJJc3N1ZXIoJ186YicpO1xuICBfY3JlYXRlTm9kZU1hcChpbnB1dCwgc3RhdGUuZ3JhcGhNYXAsICdAZGVmYXVsdCcsIGlzc3Vlcik7XG4gIGlmKG9wdGlvbnMubWVyZ2VkKSB7XG4gICAgc3RhdGUuZ3JhcGhNYXBbJ0BtZXJnZWQnXSA9IF9tZXJnZU5vZGVNYXBHcmFwaHMoc3RhdGUuZ3JhcGhNYXApO1xuICAgIHN0YXRlLmdyYXBoID0gJ0BtZXJnZWQnO1xuICB9XG4gIHN0YXRlLnN1YmplY3RzID0gc3RhdGUuZ3JhcGhNYXBbc3RhdGUuZ3JhcGhdO1xuXG4gIC8vIGZyYW1lIHRoZSBzdWJqZWN0c1xuICBjb25zdCBmcmFtZWQgPSBbXTtcbiAgYXBpLmZyYW1lKHN0YXRlLCBPYmplY3Qua2V5cyhzdGF0ZS5zdWJqZWN0cykuc29ydCgpLCBmcmFtZSwgZnJhbWVkKTtcblxuICAvLyBJZiBwcnVuaW5nIGJsYW5rIG5vZGVzLCBmaW5kIHRob3NlIHRvIHBydW5lXG4gIGlmKG9wdGlvbnMucHJ1bmVCbGFua05vZGVJZGVudGlmaWVycykge1xuICAgIC8vIHJlbW92ZSBhbGwgYmxhbmsgbm9kZXMgYXBwZWFyaW5nIG9ubHkgb25jZSwgZG9uZSBpbiBjb21wYWN0aW9uXG4gICAgb3B0aW9ucy5ibm9kZXNUb0NsZWFyID1cbiAgICAgIE9iamVjdC5rZXlzKHN0YXRlLmJub2RlTWFwKS5maWx0ZXIoaWQgPT4gc3RhdGUuYm5vZGVNYXBbaWRdLmxlbmd0aCA9PT0gMSk7XG4gIH1cblxuICAvLyByZW1vdmUgQHByZXNlcnZlIGZyb20gcmVzdWx0c1xuICBvcHRpb25zLmxpbmsgPSB7fTtcbiAgcmV0dXJuIF9jbGVhbnVwUHJlc2VydmUoZnJhbWVkLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRnJhbWVzIHN1YmplY3RzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZnJhbWUuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBjdXJyZW50IGZyYW1pbmcgc3RhdGUuXG4gKiBAcGFyYW0gc3ViamVjdHMgdGhlIHN1YmplY3RzIHRvIGZpbHRlci5cbiAqIEBwYXJhbSBmcmFtZSB0aGUgZnJhbWUuXG4gKiBAcGFyYW0gcGFyZW50IHRoZSBwYXJlbnQgc3ViamVjdCBvciB0b3AtbGV2ZWwgYXJyYXkuXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHBhcmVudCBwcm9wZXJ0eSwgaW5pdGlhbGl6ZWQgdG8gbnVsbC5cbiAqL1xuYXBpLmZyYW1lID0gKHN0YXRlLCBzdWJqZWN0cywgZnJhbWUsIHBhcmVudCwgcHJvcGVydHkgPSBudWxsKSA9PiB7XG4gIC8vIHZhbGlkYXRlIHRoZSBmcmFtZVxuICBfdmFsaWRhdGVGcmFtZShmcmFtZSk7XG4gIGZyYW1lID0gZnJhbWVbMF07XG5cbiAgLy8gZ2V0IGZsYWdzIGZvciBjdXJyZW50IGZyYW1lXG4gIGNvbnN0IG9wdGlvbnMgPSBzdGF0ZS5vcHRpb25zO1xuICBjb25zdCBmbGFncyA9IHtcbiAgICBlbWJlZDogX2dldEZyYW1lRmxhZyhmcmFtZSwgb3B0aW9ucywgJ2VtYmVkJyksXG4gICAgZXhwbGljaXQ6IF9nZXRGcmFtZUZsYWcoZnJhbWUsIG9wdGlvbnMsICdleHBsaWNpdCcpLFxuICAgIHJlcXVpcmVBbGw6IF9nZXRGcmFtZUZsYWcoZnJhbWUsIG9wdGlvbnMsICdyZXF1aXJlQWxsJylcbiAgfTtcblxuICAvLyBnZXQgbGluayBmb3IgY3VycmVudCBncmFwaFxuICBpZighc3RhdGUubGluay5oYXNPd25Qcm9wZXJ0eShzdGF0ZS5ncmFwaCkpIHtcbiAgICBzdGF0ZS5saW5rW3N0YXRlLmdyYXBoXSA9IHt9O1xuICB9XG4gIGNvbnN0IGxpbmsgPSBzdGF0ZS5saW5rW3N0YXRlLmdyYXBoXTtcblxuICAvLyBmaWx0ZXIgb3V0IHN1YmplY3RzIHRoYXQgbWF0Y2ggdGhlIGZyYW1lXG4gIGNvbnN0IG1hdGNoZXMgPSBfZmlsdGVyU3ViamVjdHMoc3RhdGUsIHN1YmplY3RzLCBmcmFtZSwgZmxhZ3MpO1xuXG4gIC8vIGFkZCBtYXRjaGVzIHRvIG91dHB1dFxuICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5zb3J0KCk7XG4gIGZvcihjb25zdCBpZCBvZiBpZHMpIHtcbiAgICBjb25zdCBzdWJqZWN0ID0gbWF0Y2hlc1tpZF07XG5cbiAgICAvKiBOb3RlOiBJbiBvcmRlciB0byB0cmVhdCBlYWNoIHRvcC1sZXZlbCBtYXRjaCBhcyBhIGNvbXBhcnRtZW50YWxpemVkXG4gICAgcmVzdWx0LCBjbGVhciB0aGUgdW5pcXVlIGVtYmVkZGVkIHN1YmplY3RzIG1hcCB3aGVuIHRoZSBwcm9wZXJ0eSBpcyBudWxsLFxuICAgIHdoaWNoIG9ubHkgb2NjdXJzIGF0IHRoZSB0b3AtbGV2ZWwuICovXG4gICAgaWYocHJvcGVydHkgPT09IG51bGwpIHtcbiAgICAgIHN0YXRlLnVuaXF1ZUVtYmVkcyA9IHtbc3RhdGUuZ3JhcGhdOiB7fX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnVuaXF1ZUVtYmVkc1tzdGF0ZS5ncmFwaF0gPSBzdGF0ZS51bmlxdWVFbWJlZHNbc3RhdGUuZ3JhcGhdIHx8IHt9O1xuICAgIH1cblxuICAgIGlmKGZsYWdzLmVtYmVkID09PSAnQGxpbmsnICYmIGlkIGluIGxpbmspIHtcbiAgICAgIC8vIFRPRE86IG1heSB3YW50IHRvIGFsc28gbWF0Y2ggYW4gZXhpc3RpbmcgbGlua2VkIHN1YmplY3QgYWdhaW5zdFxuICAgICAgLy8gdGhlIGN1cnJlbnQgZnJhbWUgLi4uIHNvIGRpZmZlcmVudCBmcmFtZXMgY291bGQgcHJvZHVjZSBkaWZmZXJlbnRcbiAgICAgIC8vIHN1YmplY3RzIHRoYXQgYXJlIG9ubHkgc2hhcmVkIGluLW1lbW9yeSB3aGVuIHRoZSBmcmFtZXMgYXJlIHRoZSBzYW1lXG5cbiAgICAgIC8vIGFkZCBleGlzdGluZyBsaW5rZWQgc3ViamVjdFxuICAgICAgX2FkZEZyYW1lT3V0cHV0KHBhcmVudCwgcHJvcGVydHksIGxpbmtbaWRdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IG91dHB1dCBmb3Igc3ViamVjdFxuICAgIGNvbnN0IG91dHB1dCA9IHsnQGlkJzogaWR9O1xuICAgIGlmKGlkLmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgIHV0aWwuYWRkVmFsdWUoc3RhdGUuYm5vZGVNYXAsIGlkLCBvdXRwdXQsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgICB9XG4gICAgbGlua1tpZF0gPSBvdXRwdXQ7XG5cbiAgICAvLyB2YWxpZGF0ZSBAZW1iZWRcbiAgICBpZigoZmxhZ3MuZW1iZWQgPT09ICdAZmlyc3QnIHx8IGZsYWdzLmVtYmVkID09PSAnQGxhc3QnKSAmJiBzdGF0ZS5pczExKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBpbnZhbGlkIHZhbHVlIG9mIEBlbWJlZC4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIEBlbWJlZCB2YWx1ZScsIGZyYW1lfSk7XG4gICAgfVxuXG4gICAgaWYoIXN0YXRlLmVtYmVkZGVkICYmIHN0YXRlLnVuaXF1ZUVtYmVkc1tzdGF0ZS5ncmFwaF0uaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAvLyBza2lwIGFkZGluZyB0aGlzIG5vZGUgb2JqZWN0IHRvIHRoZSB0b3AgbGV2ZWwsIGFzIGl0IHdhc1xuICAgICAgLy8gYWxyZWFkeSBpbmNsdWRlZCBpbiBhbm90aGVyIG5vZGUgb2JqZWN0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBlbWJlZCBpcyBAbmV2ZXIgb3IgaWYgYSBjaXJjdWxhciByZWZlcmVuY2Ugd291bGQgYmUgY3JlYXRlZCBieSBhblxuICAgIC8vIGVtYmVkLCB0aGUgc3ViamVjdCBjYW5ub3QgYmUgZW1iZWRkZWQsIGp1c3QgYWRkIHRoZSByZWZlcmVuY2U7XG4gICAgLy8gbm90ZSB0aGF0IGEgY2lyY3VsYXIgcmVmZXJlbmNlIHdvbid0IG9jY3VyIHdoZW4gdGhlIGVtYmVkIGZsYWcgaXNcbiAgICAvLyBgQGxpbmtgIGFzIHRoZSBhYm92ZSBjaGVjayB3aWxsIHNob3J0LWNpcmN1aXQgYmVmb3JlIHJlYWNoaW5nIHRoaXMgcG9pbnRcbiAgICBpZihzdGF0ZS5lbWJlZGRlZCAmJlxuICAgICAgKGZsYWdzLmVtYmVkID09PSAnQG5ldmVyJyB8fFxuICAgICAgX2NyZWF0ZXNDaXJjdWxhclJlZmVyZW5jZShzdWJqZWN0LCBzdGF0ZS5ncmFwaCwgc3RhdGUuc3ViamVjdFN0YWNrKSkpIHtcbiAgICAgIF9hZGRGcmFtZU91dHB1dChwYXJlbnQsIHByb3BlcnR5LCBvdXRwdXQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaWYgb25seSB0aGUgZmlyc3QgKG9yIG9uY2UpIHNob3VsZCBiZSBlbWJlZGRlZFxuICAgIGlmKHN0YXRlLmVtYmVkZGVkICYmXG4gICAgICAgKGZsYWdzLmVtYmVkID09ICdAZmlyc3QnIHx8IGZsYWdzLmVtYmVkID09ICdAb25jZScpICYmXG4gICAgICAgc3RhdGUudW5pcXVlRW1iZWRzW3N0YXRlLmdyYXBoXS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIF9hZGRGcmFtZU91dHB1dChwYXJlbnQsIHByb3BlcnR5LCBvdXRwdXQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaWYgb25seSB0aGUgbGFzdCBtYXRjaCBzaG91bGQgYmUgZW1iZWRkZWRcbiAgICBpZihmbGFncy5lbWJlZCA9PT0gJ0BsYXN0Jykge1xuICAgICAgLy8gcmVtb3ZlIGFueSBleGlzdGluZyBlbWJlZFxuICAgICAgaWYoaWQgaW4gc3RhdGUudW5pcXVlRW1iZWRzW3N0YXRlLmdyYXBoXSkge1xuICAgICAgICBfcmVtb3ZlRW1iZWQoc3RhdGUsIGlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS51bmlxdWVFbWJlZHNbc3RhdGUuZ3JhcGhdW2lkXSA9IHtwYXJlbnQsIHByb3BlcnR5fTtcblxuICAgIC8vIHB1c2ggbWF0Y2hpbmcgc3ViamVjdCBvbnRvIHN0YWNrIHRvIGVuYWJsZSBjaXJjdWxhciBlbWJlZCBjaGVja3NcbiAgICBzdGF0ZS5zdWJqZWN0U3RhY2sucHVzaCh7c3ViamVjdCwgZ3JhcGg6IHN0YXRlLmdyYXBofSk7XG5cbiAgICAvLyBzdWJqZWN0IGlzIGFsc28gdGhlIG5hbWUgb2YgYSBncmFwaFxuICAgIGlmKGlkIGluIHN0YXRlLmdyYXBoTWFwKSB7XG4gICAgICBsZXQgcmVjdXJzZSA9IGZhbHNlO1xuICAgICAgbGV0IHN1YmZyYW1lID0gbnVsbDtcbiAgICAgIGlmKCEoJ0BncmFwaCcgaW4gZnJhbWUpKSB7XG4gICAgICAgIHJlY3Vyc2UgPSBzdGF0ZS5ncmFwaCAhPT0gJ0BtZXJnZWQnO1xuICAgICAgICBzdWJmcmFtZSA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViZnJhbWUgPSBmcmFtZVsnQGdyYXBoJ11bMF07XG4gICAgICAgIHJlY3Vyc2UgPSAhKGlkID09PSAnQG1lcmdlZCcgfHwgaWQgPT09ICdAZGVmYXVsdCcpO1xuICAgICAgICBpZighdHlwZXMuaXNPYmplY3Qoc3ViZnJhbWUpKSB7XG4gICAgICAgICAgc3ViZnJhbWUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihyZWN1cnNlKSB7XG4gICAgICAgIC8vIHJlY3Vyc2UgaW50byBncmFwaFxuICAgICAgICBhcGkuZnJhbWUoXG4gICAgICAgICAgey4uLnN0YXRlLCBncmFwaDogaWQsIGVtYmVkZGVkOiBmYWxzZX0sXG4gICAgICAgICAgT2JqZWN0LmtleXMoc3RhdGUuZ3JhcGhNYXBbaWRdKS5zb3J0KCksIFtzdWJmcmFtZV0sIG91dHB1dCwgJ0BncmFwaCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGZyYW1lIGhhcyBAaW5jbHVkZWQsIHJlY3Vyc2Ugb3ZlciBpdHMgc3ViLWZyYW1lXG4gICAgaWYoJ0BpbmNsdWRlZCcgaW4gZnJhbWUpIHtcbiAgICAgIGFwaS5mcmFtZShcbiAgICAgICAgey4uLnN0YXRlLCBlbWJlZGRlZDogZmFsc2V9LFxuICAgICAgICBzdWJqZWN0cywgZnJhbWVbJ0BpbmNsdWRlZCddLCBvdXRwdXQsICdAaW5jbHVkZWQnKTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgc3ViamVjdCBwcm9wZXJ0aWVzXG4gICAgZm9yKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMoc3ViamVjdCkuc29ydCgpKSB7XG4gICAgICAvLyBjb3B5IGtleXdvcmRzIHRvIG91dHB1dFxuICAgICAgaWYoaXNLZXl3b3JkKHByb3ApKSB7XG4gICAgICAgIG91dHB1dFtwcm9wXSA9IHV0aWwuY2xvbmUoc3ViamVjdFtwcm9wXSk7XG5cbiAgICAgICAgaWYocHJvcCA9PT0gJ0B0eXBlJykge1xuICAgICAgICAgIC8vIGNvdW50IGJub2RlIHZhbHVlcyBvZiBAdHlwZVxuICAgICAgICAgIGZvcihjb25zdCB0eXBlIG9mIHN1YmplY3RbJ0B0eXBlJ10pIHtcbiAgICAgICAgICAgIGlmKHR5cGUuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgICAgICAgICB1dGlsLmFkZFZhbHVlKFxuICAgICAgICAgICAgICAgIHN0YXRlLmJub2RlTWFwLCB0eXBlLCBvdXRwdXQsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGV4cGxpY2l0IGlzIG9uIGFuZCBwcm9wZXJ0eSBpc24ndCBpbiB0aGUgZnJhbWUsIHNraXAgcHJvY2Vzc2luZ1xuICAgICAgaWYoZmxhZ3MuZXhwbGljaXQgJiYgIShwcm9wIGluIGZyYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIG9iamVjdHNcbiAgICAgIGZvcihjb25zdCBvIG9mIHN1YmplY3RbcHJvcF0pIHtcbiAgICAgICAgY29uc3Qgc3ViZnJhbWUgPSAocHJvcCBpbiBmcmFtZSA/XG4gICAgICAgICAgZnJhbWVbcHJvcF0gOiBfY3JlYXRlSW1wbGljaXRGcmFtZShmbGFncykpO1xuXG4gICAgICAgIC8vIHJlY3Vyc2UgaW50byBsaXN0XG4gICAgICAgIGlmKGdyYXBoVHlwZXMuaXNMaXN0KG8pKSB7XG4gICAgICAgICAgY29uc3Qgc3ViZnJhbWUgPVxuICAgICAgICAgICAgKGZyYW1lW3Byb3BdICYmIGZyYW1lW3Byb3BdWzBdICYmIGZyYW1lW3Byb3BdWzBdWydAbGlzdCddKSA/XG4gICAgICAgICAgICAgIGZyYW1lW3Byb3BdWzBdWydAbGlzdCddIDpcbiAgICAgICAgICAgICAgX2NyZWF0ZUltcGxpY2l0RnJhbWUoZmxhZ3MpO1xuXG4gICAgICAgICAgLy8gYWRkIGVtcHR5IGxpc3RcbiAgICAgICAgICBjb25zdCBsaXN0ID0geydAbGlzdCc6IFtdfTtcbiAgICAgICAgICBfYWRkRnJhbWVPdXRwdXQob3V0cHV0LCBwcm9wLCBsaXN0KTtcblxuICAgICAgICAgIC8vIGFkZCBsaXN0IG9iamVjdHNcbiAgICAgICAgICBjb25zdCBzcmMgPSBvWydAbGlzdCddO1xuICAgICAgICAgIGZvcihjb25zdCBvbyBvZiBzcmMpIHtcbiAgICAgICAgICAgIGlmKGdyYXBoVHlwZXMuaXNTdWJqZWN0UmVmZXJlbmNlKG9vKSkge1xuICAgICAgICAgICAgICAvLyByZWN1cnNlIGludG8gc3ViamVjdCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgYXBpLmZyYW1lKFxuICAgICAgICAgICAgICAgIHsuLi5zdGF0ZSwgZW1iZWRkZWQ6IHRydWV9LFxuICAgICAgICAgICAgICAgIFtvb1snQGlkJ11dLCBzdWJmcmFtZSwgbGlzdCwgJ0BsaXN0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpbmNsdWRlIG90aGVyIHZhbHVlcyBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgIF9hZGRGcmFtZU91dHB1dChsaXN0LCAnQGxpc3QnLCB1dGlsLmNsb25lKG9vKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2UobykpIHtcbiAgICAgICAgICAvLyByZWN1cnNlIGludG8gc3ViamVjdCByZWZlcmVuY2VcbiAgICAgICAgICBhcGkuZnJhbWUoXG4gICAgICAgICAgICB7Li4uc3RhdGUsIGVtYmVkZGVkOiB0cnVlfSxcbiAgICAgICAgICAgIFtvWydAaWQnXV0sIHN1YmZyYW1lLCBvdXRwdXQsIHByb3ApO1xuICAgICAgICB9IGVsc2UgaWYoX3ZhbHVlTWF0Y2goc3ViZnJhbWVbMF0sIG8pKSB7XG4gICAgICAgICAgLy8gaW5jbHVkZSBvdGhlciB2YWx1ZXMsIGlmIHRoZXkgbWF0Y2hcbiAgICAgICAgICBfYWRkRnJhbWVPdXRwdXQob3V0cHV0LCBwcm9wLCB1dGlsLmNsb25lKG8pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBkZWZhdWx0c1xuICAgIGZvcihjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKGZyYW1lKS5zb3J0KCkpIHtcbiAgICAgIC8vIHNraXAga2V5d29yZHNcbiAgICAgIGlmKHByb3AgPT09ICdAdHlwZScpIHtcbiAgICAgICAgaWYoIXR5cGVzLmlzT2JqZWN0KGZyYW1lW3Byb3BdWzBdKSB8fFxuICAgICAgICAgICAhKCdAZGVmYXVsdCcgaW4gZnJhbWVbcHJvcF1bMF0pKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgdGhyb3VnaCBkZWZhdWx0IHR5cGVzXG4gICAgICB9IGVsc2UgaWYoaXNLZXl3b3JkKHByb3ApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBvbWl0IGRlZmF1bHQgaXMgb2ZmLCB0aGVuIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHByb3BlcnRpZXNcbiAgICAgIC8vIHRoYXQgYXBwZWFyIGluIHRoZSBuZXh0IGZyYW1lIGJ1dCBhcmUgbm90IGluIHRoZSBtYXRjaGluZyBzdWJqZWN0XG4gICAgICBjb25zdCBuZXh0ID0gZnJhbWVbcHJvcF1bMF0gfHwge307XG4gICAgICBjb25zdCBvbWl0RGVmYXVsdE9uID0gX2dldEZyYW1lRmxhZyhuZXh0LCBvcHRpb25zLCAnb21pdERlZmF1bHQnKTtcbiAgICAgIGlmKCFvbWl0RGVmYXVsdE9uICYmICEocHJvcCBpbiBvdXRwdXQpKSB7XG4gICAgICAgIGxldCBwcmVzZXJ2ZSA9ICdAbnVsbCc7XG4gICAgICAgIGlmKCdAZGVmYXVsdCcgaW4gbmV4dCkge1xuICAgICAgICAgIHByZXNlcnZlID0gdXRpbC5jbG9uZShuZXh0WydAZGVmYXVsdCddKTtcbiAgICAgICAgfVxuICAgICAgICBpZighdHlwZXMuaXNBcnJheShwcmVzZXJ2ZSkpIHtcbiAgICAgICAgICBwcmVzZXJ2ZSA9IFtwcmVzZXJ2ZV07XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0W3Byb3BdID0gW3snQHByZXNlcnZlJzogcHJlc2VydmV9XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBlbWJlZCByZXZlcnNlIHZhbHVlcyBieSBmaW5kaW5nIG5vZGVzIGhhdmluZyB0aGlzIHN1YmplY3QgYXMgYSB2YWx1ZVxuICAgIC8vIG9mIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5XG4gICAgZm9yKGNvbnN0IHJldmVyc2VQcm9wIG9mIE9iamVjdC5rZXlzKGZyYW1lWydAcmV2ZXJzZSddIHx8IHt9KS5zb3J0KCkpIHtcbiAgICAgIGNvbnN0IHN1YmZyYW1lID0gZnJhbWVbJ0ByZXZlcnNlJ11bcmV2ZXJzZVByb3BdO1xuICAgICAgZm9yKGNvbnN0IHN1YmplY3Qgb2YgT2JqZWN0LmtleXMoc3RhdGUuc3ViamVjdHMpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVWYWx1ZXMgPVxuICAgICAgICAgIHV0aWwuZ2V0VmFsdWVzKHN0YXRlLnN1YmplY3RzW3N1YmplY3RdLCByZXZlcnNlUHJvcCk7XG4gICAgICAgIGlmKG5vZGVWYWx1ZXMuc29tZSh2ID0+IHZbJ0BpZCddID09PSBpZCkpIHtcbiAgICAgICAgICAvLyBub2RlIGhhcyBwcm9wZXJ0eSByZWZlcmVuY2luZyB0aGlzIHN1YmplY3QsIHJlY3Vyc2VcbiAgICAgICAgICBvdXRwdXRbJ0ByZXZlcnNlJ10gPSBvdXRwdXRbJ0ByZXZlcnNlJ10gfHwge307XG4gICAgICAgICAgdXRpbC5hZGRWYWx1ZShcbiAgICAgICAgICAgIG91dHB1dFsnQHJldmVyc2UnXSwgcmV2ZXJzZVByb3AsIFtdLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICAgICAgYXBpLmZyYW1lKFxuICAgICAgICAgICAgey4uLnN0YXRlLCBlbWJlZGRlZDogdHJ1ZX0sXG4gICAgICAgICAgICBbc3ViamVjdF0sIHN1YmZyYW1lLCBvdXRwdXRbJ0ByZXZlcnNlJ11bcmV2ZXJzZVByb3BdLFxuICAgICAgICAgICAgcHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIG91dHB1dCB0byBwYXJlbnRcbiAgICBfYWRkRnJhbWVPdXRwdXQocGFyZW50LCBwcm9wZXJ0eSwgb3V0cHV0KTtcblxuICAgIC8vIHBvcCBtYXRjaGluZyBzdWJqZWN0IGZyb20gY2lyY3VsYXIgcmVmLWNoZWNraW5nIHN0YWNrXG4gICAgc3RhdGUuc3ViamVjdFN0YWNrLnBvcCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYEBudWxsYCB3aXRoIGBudWxsYCwgcmVtb3ZpbmcgaXQgZnJvbSBhcnJheXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBmcmFtZWQsIGNvbXBhY3RlZCBvdXRwdXQuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgZnJhbWluZyBvcHRpb25zIHVzZWQuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIG91dHB1dC5cbiAqL1xuYXBpLmNsZWFudXBOdWxsID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIC8vIHJlY3Vyc2UgdGhyb3VnaCBhcnJheXNcbiAgaWYodHlwZXMuaXNBcnJheShpbnB1dCkpIHtcbiAgICBjb25zdCBub051bGxzID0gaW5wdXQubWFwKHYgPT4gYXBpLmNsZWFudXBOdWxsKHYsIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gbm9OdWxscy5maWx0ZXIodiA9PiB2KTsgLy8gcmVtb3ZlcyBudWxscyBmcm9tIGFycmF5XG4gIH1cblxuICBpZihpbnB1dCA9PT0gJ0BudWxsJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYodHlwZXMuaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgLy8gaGFuZGxlIGluLW1lbW9yeSBsaW5rZWQgbm9kZXNcbiAgICBpZignQGlkJyBpbiBpbnB1dCkge1xuICAgICAgY29uc3QgaWQgPSBpbnB1dFsnQGlkJ107XG4gICAgICBpZihvcHRpb25zLmxpbmsuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IG9wdGlvbnMubGlua1tpZF0uaW5kZXhPZihpbnB1dCk7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBhbHJlYWR5IHZpc2l0ZWRcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5saW5rW2lkXVtpZHhdO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgY2lyY3VsYXIgdmlzaXRhdGlvblxuICAgICAgICBvcHRpb25zLmxpbmtbaWRdLnB1c2goaW5wdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHJldmVudCBjaXJjdWxhciB2aXNpdGF0aW9uXG4gICAgICAgIG9wdGlvbnMubGlua1tpZF0gPSBbaW5wdXRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvcihjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgIGlucHV0W2tleV0gPSBhcGkuY2xlYW51cE51bGwoaW5wdXRba2V5XSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbXBsaWNpdCBmcmFtZSB3aGVuIHJlY3Vyc2luZyB0aHJvdWdoIHN1YmplY3QgbWF0Y2hlcy4gSWZcbiAqIGEgZnJhbWUgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGZyYW1lIGZvciBhIHBhcnRpY3VsYXIgcHJvcGVydHksIHRoZW5cbiAqIGEgd2lsZGNhcmQgY2hpbGQgZnJhbWUgd2lsbCBiZSBjcmVhdGVkIHRoYXQgdXNlcyB0aGUgc2FtZSBmbGFncyB0aGF0IHRoZVxuICogcGFyZW50IGZyYW1lIHVzZWQuXG4gKlxuICogQHBhcmFtIGZsYWdzIHRoZSBjdXJyZW50IGZyYW1pbmcgZmxhZ3MuXG4gKlxuICogQHJldHVybiB0aGUgaW1wbGljaXQgZnJhbWUuXG4gKi9cbmZ1bmN0aW9uIF9jcmVhdGVJbXBsaWNpdEZyYW1lKGZsYWdzKSB7XG4gIGNvbnN0IGZyYW1lID0ge307XG4gIGZvcihjb25zdCBrZXkgaW4gZmxhZ3MpIHtcbiAgICBpZihmbGFnc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyYW1lWydAJyArIGtleV0gPSBbZmxhZ3Nba2V5XV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbZnJhbWVdO1xufVxuXG4vKipcbiAqIENoZWNrcyB0aGUgY3VycmVudCBzdWJqZWN0IHN0YWNrIHRvIHNlZSBpZiBlbWJlZGRpbmcgdGhlIGdpdmVuIHN1YmplY3RcbiAqIHdvdWxkIGNhdXNlIGEgY2lyY3VsYXIgcmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSBzdWJqZWN0VG9FbWJlZCB0aGUgc3ViamVjdCB0byBlbWJlZC5cbiAqIEBwYXJhbSBncmFwaCB0aGUgZ3JhcGggdGhlIHN1YmplY3QgdG8gZW1iZWQgaXMgaW4uXG4gKiBAcGFyYW0gc3ViamVjdFN0YWNrIHRoZSBjdXJyZW50IHN0YWNrIG9mIHN1YmplY3RzLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBhIGNpcmN1bGFyIHJlZmVyZW5jZSB3b3VsZCBiZSBjcmVhdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9jcmVhdGVzQ2lyY3VsYXJSZWZlcmVuY2Uoc3ViamVjdFRvRW1iZWQsIGdyYXBoLCBzdWJqZWN0U3RhY2spIHtcbiAgZm9yKGxldCBpID0gc3ViamVjdFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3Qgc3ViamVjdCA9IHN1YmplY3RTdGFja1tpXTtcbiAgICBpZihzdWJqZWN0LmdyYXBoID09PSBncmFwaCAmJlxuICAgICAgc3ViamVjdC5zdWJqZWN0WydAaWQnXSA9PT0gc3ViamVjdFRvRW1iZWRbJ0BpZCddKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGZyYW1lIGZsYWcgdmFsdWUgZm9yIHRoZSBnaXZlbiBmbGFnIG5hbWUuXG4gKlxuICogQHBhcmFtIGZyYW1lIHRoZSBmcmFtZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBmcmFtaW5nIG9wdGlvbnMuXG4gKiBAcGFyYW0gbmFtZSB0aGUgZmxhZyBuYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGZsYWcgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIF9nZXRGcmFtZUZsYWcoZnJhbWUsIG9wdGlvbnMsIG5hbWUpIHtcbiAgY29uc3QgZmxhZyA9ICdAJyArIG5hbWU7XG4gIGxldCBydmFsID0gKGZsYWcgaW4gZnJhbWUgPyBmcmFtZVtmbGFnXVswXSA6IG9wdGlvbnNbbmFtZV0pO1xuICBpZihuYW1lID09PSAnZW1iZWQnKSB7XG4gICAgLy8gZGVmYXVsdCBpcyBcIkBsYXN0XCJcbiAgICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBzdXBwb3J0IGZvciBcImVtYmVkXCIgbWFwczpcbiAgICAvLyB0cnVlID0+IFwiQGxhc3RcIlxuICAgIC8vIGZhbHNlID0+IFwiQG5ldmVyXCJcbiAgICBpZihydmFsID09PSB0cnVlKSB7XG4gICAgICBydmFsID0gJ0BvbmNlJztcbiAgICB9IGVsc2UgaWYocnZhbCA9PT0gZmFsc2UpIHtcbiAgICAgIHJ2YWwgPSAnQG5ldmVyJztcbiAgICB9IGVsc2UgaWYocnZhbCAhPT0gJ0BhbHdheXMnICYmIHJ2YWwgIT09ICdAbmV2ZXInICYmIHJ2YWwgIT09ICdAbGluaycgJiZcbiAgICAgIHJ2YWwgIT09ICdAZmlyc3QnICYmIHJ2YWwgIT09ICdAbGFzdCcgJiYgcnZhbCAhPT0gJ0BvbmNlJykge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgaW52YWxpZCB2YWx1ZSBvZiBAZW1iZWQuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAZW1iZWQgdmFsdWUnLCBmcmFtZX0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBKU09OLUxEIGZyYW1lLCB0aHJvd2luZyBhbiBleGNlcHRpb24gaWYgdGhlIGZyYW1lIGlzIGludmFsaWQuXG4gKlxuICogQHBhcmFtIGZyYW1lIHRoZSBmcmFtZSB0byB2YWxpZGF0ZS5cbiAqL1xuZnVuY3Rpb24gX3ZhbGlkYXRlRnJhbWUoZnJhbWUpIHtcbiAgaWYoIXR5cGVzLmlzQXJyYXkoZnJhbWUpIHx8IGZyYW1lLmxlbmd0aCAhPT0gMSB8fCAhdHlwZXMuaXNPYmplY3QoZnJhbWVbMF0pKSB7XG4gICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEgSlNPTi1MRCBmcmFtZSBtdXN0IGJlIGEgc2luZ2xlIG9iamVjdC4nLFxuICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtmcmFtZX0pO1xuICB9XG5cbiAgaWYoJ0BpZCcgaW4gZnJhbWVbMF0pIHtcbiAgICBmb3IoY29uc3QgaWQgb2YgdXRpbC5hc0FycmF5KGZyYW1lWzBdWydAaWQnXSkpIHtcbiAgICAgIC8vIEBpZCBtdXN0IGJlIHdpbGRjYXJkIG9yIGFuIElSSVxuICAgICAgaWYoISh0eXBlcy5pc09iamVjdChpZCkgfHwgdXJsLmlzQWJzb2x1dGUoaWQpKSB8fFxuICAgICAgICAodHlwZXMuaXNTdHJpbmcoaWQpICYmIGlkLmluZGV4T2YoJ186JykgPT09IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgaW52YWxpZCBAaWQgaW4gZnJhbWUuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIGZyYW1lJywgZnJhbWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZignQHR5cGUnIGluIGZyYW1lWzBdKSB7XG4gICAgZm9yKGNvbnN0IHR5cGUgb2YgdXRpbC5hc0FycmF5KGZyYW1lWzBdWydAdHlwZSddKSkge1xuICAgICAgLy8gQGlkIG11c3QgYmUgd2lsZGNhcmQgb3IgYW4gSVJJXG4gICAgICBpZighKHR5cGVzLmlzT2JqZWN0KHR5cGUpIHx8IHVybC5pc0Fic29sdXRlKHR5cGUpKSB8fFxuICAgICAgICAodHlwZXMuaXNTdHJpbmcodHlwZSkgJiYgdHlwZS5pbmRleE9mKCdfOicpID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGludmFsaWQgQHR5cGUgaW4gZnJhbWUuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIGZyYW1lJywgZnJhbWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbWFwIG9mIGFsbCBvZiB0aGUgc3ViamVjdHMgdGhhdCBtYXRjaCBhIHBhcnNlZCBmcmFtZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGN1cnJlbnQgZnJhbWluZyBzdGF0ZS5cbiAqIEBwYXJhbSBzdWJqZWN0cyB0aGUgc2V0IG9mIHN1YmplY3RzIHRvIGZpbHRlci5cbiAqIEBwYXJhbSBmcmFtZSB0aGUgcGFyc2VkIGZyYW1lLlxuICogQHBhcmFtIGZsYWdzIHRoZSBmcmFtZSBmbGFncy5cbiAqXG4gKiBAcmV0dXJuIGFsbCBvZiB0aGUgbWF0Y2hlZCBzdWJqZWN0cy5cbiAqL1xuZnVuY3Rpb24gX2ZpbHRlclN1YmplY3RzKHN0YXRlLCBzdWJqZWN0cywgZnJhbWUsIGZsYWdzKSB7XG4gIC8vIGZpbHRlciBzdWJqZWN0cyBpbiBAaWQgb3JkZXJcbiAgY29uc3QgcnZhbCA9IHt9O1xuICBmb3IoY29uc3QgaWQgb2Ygc3ViamVjdHMpIHtcbiAgICBjb25zdCBzdWJqZWN0ID0gc3RhdGUuZ3JhcGhNYXBbc3RhdGUuZ3JhcGhdW2lkXTtcbiAgICBpZihfZmlsdGVyU3ViamVjdChzdGF0ZSwgc3ViamVjdCwgZnJhbWUsIGZsYWdzKSkge1xuICAgICAgcnZhbFtpZF0gPSBzdWJqZWN0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN1YmplY3QgbWF0Y2hlcyB0aGUgZ2l2ZW4gZnJhbWUuXG4gKlxuICogTWF0Y2hlcyBlaXRoZXIgYmFzZWQgb24gZXhwbGljaXQgdHlwZSBpbmNsdXNpb24gd2hlcmUgdGhlIG5vZGUgaGFzIGFueVxuICogdHlwZSBsaXN0ZWQgaW4gdGhlIGZyYW1lLiBJZiB0aGUgZnJhbWUgaGFzIGVtcHR5IHR5cGVzIGRlZmluZWQgbWF0Y2hlc1xuICogbm9kZXMgbm90IGhhdmluZyBhIEB0eXBlLiBJZiB0aGUgZnJhbWUgaGFzIGEgdHlwZSBvZiB7fSBkZWZpbmVkIG1hdGNoZXNcbiAqIG5vZGVzIGhhdmluZyBhbnkgdHlwZSBkZWZpbmVkLlxuICpcbiAqIE90aGVyd2lzZSwgZG9lcyBkdWNrIHR5cGluZywgd2hlcmUgdGhlIG5vZGUgbXVzdCBoYXZlIGFsbCBvZiB0aGVcbiAqIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgZnJhbWUuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBjdXJyZW50IGZyYW1pbmcgc3RhdGUuXG4gKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBmcmFtZSB0aGUgZnJhbWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gZmxhZ3MgdGhlIGZyYW1lIGZsYWdzLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgc3ViamVjdCBtYXRjaGVzLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9maWx0ZXJTdWJqZWN0KHN0YXRlLCBzdWJqZWN0LCBmcmFtZSwgZmxhZ3MpIHtcbiAgLy8gY2hlY2sgZHVja3R5cGVcbiAgbGV0IHdpbGRjYXJkID0gdHJ1ZTtcbiAgbGV0IG1hdGNoZXNTb21lID0gZmFsc2U7XG5cbiAgZm9yKGNvbnN0IGtleSBpbiBmcmFtZSkge1xuICAgIGxldCBtYXRjaFRoaXMgPSBmYWxzZTtcbiAgICBjb25zdCBub2RlVmFsdWVzID0gdXRpbC5nZXRWYWx1ZXMoc3ViamVjdCwga2V5KTtcbiAgICBjb25zdCBpc0VtcHR5ID0gdXRpbC5nZXRWYWx1ZXMoZnJhbWUsIGtleSkubGVuZ3RoID09PSAwO1xuXG4gICAgaWYoa2V5ID09PSAnQGlkJykge1xuICAgICAgLy8gbWF0Y2ggb24gbm8gQGlkIG9yIGFueSBtYXRjaGluZyBAaWQsIGluY2x1ZGluZyB3aWxkY2FyZFxuICAgICAgaWYodHlwZXMuaXNFbXB0eU9iamVjdChmcmFtZVsnQGlkJ11bMF0gfHwge30pKSB7XG4gICAgICAgIG1hdGNoVGhpcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYoZnJhbWVbJ0BpZCddLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgIG1hdGNoVGhpcyA9IGZyYW1lWydAaWQnXS5pbmNsdWRlcyhub2RlVmFsdWVzWzBdKTtcbiAgICAgIH1cbiAgICAgIGlmKCFmbGFncy5yZXF1aXJlQWxsKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFRoaXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGtleSA9PT0gJ0B0eXBlJykge1xuICAgICAgLy8gY2hlY2sgQHR5cGUgKG9iamVjdCB2YWx1ZSBtZWFucyAnYW55JyB0eXBlLFxuICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIGR1Y2t0eXBpbmcpXG4gICAgICB3aWxkY2FyZCA9IGZhbHNlO1xuICAgICAgaWYoaXNFbXB0eSkge1xuICAgICAgICBpZihub2RlVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBkb24ndCBtYXRjaCBvbiBubyBAdHlwZVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaFRoaXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmKGZyYW1lWydAdHlwZSddLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICB0eXBlcy5pc0VtcHR5T2JqZWN0KGZyYW1lWydAdHlwZSddWzBdKSkge1xuICAgICAgICAvLyBtYXRjaCBvbiB3aWxkY2FyZCBAdHlwZSBpZiB0aGVyZSBpcyBhIHR5cGVcbiAgICAgICAgbWF0Y2hUaGlzID0gbm9kZVZhbHVlcy5sZW5ndGggPiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWF0Y2ggb24gYSBzcGVjaWZpYyBAdHlwZVxuICAgICAgICBmb3IoY29uc3QgdHlwZSBvZiBmcmFtZVsnQHR5cGUnXSkge1xuICAgICAgICAgIGlmKHR5cGVzLmlzT2JqZWN0KHR5cGUpICYmICdAZGVmYXVsdCcgaW4gdHlwZSkge1xuICAgICAgICAgICAgLy8gbWF0Y2ggb24gZGVmYXVsdCBvYmplY3RcbiAgICAgICAgICAgIG1hdGNoVGhpcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoVGhpcyA9IG1hdGNoVGhpcyB8fCBub2RlVmFsdWVzLnNvbWUodHQgPT4gdHQgPT09IHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoIWZsYWdzLnJlcXVpcmVBbGwpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoVGhpcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoaXNLZXl3b3JkKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3JjZSBhIGNvcHkgb2YgdGhpcyBmcmFtZSBlbnRyeSBzbyBpdCBjYW4gYmUgbWFuaXB1bGF0ZWRcbiAgICAgIGNvbnN0IHRoaXNGcmFtZSA9IHV0aWwuZ2V0VmFsdWVzKGZyYW1lLCBrZXkpWzBdO1xuICAgICAgbGV0IGhhc0RlZmF1bHQgPSBmYWxzZTtcbiAgICAgIGlmKHRoaXNGcmFtZSkge1xuICAgICAgICBfdmFsaWRhdGVGcmFtZShbdGhpc0ZyYW1lXSk7XG4gICAgICAgIGhhc0RlZmF1bHQgPSAnQGRlZmF1bHQnIGluIHRoaXNGcmFtZTtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gbG9uZ2VyIGEgd2lsZGNhcmQgcGF0dGVybiBpZiBmcmFtZSBoYXMgYW55IG5vbi1rZXl3b3JkIHByb3BlcnRpZXNcbiAgICAgIHdpbGRjYXJkID0gZmFsc2U7XG5cbiAgICAgIC8vIHNraXAsIGJ1dCBhbGxvdyBtYXRjaCBpZiBub2RlIGhhcyBubyB2YWx1ZSBmb3IgcHJvcGVydHksIGFuZCBmcmFtZSBoYXNcbiAgICAgIC8vIGEgZGVmYXVsdCB2YWx1ZVxuICAgICAgaWYobm9kZVZhbHVlcy5sZW5ndGggPT09IDAgJiYgaGFzRGVmYXVsdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgZnJhbWUgdmFsdWUgaXMgZW1wdHksIGRvbid0IG1hdGNoIGlmIHN1YmplY3QgaGFzIGFueSB2YWx1ZVxuICAgICAgaWYobm9kZVZhbHVlcy5sZW5ndGggPiAwICYmIGlzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZih0aGlzRnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBub2RlIGRvZXMgbm90IG1hdGNoIGlmIHZhbHVlcyBpcyBub3QgZW1wdHkgYW5kIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eVxuICAgICAgICAvLyBpbiBmcmFtZSBpcyBtYXRjaCBub25lLlxuICAgICAgICBpZihub2RlVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hUaGlzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKGdyYXBoVHlwZXMuaXNMaXN0KHRoaXNGcmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBsaXN0VmFsdWUgPSB0aGlzRnJhbWVbJ0BsaXN0J11bMF07XG4gICAgICAgICAgaWYoZ3JhcGhUeXBlcy5pc0xpc3Qobm9kZVZhbHVlc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVMaXN0VmFsdWVzID0gbm9kZVZhbHVlc1swXVsnQGxpc3QnXTtcblxuICAgICAgICAgICAgaWYoZ3JhcGhUeXBlcy5pc1ZhbHVlKGxpc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgLy8gbWF0Y2ggb24gYW55IG1hdGNoaW5nIHZhbHVlXG4gICAgICAgICAgICAgIG1hdGNoVGhpcyA9IG5vZGVMaXN0VmFsdWVzLnNvbWUobHYgPT4gX3ZhbHVlTWF0Y2gobGlzdFZhbHVlLCBsdikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNTdWJqZWN0KGxpc3RWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2UobGlzdFZhbHVlKSkge1xuICAgICAgICAgICAgICBtYXRjaFRoaXMgPSBub2RlTGlzdFZhbHVlcy5zb21lKGx2ID0+IF9ub2RlTWF0Y2goXG4gICAgICAgICAgICAgICAgc3RhdGUsIGxpc3RWYWx1ZSwgbHYsIGZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc1ZhbHVlKHRoaXNGcmFtZSkpIHtcbiAgICAgICAgICBtYXRjaFRoaXMgPSBub2RlVmFsdWVzLnNvbWUobnYgPT4gX3ZhbHVlTWF0Y2godGhpc0ZyYW1lLCBudikpO1xuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2UodGhpc0ZyYW1lKSkge1xuICAgICAgICAgIG1hdGNoVGhpcyA9XG4gICAgICAgICAgICBub2RlVmFsdWVzLnNvbWUobnYgPT4gX25vZGVNYXRjaChzdGF0ZSwgdGhpc0ZyYW1lLCBudiwgZmxhZ3MpKTtcbiAgICAgICAgfSBlbHNlIGlmKHR5cGVzLmlzT2JqZWN0KHRoaXNGcmFtZSkpIHtcbiAgICAgICAgICBtYXRjaFRoaXMgPSBub2RlVmFsdWVzLmxlbmd0aCA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2hUaGlzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbm9uLWRlZmF1bHRlZCB2YWx1ZXMgbXVzdCBtYXRjaCBpZiByZXF1aXJlQWxsIGlzIHNldFxuICAgIGlmKCFtYXRjaFRoaXMgJiYgZmxhZ3MucmVxdWlyZUFsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1hdGNoZXNTb21lID0gbWF0Y2hlc1NvbWUgfHwgbWF0Y2hUaGlzO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRydWUgaWYgd2lsZGNhcmQgb3Igc3ViamVjdCBtYXRjaGVzIHNvbWUgcHJvcGVydGllc1xuICByZXR1cm4gd2lsZGNhcmQgfHwgbWF0Y2hlc1NvbWU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBleGlzdGluZyBlbWJlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGN1cnJlbnQgZnJhbWluZyBzdGF0ZS5cbiAqIEBwYXJhbSBpZCB0aGUgQGlkIG9mIHRoZSBlbWJlZCB0byByZW1vdmUuXG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVFbWJlZChzdGF0ZSwgaWQpIHtcbiAgLy8gZ2V0IGV4aXN0aW5nIGVtYmVkXG4gIGNvbnN0IGVtYmVkcyA9IHN0YXRlLnVuaXF1ZUVtYmVkc1tzdGF0ZS5ncmFwaF07XG4gIGNvbnN0IGVtYmVkID0gZW1iZWRzW2lkXTtcbiAgY29uc3QgcGFyZW50ID0gZW1iZWQucGFyZW50O1xuICBjb25zdCBwcm9wZXJ0eSA9IGVtYmVkLnByb3BlcnR5O1xuXG4gIC8vIGNyZWF0ZSByZWZlcmVuY2UgdG8gcmVwbGFjZSBlbWJlZFxuICBjb25zdCBzdWJqZWN0ID0geydAaWQnOiBpZH07XG5cbiAgLy8gcmVtb3ZlIGV4aXN0aW5nIGVtYmVkXG4gIGlmKHR5cGVzLmlzQXJyYXkocGFyZW50KSkge1xuICAgIC8vIHJlcGxhY2Ugc3ViamVjdCB3aXRoIHJlZmVyZW5jZVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJlbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKHV0aWwuY29tcGFyZVZhbHVlcyhwYXJlbnRbaV0sIHN1YmplY3QpKSB7XG4gICAgICAgIHBhcmVudFtpXSA9IHN1YmplY3Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyByZXBsYWNlIHN1YmplY3Qgd2l0aCByZWZlcmVuY2VcbiAgICBjb25zdCB1c2VBcnJheSA9IHR5cGVzLmlzQXJyYXkocGFyZW50W3Byb3BlcnR5XSk7XG4gICAgdXRpbC5yZW1vdmVWYWx1ZShwYXJlbnQsIHByb3BlcnR5LCBzdWJqZWN0LCB7cHJvcGVydHlJc0FycmF5OiB1c2VBcnJheX0pO1xuICAgIHV0aWwuYWRkVmFsdWUocGFyZW50LCBwcm9wZXJ0eSwgc3ViamVjdCwge3Byb3BlcnR5SXNBcnJheTogdXNlQXJyYXl9KTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2l2ZWx5IHJlbW92ZSBkZXBlbmRlbnQgZGFuZ2xpbmcgZW1iZWRzXG4gIGNvbnN0IHJlbW92ZURlcGVuZGVudHMgPSBpZCA9PiB7XG4gICAgLy8gZ2V0IGVtYmVkIGtleXMgYXMgYSBzZXBhcmF0ZSBhcnJheSB0byBlbmFibGUgZGVsZXRpbmcga2V5cyBpbiBtYXBcbiAgICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhlbWJlZHMpO1xuICAgIGZvcihjb25zdCBuZXh0IG9mIGlkcykge1xuICAgICAgaWYobmV4dCBpbiBlbWJlZHMgJiYgdHlwZXMuaXNPYmplY3QoZW1iZWRzW25leHRdLnBhcmVudCkgJiZcbiAgICAgICAgZW1iZWRzW25leHRdLnBhcmVudFsnQGlkJ10gPT09IGlkKSB7XG4gICAgICAgIGRlbGV0ZSBlbWJlZHNbbmV4dF07XG4gICAgICAgIHJlbW92ZURlcGVuZGVudHMobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZW1vdmVEZXBlbmRlbnRzKGlkKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBAcHJlc2VydmUga2V5d29yZHMgZnJvbSBleHBhbmRlZCByZXN1bHQgb2YgZnJhbWluZy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGZyYW1lZCwgZnJhbWVkIG91dHB1dC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBmcmFtaW5nIG9wdGlvbnMgdXNlZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBfY2xlYW51cFByZXNlcnZlKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIHJlY3Vyc2UgdGhyb3VnaCBhcnJheXNcbiAgaWYodHlwZXMuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQubWFwKHZhbHVlID0+IF9jbGVhbnVwUHJlc2VydmUodmFsdWUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIGlmKHR5cGVzLmlzT2JqZWN0KGlucHV0KSkge1xuICAgIC8vIHJlbW92ZSBAcHJlc2VydmVcbiAgICBpZignQHByZXNlcnZlJyBpbiBpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0WydAcHJlc2VydmUnXVswXTtcbiAgICB9XG5cbiAgICAvLyBza2lwIEB2YWx1ZXNcbiAgICBpZihncmFwaFR5cGVzLmlzVmFsdWUoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzZSB0aHJvdWdoIEBsaXN0c1xuICAgIGlmKGdyYXBoVHlwZXMuaXNMaXN0KGlucHV0KSkge1xuICAgICAgaW5wdXRbJ0BsaXN0J10gPSBfY2xlYW51cFByZXNlcnZlKGlucHV0WydAbGlzdCddLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgaW4tbWVtb3J5IGxpbmtlZCBub2Rlc1xuICAgIGlmKCdAaWQnIGluIGlucHV0KSB7XG4gICAgICBjb25zdCBpZCA9IGlucHV0WydAaWQnXTtcbiAgICAgIGlmKG9wdGlvbnMubGluay5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gb3B0aW9ucy5saW5rW2lkXS5pbmRleE9mKGlucHV0KTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIC8vIGFscmVhZHkgdmlzaXRlZFxuICAgICAgICAgIHJldHVybiBvcHRpb25zLmxpbmtbaWRdW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCBjaXJjdWxhciB2aXNpdGF0aW9uXG4gICAgICAgIG9wdGlvbnMubGlua1tpZF0ucHVzaChpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwcmV2ZW50IGNpcmN1bGFyIHZpc2l0YXRpb25cbiAgICAgICAgb3B0aW9ucy5saW5rW2lkXSA9IFtpbnB1dF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzZSB0aHJvdWdoIHByb3BlcnRpZXNcbiAgICBmb3IoY29uc3QgcHJvcCBpbiBpbnB1dCkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgcmVtb3ZlIHRoZSBpZCwgaWYgaXQgaXMgYW4gdW5yZWZlcmVuY2UgYm5vZGVcbiAgICAgIGlmKHByb3AgPT09ICdAaWQnICYmIG9wdGlvbnMuYm5vZGVzVG9DbGVhci5pbmNsdWRlcyhpbnB1dFtwcm9wXSkpIHtcbiAgICAgICAgZGVsZXRlIGlucHV0WydAaWQnXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlucHV0W3Byb3BdID0gX2NsZWFudXBQcmVzZXJ2ZShpbnB1dFtwcm9wXSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBBZGRzIGZyYW1pbmcgb3V0cHV0IHRvIHRoZSBnaXZlbiBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHBhcmVudCB0aGUgcGFyZW50IHRvIGFkZCB0by5cbiAqIEBwYXJhbSBwcm9wZXJ0eSB0aGUgcGFyZW50IHByb3BlcnR5LlxuICogQHBhcmFtIG91dHB1dCB0aGUgb3V0cHV0IHRvIGFkZC5cbiAqL1xuZnVuY3Rpb24gX2FkZEZyYW1lT3V0cHV0KHBhcmVudCwgcHJvcGVydHksIG91dHB1dCkge1xuICBpZih0eXBlcy5pc09iamVjdChwYXJlbnQpKSB7XG4gICAgdXRpbC5hZGRWYWx1ZShwYXJlbnQsIHByb3BlcnR5LCBvdXRwdXQsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQucHVzaChvdXRwdXQpO1xuICB9XG59XG5cbi8qKlxuICogTm9kZSBtYXRjaGVzIGlmIGl0IGlzIGEgbm9kZSwgYW5kIG1hdGNoZXMgdGhlIHBhdHRlcm4gYXMgYSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGN1cnJlbnQgZnJhbWluZyBzdGF0ZS5cbiAqIEBwYXJhbSBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2ggdmFsdWVcbiAqIEBwYXJhbSB2YWx1ZSB0byBjaGVja1xuICogQHBhcmFtIGZsYWdzIHRoZSBmcmFtZSBmbGFncy5cbiAqL1xuZnVuY3Rpb24gX25vZGVNYXRjaChzdGF0ZSwgcGF0dGVybiwgdmFsdWUsIGZsYWdzKSB7XG4gIGlmKCEoJ0BpZCcgaW4gdmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5vZGVPYmplY3QgPSBzdGF0ZS5zdWJqZWN0c1t2YWx1ZVsnQGlkJ11dO1xuICByZXR1cm4gbm9kZU9iamVjdCAmJiBfZmlsdGVyU3ViamVjdChzdGF0ZSwgbm9kZU9iamVjdCwgcGF0dGVybiwgZmxhZ3MpO1xufVxuXG4vKipcbiAqIFZhbHVlIG1hdGNoZXMgaWYgaXQgaXMgYSB2YWx1ZSBhbmQgbWF0Y2hlcyB0aGUgdmFsdWUgcGF0dGVyblxuICpcbiAqICogYHBhdHRlcm5gIGlzIGVtcHR5XG4gKiAqIEB2YWx1ZXMgYXJlIHRoZSBzYW1lLCBvciBgcGF0dGVybltAdmFsdWVdYCBpcyBhIHdpbGRjYXJkLCBhbmRcbiAqICogQHR5cGVzIGFyZSB0aGUgc2FtZSBvciBgdmFsdWVbQHR5cGVdYCBpcyBub3QgbnVsbFxuICogICBhbmQgYHBhdHRlcm5bQHR5cGVdYCBpcyBge31gLCBvciBgdmFsdWVbQHR5cGVdYCBpcyBudWxsXG4gKiAgIGFuZCBgcGF0dGVybltAdHlwZV1gIGlzIG51bGwgb3IgYFtdYCwgYW5kXG4gKiAqIEBsYW5ndWFnZXMgYXJlIHRoZSBzYW1lIG9yIGB2YWx1ZVtAbGFuZ3VhZ2VdYCBpcyBub3QgbnVsbFxuICogICBhbmQgYHBhdHRlcm5bQGxhbmd1YWdlXWAgaXMgYHt9YCwgb3IgYHZhbHVlW0BsYW5ndWFnZV1gIGlzIG51bGxcbiAqICAgYW5kIGBwYXR0ZXJuW0BsYW5ndWFnZV1gIGlzIG51bGwgb3IgYFtdYC5cbiAqXG4gKiBAcGFyYW0gcGF0dGVybiB1c2VkIHRvIG1hdGNoIHZhbHVlXG4gKiBAcGFyYW0gdmFsdWUgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gX3ZhbHVlTWF0Y2gocGF0dGVybiwgdmFsdWUpIHtcbiAgY29uc3QgdjEgPSB2YWx1ZVsnQHZhbHVlJ107XG4gIGNvbnN0IHQxID0gdmFsdWVbJ0B0eXBlJ107XG4gIGNvbnN0IGwxID0gdmFsdWVbJ0BsYW5ndWFnZSddO1xuICBjb25zdCB2MiA9IHBhdHRlcm5bJ0B2YWx1ZSddID9cbiAgICAodHlwZXMuaXNBcnJheShwYXR0ZXJuWydAdmFsdWUnXSkgP1xuICAgICAgcGF0dGVyblsnQHZhbHVlJ10gOiBbcGF0dGVyblsnQHZhbHVlJ11dKSA6XG4gICAgW107XG4gIGNvbnN0IHQyID0gcGF0dGVyblsnQHR5cGUnXSA/XG4gICAgKHR5cGVzLmlzQXJyYXkocGF0dGVyblsnQHR5cGUnXSkgP1xuICAgICAgcGF0dGVyblsnQHR5cGUnXSA6IFtwYXR0ZXJuWydAdHlwZSddXSkgOlxuICAgIFtdO1xuICBjb25zdCBsMiA9IHBhdHRlcm5bJ0BsYW5ndWFnZSddID9cbiAgICAodHlwZXMuaXNBcnJheShwYXR0ZXJuWydAbGFuZ3VhZ2UnXSkgP1xuICAgICAgcGF0dGVyblsnQGxhbmd1YWdlJ10gOiBbcGF0dGVyblsnQGxhbmd1YWdlJ11dKSA6XG4gICAgW107XG5cbiAgaWYodjIubGVuZ3RoID09PSAwICYmIHQyLmxlbmd0aCA9PT0gMCAmJiBsMi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZighKHYyLmluY2x1ZGVzKHYxKSB8fCB0eXBlcy5pc0VtcHR5T2JqZWN0KHYyWzBdKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYoISghdDEgJiYgdDIubGVuZ3RoID09PSAwIHx8IHQyLmluY2x1ZGVzKHQxKSB8fCB0MSAmJlxuICAgIHR5cGVzLmlzRW1wdHlPYmplY3QodDJbMF0pKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZighKCFsMSAmJiBsMi5sZW5ndGggPT09IDAgfHwgbDIuaW5jbHVkZXMobDEpIHx8IGwxICYmXG4gICAgdHlwZXMuaXNFbXB0eU9iamVjdChsMlswXSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEpzb25MZEVycm9yID0gcmVxdWlyZSgnLi9Kc29uTGRFcnJvcicpO1xuY29uc3QgZ3JhcGhUeXBlcyA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIGNvbnN0YW50c1xuY29uc3Qge1xuICAvLyBSREYsXG4gIFJERl9MSVNULFxuICBSREZfRklSU1QsXG4gIFJERl9SRVNULFxuICBSREZfTklMLFxuICBSREZfVFlQRSxcbiAgLy8gUkRGX1BMQUlOX0xJVEVSQUwsXG4gIC8vIFJERl9YTUxfTElURVJBTCxcbiAgUkRGX0pTT05fTElURVJBTCxcbiAgLy8gUkRGX09CSkVDVCxcbiAgLy8gUkRGX0xBTkdTVFJJTkcsXG5cbiAgLy8gWFNELFxuICBYU0RfQk9PTEVBTixcbiAgWFNEX0RPVUJMRSxcbiAgWFNEX0lOVEVHRVIsXG4gIFhTRF9TVFJJTkcsXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgUkVHRVhfQkNQNDcgPSAvXlthLXpBLVpdezEsOH0oLVthLXpBLVowLTldezEsOH0pKiQvO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJERiBkYXRhc2V0IHRvIEpTT04tTEQuXG4gKlxuICogQHBhcmFtIGRhdGFzZXQgdGhlIFJERiBkYXRhc2V0LlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIFJERiBzZXJpYWxpemF0aW9uIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgSlNPTi1MRCBvdXRwdXQuXG4gKi9cbmFwaS5mcm9tUkRGID0gYXN5bmMgKFxuICBkYXRhc2V0LFxuICB7XG4gICAgdXNlUmRmVHlwZSA9IGZhbHNlLFxuICAgIHVzZU5hdGl2ZVR5cGVzID0gZmFsc2UsXG4gICAgcmRmRGlyZWN0aW9uID0gbnVsbFxuICB9XG4pID0+IHtcbiAgY29uc3QgZGVmYXVsdEdyYXBoID0ge307XG4gIGNvbnN0IGdyYXBoTWFwID0geydAZGVmYXVsdCc6IGRlZmF1bHRHcmFwaH07XG4gIGNvbnN0IHJlZmVyZW5jZWRPbmNlID0ge307XG5cbiAgZm9yKGNvbnN0IHF1YWQgb2YgZGF0YXNldCkge1xuICAgIC8vIFRPRE86IGNoYW5nZSAnbmFtZScgdG8gJ2dyYXBoJ1xuICAgIGNvbnN0IG5hbWUgPSAocXVhZC5ncmFwaC50ZXJtVHlwZSA9PT0gJ0RlZmF1bHRHcmFwaCcpID9cbiAgICAgICdAZGVmYXVsdCcgOiBxdWFkLmdyYXBoLnZhbHVlO1xuICAgIGlmKCEobmFtZSBpbiBncmFwaE1hcCkpIHtcbiAgICAgIGdyYXBoTWFwW25hbWVdID0ge307XG4gICAgfVxuICAgIGlmKG5hbWUgIT09ICdAZGVmYXVsdCcgJiYgIShuYW1lIGluIGRlZmF1bHRHcmFwaCkpIHtcbiAgICAgIGRlZmF1bHRHcmFwaFtuYW1lXSA9IHsnQGlkJzogbmFtZX07XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZU1hcCA9IGdyYXBoTWFwW25hbWVdO1xuXG4gICAgLy8gZ2V0IHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0XG4gICAgY29uc3QgcyA9IHF1YWQuc3ViamVjdC52YWx1ZTtcbiAgICBjb25zdCBwID0gcXVhZC5wcmVkaWNhdGUudmFsdWU7XG4gICAgY29uc3QgbyA9IHF1YWQub2JqZWN0O1xuXG4gICAgaWYoIShzIGluIG5vZGVNYXApKSB7XG4gICAgICBub2RlTWFwW3NdID0geydAaWQnOiBzfTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXBbc107XG5cbiAgICBjb25zdCBvYmplY3RJc05vZGUgPSBvLnRlcm1UeXBlLmVuZHNXaXRoKCdOb2RlJyk7XG4gICAgaWYob2JqZWN0SXNOb2RlICYmICEoby52YWx1ZSBpbiBub2RlTWFwKSkge1xuICAgICAgbm9kZU1hcFtvLnZhbHVlXSA9IHsnQGlkJzogby52YWx1ZX07XG4gICAgfVxuXG4gICAgaWYocCA9PT0gUkRGX1RZUEUgJiYgIXVzZVJkZlR5cGUgJiYgb2JqZWN0SXNOb2RlKSB7XG4gICAgICB1dGlsLmFkZFZhbHVlKG5vZGUsICdAdHlwZScsIG8udmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gX1JERlRvT2JqZWN0KG8sIHVzZU5hdGl2ZVR5cGVzLCByZGZEaXJlY3Rpb24pO1xuICAgIHV0aWwuYWRkVmFsdWUobm9kZSwgcCwgdmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcblxuICAgIC8vIG9iamVjdCBtYXkgYmUgYW4gUkRGIGxpc3QvcGFydGlhbCBsaXN0IG5vZGUgYnV0IHdlIGNhbid0IGtub3cgZWFzaWx5XG4gICAgLy8gdW50aWwgYWxsIHRyaXBsZXMgYXJlIHJlYWRcbiAgICBpZihvYmplY3RJc05vZGUpIHtcbiAgICAgIGlmKG8udmFsdWUgPT09IFJERl9OSUwpIHtcbiAgICAgICAgLy8gdHJhY2sgcmRmOm5pbCB1bmlxdWVseSBwZXIgZ3JhcGhcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gbm9kZU1hcFtvLnZhbHVlXTtcbiAgICAgICAgaWYoISgndXNhZ2VzJyBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgb2JqZWN0LnVzYWdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC51c2FnZXMucHVzaCh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwcm9wZXJ0eTogcCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZihvLnZhbHVlIGluIHJlZmVyZW5jZWRPbmNlKSB7XG4gICAgICAgIC8vIG9iamVjdCByZWZlcmVuY2VkIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgIHJlZmVyZW5jZWRPbmNlW28udmFsdWVdID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHNpbmdsZSByZWZlcmVuY2VcbiAgICAgICAgcmVmZXJlbmNlZE9uY2Vbby52YWx1ZV0gPSB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwcm9wZXJ0eTogcCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gIGZvcihsZXQgbmFtZSBpbiBkYXRhc2V0KSB7XG4gICAgY29uc3QgZ3JhcGggPSBkYXRhc2V0W25hbWVdO1xuICAgIGlmKCEobmFtZSBpbiBncmFwaE1hcCkpIHtcbiAgICAgIGdyYXBoTWFwW25hbWVdID0ge307XG4gICAgfVxuICAgIGlmKG5hbWUgIT09ICdAZGVmYXVsdCcgJiYgIShuYW1lIGluIGRlZmF1bHRHcmFwaCkpIHtcbiAgICAgIGRlZmF1bHRHcmFwaFtuYW1lXSA9IHsnQGlkJzogbmFtZX07XG4gICAgfVxuICAgIGNvbnN0IG5vZGVNYXAgPSBncmFwaE1hcFtuYW1lXTtcbiAgICBmb3IobGV0IHRpID0gMDsgdGkgPCBncmFwaC5sZW5ndGg7ICsrdGkpIHtcbiAgICAgIGNvbnN0IHRyaXBsZSA9IGdyYXBoW3RpXTtcblxuICAgICAgLy8gZ2V0IHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0XG4gICAgICBjb25zdCBzID0gdHJpcGxlLnN1YmplY3QudmFsdWU7XG4gICAgICBjb25zdCBwID0gdHJpcGxlLnByZWRpY2F0ZS52YWx1ZTtcbiAgICAgIGNvbnN0IG8gPSB0cmlwbGUub2JqZWN0O1xuXG4gICAgICBpZighKHMgaW4gbm9kZU1hcCkpIHtcbiAgICAgICAgbm9kZU1hcFtzXSA9IHsnQGlkJzogc307XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gbm9kZU1hcFtzXTtcblxuICAgICAgY29uc3Qgb2JqZWN0SXNJZCA9IChvLnR5cGUgPT09ICdJUkknIHx8IG8udHlwZSA9PT0gJ2JsYW5rIG5vZGUnKTtcbiAgICAgIGlmKG9iamVjdElzSWQgJiYgIShvLnZhbHVlIGluIG5vZGVNYXApKSB7XG4gICAgICAgIG5vZGVNYXBbby52YWx1ZV0gPSB7J0BpZCc6IG8udmFsdWV9O1xuICAgICAgfVxuXG4gICAgICBpZihwID09PSBSREZfVFlQRSAmJiAhdXNlUmRmVHlwZSAmJiBvYmplY3RJc0lkKSB7XG4gICAgICAgIHV0aWwuYWRkVmFsdWUobm9kZSwgJ0B0eXBlJywgby52YWx1ZSwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWUgPSBfUkRGVG9PYmplY3QobywgdXNlTmF0aXZlVHlwZXMpO1xuICAgICAgdXRpbC5hZGRWYWx1ZShub2RlLCBwLCB2YWx1ZSwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuXG4gICAgICAvLyBvYmplY3QgbWF5IGJlIGFuIFJERiBsaXN0L3BhcnRpYWwgbGlzdCBub2RlIGJ1dCB3ZSBjYW4ndCBrbm93IGVhc2lseVxuICAgICAgLy8gdW50aWwgYWxsIHRyaXBsZXMgYXJlIHJlYWRcbiAgICAgIGlmKG9iamVjdElzSWQpIHtcbiAgICAgICAgaWYoby52YWx1ZSA9PT0gUkRGX05JTCkge1xuICAgICAgICAgIC8vIHRyYWNrIHJkZjpuaWwgdW5pcXVlbHkgcGVyIGdyYXBoXG4gICAgICAgICAgY29uc3Qgb2JqZWN0ID0gbm9kZU1hcFtvLnZhbHVlXTtcbiAgICAgICAgICBpZighKCd1c2FnZXMnIGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgIG9iamVjdC51c2FnZXMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0LnVzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICBwcm9wZXJ0eTogcCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYoby52YWx1ZSBpbiByZWZlcmVuY2VkT25jZSkge1xuICAgICAgICAgIC8vIG9iamVjdCByZWZlcmVuY2VkIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgICAgcmVmZXJlbmNlZE9uY2Vbby52YWx1ZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHNpbmdsZSByZWZlcmVuY2VcbiAgICAgICAgICByZWZlcmVuY2VkT25jZVtvLnZhbHVlXSA9IHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICBwcm9wZXJ0eTogcCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0qL1xuXG4gIC8vIGNvbnZlcnQgbGlua2VkIGxpc3RzIHRvIEBsaXN0IGFycmF5c1xuICBmb3IoY29uc3QgbmFtZSBpbiBncmFwaE1hcCkge1xuICAgIGNvbnN0IGdyYXBoT2JqZWN0ID0gZ3JhcGhNYXBbbmFtZV07XG5cbiAgICAvLyBubyBAbGlzdHMgdG8gYmUgY29udmVydGVkLCBjb250aW51ZVxuICAgIGlmKCEoUkRGX05JTCBpbiBncmFwaE9iamVjdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgYmFja3dhcmRzIHRocm91Z2ggZWFjaCBSREYgbGlzdFxuICAgIGNvbnN0IG5pbCA9IGdyYXBoT2JqZWN0W1JERl9OSUxdO1xuICAgIGlmKCFuaWwudXNhZ2VzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yKGxldCB1c2FnZSBvZiBuaWwudXNhZ2VzKSB7XG4gICAgICBsZXQgbm9kZSA9IHVzYWdlLm5vZGU7XG4gICAgICBsZXQgcHJvcGVydHkgPSB1c2FnZS5wcm9wZXJ0eTtcbiAgICAgIGxldCBoZWFkID0gdXNhZ2UudmFsdWU7XG4gICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICBjb25zdCBsaXN0Tm9kZXMgPSBbXTtcblxuICAgICAgLy8gZW5zdXJlIG5vZGUgaXMgYSB3ZWxsLWZvcm1lZCBsaXN0IG5vZGU7IGl0IG11c3Q6XG4gICAgICAvLyAxLiBCZSByZWZlcmVuY2VkIG9ubHkgb25jZS5cbiAgICAgIC8vIDIuIEhhdmUgYW4gYXJyYXkgZm9yIHJkZjpmaXJzdCB0aGF0IGhhcyAxIGl0ZW0uXG4gICAgICAvLyAzLiBIYXZlIGFuIGFycmF5IGZvciByZGY6cmVzdCB0aGF0IGhhcyAxIGl0ZW0uXG4gICAgICAvLyA0LiBIYXZlIG5vIGtleXMgb3RoZXIgdGhhbjogQGlkLCByZGY6Zmlyc3QsIHJkZjpyZXN0LCBhbmQsXG4gICAgICAvLyAgIG9wdGlvbmFsbHksIEB0eXBlIHdoZXJlIHRoZSB2YWx1ZSBpcyByZGY6TGlzdC5cbiAgICAgIGxldCBub2RlS2V5Q291bnQgPSBPYmplY3Qua2V5cyhub2RlKS5sZW5ndGg7XG4gICAgICB3aGlsZShwcm9wZXJ0eSA9PT0gUkRGX1JFU1QgJiZcbiAgICAgICAgdHlwZXMuaXNPYmplY3QocmVmZXJlbmNlZE9uY2Vbbm9kZVsnQGlkJ11dKSAmJlxuICAgICAgICB0eXBlcy5pc0FycmF5KG5vZGVbUkRGX0ZJUlNUXSkgJiYgbm9kZVtSREZfRklSU1RdLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICB0eXBlcy5pc0FycmF5KG5vZGVbUkRGX1JFU1RdKSAmJiBub2RlW1JERl9SRVNUXS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgKG5vZGVLZXlDb3VudCA9PT0gMyB8fFxuICAgICAgICAgIChub2RlS2V5Q291bnQgPT09IDQgJiYgdHlwZXMuaXNBcnJheShub2RlWydAdHlwZSddKSAmJlxuICAgICAgICAgIG5vZGVbJ0B0eXBlJ10ubGVuZ3RoID09PSAxICYmIG5vZGVbJ0B0eXBlJ11bMF0gPT09IFJERl9MSVNUKSkpIHtcbiAgICAgICAgbGlzdC5wdXNoKG5vZGVbUkRGX0ZJUlNUXVswXSk7XG4gICAgICAgIGxpc3ROb2Rlcy5wdXNoKG5vZGVbJ0BpZCddKTtcblxuICAgICAgICAvLyBnZXQgbmV4dCBub2RlLCBtb3ZpbmcgYmFja3dhcmRzIHRocm91Z2ggbGlzdFxuICAgICAgICB1c2FnZSA9IHJlZmVyZW5jZWRPbmNlW25vZGVbJ0BpZCddXTtcbiAgICAgICAgbm9kZSA9IHVzYWdlLm5vZGU7XG4gICAgICAgIHByb3BlcnR5ID0gdXNhZ2UucHJvcGVydHk7XG4gICAgICAgIGhlYWQgPSB1c2FnZS52YWx1ZTtcbiAgICAgICAgbm9kZUtleUNvdW50ID0gT2JqZWN0LmtleXMobm9kZSkubGVuZ3RoO1xuXG4gICAgICAgIC8vIGlmIG5vZGUgaXMgbm90IGEgYmxhbmsgbm9kZSwgdGhlbiBsaXN0IGhlYWQgZm91bmRcbiAgICAgICAgaWYoIWdyYXBoVHlwZXMuaXNCbGFua05vZGUobm9kZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmFuc2Zvcm0gbGlzdCBpbnRvIEBsaXN0IG9iamVjdFxuICAgICAgZGVsZXRlIGhlYWRbJ0BpZCddO1xuICAgICAgaGVhZFsnQGxpc3QnXSA9IGxpc3QucmV2ZXJzZSgpO1xuICAgICAgZm9yKGNvbnN0IGxpc3ROb2RlIG9mIGxpc3ROb2Rlcykge1xuICAgICAgICBkZWxldGUgZ3JhcGhPYmplY3RbbGlzdE5vZGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZSBuaWwudXNhZ2VzO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHN1YmplY3RzID0gT2JqZWN0LmtleXMoZGVmYXVsdEdyYXBoKS5zb3J0KCk7XG4gIGZvcihjb25zdCBzdWJqZWN0IG9mIHN1YmplY3RzKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRlZmF1bHRHcmFwaFtzdWJqZWN0XTtcbiAgICBpZihzdWJqZWN0IGluIGdyYXBoTWFwKSB7XG4gICAgICBjb25zdCBncmFwaCA9IG5vZGVbJ0BncmFwaCddID0gW107XG4gICAgICBjb25zdCBncmFwaE9iamVjdCA9IGdyYXBoTWFwW3N1YmplY3RdO1xuICAgICAgY29uc3QgZ3JhcGhTdWJqZWN0cyA9IE9iamVjdC5rZXlzKGdyYXBoT2JqZWN0KS5zb3J0KCk7XG4gICAgICBmb3IoY29uc3QgZ3JhcGhTdWJqZWN0IG9mIGdyYXBoU3ViamVjdHMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGdyYXBoT2JqZWN0W2dyYXBoU3ViamVjdF07XG4gICAgICAgIC8vIG9ubHkgYWRkIGZ1bGwgc3ViamVjdHMgdG8gdG9wLWxldmVsXG4gICAgICAgIGlmKCFncmFwaFR5cGVzLmlzU3ViamVjdFJlZmVyZW5jZShub2RlKSkge1xuICAgICAgICAgIGdyYXBoLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb25seSBhZGQgZnVsbCBzdWJqZWN0cyB0byB0b3AtbGV2ZWxcbiAgICBpZighZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2Uobm9kZSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJERiB0cmlwbGUgb2JqZWN0IHRvIGEgSlNPTi1MRCBvYmplY3QuXG4gKlxuICogQHBhcmFtIG8gdGhlIFJERiB0cmlwbGUgb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gdXNlTmF0aXZlVHlwZXMgdHJ1ZSB0byBvdXRwdXQgbmF0aXZlIHR5cGVzLCBmYWxzZSBub3QgdG8uXG4gKlxuICogQHJldHVybiB0aGUgSlNPTi1MRCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9SREZUb09iamVjdChvLCB1c2VOYXRpdmVUeXBlcywgcmRmRGlyZWN0aW9uKSB7XG4gIC8vIGNvbnZlcnQgTmFtZWROb2RlL0JsYW5rTm9kZSBvYmplY3QgdG8gSlNPTi1MRFxuICBpZihvLnRlcm1UeXBlLmVuZHNXaXRoKCdOb2RlJykpIHtcbiAgICByZXR1cm4geydAaWQnOiBvLnZhbHVlfTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgbGl0ZXJhbCB0byBKU09OLUxEXG4gIGNvbnN0IHJ2YWwgPSB7J0B2YWx1ZSc6IG8udmFsdWV9O1xuXG4gIC8vIGFkZCBsYW5ndWFnZVxuICBpZihvLmxhbmd1YWdlKSB7XG4gICAgcnZhbFsnQGxhbmd1YWdlJ10gPSBvLmxhbmd1YWdlO1xuICB9IGVsc2Uge1xuICAgIGxldCB0eXBlID0gby5kYXRhdHlwZS52YWx1ZTtcbiAgICBpZighdHlwZSkge1xuICAgICAgdHlwZSA9IFhTRF9TVFJJTkc7XG4gICAgfVxuICAgIGlmKHR5cGUgPT09IFJERl9KU09OX0xJVEVSQUwpIHtcbiAgICAgIHR5cGUgPSAnQGpzb24nO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnZhbFsnQHZhbHVlJ10gPSBKU09OLnBhcnNlKHJ2YWxbJ0B2YWx1ZSddKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0pTT04gbGl0ZXJhbCBjb3VsZCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgJ2pzb25sZC5JbnZhbGlkSnNvbkxpdGVyYWwnLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBKU09OIGxpdGVyYWwnLCB2YWx1ZTogcnZhbFsnQHZhbHVlJ10sIGNhdXNlOiBlfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZSBuYXRpdmUgdHlwZXMgZm9yIGNlcnRhaW4geHNkIHR5cGVzXG4gICAgaWYodXNlTmF0aXZlVHlwZXMpIHtcbiAgICAgIGlmKHR5cGUgPT09IFhTRF9CT09MRUFOKSB7XG4gICAgICAgIGlmKHJ2YWxbJ0B2YWx1ZSddID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBydmFsWydAdmFsdWUnXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZihydmFsWydAdmFsdWUnXSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIHJ2YWxbJ0B2YWx1ZSddID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZih0eXBlcy5pc051bWVyaWMocnZhbFsnQHZhbHVlJ10pKSB7XG4gICAgICAgIGlmKHR5cGUgPT09IFhTRF9JTlRFR0VSKSB7XG4gICAgICAgICAgY29uc3QgaSA9IHBhcnNlSW50KHJ2YWxbJ0B2YWx1ZSddLCAxMCk7XG4gICAgICAgICAgaWYoaS50b0ZpeGVkKDApID09PSBydmFsWydAdmFsdWUnXSkge1xuICAgICAgICAgICAgcnZhbFsnQHZhbHVlJ10gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHR5cGUgPT09IFhTRF9ET1VCTEUpIHtcbiAgICAgICAgICBydmFsWydAdmFsdWUnXSA9IHBhcnNlRmxvYXQocnZhbFsnQHZhbHVlJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBkbyBub3QgYWRkIG5hdGl2ZSB0eXBlXG4gICAgICBpZighW1hTRF9CT09MRUFOLCBYU0RfSU5URUdFUiwgWFNEX0RPVUJMRSwgWFNEX1NUUklOR10uaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgcnZhbFsnQHR5cGUnXSA9IHR5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHJkZkRpcmVjdGlvbiA9PT0gJ2kxOG4tZGF0YXR5cGUnICYmXG4gICAgICB0eXBlLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9pMThuIycpKSB7XG4gICAgICBjb25zdCBbLCBsYW5ndWFnZSwgZGlyZWN0aW9uXSA9IHR5cGUuc3BsaXQoL1sjX10vKTtcbiAgICAgIGlmKGxhbmd1YWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcnZhbFsnQGxhbmd1YWdlJ10gPSBsYW5ndWFnZTtcbiAgICAgICAgaWYoIWxhbmd1YWdlLm1hdGNoKFJFR0VYX0JDUDQ3KSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQGxhbmd1YWdlIG11c3QgYmUgdmFsaWQgQkNQNDc6ICR7bGFuZ3VhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJ2YWxbJ0BkaXJlY3Rpb24nXSA9IGRpcmVjdGlvbjtcbiAgICB9IGVsc2UgaWYodHlwZSAhPT0gWFNEX1NUUklORykge1xuICAgICAgcnZhbFsnQHR5cGUnXSA9IHR5cGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN1YmplY3Qgd2l0aCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgc3ViamVjdCB3aXRoIHByb3BlcnRpZXMsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzU3ViamVjdCA9IHYgPT4ge1xuICAvLyBOb3RlOiBBIHZhbHVlIGlzIGEgc3ViamVjdCBpZiBhbGwgb2YgdGhlc2UgaG9sZCB0cnVlOlxuICAvLyAxLiBJdCBpcyBhbiBPYmplY3QuXG4gIC8vIDIuIEl0IGlzIG5vdCBhIEB2YWx1ZSwgQHNldCwgb3IgQGxpc3QuXG4gIC8vIDMuIEl0IGhhcyBtb3JlIHRoYW4gMSBrZXkgT1IgYW55IGV4aXN0aW5nIGtleSBpcyBub3QgQGlkLlxuICBpZih0eXBlcy5pc09iamVjdCh2KSAmJlxuICAgICEoKCdAdmFsdWUnIGluIHYpIHx8ICgnQHNldCcgaW4gdikgfHwgKCdAbGlzdCcgaW4gdikpKSB7XG4gICAgY29uc3Qga2V5Q291bnQgPSBPYmplY3Qua2V5cyh2KS5sZW5ndGg7XG4gICAgcmV0dXJuIChrZXlDb3VudCA+IDEgfHwgISgnQGlkJyBpbiB2KSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3ViamVjdCByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzdWJqZWN0IHJlZmVyZW5jZSwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNTdWJqZWN0UmVmZXJlbmNlID0gdiA9PlxuICAvLyBOb3RlOiBBIHZhbHVlIGlzIGEgc3ViamVjdCByZWZlcmVuY2UgaWYgYWxsIG9mIHRoZXNlIGhvbGQgdHJ1ZTpcbiAgLy8gMS4gSXQgaXMgYW4gT2JqZWN0LlxuICAvLyAyLiBJdCBoYXMgYSBzaW5nbGUga2V5OiBAaWQuXG4gICh0eXBlcy5pc09iamVjdCh2KSAmJiBPYmplY3Qua2V5cyh2KS5sZW5ndGggPT09IDEgJiYgKCdAaWQnIGluIHYpKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgQHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgQHZhbHVlLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc1ZhbHVlID0gdiA9PlxuICAvLyBOb3RlOiBBIHZhbHVlIGlzIGEgQHZhbHVlIGlmIGFsbCBvZiB0aGVzZSBob2xkIHRydWU6XG4gIC8vIDEuIEl0IGlzIGFuIE9iamVjdC5cbiAgLy8gMi4gSXQgaGFzIHRoZSBAdmFsdWUgcHJvcGVydHkuXG4gIHR5cGVzLmlzT2JqZWN0KHYpICYmICgnQHZhbHVlJyBpbiB2KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgQGxpc3QuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBAbGlzdCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNMaXN0ID0gdiA9PlxuICAvLyBOb3RlOiBBIHZhbHVlIGlzIGEgQGxpc3QgaWYgYWxsIG9mIHRoZXNlIGhvbGQgdHJ1ZTpcbiAgLy8gMS4gSXQgaXMgYW4gT2JqZWN0LlxuICAvLyAyLiBJdCBoYXMgdGhlIEBsaXN0IHByb3BlcnR5LlxuICB0eXBlcy5pc09iamVjdCh2KSAmJiAoJ0BsaXN0JyBpbiB2KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgQGdyYXBoLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBAZ3JhcGgsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzR3JhcGggPSB2ID0+IHtcbiAgLy8gTm90ZTogQSB2YWx1ZSBpcyBhIGdyYXBoIGlmIGFsbCBvZiB0aGVzZSBob2xkIHRydWU6XG4gIC8vIDEuIEl0IGlzIGFuIG9iamVjdC5cbiAgLy8gMi4gSXQgaGFzIGFuIGBAZ3JhcGhgIGtleS5cbiAgLy8gMy4gSXQgbWF5IGhhdmUgJ0BpZCcgb3IgJ0BpbmRleCdcbiAgcmV0dXJuIHR5cGVzLmlzT2JqZWN0KHYpICYmXG4gICAgJ0BncmFwaCcgaW4gdiAmJlxuICAgIE9iamVjdC5rZXlzKHYpXG4gICAgICAuZmlsdGVyKGtleSA9PiBrZXkgIT09ICdAaWQnICYmIGtleSAhPT0gJ0BpbmRleCcpLmxlbmd0aCA9PT0gMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHNpbXBsZSBAZ3JhcGguXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHNpbXBsZSBAZ3JhcGgsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzU2ltcGxlR3JhcGggPSB2ID0+IHtcbiAgLy8gTm90ZTogQSB2YWx1ZSBpcyBhIHNpbXBsZSBncmFwaCBpZiBhbGwgb2YgdGhlc2UgaG9sZCB0cnVlOlxuICAvLyAxLiBJdCBpcyBhbiBvYmplY3QuXG4gIC8vIDIuIEl0IGhhcyBhbiBgQGdyYXBoYCBrZXkuXG4gIC8vIDMuIEl0IGhhcyBvbmx5IDEga2V5IG9yIDIga2V5cyB3aGVyZSBvbmUgb2YgdGhlbSBpcyBgQGluZGV4YC5cbiAgcmV0dXJuIGFwaS5pc0dyYXBoKHYpICYmICEoJ0BpZCcgaW4gdik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBibGFuayBub2RlLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgYmxhbmsgbm9kZSwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNCbGFua05vZGUgPSB2ID0+IHtcbiAgLy8gTm90ZTogQSB2YWx1ZSBpcyBhIGJsYW5rIG5vZGUgaWYgYWxsIG9mIHRoZXNlIGhvbGQgdHJ1ZTpcbiAgLy8gMS4gSXQgaXMgYW4gT2JqZWN0LlxuICAvLyAyLiBJZiBpdCBoYXMgYW4gQGlkIGtleSBpdHMgdmFsdWUgYmVnaW5zIHdpdGggJ186Jy5cbiAgLy8gMy4gSXQgaGFzIG5vIGtleXMgT1IgaXMgbm90IGEgQHZhbHVlLCBAc2V0LCBvciBAbGlzdC5cbiAgaWYodHlwZXMuaXNPYmplY3QodikpIHtcbiAgICBpZignQGlkJyBpbiB2KSB7XG4gICAgICByZXR1cm4gKHZbJ0BpZCddLmluZGV4T2YoJ186JykgPT09IDApO1xuICAgIH1cbiAgICByZXR1cm4gKE9iamVjdC5rZXlzKHYpLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgISgoJ0B2YWx1ZScgaW4gdikgfHwgKCdAc2V0JyBpbiB2KSB8fCAoJ0BsaXN0JyBpbiB2KSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSlNPTi1MRCBBUEkuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBAbGljZW5zZSBCU0QgMy1DbGF1c2UgTGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTkgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIERpZ2l0YWwgQmF6YWFyLCBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVNcbiAqIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQVxuICogUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURURcbiAqIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5jb25zdCBjYW5vbml6ZSA9IHJlcXVpcmUoJ3JkZi1jYW5vbml6ZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgQ29udGV4dFJlc29sdmVyID0gcmVxdWlyZSgnLi9Db250ZXh0UmVzb2x2ZXInKTtcbmNvbnN0IElkZW50aWZpZXJJc3N1ZXIgPSB1dGlsLklkZW50aWZpZXJJc3N1ZXI7XG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpO1xuY29uc3QgTlF1YWRzID0gcmVxdWlyZSgnLi9OUXVhZHMnKTtcbmNvbnN0IFJkZmEgPSByZXF1aXJlKCcuL1JkZmEnKTtcblxuY29uc3Qge2V4cGFuZDogX2V4cGFuZH0gPSByZXF1aXJlKCcuL2V4cGFuZCcpO1xuY29uc3Qge2ZsYXR0ZW46IF9mbGF0dGVufSA9IHJlcXVpcmUoJy4vZmxhdHRlbicpO1xuY29uc3Qge2Zyb21SREY6IF9mcm9tUkRGfSA9IHJlcXVpcmUoJy4vZnJvbVJkZicpO1xuY29uc3Qge3RvUkRGOiBfdG9SREZ9ID0gcmVxdWlyZSgnLi90b1JkZicpO1xuXG5jb25zdCB7XG4gIGZyYW1lTWVyZ2VkT3JEZWZhdWx0OiBfZnJhbWVNZXJnZWRPckRlZmF1bHQsXG4gIGNsZWFudXBOdWxsOiBfY2xlYW51cE51bGxcbn0gPSByZXF1aXJlKCcuL2ZyYW1lJyk7XG5cbmNvbnN0IHtcbiAgaXNBcnJheTogX2lzQXJyYXksXG4gIGlzT2JqZWN0OiBfaXNPYmplY3QsXG4gIGlzU3RyaW5nOiBfaXNTdHJpbmdcbn0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IHtcbiAgaXNTdWJqZWN0UmVmZXJlbmNlOiBfaXNTdWJqZWN0UmVmZXJlbmNlLFxufSA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuXG5jb25zdCB7XG4gIGV4cGFuZElyaTogX2V4cGFuZElyaSxcbiAgZ2V0SW5pdGlhbENvbnRleHQ6IF9nZXRJbml0aWFsQ29udGV4dCxcbiAgcHJvY2VzczogX3Byb2Nlc3NDb250ZXh0LFxuICBwcm9jZXNzaW5nTW9kZTogX3Byb2Nlc3NpbmdNb2RlXG59ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG5cbmNvbnN0IHtcbiAgY29tcGFjdDogX2NvbXBhY3QsXG4gIGNvbXBhY3RJcmk6IF9jb21wYWN0SXJpXG59ID0gcmVxdWlyZSgnLi9jb21wYWN0Jyk7XG5cbmNvbnN0IHtcbiAgY3JlYXRlTm9kZU1hcDogX2NyZWF0ZU5vZGVNYXAsXG4gIGNyZWF0ZU1lcmdlZE5vZGVNYXA6IF9jcmVhdGVNZXJnZWROb2RlTWFwLFxuICBtZXJnZU5vZGVNYXBzOiBfbWVyZ2VOb2RlTWFwc1xufSA9IHJlcXVpcmUoJy4vbm9kZU1hcCcpO1xuXG4vLyBkZXRlcm1pbmUgaWYgaW4tYnJvd3NlciBvciB1c2luZyBOb2RlLmpzXG5jb25zdCBfbm9kZWpzID0gKFxuICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuY29uc3QgX2Jyb3dzZXIgPSAhX25vZGVqcyAmJlxuICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKTtcblxuLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG4vLyBhdHRhY2hlcyBqc29ubGQgQVBJIHRvIHRoZSBnaXZlbiBvYmplY3RcbmNvbnN0IHdyYXBwZXIgPSBmdW5jdGlvbihqc29ubGQpIHtcblxuLyoqIFJlZ2lzdGVyZWQgUkRGIGRhdGFzZXQgcGFyc2VycyBoYXNoZWQgYnkgY29udGVudC10eXBlLiAqL1xuY29uc3QgX3JkZlBhcnNlcnMgPSB7fTtcblxuLy8gcmVzb2x2ZWQgY29udGV4dCBjYWNoZVxuLy8gVE9ETzogY29uc2lkZXIgYmFzaW5nIG1heCBvbiBjb250ZXh0IHNpemUgcmF0aGVyIHRoYW4gbnVtYmVyXG5jb25zdCBSRVNPTFZFRF9DT05URVhUX0NBQ0hFX01BWF9TSVpFID0gMTAwO1xuY29uc3QgX3Jlc29sdmVkQ29udGV4dENhY2hlID0gbmV3IExSVSh7bWF4OiBSRVNPTFZFRF9DT05URVhUX0NBQ0hFX01BWF9TSVpFfSk7XG5cbi8qIENvcmUgQVBJICovXG5cbi8qKlxuICogUGVyZm9ybXMgSlNPTi1MRCBjb21wYWN0aW9uLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgSlNPTi1MRCBpbnB1dCB0byBjb21wYWN0LlxuICogQHBhcmFtIGN0eCB0aGUgY29udGV4dCB0byBjb21wYWN0IHdpdGguXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbY29tcGFjdEFycmF5c10gdHJ1ZSB0byBjb21wYWN0IGFycmF5cyB0byBzaW5nbGUgdmFsdWVzIHdoZW5cbiAqICAgICAgICAgICAgYXBwcm9wcmlhdGUsIGZhbHNlIG5vdCB0byAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbY29tcGFjdFRvUmVsYXRpdmVdIHRydWUgdG8gY29tcGFjdCBJUklzIHRvIGJlIHJlbGF0aXZlIHRvIGRvY3VtZW50XG4gKiAgICAgICAgICAgIGJhc2UsIGZhbHNlIHRvIGtlZXAgYWJzb2x1dGUgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgICAgICBbZ3JhcGhdIHRydWUgdG8gYWx3YXlzIG91dHB1dCBhIHRvcC1sZXZlbCBncmFwaCAoZGVmYXVsdDogZmFsc2UpLlxuICogICAgICAgICAgW2V4cGFuZENvbnRleHRdIGEgY29udGV4dCB0byBleHBhbmQgd2l0aC5cbiAqICAgICAgICAgIFtza2lwRXhwYW5zaW9uXSB0cnVlIHRvIGFzc3VtZSB0aGUgaW5wdXQgaXMgZXhwYW5kZWQgYW5kIHNraXBcbiAqICAgICAgICAgICAgZXhwYW5zaW9uLCBmYWxzZSBub3QgdG8sIGRlZmF1bHRzIHRvIGZhbHNlLlxuICogICAgICAgICAgW2RvY3VtZW50TG9hZGVyKHVybCwgb3B0aW9ucyldIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKiAgICAgICAgICBbZXhwYW5zaW9uTWFwKGluZm8pXSBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3VzdG9tIG1hcFxuICogICAgICAgICAgICB1bm1hcHBhYmxlIHZhbHVlcyAob3IgdG8gdGhyb3cgYW4gZXJyb3Igd2hlbiB0aGV5IGFyZSBkZXRlY3RlZCk7XG4gKiAgICAgICAgICAgIGlmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCB0aGVuIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gKiAgICAgICAgICAgIHdpbGwgYmUgdXNlZC5cbiAqICAgICAgICAgIFtmcmFtaW5nXSB0cnVlIGlmIGNvbXBhY3Rpb24gaXMgb2NjdXJpbmcgZHVyaW5nIGEgZnJhbWluZyBvcGVyYXRpb24uXG4gKiAgICAgICAgICBbY29tcGFjdGlvbk1hcChpbmZvKV0gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGN1c3RvbSBtYXBcbiAqICAgICAgICAgICAgdW5tYXBwYWJsZSB2YWx1ZXMgKG9yIHRvIHRocm93IGFuIGVycm9yIHdoZW4gdGhleSBhcmUgZGV0ZWN0ZWQpO1xuICogICAgICAgICAgICBpZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgdGhlbiB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICogICAgICAgICAgICB3aWxsIGJlIHVzZWQuXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjb21wYWN0ZWQgb3V0cHV0LlxuICovXG5qc29ubGQuY29tcGFjdCA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBjdHgsIG9wdGlvbnMpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgY29tcGFjdCwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICBpZihjdHggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnVGhlIGNvbXBhY3Rpb24gY29udGV4dCBtdXN0IG5vdCBiZSBudWxsLicsXG4gICAgICAnanNvbmxkLkNvbXBhY3RFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBsb2NhbCBjb250ZXh0J30pO1xuICB9XG5cbiAgLy8gbm90aGluZyB0byBjb21wYWN0XG4gIGlmKGlucHV0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIGNvbXBhY3RBcnJheXM6IHRydWUsXG4gICAgY29tcGFjdFRvUmVsYXRpdmU6IHRydWUsXG4gICAgZ3JhcGg6IGZhbHNlLFxuICAgIHNraXBFeHBhbnNpb246IGZhbHNlLFxuICAgIGxpbms6IGZhbHNlLFxuICAgIGlzc3VlcjogbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YicpLFxuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG4gIGlmKG9wdGlvbnMubGluaykge1xuICAgIC8vIGZvcmNlIHNraXAgZXhwYW5zaW9uIHdoZW4gbGlua2luZywgXCJsaW5rXCIgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpY1xuICAgIC8vIEFQSSwgaXQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gZnJhbWluZ1xuICAgIG9wdGlvbnMuc2tpcEV4cGFuc2lvbiA9IHRydWU7XG4gIH1cbiAgaWYoIW9wdGlvbnMuY29tcGFjdFRvUmVsYXRpdmUpIHtcbiAgICBkZWxldGUgb3B0aW9ucy5iYXNlO1xuICB9XG5cbiAgLy8gZXhwYW5kIGlucHV0XG4gIGxldCBleHBhbmRlZDtcbiAgaWYob3B0aW9ucy5za2lwRXhwYW5zaW9uKSB7XG4gICAgZXhwYW5kZWQgPSBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICBleHBhbmRlZCA9IGF3YWl0IGpzb25sZC5leHBhbmQoaW5wdXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gcHJvY2VzcyBjb250ZXh0XG4gIGNvbnN0IGFjdGl2ZUN0eCA9IGF3YWl0IGpzb25sZC5wcm9jZXNzQ29udGV4dChcbiAgICBfZ2V0SW5pdGlhbENvbnRleHQob3B0aW9ucyksIGN0eCwgb3B0aW9ucyk7XG5cbiAgLy8gZG8gY29tcGFjdGlvblxuICBsZXQgY29tcGFjdGVkID0gYXdhaXQgX2NvbXBhY3Qoe1xuICAgIGFjdGl2ZUN0eCxcbiAgICBlbGVtZW50OiBleHBhbmRlZCxcbiAgICBvcHRpb25zLFxuICAgIGNvbXBhY3Rpb25NYXA6IG9wdGlvbnMuY29tcGFjdGlvbk1hcFxuICB9KTtcblxuICAvLyBwZXJmb3JtIGNsZWFuIHVwXG4gIGlmKG9wdGlvbnMuY29tcGFjdEFycmF5cyAmJiAhb3B0aW9ucy5ncmFwaCAmJiBfaXNBcnJheShjb21wYWN0ZWQpKSB7XG4gICAgaWYoY29tcGFjdGVkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gc2ltcGxpZnkgdG8gYSBzaW5nbGUgaXRlbVxuICAgICAgY29tcGFjdGVkID0gY29tcGFjdGVkWzBdO1xuICAgIH0gZWxzZSBpZihjb21wYWN0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBzaW1wbGlmeSB0byBhbiBlbXB0eSBvYmplY3RcbiAgICAgIGNvbXBhY3RlZCA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmKG9wdGlvbnMuZ3JhcGggJiYgX2lzT2JqZWN0KGNvbXBhY3RlZCkpIHtcbiAgICAvLyBhbHdheXMgdXNlIGFycmF5IGlmIGdyYXBoIG9wdGlvbiBpcyBvblxuICAgIGNvbXBhY3RlZCA9IFtjb21wYWN0ZWRdO1xuICB9XG5cbiAgLy8gZm9sbG93IEBjb250ZXh0IGtleVxuICBpZihfaXNPYmplY3QoY3R4KSAmJiAnQGNvbnRleHQnIGluIGN0eCkge1xuICAgIGN0eCA9IGN0eFsnQGNvbnRleHQnXTtcbiAgfVxuXG4gIC8vIGJ1aWxkIG91dHB1dCBjb250ZXh0XG4gIGN0eCA9IHV0aWwuY2xvbmUoY3R4KTtcbiAgaWYoIV9pc0FycmF5KGN0eCkpIHtcbiAgICBjdHggPSBbY3R4XTtcbiAgfVxuICAvLyByZW1vdmUgZW1wdHkgY29udGV4dHNcbiAgY29uc3QgdG1wID0gY3R4O1xuICBjdHggPSBbXTtcbiAgZm9yKGxldCBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgIGlmKCFfaXNPYmplY3QodG1wW2ldKSB8fCBPYmplY3Qua2V5cyh0bXBbaV0pLmxlbmd0aCA+IDApIHtcbiAgICAgIGN0eC5wdXNoKHRtcFtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIGFycmF5IGlmIG9ubHkgb25lIGNvbnRleHRcbiAgY29uc3QgaGFzQ29udGV4dCA9IChjdHgubGVuZ3RoID4gMCk7XG4gIGlmKGN0eC5sZW5ndGggPT09IDEpIHtcbiAgICBjdHggPSBjdHhbMF07XG4gIH1cblxuICAvLyBhZGQgY29udGV4dCBhbmQvb3IgQGdyYXBoXG4gIGlmKF9pc0FycmF5KGNvbXBhY3RlZCkpIHtcbiAgICAvLyB1c2UgJ0BncmFwaCcga2V5d29yZFxuICAgIGNvbnN0IGdyYXBoQWxpYXMgPSBfY29tcGFjdElyaSh7XG4gICAgICBhY3RpdmVDdHgsIGlyaTogJ0BncmFwaCcsIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICB9KTtcbiAgICBjb25zdCBncmFwaCA9IGNvbXBhY3RlZDtcbiAgICBjb21wYWN0ZWQgPSB7fTtcbiAgICBpZihoYXNDb250ZXh0KSB7XG4gICAgICBjb21wYWN0ZWRbJ0Bjb250ZXh0J10gPSBjdHg7XG4gICAgfVxuICAgIGNvbXBhY3RlZFtncmFwaEFsaWFzXSA9IGdyYXBoO1xuICB9IGVsc2UgaWYoX2lzT2JqZWN0KGNvbXBhY3RlZCkgJiYgaGFzQ29udGV4dCkge1xuICAgIC8vIHJlb3JkZXIga2V5cyBzbyBAY29udGV4dCBpcyBmaXJzdFxuICAgIGNvbnN0IGdyYXBoID0gY29tcGFjdGVkO1xuICAgIGNvbXBhY3RlZCA9IHsnQGNvbnRleHQnOiBjdHh9O1xuICAgIGZvcihjb25zdCBrZXkgaW4gZ3JhcGgpIHtcbiAgICAgIGNvbXBhY3RlZFtrZXldID0gZ3JhcGhba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tcGFjdGVkO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBKU09OLUxEIGV4cGFuc2lvbi5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIEpTT04tTEQgaW5wdXQgdG8gZXhwYW5kLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBba2VlcEZyZWVGbG9hdGluZ05vZGVzXSB0cnVlIHRvIGtlZXAgZnJlZS1mbG9hdGluZyBub2RlcyxcbiAqICAgICAgICAgICAgZmFsc2Ugbm90IHRvLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAqICAgICAgICAgIFtkb2N1bWVudExvYWRlcih1cmwsIG9wdGlvbnMpXSB0aGUgZG9jdW1lbnQgbG9hZGVyLlxuICogICAgICAgICAgW2V4cGFuc2lvbk1hcChpbmZvKV0gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGN1c3RvbSBtYXBcbiAqICAgICAgICAgICAgdW5tYXBwYWJsZSB2YWx1ZXMgKG9yIHRvIHRocm93IGFuIGVycm9yIHdoZW4gdGhleSBhcmUgZGV0ZWN0ZWQpO1xuICogICAgICAgICAgICBpZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgdGhlbiB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICogICAgICAgICAgICB3aWxsIGJlIHVzZWQuXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBleHBhbmRlZCBvdXRwdXQuXG4gKi9cbmpzb25sZC5leHBhbmQgPSBhc3luYyBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBleHBhbmQsIHRvbyBmZXcgYXJndW1lbnRzLicpO1xuICB9XG5cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBrZWVwRnJlZUZsb2F0aW5nTm9kZXM6IGZhbHNlLFxuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG4gIGlmKG9wdGlvbnMuZXhwYW5zaW9uTWFwID09PSBmYWxzZSkge1xuICAgIG9wdGlvbnMuZXhwYW5zaW9uTWFwID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gYnVpbGQgc2V0IG9mIG9iamVjdHMgdGhhdCBtYXkgaGF2ZSBAY29udGV4dHMgdG8gcmVzb2x2ZVxuICBjb25zdCB0b1Jlc29sdmUgPSB7fTtcblxuICAvLyBidWlsZCBzZXQgb2YgY29udGV4dHMgdG8gcHJvY2VzcyBwcmlvciB0byBleHBhbnNpb25cbiAgY29uc3QgY29udGV4dHNUb1Byb2Nlc3MgPSBbXTtcblxuICAvLyBpZiBhbiBgZXhwYW5kQ29udGV4dGAgaGFzIGJlZW4gZ2l2ZW4gZW5zdXJlIGl0IGdldHMgcmVzb2x2ZWRcbiAgaWYoJ2V4cGFuZENvbnRleHQnIGluIG9wdGlvbnMpIHtcbiAgICBjb25zdCBleHBhbmRDb250ZXh0ID0gdXRpbC5jbG9uZShvcHRpb25zLmV4cGFuZENvbnRleHQpO1xuICAgIGlmKF9pc09iamVjdChleHBhbmRDb250ZXh0KSAmJiAnQGNvbnRleHQnIGluIGV4cGFuZENvbnRleHQpIHtcbiAgICAgIHRvUmVzb2x2ZS5leHBhbmRDb250ZXh0ID0gZXhwYW5kQ29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9SZXNvbHZlLmV4cGFuZENvbnRleHQgPSB7J0Bjb250ZXh0JzogZXhwYW5kQ29udGV4dH07XG4gICAgfVxuICAgIGNvbnRleHRzVG9Qcm9jZXNzLnB1c2godG9SZXNvbHZlLmV4cGFuZENvbnRleHQpO1xuICB9XG5cbiAgLy8gaWYgaW5wdXQgaXMgYSBzdHJpbmcsIGF0dGVtcHQgdG8gZGVyZWZlcmVuY2UgcmVtb3RlIGRvY3VtZW50XG4gIGxldCBkZWZhdWx0QmFzZTtcbiAgaWYoIV9pc1N0cmluZyhpbnB1dCkpIHtcbiAgICAvLyBpbnB1dCBpcyBub3QgYSBVUkwsIGRvIG5vdCBuZWVkIHRvIHJldHJpZXZlIGl0IGZpcnN0XG4gICAgdG9SZXNvbHZlLmlucHV0ID0gdXRpbC5jbG9uZShpbnB1dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbG9hZCByZW1vdGUgZG9jXG4gICAgY29uc3QgcmVtb3RlRG9jID0gYXdhaXQganNvbmxkLmdldChpbnB1dCwgb3B0aW9ucyk7XG4gICAgZGVmYXVsdEJhc2UgPSByZW1vdGVEb2MuZG9jdW1lbnRVcmw7XG4gICAgdG9SZXNvbHZlLmlucHV0ID0gcmVtb3RlRG9jLmRvY3VtZW50O1xuICAgIGlmKHJlbW90ZURvYy5jb250ZXh0VXJsKSB7XG4gICAgICAvLyBjb250ZXh0IGluY2x1ZGVkIGluIEhUVFAgbGluayBoZWFkZXIgYW5kIG11c3QgYmUgcmVzb2x2ZWRcbiAgICAgIHRvUmVzb2x2ZS5yZW1vdGVDb250ZXh0ID0geydAY29udGV4dCc6IHJlbW90ZURvYy5jb250ZXh0VXJsfTtcbiAgICAgIGNvbnRleHRzVG9Qcm9jZXNzLnB1c2godG9SZXNvbHZlLnJlbW90ZUNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBkZWZhdWx0IGJhc2VcbiAgaWYoISgnYmFzZScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmJhc2UgPSBkZWZhdWx0QmFzZSB8fCAnJztcbiAgfVxuXG4gIC8vIHByb2Nlc3MgYW55IGFkZGl0aW9uYWwgY29udGV4dHNcbiAgbGV0IGFjdGl2ZUN0eCA9IF9nZXRJbml0aWFsQ29udGV4dChvcHRpb25zKTtcbiAgZm9yKGNvbnN0IGxvY2FsQ3R4IG9mIGNvbnRleHRzVG9Qcm9jZXNzKSB7XG4gICAgYWN0aXZlQ3R4ID0gYXdhaXQgX3Byb2Nlc3NDb250ZXh0KHthY3RpdmVDdHgsIGxvY2FsQ3R4LCBvcHRpb25zfSk7XG4gIH1cblxuICAvLyBleHBhbmQgcmVzb2x2ZWQgaW5wdXRcbiAgbGV0IGV4cGFuZGVkID0gYXdhaXQgX2V4cGFuZCh7XG4gICAgYWN0aXZlQ3R4LFxuICAgIGVsZW1lbnQ6IHRvUmVzb2x2ZS5pbnB1dCxcbiAgICBvcHRpb25zLFxuICAgIGV4cGFuc2lvbk1hcDogb3B0aW9ucy5leHBhbnNpb25NYXBcbiAgfSk7XG5cbiAgLy8gb3B0aW1pemUgYXdheSBAZ3JhcGggd2l0aCBubyBvdGhlciBwcm9wZXJ0aWVzXG4gIGlmKF9pc09iamVjdChleHBhbmRlZCkgJiYgKCdAZ3JhcGgnIGluIGV4cGFuZGVkKSAmJlxuICAgIE9iamVjdC5rZXlzKGV4cGFuZGVkKS5sZW5ndGggPT09IDEpIHtcbiAgICBleHBhbmRlZCA9IGV4cGFuZGVkWydAZ3JhcGgnXTtcbiAgfSBlbHNlIGlmKGV4cGFuZGVkID09PSBudWxsKSB7XG4gICAgZXhwYW5kZWQgPSBbXTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSB0byBhbiBhcnJheVxuICBpZighX2lzQXJyYXkoZXhwYW5kZWQpKSB7XG4gICAgZXhwYW5kZWQgPSBbZXhwYW5kZWRdO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBKU09OLUxEIGZsYXR0ZW5pbmcuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0gY3R4IHRoZSBjb250ZXh0IHRvIHVzZSB0byBjb21wYWN0IHRoZSBmbGF0dGVuZWQgb3V0cHV0LCBvciBudWxsLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZsYXR0ZW5lZCBvdXRwdXQuXG4gKi9cbmpzb25sZC5mbGF0dGVuID0gYXN5bmMgZnVuY3Rpb24oaW5wdXQsIGN0eCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgZmxhdHRlbiwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICBpZih0eXBlb2YgY3R4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY3R4ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBjdHggPSBjdHggfHwgbnVsbDtcbiAgfVxuXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgYmFzZTogX2lzU3RyaW5nKGlucHV0KSA/IGlucHV0IDogJycsXG4gICAgY29udGV4dFJlc29sdmVyOiBuZXcgQ29udGV4dFJlc29sdmVyKFxuICAgICAge3NoYXJlZENhY2hlOiBfcmVzb2x2ZWRDb250ZXh0Q2FjaGV9KVxuICB9KTtcblxuICAvLyBleHBhbmQgaW5wdXRcbiAgY29uc3QgZXhwYW5kZWQgPSBhd2FpdCBqc29ubGQuZXhwYW5kKGlucHV0LCBvcHRpb25zKTtcblxuICAvLyBkbyBmbGF0dGVuaW5nXG4gIGNvbnN0IGZsYXR0ZW5lZCA9IF9mbGF0dGVuKGV4cGFuZGVkKTtcblxuICBpZihjdHggPT09IG51bGwpIHtcbiAgICAvLyBubyBjb21wYWN0aW9uIHJlcXVpcmVkXG4gICAgcmV0dXJuIGZsYXR0ZW5lZDtcbiAgfVxuXG4gIC8vIGNvbXBhY3QgcmVzdWx0IChmb3JjZSBAZ3JhcGggb3B0aW9uIHRvIHRydWUsIHNraXAgZXhwYW5zaW9uKVxuICBvcHRpb25zLmdyYXBoID0gdHJ1ZTtcbiAgb3B0aW9ucy5za2lwRXhwYW5zaW9uID0gdHJ1ZTtcbiAgY29uc3QgY29tcGFjdGVkID0gYXdhaXQganNvbmxkLmNvbXBhY3QoZmxhdHRlbmVkLCBjdHgsIG9wdGlvbnMpO1xuXG4gIHJldHVybiBjb21wYWN0ZWQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIEpTT04tTEQgZnJhbWluZy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIEpTT04tTEQgaW5wdXQgdG8gZnJhbWUuXG4gKiBAcGFyYW0gZnJhbWUgdGhlIEpTT04tTEQgZnJhbWUgdG8gdXNlLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgZnJhbWluZyBvcHRpb25zLlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2VtYmVkXSBkZWZhdWx0IEBlbWJlZCBmbGFnOiAnQGxhc3QnLCAnQGFsd2F5cycsICdAbmV2ZXInLCAnQGxpbmsnXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiAnQGxhc3QnKS5cbiAqICAgICAgICAgIFtleHBsaWNpdF0gZGVmYXVsdCBAZXhwbGljaXQgZmxhZyAoZGVmYXVsdDogZmFsc2UpLlxuICogICAgICAgICAgW3JlcXVpcmVBbGxdIGRlZmF1bHQgQHJlcXVpcmVBbGwgZmxhZyAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbb21pdERlZmF1bHRdIGRlZmF1bHQgQG9taXREZWZhdWx0IGZsYWcgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICAgIFtkb2N1bWVudExvYWRlcih1cmwsIG9wdGlvbnMpXSB0aGUgZG9jdW1lbnQgbG9hZGVyLlxuICogICAgICAgICAgW2NvbnRleHRSZXNvbHZlcl0gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZnJhbWVkIG91dHB1dC5cbiAqL1xuanNvbmxkLmZyYW1lID0gYXN5bmMgZnVuY3Rpb24oaW5wdXQsIGZyYW1lLCBvcHRpb25zKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGZyYW1lLCB0b28gZmV3IGFyZ3VtZW50cy4nKTtcbiAgfVxuXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgYmFzZTogX2lzU3RyaW5nKGlucHV0KSA/IGlucHV0IDogJycsXG4gICAgZW1iZWQ6ICdAb25jZScsXG4gICAgZXhwbGljaXQ6IGZhbHNlLFxuICAgIHJlcXVpcmVBbGw6IGZhbHNlLFxuICAgIG9taXREZWZhdWx0OiBmYWxzZSxcbiAgICBibm9kZXNUb0NsZWFyOiBbXSxcbiAgICBjb250ZXh0UmVzb2x2ZXI6IG5ldyBDb250ZXh0UmVzb2x2ZXIoXG4gICAgICB7c2hhcmVkQ2FjaGU6IF9yZXNvbHZlZENvbnRleHRDYWNoZX0pXG4gIH0pO1xuXG4gIC8vIGlmIGZyYW1lIGlzIGEgc3RyaW5nLCBhdHRlbXB0IHRvIGRlcmVmZXJlbmNlIHJlbW90ZSBkb2N1bWVudFxuICBpZihfaXNTdHJpbmcoZnJhbWUpKSB7XG4gICAgLy8gbG9hZCByZW1vdGUgZG9jXG4gICAgY29uc3QgcmVtb3RlRG9jID0gYXdhaXQganNvbmxkLmdldChmcmFtZSwgb3B0aW9ucyk7XG4gICAgZnJhbWUgPSByZW1vdGVEb2MuZG9jdW1lbnQ7XG5cbiAgICBpZihyZW1vdGVEb2MuY29udGV4dFVybCkge1xuICAgICAgLy8gaW5qZWN0IGxpbmsgaGVhZGVyIEBjb250ZXh0IGludG8gZnJhbWVcbiAgICAgIGxldCBjdHggPSBmcmFtZVsnQGNvbnRleHQnXTtcbiAgICAgIGlmKCFjdHgpIHtcbiAgICAgICAgY3R4ID0gcmVtb3RlRG9jLmNvbnRleHRVcmw7XG4gICAgICB9IGVsc2UgaWYoX2lzQXJyYXkoY3R4KSkge1xuICAgICAgICBjdHgucHVzaChyZW1vdGVEb2MuY29udGV4dFVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHggPSBbY3R4LCByZW1vdGVEb2MuY29udGV4dFVybF07XG4gICAgICB9XG4gICAgICBmcmFtZVsnQGNvbnRleHQnXSA9IGN0eDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBmcmFtZUNvbnRleHQgPSBmcmFtZSA/IGZyYW1lWydAY29udGV4dCddIHx8IHt9IDoge307XG5cbiAgLy8gcHJvY2VzcyBjb250ZXh0XG4gIGNvbnN0IGFjdGl2ZUN0eCA9IGF3YWl0IGpzb25sZC5wcm9jZXNzQ29udGV4dChcbiAgICBfZ2V0SW5pdGlhbENvbnRleHQob3B0aW9ucyksIGZyYW1lQ29udGV4dCwgb3B0aW9ucyk7XG5cbiAgLy8gbW9kZSBzcGVjaWZpYyBkZWZhdWx0c1xuICBpZighb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnb21pdEdyYXBoJykpIHtcbiAgICBvcHRpb25zLm9taXRHcmFwaCA9IF9wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSk7XG4gIH1cbiAgaWYoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3BydW5lQmxhbmtOb2RlSWRlbnRpZmllcnMnKSkge1xuICAgIG9wdGlvbnMucHJ1bmVCbGFua05vZGVJZGVudGlmaWVycyA9IF9wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSk7XG4gIH1cblxuICAvLyBleHBhbmQgaW5wdXRcbiAgY29uc3QgZXhwYW5kZWQgPSBhd2FpdCBqc29ubGQuZXhwYW5kKGlucHV0LCBvcHRpb25zKTtcblxuICAvLyBleHBhbmQgZnJhbWVcbiAgY29uc3Qgb3B0cyA9IHsuLi5vcHRpb25zfTtcbiAgb3B0cy5pc0ZyYW1lID0gdHJ1ZTtcbiAgb3B0cy5rZWVwRnJlZUZsb2F0aW5nTm9kZXMgPSB0cnVlO1xuICBjb25zdCBleHBhbmRlZEZyYW1lID0gYXdhaXQganNvbmxkLmV4cGFuZChmcmFtZSwgb3B0cyk7XG5cbiAgLy8gaWYgdGhlIHVuZXhwYW5kZWQgZnJhbWUgaW5jbHVkZXMgYSBrZXkgZXhwYW5kaW5nIHRvIEBncmFwaCwgZnJhbWUgdGhlXG4gIC8vIGRlZmF1bHQgZ3JhcGgsIG90aGVyd2lzZSwgdGhlIG1lcmdlZCBncmFwaFxuICBjb25zdCBmcmFtZUtleXMgPSBPYmplY3Qua2V5cyhmcmFtZSlcbiAgICAubWFwKGtleSA9PiBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwga2V5LCB7dm9jYWI6IHRydWV9KSk7XG4gIG9wdHMubWVyZ2VkID0gIWZyYW1lS2V5cy5pbmNsdWRlcygnQGdyYXBoJyk7XG4gIG9wdHMuaXMxMSA9IF9wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSk7XG5cbiAgLy8gZG8gZnJhbWluZ1xuICBjb25zdCBmcmFtZWQgPSBfZnJhbWVNZXJnZWRPckRlZmF1bHQoZXhwYW5kZWQsIGV4cGFuZGVkRnJhbWUsIG9wdHMpO1xuXG4gIG9wdHMuZ3JhcGggPSAhb3B0aW9ucy5vbWl0R3JhcGg7XG4gIG9wdHMuc2tpcEV4cGFuc2lvbiA9IHRydWU7XG4gIG9wdHMubGluayA9IHt9O1xuICBvcHRzLmZyYW1pbmcgPSB0cnVlO1xuICBsZXQgY29tcGFjdGVkID0gYXdhaXQganNvbmxkLmNvbXBhY3QoZnJhbWVkLCBmcmFtZUNvbnRleHQsIG9wdHMpO1xuXG4gIC8vIHJlcGxhY2UgQG51bGwgd2l0aCBudWxsLCBjb21wYWN0aW5nIGFycmF5c1xuICBvcHRzLmxpbmsgPSB7fTtcbiAgY29tcGFjdGVkID0gX2NsZWFudXBOdWxsKGNvbXBhY3RlZCwgb3B0cyk7XG5cbiAgcmV0dXJuIGNvbXBhY3RlZDtcbn07XG5cbi8qKlxuICogKipFeHBlcmltZW50YWwqKlxuICpcbiAqIExpbmtzIGEgSlNPTi1MRCBkb2N1bWVudCdzIG5vZGVzIGluIG1lbW9yeS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIEpTT04tTEQgZG9jdW1lbnQgdG8gbGluay5cbiAqIEBwYXJhbSBbY3R4XSB0aGUgSlNPTi1MRCBjb250ZXh0IHRvIGFwcGx5LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxpbmtlZCBvdXRwdXQuXG4gKi9cbmpzb25sZC5saW5rID0gYXN5bmMgZnVuY3Rpb24oaW5wdXQsIGN0eCwgb3B0aW9ucykge1xuICAvLyBBUEkgbWF0Y2hlcyBydW5uaW5nIGZyYW1lIHdpdGggYSB3aWxkY2FyZCBmcmFtZSBhbmQgZW1iZWQ6ICdAbGluaydcbiAgLy8gZ2V0IGFyZ3VtZW50c1xuICBjb25zdCBmcmFtZSA9IHt9O1xuICBpZihjdHgpIHtcbiAgICBmcmFtZVsnQGNvbnRleHQnXSA9IGN0eDtcbiAgfVxuICBmcmFtZVsnQGVtYmVkJ10gPSAnQGxpbmsnO1xuICByZXR1cm4ganNvbmxkLmZyYW1lKGlucHV0LCBmcmFtZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIFJERiBkYXRhc2V0IG5vcm1hbGl6YXRpb24gb24gdGhlIGdpdmVuIGlucHV0LiBUaGUgaW5wdXQgaXMgSlNPTi1MRFxuICogdW5sZXNzIHRoZSAnaW5wdXRGb3JtYXQnIG9wdGlvbiBpcyB1c2VkLiBUaGUgb3V0cHV0IGlzIGFuIFJERiBkYXRhc2V0XG4gKiB1bmxlc3MgdGhlICdmb3JtYXQnIG9wdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgdG8gbm9ybWFsaXplIGFzIEpTT04tTEQgb3IgYXMgYSBmb3JtYXQgc3BlY2lmaWVkIGJ5XG4gKiAgICAgICAgICB0aGUgJ2lucHV0Rm9ybWF0JyBvcHRpb24uXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFthbGdvcml0aG1dIHRoZSBub3JtYWxpemF0aW9uIGFsZ29yaXRobSB0byB1c2UsIGBVUkROQTIwMTVgIG9yXG4gKiAgICAgICAgICAgIGBVUkdOQTIwMTJgIChkZWZhdWx0OiBgVVJETkEyMDE1YCkuXG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBbc2tpcEV4cGFuc2lvbl0gdHJ1ZSB0byBhc3N1bWUgdGhlIGlucHV0IGlzIGV4cGFuZGVkIGFuZCBza2lwXG4gKiAgICAgICAgICAgIGV4cGFuc2lvbiwgZmFsc2Ugbm90IHRvLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAqICAgICAgICAgIFtpbnB1dEZvcm1hdF0gdGhlIGZvcm1hdCBpZiBpbnB1dCBpcyBub3QgSlNPTi1MRDpcbiAqICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL24tcXVhZHMnIGZvciBOLVF1YWRzLlxuICogICAgICAgICAgW2Zvcm1hdF0gdGhlIGZvcm1hdCBpZiBvdXRwdXQgaXMgYSBzdHJpbmc6XG4gKiAgICAgICAgICAgICdhcHBsaWNhdGlvbi9uLXF1YWRzJyBmb3IgTi1RdWFkcy5cbiAqICAgICAgICAgIFtkb2N1bWVudExvYWRlcih1cmwsIG9wdGlvbnMpXSB0aGUgZG9jdW1lbnQgbG9hZGVyLlxuICogICAgICAgICAgW3VzZU5hdGl2ZV0gdHJ1ZSB0byB1c2UgYSBuYXRpdmUgY2Fub25pemUgYWxnb3JpdGhtXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBub3JtYWxpemVkIG91dHB1dC5cbiAqL1xuanNvbmxkLm5vcm1hbGl6ZSA9IGpzb25sZC5jYW5vbml6ZSA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGNhbm9uaXplLCB0b28gZmV3IGFyZ3VtZW50cy4nKTtcbiAgfVxuXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgYmFzZTogX2lzU3RyaW5nKGlucHV0KSA/IGlucHV0IDogJycsXG4gICAgYWxnb3JpdGhtOiAnVVJETkEyMDE1JyxcbiAgICBza2lwRXhwYW5zaW9uOiBmYWxzZSxcbiAgICBjb250ZXh0UmVzb2x2ZXI6IG5ldyBDb250ZXh0UmVzb2x2ZXIoXG4gICAgICB7c2hhcmVkQ2FjaGU6IF9yZXNvbHZlZENvbnRleHRDYWNoZX0pXG4gIH0pO1xuICBpZignaW5wdXRGb3JtYXQnIGluIG9wdGlvbnMpIHtcbiAgICBpZihvcHRpb25zLmlucHV0Rm9ybWF0ICE9PSAnYXBwbGljYXRpb24vbi1xdWFkcycgJiZcbiAgICAgIG9wdGlvbnMuaW5wdXRGb3JtYXQgIT09ICdhcHBsaWNhdGlvbi9ucXVhZHMnKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdVbmtub3duIGNhbm9uaWNhbGl6YXRpb24gaW5wdXQgZm9ybWF0LicsXG4gICAgICAgICdqc29ubGQuQ2Fub25pemVFcnJvcicpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBgYXdhaXRgIGZvciBhc3luYyBwYXJzZXJzXG4gICAgY29uc3QgcGFyc2VkSW5wdXQgPSBOUXVhZHMucGFyc2UoaW5wdXQpO1xuXG4gICAgLy8gZG8gY2Fub25pY2FsaXphdGlvblxuICAgIHJldHVybiBjYW5vbml6ZS5jYW5vbml6ZShwYXJzZWRJbnB1dCwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IHRvIFJERiBkYXRhc2V0IHRoZW4gZG8gbm9ybWFsaXphdGlvblxuICBjb25zdCBvcHRzID0gey4uLm9wdGlvbnN9O1xuICBkZWxldGUgb3B0cy5mb3JtYXQ7XG4gIG9wdHMucHJvZHVjZUdlbmVyYWxpemVkUmRmID0gZmFsc2U7XG4gIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCBqc29ubGQudG9SREYoaW5wdXQsIG9wdHMpO1xuXG4gIC8vIGRvIGNhbm9uaWNhbGl6YXRpb25cbiAgcmV0dXJuIGNhbm9uaXplLmNhbm9uaXplKGRhdGFzZXQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSREYgZGF0YXNldCB0byBKU09OLUxELlxuICpcbiAqIEBwYXJhbSBkYXRhc2V0IGEgc2VyaWFsaXplZCBzdHJpbmcgb2YgUkRGIGluIGEgZm9ybWF0IHNwZWNpZmllZCBieSB0aGVcbiAqICAgICAgICAgIGZvcm1hdCBvcHRpb24gb3IgYW4gUkRGIGRhdGFzZXQgdG8gY29udmVydC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Zvcm1hdF0gdGhlIGZvcm1hdCBpZiBkYXRhc2V0IHBhcmFtIG11c3QgZmlyc3QgYmUgcGFyc2VkOlxuICogICAgICAgICAgICAnYXBwbGljYXRpb24vbi1xdWFkcycgZm9yIE4tUXVhZHMgKGRlZmF1bHQpLlxuICogICAgICAgICAgW3JkZlBhcnNlcl0gYSBjdXN0b20gUkRGLXBhcnNlciB0byB1c2UgdG8gcGFyc2UgdGhlIGRhdGFzZXQuXG4gKiAgICAgICAgICBbdXNlUmRmVHlwZV0gdHJ1ZSB0byB1c2UgcmRmOnR5cGUsIGZhbHNlIHRvIHVzZSBAdHlwZVxuICogICAgICAgICAgICAoZGVmYXVsdDogZmFsc2UpLlxuICogICAgICAgICAgW3VzZU5hdGl2ZVR5cGVzXSB0cnVlIHRvIGNvbnZlcnQgWFNEIHR5cGVzIGludG8gbmF0aXZlIHR5cGVzXG4gKiAgICAgICAgICAgIChib29sZWFuLCBpbnRlZ2VyLCBkb3VibGUpLCBmYWxzZSBub3QgdG8gKGRlZmF1bHQ6IGZhbHNlKS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBKU09OLUxEIGRvY3VtZW50LlxuICovXG5qc29ubGQuZnJvbVJERiA9IGFzeW5jIGZ1bmN0aW9uKGRhdGFzZXQsIG9wdGlvbnMpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgY29udmVydCBmcm9tIFJERiwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGZvcm1hdDogX2lzU3RyaW5nKGRhdGFzZXQpID8gJ2FwcGxpY2F0aW9uL24tcXVhZHMnIDogdW5kZWZpbmVkXG4gIH0pO1xuXG4gIGNvbnN0IHtmb3JtYXR9ID0gb3B0aW9ucztcbiAgbGV0IHtyZGZQYXJzZXJ9ID0gb3B0aW9ucztcblxuICAvLyBoYW5kbGUgc3BlY2lhbCBmb3JtYXRcbiAgaWYoZm9ybWF0KSB7XG4gICAgLy8gY2hlY2sgc3VwcG9ydGVkIGZvcm1hdHNcbiAgICByZGZQYXJzZXIgPSByZGZQYXJzZXIgfHwgX3JkZlBhcnNlcnNbZm9ybWF0XTtcbiAgICBpZighcmRmUGFyc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdVbmtub3duIGlucHV0IGZvcm1hdC4nLFxuICAgICAgICAnanNvbmxkLlVua25vd25Gb3JtYXQnLCB7Zm9ybWF0fSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG5vLW9wIHBhcnNlciwgYXNzdW1lIGRhdGFzZXQgYWxyZWFkeSBwYXJzZWRcbiAgICByZGZQYXJzZXIgPSAoKSA9PiBkYXRhc2V0O1xuICB9XG5cbiAgLy8gcmRmUGFyc2VyIG11c3QgYmUgc3luY2hyb25vdXMgb3IgcmV0dXJuIGEgcHJvbWlzZSwgbm8gY2FsbGJhY2sgc3VwcG9ydFxuICBjb25zdCBwYXJzZWREYXRhc2V0ID0gYXdhaXQgcmRmUGFyc2VyKGRhdGFzZXQpO1xuICByZXR1cm4gX2Zyb21SREYocGFyc2VkRGF0YXNldCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIE91dHB1dHMgdGhlIFJERiBkYXRhc2V0IGZvdW5kIGluIHRoZSBnaXZlbiBKU09OLUxEIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIEpTT04tTEQgaW5wdXQuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtiYXNlXSB0aGUgYmFzZSBJUkkgdG8gdXNlLlxuICogICAgICAgICAgW2V4cGFuZENvbnRleHRdIGEgY29udGV4dCB0byBleHBhbmQgd2l0aC5cbiAqICAgICAgICAgIFtza2lwRXhwYW5zaW9uXSB0cnVlIHRvIGFzc3VtZSB0aGUgaW5wdXQgaXMgZXhwYW5kZWQgYW5kIHNraXBcbiAqICAgICAgICAgICAgZXhwYW5zaW9uLCBmYWxzZSBub3QgdG8sIGRlZmF1bHRzIHRvIGZhbHNlLlxuICogICAgICAgICAgW2Zvcm1hdF0gdGhlIGZvcm1hdCB0byB1c2UgdG8gb3V0cHV0IGEgc3RyaW5nOlxuICogICAgICAgICAgICAnYXBwbGljYXRpb24vbi1xdWFkcycgZm9yIE4tUXVhZHMuXG4gKiAgICAgICAgICBbcHJvZHVjZUdlbmVyYWxpemVkUmRmXSB0cnVlIHRvIG91dHB1dCBnZW5lcmFsaXplZCBSREYsIGZhbHNlXG4gKiAgICAgICAgICAgIHRvIHByb2R1Y2Ugb25seSBzdGFuZGFyZCBSREYgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICAgIFtkb2N1bWVudExvYWRlcih1cmwsIG9wdGlvbnMpXSB0aGUgZG9jdW1lbnQgbG9hZGVyLlxuICogICAgICAgICAgW2NvbnRleHRSZXNvbHZlcl0gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgUkRGIGRhdGFzZXQuXG4gKi9cbmpzb25sZC50b1JERiA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgdG8gUkRGLCB0b28gZmV3IGFyZ3VtZW50cy4nKTtcbiAgfVxuXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgYmFzZTogX2lzU3RyaW5nKGlucHV0KSA/IGlucHV0IDogJycsXG4gICAgc2tpcEV4cGFuc2lvbjogZmFsc2UsXG4gICAgY29udGV4dFJlc29sdmVyOiBuZXcgQ29udGV4dFJlc29sdmVyKFxuICAgICAge3NoYXJlZENhY2hlOiBfcmVzb2x2ZWRDb250ZXh0Q2FjaGV9KVxuICB9KTtcblxuICAvLyBUT0RPOiBzdXBwb3J0IHRvUkRGIGN1c3RvbSBtYXA/XG4gIGxldCBleHBhbmRlZDtcbiAgaWYob3B0aW9ucy5za2lwRXhwYW5zaW9uKSB7XG4gICAgZXhwYW5kZWQgPSBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICAvLyBleHBhbmQgaW5wdXRcbiAgICBleHBhbmRlZCA9IGF3YWl0IGpzb25sZC5leHBhbmQoaW5wdXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gb3V0cHV0IFJERiBkYXRhc2V0XG4gIGNvbnN0IGRhdGFzZXQgPSBfdG9SREYoZXhwYW5kZWQsIG9wdGlvbnMpO1xuICBpZihvcHRpb25zLmZvcm1hdCkge1xuICAgIGlmKG9wdGlvbnMuZm9ybWF0ID09PSAnYXBwbGljYXRpb24vbi1xdWFkcycgfHxcbiAgICAgIG9wdGlvbnMuZm9ybWF0ID09PSAnYXBwbGljYXRpb24vbnF1YWRzJykge1xuICAgICAgcmV0dXJuIGF3YWl0IE5RdWFkcy5zZXJpYWxpemUoZGF0YXNldCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdVbmtub3duIG91dHB1dCBmb3JtYXQuJyxcbiAgICAgICdqc29ubGQuVW5rbm93bkZvcm1hdCcsIHtmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0fSk7XG4gIH1cblxuICByZXR1cm4gZGF0YXNldDtcbn07XG5cbi8qKlxuICogKipFeHBlcmltZW50YWwqKlxuICpcbiAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZSBub2RlcyBpbiB0aGUgZ2l2ZW4gSlNPTi1MRCBpbnB1dCBpbnRvIGEgbWVyZ2VkXG4gKiBtYXAgb2Ygbm9kZSBJRCA9PiBub2RlLiBBbGwgZ3JhcGhzIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIGRlZmF1bHQgZ3JhcGguXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGlucHV0LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBbaXNzdWVyXSBhIGpzb25sZC5JZGVudGlmaWVySXNzdWVyIHRvIHVzZSB0byBsYWJlbCBibGFuayBub2Rlcy5cbiAqICAgICAgICAgIFtkb2N1bWVudExvYWRlcih1cmwsIG9wdGlvbnMpXSB0aGUgZG9jdW1lbnQgbG9hZGVyLlxuICogICAgICAgICAgW2NvbnRleHRSZXNvbHZlcl0gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbWVyZ2VkIG5vZGUgbWFwLlxuICovXG5qc29ubGQuY3JlYXRlTm9kZU1hcCA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGNyZWF0ZSBub2RlIG1hcCwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG5cbiAgLy8gZXhwYW5kIGlucHV0XG4gIGNvbnN0IGV4cGFuZGVkID0gYXdhaXQganNvbmxkLmV4cGFuZChpbnB1dCwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIF9jcmVhdGVNZXJnZWROb2RlTWFwKGV4cGFuZGVkLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogKipFeHBlcmltZW50YWwqKlxuICpcbiAqIE1lcmdlcyB0d28gb3IgbW9yZSBKU09OLUxEIGRvY3VtZW50cyBpbnRvIGEgc2luZ2xlIGZsYXR0ZW5lZCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0gZG9jcyB0aGUgSlNPTi1MRCBkb2N1bWVudHMgdG8gbWVyZ2UgdG9nZXRoZXIuXG4gKiBAcGFyYW0gY3R4IHRoZSBjb250ZXh0IHRvIHVzZSB0byBjb21wYWN0IHRoZSBtZXJnZWQgcmVzdWx0LCBvciBudWxsLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBbaXNzdWVyXSBhIGpzb25sZC5JZGVudGlmaWVySXNzdWVyIHRvIHVzZSB0byBsYWJlbCBibGFuayBub2Rlcy5cbiAqICAgICAgICAgIFttZXJnZU5vZGVzXSB0cnVlIHRvIG1lcmdlIHByb3BlcnRpZXMgZm9yIG5vZGVzIHdpdGggdGhlIHNhbWUgSUQsXG4gKiAgICAgICAgICAgIGZhbHNlIHRvIGlnbm9yZSBuZXcgcHJvcGVydGllcyBmb3Igbm9kZXMgd2l0aCB0aGUgc2FtZSBJRCBvbmNlXG4gKiAgICAgICAgICAgIHRoZSBJRCBoYXMgYmVlbiBkZWZpbmVkOyBub3RlIHRoYXQgdGhpcyBtYXkgbm90IHByZXZlbnQgbWVyZ2luZ1xuICogICAgICAgICAgICBuZXcgcHJvcGVydGllcyB3aGVyZSBhIG5vZGUgaXMgaW4gdGhlIGBvYmplY3RgIHBvc2l0aW9uXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiB0cnVlKS5cbiAqICAgICAgICAgIFtkb2N1bWVudExvYWRlcih1cmwsIG9wdGlvbnMpXSB0aGUgZG9jdW1lbnQgbG9hZGVyLlxuICogICAgICAgICAgW2NvbnRleHRSZXNvbHZlcl0gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbWVyZ2VkIG91dHB1dC5cbiAqL1xuanNvbmxkLm1lcmdlID0gYXN5bmMgZnVuY3Rpb24oZG9jcywgY3R4LCBvcHRpb25zKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IG1lcmdlLCB0b28gZmV3IGFyZ3VtZW50cy4nKTtcbiAgfVxuICBpZighX2lzQXJyYXkoZG9jcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgbWVyZ2UsIFwiZG9jc1wiIG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gIH1cblxuICBpZih0eXBlb2YgY3R4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY3R4ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBjdHggPSBjdHggfHwgbnVsbDtcbiAgfVxuXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgY29udGV4dFJlc29sdmVyOiBuZXcgQ29udGV4dFJlc29sdmVyKFxuICAgICAge3NoYXJlZENhY2hlOiBfcmVzb2x2ZWRDb250ZXh0Q2FjaGV9KVxuICB9KTtcblxuICAvLyBleHBhbmQgYWxsIGRvY3VtZW50c1xuICBjb25zdCBleHBhbmRlZCA9IGF3YWl0IFByb21pc2UuYWxsKGRvY3MubWFwKGRvYyA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHsuLi5vcHRpb25zfTtcbiAgICByZXR1cm4ganNvbmxkLmV4cGFuZChkb2MsIG9wdHMpO1xuICB9KSk7XG5cbiAgbGV0IG1lcmdlTm9kZXMgPSB0cnVlO1xuICBpZignbWVyZ2VOb2RlcycgaW4gb3B0aW9ucykge1xuICAgIG1lcmdlTm9kZXMgPSBvcHRpb25zLm1lcmdlTm9kZXM7XG4gIH1cblxuICBjb25zdCBpc3N1ZXIgPSBvcHRpb25zLmlzc3VlciB8fCBuZXcgSWRlbnRpZmllcklzc3VlcignXzpiJyk7XG4gIGNvbnN0IGdyYXBocyA9IHsnQGRlZmF1bHQnOiB7fX07XG5cbiAgZm9yKGxldCBpID0gMDsgaSA8IGV4cGFuZGVkLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gdW5pcXVlbHkgcmVsYWJlbCBibGFuayBub2Rlc1xuICAgIGNvbnN0IGRvYyA9IHV0aWwucmVsYWJlbEJsYW5rTm9kZXMoZXhwYW5kZWRbaV0sIHtcbiAgICAgIGlzc3VlcjogbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YicgKyBpICsgJy0nKVxuICAgIH0pO1xuXG4gICAgLy8gYWRkIG5vZGVzIHRvIHRoZSBzaGFyZWQgbm9kZSBtYXAgZ3JhcGhzIGlmIG1lcmdpbmcgbm9kZXMsIHRvIGFcbiAgICAvLyBzZXBhcmF0ZSBncmFwaCBzZXQgaWYgbm90XG4gICAgY29uc3QgX2dyYXBocyA9IChtZXJnZU5vZGVzIHx8IGkgPT09IDApID8gZ3JhcGhzIDogeydAZGVmYXVsdCc6IHt9fTtcbiAgICBfY3JlYXRlTm9kZU1hcChkb2MsIF9ncmFwaHMsICdAZGVmYXVsdCcsIGlzc3Vlcik7XG5cbiAgICBpZihfZ3JhcGhzICE9PSBncmFwaHMpIHtcbiAgICAgIC8vIG1lcmdlIGRvY3VtZW50IGdyYXBocyBidXQgZG9uJ3QgbWVyZ2UgZXhpc3Rpbmcgbm9kZXNcbiAgICAgIGZvcihjb25zdCBncmFwaE5hbWUgaW4gX2dyYXBocykge1xuICAgICAgICBjb25zdCBfbm9kZU1hcCA9IF9ncmFwaHNbZ3JhcGhOYW1lXTtcbiAgICAgICAgaWYoIShncmFwaE5hbWUgaW4gZ3JhcGhzKSkge1xuICAgICAgICAgIGdyYXBoc1tncmFwaE5hbWVdID0gX25vZGVNYXA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IGdyYXBoc1tncmFwaE5hbWVdO1xuICAgICAgICBmb3IoY29uc3Qga2V5IGluIF9ub2RlTWFwKSB7XG4gICAgICAgICAgaWYoIShrZXkgaW4gbm9kZU1hcCkpIHtcbiAgICAgICAgICAgIG5vZGVNYXBba2V5XSA9IF9ub2RlTWFwW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIGFsbCBub24tZGVmYXVsdCBncmFwaHMgdG8gZGVmYXVsdCBncmFwaFxuICBjb25zdCBkZWZhdWx0R3JhcGggPSBfbWVyZ2VOb2RlTWFwcyhncmFwaHMpO1xuXG4gIC8vIHByb2R1Y2UgZmxhdHRlbmVkIG91dHB1dFxuICBjb25zdCBmbGF0dGVuZWQgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRHcmFwaCkuc29ydCgpO1xuICBmb3IobGV0IGtpID0gMDsga2kgPCBrZXlzLmxlbmd0aDsgKytraSkge1xuICAgIGNvbnN0IG5vZGUgPSBkZWZhdWx0R3JhcGhba2V5c1traV1dO1xuICAgIC8vIG9ubHkgYWRkIGZ1bGwgc3ViamVjdHMgdG8gdG9wLWxldmVsXG4gICAgaWYoIV9pc1N1YmplY3RSZWZlcmVuY2Uobm9kZSkpIHtcbiAgICAgIGZsYXR0ZW5lZC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmKGN0eCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gIH1cblxuICAvLyBjb21wYWN0IHJlc3VsdCAoZm9yY2UgQGdyYXBoIG9wdGlvbiB0byB0cnVlLCBza2lwIGV4cGFuc2lvbilcbiAgb3B0aW9ucy5ncmFwaCA9IHRydWU7XG4gIG9wdGlvbnMuc2tpcEV4cGFuc2lvbiA9IHRydWU7XG4gIGNvbnN0IGNvbXBhY3RlZCA9IGF3YWl0IGpzb25sZC5jb21wYWN0KGZsYXR0ZW5lZCwgY3R4LCBvcHRpb25zKTtcblxuICByZXR1cm4gY29tcGFjdGVkO1xufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBkb2N1bWVudCBsb2FkZXIgZm9yIGV4dGVybmFsIGRvY3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gdXJsIHRoZSBVUkwgdG8gbG9hZC5cbiAqXG4gKiBAcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZW1vdGUgZG9jdW1lbnQuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShqc29ubGQsICdkb2N1bWVudExvYWRlcicsIHtcbiAgZ2V0OiAoKSA9PiBqc29ubGQuX2RvY3VtZW50TG9hZGVyLFxuICBzZXQ6IHYgPT4ganNvbmxkLl9kb2N1bWVudExvYWRlciA9IHZcbn0pO1xuLy8gZGVmYXVsdCBkb2N1bWVudCBsb2FkZXIgbm90IGltcGxlbWVudGVkXG5qc29ubGQuZG9jdW1lbnRMb2FkZXIgPSBhc3luYyB1cmwgPT4ge1xuICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgJ0NvdWxkIG5vdCByZXRyaWV2ZSBhIEpTT04tTEQgZG9jdW1lbnQgZnJvbSB0aGUgVVJMLiBVUkwgJyArXG4gICAgJ2RlcmVmZXJlbmNpbmcgbm90IGltcGxlbWVudGVkLicsICdqc29ubGQuTG9hZERvY3VtZW50RXJyb3InLFxuICAgIHtjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLCB1cmx9KTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHJlbW90ZSBKU09OLUxEIGRvY3VtZW50IHVzaW5nIHRoZSBkZWZhdWx0IGRvY3VtZW50IGxvYWRlciBvclxuICogb25lIGdpdmVuIGluIHRoZSBwYXNzZWQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gdXJsIHRoZSBVUkwgdG8gZmV0Y2guXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtkb2N1bWVudExvYWRlcl0gdGhlIGRvY3VtZW50IGxvYWRlciB0byB1c2UuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmV0cmlldmVkIHJlbW90ZSBkb2N1bWVudC5cbiAqL1xuanNvbmxkLmdldCA9IGFzeW5jIGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICBsZXQgbG9hZDtcbiAgaWYodHlwZW9mIG9wdGlvbnMuZG9jdW1lbnRMb2FkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBsb2FkID0gb3B0aW9ucy5kb2N1bWVudExvYWRlcjtcbiAgfSBlbHNlIHtcbiAgICBsb2FkID0ganNvbmxkLmRvY3VtZW50TG9hZGVyO1xuICB9XG5cbiAgY29uc3QgcmVtb3RlRG9jID0gYXdhaXQgbG9hZCh1cmwpO1xuXG4gIHRyeSB7XG4gICAgaWYoIXJlbW90ZURvYy5kb2N1bWVudCkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnTm8gcmVtb3RlIGRvY3VtZW50IGZvdW5kIGF0IHRoZSBnaXZlbiBVUkwuJyxcbiAgICAgICAgJ2pzb25sZC5OdWxsUmVtb3RlRG9jdW1lbnQnKTtcbiAgICB9XG4gICAgaWYoX2lzU3RyaW5nKHJlbW90ZURvYy5kb2N1bWVudCkpIHtcbiAgICAgIHJlbW90ZURvYy5kb2N1bWVudCA9IEpTT04ucGFyc2UocmVtb3RlRG9jLmRvY3VtZW50KTtcbiAgICB9XG4gIH0gY2F0Y2goZSkge1xuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdDb3VsZCBub3QgcmV0cmlldmUgYSBKU09OLUxEIGRvY3VtZW50IGZyb20gdGhlIFVSTC4nLFxuICAgICAgJ2pzb25sZC5Mb2FkRG9jdW1lbnRFcnJvcicsIHtcbiAgICAgICAgY29kZTogJ2xvYWRpbmcgZG9jdW1lbnQgZmFpbGVkJyxcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICAgIHJlbW90ZURvY1xuICAgICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVtb3RlRG9jO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgYSBsb2NhbCBjb250ZXh0LCByZXNvbHZpbmcgYW55IFVSTHMgYXMgbmVjZXNzYXJ5LCBhbmQgcmV0dXJucyBhXG4gKiBuZXcgYWN0aXZlIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY3VycmVudCBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSBsb2NhbEN0eCB0aGUgbG9jYWwgY29udGV4dCB0byBwcm9jZXNzLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5ldyBhY3RpdmUgY29udGV4dC5cbiAqL1xuanNvbmxkLnByb2Nlc3NDb250ZXh0ID0gYXN5bmMgZnVuY3Rpb24oXG4gIGFjdGl2ZUN0eCwgbG9jYWxDdHgsIG9wdGlvbnMpIHtcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBiYXNlOiAnJyxcbiAgICBjb250ZXh0UmVzb2x2ZXI6IG5ldyBDb250ZXh0UmVzb2x2ZXIoXG4gICAgICB7c2hhcmVkQ2FjaGU6IF9yZXNvbHZlZENvbnRleHRDYWNoZX0pXG4gIH0pO1xuXG4gIC8vIHJldHVybiBpbml0aWFsIGNvbnRleHQgZWFybHkgZm9yIG51bGwgY29udGV4dFxuICBpZihsb2NhbEN0eCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBfZ2V0SW5pdGlhbENvbnRleHQob3B0aW9ucyk7XG4gIH1cblxuICAvLyBnZXQgVVJMcyBpbiBsb2NhbEN0eFxuICBsb2NhbEN0eCA9IHV0aWwuY2xvbmUobG9jYWxDdHgpO1xuICBpZighKF9pc09iamVjdChsb2NhbEN0eCkgJiYgJ0Bjb250ZXh0JyBpbiBsb2NhbEN0eCkpIHtcbiAgICBsb2NhbEN0eCA9IHsnQGNvbnRleHQnOiBsb2NhbEN0eH07XG4gIH1cblxuICByZXR1cm4gX3Byb2Nlc3NDb250ZXh0KHthY3RpdmVDdHgsIGxvY2FsQ3R4LCBvcHRpb25zfSk7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuanNvbmxkLmdldENvbnRleHRWYWx1ZSA9IHJlcXVpcmUoJy4vY29udGV4dCcpLmdldENvbnRleHRWYWx1ZTtcblxuLyoqXG4gKiBEb2N1bWVudCBsb2FkZXJzLlxuICovXG5qc29ubGQuZG9jdW1lbnRMb2FkZXJzID0ge307XG5qc29ubGQuZG9jdW1lbnRMb2FkZXJzLm5vZGUgPSByZXF1aXJlKCcuL2RvY3VtZW50TG9hZGVycy9ub2RlJyk7XG5qc29ubGQuZG9jdW1lbnRMb2FkZXJzLnhociA9IHJlcXVpcmUoJy4vZG9jdW1lbnRMb2FkZXJzL3hocicpO1xuXG4vKipcbiAqIEFzc2lnbnMgdGhlIGRlZmF1bHQgZG9jdW1lbnQgbG9hZGVyIGZvciBleHRlcm5hbCBkb2N1bWVudCBVUkxzIHRvIGEgYnVpbHQtaW5cbiAqIGRlZmF1bHQuIFN1cHBvcnRlZCB0eXBlcyBjdXJyZW50bHkgaW5jbHVkZTogJ3hocicgYW5kICdub2RlJy5cbiAqXG4gKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSB0byBzZXQuXG4gKiBAcGFyYW0gW3BhcmFtc10gdGhlIHBhcmFtZXRlcnMgcmVxdWlyZWQgdG8gdXNlIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKi9cbmpzb25sZC51c2VEb2N1bWVudExvYWRlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYoISh0eXBlIGluIGpzb25sZC5kb2N1bWVudExvYWRlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgJ1Vua25vd24gZG9jdW1lbnQgbG9hZGVyIHR5cGU6IFwiJyArIHR5cGUgKyAnXCInLFxuICAgICAgJ2pzb25sZC5Vbmtub3duRG9jdW1lbnRMb2FkZXInLFxuICAgICAge3R5cGV9KTtcbiAgfVxuXG4gIC8vIHNldCBkb2N1bWVudCBsb2FkZXJcbiAganNvbmxkLmRvY3VtZW50TG9hZGVyID0ganNvbmxkLmRvY3VtZW50TG9hZGVyc1t0eXBlXS5hcHBseShcbiAgICBqc29ubGQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gUkRGIGRhdGFzZXQgcGFyc2VyIGJ5IGNvbnRlbnQtdHlwZSwgZm9yIHVzZSB3aXRoXG4gKiBqc29ubGQuZnJvbVJERi4gQW4gUkRGIGRhdGFzZXQgcGFyc2VyIHdpbGwgYWx3YXlzIGJlIGdpdmVuIG9uZSBwYXJhbWV0ZXIsXG4gKiBhIHN0cmluZyBvZiBpbnB1dC4gQW4gUkRGIGRhdGFzZXQgcGFyc2VyIGNhbiBiZSBzeW5jaHJvbm91cyBvclxuICogYXN5bmNocm9ub3VzIChieSByZXR1cm5pbmcgYSBwcm9taXNlKS5cbiAqXG4gKiBAcGFyYW0gY29udGVudFR5cGUgdGhlIGNvbnRlbnQtdHlwZSBmb3IgdGhlIHBhcnNlci5cbiAqIEBwYXJhbSBwYXJzZXIoaW5wdXQpIHRoZSBwYXJzZXIgZnVuY3Rpb24gKHRha2VzIGEgc3RyaW5nIGFzIGEgcGFyYW1ldGVyXG4gKiAgICAgICAgICBhbmQgZWl0aGVyIHJldHVybnMgYW4gUkRGIGRhdGFzZXQgb3IgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gb25lLlxuICovXG5qc29ubGQucmVnaXN0ZXJSREZQYXJzZXIgPSBmdW5jdGlvbihjb250ZW50VHlwZSwgcGFyc2VyKSB7XG4gIF9yZGZQYXJzZXJzW2NvbnRlbnRUeXBlXSA9IHBhcnNlcjtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlcnMgYW4gUkRGIGRhdGFzZXQgcGFyc2VyIGJ5IGNvbnRlbnQtdHlwZS5cbiAqXG4gKiBAcGFyYW0gY29udGVudFR5cGUgdGhlIGNvbnRlbnQtdHlwZSBmb3IgdGhlIHBhcnNlci5cbiAqL1xuanNvbmxkLnVucmVnaXN0ZXJSREZQYXJzZXIgPSBmdW5jdGlvbihjb250ZW50VHlwZSkge1xuICBkZWxldGUgX3JkZlBhcnNlcnNbY29udGVudFR5cGVdO1xufTtcblxuLy8gcmVnaXN0ZXIgdGhlIE4tUXVhZHMgUkRGIHBhcnNlclxuanNvbmxkLnJlZ2lzdGVyUkRGUGFyc2VyKCdhcHBsaWNhdGlvbi9uLXF1YWRzJywgTlF1YWRzLnBhcnNlKTtcbmpzb25sZC5yZWdpc3RlclJERlBhcnNlcignYXBwbGljYXRpb24vbnF1YWRzJywgTlF1YWRzLnBhcnNlKTtcblxuLy8gcmVnaXN0ZXIgdGhlIFJERmEgQVBJIFJERiBwYXJzZXJcbmpzb25sZC5yZWdpc3RlclJERlBhcnNlcigncmRmYS1hcGknLCBSZGZhLnBhcnNlKTtcblxuLyogVVJMIEFQSSAqL1xuanNvbmxkLnVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbi8qIFV0aWxpdHkgQVBJICovXG5qc29ubGQudXRpbCA9IHV0aWw7XG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuT2JqZWN0LmFzc2lnbihqc29ubGQsIHV0aWwpO1xuXG4vLyByZWV4cG9zZSBBUEkgYXMganNvbmxkLnByb21pc2VzIGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eVxuanNvbmxkLnByb21pc2VzID0ganNvbmxkO1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuanNvbmxkLlJlcXVlc3RRdWV1ZSA9IHJlcXVpcmUoJy4vUmVxdWVzdFF1ZXVlJyk7XG5cbi8qIFdlYklETCBBUEkgKi9cbmpzb25sZC5Kc29uTGRQcm9jZXNzb3IgPSByZXF1aXJlKCcuL0pzb25MZFByb2Nlc3NvcicpKGpzb25sZCk7XG5cbi8vIHNldHVwIGJyb3dzZXIgZ2xvYmFsIEpzb25MZFByb2Nlc3NvclxuaWYoX2Jyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbC5Kc29uTGRQcm9jZXNzb3IgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsICdKc29uTGRQcm9jZXNzb3InLCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBqc29ubGQuSnNvbkxkUHJvY2Vzc29yXG4gIH0pO1xufVxuXG4vLyBzZXQgcGxhdGZvcm0tc3BlY2lmaWMgZGVmYXVsdHMvQVBJc1xuaWYoX25vZGVqcykge1xuICAvLyB1c2Ugbm9kZSBkb2N1bWVudCBsb2FkZXIgYnkgZGVmYXVsdFxuICBqc29ubGQudXNlRG9jdW1lbnRMb2FkZXIoJ25vZGUnKTtcbn0gZWxzZSBpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIHVzZSB4aHIgZG9jdW1lbnQgbG9hZGVyIGJ5IGRlZmF1bHRcbiAganNvbmxkLnVzZURvY3VtZW50TG9hZGVyKCd4aHInKTtcbn1cblxuZnVuY3Rpb24gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgZG9jdW1lbnRMb2FkZXIgPSBqc29ubGQuZG9jdW1lbnRMb2FkZXIsXG4gIC4uLmRlZmF1bHRzXG59KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB7ZG9jdW1lbnRMb2FkZXJ9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5cbi8vIGVuZCBvZiBqc29ubGQgQVBJIGB3cmFwcGVyYCBmYWN0b3J5XG5yZXR1cm4ganNvbmxkO1xufTtcblxuLy8gZXh0ZXJuYWwgQVBJczpcblxuLy8gdXNlZCB0byBnZW5lcmF0ZSBhIG5ldyBqc29ubGQgQVBJIGluc3RhbmNlXG5jb25zdCBmYWN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB3cmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmYWN0b3J5KCk7XG4gIH0pO1xufTtcblxuLy8gd3JhcCB0aGUgbWFpbiBqc29ubGQgQVBJIGluc3RhbmNlXG53cmFwcGVyKGZhY3RvcnkpO1xuLy8gZXhwb3J0IEFQSVxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtpc0tleXdvcmR9ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG5jb25zdCBncmFwaFR5cGVzID0gcmVxdWlyZSgnLi9ncmFwaFR5cGVzJyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IEpzb25MZEVycm9yID0gcmVxdWlyZSgnLi9Kc29uTGRFcnJvcicpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtZXJnZWQgSlNPTi1MRCBub2RlIG1hcCAobm9kZSBJRCA9PiBub2RlKS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGV4cGFuZGVkIEpTT04tTEQgdG8gY3JlYXRlIGEgbm9kZSBtYXAgb2YuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtpc3N1ZXJdIGEganNvbmxkLklkZW50aWZpZXJJc3N1ZXIgdG8gdXNlIHRvIGxhYmVsIGJsYW5rIG5vZGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIG5vZGUgbWFwLlxuICovXG5hcGkuY3JlYXRlTWVyZ2VkTm9kZU1hcCA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBwcm9kdWNlIGEgbWFwIG9mIGFsbCBzdWJqZWN0cyBhbmQgbmFtZSBlYWNoIGJub2RlXG4gIGNvbnN0IGlzc3VlciA9IG9wdGlvbnMuaXNzdWVyIHx8IG5ldyB1dGlsLklkZW50aWZpZXJJc3N1ZXIoJ186YicpO1xuICBjb25zdCBncmFwaHMgPSB7J0BkZWZhdWx0Jzoge319O1xuICBhcGkuY3JlYXRlTm9kZU1hcChpbnB1dCwgZ3JhcGhzLCAnQGRlZmF1bHQnLCBpc3N1ZXIpO1xuXG4gIC8vIGFkZCBhbGwgbm9uLWRlZmF1bHQgZ3JhcGhzIHRvIGRlZmF1bHQgZ3JhcGhcbiAgcmV0dXJuIGFwaS5tZXJnZU5vZGVNYXBzKGdyYXBocyk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZSBzdWJqZWN0cyBpbiB0aGUgZ2l2ZW4gSlNPTi1MRCBleHBhbmRlZCBpbnB1dFxuICogaW50byBhIG5vZGUgbWFwLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgSlNPTi1MRCBleHBhbmRlZCBpbnB1dC5cbiAqIEBwYXJhbSBncmFwaHMgYSBtYXAgb2YgZ3JhcGggbmFtZSB0byBzdWJqZWN0IG1hcC5cbiAqIEBwYXJhbSBncmFwaCB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBncmFwaC5cbiAqIEBwYXJhbSBpc3N1ZXIgdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpc3N1ZXIuXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBhc3NpZ25lZCB0byB0aGUgY3VycmVudCBpbnB1dCBpZiBpdCBpcyBhIGJub2RlLlxuICogQHBhcmFtIGxpc3QgdGhlIGxpc3QgdG8gYXBwZW5kIHRvLCBudWxsIGZvciBub25lLlxuICovXG5hcGkuY3JlYXRlTm9kZU1hcCA9IChpbnB1dCwgZ3JhcGhzLCBncmFwaCwgaXNzdWVyLCBuYW1lLCBsaXN0KSA9PiB7XG4gIC8vIHJlY3Vyc2UgdGhyb3VnaCBhcnJheVxuICBpZih0eXBlcy5pc0FycmF5KGlucHV0KSkge1xuICAgIGZvcihjb25zdCBub2RlIG9mIGlucHV0KSB7XG4gICAgICBhcGkuY3JlYXRlTm9kZU1hcChub2RlLCBncmFwaHMsIGdyYXBoLCBpc3N1ZXIsIHVuZGVmaW5lZCwgbGlzdCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGFkZCBub24tb2JqZWN0IHRvIGxpc3RcbiAgaWYoIXR5cGVzLmlzT2JqZWN0KGlucHV0KSkge1xuICAgIGlmKGxpc3QpIHtcbiAgICAgIGxpc3QucHVzaChpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGFkZCB2YWx1ZXMgdG8gbGlzdFxuICBpZihncmFwaFR5cGVzLmlzVmFsdWUoaW5wdXQpKSB7XG4gICAgaWYoJ0B0eXBlJyBpbiBpbnB1dCkge1xuICAgICAgbGV0IHR5cGUgPSBpbnB1dFsnQHR5cGUnXTtcbiAgICAgIC8vIHJlbmFtZSBAdHlwZSBibGFuayBub2RlXG4gICAgICBpZih0eXBlLmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgICAgaW5wdXRbJ0B0eXBlJ10gPSB0eXBlID0gaXNzdWVyLmdldElkKHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihsaXN0KSB7XG4gICAgICBsaXN0LnB1c2goaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZihsaXN0ICYmIGdyYXBoVHlwZXMuaXNMaXN0KGlucHV0KSkge1xuICAgIGNvbnN0IF9saXN0ID0gW107XG4gICAgYXBpLmNyZWF0ZU5vZGVNYXAoaW5wdXRbJ0BsaXN0J10sIGdyYXBocywgZ3JhcGgsIGlzc3VlciwgbmFtZSwgX2xpc3QpO1xuICAgIGxpc3QucHVzaCh7J0BsaXN0JzogX2xpc3R9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb3RlOiBBdCB0aGlzIHBvaW50LCBpbnB1dCBtdXN0IGJlIGEgc3ViamVjdC5cblxuICAvLyBzcGVjIHJlcXVpcmVzIEB0eXBlIHRvIGJlIG5hbWVkIGZpcnN0LCBzbyBhc3NpZ24gbmFtZXMgZWFybHlcbiAgaWYoJ0B0eXBlJyBpbiBpbnB1dCkge1xuICAgIGNvbnN0IHR5cGVzID0gaW5wdXRbJ0B0eXBlJ107XG4gICAgZm9yKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgIGlmKHR5cGUuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgICBpc3N1ZXIuZ2V0SWQodHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZ2V0IG5hbWUgZm9yIHN1YmplY3RcbiAgaWYodHlwZXMuaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBuYW1lID0gZ3JhcGhUeXBlcy5pc0JsYW5rTm9kZShpbnB1dCkgP1xuICAgICAgaXNzdWVyLmdldElkKGlucHV0WydAaWQnXSkgOiBpbnB1dFsnQGlkJ107XG4gIH1cblxuICAvLyBhZGQgc3ViamVjdCByZWZlcmVuY2UgdG8gbGlzdFxuICBpZihsaXN0KSB7XG4gICAgbGlzdC5wdXNoKHsnQGlkJzogbmFtZX0pO1xuICB9XG5cbiAgLy8gY3JlYXRlIG5ldyBzdWJqZWN0IG9yIG1lcmdlIGludG8gZXhpc3Rpbmcgb25lXG4gIGNvbnN0IHN1YmplY3RzID0gZ3JhcGhzW2dyYXBoXTtcbiAgY29uc3Qgc3ViamVjdCA9IHN1YmplY3RzW25hbWVdID0gc3ViamVjdHNbbmFtZV0gfHwge307XG4gIHN1YmplY3RbJ0BpZCddID0gbmFtZTtcbiAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKGlucHV0KS5zb3J0KCk7XG4gIGZvcihsZXQgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgIC8vIHNraXAgQGlkXG4gICAgaWYocHJvcGVydHkgPT09ICdAaWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcmV2ZXJzZSBwcm9wZXJ0aWVzXG4gICAgaWYocHJvcGVydHkgPT09ICdAcmV2ZXJzZScpIHtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZWROb2RlID0geydAaWQnOiBuYW1lfTtcbiAgICAgIGNvbnN0IHJldmVyc2VNYXAgPSBpbnB1dFsnQHJldmVyc2UnXTtcbiAgICAgIGZvcihjb25zdCByZXZlcnNlUHJvcGVydHkgaW4gcmV2ZXJzZU1hcCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHJldmVyc2VNYXBbcmV2ZXJzZVByb3BlcnR5XTtcbiAgICAgICAgZm9yKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICBsZXQgaXRlbU5hbWUgPSBpdGVtWydAaWQnXTtcbiAgICAgICAgICBpZihncmFwaFR5cGVzLmlzQmxhbmtOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtTmFtZSA9IGlzc3Vlci5nZXRJZChpdGVtTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFwaS5jcmVhdGVOb2RlTWFwKGl0ZW0sIGdyYXBocywgZ3JhcGgsIGlzc3VlciwgaXRlbU5hbWUpO1xuICAgICAgICAgIHV0aWwuYWRkVmFsdWUoXG4gICAgICAgICAgICBzdWJqZWN0c1tpdGVtTmFtZV0sIHJldmVyc2VQcm9wZXJ0eSwgcmVmZXJlbmNlZE5vZGUsXG4gICAgICAgICAgICB7cHJvcGVydHlJc0FycmF5OiB0cnVlLCBhbGxvd0R1cGxpY2F0ZTogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzZSBpbnRvIGdyYXBoXG4gICAgaWYocHJvcGVydHkgPT09ICdAZ3JhcGgnKSB7XG4gICAgICAvLyBhZGQgZ3JhcGggc3ViamVjdHMgbWFwIGVudHJ5XG4gICAgICBpZighKG5hbWUgaW4gZ3JhcGhzKSkge1xuICAgICAgICBncmFwaHNbbmFtZV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGFwaS5jcmVhdGVOb2RlTWFwKGlucHV0W3Byb3BlcnR5XSwgZ3JhcGhzLCBuYW1lLCBpc3N1ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzZSBpbnRvIGluY2x1ZGVkXG4gICAgaWYocHJvcGVydHkgPT09ICdAaW5jbHVkZWQnKSB7XG4gICAgICBhcGkuY3JlYXRlTm9kZU1hcChpbnB1dFtwcm9wZXJ0eV0sIGdyYXBocywgZ3JhcGgsIGlzc3Vlcik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb3B5IG5vbi1AdHlwZSBrZXl3b3Jkc1xuICAgIGlmKHByb3BlcnR5ICE9PSAnQHR5cGUnICYmIGlzS2V5d29yZChwcm9wZXJ0eSkpIHtcbiAgICAgIGlmKHByb3BlcnR5ID09PSAnQGluZGV4JyAmJiBwcm9wZXJ0eSBpbiBzdWJqZWN0ICYmXG4gICAgICAgIChpbnB1dFtwcm9wZXJ0eV0gIT09IHN1YmplY3RbcHJvcGVydHldIHx8XG4gICAgICAgIGlucHV0W3Byb3BlcnR5XVsnQGlkJ10gIT09IHN1YmplY3RbcHJvcGVydHldWydAaWQnXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBjb25mbGljdGluZyBAaW5kZXggcHJvcGVydHkgZGV0ZWN0ZWQuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2NvbmZsaWN0aW5nIGluZGV4ZXMnLCBzdWJqZWN0fSk7XG4gICAgICB9XG4gICAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IGlucHV0W3Byb3BlcnR5XTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBvYmplY3RzXG4gICAgY29uc3Qgb2JqZWN0cyA9IGlucHV0W3Byb3BlcnR5XTtcblxuICAgIC8vIGlmIHByb3BlcnR5IGlzIGEgYm5vZGUsIGFzc2lnbiBpdCBhIG5ldyBpZFxuICAgIGlmKHByb3BlcnR5LmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgIHByb3BlcnR5ID0gaXNzdWVyLmdldElkKHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgcHJvcGVydHkgaXMgYWRkZWQgZm9yIGVtcHR5IGFycmF5c1xuICAgIGlmKG9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB1dGlsLmFkZFZhbHVlKHN1YmplY3QsIHByb3BlcnR5LCBbXSwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvcihsZXQgbyBvZiBvYmplY3RzKSB7XG4gICAgICBpZihwcm9wZXJ0eSA9PT0gJ0B0eXBlJykge1xuICAgICAgICAvLyByZW5hbWUgQHR5cGUgYmxhbmsgbm9kZXNcbiAgICAgICAgbyA9IChvLmluZGV4T2YoJ186JykgPT09IDApID8gaXNzdWVyLmdldElkKG8pIDogbztcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIGVtYmVkZGVkIHN1YmplY3Qgb3Igc3ViamVjdCByZWZlcmVuY2VcbiAgICAgIGlmKGdyYXBoVHlwZXMuaXNTdWJqZWN0KG8pIHx8IGdyYXBoVHlwZXMuaXNTdWJqZWN0UmVmZXJlbmNlKG8pKSB7XG4gICAgICAgIC8vIHNraXAgbnVsbCBAaWRcbiAgICAgICAgaWYoJ0BpZCcgaW4gbyAmJiAhb1snQGlkJ10pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbGFiZWwgYmxhbmsgbm9kZSBAaWRcbiAgICAgICAgY29uc3QgaWQgPSBncmFwaFR5cGVzLmlzQmxhbmtOb2RlKG8pID9cbiAgICAgICAgICBpc3N1ZXIuZ2V0SWQob1snQGlkJ10pIDogb1snQGlkJ107XG5cbiAgICAgICAgLy8gYWRkIHJlZmVyZW5jZSBhbmQgcmVjdXJzZVxuICAgICAgICB1dGlsLmFkZFZhbHVlKFxuICAgICAgICAgIHN1YmplY3QsIHByb3BlcnR5LCB7J0BpZCc6IGlkfSxcbiAgICAgICAgICB7cHJvcGVydHlJc0FycmF5OiB0cnVlLCBhbGxvd0R1cGxpY2F0ZTogZmFsc2V9KTtcbiAgICAgICAgYXBpLmNyZWF0ZU5vZGVNYXAobywgZ3JhcGhzLCBncmFwaCwgaXNzdWVyLCBpZCk7XG4gICAgICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc1ZhbHVlKG8pKSB7XG4gICAgICAgIHV0aWwuYWRkVmFsdWUoXG4gICAgICAgICAgc3ViamVjdCwgcHJvcGVydHksIG8sXG4gICAgICAgICAge3Byb3BlcnR5SXNBcnJheTogdHJ1ZSwgYWxsb3dEdXBsaWNhdGU6IGZhbHNlfSk7XG4gICAgICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc0xpc3QobykpIHtcbiAgICAgICAgLy8gaGFuZGxlIEBsaXN0XG4gICAgICAgIGNvbnN0IF9saXN0ID0gW107XG4gICAgICAgIGFwaS5jcmVhdGVOb2RlTWFwKG9bJ0BsaXN0J10sIGdyYXBocywgZ3JhcGgsIGlzc3VlciwgbmFtZSwgX2xpc3QpO1xuICAgICAgICBvID0geydAbGlzdCc6IF9saXN0fTtcbiAgICAgICAgdXRpbC5hZGRWYWx1ZShcbiAgICAgICAgICBzdWJqZWN0LCBwcm9wZXJ0eSwgbyxcbiAgICAgICAgICB7cHJvcGVydHlJc0FycmF5OiB0cnVlLCBhbGxvd0R1cGxpY2F0ZTogZmFsc2V9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBAdmFsdWVcbiAgICAgICAgYXBpLmNyZWF0ZU5vZGVNYXAobywgZ3JhcGhzLCBncmFwaCwgaXNzdWVyLCBuYW1lKTtcbiAgICAgICAgdXRpbC5hZGRWYWx1ZShcbiAgICAgICAgICBzdWJqZWN0LCBwcm9wZXJ0eSwgbywge3Byb3BlcnR5SXNBcnJheTogdHJ1ZSwgYWxsb3dEdXBsaWNhdGU6IGZhbHNlfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1lcmdlIHNlcGFyYXRlIG5hbWVkIGdyYXBocyBpbnRvIGEgc2luZ2xlIG1lcmdlZCBncmFwaCBpbmNsdWRpbmdcbiAqIGFsbCBub2RlcyBmcm9tIHRoZSBkZWZhdWx0IGdyYXBoIGFuZCBuYW1lZCBncmFwaHMuXG4gKlxuICogQHBhcmFtIGdyYXBocyBhIG1hcCBvZiBncmFwaCBuYW1lIHRvIHN1YmplY3QgbWFwLlxuICpcbiAqIEByZXR1cm4gdGhlIG1lcmdlZCBncmFwaCBtYXAuXG4gKi9cbmFwaS5tZXJnZU5vZGVNYXBHcmFwaHMgPSBncmFwaHMgPT4ge1xuICBjb25zdCBtZXJnZWQgPSB7fTtcbiAgZm9yKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZ3JhcGhzKS5zb3J0KCkpIHtcbiAgICBmb3IoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMoZ3JhcGhzW25hbWVdKS5zb3J0KCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBncmFwaHNbbmFtZV1baWRdO1xuICAgICAgaWYoIShpZCBpbiBtZXJnZWQpKSB7XG4gICAgICAgIG1lcmdlZFtpZF0gPSB7J0BpZCc6IGlkfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lcmdlZE5vZGUgPSBtZXJnZWRbaWRdO1xuXG4gICAgICBmb3IoY29uc3QgcHJvcGVydHkgb2YgT2JqZWN0LmtleXMobm9kZSkuc29ydCgpKSB7XG4gICAgICAgIGlmKGlzS2V5d29yZChwcm9wZXJ0eSkgJiYgcHJvcGVydHkgIT09ICdAdHlwZScpIHtcbiAgICAgICAgICAvLyBjb3B5IGtleXdvcmRzXG4gICAgICAgICAgbWVyZ2VkTm9kZVtwcm9wZXJ0eV0gPSB1dGlsLmNsb25lKG5vZGVbcHJvcGVydHldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtZXJnZSBvYmplY3RzXG4gICAgICAgICAgZm9yKGNvbnN0IHZhbHVlIG9mIG5vZGVbcHJvcGVydHldKSB7XG4gICAgICAgICAgICB1dGlsLmFkZFZhbHVlKFxuICAgICAgICAgICAgICBtZXJnZWROb2RlLCBwcm9wZXJ0eSwgdXRpbC5jbG9uZSh2YWx1ZSksXG4gICAgICAgICAgICAgIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWUsIGFsbG93RHVwbGljYXRlOiBmYWxzZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXJnZWQ7XG59O1xuXG5hcGkubWVyZ2VOb2RlTWFwcyA9IGdyYXBocyA9PiB7XG4gIC8vIGFkZCBhbGwgbm9uLWRlZmF1bHQgZ3JhcGhzIHRvIGRlZmF1bHQgZ3JhcGhcbiAgY29uc3QgZGVmYXVsdEdyYXBoID0gZ3JhcGhzWydAZGVmYXVsdCddO1xuICBjb25zdCBncmFwaE5hbWVzID0gT2JqZWN0LmtleXMoZ3JhcGhzKS5zb3J0KCk7XG4gIGZvcihjb25zdCBncmFwaE5hbWUgb2YgZ3JhcGhOYW1lcykge1xuICAgIGlmKGdyYXBoTmFtZSA9PT0gJ0BkZWZhdWx0Jykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVNYXAgPSBncmFwaHNbZ3JhcGhOYW1lXTtcbiAgICBsZXQgc3ViamVjdCA9IGRlZmF1bHRHcmFwaFtncmFwaE5hbWVdO1xuICAgIGlmKCFzdWJqZWN0KSB7XG4gICAgICBkZWZhdWx0R3JhcGhbZ3JhcGhOYW1lXSA9IHN1YmplY3QgPSB7XG4gICAgICAgICdAaWQnOiBncmFwaE5hbWUsXG4gICAgICAgICdAZ3JhcGgnOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoISgnQGdyYXBoJyBpbiBzdWJqZWN0KSkge1xuICAgICAgc3ViamVjdFsnQGdyYXBoJ10gPSBbXTtcbiAgICB9XG4gICAgY29uc3QgZ3JhcGggPSBzdWJqZWN0WydAZ3JhcGgnXTtcbiAgICBmb3IoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMobm9kZU1hcCkuc29ydCgpKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZU1hcFtpZF07XG4gICAgICAvLyBvbmx5IGFkZCBmdWxsIHN1YmplY3RzXG4gICAgICBpZighZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2Uobm9kZSkpIHtcbiAgICAgICAgZ3JhcGgucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRHcmFwaDtcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qge2NyZWF0ZU5vZGVNYXB9ID0gcmVxdWlyZSgnLi9ub2RlTWFwJyk7XG5jb25zdCB7aXNLZXl3b3JkfSA9IHJlcXVpcmUoJy4vY29udGV4dCcpO1xuY29uc3QgZ3JhcGhUeXBlcyA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuY29uc3QganNvbkNhbm9uaWNhbGl6ZSA9IHJlcXVpcmUoJ2Nhbm9uaWNhbGl6ZScpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmNvbnN0IHtcbiAgLy8gUkRGLFxuICAvLyBSREZfTElTVCxcbiAgUkRGX0ZJUlNULFxuICBSREZfUkVTVCxcbiAgUkRGX05JTCxcbiAgUkRGX1RZUEUsXG4gIC8vIFJERl9QTEFJTl9MSVRFUkFMLFxuICAvLyBSREZfWE1MX0xJVEVSQUwsXG4gIFJERl9KU09OX0xJVEVSQUwsXG4gIC8vIFJERl9PQkpFQ1QsXG4gIFJERl9MQU5HU1RSSU5HLFxuXG4gIC8vIFhTRCxcbiAgWFNEX0JPT0xFQU4sXG4gIFhTRF9ET1VCTEUsXG4gIFhTRF9JTlRFR0VSLFxuICBYU0RfU1RSSU5HLFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IHtcbiAgaXNBYnNvbHV0ZTogX2lzQWJzb2x1dGVJcmlcbn0gPSByZXF1aXJlKCcuL3VybCcpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIE91dHB1dHMgYW4gUkRGIGRhdGFzZXQgZm9yIHRoZSBleHBhbmRlZCBKU09OLUxEIGlucHV0LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgZXhwYW5kZWQgSlNPTi1MRCBpbnB1dC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBSREYgc2VyaWFsaXphdGlvbiBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIFJERiBkYXRhc2V0LlxuICovXG5hcGkudG9SREYgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgLy8gY3JlYXRlIG5vZGUgbWFwIGZvciBkZWZhdWx0IGdyYXBoIChhbmQgYW55IG5hbWVkIGdyYXBocylcbiAgY29uc3QgaXNzdWVyID0gbmV3IHV0aWwuSWRlbnRpZmllcklzc3VlcignXzpiJyk7XG4gIGNvbnN0IG5vZGVNYXAgPSB7J0BkZWZhdWx0Jzoge319O1xuICBjcmVhdGVOb2RlTWFwKGlucHV0LCBub2RlTWFwLCAnQGRlZmF1bHQnLCBpc3N1ZXIpO1xuXG4gIGNvbnN0IGRhdGFzZXQgPSBbXTtcbiAgY29uc3QgZ3JhcGhOYW1lcyA9IE9iamVjdC5rZXlzKG5vZGVNYXApLnNvcnQoKTtcbiAgZm9yKGNvbnN0IGdyYXBoTmFtZSBvZiBncmFwaE5hbWVzKSB7XG4gICAgbGV0IGdyYXBoVGVybTtcbiAgICBpZihncmFwaE5hbWUgPT09ICdAZGVmYXVsdCcpIHtcbiAgICAgIGdyYXBoVGVybSA9IHt0ZXJtVHlwZTogJ0RlZmF1bHRHcmFwaCcsIHZhbHVlOiAnJ307XG4gICAgfSBlbHNlIGlmKF9pc0Fic29sdXRlSXJpKGdyYXBoTmFtZSkpIHtcbiAgICAgIGlmKGdyYXBoTmFtZS5zdGFydHNXaXRoKCdfOicpKSB7XG4gICAgICAgIGdyYXBoVGVybSA9IHt0ZXJtVHlwZTogJ0JsYW5rTm9kZSd9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JhcGhUZXJtID0ge3Rlcm1UeXBlOiAnTmFtZWROb2RlJ307XG4gICAgICB9XG4gICAgICBncmFwaFRlcm0udmFsdWUgPSBncmFwaE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNraXAgcmVsYXRpdmUgSVJJcyAobm90IHZhbGlkIFJERilcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBfZ3JhcGhUb1JERihkYXRhc2V0LCBub2RlTWFwW2dyYXBoTmFtZV0sIGdyYXBoVGVybSwgaXNzdWVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhc2V0O1xufTtcblxuLyoqXG4gKiBBZGRzIFJERiBxdWFkcyBmb3IgYSBwYXJ0aWN1bGFyIGdyYXBoIHRvIHRoZSBnaXZlbiBkYXRhc2V0LlxuICpcbiAqIEBwYXJhbSBkYXRhc2V0IHRoZSBkYXRhc2V0IHRvIGFwcGVuZCBSREYgcXVhZHMgdG8uXG4gKiBAcGFyYW0gZ3JhcGggdGhlIGdyYXBoIHRvIGNyZWF0ZSBSREYgcXVhZHMgZm9yLlxuICogQHBhcmFtIGdyYXBoVGVybSB0aGUgZ3JhcGggdGVybSBmb3IgZWFjaCBxdWFkLlxuICogQHBhcmFtIGlzc3VlciBhIElkZW50aWZpZXJJc3N1ZXIgZm9yIGFzc2lnbmluZyBibGFuayBub2RlIG5hbWVzLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIFJERiBzZXJpYWxpemF0aW9uIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB0aGUgYXJyYXkgb2YgUkRGIHRyaXBsZXMgZm9yIHRoZSBnaXZlbiBncmFwaC5cbiAqL1xuZnVuY3Rpb24gX2dyYXBoVG9SREYoZGF0YXNldCwgZ3JhcGgsIGdyYXBoVGVybSwgaXNzdWVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKGdyYXBoKS5zb3J0KCk7XG4gIGZvcihjb25zdCBpZCBvZiBpZHMpIHtcbiAgICBjb25zdCBub2RlID0gZ3JhcGhbaWRdO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhub2RlKS5zb3J0KCk7XG4gICAgZm9yKGxldCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjb25zdCBpdGVtcyA9IG5vZGVbcHJvcGVydHldO1xuICAgICAgaWYocHJvcGVydHkgPT09ICdAdHlwZScpIHtcbiAgICAgICAgcHJvcGVydHkgPSBSREZfVFlQRTtcbiAgICAgIH0gZWxzZSBpZihpc0tleXdvcmQocHJvcGVydHkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAvLyBSREYgc3ViamVjdFxuICAgICAgICBjb25zdCBzdWJqZWN0ID0ge1xuICAgICAgICAgIHRlcm1UeXBlOiBpZC5zdGFydHNXaXRoKCdfOicpID8gJ0JsYW5rTm9kZScgOiAnTmFtZWROb2RlJyxcbiAgICAgICAgICB2YWx1ZTogaWRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBza2lwIHJlbGF0aXZlIElSSSBzdWJqZWN0cyAobm90IHZhbGlkIFJERilcbiAgICAgICAgaWYoIV9pc0Fic29sdXRlSXJpKGlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUkRGIHByZWRpY2F0ZVxuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB7XG4gICAgICAgICAgdGVybVR5cGU6IHByb3BlcnR5LnN0YXJ0c1dpdGgoJ186JykgPyAnQmxhbmtOb2RlJyA6ICdOYW1lZE5vZGUnLFxuICAgICAgICAgIHZhbHVlOiBwcm9wZXJ0eVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNraXAgcmVsYXRpdmUgSVJJIHByZWRpY2F0ZXMgKG5vdCB2YWxpZCBSREYpXG4gICAgICAgIGlmKCFfaXNBYnNvbHV0ZUlyaShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraXAgYmxhbmsgbm9kZSBwcmVkaWNhdGVzIHVubGVzcyBwcm9kdWNpbmcgZ2VuZXJhbGl6ZWQgUkRGXG4gICAgICAgIGlmKHByZWRpY2F0ZS50ZXJtVHlwZSA9PT0gJ0JsYW5rTm9kZScgJiZcbiAgICAgICAgICAhb3B0aW9ucy5wcm9kdWNlR2VuZXJhbGl6ZWRSZGYpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgbGlzdCwgdmFsdWUgb3Igbm9kZSBvYmplY3QgdG8gdHJpcGxlXG4gICAgICAgIGNvbnN0IG9iamVjdCA9XG4gICAgICAgICAgX29iamVjdFRvUkRGKGl0ZW0sIGlzc3VlciwgZGF0YXNldCwgZ3JhcGhUZXJtLCBvcHRpb25zLnJkZkRpcmVjdGlvbik7XG4gICAgICAgIC8vIHNraXAgbnVsbCBvYmplY3RzICh0aGV5IGFyZSByZWxhdGl2ZSBJUklzKVxuICAgICAgICBpZihvYmplY3QpIHtcbiAgICAgICAgICBkYXRhc2V0LnB1c2goe1xuICAgICAgICAgICAgc3ViamVjdCxcbiAgICAgICAgICAgIHByZWRpY2F0ZSxcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyYXBoOiBncmFwaFRlcm1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgQGxpc3QgdmFsdWUgaW50byBsaW5rZWQgbGlzdCBvZiBibGFuayBub2RlIFJERiBxdWFkc1xuICogKGFuIFJERiBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAcGFyYW0gbGlzdCB0aGUgQGxpc3QgdmFsdWUuXG4gKiBAcGFyYW0gaXNzdWVyIGEgSWRlbnRpZmllcklzc3VlciBmb3IgYXNzaWduaW5nIGJsYW5rIG5vZGUgbmFtZXMuXG4gKiBAcGFyYW0gZGF0YXNldCB0aGUgYXJyYXkgb2YgcXVhZHMgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIGdyYXBoVGVybSB0aGUgZ3JhcGggdGVybSBmb3IgZWFjaCBxdWFkLlxuICpcbiAqIEByZXR1cm4gdGhlIGhlYWQgb2YgdGhlIGxpc3QuXG4gKi9cbmZ1bmN0aW9uIF9saXN0VG9SREYobGlzdCwgaXNzdWVyLCBkYXRhc2V0LCBncmFwaFRlcm0sIHJkZkRpcmVjdGlvbikge1xuICBjb25zdCBmaXJzdCA9IHt0ZXJtVHlwZTogJ05hbWVkTm9kZScsIHZhbHVlOiBSREZfRklSU1R9O1xuICBjb25zdCByZXN0ID0ge3Rlcm1UeXBlOiAnTmFtZWROb2RlJywgdmFsdWU6IFJERl9SRVNUfTtcbiAgY29uc3QgbmlsID0ge3Rlcm1UeXBlOiAnTmFtZWROb2RlJywgdmFsdWU6IFJERl9OSUx9O1xuXG4gIGNvbnN0IGxhc3QgPSBsaXN0LnBvcCgpO1xuICAvLyBSZXN1bHQgaXMgdGhlIGhlYWQgb2YgdGhlIGxpc3RcbiAgY29uc3QgcmVzdWx0ID0gbGFzdCA/IHt0ZXJtVHlwZTogJ0JsYW5rTm9kZScsIHZhbHVlOiBpc3N1ZXIuZ2V0SWQoKX0gOiBuaWw7XG4gIGxldCBzdWJqZWN0ID0gcmVzdWx0O1xuXG4gIGZvcihjb25zdCBpdGVtIG9mIGxpc3QpIHtcbiAgICBjb25zdCBvYmplY3QgPSBfb2JqZWN0VG9SREYoaXRlbSwgaXNzdWVyLCBkYXRhc2V0LCBncmFwaFRlcm0sIHJkZkRpcmVjdGlvbik7XG4gICAgY29uc3QgbmV4dCA9IHt0ZXJtVHlwZTogJ0JsYW5rTm9kZScsIHZhbHVlOiBpc3N1ZXIuZ2V0SWQoKX07XG4gICAgZGF0YXNldC5wdXNoKHtcbiAgICAgIHN1YmplY3QsXG4gICAgICBwcmVkaWNhdGU6IGZpcnN0LFxuICAgICAgb2JqZWN0LFxuICAgICAgZ3JhcGg6IGdyYXBoVGVybVxuICAgIH0pO1xuICAgIGRhdGFzZXQucHVzaCh7XG4gICAgICBzdWJqZWN0LFxuICAgICAgcHJlZGljYXRlOiByZXN0LFxuICAgICAgb2JqZWN0OiBuZXh0LFxuICAgICAgZ3JhcGg6IGdyYXBoVGVybVxuICAgIH0pO1xuICAgIHN1YmplY3QgPSBuZXh0O1xuICB9XG5cbiAgLy8gVGFpbCBvZiBsaXN0XG4gIGlmKGxhc3QpIHtcbiAgICBjb25zdCBvYmplY3QgPSBfb2JqZWN0VG9SREYobGFzdCwgaXNzdWVyLCBkYXRhc2V0LCBncmFwaFRlcm0sIHJkZkRpcmVjdGlvbik7XG4gICAgZGF0YXNldC5wdXNoKHtcbiAgICAgIHN1YmplY3QsXG4gICAgICBwcmVkaWNhdGU6IGZpcnN0LFxuICAgICAgb2JqZWN0LFxuICAgICAgZ3JhcGg6IGdyYXBoVGVybVxuICAgIH0pO1xuICAgIGRhdGFzZXQucHVzaCh7XG4gICAgICBzdWJqZWN0LFxuICAgICAgcHJlZGljYXRlOiByZXN0LFxuICAgICAgb2JqZWN0OiBuaWwsXG4gICAgICBncmFwaDogZ3JhcGhUZXJtXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgSlNPTi1MRCB2YWx1ZSBvYmplY3QgdG8gYW4gUkRGIGxpdGVyYWwgb3IgYSBKU09OLUxEIHN0cmluZyxcbiAqIG5vZGUgb2JqZWN0IHRvIGFuIFJERiByZXNvdXJjZSwgb3IgYWRkcyBhIGxpc3QuXG4gKlxuICogQHBhcmFtIGl0ZW0gdGhlIEpTT04tTEQgdmFsdWUgb3Igbm9kZSBvYmplY3QuXG4gKiBAcGFyYW0gaXNzdWVyIGEgSWRlbnRpZmllcklzc3VlciBmb3IgYXNzaWduaW5nIGJsYW5rIG5vZGUgbmFtZXMuXG4gKiBAcGFyYW0gZGF0YXNldCB0aGUgZGF0YXNldCB0byBhcHBlbmQgUkRGIHF1YWRzIHRvLlxuICogQHBhcmFtIGdyYXBoVGVybSB0aGUgZ3JhcGggdGVybSBmb3IgZWFjaCBxdWFkLlxuICpcbiAqIEByZXR1cm4gdGhlIFJERiBsaXRlcmFsIG9yIFJERiByZXNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gX29iamVjdFRvUkRGKGl0ZW0sIGlzc3VlciwgZGF0YXNldCwgZ3JhcGhUZXJtLCByZGZEaXJlY3Rpb24pIHtcbiAgY29uc3Qgb2JqZWN0ID0ge307XG5cbiAgLy8gY29udmVydCB2YWx1ZSBvYmplY3QgdG8gUkRGXG4gIGlmKGdyYXBoVHlwZXMuaXNWYWx1ZShpdGVtKSkge1xuICAgIG9iamVjdC50ZXJtVHlwZSA9ICdMaXRlcmFsJztcbiAgICBvYmplY3QudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgb2JqZWN0LmRhdGF0eXBlID0ge1xuICAgICAgdGVybVR5cGU6ICdOYW1lZE5vZGUnXG4gICAgfTtcbiAgICBsZXQgdmFsdWUgPSBpdGVtWydAdmFsdWUnXTtcbiAgICBjb25zdCBkYXRhdHlwZSA9IGl0ZW1bJ0B0eXBlJ10gfHwgbnVsbDtcblxuICAgIC8vIGNvbnZlcnQgdG8gWFNEL0pTT04gZGF0YXR5cGVzIGFzIGFwcHJvcHJpYXRlXG4gICAgaWYoZGF0YXR5cGUgPT09ICdAanNvbicpIHtcbiAgICAgIG9iamVjdC52YWx1ZSA9IGpzb25DYW5vbmljYWxpemUodmFsdWUpO1xuICAgICAgb2JqZWN0LmRhdGF0eXBlLnZhbHVlID0gUkRGX0pTT05fTElURVJBTDtcbiAgICB9IGVsc2UgaWYodHlwZXMuaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIG9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IGRhdGF0eXBlIHx8IFhTRF9CT09MRUFOO1xuICAgIH0gZWxzZSBpZih0eXBlcy5pc0RvdWJsZSh2YWx1ZSkgfHwgZGF0YXR5cGUgPT09IFhTRF9ET1VCTEUpIHtcbiAgICAgIGlmKCF0eXBlcy5pc0RvdWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGNhbm9uaWNhbCBkb3VibGUgcmVwcmVzZW50YXRpb25cbiAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlLnRvRXhwb25lbnRpYWwoMTUpLnJlcGxhY2UoLyhcXGQpMCplXFwrPy8sICckMUUnKTtcbiAgICAgIG9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IGRhdGF0eXBlIHx8IFhTRF9ET1VCTEU7XG4gICAgfSBlbHNlIGlmKHR5cGVzLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICAgIG9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IGRhdGF0eXBlIHx8IFhTRF9JTlRFR0VSO1xuICAgIH0gZWxzZSBpZihyZGZEaXJlY3Rpb24gPT09ICdpMThuLWRhdGF0eXBlJyAmJlxuICAgICAgJ0BkaXJlY3Rpb24nIGluIGl0ZW0pIHtcbiAgICAgIGNvbnN0IGRhdGF0eXBlID0gJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9pMThuIycgK1xuICAgICAgICAoaXRlbVsnQGxhbmd1YWdlJ10gfHwgJycpICtcbiAgICAgICAgYF8ke2l0ZW1bJ0BkaXJlY3Rpb24nXX1gO1xuICAgICAgb2JqZWN0LmRhdGF0eXBlLnZhbHVlID0gZGF0YXR5cGU7XG4gICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYoJ0BsYW5ndWFnZScgaW4gaXRlbSkge1xuICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBSREZfTEFOR1NUUklORztcbiAgICAgIG9iamVjdC5sYW5ndWFnZSA9IGl0ZW1bJ0BsYW5ndWFnZSddO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgIG9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IGRhdGF0eXBlIHx8IFhTRF9TVFJJTkc7XG4gICAgfVxuICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc0xpc3QoaXRlbSkpIHtcbiAgICBjb25zdCBfbGlzdCA9XG4gICAgICBfbGlzdFRvUkRGKGl0ZW1bJ0BsaXN0J10sIGlzc3VlciwgZGF0YXNldCwgZ3JhcGhUZXJtLCByZGZEaXJlY3Rpb24pO1xuICAgIG9iamVjdC50ZXJtVHlwZSA9IF9saXN0LnRlcm1UeXBlO1xuICAgIG9iamVjdC52YWx1ZSA9IF9saXN0LnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGNvbnZlcnQgc3RyaW5nL25vZGUgb2JqZWN0IHRvIFJERlxuICAgIGNvbnN0IGlkID0gdHlwZXMuaXNPYmplY3QoaXRlbSkgPyBpdGVtWydAaWQnXSA6IGl0ZW07XG4gICAgb2JqZWN0LnRlcm1UeXBlID0gaWQuc3RhcnRzV2l0aCgnXzonKSA/ICdCbGFua05vZGUnIDogJ05hbWVkTm9kZSc7XG4gICAgb2JqZWN0LnZhbHVlID0gaWQ7XG4gIH1cblxuICAvLyBza2lwIHJlbGF0aXZlIElSSXMsIG5vdCB2YWxpZCBSREZcbiAgaWYob2JqZWN0LnRlcm1UeXBlID09PSAnTmFtZWROb2RlJyAmJiAhX2lzQWJzb2x1dGVJcmkob2JqZWN0LnZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gQXJyYXkuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gQXJyYXksIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBCb29sZWFuLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgQm9vbGVhbiwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNCb29sZWFuID0gdiA9PiAodHlwZW9mIHYgPT09ICdib29sZWFuJyB8fFxuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRvdWJsZS5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGRvdWJsZSwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNEb3VibGUgPSB2ID0+IGFwaS5pc051bWJlcih2KSAmJlxuICAoU3RyaW5nKHYpLmluZGV4T2YoJy4nKSAhPT0gLTEgfHwgTWF0aC5hYnModikgPj0gMWUyMSk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlbXB0eSBPYmplY3QuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gZW1wdHkgT2JqZWN0LCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc0VtcHR5T2JqZWN0ID0gdiA9PiBhcGkuaXNPYmplY3QodikgJiYgT2JqZWN0LmtleXModikubGVuZ3RoID09PSAwO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBOdW1iZXIuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBOdW1iZXIsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzTnVtYmVyID0gdiA9PiAodHlwZW9mIHYgPT09ICdudW1iZXInIHx8XG4gIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbnVtZXJpYy5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc051bWVyaWMgPSB2ID0+ICFpc05hTihwYXJzZUZsb2F0KHYpKSAmJiBpc0Zpbml0ZSh2KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBPYmplY3QsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzT2JqZWN0ID0gdiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBTdHJpbmcuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBTdHJpbmcsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzU3RyaW5nID0gdiA9PiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8XG4gIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNVbmRlZmluZWQgPSB2ID0+IHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLy8gZGVmaW5lIFVSTCBwYXJzZXJcbi8vIHBhcnNlVXJpIDEuMi4yXG4vLyAoYykgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4vLyBNSVQgTGljZW5zZVxuLy8gd2l0aCBsb2NhbCBqc29ubGQuanMgbW9kaWZpY2F0aW9uc1xuYXBpLnBhcnNlcnMgPSB7XG4gIHNpbXBsZToge1xuICAgIC8vIFJGQyAzOTg2IGJhc2ljIHBhcnRzXG4gICAga2V5czogW1xuICAgICAgJ2hyZWYnLCAnc2NoZW1lJywgJ2F1dGhvcml0eScsICdwYXRoJywgJ3F1ZXJ5JywgJ2ZyYWdtZW50J1xuICAgIF0sXG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW4gKi9cbiAgICByZWdleDogL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oW15cXC8/I10qKSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/L1xuICB9LFxuICBmdWxsOiB7XG4gICAga2V5czogW1xuICAgICAgJ2hyZWYnLCAncHJvdG9jb2wnLCAnc2NoZW1lJywgJ2F1dGhvcml0eScsICdhdXRoJywgJ3VzZXInLCAncGFzc3dvcmQnLFxuICAgICAgJ2hvc3RuYW1lJywgJ3BvcnQnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdmcmFnbWVudCdcbiAgICBdLFxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuICovXG4gICAgcmVnZXg6IC9eKChbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSk/KD86KCgoPzpbXj8jXFwvXSpcXC8pKikoW14/I10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS9cbiAgfVxufTtcbmFwaS5wYXJzZSA9IChzdHIsIHBhcnNlcikgPT4ge1xuICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgY29uc3QgbyA9IGFwaS5wYXJzZXJzW3BhcnNlciB8fCAnZnVsbCddO1xuICBjb25zdCBtID0gby5yZWdleC5leGVjKHN0cik7XG4gIGxldCBpID0gby5rZXlzLmxlbmd0aDtcbiAgd2hpbGUoaS0tKSB7XG4gICAgcGFyc2VkW28ua2V5c1tpXV0gPSAobVtpXSA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOiBtW2ldO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGRlZmF1bHQgcG9ydHMgaW4gZm91bmQgaW4gVVJMc1xuICBpZigocGFyc2VkLnNjaGVtZSA9PT0gJ2h0dHBzJyAmJiBwYXJzZWQucG9ydCA9PT0gJzQ0MycpIHx8XG4gICAgKHBhcnNlZC5zY2hlbWUgPT09ICdodHRwJyAmJiBwYXJzZWQucG9ydCA9PT0gJzgwJykpIHtcbiAgICBwYXJzZWQuaHJlZiA9IHBhcnNlZC5ocmVmLnJlcGxhY2UoJzonICsgcGFyc2VkLnBvcnQsICcnKTtcbiAgICBwYXJzZWQuYXV0aG9yaXR5ID0gcGFyc2VkLmF1dGhvcml0eS5yZXBsYWNlKCc6JyArIHBhcnNlZC5wb3J0LCAnJyk7XG4gICAgcGFyc2VkLnBvcnQgPSBudWxsO1xuICB9XG5cbiAgcGFyc2VkLm5vcm1hbGl6ZWRQYXRoID0gYXBpLnJlbW92ZURvdFNlZ21lbnRzKHBhcnNlZC5wYXRoKTtcbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8qKlxuICogUHJlcGVuZHMgYSBiYXNlIElSSSB0byB0aGUgZ2l2ZW4gcmVsYXRpdmUgSVJJLlxuICpcbiAqIEBwYXJhbSBiYXNlIHRoZSBiYXNlIElSSS5cbiAqIEBwYXJhbSBpcmkgdGhlIHJlbGF0aXZlIElSSS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhYnNvbHV0ZSBJUkkuXG4gKi9cbmFwaS5wcmVwZW5kQmFzZSA9IChiYXNlLCBpcmkpID0+IHtcbiAgLy8gc2tpcCBJUkkgcHJvY2Vzc2luZ1xuICBpZihiYXNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGlyaTtcbiAgfVxuICAvLyBhbHJlYWR5IGFuIGFic29sdXRlIElSSVxuICBpZihhcGkuaXNBYnNvbHV0ZShpcmkpKSB7XG4gICAgcmV0dXJuIGlyaTtcbiAgfVxuXG4gIC8vIHBhcnNlIGJhc2UgaWYgaXQgaXMgYSBzdHJpbmdcbiAgaWYoIWJhc2UgfHwgdHlwZXMuaXNTdHJpbmcoYmFzZSkpIHtcbiAgICBiYXNlID0gYXBpLnBhcnNlKGJhc2UgfHwgJycpO1xuICB9XG5cbiAgLy8gcGFyc2UgZ2l2ZW4gSVJJXG4gIGNvbnN0IHJlbCA9IGFwaS5wYXJzZShpcmkpO1xuXG4gIC8vIHBlciBSRkMzOTg2IDUuMi4yXG4gIGNvbnN0IHRyYW5zZm9ybSA9IHtcbiAgICBwcm90b2NvbDogYmFzZS5wcm90b2NvbCB8fCAnJ1xuICB9O1xuXG4gIGlmKHJlbC5hdXRob3JpdHkgIT09IG51bGwpIHtcbiAgICB0cmFuc2Zvcm0uYXV0aG9yaXR5ID0gcmVsLmF1dGhvcml0eTtcbiAgICB0cmFuc2Zvcm0ucGF0aCA9IHJlbC5wYXRoO1xuICAgIHRyYW5zZm9ybS5xdWVyeSA9IHJlbC5xdWVyeTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2Zvcm0uYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG5cbiAgICBpZihyZWwucGF0aCA9PT0gJycpIHtcbiAgICAgIHRyYW5zZm9ybS5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgaWYocmVsLnF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICAgIHRyYW5zZm9ybS5xdWVyeSA9IHJlbC5xdWVyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zZm9ybS5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHJlbC5wYXRoLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICAvLyBJUkkgcmVwcmVzZW50cyBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICAgIHRyYW5zZm9ybS5wYXRoID0gcmVsLnBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtZXJnZSBwYXRoc1xuICAgICAgICBsZXQgcGF0aCA9IGJhc2UucGF0aDtcblxuICAgICAgICAvLyBhcHBlbmQgcmVsYXRpdmUgcGF0aCB0byB0aGUgZW5kIG9mIHRoZSBsYXN0IGRpcmVjdG9yeSBmcm9tIGJhc2VcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgICBpZigocGF0aC5sZW5ndGggPiAwIHx8IGJhc2UuYXV0aG9yaXR5KSAmJiBwYXRoLnN1YnN0cigtMSkgIT09ICcvJykge1xuICAgICAgICAgIHBhdGggKz0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggKz0gcmVsLnBhdGg7XG5cbiAgICAgICAgdHJhbnNmb3JtLnBhdGggPSBwYXRoO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtLnF1ZXJ5ID0gcmVsLnF1ZXJ5O1xuICAgIH1cbiAgfVxuXG4gIGlmKHJlbC5wYXRoICE9PSAnJykge1xuICAgIC8vIHJlbW92ZSBzbGFzaGVzIGFuZCBkb3RzIGluIHBhdGhcbiAgICB0cmFuc2Zvcm0ucGF0aCA9IGFwaS5yZW1vdmVEb3RTZWdtZW50cyh0cmFuc2Zvcm0ucGF0aCk7XG4gIH1cblxuICAvLyBjb25zdHJ1Y3QgVVJMXG4gIGxldCBydmFsID0gdHJhbnNmb3JtLnByb3RvY29sO1xuICBpZih0cmFuc2Zvcm0uYXV0aG9yaXR5ICE9PSBudWxsKSB7XG4gICAgcnZhbCArPSAnLy8nICsgdHJhbnNmb3JtLmF1dGhvcml0eTtcbiAgfVxuICBydmFsICs9IHRyYW5zZm9ybS5wYXRoO1xuICBpZih0cmFuc2Zvcm0ucXVlcnkgIT09IG51bGwpIHtcbiAgICBydmFsICs9ICc/JyArIHRyYW5zZm9ybS5xdWVyeTtcbiAgfVxuICBpZihyZWwuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBydmFsICs9ICcjJyArIHJlbC5mcmFnbWVudDtcbiAgfVxuXG4gIC8vIGhhbmRsZSBlbXB0eSBiYXNlXG4gIGlmKHJ2YWwgPT09ICcnKSB7XG4gICAgcnZhbCA9ICcuLyc7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGJhc2UgSVJJIGZyb20gdGhlIGdpdmVuIGFic29sdXRlIElSSS5cbiAqXG4gKiBAcGFyYW0gYmFzZSB0aGUgYmFzZSBJUkkuXG4gKiBAcGFyYW0gaXJpIHRoZSBhYnNvbHV0ZSBJUkkuXG4gKlxuICogQHJldHVybiB0aGUgcmVsYXRpdmUgSVJJIGlmIHJlbGF0aXZlIHRvIGJhc2UsIG90aGVyd2lzZSB0aGUgYWJzb2x1dGUgSVJJLlxuICovXG5hcGkucmVtb3ZlQmFzZSA9IChiYXNlLCBpcmkpID0+IHtcbiAgLy8gc2tpcCBJUkkgcHJvY2Vzc2luZ1xuICBpZihiYXNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGlyaTtcbiAgfVxuXG4gIGlmKCFiYXNlIHx8IHR5cGVzLmlzU3RyaW5nKGJhc2UpKSB7XG4gICAgYmFzZSA9IGFwaS5wYXJzZShiYXNlIHx8ICcnKTtcbiAgfVxuXG4gIC8vIGVzdGFibGlzaCBiYXNlIHJvb3RcbiAgbGV0IHJvb3QgPSAnJztcbiAgaWYoYmFzZS5ocmVmICE9PSAnJykge1xuICAgIHJvb3QgKz0gKGJhc2UucHJvdG9jb2wgfHwgJycpICsgJy8vJyArIChiYXNlLmF1dGhvcml0eSB8fCAnJyk7XG4gIH0gZWxzZSBpZihpcmkuaW5kZXhPZignLy8nKSkge1xuICAgIC8vIHN1cHBvcnQgbmV0d29yay1wYXRoIHJlZmVyZW5jZSB3aXRoIGVtcHR5IGJhc2VcbiAgICByb290ICs9ICcvLyc7XG4gIH1cblxuICAvLyBJUkkgbm90IHJlbGF0aXZlIHRvIGJhc2VcbiAgaWYoaXJpLmluZGV4T2Yocm9vdCkgIT09IDApIHtcbiAgICByZXR1cm4gaXJpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHJvb3QgZnJvbSBJUkkgYW5kIHBhcnNlIHJlbWFpbmRlclxuICBjb25zdCByZWwgPSBhcGkucGFyc2UoaXJpLnN1YnN0cihyb290Lmxlbmd0aCkpO1xuXG4gIC8vIHJlbW92ZSBwYXRoIHNlZ21lbnRzIHRoYXQgbWF0Y2ggKGRvIG5vdCByZW1vdmUgbGFzdCBzZWdtZW50IHVubGVzcyB0aGVyZVxuICAvLyBpcyBhIGhhc2ggb3IgcXVlcnkpXG4gIGNvbnN0IGJhc2VTZWdtZW50cyA9IGJhc2Uubm9ybWFsaXplZFBhdGguc3BsaXQoJy8nKTtcbiAgY29uc3QgaXJpU2VnbWVudHMgPSByZWwubm9ybWFsaXplZFBhdGguc3BsaXQoJy8nKTtcbiAgY29uc3QgbGFzdCA9IChyZWwuZnJhZ21lbnQgfHwgcmVsLnF1ZXJ5KSA/IDAgOiAxO1xuICB3aGlsZShiYXNlU2VnbWVudHMubGVuZ3RoID4gMCAmJiBpcmlTZWdtZW50cy5sZW5ndGggPiBsYXN0KSB7XG4gICAgaWYoYmFzZVNlZ21lbnRzWzBdICE9PSBpcmlTZWdtZW50c1swXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJhc2VTZWdtZW50cy5zaGlmdCgpO1xuICAgIGlyaVNlZ21lbnRzLnNoaWZ0KCk7XG4gIH1cblxuICAvLyB1c2UgJy4uLycgZm9yIGVhY2ggbm9uLW1hdGNoaW5nIGJhc2Ugc2VnbWVudFxuICBsZXQgcnZhbCA9ICcnO1xuICBpZihiYXNlU2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgIC8vIGRvbid0IGNvdW50IHRoZSBsYXN0IHNlZ21lbnQgKGlmIGl0IGVuZHMgd2l0aCAnLycgbGFzdCBwYXRoIGRvZXNuJ3RcbiAgICAvLyBjb3VudCBhbmQgaWYgaXQgZG9lc24ndCBlbmQgd2l0aCAnLycgaXQgaXNuJ3QgYSBwYXRoKVxuICAgIGJhc2VTZWdtZW50cy5wb3AoKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYmFzZVNlZ21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBydmFsICs9ICcuLi8nO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByZXBlbmQgcmVtYWluaW5nIHNlZ21lbnRzXG4gIHJ2YWwgKz0gaXJpU2VnbWVudHMuam9pbignLycpO1xuXG4gIC8vIGFkZCBxdWVyeSBhbmQgaGFzaFxuICBpZihyZWwucXVlcnkgIT09IG51bGwpIHtcbiAgICBydmFsICs9ICc/JyArIHJlbC5xdWVyeTtcbiAgfVxuICBpZihyZWwuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBydmFsICs9ICcjJyArIHJlbC5mcmFnbWVudDtcbiAgfVxuXG4gIC8vIGhhbmRsZSBlbXB0eSBiYXNlXG4gIGlmKHJ2YWwgPT09ICcnKSB7XG4gICAgcnZhbCA9ICcuLyc7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBkb3Qgc2VnbWVudHMgZnJvbSBhIFVSTCBwYXRoLlxuICpcbiAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIHRvIHJlbW92ZSBkb3Qgc2VnbWVudHMgZnJvbS5cbiAqL1xuYXBpLnJlbW92ZURvdFNlZ21lbnRzID0gcGF0aCA9PiB7XG4gIC8vIFJGQyAzOTg2IDUuMi40IChyZXdvcmtlZClcblxuICAvLyBlbXB0eSBwYXRoIHNob3J0Y3V0XG4gIGlmKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3QgaW5wdXQgPSBwYXRoLnNwbGl0KCcvJyk7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuXG4gIHdoaWxlKGlucHV0Lmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBuZXh0ID0gaW5wdXQuc2hpZnQoKTtcbiAgICBjb25zdCBkb25lID0gaW5wdXQubGVuZ3RoID09PSAwO1xuXG4gICAgaWYobmV4dCA9PT0gJy4nKSB7XG4gICAgICBpZihkb25lKSB7XG4gICAgICAgIC8vIGVuc3VyZSBvdXRwdXQgaGFzIHRyYWlsaW5nIC9cbiAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYobmV4dCA9PT0gJy4uJykge1xuICAgICAgb3V0cHV0LnBvcCgpO1xuICAgICAgaWYoZG9uZSkge1xuICAgICAgICAvLyBlbnN1cmUgb3V0cHV0IGhhcyB0cmFpbGluZyAvXG4gICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIG91dHB1dC5wdXNoKG5leHQpO1xuICB9XG5cbiAgLy8gaWYgcGF0aCB3YXMgYWJzb2x1dGUsIGVuc3VyZSBvdXRwdXQgaGFzIGxlYWRpbmcgL1xuICBpZihwYXRoWzBdID09PSAnLycgJiYgb3V0cHV0Lmxlbmd0aCA+IDAgJiYgb3V0cHV0WzBdICE9PSAnJykge1xuICAgIG91dHB1dC51bnNoaWZ0KCcnKTtcbiAgfVxuICBpZihvdXRwdXQubGVuZ3RoID09PSAxICYmIG91dHB1dFswXSA9PT0gJycpIHtcbiAgICByZXR1cm4gJy8nO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcvJyk7XG59O1xuXG4vLyBUT0RPOiB0aW1lIGJldHRlciBpc0Fic29sdXRlL2lzUmVsYXRpdmUgY2hlY2tzIHVzaW5nIGZ1bGwgcmVnZXhlczpcbi8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWxcblxuLy8gcmVnZXggdG8gY2hlY2sgZm9yIGFic29sdXRlIElSSSAoc3RhcnRpbmcgc2NoZW1lIGFuZCAnOicpIG9yIGJsYW5rIG5vZGUgSVJJXG5jb25zdCBpc0Fic29sdXRlUmVnZXggPSAvXihbQS1aYS16XVtBLVphLXowLTkrLS5dKnxfKTpbXlxcc10qJC87XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBhYnNvbHV0ZSBJUkkgb3IgYmxhbmsgbm9kZSBJUkksIGZhbHNlXG4gKiBpZiBub3QuXG4gKiBOb3RlOiBUaGlzIHdlYWsgY2hlY2sgb25seSBjaGVja3MgZm9yIGEgY29ycmVjdCBzdGFydGluZyBzY2hlbWUuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gYWJzb2x1dGUgSVJJLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc0Fic29sdXRlID0gdiA9PiB0eXBlcy5pc1N0cmluZyh2KSAmJiBpc0Fic29sdXRlUmVnZXgudGVzdCh2KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcmVsYXRpdmUgSVJJLCBmYWxzZSBpZiBub3QuXG4gKiBOb3RlOiB0aGlzIGlzIGEgd2VhayBjaGVjay5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHJlbGF0aXZlIElSSSwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNSZWxhdGl2ZSA9IHYgPT4gdHlwZXMuaXNTdHJpbmcodik7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMTkgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBncmFwaFR5cGVzID0gcmVxdWlyZSgnLi9ncmFwaFR5cGVzJyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbi8vIFRPRE86IG1vdmUgYElkZW50aWZpZXJJc3N1ZXJgIHRvIGl0cyBvd24gcGFja2FnZVxuY29uc3QgSWRlbnRpZmllcklzc3VlciA9IHJlcXVpcmUoJ3JkZi1jYW5vbml6ZScpLklkZW50aWZpZXJJc3N1ZXI7XG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcblxuLy8gY29uc3RhbnRzXG5jb25zdCBSRUdFWF9MSU5LX0hFQURFUlMgPSAvKD86PFtePl0qPz58XCJbXlwiXSo/XCJ8W14sXSkrL2c7XG5jb25zdCBSRUdFWF9MSU5LX0hFQURFUiA9IC9cXHMqPChbXj5dKj8pPlxccyooPzo7XFxzKiguKikpPy87XG5jb25zdCBSRUdFWF9MSU5LX0hFQURFUl9QQVJBTVMgPVxuICAvKC4qPyk9KD86KD86XCIoW15cIl0qPylcIil8KFteXCJdKj8pKVxccyooPzooPzo7XFxzKil8JCkvZztcblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIGhlYWRlcnM6IHtcbiAgICBhY2NlcHQ6ICdhcHBsaWNhdGlvbi9sZCtqc29uLCBhcHBsaWNhdGlvbi9qc29uJ1xuICB9XG59O1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuYXBpLklkZW50aWZpZXJJc3N1ZXIgPSBJZGVudGlmaWVySXNzdWVyO1xuXG4vKipcbiAqIENsb25lcyBhbiBvYmplY3QsIGFycmF5LCBNYXAsIFNldCwgb3Igc3RyaW5nL251bWJlci4gSWYgYSB0eXBlZCBKYXZhU2NyaXB0XG4gKiBvYmplY3QgaXMgZ2l2ZW4sIHN1Y2ggYXMgYSBEYXRlLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGNsb25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuYXBpLmNsb25lID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGxldCBydmFsO1xuICAgIGlmKHR5cGVzLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBydmFsID0gW107XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcnZhbFtpXSA9IGFwaS5jbG9uZSh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBydmFsID0gbmV3IE1hcCgpO1xuICAgICAgZm9yKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZSkge1xuICAgICAgICBydmFsLnNldChrLCBhcGkuY2xvbmUodikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgcnZhbCA9IG5ldyBTZXQoKTtcbiAgICAgIGZvcihjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgIHJ2YWwuYWRkKGFwaS5jbG9uZSh2KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVzLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcnZhbCA9IHt9O1xuICAgICAgZm9yKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBydmFsW2tleV0gPSBhcGkuY2xvbmUodmFsdWVba2V5XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIEVuc3VyZSBhIHZhbHVlIGlzIGFuIGFycmF5LiBJZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIGl0IGlzIHJldHVybmVkLlxuICogT3RoZXJ3aXNlLCBpdCBpcyB3cmFwcGVkIGluIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gcmV0dXJuIGFzIGFuIGFycmF5LlxuICpcbiAqIEByZXR1cm4gdGhlIHZhbHVlIGFzIGFuIGFycmF5LlxuICovXG5hcGkuYXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn07XG5cbi8qKlxuICogQnVpbGRzIGFuIEhUVFAgaGVhZGVycyBvYmplY3QgZm9yIG1ha2luZyBhIEpTT04tTEQgcmVxdWVzdCBmcm9tIGN1c3RvbVxuICogaGVhZGVycyBhbmQgYXNzZXJ0cyB0aGUgYGFjY2VwdGAgaGVhZGVyIGlzbid0IG92ZXJyaWRkZW4uXG4gKlxuICogQHBhcmFtIGhlYWRlcnMgYW4gb2JqZWN0IG9mIGhlYWRlcnMgd2l0aCBrZXlzIGFzIGhlYWRlciBuYW1lcyBhbmQgdmFsdWVzXG4gKiAgICAgICAgICBhcyBoZWFkZXIgdmFsdWVzLlxuICpcbiAqIEByZXR1cm4gYW4gb2JqZWN0IG9mIGhlYWRlcnMgd2l0aCBhIHZhbGlkIGBhY2NlcHRgIGhlYWRlci5cbiAqL1xuYXBpLmJ1aWxkSGVhZGVycyA9IChoZWFkZXJzID0ge30pID0+IHtcbiAgY29uc3QgaGFzQWNjZXB0ID0gT2JqZWN0LmtleXMoaGVhZGVycykuc29tZShcbiAgICBoID0+IGgudG9Mb3dlckNhc2UoKSA9PT0gJ2FjY2VwdCcpO1xuXG4gIGlmKGhhc0FjY2VwdCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgJ0FjY2VwdCBoZWFkZXIgbWF5IG5vdCBiZSBzcGVjaWZpZWQ7IG9ubHkgXCInICtcbiAgICAgIERFRkFVTFRTLmhlYWRlcnMuYWNjZXB0ICsgJ1wiIGlzIHN1cHBvcnRlZC4nKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtBY2NlcHQ6IERFRkFVTFRTLmhlYWRlcnMuYWNjZXB0fSwgaGVhZGVycyk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIGxpbmsgaGVhZGVyLiBUaGUgcmVzdWx0cyB3aWxsIGJlIGtleSdkIGJ5IHRoZSB2YWx1ZSBvZiBcInJlbFwiLlxuICpcbiAqIExpbms6IDxodHRwOi8vanNvbi1sZC5vcmcvY29udGV4dHMvcGVyc29uLmpzb25sZD47XG4gKiByZWw9XCJodHRwOi8vd3d3LnczLm9yZy9ucy9qc29uLWxkI2NvbnRleHRcIjsgdHlwZT1cImFwcGxpY2F0aW9uL2xkK2pzb25cIlxuICpcbiAqIFBhcnNlcyBhczoge1xuICogICAnaHR0cDovL3d3dy53My5vcmcvbnMvanNvbi1sZCNjb250ZXh0Jzoge1xuICogICAgIHRhcmdldDogaHR0cDovL2pzb24tbGQub3JnL2NvbnRleHRzL3BlcnNvbi5qc29ubGQsXG4gKiAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2xkK2pzb24nXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIFwicmVsXCIgd2l0aCB0aGUgc2FtZSBJUkksIHRoZW4gZW50cmllcyBpbiB0aGVcbiAqIHJlc3VsdGluZyBtYXAgZm9yIHRoYXQgXCJyZWxcIiB3aWxsIGJlIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0gaGVhZGVyIHRoZSBsaW5rIGhlYWRlciB0byBwYXJzZS5cbiAqL1xuYXBpLnBhcnNlTGlua0hlYWRlciA9IGhlYWRlciA9PiB7XG4gIGNvbnN0IHJ2YWwgPSB7fTtcbiAgLy8gc3BsaXQgb24gdW5icmFja2V0ZWQvdW5xdW90ZWQgY29tbWFzXG4gIGNvbnN0IGVudHJpZXMgPSBoZWFkZXIubWF0Y2goUkVHRVhfTElOS19IRUFERVJTKTtcbiAgZm9yKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgbWF0Y2ggPSBlbnRyaWVzW2ldLm1hdGNoKFJFR0VYX0xJTktfSEVBREVSKTtcbiAgICBpZighbWF0Y2gpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7dGFyZ2V0OiBtYXRjaFsxXX07XG4gICAgY29uc3QgcGFyYW1zID0gbWF0Y2hbMl07XG4gICAgd2hpbGUoKG1hdGNoID0gUkVHRVhfTElOS19IRUFERVJfUEFSQU1TLmV4ZWMocGFyYW1zKSkpIHtcbiAgICAgIHJlc3VsdFttYXRjaFsxXV0gPSAobWF0Y2hbMl0gPT09IHVuZGVmaW5lZCkgPyBtYXRjaFszXSA6IG1hdGNoWzJdO1xuICAgIH1cbiAgICBjb25zdCByZWwgPSByZXN1bHRbJ3JlbCddIHx8ICcnO1xuICAgIGlmKEFycmF5LmlzQXJyYXkocnZhbFtyZWxdKSkge1xuICAgICAgcnZhbFtyZWxdLnB1c2gocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYocnZhbC5oYXNPd25Qcm9wZXJ0eShyZWwpKSB7XG4gICAgICBydmFsW3JlbF0gPSBbcnZhbFtyZWxdLCByZXN1bHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsW3JlbF0gPSByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBAdHlwZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmFwaS52YWxpZGF0ZVR5cGVWYWx1ZSA9ICh2LCBpc0ZyYW1lKSA9PiB7XG4gIGlmKHR5cGVzLmlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYodHlwZXMuaXNBcnJheSh2KSAmJiB2LmV2ZXJ5KHZ2ID0+IHR5cGVzLmlzU3RyaW5nKHZ2KSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYoaXNGcmFtZSAmJiB0eXBlcy5pc09iamVjdCh2KSkge1xuICAgIHN3aXRjaChPYmplY3Qua2V5cyh2KS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLy8gZW1wdHkgb2JqZWN0IGlzIHdpbGRjYXJkXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLy8gZGVmYXVsdCBlbnRyeSBpcyBhbGwgc3RyaW5nc1xuICAgICAgICBpZignQGRlZmF1bHQnIGluIHYgJiZcbiAgICAgICAgICBhcGkuYXNBcnJheSh2WydAZGVmYXVsdCddKS5ldmVyeSh2diA9PiB0eXBlcy5pc1N0cmluZyh2dikpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkB0eXBlXCIgdmFsdWUgbXVzdCBhIHN0cmluZywgYW4gYXJyYXkgb2YgJyArXG4gICAgJ3N0cmluZ3MsIGFuIGVtcHR5IG9iamVjdCwgJyArXG4gICAgJ29yIGEgZGVmYXVsdCBvYmplY3QuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAge2NvZGU6ICdpbnZhbGlkIHR5cGUgdmFsdWUnLCB2YWx1ZTogdn0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN1YmplY3QgaGFzIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBwcm9wZXJ0eSB0aGUgcHJvcGVydHkgdG8gbG9vayBmb3IuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBzdWJqZWN0IGhhcyB0aGUgZ2l2ZW4gcHJvcGVydHksIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmhhc1Byb3BlcnR5ID0gKHN1YmplY3QsIHByb3BlcnR5KSA9PiB7XG4gIGlmKHN1YmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdWJqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gKCF0eXBlcy5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPiAwKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcHJvcGVydHkgb2YgdGhlIGdpdmVuIHN1YmplY3QuXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gY2hlY2suXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGV4aXN0cywgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaGFzVmFsdWUgPSAoc3ViamVjdCwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gIGlmKGFwaS5oYXNQcm9wZXJ0eShzdWJqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBsZXQgdmFsID0gc3ViamVjdFtwcm9wZXJ0eV07XG4gICAgY29uc3QgaXNMaXN0ID0gZ3JhcGhUeXBlcy5pc0xpc3QodmFsKTtcbiAgICBpZih0eXBlcy5pc0FycmF5KHZhbCkgfHwgaXNMaXN0KSB7XG4gICAgICBpZihpc0xpc3QpIHtcbiAgICAgICAgdmFsID0gdmFsWydAbGlzdCddO1xuICAgICAgfVxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZihhcGkuY29tcGFyZVZhbHVlcyh2YWx1ZSwgdmFsW2ldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCF0eXBlcy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gYXZvaWQgbWF0Y2hpbmcgdGhlIHNldCBvZiB2YWx1ZXMgd2l0aCBhbiBhcnJheSB2YWx1ZSBwYXJhbWV0ZXJcbiAgICAgIHJldHVybiBhcGkuY29tcGFyZVZhbHVlcyh2YWx1ZSwgdmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdmFsdWUgdG8gYSBzdWJqZWN0LiBJZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIGFsbCB2YWx1ZXMgaW4gdGhlXG4gKiBhcnJheSB3aWxsIGJlIGFkZGVkLlxuICpcbiAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0IHRvIGFkZCB0aGUgdmFsdWUgdG8uXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHByb3BlcnR5IHRoYXQgcmVsYXRlcyB0aGUgdmFsdWUgdG8gdGhlIHN1YmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGFkZC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgIFtwcm9wZXJ0eUlzQXJyYXldIHRydWUgaWYgdGhlIHByb3BlcnR5IGlzIGFsd2F5cyBhbiBhcnJheSwgZmFsc2VcbiAqICAgICAgICAgIGlmIG5vdCAoZGVmYXVsdDogZmFsc2UpLlxuICogICAgICAgIFt2YWx1ZUlzQXJyYXldIHRydWUgaWYgdGhlIHZhbHVlIHRvIGJlIGFkZGVkIHNob3VsZCBiZSBwcmVzZXJ2ZWQgYXNcbiAqICAgICAgICAgIGFuIGFycmF5IChsaXN0cykgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICBbYWxsb3dEdXBsaWNhdGVdIHRydWUgdG8gYWxsb3cgZHVwbGljYXRlcywgZmFsc2Ugbm90IHRvICh1c2VzIGFcbiAqICAgICAgICAgIHNpbXBsZSBzaGFsbG93IGNvbXBhcmlzb24gb2Ygc3ViamVjdCBJRCBvciB2YWx1ZSkgKGRlZmF1bHQ6IHRydWUpLlxuICogICAgICAgIFtwcmVwZW5kVmFsdWVdIGZhbHNlIHRvIHByZXBlbmQgdmFsdWUgdG8gYW55IGV4aXN0aW5nIHZhbHVlcy5cbiAqICAgICAgICAgIChkZWZhdWx0OiBmYWxzZSlcbiAqL1xuYXBpLmFkZFZhbHVlID0gKHN1YmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoISgncHJvcGVydHlJc0FycmF5JyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMucHJvcGVydHlJc0FycmF5ID0gZmFsc2U7XG4gIH1cbiAgaWYoISgndmFsdWVJc0FycmF5JyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMudmFsdWVJc0FycmF5ID0gZmFsc2U7XG4gIH1cbiAgaWYoISgnYWxsb3dEdXBsaWNhdGUnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5hbGxvd0R1cGxpY2F0ZSA9IHRydWU7XG4gIH1cbiAgaWYoISgncHJlcGVuZFZhbHVlJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMucHJlcGVuZFZhbHVlID0gZmFsc2U7XG4gIH1cblxuICBpZihvcHRpb25zLnZhbHVlSXNBcnJheSkge1xuICAgIHN1YmplY3RbcHJvcGVydHldID0gdmFsdWU7XG4gIH0gZWxzZSBpZih0eXBlcy5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmKHZhbHVlLmxlbmd0aCA9PT0gMCAmJiBvcHRpb25zLnByb3BlcnR5SXNBcnJheSAmJlxuICAgICAgIXN1YmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IFtdO1xuICAgIH1cbiAgICBpZihvcHRpb25zLnByZXBlbmRWYWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5jb25jYXQoc3ViamVjdFtwcm9wZXJ0eV0pO1xuICAgICAgc3ViamVjdFtwcm9wZXJ0eV0gPSBbXTtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhcGkuYWRkVmFsdWUoc3ViamVjdCwgcHJvcGVydHksIHZhbHVlW2ldLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZihzdWJqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgIC8vIGNoZWNrIGlmIHN1YmplY3QgYWxyZWFkeSBoYXMgdmFsdWUgaWYgZHVwbGljYXRlcyBub3QgYWxsb3dlZFxuICAgIGNvbnN0IGhhc1ZhbHVlID0gKCFvcHRpb25zLmFsbG93RHVwbGljYXRlICYmXG4gICAgICBhcGkuaGFzVmFsdWUoc3ViamVjdCwgcHJvcGVydHksIHZhbHVlKSk7XG5cbiAgICAvLyBtYWtlIHByb3BlcnR5IGFuIGFycmF5IGlmIHZhbHVlIG5vdCBwcmVzZW50IG9yIGFsd2F5cyBhbiBhcnJheVxuICAgIGlmKCF0eXBlcy5pc0FycmF5KHN1YmplY3RbcHJvcGVydHldKSAmJlxuICAgICAgKCFoYXNWYWx1ZSB8fCBvcHRpb25zLnByb3BlcnR5SXNBcnJheSkpIHtcbiAgICAgIHN1YmplY3RbcHJvcGVydHldID0gW3N1YmplY3RbcHJvcGVydHldXTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbmV3IHZhbHVlXG4gICAgaWYoIWhhc1ZhbHVlKSB7XG4gICAgICBpZihvcHRpb25zLnByZXBlbmRWYWx1ZSkge1xuICAgICAgICBzdWJqZWN0W3Byb3BlcnR5XS51bnNoaWZ0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YmplY3RbcHJvcGVydHldLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBhZGQgbmV3IHZhbHVlIGFzIHNldCBvciBzaW5nbGUgdmFsdWVcbiAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IG9wdGlvbnMucHJvcGVydHlJc0FycmF5ID8gW3ZhbHVlXSA6IHZhbHVlO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgYWxsIG9mIHRoZSB2YWx1ZXMgZm9yIGEgc3ViamVjdCdzIHByb3BlcnR5IGFzIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0LlxuICogQHBhcmFtIHByb3BlcnR5IHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJuIGFsbCBvZiB0aGUgdmFsdWVzIGZvciBhIHN1YmplY3QncyBwcm9wZXJ0eSBhcyBhbiBhcnJheS5cbiAqL1xuYXBpLmdldFZhbHVlcyA9IChzdWJqZWN0LCBwcm9wZXJ0eSkgPT4gW10uY29uY2F0KHN1YmplY3RbcHJvcGVydHldIHx8IFtdKTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcHJvcGVydHkgZnJvbSBhIHN1YmplY3QuXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QuXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHByb3BlcnR5LlxuICovXG5hcGkucmVtb3ZlUHJvcGVydHkgPSAoc3ViamVjdCwgcHJvcGVydHkpID0+IHtcbiAgZGVsZXRlIHN1YmplY3RbcHJvcGVydHldO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSBhIHN1YmplY3QuXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QuXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHByb3BlcnR5IHRoYXQgcmVsYXRlcyB0aGUgdmFsdWUgdG8gdGhlIHN1YmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW3Byb3BlcnR5SXNBcnJheV0gdHJ1ZSBpZiB0aGUgcHJvcGVydHkgaXMgYWx3YXlzIGFuIGFycmF5LCBmYWxzZVxuICogICAgICAgICAgICBpZiBub3QgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqL1xuYXBpLnJlbW92ZVZhbHVlID0gKHN1YmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoISgncHJvcGVydHlJc0FycmF5JyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMucHJvcGVydHlJc0FycmF5ID0gZmFsc2U7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHZhbHVlXG4gIGNvbnN0IHZhbHVlcyA9IGFwaS5nZXRWYWx1ZXMoc3ViamVjdCwgcHJvcGVydHkpLmZpbHRlcihcbiAgICBlID0+ICFhcGkuY29tcGFyZVZhbHVlcyhlLCB2YWx1ZSkpO1xuXG4gIGlmKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICBhcGkucmVtb3ZlUHJvcGVydHkoc3ViamVjdCwgcHJvcGVydHkpO1xuICB9IGVsc2UgaWYodmFsdWVzLmxlbmd0aCA9PT0gMSAmJiAhb3B0aW9ucy5wcm9wZXJ0eUlzQXJyYXkpIHtcbiAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IHZhbHVlc1swXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IHZhbHVlcztcbiAgfVxufTtcblxuLyoqXG4gKiBSZWxhYmVscyBhbGwgYmxhbmsgbm9kZXMgaW4gdGhlIGdpdmVuIEpTT04tTEQgaW5wdXQuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGlucHV0LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbaXNzdWVyXSBhbiBJZGVudGlmaWVySXNzdWVyIHRvIHVzZSB0byBsYWJlbCBibGFuayBub2Rlcy5cbiAqL1xuYXBpLnJlbGFiZWxCbGFua05vZGVzID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBpc3N1ZXIgPSBvcHRpb25zLmlzc3VlciB8fCBuZXcgSWRlbnRpZmllcklzc3VlcignXzpiJyk7XG4gIHJldHVybiBfbGFiZWxCbGFua05vZGVzKGlzc3VlciwgaW5wdXQpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gSlNPTi1MRCB2YWx1ZXMgZm9yIGVxdWFsaXR5LiBUd28gSlNPTi1MRCB2YWx1ZXMgd2lsbCBiZVxuICogY29uc2lkZXJlZCBlcXVhbCBpZjpcbiAqXG4gKiAxLiBUaGV5IGFyZSBib3RoIHByaW1pdGl2ZXMgb2YgdGhlIHNhbWUgdHlwZSBhbmQgdmFsdWUuXG4gKiAyLiBUaGV5IGFyZSBib3RoIEB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBAdmFsdWUsIEB0eXBlLCBAbGFuZ3VhZ2UsXG4gKiAgIGFuZCBAaW5kZXgsIE9SXG4gKiAzLiBUaGV5IGJvdGggaGF2ZSBAaWRzIHRoZXkgYXJlIHRoZSBzYW1lLlxuICpcbiAqIEBwYXJhbSB2MSB0aGUgZmlyc3QgdmFsdWUuXG4gKiBAcGFyYW0gdjIgdGhlIHNlY29uZCB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdjEgYW5kIHYyIGFyZSBjb25zaWRlcmVkIGVxdWFsLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5jb21wYXJlVmFsdWVzID0gKHYxLCB2MikgPT4ge1xuICAvLyAxLiBlcXVhbCBwcmltaXRpdmVzXG4gIGlmKHYxID09PSB2Mikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gMi4gZXF1YWwgQHZhbHVlc1xuICBpZihncmFwaFR5cGVzLmlzVmFsdWUodjEpICYmIGdyYXBoVHlwZXMuaXNWYWx1ZSh2MikgJiZcbiAgICB2MVsnQHZhbHVlJ10gPT09IHYyWydAdmFsdWUnXSAmJlxuICAgIHYxWydAdHlwZSddID09PSB2MlsnQHR5cGUnXSAmJlxuICAgIHYxWydAbGFuZ3VhZ2UnXSA9PT0gdjJbJ0BsYW5ndWFnZSddICYmXG4gICAgdjFbJ0BpbmRleCddID09PSB2MlsnQGluZGV4J10pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIDMuIGVxdWFsIEBpZHNcbiAgaWYodHlwZXMuaXNPYmplY3QodjEpICYmXG4gICAgKCdAaWQnIGluIHYxKSAmJlxuICAgIHR5cGVzLmlzT2JqZWN0KHYyKSAmJlxuICAgICgnQGlkJyBpbiB2MikpIHtcbiAgICByZXR1cm4gdjFbJ0BpZCddID09PSB2MlsnQGlkJ107XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHR3byBzdHJpbmdzIGZpcnN0IGJhc2VkIG9uIGxlbmd0aCBhbmQgdGhlbiBsZXhpY29ncmFwaGljYWxseS5cbiAqXG4gKiBAcGFyYW0gYSB0aGUgZmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBzdHJpbmcuXG4gKlxuICogQHJldHVybiAtMSBpZiBhIDwgYiwgMSBpZiBhID4gYiwgMCBpZiBhID09PSBiLlxuICovXG5hcGkuY29tcGFyZVNob3J0ZXN0TGVhc3QgPSAoYSwgYikgPT4ge1xuICBpZihhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmKGIubGVuZ3RoIDwgYS5sZW5ndGgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZihhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIChhIDwgYikgPyAtMSA6IDE7XG59O1xuXG4vKipcbiAqIExhYmVscyB0aGUgYmxhbmsgbm9kZXMgaW4gdGhlIGdpdmVuIHZhbHVlIHVzaW5nIHRoZSBnaXZlbiBJZGVudGlmaWVySXNzdWVyLlxuICpcbiAqIEBwYXJhbSBpc3N1ZXIgdGhlIElkZW50aWZpZXJJc3N1ZXIgdG8gdXNlLlxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgd2l0aCBibGFuayBub2RlcyB0byByZW5hbWUuXG4gKlxuICogQHJldHVybiB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gX2xhYmVsQmxhbmtOb2Rlcyhpc3N1ZXIsIGVsZW1lbnQpIHtcbiAgaWYodHlwZXMuaXNBcnJheShlbGVtZW50KSkge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbGVtZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICBlbGVtZW50W2ldID0gX2xhYmVsQmxhbmtOb2Rlcyhpc3N1ZXIsIGVsZW1lbnRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNMaXN0KGVsZW1lbnQpKSB7XG4gICAgZWxlbWVudFsnQGxpc3QnXSA9IF9sYWJlbEJsYW5rTm9kZXMoaXNzdWVyLCBlbGVtZW50WydAbGlzdCddKTtcbiAgfSBlbHNlIGlmKHR5cGVzLmlzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgLy8gcmVsYWJlbCBibGFuayBub2RlXG4gICAgaWYoZ3JhcGhUeXBlcy5pc0JsYW5rTm9kZShlbGVtZW50KSkge1xuICAgICAgZWxlbWVudFsnQGlkJ10gPSBpc3N1ZXIuZ2V0SWQoZWxlbWVudFsnQGlkJ10pO1xuICAgIH1cblxuICAgIC8vIHJlY3Vyc2l2ZWx5IGFwcGx5IHRvIGFsbCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQpLnNvcnQoKTtcbiAgICBmb3IobGV0IGtpID0gMDsga2kgPCBrZXlzLmxlbmd0aDsgKytraSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1traV07XG4gICAgICBpZihrZXkgIT09ICdAaWQnKSB7XG4gICAgICAgIGVsZW1lbnRba2V5XSA9IF9sYWJlbEJsYW5rTm9kZXMoaXNzdWVyLCBlbGVtZW50W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIEEgbGlua2VkIGxpc3QgdG8ga2VlcCB0cmFjayBvZiByZWNlbnRseS11c2VkLW5lc3NcbmNvbnN0IFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcblxuY29uc3QgTUFYID0gU3ltYm9sKCdtYXgnKVxuY29uc3QgTEVOR1RIID0gU3ltYm9sKCdsZW5ndGgnKVxuY29uc3QgTEVOR1RIX0NBTENVTEFUT1IgPSBTeW1ib2woJ2xlbmd0aENhbGN1bGF0b3InKVxuY29uc3QgQUxMT1dfU1RBTEUgPSBTeW1ib2woJ2FsbG93U3RhbGUnKVxuY29uc3QgTUFYX0FHRSA9IFN5bWJvbCgnbWF4QWdlJylcbmNvbnN0IERJU1BPU0UgPSBTeW1ib2woJ2Rpc3Bvc2UnKVxuY29uc3QgTk9fRElTUE9TRV9PTl9TRVQgPSBTeW1ib2woJ25vRGlzcG9zZU9uU2V0JylcbmNvbnN0IExSVV9MSVNUID0gU3ltYm9sKCdscnVMaXN0JylcbmNvbnN0IENBQ0hFID0gU3ltYm9sKCdjYWNoZScpXG5jb25zdCBVUERBVEVfQUdFX09OX0dFVCA9IFN5bWJvbCgndXBkYXRlQWdlT25HZXQnKVxuXG5jb25zdCBuYWl2ZUxlbmd0aCA9ICgpID0+IDFcblxuLy8gbHJ1TGlzdCBpcyBhIHlhbGxpc3Qgd2hlcmUgdGhlIGhlYWQgaXMgdGhlIHlvdW5nZXN0XG4vLyBpdGVtLCBhbmQgdGhlIHRhaWwgaXMgdGhlIG9sZGVzdC4gIHRoZSBsaXN0IGNvbnRhaW5zIHRoZSBIaXRcbi8vIG9iamVjdHMgYXMgdGhlIGVudHJpZXMuXG4vLyBFYWNoIEhpdCBvYmplY3QgaGFzIGEgcmVmZXJlbmNlIHRvIGl0cyBZYWxsaXN0Lk5vZGUuICBUaGlzXG4vLyBuZXZlciBjaGFuZ2VzLlxuLy9cbi8vIGNhY2hlIGlzIGEgTWFwIChvciBQc2V1ZG9NYXApIHRoYXQgbWF0Y2hlcyB0aGUga2V5cyB0b1xuLy8gdGhlIFlhbGxpc3QuTm9kZSBvYmplY3QuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJylcbiAgICAgIG9wdGlvbnMgPSB7IG1heDogb3B0aW9ucyB9XG5cbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICBvcHRpb25zID0ge31cblxuICAgIGlmIChvcHRpb25zLm1heCAmJiAodHlwZW9mIG9wdGlvbnMubWF4ICE9PSAnbnVtYmVyJyB8fCBvcHRpb25zLm1heCA8IDApKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcbiAgICAvLyBLaW5kIG9mIHdlaXJkIHRvIGhhdmUgYSBkZWZhdWx0IG1heCBvZiBJbmZpbml0eSwgYnV0IG9oIHdlbGwuXG4gICAgY29uc3QgbWF4ID0gdGhpc1tNQVhdID0gb3B0aW9ucy5tYXggfHwgSW5maW5pdHlcblxuICAgIGNvbnN0IGxjID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGhcbiAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9ICh0eXBlb2YgbGMgIT09ICdmdW5jdGlvbicpID8gbmFpdmVMZW5ndGggOiBsY1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZVxuICAgIGlmIChvcHRpb25zLm1heEFnZSAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhBZ2UgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKVxuICAgIHRoaXNbTUFYX0FHRV0gPSBvcHRpb25zLm1heEFnZSB8fCAwXG4gICAgdGhpc1tESVNQT1NFXSA9IG9wdGlvbnMuZGlzcG9zZVxuICAgIHRoaXNbTk9fRElTUE9TRV9PTl9TRVRdID0gb3B0aW9ucy5ub0Rpc3Bvc2VPblNldCB8fCBmYWxzZVxuICAgIHRoaXNbVVBEQVRFX0FHRV9PTl9HRVRdID0gb3B0aW9ucy51cGRhdGVBZ2VPbkdldCB8fCBmYWxzZVxuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBtYXggY2hhbmdlcy5cbiAgc2V0IG1heCAobUwpIHtcbiAgICBpZiAodHlwZW9mIG1MICE9PSAnbnVtYmVyJyB8fCBtTCA8IDApXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuXG4gICAgdGhpc1tNQVhdID0gbUwgfHwgSW5maW5pdHlcbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IG1heCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYXVxuICB9XG5cbiAgc2V0IGFsbG93U3RhbGUgKGFsbG93U3RhbGUpIHtcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9ICEhYWxsb3dTdGFsZVxuICB9XG4gIGdldCBhbGxvd1N0YWxlICgpIHtcbiAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV1cbiAgfVxuXG4gIHNldCBtYXhBZ2UgKG1BKSB7XG4gICAgaWYgKHR5cGVvZiBtQSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuXG4gICAgdGhpc1tNQVhfQUdFXSA9IG1BXG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXhBZ2UgKCkge1xuICAgIHJldHVybiB0aGlzW01BWF9BR0VdXG4gIH1cblxuICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIGxlbmd0aENhbGN1bGF0b3IgY2hhbmdlcy5cbiAgc2V0IGxlbmd0aENhbGN1bGF0b3IgKGxDKSB7XG4gICAgaWYgKHR5cGVvZiBsQyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIGxDID0gbmFpdmVMZW5ndGhcblxuICAgIGlmIChsQyAhPT0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0pIHtcbiAgICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbENcbiAgICAgIHRoaXNbTEVOR1RIXSA9IDBcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHtcbiAgICAgICAgaGl0Lmxlbmd0aCA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKGhpdC52YWx1ZSwgaGl0LmtleSlcbiAgICAgICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICAgIH0pXG4gICAgfVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbGVuZ3RoQ2FsY3VsYXRvciAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF0gfVxuICBnZXQgaXRlbUNvdW50ICgpIHsgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCB9XG5cbiAgcmZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG5cbiAgZm9yRWFjaCAoZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgY29uc3QgbmV4dCA9IHdhbGtlci5uZXh0XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICAgIHdhbGtlciA9IG5leHRcbiAgICB9XG4gIH1cblxuICBrZXlzICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChrID0+IGsua2V5KVxuICB9XG5cbiAgdmFsdWVzICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChrID0+IGsudmFsdWUpXG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgaWYgKHRoaXNbRElTUE9TRV0gJiZcbiAgICAgICAgdGhpc1tMUlVfTElTVF0gJiZcbiAgICAgICAgdGhpc1tMUlVfTElTVF0ubGVuZ3RoKSB7XG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB0aGlzW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSkpXG4gICAgfVxuXG4gICAgdGhpc1tDQUNIRV0gPSBuZXcgTWFwKCkgLy8gaGFzaCBvZiBpdGVtcyBieSBrZXlcbiAgICB0aGlzW0xSVV9MSVNUXSA9IG5ldyBZYWxsaXN0KCkgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICAgIHRoaXNbTEVOR1RIXSA9IDAgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gIH1cblxuICBkdW1wICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGhpdCA9PlxuICAgICAgaXNTdGFsZSh0aGlzLCBoaXQpID8gZmFsc2UgOiB7XG4gICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICB9KS50b0FycmF5KCkuZmlsdGVyKGggPT4gaClcbiAgfVxuXG4gIGR1bXBMcnUgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXVxuICB9XG5cbiAgc2V0IChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgICBtYXhBZ2UgPSBtYXhBZ2UgfHwgdGhpc1tNQVhfQUdFXVxuXG4gICAgaWYgKG1heEFnZSAmJiB0eXBlb2YgbWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcblxuICAgIGNvbnN0IG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwXG4gICAgY29uc3QgbGVuID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0odmFsdWUsIGtleSlcblxuICAgIGlmICh0aGlzW0NBQ0hFXS5oYXMoa2V5KSkge1xuICAgICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gdGhpc1tDQUNIRV0uZ2V0KGtleSlcbiAgICAgIGNvbnN0IGl0ZW0gPSBub2RlLnZhbHVlXG5cbiAgICAgIC8vIGRpc3Bvc2Ugb2YgdGhlIG9sZCBvbmUgYmVmb3JlIG92ZXJ3cml0aW5nXG4gICAgICAvLyBzcGxpdCBvdXQgaW50byAyIGlmcyBmb3IgYmV0dGVyIGNvdmVyYWdlIHRyYWNraW5nXG4gICAgICBpZiAodGhpc1tESVNQT1NFXSkge1xuICAgICAgICBpZiAoIXRoaXNbTk9fRElTUE9TRV9PTl9TRVRdKVxuICAgICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCBpdGVtLnZhbHVlKVxuICAgICAgfVxuXG4gICAgICBpdGVtLm5vdyA9IG5vd1xuICAgICAgaXRlbS5tYXhBZ2UgPSBtYXhBZ2VcbiAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZVxuICAgICAgdGhpc1tMRU5HVEhdICs9IGxlbiAtIGl0ZW0ubGVuZ3RoXG4gICAgICBpdGVtLmxlbmd0aCA9IGxlblxuICAgICAgdGhpcy5nZXQoa2V5KVxuICAgICAgdHJpbSh0aGlzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgbGVuLCBub3csIG1heEFnZSlcblxuICAgIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gICAgaWYgKGhpdC5sZW5ndGggPiB0aGlzW01BWF0pIHtcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKVxuICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgdmFsdWUpXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgdGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpXG4gICAgdGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZClcbiAgICB0cmltKHRoaXMpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGhhcyAoa2V5KSB7XG4gICAgaWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaGl0ID0gdGhpc1tDQUNIRV0uZ2V0KGtleSkudmFsdWVcbiAgICByZXR1cm4gIWlzU3RhbGUodGhpcywgaGl0KVxuICB9XG5cbiAgZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbiAgfVxuXG4gIHBlZWsgKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbiAgfVxuXG4gIHBvcCAoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXNbTFJVX0xJU1RdLnRhaWxcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgZGVsKHRoaXMsIG5vZGUpXG4gICAgcmV0dXJuIG5vZGUudmFsdWVcbiAgfVxuXG4gIGRlbCAoa2V5KSB7XG4gICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICB9XG5cbiAgbG9hZCAoYXJyKSB7XG4gICAgLy8gcmVzZXQgdGhlIGNhY2hlXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgLy8gQSBwcmV2aW91cyBzZXJpYWxpemVkIGNhY2hlIGhhcyB0aGUgbW9zdCByZWNlbnQgaXRlbXMgZmlyc3RcbiAgICBmb3IgKGxldCBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgICBjb25zdCBoaXQgPSBhcnJbbF1cbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGhpdC5lIHx8IDBcbiAgICAgIGlmIChleHBpcmVzQXQgPT09IDApXG4gICAgICAgIC8vIHRoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3dcbiAgICAgICAgLy8gZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcnVuZSAoKSB7XG4gICAgdGhpc1tDQUNIRV0uZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpKVxuICB9XG59XG5cbmNvbnN0IGdldCA9IChzZWxmLCBrZXksIGRvVXNlKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KVxuICBpZiAobm9kZSkge1xuICAgIGNvbnN0IGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pXG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIGlmIChzZWxmW1VQREFURV9BR0VfT05fR0VUXSlcbiAgICAgICAgICBub2RlLnZhbHVlLm5vdyA9IERhdGUubm93KClcbiAgICAgICAgc2VsZltMUlVfTElTVF0udW5zaGlmdE5vZGUobm9kZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpdC52YWx1ZVxuICB9XG59XG5cbmNvbnN0IGlzU3RhbGUgPSAoc2VsZiwgaGl0KSA9PiB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZltNQVhfQUdFXSkpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIHJldHVybiBoaXQubWF4QWdlID8gZGlmZiA+IGhpdC5tYXhBZ2VcbiAgICA6IHNlbGZbTUFYX0FHRV0gJiYgKGRpZmYgPiBzZWxmW01BWF9BR0VdKVxufVxuXG5jb25zdCB0cmltID0gc2VsZiA9PiB7XG4gIGlmIChzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0pIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSBzZWxmW0xSVV9MSVNUXS50YWlsO1xuICAgICAgc2VsZltMRU5HVEhdID4gc2VsZltNQVhdICYmIHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCB3ZSdyZSBhYm91dCB0byBkZWxldGUgdGhpcyBvbmUsIGFuZCBhbHNvXG4gICAgICAvLyB3aGF0IHRoZSBuZXh0IGxlYXN0IHJlY2VudGx5IHVzZWQga2V5IHdpbGwgYmUsIHNvIGp1c3RcbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBzZXQgaXQgbm93LlxuICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBkZWwoc2VsZiwgd2Fsa2VyKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBkZWwgPSAoc2VsZiwgbm9kZSkgPT4ge1xuICBpZiAobm9kZSkge1xuICAgIGNvbnN0IGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoc2VsZltESVNQT1NFXSlcbiAgICAgIHNlbGZbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKVxuXG4gICAgc2VsZltMRU5HVEhdIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSlcbiAgICBzZWxmW0xSVV9MSVNUXS5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cbn1cblxuY2xhc3MgRW50cnkge1xuICBjb25zdHJ1Y3RvciAoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGlzLm5vdyA9IG5vd1xuICAgIHRoaXMubWF4QWdlID0gbWF4QWdlIHx8IDBcbiAgfVxufVxuXG5jb25zdCBmb3JFYWNoU3RlcCA9IChzZWxmLCBmbiwgbm9kZSwgdGhpc3ApID0+IHtcbiAgbGV0IGhpdCA9IG5vZGUudmFsdWVcbiAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgIGRlbChzZWxmLCBub2RlKVxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pXG4gICAgICBoaXQgPSB1bmRlZmluZWRcbiAgfVxuICBpZiAoaGl0KVxuICAgIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgc2VsZilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvcHJvcGVydHloYW5kbGVyL0lJdGVtUHJvcGVydHlIYW5kbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJDb250ZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJOdW1iZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9wcm9wZXJ0eWhhbmRsZXIvSXRlbVByb3BlcnR5SGFuZGxlclRpbWVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9wcm9wZXJ0eWhhbmRsZXIvSXRlbVByb3BlcnR5SGFuZGxlclVybFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL0lIdG1sUGFyc2VMaXN0ZW5lclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL0lJdGVtU2NvcGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9JVm9jYWJSZWdpc3RyeVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL01pY3JvZGF0YVJkZlBhcnNlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL1V0aWxcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JSHRtbFBhcnNlTGlzdGVuZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JSXRlbVNjb3BlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVZvY2FiUmVnaXN0cnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1pY3JvZGF0YVJkZlBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGh0bWxwYXJzZXIyXzEgPSByZXF1aXJlKFwiaHRtbHBhcnNlcjJcIik7XG5jb25zdCBJdGVtUHJvcGVydHlIYW5kbGVyQ29udGVudF8xID0gcmVxdWlyZShcIi4vcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJDb250ZW50XCIpO1xuY29uc3QgSXRlbVByb3BlcnR5SGFuZGxlck51bWJlcl8xID0gcmVxdWlyZShcIi4vcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJOdW1iZXJcIik7XG5jb25zdCBJdGVtUHJvcGVydHlIYW5kbGVyVGltZV8xID0gcmVxdWlyZShcIi4vcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lXCIpO1xuY29uc3QgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xID0gcmVxdWlyZShcIi4vcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxcIik7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi9VdGlsXCIpO1xuY29uc3QgVk9DQUJfUkVHSVNUUllfREVGQVVMVCA9IHJlcXVpcmUoXCIuL3ZvY2FiLXJlZ2lzdHJ5LWRlZmF1bHQuanNvblwiKTtcbi8qKlxuICogQSBzdHJlYW0gdHJhbnNmb3JtZXIgdGhhdCBwYXJzZXMgTWljcm9kYXRhICh0ZXh0KSBzdHJlYW1zIHRvIGFuIHtAbGluayBSREYuU3RyZWFtfS5cbiAqL1xuY2xhc3MgTWljcm9kYXRhUmRmUGFyc2VyIGV4dGVuZHMgc3RyZWFtXzEuVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHsgcmVhZGFibGVPYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICAvLyBTdGFja3MsIHdoZXJlIHRoZSBrZXkgaXMgdGhlIGN1cnJlbnQgZGVwdGguXG4gICAgICAgIHRoaXMuaXRlbVNjb3BlU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy50ZXh0QnVmZmVyU3RhY2sgPSBbXTtcbiAgICAgICAgLy8gVmFyaWFibGVzIGZvciBtYW5hZ2luZyBpdGVtcmVmcy5cbiAgICAgICAgdGhpcy5pc0VtaXR0aW5nUmVmZXJlbmNlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdJdGVtUmVmc0RvbWFpbiA9IHt9O1xuICAgICAgICB0aGlzLnBlbmRpbmdJdGVtUmVmc1JhbmdlRmluYWxpemVkID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBsaW5lcy1iZXR3ZWVuLWNsYXNzLW1lbWJlcnNcbiAgICAgICAgdGhpcy5wZW5kaW5nSXRlbVJlZnNSYW5nZUNvbGxlY3RpbmcgPSB7fTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudXRpbCA9IG5ldyBVdGlsXzEuVXRpbChvcHRpb25zLmRhdGFGYWN0b3J5LCBvcHRpb25zLmJhc2VJUkkpO1xuICAgICAgICB0aGlzLmRlZmF1bHRHcmFwaCA9IG9wdGlvbnMuZGVmYXVsdEdyYXBoIHx8IHRoaXMudXRpbC5kYXRhRmFjdG9yeS5kZWZhdWx0R3JhcGgoKTtcbiAgICAgICAgdGhpcy5odG1sUGFyc2VMaXN0ZW5lciA9IG9wdGlvbnMuaHRtbFBhcnNlTGlzdGVuZXI7XG4gICAgICAgIHRoaXMudm9jYWJSZWdpc3RyeSA9IG9wdGlvbnMudm9jYWJSZWdpc3RyeSB8fCBWT0NBQl9SRUdJU1RSWV9ERUZBVUxUO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHRoaXMuaW5pdGlhbGl6ZVBhcnNlcighIW9wdGlvbnMueG1sTW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gdGV4dCBzdHJlYW0gaW50byBhIHF1YWQgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7Tm9kZUpTLkV2ZW50RW1pdHRlcn0gc3RyZWFtIEEgdGV4dCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7UkRGLlN0cmVhbX0gQSBxdWFkIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbXBvcnQoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBzdHJlYW1fMS5QYXNzVGhyb3VnaCh7IHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIChlcnJvcikgPT4gcGFyc2VkLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgKGRhdGEpID0+IG91dHB1dC5wdXNoKGRhdGEpKTtcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiBvdXRwdXQucHVzaChudWxsKSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IG91dHB1dC5waXBlKG5ldyBNaWNyb2RhdGFSZGZQYXJzZXIodGhpcy5vcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnBhcnNlci53cml0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIF9mbHVzaChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnBhcnNlci5lbmQoKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGl0ZW0gc2NvcGUgZm9yIHRoZSBjdXJyZW50IGRlcHRoLlxuICAgICAqIFRoaXMgd2lsbCBza2lwIGFsbCB1bmRlZmluZWQgaXRlbSBzY29wZXMuXG4gICAgICogQHBhcmFtIHBhcmVudCBJZiB3ZSBzaG91bGQgc3RhcnQgbG9va2luZyBvbmUgbGV2ZWwgaGlnaGVyIGluIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBnZXRJdGVtU2NvcGUocGFyZW50KSB7XG4gICAgICAgIGxldCBwYXJlbnRUYWdJID0gdGhpcy5pdGVtU2NvcGVTdGFjay5sZW5ndGggLSAocGFyZW50ID8gMiA6IDEpO1xuICAgICAgICB3aGlsZSAocGFyZW50VGFnSSA+IDAgJiYgIXRoaXMuaXRlbVNjb3BlU3RhY2tbcGFyZW50VGFnSV0pIHtcbiAgICAgICAgICAgIHBhcmVudFRhZ0ktLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtU2NvcGVTdGFja1twYXJlbnRUYWdJXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHN0YWNrIGRlcHRoLlxuICAgICAqL1xuICAgIGdldERlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtU2NvcGVTdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIG9uVGFnT3BlbihuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VtaXR0aW5nUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRhZyBoYXMgYW4gJ2lkJywgc3RhcnQgY29sbGVjdGluZyB0aGUgd2hvbGUgc3RhY2sgaW4gdGhlIGl0ZW0gcmVmZXJlbmNlIGJ1ZmZlclxuICAgICAgICAgICAgaWYgKCdpZCcgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gYXR0cmlidXRlcy5pZDtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJdGVtUmVmc1JhbmdlQ29sbGVjdGluZ1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgIGlkczogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoaXMgZXZlbnQgaW4gYWxsIGNvbGxlY3RpbmcgaXRlbSByZWZlcmVuY2UgYnVmZmVyc1xuICAgICAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnBlbmRpbmdJdGVtUmVmc1JhbmdlQ29sbGVjdGluZykpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuY291bnRlcisrO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5ldmVudHMucHVzaCh7IHR5cGU6ICdvcGVuJywgbmFtZSwgYXR0cmlidXRlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHRleHQgYnVmZmVyIHN0YWNrIGlzIGluIGxpbmUgd2l0aCB0aGUgc3RhY2sgZGVwdGhcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tdXNlbGVzcy11bmRlZmluZWRcbiAgICAgICAgdGhpcy50ZXh0QnVmZmVyU3RhY2sucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAvLyBQcm9jZXNzaW5nIHN0ZXBzIGJhc2VkIG9uIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9taWNyb2RhdGEtcmRmLyNyZGYtY29udmVyc2lvbi1hbGdvcml0aG1cbiAgICAgICAgLy8gMS4gRGV0ZXJtaW5lIHRoZSBjdXJyZW50IGl0ZW0gc2NvcGVcbiAgICAgICAgbGV0IGl0ZW1TY29wZTtcbiAgICAgICAgaWYgKCdpdGVtc2NvcGUnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBpdGVtIHNjb3BlXG4gICAgICAgICAgICBsZXQgc3ViamVjdDtcbiAgICAgICAgICAgIGlmICh0aGlzLmVtaXR0aW5nUmVmZXJlbmNlc0l0ZW1TY29wZUlkR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgc3ViamVjdCA9IHRoaXMuZW1pdHRpbmdSZWZlcmVuY2VzSXRlbVNjb3BlSWRHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YmplY3QgPSAnaXRlbWlkJyBpbiBhdHRyaWJ1dGVzICYmIHRoaXMudXRpbC5jcmVhdGVTdWJqZWN0KGF0dHJpYnV0ZXMuaXRlbWlkKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnV0aWwuZGF0YUZhY3RvcnkuYmxhbmtOb2RlKCk7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGdlbmVyZXJhdGVkIGlkIGluIGFsbCBjb2xsZWN0aW5nIGl0ZW0gcmVmZXJlbmNlIGJ1ZmZlcnNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBPYmplY3QudmFsdWVzKHRoaXMucGVuZGluZ0l0ZW1SZWZzUmFuZ2VDb2xsZWN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIuaWRzLnB1c2goc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbVNjb3BlID0geyBzdWJqZWN0IH07XG4gICAgICAgICAgICAvLyBJZiB0aGUgaWQgd2FzIHJldXNlZCBmcm9tIGEgcmVmZXJlbmNlLCBibG9jayBhbnkgbmV3IHRyaXBsZXMgdG8gYmUgZ2VuZXJhdGVkIGZyb20gaXRcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW1pdHRpbmdSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgaXRlbVNjb3BlLmJsb2NrRW1pc3Npb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5oZXJpdCB2b2NhYiBmcm9tIHBhcmVudCBpdGVtIHNjb3BlXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJdGVtU2NvcGUgPSB0aGlzLmdldEl0ZW1TY29wZSgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudEl0ZW1TY29wZSAmJiBwYXJlbnRJdGVtU2NvcGUudm9jYWIpIHtcbiAgICAgICAgICAgICAgICBpdGVtU2NvcGUudm9jYWIgPSBwYXJlbnRJdGVtU2NvcGUudm9jYWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyLiBQdXNoIGFueSBjaGFuZ2VzIHRvIHRoZSBpdGVtIHNjb3BlIHRvIHRoZSBzdGFja1xuICAgICAgICAgICAgdGhpcy5pdGVtU2NvcGVTdGFjay5wdXNoKGl0ZW1TY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBhcmVudCBpdGVtIHNjb3BlXG4gICAgICAgICAgICBpdGVtU2NvcGUgPSB0aGlzLmdldEl0ZW1TY29wZSgpO1xuICAgICAgICAgICAgLy8gMi4gUHVzaCBhbnkgY2hhbmdlcyB0byB0aGUgaXRlbSBzY29wZSB0byB0aGUgc3RhY2tcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLXVzZWxlc3MtdW5kZWZpbmVkXG4gICAgICAgICAgICB0aGlzLml0ZW1TY29wZVN0YWNrLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgdmFsaWQgaXRlbSBzY29wZSwgcHJvY2VzcyB0aGUgY3VycmVudCBub2RlXG4gICAgICAgIGlmIChpdGVtU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIDMuIEhhbmRsZSBpdGVtIHR5cGVzXG4gICAgICAgICAgICBpZiAoJ2l0ZW10eXBlJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMudXRpbC5jcmVhdGVWb2NhYklyaXMoYXR0cmlidXRlcy5pdGVtdHlwZSwgaXRlbVNjb3BlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gNC4gVm9jYWIgaWRlbnRpZmllciBpcyB0aGUgZmlyc3QgdmFsaWQgaXRlbVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1TY29wZS52b2NhYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNS4gTW9kaWZ5IHZvY2FiIGJhc2VkIG9uIHJlZ2lzdHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtU2NvcGUudm9jYWIgPSB0aGlzLnV0aWwuZGVyaXZlVm9jYWIodHlwZS52YWx1ZSwgdGhpcy52b2NhYlJlZ2lzdHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IGl0ZW0gdHlwZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1TY29wZS5ibG9ja0VtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUoaXRlbVNjb3BlLnN1YmplY3QsIHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoYCR7VXRpbF8xLlV0aWwuUkRGfXR5cGVgKSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYXZlIGxhbmd1YWdlIGluIGl0ZW0gc2NvcGVcbiAgICAgICAgICAgIGlmICgnbGFuZycgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGl0ZW1TY29wZS5sYW5ndWFnZSA9IGF0dHJpYnV0ZXMubGFuZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgneG1sOmxhbmcnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpdGVtU2NvcGUubGFuZ3VhZ2UgPSBhdHRyaWJ1dGVzWyd4bWw6bGFuZyddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIGl0ZW1yZWZzIChvbmx5IGlmIHdlIGFsc28gaGFkIGFuIGl0ZW1zY29wZSlcbiAgICAgICAgICAgIGlmICgnaXRlbXNjb3BlJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBpdGVtcmVmLCBzdG9yZSBpdCBpbiBvdXIgZG9tYWluIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNFbWl0dGluZ1JlZmVyZW5jZXMgJiYgJ2l0ZW1yZWYnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWZlcmVuY2Ugb2YgYXR0cmlidXRlcy5pdGVtcmVmLnNwbGl0KC9cXHMrL3UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWZlcmVuY2UgaW4gdGhpcy5wZW5kaW5nSXRlbVJlZnNEb21haW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSXRlbVJlZnNEb21haW5bcmVmZXJlbmNlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSXRlbVJlZnNEb21haW5bcmVmZXJlbmNlXS5wdXNoKGl0ZW1TY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVRvRW1pdFJlZmVyZW5jZXMocmVmZXJlbmNlLCBpdGVtU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDYuIEhhbmRsZSBpdGVtIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCdpdGVtcHJvcCcgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVJdGVtUHJvcGVydGllcyhhdHRyaWJ1dGVzLml0ZW1wcm9wLCBmYWxzZSwgaXRlbVNjb3BlLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgcmV2ZXJzZSBpdGVtIHByb3BlcnRpZXNcbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL21pY3JvZGF0YS1yZGYvI3JldmVyc2UtaXRlbXByb3BcbiAgICAgICAgaWYgKCdpdGVtcHJvcC1yZXZlcnNlJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUl0ZW1Qcm9wZXJ0aWVzKGF0dHJpYnV0ZXNbJ2l0ZW1wcm9wLXJldmVyc2UnXSwgdHJ1ZSwgaXRlbVNjb3BlLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblRleHQoZGF0YSkge1xuICAgICAgICAvLyBTdG9yZSB0aGlzIGV2ZW50IGluIGFsbCBjb2xsZWN0aW5nIGl0ZW0gcmVmZXJlbmNlIGJ1ZmZlcnNcbiAgICAgICAgaWYgKCF0aGlzLmlzRW1pdHRpbmdSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBPYmplY3QudmFsdWVzKHRoaXMucGVuZGluZ0l0ZW1SZWZzUmFuZ2VDb2xsZWN0aW5nKSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5ldmVudHMucHVzaCh7IHR5cGU6ICd0ZXh0JywgZGF0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTYXZlIHRoZSB0ZXh0IGluc2lkZSBhbGwgaXRlbSBzY29wZXMgdGhhdCBuZWVkIHRvIGNvbGxlY3QgdGV4dFxuICAgICAgICBmb3IgKGNvbnN0IHRleHRCdWZmZXIgb2YgdGhpcy50ZXh0QnVmZmVyU3RhY2spIHtcbiAgICAgICAgICAgIGlmICh0ZXh0QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGV4dEJ1ZmZlci5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9uVGFnQ2xvc2UoKSB7XG4gICAgICAgIC8vIFN0b3JlIHRoaXMgZXZlbnQgaW4gYWxsIGNvbGxlY3RpbmcgaXRlbSByZWZlcmVuY2UgYnVmZmVyc1xuICAgICAgICBpZiAoIXRoaXMuaXNFbWl0dGluZ1JlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3JlZmVyZW5jZSwgYnVmZmVyXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnBlbmRpbmdJdGVtUmVmc1JhbmdlQ29sbGVjdGluZykpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuY291bnRlci0tO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5ldmVudHMucHVzaCh7IHR5cGU6ICdjbG9zZScgfSk7XG4gICAgICAgICAgICAgICAgLy8gT25jZSB0aGUgY291bnRlciBiZWNvbWVzIHplcm8sIHRoZSB0YWcgaXMgZnVsbHkgYnVmZmVyZWQsIHNvIHdlIGZpbmFsaXplIGl0LlxuICAgICAgICAgICAgICAgIGlmIChidWZmZXIuY291bnRlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJdGVtUmVmc1JhbmdlRmluYWxpemVkW3JlZmVyZW5jZV0gPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdJdGVtUmVmc1JhbmdlQ29sbGVjdGluZ1tyZWZlcmVuY2VdO1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZW1pdCB0aGlzIHJlZmVyZW5jZSB3aXRoIGJ1ZmZlcmVkIGRvbWFpbiBpdGVtc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVRvRW1pdFJlZmVyZW5jZXMocmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1pdCBhbGwgdHJpcGxlcyB0aGF0IHdlcmUgZGV0ZXJtaW5lZCBpbiB0aGUgYWN0aXZlIHRhZ1xuICAgICAgICBjb25zdCBpdGVtU2NvcGUgPSB0aGlzLmdldEl0ZW1TY29wZSh0cnVlKTtcbiAgICAgICAgaWYgKGl0ZW1TY29wZSkge1xuICAgICAgICAgICAgY29uc3QgZGVwdGggPSB0aGlzLmdldERlcHRoKCk7XG4gICAgICAgICAgICBpZiAoaXRlbVNjb3BlLnByZWRpY2F0ZXMgJiYgZGVwdGggaW4gaXRlbVNjb3BlLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtwcmVkaWNhdGVLZXksIHByZWRpY2F0ZXNdIG9mIE9iamVjdC5lbnRyaWVzKGl0ZW1TY29wZS5wcmVkaWNhdGVzW2RlcHRoXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgaGF2ZSBhIGNoaWxkIGl0ZW0gc2NvcGUsIG90aGVyd2lzZSBnZXQgdGhlIHRleHQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAvLyBTYWZlbHkgY2FzdCB0ZXh0QnVmZmVyU3RhY2ssIGFzIGl0IGlzIGFsd2F5cyBkZWZpbmVkIHdoZW4gaXRlbVNjb3BlLnByZWRpY2F0ZXMgaXMgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy51dGlsLmNyZWF0ZUxpdGVyYWwodGhpcy50ZXh0QnVmZmVyU3RhY2tbZGVwdGhdLmpvaW4oJycpLCBpdGVtU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRQcmVkaWNhdGVUcmlwbGVzKGl0ZW1TY29wZSwgcHJlZGljYXRlcywgb2JqZWN0LCBwcmVkaWNhdGVLZXkgPT09ICdyZXZlcnNlJyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtU2NvcGUucHJlZGljYXRlc1tkZXB0aF1bcHJlZGljYXRlS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBhY3RpdmUgdGFnIGZyb20gdGhlIHN0YWNrXG4gICAgICAgIHRoaXMuaXRlbVNjb3BlU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMudGV4dEJ1ZmZlclN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICBvbkVuZCgpIHtcbiAgICAgICAgLy8gTm90aGluZyBpbXBvcnRhbnQgc2hvdWxkIGhhcHBlbiBoZXJlLlxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IEh0bWxQYXJzZXIuXG4gICAgICogQHBhcmFtIHhtbE1vZGUgSWYgdGhlIHBhcnNlciBzaG91bGQgYmUgc2V0dXAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZVBhcnNlcih4bWxNb2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgaHRtbHBhcnNlcjJfMS5QYXJzZXIoe1xuICAgICAgICAgICAgb25jbG9zZXRhZzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UYWdDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5odG1sUGFyc2VMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odG1sUGFyc2VMaXN0ZW5lci5vblRhZ0Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uZW5kOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5odG1sUGFyc2VMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odG1sUGFyc2VMaXN0ZW5lci5vbkVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbm9wZW50YWc6IChuYW1lLCBhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRhZ09wZW4obmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmh0bWxQYXJzZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmh0bWxQYXJzZUxpc3RlbmVyLm9uVGFnT3BlbihuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb250ZXh0OiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UZXh0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5odG1sUGFyc2VMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odG1sUGFyc2VMaXN0ZW5lci5vblRleHQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZGVjb2RlRW50aXRpZXM6IHRydWUsXG4gICAgICAgICAgICByZWNvZ25pemVTZWxmQ2xvc2luZzogdHJ1ZSxcbiAgICAgICAgICAgIHhtbE1vZGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGdpdmVuIGl0ZW0gcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0gaXRlbXByb3BWYWx1ZSBUaGUgdmFsdWUgb2YgaXRlbXByb3Agb3IgaXRlbXByb3AtcmV2ZXJzZS5cbiAgICAgKiBAcGFyYW0gcmV2ZXJzZSBJZiB0aGUgaXRlbSBwcm9wZXJ0aWVzIGFyZSByZXZlcnNlZCAoaXRlbXByb3AtcmV2ZXJzZSkuXG4gICAgICogQHBhcmFtIGl0ZW1TY29wZSBUaGUgY3VycmVudCBpdGVtIHNjb3BlLlxuICAgICAqIEBwYXJhbSB0YWdOYW1lIFRoZSBjdXJyZW50IHRhZyBuYW1lLlxuICAgICAqIEBwYXJhbSB0YWdBdHRyaWJ1dGVzIFRoZSBjdXJyZW50IHRhZyBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIGhhbmRsZUl0ZW1Qcm9wZXJ0aWVzKGl0ZW1wcm9wVmFsdWUsIHJldmVyc2UsIGl0ZW1TY29wZSwgdGFnTmFtZSwgdGFnQXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBwYXJlbnRJdGVtU2NvcGUgPSB0aGlzLmdldEl0ZW1TY29wZSh0cnVlKTtcbiAgICAgICAgaWYgKHBhcmVudEl0ZW1TY29wZSkge1xuICAgICAgICAgICAgLy8gU2V0IHByZWRpY2F0ZXMgaW4gdGhlIHNjb3BlLCBhbmQgaGFuZGxlIHRoZW0gb24gdGFnIGNsb3NlLlxuICAgICAgICAgICAgY29uc3QgZGVwdGggPSB0aGlzLmdldERlcHRoKCk7XG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGVzID0gdGhpcy51dGlsLmNyZWF0ZVZvY2FiSXJpcyhpdGVtcHJvcFZhbHVlLCBwYXJlbnRJdGVtU2NvcGUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRJdGVtU2NvcGUucHJlZGljYXRlcykge1xuICAgICAgICAgICAgICAgIHBhcmVudEl0ZW1TY29wZS5wcmVkaWNhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmVudEl0ZW1TY29wZS5wcmVkaWNhdGVzW2RlcHRoXSkge1xuICAgICAgICAgICAgICAgIHBhcmVudEl0ZW1TY29wZS5wcmVkaWNhdGVzW2RlcHRoXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlc0tleSA9IHJldmVyc2UgPyAncmV2ZXJzZScgOiAnZm9yd2FyZCc7XG4gICAgICAgICAgICBwYXJlbnRJdGVtU2NvcGUucHJlZGljYXRlc1tkZXB0aF1bcHJlZGljYXRlc0tleV0gPSBwcmVkaWNhdGVzO1xuICAgICAgICAgICAgLy8gQXBwZW5kIHJkZjp0eXBlIHByZWRpY2F0ZSBpZiB2b2NhYnVsYXJ5IGV4cGFuc2lvbiBhcHBsaWVzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZvY2FidWxhcnlFeHBhbnNpb25UeXBlIG9mIHRoaXMudXRpbC5nZXRWb2NhYnVsYXJ5RXhwYW5zaW9uVHlwZShpdGVtcHJvcFZhbHVlLCBwYXJlbnRJdGVtU2NvcGUsIHRoaXMudm9jYWJSZWdpc3RyeSkpIHtcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGVzLnB1c2godm9jYWJ1bGFyeUV4cGFuc2lvblR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBwcm9wZXJ0eSBoYW5kbGVyIHRoYXQgYXBwbGllcywgZm9yY2VmdWxseSB1c2UgdGhhdCBhcyBwcmVkaWNhdGUgdmFsdWUuXG4gICAgICAgICAgICAvLyBCdXQgRE9OJ1QgY2FsbCBoYW5kbGVycyBpbiB0aGlzIHByb3AgaXMgYSBkaXJlY3QgKG5lc3RlZCkgaXRlbXNjb3BlLlxuICAgICAgICAgICAgaWYgKGl0ZW1TY29wZSAmJiAnaXRlbXNjb3BlJyBpbiB0YWdBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UHJlZGljYXRlVHJpcGxlcyhwYXJlbnRJdGVtU2NvcGUsIHByZWRpY2F0ZXMsIGl0ZW1TY29wZS5zdWJqZWN0LCByZXZlcnNlKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5hbGl6ZSB0aGUgcHJlZGljYXRlcywgc28gdGV4dCB2YWx1ZXMgZG8gbm90IGFwcGx5IHRvIHRoZW0uXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudEl0ZW1TY29wZS5wcmVkaWNhdGVzW2RlcHRoXVtwcmVkaWNhdGVzS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBNaWNyb2RhdGFSZGZQYXJzZXIuSVRFTV9QUk9QRVJUWV9IQU5ETEVSUykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodGFnTmFtZSwgdGFnQXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IGhhbmRsZXIuZ2V0T2JqZWN0KHRhZ0F0dHJpYnV0ZXMsIHRoaXMudXRpbCwgcGFyZW50SXRlbVNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFByZWRpY2F0ZVRyaXBsZXMocGFyZW50SXRlbVNjb3BlLCBwcmVkaWNhdGVzLCBvYmplY3QsIHJldmVyc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluYWxpemUgdGhlIHByZWRpY2F0ZXMsIHNvIHRleHQgdmFsdWVzIGRvIG5vdCBhcHBseSB0byB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudEl0ZW1TY29wZS5wcmVkaWNhdGVzW2RlcHRoXVtwcmVkaWNhdGVzS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vIHZhbGlkIGhhbmRsZXIgd2FzIGZvdW5kLCBpbmRpY2F0ZSB0aGF0IHdlIHNob3VsZCBjb2xsZWN0IHRleHQgYXQgdGhpcyBkZXB0aC5cbiAgICAgICAgICAgIGlmIChwYXJlbnRJdGVtU2NvcGUucHJlZGljYXRlc1tkZXB0aF1bcHJlZGljYXRlc0tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRCdWZmZXJTdGFja1tkZXB0aF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IHRoZSBnaXZlbiBvYmplY3QgZm9yIHRoZSBnaXZlbiBwcmVkaWNhdGVzLlxuICAgICAqIEBwYXJhbSBpdGVtU2NvcGUgVGhlIGN1cnJlbnQgaXRlbSBzY29wZS5cbiAgICAgKiBAcGFyYW0gcHJlZGljYXRlcyBBbiBhcnJheSBvZiBwcmVkaWNhdGVzLlxuICAgICAqIEBwYXJhbSBvYmplY3QgQW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSByZXZlcnNlIElmIHRoZSB0cmlwbGVzIHNob3VsZCBiZSByZXZlcnNlZC5cbiAgICAgKi9cbiAgICBlbWl0UHJlZGljYXRlVHJpcGxlcyhpdGVtU2NvcGUsIHByZWRpY2F0ZXMsIG9iamVjdCwgcmV2ZXJzZSkge1xuICAgICAgICBpZiAoIWl0ZW1TY29wZS5ibG9ja0VtaXNzaW9uKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiBwcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGl0ZXJhbHMgY2FuIG5vdCBleGlzdCBpbiBzdWJqZWN0IHBvc2l0aW9uLCBzbyB0aGV5IG11c3QgYmUgaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC50ZXJtVHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUob2JqZWN0LCBwcmVkaWNhdGUsIGl0ZW1TY29wZS5zdWJqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKGl0ZW1TY29wZS5zdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgdGhlIGdpdmVuIHRyaXBsZSB0byB0aGUgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7UXVhZF9TdWJqZWN0fSBzdWJqZWN0IEEgc3ViamVjdCB0ZXJtLlxuICAgICAqIEBwYXJhbSB7UXVhZF9QcmVkaWNhdGV9IHByZWRpY2F0ZSBBIHByZWRpY2F0ZSB0ZXJtLlxuICAgICAqIEBwYXJhbSB7UXVhZF9PYmplY3R9IG9iamVjdCBBbiBvYmplY3QgdGVybS5cbiAgICAgKi9cbiAgICBlbWl0VHJpcGxlKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KSB7XG4gICAgICAgIHRoaXMucHVzaCh0aGlzLnV0aWwuZGF0YUZhY3RvcnkucXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgdGhpcy5kZWZhdWx0R3JhcGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBlbWl0IGFsbCBwZW5kaW5nIGl0ZW1yZWZzIGZvciB0aGUgZ2l2ZW4gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSByZWZlcmVuY2UgQW4gaXRlbSByZWZlcmVuY2UgaWQuXG4gICAgICogQHBhcmFtIGl0ZW1TY29wZURvbWFpbiBBbiBvcHRpb25hbCBpdGVtIHNjb3BlLiBJZiBkZWZpbmVkLCBvbmx5IHJlZnMgZnJvbSB0aGlzIHNjb3BlIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cbiAgICB0cnlUb0VtaXRSZWZlcmVuY2VzKHJlZmVyZW5jZSwgaXRlbVNjb3BlRG9tYWluKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5wZW5kaW5nSXRlbVJlZnNSYW5nZUZpbmFsaXplZFtyZWZlcmVuY2VdO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgaXRlbSBzY29wZSBkb21haW5zIHRvIGVtaXRcbiAgICAgICAgICAgIGxldCBhcHBsaWNhYmxlSXRlbVNjb3BlcztcbiAgICAgICAgICAgIGlmIChpdGVtU2NvcGVEb21haW4pIHtcbiAgICAgICAgICAgICAgICBhcHBsaWNhYmxlSXRlbVNjb3BlcyA9IFtpdGVtU2NvcGVEb21haW5dO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBwZW5kaW5nIGFycmF5XG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IGluIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1TY29wZURvbWFpbkluZGV4ID0gdGhpcy5wZW5kaW5nSXRlbVJlZnNEb21haW5bcmVmZXJlbmNlXS5pbmRleE9mKGl0ZW1TY29wZURvbWFpbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSXRlbVJlZnNEb21haW5bcmVmZXJlbmNlXS5zcGxpY2UoaXRlbVNjb3BlRG9tYWluSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwbGljYWJsZUl0ZW1TY29wZXMgPSB0aGlzLnBlbmRpbmdJdGVtUmVmc0RvbWFpbltyZWZlcmVuY2VdO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgaXRlbXMgZnJvbSB0aGUgcGVuZGluZyBhcnJheVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdJdGVtUmVmc0RvbWFpbltyZWZlcmVuY2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFwcGxpY2FibGVJdGVtU2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgc3RhY2sgc3RhdGVcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtU2NvcGVTdGFja09sZCA9IHRoaXMuaXRlbVNjb3BlU3RhY2s7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEJ1ZmZlclN0YWNrT2xkID0gdGhpcy50ZXh0QnVmZmVyU3RhY2s7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0VtaXR0aW5nUmVmZXJlbmNlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGFsbCBhcHBsaWNhYmxlIGl0ZW0gc2NvcGVzLCBlbWl0IHRoZSBidWZmZXJlZCBldmVudHMuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtU2NvcGUgb2YgYXBwbGljYWJsZUl0ZW1TY29wZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtU2NvcGVTdGFjayA9IFtpdGVtU2NvcGVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRCdWZmZXJTdGFjayA9IFt1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nSWRzID0gcmFuZ2UuaWRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRpbmdSZWZlcmVuY2VzSXRlbVNjb3BlSWRHZW5lcmF0b3IgPSAoKSA9PiBwZW5kaW5nSWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgcmFuZ2UuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRhZ09wZW4oZXZlbnQubmFtZSwgZXZlbnQuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGV4dChldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGFnQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgc3RhY2sgc3RhdGVcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0aW5nUmVmZXJlbmNlc0l0ZW1TY29wZUlkR2VuZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbVNjb3BlU3RhY2sgPSBpdGVtU2NvcGVTdGFja09sZDtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRCdWZmZXJTdGFjayA9IHRleHRCdWZmZXJTdGFja09sZDtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRW1pdHRpbmdSZWZlcmVuY2VzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk1pY3JvZGF0YVJkZlBhcnNlciA9IE1pY3JvZGF0YVJkZlBhcnNlcjtcbk1pY3JvZGF0YVJkZlBhcnNlci5JVEVNX1BST1BFUlRZX0hBTkRMRVJTID0gW1xuICAgIG5ldyBJdGVtUHJvcGVydHlIYW5kbGVyQ29udGVudF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJDb250ZW50KCksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxfMS5JdGVtUHJvcGVydHlIYW5kbGVyVXJsKCdhJywgJ2hyZWYnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwoJ2FyZWEnLCAnaHJlZicpLFxuICAgIG5ldyBJdGVtUHJvcGVydHlIYW5kbGVyVXJsXzEuSXRlbVByb3BlcnR5SGFuZGxlclVybCgnYXVkaW8nLCAnc3JjJyksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxfMS5JdGVtUHJvcGVydHlIYW5kbGVyVXJsKCdlbWJlZCcsICdzcmMnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwoJ2lmcmFtZScsICdzcmMnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwoJ2ltZycsICdzcmMnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwoJ2xpbmsnLCAnaHJlZicpLFxuICAgIG5ldyBJdGVtUHJvcGVydHlIYW5kbGVyVXJsXzEuSXRlbVByb3BlcnR5SGFuZGxlclVybCgnb2JqZWN0JywgJ2RhdGEnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwoJ3NvdXJjZScsICdzcmMnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwoJ3RyYWNrJywgJ3NyYycpLFxuICAgIG5ldyBJdGVtUHJvcGVydHlIYW5kbGVyVXJsXzEuSXRlbVByb3BlcnR5SGFuZGxlclVybCgndmlkZW8nLCAnc3JjJyksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJOdW1iZXJfMS5JdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyKCdkYXRhJywgJ3ZhbHVlJyksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJOdW1iZXJfMS5JdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyKCdtZXRlcicsICd2YWx1ZScpLFxuICAgIG5ldyBJdGVtUHJvcGVydHlIYW5kbGVyVGltZV8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lKCksXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWljcm9kYXRhUmRmUGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VdGlsID0gdm9pZCAwO1xuY29uc3QgcmRmX2RhdGFfZmFjdG9yeV8xID0gcmVxdWlyZShcInJkZi1kYXRhLWZhY3RvcnlcIik7XG5jb25zdCByZWxhdGl2ZV90b19hYnNvbHV0ZV9pcmlfMSA9IHJlcXVpcmUoXCJyZWxhdGl2ZS10by1hYnNvbHV0ZS1pcmlcIik7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuY2xhc3MgVXRpbCB7XG4gICAgY29uc3RydWN0b3IoZGF0YUZhY3RvcnksIGJhc2VJUkkpIHtcbiAgICAgICAgdGhpcy5kYXRhRmFjdG9yeSA9IGRhdGFGYWN0b3J5IHx8IG5ldyByZGZfZGF0YV9mYWN0b3J5XzEuRGF0YUZhY3RvcnkoKTtcbiAgICAgICAgdGhpcy5iYXNlSVJJID0gYmFzZUlSSSB8fCAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIElSSSBpcyB2YWxpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXJpIEEgcG90ZW50aWFsIElSSS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZ2l2ZW4gSVJJIGlzIHZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1ZhbGlkSXJpKGlyaSkge1xuICAgICAgICByZXR1cm4gVXRpbC5JUklfUkVHRVgudGVzdChpcmkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdm9jYWIgdGVybXMgZm9yIHRoZSBnaXZlbiB0ZXJtcyBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBSZWxhdGl2ZSBJUklzIHdpbGwgYmUgYmFzZWQgb24gdGhlIGFjdGl2ZSB2b2NhYiBvciBiYXNlSVJJIGlmIGBhbGxvd1JlbGF0aXZlSXJpc2AgaXMgdHJ1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXJtcyBBbiBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtJSXRlbVNjb3BlfSBpdGVtU2NvcGUgVGhlIGFjdGl2ZSBpdGVtIHNjb3BlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dSZWxhdGl2ZUlyaXMgSWYgcmVsYXRpdmUgSVJJcyBhcmUgYWxsb3dlZC5cbiAgICAgKiBAcmV0dXJuIHtUZXJtW119IFRoZSBJUkkgdGVybXMuXG4gICAgICovXG4gICAgY3JlYXRlVm9jYWJJcmlzKHRlcm1zLCBpdGVtU2NvcGUsIGFsbG93UmVsYXRpdmVJcmlzKSB7XG4gICAgICAgIHJldHVybiB0ZXJtcy5zcGxpdCgvXFxzKy91KVxuICAgICAgICAgICAgLmZpbHRlcih0ZXJtID0+ICEhdGVybSlcbiAgICAgICAgICAgIC5tYXAocHJvcGVydHkgPT4ge1xuICAgICAgICAgICAgaWYgKCFVdGlsLmlzVmFsaWRJcmkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd1JlbGF0aXZlSXJpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gYCR7aXRlbVNjb3BlLnZvY2FiIHx8IGAke3RoaXMuYmFzZUlSSX0jYH0ke3Byb3BlcnR5fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhRmFjdG9yeS5uYW1lZE5vZGUocHJvcGVydHkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcih0ZXJtID0+ICEhdGVybSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJlZGljYXRlcyBmb3Igd2hpY2ggdGhlIGdpdmVuIGl0ZW1wcm9wIHZhbHVlIHNob3VsZCBjYXVzZSB2b2NhYnVsYXJ5IGV4cGFuc2lvbi5cbiAgICAgKiBAcGFyYW0gdGVybXMgQW4gYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBpdGVtU2NvcGUgVGhlIGFjdGl2ZSBpdGVtIHNjb3BlLlxuICAgICAqIEBwYXJhbSB2b2NhYlJlZ2lzdHJ5IFRoZSBhY3RpdmUgdm9jYWJ1bGFyeSByZWdpc3RyeS5cbiAgICAgKi9cbiAgICBnZXRWb2NhYnVsYXJ5RXhwYW5zaW9uVHlwZSh0ZXJtcywgaXRlbVNjb3BlLCB2b2NhYlJlZ2lzdHJ5KSB7XG4gICAgICAgIC8vIENoZWNrIHRoZSBwcmVzZW5jZSBvZiBzdWJQcm9wZXJ0eU9mIG9yIGVxdWl2YWxlbnRQcm9wZXJ0eVxuICAgICAgICBjb25zdCBwYXJ0cyA9IHRlcm1zLnNwbGl0KC9cXHMrL3UpO1xuICAgICAgICBpZiAocGFydHMuaW5jbHVkZXMoJ3N1YlByb3BlcnR5T2YnKSB8fCBwYXJ0cy5pbmNsdWRlcygnZXF1aXZhbGVudFByb3BlcnR5JykpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoYCR7VXRpbC5SREZ9dHlwZWApXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpbiB0aGUgaXRlbSBzY29wZSdzIHZvY2FiXG4gICAgICAgIGlmIChpdGVtU2NvcGUudm9jYWIgJiYgaXRlbVNjb3BlLnZvY2FiIGluIHZvY2FiUmVnaXN0cnkgJiYgdm9jYWJSZWdpc3RyeVtpdGVtU2NvcGUudm9jYWJdLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGxldCBwcmVkaWNhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgZXhwYW5zaW9uc10gb2YgT2JqZWN0XG4gICAgICAgICAgICAgICAgLmVudHJpZXModm9jYWJSZWdpc3RyeVtpdGVtU2NvcGUudm9jYWJdLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmluY2x1ZGVzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGVzID0gcHJlZGljYXRlcy5jb25jYXQoT2JqZWN0LnZhbHVlcyhleHBhbnNpb25zKS5tYXAoaXJpID0+IHRoaXMuZGF0YUZhY3RvcnkubmFtZWROb2RlKGlyaSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5hbWVkIG5vZGUgZm9yIHRoZSBnaXZlbiB0ZXJtLCB3aGljaCBjYW4gYmUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IGJhc2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlyaSBBIHRlcm0gc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge1Rlcm19IEFuIFJERiB0ZXJtLCBvciB1bmRlZmluZWQgaWYgaW52YWxpZC5cbiAgICAgKi9cbiAgICBjcmVhdGVTdWJqZWN0KGlyaSkge1xuICAgICAgICBpZiAoIVV0aWwuaXNWYWxpZElyaShpcmkpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlyaSA9IHJlbGF0aXZlX3RvX2Fic29sdXRlX2lyaV8xLnJlc29sdmUoaXJpLCB0aGlzLmJhc2VJUkkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShpcmkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbGl0ZXJhbCBub2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaXRlcmFsIFRoZSBsaXRlcmFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7SUFjdGl2ZVRhZ30gYWN0aXZlVGFnIFRoZSBjdXJyZW50IGFjdGl2ZSB0YWcuXG4gICAgICogQHJldHVybiB7TGl0ZXJhbH0gQSBuZXcgbGl0ZXJhbCBub2RlLlxuICAgICAqL1xuICAgIGNyZWF0ZUxpdGVyYWwobGl0ZXJhbCwgYWN0aXZlVGFnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFGYWN0b3J5LmxpdGVyYWwobGl0ZXJhbCwgYWN0aXZlVGFnLmxhbmd1YWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSB2b2NhYiBJUkkgZnJvbSBhIGdpdmVuIHR5cGUgSVJJLlxuICAgICAqIEBsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9taWNyb2RhdGEtcmRmLyNwcm9wZXJ0eS11cmktZ2VuZXJhdGlvblxuICAgICAqIEBwYXJhbSB0eXBlSXJpIEEgdHlwZSBJUkkuXG4gICAgICogQHBhcmFtIHZvY2FiUmVnaXN0cnkgVGhlIGFjdGl2ZSB2b2NhYnVsYXJ5IHJlZ2lzdHJ5LlxuICAgICAqL1xuICAgIGRlcml2ZVZvY2FiKHR5cGVJcmksIHZvY2FiUmVnaXN0cnkpIHtcbiAgICAgICAgbGV0IHZvY2FiO1xuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBmaW5kIGEgcHJlZml4IGluIHRoZSB2b2NhYiByZWdpc3RyeVxuICAgICAgICBmb3IgKGNvbnN0IHVyaVByZWZpeCBpbiB2b2NhYlJlZ2lzdHJ5KSB7XG4gICAgICAgICAgICBpZiAodHlwZUlyaS5zdGFydHNXaXRoKHVyaVByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICB2b2NhYiA9IHVyaVByZWZpeDtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgZnJhZ21lbnQgaWYgcHJlZml4IGRvZXMgbm90IGVuZCB3aXRoIGEgc2xhc2hcbiAgICAgICAgICAgICAgICBpZiAoIXZvY2FiLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9jYWIgKz0gJyMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBtYXRjaCB3YXMgZm91bmQsIHJlbW92ZSB0aGUgbGFzdCBwYXRoIHNlZ21lbnQgZnJvbSB0aGUgVVJJXG4gICAgICAgIGlmICghdm9jYWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hQb3MgPSB0eXBlSXJpLmluZGV4T2YoJyMnKTtcbiAgICAgICAgICAgIGlmIChoYXNoUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIHZvY2FiID0gdHlwZUlyaS5zbGljZSgwLCBoYXNoUG9zICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2b2NhYiA9IHJlbGF0aXZlX3RvX2Fic29sdXRlX2lyaV8xLnJlc29sdmUoJy4nLCB0eXBlSXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9jYWI7XG4gICAgfVxufVxuZXhwb3J0cy5VdGlsID0gVXRpbDtcblV0aWwuUkRGID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMnO1xuVXRpbC5YU0QgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjJztcblV0aWwuUkRGQSA9ICdodHRwOi8vd3d3LnczLm9yZy9ucy9yZGZhIyc7XG5VdGlsLklSSV9SRUdFWCA9IC9eKFtBLVphLXpdW1xcZCstLkEtWmEtel0qfF8pOlteIFwiPD5bXFxcXFxcXWB7fH1dKiQvdTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JSXRlbVByb3BlcnR5SGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXRlbVByb3BlcnR5SGFuZGxlckNvbnRlbnQgPSB2b2lkIDA7XG4vKipcbiAqIEhhbmRsZXIgZm9yIGFuIGl0ZW0gcHJvcGVydHkgd2l0aCB0aGUgJ2NvbnRlbnQnIGF0dHJpYnV0ZS5cbiAqL1xuY2xhc3MgSXRlbVByb3BlcnR5SGFuZGxlckNvbnRlbnQge1xuICAgIGNhbkhhbmRsZSh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiAnY29udGVudCcgaW4gYXR0cmlidXRlcztcbiAgICB9XG4gICAgZ2V0T2JqZWN0KGF0dHJpYnV0ZXMsIHV0aWwsIGl0ZW1TY29wZSkge1xuICAgICAgICByZXR1cm4gdXRpbC5jcmVhdGVMaXRlcmFsKGF0dHJpYnV0ZXMuY29udGVudCwgaXRlbVNjb3BlKTtcbiAgICB9XG59XG5leHBvcnRzLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJDb250ZW50ID0gSXRlbVByb3BlcnR5SGFuZGxlckNvbnRlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JdGVtUHJvcGVydHlIYW5kbGVyQ29udGVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXRlbVByb3BlcnR5SGFuZGxlck51bWJlciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxfMSA9IHJlcXVpcmUoXCIuLi9VdGlsXCIpO1xuLyoqXG4gKiBIYW5kbGVyIGZvciBhbiBpdGVtIHByb3BlcnR5IHdpdGggYSBudW1iZXIgYXR0cmlidXRlLlxuICovXG5jbGFzcyBJdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgfVxuICAgIGNhbkhhbmRsZSh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZ05hbWUgPT09IHRhZ05hbWUgJiYgdGhpcy5hdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGdldE9iamVjdChhdHRyaWJ1dGVzLCB1dGlsLCBpdGVtU2NvcGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW3RoaXMuYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGxldCBkYXRhdHlwZTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpICYmICF2YWx1ZS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICBkYXRhdHlwZSA9IGAke1V0aWxfMS5VdGlsLlhTRH1pbnRlZ2VyYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghTnVtYmVyLmlzTmFOKE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGRhdGF0eXBlID0gYCR7VXRpbF8xLlV0aWwuWFNEfWRvdWJsZWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWwuZGF0YUZhY3RvcnkubGl0ZXJhbCh2YWx1ZSwgZGF0YXR5cGUgJiYgdXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoZGF0YXR5cGUpKTtcbiAgICB9XG59XG5leHBvcnRzLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJOdW1iZXIgPSBJdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlbVByb3BlcnR5SGFuZGxlck51bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSXRlbVByb3BlcnR5SGFuZGxlclRpbWUgPSB2b2lkIDA7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vVXRpbFwiKTtcbi8qKlxuICogSGFuZGxlciBmb3IgYW4gaXRlbSBwcm9wZXJ0eSBmb3IgdGltZSB0YWdzLlxuICovXG5jbGFzcyBJdGVtUHJvcGVydHlIYW5kbGVyVGltZSB7XG4gICAgY2FuSGFuZGxlKHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICd0aW1lJyAmJiAnZGF0ZXRpbWUnIGluIGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGdldE9iamVjdChhdHRyaWJ1dGVzLCB1dGlsLCBpdGVtU2NvcGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzLmRhdGV0aW1lO1xuICAgICAgICBsZXQgZGF0YXR5cGU7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgSXRlbVByb3BlcnR5SGFuZGxlclRpbWUuVElNRV9SRUdFWEVTKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkucmVnZXguZXhlYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhdHlwZSA9IHV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKFV0aWxfMS5VdGlsLlhTRCArIGVudHJ5LnR5cGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLmRhdGFGYWN0b3J5LmxpdGVyYWwodmFsdWUsIGRhdGF0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lID0gSXRlbVByb3BlcnR5SGFuZGxlclRpbWU7XG5JdGVtUHJvcGVydHlIYW5kbGVyVGltZS5USU1FX1JFR0VYRVMgPSBbXG4gICAge1xuICAgICAgICByZWdleDogL14tP1AoXFxkK1kpPyhcXGQrTSk/KFxcZCtEKT8oVChcXGQrSCk/KFxcZCtNKT8oXFxkKyhcXC5cXGQpP1MpPyk/JC91LFxuICAgICAgICB0eXBlOiAnZHVyYXRpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICByZWdleDogL15cXGQrLVxcZFxcZC1cXGRcXGRUXFxkXFxkOlxcZFxcZDpcXGRcXGQoKFo/KXwoWystXVxcZFxcZDpcXGRcXGQpKSQvdSxcbiAgICAgICAgdHlwZTogJ2RhdGVUaW1lJyxcbiAgICB9LFxuICAgIHsgcmVnZXg6IC9eXFxkKy1cXGRcXGQtXFxkXFxkWj8kL3UsIHR5cGU6ICdkYXRlJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkXFxkOlxcZFxcZDpcXGRcXGQoKFo/KXwoWystXVxcZFxcZDpcXGRcXGQpKSQvdSwgdHlwZTogJ3RpbWUnIH0sXG4gICAgeyByZWdleDogL15cXGQrLVxcZFxcZCQvdSwgdHlwZTogJ2dZZWFyTW9udGgnIH0sXG4gICAgeyByZWdleDogL15cXGQrJC91LCB0eXBlOiAnZ1llYXInIH0sXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlbVByb3BlcnR5SGFuZGxlclRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwgPSB2b2lkIDA7XG5jb25zdCByZWxhdGl2ZV90b19hYnNvbHV0ZV9pcmlfMSA9IHJlcXVpcmUoXCJyZWxhdGl2ZS10by1hYnNvbHV0ZS1pcmlcIik7XG4vKipcbiAqIEhhbmRsZXIgZm9yIGFuIGl0ZW0gcHJvcGVydHkgd2l0aCBhIFVSTCBhdHRyaWJ1dGUuXG4gKi9cbmNsYXNzIEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwge1xuICAgIGNvbnN0cnVjdG9yKHRhZ05hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICB9XG4gICAgY2FuSGFuZGxlKHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnTmFtZSA9PT0gdGFnTmFtZSAmJiB0aGlzLmF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcztcbiAgICB9XG4gICAgZ2V0T2JqZWN0KGF0dHJpYnV0ZXMsIHV0aWwsIGl0ZW1TY29wZSkge1xuICAgICAgICByZXR1cm4gdXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUocmVsYXRpdmVfdG9fYWJzb2x1dGVfaXJpXzEucmVzb2x2ZShhdHRyaWJ1dGVzW3RoaXMuYXR0cmlidXRlTmFtZV0sIHV0aWwuYmFzZUlSSSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuSXRlbVByb3BlcnR5SGFuZGxlclVybCA9IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JdGVtUHJvcGVydHlIYW5kbGVyVXJsLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJodHRwOi8vc2NoZW1hLm9yZy9cIjoge1xuICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICBcImFkZGl0aW9uYWxUeXBlXCI6IHtcInN1YlByb3BlcnR5T2ZcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjdHlwZVwifVxuICAgIH1cbiAgfSxcbiAgXCJodHRwOi8vbWljcm9mb3JtYXRzLm9yZy9wcm9maWxlL2hjYXJkXCI6IHt9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBSREYgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIycsXG4gICAgWFNEID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hIycsXG4gICAgU1dBUCA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwLzEwL3N3YXAvJztcbnZhciBfZGVmYXVsdCA9IHtcbiAgeHNkOiB7XG4gICAgZGVjaW1hbDogWFNEICsgJ2RlY2ltYWwnLFxuICAgIGJvb2xlYW46IFhTRCArICdib29sZWFuJyxcbiAgICBkb3VibGU6IFhTRCArICdkb3VibGUnLFxuICAgIGludGVnZXI6IFhTRCArICdpbnRlZ2VyJyxcbiAgICBzdHJpbmc6IFhTRCArICdzdHJpbmcnXG4gIH0sXG4gIHJkZjoge1xuICAgIHR5cGU6IFJERiArICd0eXBlJyxcbiAgICBuaWw6IFJERiArICduaWwnLFxuICAgIGZpcnN0OiBSREYgKyAnZmlyc3QnLFxuICAgIHJlc3Q6IFJERiArICdyZXN0JyxcbiAgICBsYW5nU3RyaW5nOiBSREYgKyAnbGFuZ1N0cmluZydcbiAgfSxcbiAgb3dsOiB7XG4gICAgc2FtZUFzOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMi8wNy9vd2wjc2FtZUFzJ1xuICB9LFxuICByOiB7XG4gICAgZm9yU29tZTogU1dBUCArICdyZWlmeSNmb3JTb21lJyxcbiAgICBmb3JBbGw6IFNXQVAgKyAncmVpZnkjZm9yQWxsJ1xuICB9LFxuICBsb2c6IHtcbiAgICBpbXBsaWVzOiBTV0FQICsgJ2xvZyNpbXBsaWVzJ1xuICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnRlcm1Gcm9tSWQgPSB0ZXJtRnJvbUlkO1xuZXhwb3J0cy50ZXJtVG9JZCA9IHRlcm1Ub0lkO1xuZXhwb3J0cy5lc2NhcGVRdW90ZXMgPSBlc2NhcGVRdW90ZXM7XG5leHBvcnRzLnVuZXNjYXBlUXVvdGVzID0gdW5lc2NhcGVRdW90ZXM7XG5leHBvcnRzLlRyaXBsZSA9IGV4cG9ydHMuUXVhZCA9IGV4cG9ydHMuRGVmYXVsdEdyYXBoID0gZXhwb3J0cy5WYXJpYWJsZSA9IGV4cG9ydHMuQmxhbmtOb2RlID0gZXhwb3J0cy5MaXRlcmFsID0gZXhwb3J0cy5OYW1lZE5vZGUgPSBleHBvcnRzLlRlcm0gPSBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfSVJJcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vSVJJc1wiKSk7XG5cbnZhciBfTjNVdGlsID0gcmVxdWlyZShcIi4vTjNVdGlsXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBOMy5qcyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIFJERi9KUyBjb3JlIGRhdGEgdHlwZXNcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmRmanMvcmVwcmVzZW50YXRpb24tdGFzay1mb3JjZS9ibG9iL21hc3Rlci9pbnRlcmZhY2Utc3BlYy5tZFxuY29uc3Qge1xuICByZGYsXG4gIHhzZFxufSA9IF9JUklzLmRlZmF1bHQ7XG5sZXQgREVGQVVMVEdSQVBIO1xubGV0IF9ibGFua05vZGVDb3VudGVyID0gMDtcbmNvbnN0IGVzY2FwZWRMaXRlcmFsID0gL15cIiguKlwiLiopKD89XCJbXlwiXSokKS87XG5jb25zdCBxdWFkSWQgPSAvXjw8KFwiKD86XCJcInxbXlwiXSkqXCJbXiBdKnxbXiBdKykgKFwiKD86XCJcInxbXlwiXSkqXCJbXiBdKnxbXiBdKykgKFwiKD86XCJcInxbXlwiXSkqXCJbXiBdKnxbXiBdKykgPyhcIig/OlwiXCJ8W15cIl0pKlwiW14gXSp8W14gXSspPz4+JC87IC8vICMjIERhdGFGYWN0b3J5IHNpbmdsZXRvblxuXG5jb25zdCBEYXRhRmFjdG9yeSA9IHtcbiAgbmFtZWROb2RlLFxuICBibGFua05vZGUsXG4gIHZhcmlhYmxlLFxuICBsaXRlcmFsLFxuICBkZWZhdWx0R3JhcGgsXG4gIHF1YWQsXG4gIHRyaXBsZTogcXVhZFxufTtcbnZhciBfZGVmYXVsdCA9IERhdGFGYWN0b3J5OyAvLyAjIyBUZXJtIGNvbnN0cnVjdG9yXG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG5jbGFzcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoaWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH0gLy8gIyMjIFRoZSB2YWx1ZSBvZiB0aGlzIHRlcm1cblxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfSAvLyAjIyMgUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IHJlcHJlc2VudHMgdGhlIHNhbWUgdGVybSBhcyB0aGUgb3RoZXJcblxuXG4gIGVxdWFscyhvdGhlcikge1xuICAgIC8vIElmIGJvdGggdGVybXMgd2VyZSBjcmVhdGVkIGJ5IHRoaXMgbGlicmFyeSxcbiAgICAvLyBlcXVhbGl0eSBjYW4gYmUgY29tcHV0ZWQgdGhyb3VnaCBpZHNcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBUZXJtKSByZXR1cm4gdGhpcy5pZCA9PT0gb3RoZXIuaWQ7IC8vIE90aGVyd2lzZSwgY29tcGFyZSB0ZXJtIHR5cGUgYW5kIHZhbHVlXG5cbiAgICByZXR1cm4gISFvdGhlciAmJiB0aGlzLnRlcm1UeXBlID09PSBvdGhlci50ZXJtVHlwZSAmJiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZTtcbiAgfSAvLyAjIyMgUmV0dXJucyBhIHBsYWluIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRlcm1cblxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVybVR5cGU6IHRoaXMudGVybVR5cGUsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cblxufSAvLyAjIyBOYW1lZE5vZGUgY29uc3RydWN0b3JcblxuXG5leHBvcnRzLlRlcm0gPSBUZXJtO1xuXG5jbGFzcyBOYW1lZE5vZGUgZXh0ZW5kcyBUZXJtIHtcbiAgLy8gIyMjIFRoZSB0ZXJtIHR5cGUgb2YgdGhpcyB0ZXJtXG4gIGdldCB0ZXJtVHlwZSgpIHtcbiAgICByZXR1cm4gJ05hbWVkTm9kZSc7XG4gIH1cblxufSAvLyAjIyBMaXRlcmFsIGNvbnN0cnVjdG9yXG5cblxuZXhwb3J0cy5OYW1lZE5vZGUgPSBOYW1lZE5vZGU7XG5cbmNsYXNzIExpdGVyYWwgZXh0ZW5kcyBUZXJtIHtcbiAgLy8gIyMjIFRoZSB0ZXJtIHR5cGUgb2YgdGhpcyB0ZXJtXG4gIGdldCB0ZXJtVHlwZSgpIHtcbiAgICByZXR1cm4gJ0xpdGVyYWwnO1xuICB9IC8vICMjIyBUaGUgdGV4dCB2YWx1ZSBvZiB0aGlzIGxpdGVyYWxcblxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcoMSwgdGhpcy5pZC5sYXN0SW5kZXhPZignXCInKSk7XG4gIH0gLy8gIyMjIFRoZSBsYW5ndWFnZSBvZiB0aGlzIGxpdGVyYWxcblxuXG4gIGdldCBsYW5ndWFnZSgpIHtcbiAgICAvLyBGaW5kIHRoZSBsYXN0IHF1b3RhdGlvbiBtYXJrIChlLmcuLCAnXCJhYmNcIkBlbi11cycpXG4gICAgdmFyIGlkID0gdGhpcy5pZCxcbiAgICAgICAgYXRQb3MgPSBpZC5sYXN0SW5kZXhPZignXCInKSArIDE7IC8vIElmIFwiQFwiIGl0IGZvbGxvd3MsIHJldHVybiB0aGUgcmVtYWluaW5nIHN1YnN0cmluZzsgZW1wdHkgb3RoZXJ3aXNlXG5cbiAgICByZXR1cm4gYXRQb3MgPCBpZC5sZW5ndGggJiYgaWRbYXRQb3MrK10gPT09ICdAJyA/IGlkLnN1YnN0cihhdFBvcykudG9Mb3dlckNhc2UoKSA6ICcnO1xuICB9IC8vICMjIyBUaGUgZGF0YXR5cGUgSVJJIG9mIHRoaXMgbGl0ZXJhbFxuXG5cbiAgZ2V0IGRhdGF0eXBlKCkge1xuICAgIHJldHVybiBuZXcgTmFtZWROb2RlKHRoaXMuZGF0YXR5cGVTdHJpbmcpO1xuICB9IC8vICMjIyBUaGUgZGF0YXR5cGUgc3RyaW5nIG9mIHRoaXMgbGl0ZXJhbFxuXG5cbiAgZ2V0IGRhdGF0eXBlU3RyaW5nKCkge1xuICAgIC8vIEZpbmQgdGhlIGxhc3QgcXVvdGF0aW9uIG1hcmsgKGUuZy4sICdcImFiY1wiXl5odHRwOi8vZXgub3JnL3R5cGVzI3QnKVxuICAgIHZhciBpZCA9IHRoaXMuaWQsXG4gICAgICAgIGR0UG9zID0gaWQubGFzdEluZGV4T2YoJ1wiJykgKyAxLFxuICAgICAgICBjaDsgLy8gSWYgXCJeXCIgaXQgZm9sbG93cywgcmV0dXJuIHRoZSByZW1haW5pbmcgc3Vic3RyaW5nXG5cbiAgICByZXR1cm4gZHRQb3MgPCBpZC5sZW5ndGggJiYgKGNoID0gaWRbZHRQb3NdKSA9PT0gJ14nID8gaWQuc3Vic3RyKGR0UG9zICsgMikgOiAvLyBJZiBcIkBcIiBmb2xsb3dzLCByZXR1cm4gcmRmOmxhbmdTdHJpbmc7IHhzZDpzdHJpbmcgb3RoZXJ3aXNlXG4gICAgY2ggIT09ICdAJyA/IHhzZC5zdHJpbmcgOiByZGYubGFuZ1N0cmluZztcbiAgfSAvLyAjIyMgUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IHJlcHJlc2VudHMgdGhlIHNhbWUgdGVybSBhcyB0aGUgb3RoZXJcblxuXG4gIGVxdWFscyhvdGhlcikge1xuICAgIC8vIElmIGJvdGggbGl0ZXJhbHMgd2VyZSBjcmVhdGVkIGJ5IHRoaXMgbGlicmFyeSxcbiAgICAvLyBlcXVhbGl0eSBjYW4gYmUgY29tcHV0ZWQgdGhyb3VnaCBpZHNcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBMaXRlcmFsKSByZXR1cm4gdGhpcy5pZCA9PT0gb3RoZXIuaWQ7IC8vIE90aGVyd2lzZSwgY29tcGFyZSB0ZXJtIHR5cGUsIHZhbHVlLCBsYW5ndWFnZSwgYW5kIGRhdGF0eXBlXG5cbiAgICByZXR1cm4gISFvdGhlciAmJiAhIW90aGVyLmRhdGF0eXBlICYmIHRoaXMudGVybVR5cGUgPT09IG90aGVyLnRlcm1UeXBlICYmIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlICYmIHRoaXMubGFuZ3VhZ2UgPT09IG90aGVyLmxhbmd1YWdlICYmIHRoaXMuZGF0YXR5cGUudmFsdWUgPT09IG90aGVyLmRhdGF0eXBlLnZhbHVlO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXJtVHlwZTogdGhpcy50ZXJtVHlwZSxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgbGFuZ3VhZ2U6IHRoaXMubGFuZ3VhZ2UsXG4gICAgICBkYXRhdHlwZToge1xuICAgICAgICB0ZXJtVHlwZTogJ05hbWVkTm9kZScsXG4gICAgICAgIHZhbHVlOiB0aGlzLmRhdGF0eXBlU3RyaW5nXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG59IC8vICMjIEJsYW5rTm9kZSBjb25zdHJ1Y3RvclxuXG5cbmV4cG9ydHMuTGl0ZXJhbCA9IExpdGVyYWw7XG5cbmNsYXNzIEJsYW5rTm9kZSBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoJ186JyArIG5hbWUpO1xuICB9IC8vICMjIyBUaGUgdGVybSB0eXBlIG9mIHRoaXMgdGVybVxuXG5cbiAgZ2V0IHRlcm1UeXBlKCkge1xuICAgIHJldHVybiAnQmxhbmtOb2RlJztcbiAgfSAvLyAjIyMgVGhlIG5hbWUgb2YgdGhpcyBibGFuayBub2RlXG5cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQuc3Vic3RyKDIpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5CbGFua05vZGUgPSBCbGFua05vZGU7XG5cbmNsYXNzIFZhcmlhYmxlIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICBzdXBlcignPycgKyBuYW1lKTtcbiAgfSAvLyAjIyMgVGhlIHRlcm0gdHlwZSBvZiB0aGlzIHRlcm1cblxuXG4gIGdldCB0ZXJtVHlwZSgpIHtcbiAgICByZXR1cm4gJ1ZhcmlhYmxlJztcbiAgfSAvLyAjIyMgVGhlIG5hbWUgb2YgdGhpcyB2YXJpYWJsZVxuXG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmlkLnN1YnN0cigxKTtcbiAgfVxuXG59IC8vICMjIERlZmF1bHRHcmFwaCBjb25zdHJ1Y3RvclxuXG5cbmV4cG9ydHMuVmFyaWFibGUgPSBWYXJpYWJsZTtcblxuY2xhc3MgRGVmYXVsdEdyYXBoIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCcnKTtcbiAgICByZXR1cm4gREVGQVVMVEdSQVBIIHx8IHRoaXM7XG4gIH0gLy8gIyMjIFRoZSB0ZXJtIHR5cGUgb2YgdGhpcyB0ZXJtXG5cblxuICBnZXQgdGVybVR5cGUoKSB7XG4gICAgcmV0dXJuICdEZWZhdWx0R3JhcGgnO1xuICB9IC8vICMjIyBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgcmVwcmVzZW50cyB0aGUgc2FtZSB0ZXJtIGFzIHRoZSBvdGhlclxuXG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgLy8gSWYgYm90aCB0ZXJtcyB3ZXJlIGNyZWF0ZWQgYnkgdGhpcyBsaWJyYXJ5LFxuICAgIC8vIGVxdWFsaXR5IGNhbiBiZSBjb21wdXRlZCB0aHJvdWdoIHN0cmljdCBlcXVhbGl0eTtcbiAgICAvLyBvdGhlcndpc2UsIGNvbXBhcmUgdGVybSB0eXBlcy5cbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHwgISFvdGhlciAmJiB0aGlzLnRlcm1UeXBlID09PSBvdGhlci50ZXJtVHlwZTtcbiAgfVxuXG59IC8vICMjIERlZmF1bHRHcmFwaCBzaW5nbGV0b25cblxuXG5leHBvcnRzLkRlZmF1bHRHcmFwaCA9IERlZmF1bHRHcmFwaDtcbkRFRkFVTFRHUkFQSCA9IG5ldyBEZWZhdWx0R3JhcGgoKTsgLy8gIyMjIENvbnN0cnVjdHMgYSB0ZXJtIGZyb20gdGhlIGdpdmVuIGludGVybmFsIHN0cmluZyBJRFxuXG5mdW5jdGlvbiB0ZXJtRnJvbUlkKGlkLCBmYWN0b3J5KSB7XG4gIGZhY3RvcnkgPSBmYWN0b3J5IHx8IERhdGFGYWN0b3J5OyAvLyBGYWxzeSB2YWx1ZSBvciBlbXB0eSBzdHJpbmcgaW5kaWNhdGUgdGhlIGRlZmF1bHQgZ3JhcGhcblxuICBpZiAoIWlkKSByZXR1cm4gZmFjdG9yeS5kZWZhdWx0R3JhcGgoKTsgLy8gSWRlbnRpZnkgdGhlIHRlcm0gdHlwZSBiYXNlZCBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyXG5cbiAgc3dpdGNoIChpZFswXSkge1xuICAgIGNhc2UgJz8nOlxuICAgICAgcmV0dXJuIGZhY3RvcnkudmFyaWFibGUoaWQuc3Vic3RyKDEpKTtcblxuICAgIGNhc2UgJ18nOlxuICAgICAgcmV0dXJuIGZhY3RvcnkuYmxhbmtOb2RlKGlkLnN1YnN0cigyKSk7XG5cbiAgICBjYXNlICdcIic6XG4gICAgICAvLyBTaG9ydGN1dCBmb3IgaW50ZXJuYWwgbGl0ZXJhbHNcbiAgICAgIGlmIChmYWN0b3J5ID09PSBEYXRhRmFjdG9yeSkgcmV0dXJuIG5ldyBMaXRlcmFsKGlkKTsgLy8gTGl0ZXJhbCB3aXRob3V0IGRhdGF0eXBlIG9yIGxhbmd1YWdlXG5cbiAgICAgIGlmIChpZFtpZC5sZW5ndGggLSAxXSA9PT0gJ1wiJykgcmV0dXJuIGZhY3RvcnkubGl0ZXJhbChpZC5zdWJzdHIoMSwgaWQubGVuZ3RoIC0gMikpOyAvLyBMaXRlcmFsIHdpdGggZGF0YXR5cGUgb3IgbGFuZ3VhZ2VcblxuICAgICAgdmFyIGVuZFBvcyA9IGlkLmxhc3RJbmRleE9mKCdcIicsIGlkLmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIGZhY3RvcnkubGl0ZXJhbChpZC5zdWJzdHIoMSwgZW5kUG9zIC0gMSksIGlkW2VuZFBvcyArIDFdID09PSAnQCcgPyBpZC5zdWJzdHIoZW5kUG9zICsgMikgOiBmYWN0b3J5Lm5hbWVkTm9kZShpZC5zdWJzdHIoZW5kUG9zICsgMykpKTtcblxuICAgIGNhc2UgJzwnOlxuICAgICAgY29uc3QgY29tcG9uZW50cyA9IHF1YWRJZC5leGVjKGlkKTtcbiAgICAgIHJldHVybiBmYWN0b3J5LnF1YWQodGVybUZyb21JZCh1bmVzY2FwZVF1b3Rlcyhjb21wb25lbnRzWzFdKSwgZmFjdG9yeSksIHRlcm1Gcm9tSWQodW5lc2NhcGVRdW90ZXMoY29tcG9uZW50c1syXSksIGZhY3RvcnkpLCB0ZXJtRnJvbUlkKHVuZXNjYXBlUXVvdGVzKGNvbXBvbmVudHNbM10pLCBmYWN0b3J5KSwgY29tcG9uZW50c1s0XSAmJiB0ZXJtRnJvbUlkKHVuZXNjYXBlUXVvdGVzKGNvbXBvbmVudHNbNF0pLCBmYWN0b3J5KSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhY3RvcnkubmFtZWROb2RlKGlkKTtcbiAgfVxufSAvLyAjIyMgQ29uc3RydWN0cyBhbiBpbnRlcm5hbCBzdHJpbmcgSUQgZnJvbSB0aGUgZ2l2ZW4gdGVybSBvciBJRCBzdHJpbmdcblxuXG5mdW5jdGlvbiB0ZXJtVG9JZCh0ZXJtKSB7XG4gIGlmICh0eXBlb2YgdGVybSA9PT0gJ3N0cmluZycpIHJldHVybiB0ZXJtO1xuICBpZiAodGVybSBpbnN0YW5jZW9mIFRlcm0gJiYgdGVybS50ZXJtVHlwZSAhPT0gJ1F1YWQnKSByZXR1cm4gdGVybS5pZDtcbiAgaWYgKCF0ZXJtKSByZXR1cm4gREVGQVVMVEdSQVBILmlkOyAvLyBUZXJtIGluc3RhbnRpYXRlZCB3aXRoIGFub3RoZXIgbGlicmFyeVxuXG4gIHN3aXRjaCAodGVybS50ZXJtVHlwZSkge1xuICAgIGNhc2UgJ05hbWVkTm9kZSc6XG4gICAgICByZXR1cm4gdGVybS52YWx1ZTtcblxuICAgIGNhc2UgJ0JsYW5rTm9kZSc6XG4gICAgICByZXR1cm4gJ186JyArIHRlcm0udmFsdWU7XG5cbiAgICBjYXNlICdWYXJpYWJsZSc6XG4gICAgICByZXR1cm4gJz8nICsgdGVybS52YWx1ZTtcblxuICAgIGNhc2UgJ0RlZmF1bHRHcmFwaCc6XG4gICAgICByZXR1cm4gJyc7XG5cbiAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgIHJldHVybiAnXCInICsgdGVybS52YWx1ZSArICdcIicgKyAodGVybS5sYW5ndWFnZSA/ICdAJyArIHRlcm0ubGFuZ3VhZ2UgOiB0ZXJtLmRhdGF0eXBlICYmIHRlcm0uZGF0YXR5cGUudmFsdWUgIT09IHhzZC5zdHJpbmcgPyAnXl4nICsgdGVybS5kYXRhdHlwZS52YWx1ZSA6ICcnKTtcblxuICAgIGNhc2UgJ1F1YWQnOlxuICAgICAgLy8gVG8gaWRlbnRpZnkgUkRGKiBxdWFkIGNvbXBvbmVudHMsIHdlIGVzY2FwZSBxdW90ZXMgYnkgZG91YmxpbmcgdGhlbS5cbiAgICAgIC8vIFRoaXMgYXZvaWRzIHRoZSBvdmVyaGVhZCBvZiBiYWNrc2xhc2ggcGFyc2luZyBvZiBUdXJ0bGUtbGlrZSBzeW50YXhlcy5cbiAgICAgIHJldHVybiBgPDwke2VzY2FwZVF1b3Rlcyh0ZXJtVG9JZCh0ZXJtLnN1YmplY3QpKX0gJHtlc2NhcGVRdW90ZXModGVybVRvSWQodGVybS5wcmVkaWNhdGUpKX0gJHtlc2NhcGVRdW90ZXModGVybVRvSWQodGVybS5vYmplY3QpKX0keygwLCBfTjNVdGlsLmlzRGVmYXVsdEdyYXBoKSh0ZXJtLmdyYXBoKSA/ICcnIDogYCAke3Rlcm1Ub0lkKHRlcm0uZ3JhcGgpfWB9Pj5gO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB0ZXJtVHlwZTogJyArIHRlcm0udGVybVR5cGUpO1xuICB9XG59IC8vICMjIFF1YWQgY29uc3RydWN0b3JcblxuXG5jbGFzcyBRdWFkIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHN1cGVyKCcnKTtcbiAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMuZ3JhcGggPSBncmFwaCB8fCBERUZBVUxUR1JBUEg7XG4gIH0gLy8gIyMjIFRoZSB0ZXJtIHR5cGUgb2YgdGhpcyB0ZXJtXG5cblxuICBnZXQgdGVybVR5cGUoKSB7XG4gICAgcmV0dXJuICdRdWFkJztcbiAgfSAvLyAjIyMgUmV0dXJucyBhIHBsYWluIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHF1YWRcblxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVybVR5cGU6IHRoaXMudGVybVR5cGUsXG4gICAgICBzdWJqZWN0OiB0aGlzLnN1YmplY3QudG9KU09OKCksXG4gICAgICBwcmVkaWNhdGU6IHRoaXMucHJlZGljYXRlLnRvSlNPTigpLFxuICAgICAgb2JqZWN0OiB0aGlzLm9iamVjdC50b0pTT04oKSxcbiAgICAgIGdyYXBoOiB0aGlzLmdyYXBoLnRvSlNPTigpXG4gICAgfTtcbiAgfSAvLyAjIyMgUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IHJlcHJlc2VudHMgdGhlIHNhbWUgcXVhZCBhcyB0aGUgb3RoZXJcblxuXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAhIW90aGVyICYmIHRoaXMuc3ViamVjdC5lcXVhbHMob3RoZXIuc3ViamVjdCkgJiYgdGhpcy5wcmVkaWNhdGUuZXF1YWxzKG90aGVyLnByZWRpY2F0ZSkgJiYgdGhpcy5vYmplY3QuZXF1YWxzKG90aGVyLm9iamVjdCkgJiYgdGhpcy5ncmFwaC5lcXVhbHMob3RoZXIuZ3JhcGgpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5UcmlwbGUgPSBleHBvcnRzLlF1YWQgPSBRdWFkO1xuXG4vLyAjIyMgRXNjYXBlcyB0aGUgcXVvdGVzIHdpdGhpbiB0aGUgZ2l2ZW4gbGl0ZXJhbFxuZnVuY3Rpb24gZXNjYXBlUXVvdGVzKGlkKSB7XG4gIHJldHVybiBpZC5yZXBsYWNlKGVzY2FwZWRMaXRlcmFsLCAoXywgcXVvdGVkKSA9PiBgXCIke3F1b3RlZC5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfWApO1xufSAvLyAjIyMgVW5lc2NhcGVzIHRoZSBxdW90ZXMgd2l0aGluIHRoZSBnaXZlbiBsaXRlcmFsXG5cblxuZnVuY3Rpb24gdW5lc2NhcGVRdW90ZXMoaWQpIHtcbiAgcmV0dXJuIGlkLnJlcGxhY2UoZXNjYXBlZExpdGVyYWwsIChfLCBxdW90ZWQpID0+IGBcIiR7cXVvdGVkLnJlcGxhY2UoL1wiXCIvZywgJ1wiJyl9YCk7XG59IC8vICMjIyBDcmVhdGVzIGFuIElSSVxuXG5cbmZ1bmN0aW9uIG5hbWVkTm9kZShpcmkpIHtcbiAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoaXJpKTtcbn0gLy8gIyMjIENyZWF0ZXMgYSBibGFuayBub2RlXG5cblxuZnVuY3Rpb24gYmxhbmtOb2RlKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBCbGFua05vZGUobmFtZSB8fCBgbjMtJHtfYmxhbmtOb2RlQ291bnRlcisrfWApO1xufSAvLyAjIyMgQ3JlYXRlcyBhIGxpdGVyYWxcblxuXG5mdW5jdGlvbiBsaXRlcmFsKHZhbHVlLCBsYW5ndWFnZU9yRGF0YVR5cGUpIHtcbiAgLy8gQ3JlYXRlIGEgbGFuZ3VhZ2UtdGFnZ2VkIHN0cmluZ1xuICBpZiAodHlwZW9mIGxhbmd1YWdlT3JEYXRhVHlwZSA9PT0gJ3N0cmluZycpIHJldHVybiBuZXcgTGl0ZXJhbCgnXCInICsgdmFsdWUgKyAnXCJAJyArIGxhbmd1YWdlT3JEYXRhVHlwZS50b0xvd2VyQ2FzZSgpKTsgLy8gQXV0b21hdGljYWxseSBkZXRlcm1pbmUgZGF0YXR5cGUgZm9yIGJvb2xlYW5zIGFuZCBudW1iZXJzXG5cbiAgbGV0IGRhdGF0eXBlID0gbGFuZ3VhZ2VPckRhdGFUeXBlID8gbGFuZ3VhZ2VPckRhdGFUeXBlLnZhbHVlIDogJyc7XG5cbiAgaWYgKGRhdGF0eXBlID09PSAnJykge1xuICAgIC8vIENvbnZlcnQgYSBib29sZWFuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSBkYXRhdHlwZSA9IHhzZC5ib29sZWFuOyAvLyBDb252ZXJ0IGFuIGludGVnZXIgb3IgZG91YmxlXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkgZGF0YXR5cGUgPSBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSA/IHhzZC5pbnRlZ2VyIDogeHNkLmRvdWJsZTtlbHNlIHtcbiAgICAgICAgICBkYXRhdHlwZSA9IHhzZC5kb3VibGU7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odmFsdWUpKSB2YWx1ZSA9IHZhbHVlID4gMCA/ICdJTkYnIDogJy1JTkYnO1xuICAgICAgICB9XG4gICAgICB9XG4gIH0gLy8gQ3JlYXRlIGEgZGF0YXR5cGVkIGxpdGVyYWxcblxuXG4gIHJldHVybiBkYXRhdHlwZSA9PT0gJycgfHwgZGF0YXR5cGUgPT09IHhzZC5zdHJpbmcgPyBuZXcgTGl0ZXJhbCgnXCInICsgdmFsdWUgKyAnXCInKSA6IG5ldyBMaXRlcmFsKCdcIicgKyB2YWx1ZSArICdcIl5eJyArIGRhdGF0eXBlKTtcbn0gLy8gIyMjIENyZWF0ZXMgYSB2YXJpYWJsZVxuXG5cbmZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBWYXJpYWJsZShuYW1lKTtcbn0gLy8gIyMjIFJldHVybnMgdGhlIGRlZmF1bHQgZ3JhcGhcblxuXG5mdW5jdGlvbiBkZWZhdWx0R3JhcGgoKSB7XG4gIHJldHVybiBERUZBVUxUR1JBUEg7XG59IC8vICMjIyBDcmVhdGVzIGEgcXVhZFxuXG5cbmZ1bmN0aW9uIHF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gIHJldHVybiBuZXcgUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX0lSSXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0lSSXNcIikpO1xuXG52YXIgX3F1ZXVlTWljcm90YXNrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicXVldWUtbWljcm90YXNrXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gKipOM0xleGVyKiogdG9rZW5pemVzIE4zIGRvY3VtZW50cy5cbmNvbnN0IHtcbiAgeHNkXG59ID0gX0lSSXMuZGVmYXVsdDsgLy8gUmVndWxhciBleHByZXNzaW9uIGFuZCByZXBsYWNlbWVudCBzdHJpbmcgdG8gZXNjYXBlIE4zIHN0cmluZ3NcblxudmFyIGVzY2FwZVNlcXVlbmNlID0gL1xcXFx1KFthLWZBLUYwLTldezR9KXxcXFxcVShbYS1mQS1GMC05XXs4fSl8XFxcXChbXl0pL2c7XG52YXIgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAnXFxcXCc6ICdcXFxcJyxcbiAgXCInXCI6IFwiJ1wiLFxuICAnXCInOiAnXCInLFxuICAnbic6ICdcXG4nLFxuICAncic6ICdcXHInLFxuICAndCc6ICdcXHQnLFxuICAnZic6ICdcXGYnLFxuICAnYic6ICdcXGInLFxuICAnXyc6ICdfJyxcbiAgJ34nOiAnficsXG4gICcuJzogJy4nLFxuICAnLSc6ICctJyxcbiAgJyEnOiAnIScsXG4gICckJzogJyQnLFxuICAnJic6ICcmJyxcbiAgJygnOiAnKCcsXG4gICcpJzogJyknLFxuICAnKic6ICcqJyxcbiAgJysnOiAnKycsXG4gICcsJzogJywnLFxuICAnOyc6ICc7JyxcbiAgJz0nOiAnPScsXG4gICcvJzogJy8nLFxuICAnPyc6ICc/JyxcbiAgJyMnOiAnIycsXG4gICdAJzogJ0AnLFxuICAnJSc6ICclJ1xufTtcbnZhciBpbGxlZ2FsSXJpQ2hhcnMgPSAvW1xceDAwLVxceDIwPD5cXFxcXCJcXHtcXH1cXHxcXF5cXGBdLztcbnZhciBsaW5lTW9kZVJlZ0V4cHMgPSB7XG4gIF9pcmk6IHRydWUsXG4gIF91bmVzY2FwZWRJcmk6IHRydWUsXG4gIF9zaW1wbGVRdW90ZWRTdHJpbmc6IHRydWUsXG4gIF9sYW5nY29kZTogdHJ1ZSxcbiAgX2JsYW5rOiB0cnVlLFxuICBfbmV3bGluZTogdHJ1ZSxcbiAgX2NvbW1lbnQ6IHRydWUsXG4gIF93aGl0ZXNwYWNlOiB0cnVlLFxuICBfZW5kT2ZGaWxlOiB0cnVlXG59O1xudmFyIGludmFsaWRSZWdFeHAgPSAvJDBeLzsgLy8gIyMgQ29uc3RydWN0b3JcblxuY2xhc3MgTjNMZXhlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvLyAjIyBSZWd1bGFyIGV4cHJlc3Npb25zXG4gICAgLy8gSXQncyBzbGlnaHRseSBmYXN0ZXIgdG8gaGF2ZSB0aGVzZSBhcyBwcm9wZXJ0aWVzIHRoYW4gYXMgaW4tc2NvcGUgdmFyaWFibGVzXG4gICAgdGhpcy5faXJpID0gL148KCg/OlteIDw+e31cXFxcXXxcXFxcW3VVXSkrKT5bIFxcdF0qLzsgLy8gSVJJIHdpdGggZXNjYXBlIHNlcXVlbmNlczsgbmVlZHMgc2FuaXR5IGNoZWNrIGFmdGVyIHVuZXNjYXBpbmdcblxuICAgIHRoaXMuX3VuZXNjYXBlZElyaSA9IC9ePChbXlxceDAwLVxceDIwPD5cXFxcXCJcXHtcXH1cXHxcXF5cXGBdKik+WyBcXHRdKi87IC8vIElSSSB3aXRob3V0IGVzY2FwZSBzZXF1ZW5jZXM7IG5vIHVuZXNjYXBpbmdcblxuICAgIHRoaXMuX3NpbXBsZVF1b3RlZFN0cmluZyA9IC9eXCIoW15cIlxcXFxcXHJcXG5dKilcIig/PVteXCJdKS87IC8vIHN0cmluZyB3aXRob3V0IGVzY2FwZSBzZXF1ZW5jZXNcblxuICAgIHRoaXMuX3NpbXBsZUFwb3N0cm9waGVTdHJpbmcgPSAvXicoW14nXFxcXFxcclxcbl0qKScoPz1bXiddKS87XG4gICAgdGhpcy5fbGFuZ2NvZGUgPSAvXkAoW2Etel0rKD86LVthLXowLTldKykqKSg/PVteYS16MC05XFwtXSkvaTtcbiAgICB0aGlzLl9wcmVmaXggPSAvXigoPzpbQS1aYS16XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkoPzpcXC4/W1xcLTAtOUEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKT86KD89WyNcXHM8XSkvO1xuICAgIHRoaXMuX3ByZWZpeGVkID0gL14oKD86W0EtWmEtelxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmZmXFx1MDM3MC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl0pKD86XFwuP1tcXC0wLTlBLVpfYS16XFx4YjdcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl0pKik/OigoPzooPzpbMC06QS1aX2EtelxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmZmXFx1MDM3MC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl18JVswLTlhLWZBLUZdezJ9fFxcXFxbISMtXFwvOz0/XFwtQF9+XSkoPzooPzpbXFwuXFwtMC06QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdfCVbMC05YS1mQS1GXXsyfXxcXFxcWyEjLVxcLzs9P1xcLUBffl0pKig/OltcXC0wLTpBLVpfYS16XFx4YjdcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl18JVswLTlhLWZBLUZdezJ9fFxcXFxbISMtXFwvOz0/XFwtQF9+XSkpPyk/KSg/OlsgXFx0XSt8KD89XFwuP1ssOyFcXF5cXHMjKClcXFtcXF1cXHtcXH1cIic8Pl0pKS87XG4gICAgdGhpcy5fdmFyaWFibGUgPSAvXlxcPyg/Oig/OltBLVpfYS16XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkoPzpbXFwtMC06QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSopKD89Wy4sOyFcXF5cXHMjKClcXFtcXF1cXHtcXH1cIic8Pl0pLztcbiAgICB0aGlzLl9ibGFuayA9IC9eXzooKD86WzAtOUEtWl9hLXpcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSg/OlxcLj9bXFwtMC05QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSopKD86WyBcXHRdK3woPz1cXC4/Wyw7OlxccyMoKVxcW1xcXVxce1xcfVwiJzw+XSkpLztcbiAgICB0aGlzLl9udW1iZXIgPSAvXltcXC0rXT8oPzooXFxkK1xcLlxcZCp8XFwuP1xcZCspW2VFXVtcXC0rXT98XFxkKihcXC4pPylcXGQrKD89XFwuP1ssOzpcXHMjKClcXFtcXF1cXHtcXH1cIic8Pl0pLztcbiAgICB0aGlzLl9ib29sZWFuID0gL14oPzp0cnVlfGZhbHNlKSg/PVsuLDtcXHMjKClcXFtcXF1cXHtcXH1cIic8Pl0pLztcbiAgICB0aGlzLl9rZXl3b3JkID0gL15AW2Etel0rKD89W1xccyM8Ol0pL2k7XG4gICAgdGhpcy5fc3BhcnFsS2V5d29yZCA9IC9eKD86UFJFRklYfEJBU0V8R1JBUEgpKD89W1xccyM8XSkvaTtcbiAgICB0aGlzLl9zaG9ydFByZWRpY2F0ZXMgPSAvXmEoPz1bXFxzKClcXFtcXF1cXHtcXH1cIic8Pl0pLztcbiAgICB0aGlzLl9uZXdsaW5lID0gL15bIFxcdF0qKD86I1teXFxuXFxyXSopPyg/OlxcclxcbnxcXG58XFxyKVsgXFx0XSovO1xuICAgIHRoaXMuX2NvbW1lbnQgPSAvIyhbXlxcblxccl0qKS87XG4gICAgdGhpcy5fd2hpdGVzcGFjZSA9IC9eWyBcXHRdKy87XG4gICAgdGhpcy5fZW5kT2ZGaWxlID0gL14oPzojW15cXG5cXHJdKik/JC87XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEluIGxpbmUgbW9kZSAoTi1UcmlwbGVzIG9yIE4tUXVhZHMpLCBvbmx5IHNpbXBsZSBmZWF0dXJlcyBtYXkgYmUgcGFyc2VkXG5cbiAgICBpZiAodGhpcy5fbGluZU1vZGUgPSAhIW9wdGlvbnMubGluZU1vZGUpIHtcbiAgICAgIHRoaXMuX24zTW9kZSA9IGZhbHNlOyAvLyBEb24ndCB0b2tlbml6ZSBzcGVjaWFsIGxpdGVyYWxzXG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBsaW5lTW9kZVJlZ0V4cHMpICYmIHRoaXNba2V5XSBpbnN0YW5jZW9mIFJlZ0V4cCkgdGhpc1trZXldID0gaW52YWxpZFJlZ0V4cDtcbiAgICAgIH1cbiAgICB9IC8vIFdoZW4gbm90IGluIGxpbmUgbW9kZSwgZW5hYmxlIE4zIGZ1bmN0aW9uYWxpdHkgYnkgZGVmYXVsdFxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9uM01vZGUgPSBvcHRpb25zLm4zICE9PSBmYWxzZTtcbiAgICAgIH0gLy8gRG9uJ3Qgb3V0cHV0IGNvbW1lbnQgdG9rZW5zIGJ5IGRlZmF1bHRcblxuXG4gICAgdGhpcy5fY29tbWVudHMgPSAhIW9wdGlvbnMuY29tbWVudHM7IC8vIENhY2hlIHRoZSBsYXN0IHRlc3RlZCBjbG9zaW5nIHBvc2l0aW9uIG9mIGxvbmcgbGl0ZXJhbHNcblxuICAgIHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zID0gMDtcbiAgfSAvLyAjIyBQcml2YXRlIG1ldGhvZHNcbiAgLy8gIyMjIGBfdG9rZW5pemVUb0VuZGAgdG9rZW5pemVzIGFzIGZvciBhcyBwb3NzaWJsZSwgZW1pdHRpbmcgdG9rZW5zIHRocm91Z2ggdGhlIGNhbGxiYWNrXG5cblxuICBfdG9rZW5pemVUb0VuZChjYWxsYmFjaywgaW5wdXRGaW5pc2hlZCkge1xuICAgIC8vIENvbnRpbnVlIHBhcnNpbmcgYXMgZmFyIGFzIHBvc3NpYmxlOyB0aGUgbG9vcCB3aWxsIHJldHVybiBldmVudHVhbGx5XG4gICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQsXG4gICAgICAgIG91dHB1dENvbW1lbnRzID0gdGhpcy5fY29tbWVudHM7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gQ291bnQgYW5kIHNraXAgd2hpdGVzcGFjZSBsaW5lc1xuICAgICAgdmFyIHdoaXRlU3BhY2VNYXRjaCwgY29tbWVudDtcblxuICAgICAgd2hpbGUgKHdoaXRlU3BhY2VNYXRjaCA9IHRoaXMuX25ld2xpbmUuZXhlYyhpbnB1dCkpIHtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBjb21tZW50XG4gICAgICAgIGlmIChvdXRwdXRDb21tZW50cyAmJiAoY29tbWVudCA9IHRoaXMuX2NvbW1lbnQuZXhlYyh3aGl0ZVNwYWNlTWF0Y2hbMF0pKSkgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgIGxpbmU6IHRoaXMuX2xpbmUsXG4gICAgICAgICAgdHlwZTogJ2NvbW1lbnQnLFxuICAgICAgICAgIHZhbHVlOiBjb21tZW50WzFdLFxuICAgICAgICAgIHByZWZpeDogJydcbiAgICAgICAgfSk7IC8vIEFkdmFuY2UgdGhlIGlucHV0XG5cbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIod2hpdGVTcGFjZU1hdGNoWzBdLmxlbmd0aCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fbGluZSsrO1xuICAgICAgfSAvLyBTa2lwIHdoaXRlc3BhY2Ugb24gY3VycmVudCBsaW5lXG5cblxuICAgICAgaWYgKCF3aGl0ZVNwYWNlTWF0Y2ggJiYgKHdoaXRlU3BhY2VNYXRjaCA9IHRoaXMuX3doaXRlc3BhY2UuZXhlYyhpbnB1dCkpKSBpbnB1dCA9IGlucHV0LnN1YnN0cih3aGl0ZVNwYWNlTWF0Y2hbMF0ubGVuZ3RoLCBpbnB1dC5sZW5ndGgpOyAvLyBTdG9wIGZvciBub3cgaWYgd2UncmUgYXQgdGhlIGVuZFxuXG4gICAgICBpZiAodGhpcy5fZW5kT2ZGaWxlLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBmaW5pc2hlZCwgZW1pdCBFT0ZcbiAgICAgICAgaWYgKGlucHV0RmluaXNoZWQpIHtcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhIGZpbmFsIGNvbW1lbnRcbiAgICAgICAgICBpZiAob3V0cHV0Q29tbWVudHMgJiYgKGNvbW1lbnQgPSB0aGlzLl9jb21tZW50LmV4ZWMoaW5wdXQpKSkgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgbGluZTogdGhpcy5fbGluZSxcbiAgICAgICAgICAgIHR5cGU6ICdjb21tZW50JyxcbiAgICAgICAgICAgIHZhbHVlOiBjb21tZW50WzFdLFxuICAgICAgICAgICAgcHJlZml4OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhbGxiYWNrKGlucHV0ID0gbnVsbCwge1xuICAgICAgICAgICAgbGluZTogdGhpcy5fbGluZSxcbiAgICAgICAgICAgIHR5cGU6ICdlb2YnLFxuICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgcHJlZml4OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICB9IC8vIExvb2sgZm9yIHNwZWNpZmljIHRva2VuIHR5cGVzIGJhc2VkIG9uIHRoZSBmaXJzdCBjaGFyYWN0ZXJcblxuXG4gICAgICB2YXIgbGluZSA9IHRoaXMuX2xpbmUsXG4gICAgICAgICAgdHlwZSA9ICcnLFxuICAgICAgICAgIHZhbHVlID0gJycsXG4gICAgICAgICAgcHJlZml4ID0gJycsXG4gICAgICAgICAgZmlyc3RDaGFyID0gaW5wdXRbMF0sXG4gICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgIG1hdGNoTGVuZ3RoID0gMCxcbiAgICAgICAgICBpbmNvbmNsdXNpdmUgPSBmYWxzZTtcblxuICAgICAgc3dpdGNoIChmaXJzdENoYXIpIHtcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgLy8gV2UgbmVlZCBhdCBsZWFzdCAzIHRva2VucyBsb29rYWhlYWQgdG8gZGlzdGluZ3Vpc2ggXl48SVJJPiBhbmQgXl5wcmU6Zml4ZWRcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIDwgMykgYnJlYWs7IC8vIFRyeSB0byBtYXRjaCBhIHR5cGVcbiAgICAgICAgICBlbHNlIGlmIChpbnB1dFsxXSA9PT0gJ14nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzTWFya2VyID0gJ15eJzsgLy8gTW92ZSB0byB0eXBlIElSSSBvciBwcmVmaXhlZCBuYW1lXG5cbiAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoMik7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0WzBdICE9PSAnPCcpIHtcbiAgICAgICAgICAgICAgICBpbmNvbmNsdXNpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIElmIG5vIHR5cGUsIGl0IG11c3QgYmUgYSBwYXRoIGV4cHJlc3Npb25cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uM01vZGUpIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoTGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICAgIHR5cGUgPSAnXic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoIGluIGNhc2UgdGhlIHR5cGUgaXMgYW4gSVJJXG5cbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBmdWxsIElSSSB3aXRob3V0IGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLl91bmVzY2FwZWRJcmkuZXhlYyhpbnB1dCkpIHR5cGUgPSAnSVJJJywgdmFsdWUgPSBtYXRjaFsxXTsgLy8gVHJ5IHRvIGZpbmQgYSBmdWxsIElSSSB3aXRoIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICBlbHNlIGlmIChtYXRjaCA9IHRoaXMuX2lyaS5leGVjKGlucHV0KSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3VuZXNjYXBlKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlsbGVnYWxJcmlDaGFycy50ZXN0KHZhbHVlKSkgcmV0dXJuIHJlcG9ydFN5bnRheEVycm9yKHRoaXMpO1xuICAgICAgICAgICAgICB0eXBlID0gJ0lSSSc7XG4gICAgICAgICAgICB9IC8vIFRyeSB0byBmaW5kIGEgbmVzdGVkIHRyaXBsZVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQubGVuZ3RoID4gMSAmJiBpbnB1dFsxXSA9PT0gJzwnKSB0eXBlID0gJzw8JywgbWF0Y2hMZW5ndGggPSAyOyAvLyBUcnkgdG8gZmluZCBhIGJhY2t3YXJkcyBpbXBsaWNhdGlvbiBhcnJvd1xuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9uM01vZGUgJiYgaW5wdXQubGVuZ3RoID4gMSAmJiBpbnB1dFsxXSA9PT0gJz0nKSB0eXBlID0gJ2ludmVyc2UnLCBtYXRjaExlbmd0aCA9IDIsIHZhbHVlID0gJz4nO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiAxICYmIGlucHV0WzFdID09PSAnPicpIHR5cGUgPSAnPj4nLCBtYXRjaExlbmd0aCA9IDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnXyc6XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBibGFuayBub2RlLiBTaW5jZSBpdCBjYW4gY29udGFpbiAoYnV0IG5vdCBlbmQgd2l0aCkgYSBkb3QsXG4gICAgICAgICAgLy8gd2UgYWx3YXlzIG5lZWQgYSBub24tZG90IGNoYXJhY3RlciBiZWZvcmUgZGVjaWRpbmcgaXQgaXMgYSBibGFuayBub2RlLlxuICAgICAgICAgIC8vIFRoZXJlZm9yZSwgdHJ5IGluc2VydGluZyBhIHNwYWNlIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICAgIGlmICgobWF0Y2ggPSB0aGlzLl9ibGFuay5leGVjKGlucHV0KSkgfHwgaW5wdXRGaW5pc2hlZCAmJiAobWF0Y2ggPSB0aGlzLl9ibGFuay5leGVjKGlucHV0ICsgJyAnKSkpIHR5cGUgPSAnYmxhbmsnLCBwcmVmaXggPSAnXycsIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGEgbGl0ZXJhbCB3aXRob3V0IGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLl9zaW1wbGVRdW90ZWRTdHJpbmcuZXhlYyhpbnB1dCkpIHZhbHVlID0gbWF0Y2hbMV07IC8vIFRyeSB0byBmaW5kIGEgbGl0ZXJhbCB3cmFwcGVkIGluIHRocmVlIHBhaXJzIG9mIHF1b3Rlc1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAoe1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIG1hdGNoTGVuZ3RoXG4gICAgICAgICAgICAgIH0gPSB0aGlzLl9wYXJzZUxpdGVyYWwoaW5wdXQpKTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gcmVwb3J0U3ludGF4RXJyb3IodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgfHwgbWF0Y2hMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHR5cGUgPSAnbGl0ZXJhbCc7XG4gICAgICAgICAgICB0aGlzLl9saXRlcmFsQ2xvc2luZ1BvcyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICBpZiAoIXRoaXMuX2xpbmVNb2RlKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhIGxpdGVyYWwgd2l0aG91dCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLl9zaW1wbGVBcG9zdHJvcGhlU3RyaW5nLmV4ZWMoaW5wdXQpKSB2YWx1ZSA9IG1hdGNoWzFdOyAvLyBUcnkgdG8gZmluZCBhIGxpdGVyYWwgd3JhcHBlZCBpbiB0aHJlZSBwYWlycyBvZiBxdW90ZXNcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIG1hdGNoTGVuZ3RoXG4gICAgICAgICAgICAgICAgfSA9IHRoaXMuX3BhcnNlTGl0ZXJhbChpbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHJlcG9ydFN5bnRheEVycm9yKHRoaXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCB8fCBtYXRjaExlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICB0eXBlID0gJ2xpdGVyYWwnO1xuICAgICAgICAgICAgICB0aGlzLl9saXRlcmFsQ2xvc2luZ1BvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSB2YXJpYWJsZVxuICAgICAgICAgIGlmICh0aGlzLl9uM01vZGUgJiYgKG1hdGNoID0gdGhpcy5fdmFyaWFibGUuZXhlYyhpbnB1dCkpKSB0eXBlID0gJ3ZhcicsIHZhbHVlID0gbWF0Y2hbMF07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBsYW5ndWFnZSBjb2RlXG4gICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzTWFya2VyID09PSAnbGl0ZXJhbCcgJiYgKG1hdGNoID0gdGhpcy5fbGFuZ2NvZGUuZXhlYyhpbnB1dCkpKSB0eXBlID0gJ2xhbmdjb2RlJywgdmFsdWUgPSBtYXRjaFsxXTsgLy8gVHJ5IHRvIGZpbmQgYSBrZXl3b3JkXG4gICAgICAgICAgZWxzZSBpZiAobWF0Y2ggPSB0aGlzLl9rZXl3b3JkLmV4ZWMoaW5wdXQpKSB0eXBlID0gbWF0Y2hbMF07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBkb3QgYXMgcHVuY3R1YXRpb25cbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAxID8gaW5wdXRGaW5pc2hlZCA6IGlucHV0WzFdIDwgJzAnIHx8IGlucHV0WzFdID4gJzknKSB7XG4gICAgICAgICAgICB0eXBlID0gJy4nO1xuICAgICAgICAgICAgbWF0Y2hMZW5ndGggPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBudW1lcmljYWwgY2FzZSAoY291bGQgYmUgYSBkZWNpbWFsIGRvdClcblxuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgIGNhc2UgJzInOlxuICAgICAgICBjYXNlICczJzpcbiAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgIGNhc2UgJzUnOlxuICAgICAgICBjYXNlICc2JzpcbiAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgIGNhc2UgJzgnOlxuICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGEgbnVtYmVyLiBTaW5jZSBpdCBjYW4gY29udGFpbiAoYnV0IG5vdCBlbmQgd2l0aCkgYSBkb3QsXG4gICAgICAgICAgLy8gd2UgYWx3YXlzIG5lZWQgYSBub24tZG90IGNoYXJhY3RlciBiZWZvcmUgZGVjaWRpbmcgaXQgaXMgYSBudW1iZXIuXG4gICAgICAgICAgLy8gVGhlcmVmb3JlLCB0cnkgaW5zZXJ0aW5nIGEgc3BhY2UgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICAgICAgaWYgKG1hdGNoID0gdGhpcy5fbnVtYmVyLmV4ZWMoaW5wdXQpIHx8IGlucHV0RmluaXNoZWQgJiYgKG1hdGNoID0gdGhpcy5fbnVtYmVyLmV4ZWMoaW5wdXQgKyAnICcpKSkge1xuICAgICAgICAgICAgdHlwZSA9ICdsaXRlcmFsJywgdmFsdWUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIHByZWZpeCA9IHR5cGVvZiBtYXRjaFsxXSA9PT0gJ3N0cmluZycgPyB4c2QuZG91YmxlIDogdHlwZW9mIG1hdGNoWzJdID09PSAnc3RyaW5nJyA/IHhzZC5kZWNpbWFsIDogeHNkLmludGVnZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQic6XG4gICAgICAgIGNhc2UgJ2InOlxuICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhIFNQQVJRTC1zdHlsZSBrZXl3b3JkXG4gICAgICAgICAgaWYgKG1hdGNoID0gdGhpcy5fc3BhcnFsS2V5d29yZC5leGVjKGlucHV0KSkgdHlwZSA9IG1hdGNoWzBdLnRvVXBwZXJDYXNlKCk7ZWxzZSBpbmNvbmNsdXNpdmUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYSBib29sZWFuXG4gICAgICAgICAgaWYgKG1hdGNoID0gdGhpcy5fYm9vbGVhbi5leGVjKGlucHV0KSkgdHlwZSA9ICdsaXRlcmFsJywgdmFsdWUgPSBtYXRjaFswXSwgcHJlZml4ID0geHNkLmJvb2xlYW47ZWxzZSBpbmNvbmNsdXNpdmUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGFuIGFiYnJldmlhdGVkIHByZWRpY2F0ZVxuICAgICAgICAgIGlmIChtYXRjaCA9IHRoaXMuX3Nob3J0UHJlZGljYXRlcy5leGVjKGlucHV0KSkgdHlwZSA9ICdhYmJyZXZpYXRpb24nLCB2YWx1ZSA9ICdhJztlbHNlIGluY29uY2x1c2l2ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYW4gaW1wbGljYXRpb24gYXJyb3cgb3IgZXF1YWxzIHNpZ25cbiAgICAgICAgICBpZiAodGhpcy5fbjNNb2RlICYmIGlucHV0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnYWJicmV2aWF0aW9uJztcbiAgICAgICAgICAgIGlmIChpbnB1dFsxXSAhPT0gJz4nKSBtYXRjaExlbmd0aCA9IDEsIHZhbHVlID0gJz0nO2Vsc2UgbWF0Y2hMZW5ndGggPSAyLCB2YWx1ZSA9ICc+JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICBpZiAoIXRoaXMuX24zTW9kZSkgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgIGNhc2UgJzsnOlxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgIGNhc2UgJygnOlxuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgIGlmICghdGhpcy5fbGluZU1vZGUpIHtcbiAgICAgICAgICAgIG1hdGNoTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHR5cGUgPSBmaXJzdENoYXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpbmNvbmNsdXNpdmUgPSB0cnVlO1xuICAgICAgfSAvLyBTb21lIGZpcnN0IGNoYXJhY3RlcnMgZG8gbm90IGFsbG93IGFuIGltbWVkaWF0ZSBkZWNpc2lvbiwgc28gaW5zcGVjdCBtb3JlXG5cblxuICAgICAgaWYgKGluY29uY2x1c2l2ZSkge1xuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIHByZWZpeFxuICAgICAgICBpZiAoKHRoaXMuX3ByZXZpb3VzTWFya2VyID09PSAnQHByZWZpeCcgfHwgdGhpcy5fcHJldmlvdXNNYXJrZXIgPT09ICdQUkVGSVgnKSAmJiAobWF0Y2ggPSB0aGlzLl9wcmVmaXguZXhlYyhpbnB1dCkpKSB0eXBlID0gJ3ByZWZpeCcsIHZhbHVlID0gbWF0Y2hbMV0gfHwgJyc7IC8vIFRyeSB0byBmaW5kIGEgcHJlZml4ZWQgbmFtZS4gU2luY2UgaXQgY2FuIGNvbnRhaW4gKGJ1dCBub3QgZW5kIHdpdGgpIGEgZG90LFxuICAgICAgICAvLyB3ZSBhbHdheXMgbmVlZCBhIG5vbi1kb3QgY2hhcmFjdGVyIGJlZm9yZSBkZWNpZGluZyBpdCBpcyBhIHByZWZpeGVkIG5hbWUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgdHJ5IGluc2VydGluZyBhIHNwYWNlIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSB0aGlzLl9wcmVmaXhlZC5leGVjKGlucHV0KSkgfHwgaW5wdXRGaW5pc2hlZCAmJiAobWF0Y2ggPSB0aGlzLl9wcmVmaXhlZC5leGVjKGlucHV0ICsgJyAnKSkpIHR5cGUgPSAncHJlZml4ZWQnLCBwcmVmaXggPSBtYXRjaFsxXSB8fCAnJywgdmFsdWUgPSB0aGlzLl91bmVzY2FwZShtYXRjaFsyXSk7XG4gICAgICB9IC8vIEEgdHlwZSB0b2tlbiBpcyBzcGVjaWFsOiBpdCBjYW4gb25seSBiZSBlbWl0dGVkIGFmdGVyIGFuIElSSSBvciBwcmVmaXhlZCBuYW1lIGlzIHJlYWRcblxuXG4gICAgICBpZiAodGhpcy5fcHJldmlvdXNNYXJrZXIgPT09ICdeXicpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAncHJlZml4ZWQnOlxuICAgICAgICAgICAgdHlwZSA9ICd0eXBlJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSVJJJzpcbiAgICAgICAgICAgIHR5cGUgPSAndHlwZUlSSSc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0eXBlID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2hhdCBpZiBub3RoaW5nIG9mIHRoZSBhYm92ZSB3YXMgZm91bmQ/XG5cblxuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIC8vIFdlIGNvdWxkIGJlIGluIHN0cmVhbWluZyBtb2RlLCBhbmQgdGhlbiB3ZSBqdXN0IHdhaXQgZm9yIG1vcmUgaW5wdXQgdG8gYXJyaXZlLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGEgc3ludGF4IGVycm9yIGhhcyBvY2N1cnJlZCBpbiB0aGUgaW5wdXQuXG4gICAgICAgIC8vIE9uZSBleGNlcHRpb246IGVycm9yIG9uIGFuIHVuYWNjb3VudGVkIGxpbmVicmVhayAoPSBub3QgaW5zaWRlIGEgdHJpcGxlLXF1b3RlZCBsaXRlcmFsKS5cbiAgICAgICAgaWYgKGlucHV0RmluaXNoZWQgfHwgIS9eJycnfF5cIlwiXCIvLnRlc3QoaW5wdXQpICYmIC9cXG58XFxyLy50ZXN0KGlucHV0KSkgcmV0dXJuIHJlcG9ydFN5bnRheEVycm9yKHRoaXMpO2Vsc2UgcmV0dXJuIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICB9IC8vIEVtaXQgdGhlIHBhcnNlZCB0b2tlblxuXG5cbiAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgfTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuKTtcbiAgICAgIHRoaXMucHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgICAgdGhpcy5fcHJldmlvdXNNYXJrZXIgPSB0eXBlOyAvLyBBZHZhbmNlIHRvIG5leHQgcGFydCB0byB0b2tlbml6ZVxuXG4gICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cihtYXRjaExlbmd0aCB8fCBtYXRjaFswXS5sZW5ndGgsIGlucHV0Lmxlbmd0aCk7XG4gICAgfSAvLyBTaWduYWxzIHRoZSBzeW50YXggZXJyb3IgdGhyb3VnaCB0aGUgY2FsbGJhY2tcblxuXG4gICAgZnVuY3Rpb24gcmVwb3J0U3ludGF4RXJyb3Ioc2VsZikge1xuICAgICAgY2FsbGJhY2soc2VsZi5fc3ludGF4RXJyb3IoL15cXFMqLy5leGVjKGlucHV0KVswXSkpO1xuICAgIH1cbiAgfSAvLyAjIyMgYF91bmVzY2FwZWAgcmVwbGFjZXMgTjMgZXNjYXBlIGNvZGVzIGJ5IHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVyc1xuXG5cbiAgX3VuZXNjYXBlKGl0ZW0pIHtcbiAgICBsZXQgaW52YWxpZCA9IGZhbHNlO1xuICAgIGNvbnN0IHJlcGxhY2VkID0gaXRlbS5yZXBsYWNlKGVzY2FwZVNlcXVlbmNlLCAoc2VxdWVuY2UsIHVuaWNvZGU0LCB1bmljb2RlOCwgZXNjYXBlZENoYXIpID0+IHtcbiAgICAgIC8vIDQtZGlnaXQgdW5pY29kZSBjaGFyYWN0ZXJcbiAgICAgIGlmICh0eXBlb2YgdW5pY29kZTQgPT09ICdzdHJpbmcnKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIucGFyc2VJbnQodW5pY29kZTQsIDE2KSk7IC8vIDgtZGlnaXQgdW5pY29kZSBjaGFyYWN0ZXJcblxuICAgICAgaWYgKHR5cGVvZiB1bmljb2RlOCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IGNoYXJDb2RlID0gTnVtYmVyLnBhcnNlSW50KHVuaWNvZGU4LCAxNik7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZSA8PSAweEZGRkYgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKE51bWJlci5wYXJzZUludCh1bmljb2RlOCwgMTYpKSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKChjaGFyQ29kZSAtPSAweDEwMDAwKSA+PiAxMCksIDB4REMwMCArIChjaGFyQ29kZSAmIDB4M0ZGKSk7XG4gICAgICB9IC8vIGZpeGVkIGVzY2FwZSBzZXF1ZW5jZVxuXG5cbiAgICAgIGlmIChlc2NhcGVkQ2hhciBpbiBlc2NhcGVSZXBsYWNlbWVudHMpIHJldHVybiBlc2NhcGVSZXBsYWNlbWVudHNbZXNjYXBlZENoYXJdOyAvLyBpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZVxuXG4gICAgICBpbnZhbGlkID0gdHJ1ZTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gaW52YWxpZCA/IG51bGwgOiByZXBsYWNlZDtcbiAgfSAvLyAjIyMgYF9wYXJzZUxpdGVyYWxgIHBhcnNlcyBhIGxpdGVyYWwgaW50byBhbiB1bmVzY2FwZWQgdmFsdWVcblxuXG4gIF9wYXJzZUxpdGVyYWwoaW5wdXQpIHtcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBlbm91Z2ggbG9va2FoZWFkIHRvIGlkZW50aWZ5IHRyaXBsZS1xdW90ZWQgc3RyaW5nc1xuICAgIGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuICAgICAgLy8gSWRlbnRpZnkgdGhlIG9wZW5pbmcgcXVvdGUocylcbiAgICAgIGNvbnN0IG9wZW5pbmcgPSBpbnB1dC5tYXRjaCgvXig/OlwiXCJcInxcInwnJyd8J3wpLylbMF07XG4gICAgICBjb25zdCBvcGVuaW5nTGVuZ3RoID0gb3BlbmluZy5sZW5ndGg7IC8vIEZpbmQgdGhlIG5leHQgY2FuZGlkYXRlIGNsb3NpbmcgcXVvdGVzXG5cbiAgICAgIGxldCBjbG9zaW5nUG9zID0gTWF0aC5tYXgodGhpcy5fbGl0ZXJhbENsb3NpbmdQb3MsIG9wZW5pbmdMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKGNsb3NpbmdQb3MgPSBpbnB1dC5pbmRleE9mKG9wZW5pbmcsIGNsb3NpbmdQb3MpKSA+IDApIHtcbiAgICAgICAgLy8gQ291bnQgYmFja3NsYXNoZXMgcmlnaHQgYmVmb3JlIHRoZSBjbG9zaW5nIHF1b3Rlc1xuICAgICAgICBsZXQgYmFja3NsYXNoQ291bnQgPSAwO1xuXG4gICAgICAgIHdoaWxlIChpbnB1dFtjbG9zaW5nUG9zIC0gYmFja3NsYXNoQ291bnQgLSAxXSA9PT0gJ1xcXFwnKSBiYWNrc2xhc2hDb3VudCsrOyAvLyBBbiBldmVuIG51bWJlciBvZiBiYWNrc2xhc2hlcyAoaW4gcGFydGljdWxhciAwKVxuICAgICAgICAvLyBtZWFucyB0aGVzZSBhcmUgYWN0dWFsLCBub24tZXNjYXBlZCBjbG9zaW5nIHF1b3Rlc1xuXG5cbiAgICAgICAgaWYgKGJhY2tzbGFzaENvdW50ICUgMiA9PT0gMCkge1xuICAgICAgICAgIC8vIEV4dHJhY3QgYW5kIHVuZXNjYXBlIHRoZSB2YWx1ZVxuICAgICAgICAgIGNvbnN0IHJhdyA9IGlucHV0LnN1YnN0cmluZyhvcGVuaW5nTGVuZ3RoLCBjbG9zaW5nUG9zKTtcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IHJhdy5zcGxpdCgvXFxyXFxufFxccnxcXG4vKS5sZW5ndGggLSAxO1xuICAgICAgICAgIGNvbnN0IG1hdGNoTGVuZ3RoID0gY2xvc2luZ1BvcyArIG9wZW5pbmdMZW5ndGg7IC8vIE9ubHkgdHJpcGxlLXF1b3RlZCBzdHJpbmdzIGNhbiBiZSBtdWx0aS1saW5lXG5cbiAgICAgICAgICBpZiAob3BlbmluZ0xlbmd0aCA9PT0gMSAmJiBsaW5lcyAhPT0gMCB8fCBvcGVuaW5nTGVuZ3RoID09PSAzICYmIHRoaXMuX2xpbmVNb2RlKSBicmVhaztcbiAgICAgICAgICB0aGlzLl9saW5lICs9IGxpbmVzO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fdW5lc2NhcGUocmF3KSxcbiAgICAgICAgICAgIG1hdGNoTGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb3NpbmdQb3MrKztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGl0ZXJhbENsb3NpbmdQb3MgPSBpbnB1dC5sZW5ndGggLSBvcGVuaW5nTGVuZ3RoICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6ICcnLFxuICAgICAgbWF0Y2hMZW5ndGg6IDBcbiAgICB9O1xuICB9IC8vICMjIyBgX3N5bnRheEVycm9yYCBjcmVhdGVzIGEgc3ludGF4IGVycm9yIGZvciB0aGUgZ2l2ZW4gaXNzdWVcblxuXG4gIF9zeW50YXhFcnJvcihpc3N1ZSkge1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmV4cGVjdGVkIFwiJyArIGlzc3VlICsgJ1wiIG9uIGxpbmUgJyArIHRoaXMuX2xpbmUgKyAnLicpO1xuICAgIGVyci5jb250ZXh0ID0ge1xuICAgICAgdG9rZW46IHVuZGVmaW5lZCxcbiAgICAgIGxpbmU6IHRoaXMuX2xpbmUsXG4gICAgICBwcmV2aW91c1Rva2VuOiB0aGlzLnByZXZpb3VzVG9rZW5cbiAgICB9O1xuICAgIHJldHVybiBlcnI7XG4gIH0gLy8gIyMgUHVibGljIG1ldGhvZHNcbiAgLy8gIyMjIGB0b2tlbml6ZWAgc3RhcnRzIHRoZSB0cmFuc2Zvcm1hdGlvbiBvZiBhbiBOMyBkb2N1bWVudCBpbnRvIGFuIGFycmF5IG9mIHRva2Vucy5cbiAgLy8gVGhlIGlucHV0IGNhbiBiZSBhIHN0cmluZyBvciBhIHN0cmVhbS5cblxuXG4gIHRva2VuaXplKGlucHV0LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9saW5lID0gMTsgLy8gSWYgdGhlIGlucHV0IGlzIGEgc3RyaW5nLCBjb250aW51b3VzbHkgZW1pdCB0b2tlbnMgdGhyb3VnaCB0aGUgY2FsbGJhY2sgdW50aWwgdGhlIGVuZFxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7IC8vIElmIGEgY2FsbGJhY2sgd2FzIHBhc3NlZCwgYXN5bmNocm9ub3VzbHkgY2FsbCBpdFxuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSAoMCwgX3F1ZXVlTWljcm90YXNrLmRlZmF1bHQpKCgpID0+IHNlbGYuX3Rva2VuaXplVG9FbmQoY2FsbGJhY2ssIHRydWUpKTsgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHBhc3NlZCwgdG9rZW5pemUgc3luY2hyb25vdXNseSBhbmQgcmV0dXJuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gW10sXG4gICAgICAgICAgICAgIGVycm9yO1xuXG4gICAgICAgICAgdGhpcy5fdG9rZW5pemVUb0VuZChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgZSA/IGVycm9yID0gZSA6IHRva2Vucy5wdXNoKHQpO1xuICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9XG4gICAgfSAvLyBPdGhlcndpc2UsIHRoZSBpbnB1dCBtdXN0IGJlIGEgc3RyZWFtXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gJyc7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdCdWZmZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LnNldEVuY29kaW5nID09PSAnZnVuY3Rpb24nKSBpbnB1dC5zZXRFbmNvZGluZygndXRmOCcpOyAvLyBBZGRzIHRoZSBkYXRhIGNodW5rIHRvIHRoZSBidWZmZXIgYW5kIHBhcnNlcyBhcyBmYXIgYXMgcG9zc2libGVcblxuICAgICAgICBpbnB1dC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgaWYgKHNlbGYuX2lucHV0ICE9PSBudWxsICYmIGRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBQcmVwZW5kIGFueSBwcmV2aW91cyBwZW5kaW5nIHdyaXRlc1xuICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdCdWZmZXIpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX3BlbmRpbmdCdWZmZXIsIGRhdGFdKTtcbiAgICAgICAgICAgICAgc2VsZi5fcGVuZGluZ0J1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICB9IC8vIEhvbGQgaWYgdGhlIGJ1ZmZlciBlbmRzIGluIGFuIGluY29tcGxldGUgdW5pY29kZSBzZXF1ZW5jZVxuXG5cbiAgICAgICAgICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoIC0gMV0gJiAweDgwKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3BlbmRpbmdCdWZmZXIgPSBkYXRhO1xuICAgICAgICAgICAgfSAvLyBPdGhlcndpc2UsIHRva2VuaXplIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5faW5wdXQgKz0gZGF0YTtcblxuICAgICAgICAgICAgICAgIHNlbGYuX3Rva2VuaXplVG9FbmQoY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIFBhcnNlcyB1bnRpbCB0aGUgZW5kXG5cbiAgICAgICAgaW5wdXQub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc2VsZi5faW5wdXQgIT09IG51bGwpIHNlbGYuX3Rva2VuaXplVG9FbmQoY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5wdXQub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuICAgICAgfVxuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gTjNMZXhlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9OM0xleGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9OM0xleGVyXCIpKTtcblxudmFyIF9OM0RhdGFGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9OM0RhdGFGYWN0b3J5XCIpKTtcblxudmFyIF9JUklzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9JUklzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gKipOM1BhcnNlcioqIHBhcnNlcyBOMyBkb2N1bWVudHMuXG5sZXQgYmxhbmtOb2RlUHJlZml4ID0gMDsgLy8gIyMgQ29uc3RydWN0b3JcblxuY2xhc3MgTjNQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5fY29udGV4dFN0YWNrID0gW107XG4gICAgdGhpcy5fZ3JhcGggPSBudWxsOyAvLyBTZXQgdGhlIGRvY3VtZW50IElSSVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLl9zZXRCYXNlKG9wdGlvbnMuYmFzZUlSSSk7XG5cbiAgICBvcHRpb25zLmZhY3RvcnkgJiYgaW5pdERhdGFGYWN0b3J5KHRoaXMsIG9wdGlvbnMuZmFjdG9yeSk7IC8vIFNldCBzdXBwb3J0ZWQgZmVhdHVyZXMgZGVwZW5kaW5nIG9uIHRoZSBmb3JtYXRcblxuICAgIHZhciBmb3JtYXQgPSB0eXBlb2Ygb3B0aW9ucy5mb3JtYXQgPT09ICdzdHJpbmcnID8gb3B0aW9ucy5mb3JtYXQubWF0Y2goL1xcdyokLylbMF0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgICAgICBpc1R1cnRsZSA9IC90dXJ0bGUvLnRlc3QoZm9ybWF0KSxcbiAgICAgICAgaXNUcmlHID0gL3RyaWcvLnRlc3QoZm9ybWF0KSxcbiAgICAgICAgaXNOVHJpcGxlcyA9IC90cmlwbGUvLnRlc3QoZm9ybWF0KSxcbiAgICAgICAgaXNOUXVhZHMgPSAvcXVhZC8udGVzdChmb3JtYXQpLFxuICAgICAgICBpc04zID0gdGhpcy5fbjNNb2RlID0gL24zLy50ZXN0KGZvcm1hdCksXG4gICAgICAgIGlzTGluZU1vZGUgPSBpc05UcmlwbGVzIHx8IGlzTlF1YWRzO1xuICAgIGlmICghKHRoaXMuX3N1cHBvcnRzTmFtZWRHcmFwaHMgPSAhKGlzVHVydGxlIHx8IGlzTjMpKSkgdGhpcy5fcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaCA9IHRoaXMuX3JlYWRQcmVkaWNhdGU7IC8vIFN1cHBvcnQgdHJpcGxlcyBpbiBvdGhlciBncmFwaHNcblxuICAgIHRoaXMuX3N1cHBvcnRzUXVhZHMgPSAhKGlzVHVydGxlIHx8IGlzVHJpRyB8fCBpc05UcmlwbGVzIHx8IGlzTjMpOyAvLyBTdXBwb3J0IG5lc3Rpbmcgb2YgdHJpcGxlc1xuXG4gICAgdGhpcy5fc3VwcG9ydHNSREZTdGFyID0gZm9ybWF0ID09PSAnJyB8fCAvc3RhcnxcXCokLy50ZXN0KGZvcm1hdCk7IC8vIERpc2FibGUgcmVsYXRpdmUgSVJJcyBpbiBOLVRyaXBsZXMgb3IgTi1RdWFkcyBtb2RlXG5cbiAgICBpZiAoaXNMaW5lTW9kZSkgdGhpcy5fcmVzb2x2ZVJlbGF0aXZlSVJJID0gZnVuY3Rpb24gKGlyaSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLl9ibGFua05vZGVQcmVmaXggPSB0eXBlb2Ygb3B0aW9ucy5ibGFua05vZGVQcmVmaXggIT09ICdzdHJpbmcnID8gJycgOiBvcHRpb25zLmJsYW5rTm9kZVByZWZpeC5yZXBsYWNlKC9eKD8hXzopLywgJ186Jyk7XG4gICAgdGhpcy5fbGV4ZXIgPSBvcHRpb25zLmxleGVyIHx8IG5ldyBfTjNMZXhlci5kZWZhdWx0KHtcbiAgICAgIGxpbmVNb2RlOiBpc0xpbmVNb2RlLFxuICAgICAgbjM6IGlzTjNcbiAgICB9KTsgLy8gRGlzYWJsZSBleHBsaWNpdCBxdWFudGlmaWVycyBieSBkZWZhdWx0XG5cbiAgICB0aGlzLl9leHBsaWNpdFF1YW50aWZpZXJzID0gISFvcHRpb25zLmV4cGxpY2l0UXVhbnRpZmllcnM7XG4gIH0gLy8gIyMgU3RhdGljIGNsYXNzIG1ldGhvZHNcbiAgLy8gIyMjIGBfcmVzZXRCbGFua05vZGVQcmVmaXhgIHJlc3RhcnRzIGJsYW5rIG5vZGUgcHJlZml4IGlkZW50aWZpY2F0aW9uXG5cblxuICBzdGF0aWMgX3Jlc2V0QmxhbmtOb2RlUHJlZml4KCkge1xuICAgIGJsYW5rTm9kZVByZWZpeCA9IDA7XG4gIH0gLy8gIyMgUHJpdmF0ZSBtZXRob2RzXG4gIC8vICMjIyBgX3NldEJhc2VgIHNldHMgdGhlIGJhc2UgSVJJIHRvIHJlc29sdmUgcmVsYXRpdmUgSVJJc1xuXG5cbiAgX3NldEJhc2UoYmFzZUlSSSkge1xuICAgIGlmICghYmFzZUlSSSkge1xuICAgICAgdGhpcy5fYmFzZSA9ICcnO1xuICAgICAgdGhpcy5fYmFzZVBhdGggPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIGZyYWdtZW50IGlmIHByZXNlbnRcbiAgICAgIHZhciBmcmFnbWVudFBvcyA9IGJhc2VJUkkuaW5kZXhPZignIycpO1xuICAgICAgaWYgKGZyYWdtZW50UG9zID49IDApIGJhc2VJUkkgPSBiYXNlSVJJLnN1YnN0cigwLCBmcmFnbWVudFBvcyk7IC8vIFNldCBiYXNlIElSSSBhbmQgaXRzIGNvbXBvbmVudHNcblxuICAgICAgdGhpcy5fYmFzZSA9IGJhc2VJUkk7XG4gICAgICB0aGlzLl9iYXNlUGF0aCA9IGJhc2VJUkkuaW5kZXhPZignLycpIDwgMCA/IGJhc2VJUkkgOiBiYXNlSVJJLnJlcGxhY2UoL1teXFwvP10qKD86XFw/LiopPyQvLCAnJyk7XG4gICAgICBiYXNlSVJJID0gYmFzZUlSSS5tYXRjaCgvXig/OihbYS16XVthLXowLTkrLi1dKjopKT8oPzpcXC9cXC9bXlxcL10qKT8vaSk7XG4gICAgICB0aGlzLl9iYXNlUm9vdCA9IGJhc2VJUklbMF07XG4gICAgICB0aGlzLl9iYXNlU2NoZW1lID0gYmFzZUlSSVsxXTtcbiAgICB9XG4gIH0gLy8gIyMjIGBfc2F2ZUNvbnRleHRgIHN0b3JlcyB0aGUgY3VycmVudCBwYXJzaW5nIGNvbnRleHRcbiAgLy8gd2hlbiBlbnRlcmluZyBhIG5ldyBzY29wZSAobGlzdCwgYmxhbmsgbm9kZSwgZm9ybXVsYSlcblxuXG4gIF9zYXZlQ29udGV4dCh0eXBlLCBncmFwaCwgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpIHtcbiAgICB2YXIgbjNNb2RlID0gdGhpcy5fbjNNb2RlO1xuXG4gICAgdGhpcy5fY29udGV4dFN0YWNrLnB1c2goe1xuICAgICAgc3ViamVjdDogc3ViamVjdCxcbiAgICAgIHByZWRpY2F0ZTogcHJlZGljYXRlLFxuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBncmFwaDogZ3JhcGgsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaW52ZXJzZTogbjNNb2RlID8gdGhpcy5faW52ZXJzZVByZWRpY2F0ZSA6IGZhbHNlLFxuICAgICAgYmxhbmtQcmVmaXg6IG4zTW9kZSA/IHRoaXMuX3ByZWZpeGVzLl8gOiAnJyxcbiAgICAgIHF1YW50aWZpZWQ6IG4zTW9kZSA/IHRoaXMuX3F1YW50aWZpZWQgOiBudWxsXG4gICAgfSk7IC8vIFRoZSBzZXR0aW5ncyBiZWxvdyBvbmx5IGFwcGx5IHRvIE4zIHN0cmVhbXNcblxuXG4gICAgaWYgKG4zTW9kZSkge1xuICAgICAgLy8gRXZlcnkgbmV3IHNjb3BlIHJlc2V0cyB0aGUgcHJlZGljYXRlIGRpcmVjdGlvblxuICAgICAgdGhpcy5faW52ZXJzZVByZWRpY2F0ZSA9IGZhbHNlOyAvLyBJbiBOMywgYmxhbmsgbm9kZXMgYXJlIHNjb3BlZCB0byBhIGZvcm11bGFcbiAgICAgIC8vICh1c2luZyBhIGRvdCBhcyBzZXBhcmF0b3IsIGFzIGEgYmxhbmsgbm9kZSBsYWJlbCBjYW5ub3Qgc3RhcnQgd2l0aCBpdClcblxuICAgICAgdGhpcy5fcHJlZml4ZXMuXyA9IHRoaXMuX2dyYXBoID8gdGhpcy5fZ3JhcGguaWQuc3Vic3RyKDIpICsgJy4nIDogJy4nOyAvLyBRdWFudGlmaWVycyBhcmUgc2NvcGVkIHRvIGEgZm9ybXVsYVxuXG4gICAgICB0aGlzLl9xdWFudGlmaWVkID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9xdWFudGlmaWVkKTtcbiAgICB9XG4gIH0gLy8gIyMjIGBfcmVzdG9yZUNvbnRleHRgIHJlc3RvcmVzIHRoZSBwYXJlbnQgY29udGV4dFxuICAvLyB3aGVuIGxlYXZpbmcgYSBzY29wZSAobGlzdCwgYmxhbmsgbm9kZSwgZm9ybXVsYSlcblxuXG4gIF9yZXN0b3JlQ29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHRTdGFjay5wb3AoKSxcbiAgICAgICAgbjNNb2RlID0gdGhpcy5fbjNNb2RlO1xuXG4gICAgdGhpcy5fc3ViamVjdCA9IGNvbnRleHQuc3ViamVjdDtcbiAgICB0aGlzLl9wcmVkaWNhdGUgPSBjb250ZXh0LnByZWRpY2F0ZTtcbiAgICB0aGlzLl9vYmplY3QgPSBjb250ZXh0Lm9iamVjdDtcbiAgICB0aGlzLl9ncmFwaCA9IGNvbnRleHQuZ3JhcGg7IC8vIFRoZSBzZXR0aW5ncyBiZWxvdyBvbmx5IGFwcGx5IHRvIE4zIHN0cmVhbXNcblxuICAgIGlmIChuM01vZGUpIHtcbiAgICAgIHRoaXMuX2ludmVyc2VQcmVkaWNhdGUgPSBjb250ZXh0LmludmVyc2U7XG4gICAgICB0aGlzLl9wcmVmaXhlcy5fID0gY29udGV4dC5ibGFua1ByZWZpeDtcbiAgICAgIHRoaXMuX3F1YW50aWZpZWQgPSBjb250ZXh0LnF1YW50aWZpZWQ7XG4gICAgfVxuICB9IC8vICMjIyBgX3JlYWRJblRvcENvbnRleHRgIHJlYWRzIGEgdG9rZW4gd2hlbiBpbiB0aGUgdG9wIGNvbnRleHRcblxuXG4gIF9yZWFkSW5Ub3BDb250ZXh0KHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAvLyBJZiBhbiBFT0YgdG9rZW4gYXJyaXZlcyBpbiB0aGUgdG9wIGNvbnRleHQsIHNpZ25hbCB0aGF0IHdlJ3JlIGRvbmVcbiAgICAgIGNhc2UgJ2VvZic6XG4gICAgICAgIGlmICh0aGlzLl9ncmFwaCAhPT0gbnVsbCkgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmNsb3NlZCBncmFwaCcsIHRva2VuKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3ByZWZpeGVzLl87XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsYmFjayhudWxsLCBudWxsLCB0aGlzLl9wcmVmaXhlcyk7XG4gICAgICAvLyBJdCBjb3VsZCBiZSBhIHByZWZpeCBkZWNsYXJhdGlvblxuXG4gICAgICBjYXNlICdQUkVGSVgnOlxuICAgICAgICB0aGlzLl9zcGFycWxTdHlsZSA9IHRydWU7XG5cbiAgICAgIGNhc2UgJ0BwcmVmaXgnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFByZWZpeDtcbiAgICAgIC8vIEl0IGNvdWxkIGJlIGEgYmFzZSBkZWNsYXJhdGlvblxuXG4gICAgICBjYXNlICdCQVNFJzpcbiAgICAgICAgdGhpcy5fc3BhcnFsU3R5bGUgPSB0cnVlO1xuXG4gICAgICBjYXNlICdAYmFzZSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkQmFzZUlSSTtcbiAgICAgIC8vIEl0IGNvdWxkIGJlIGEgZ3JhcGhcblxuICAgICAgY2FzZSAneyc6XG4gICAgICAgIGlmICh0aGlzLl9zdXBwb3J0c05hbWVkR3JhcGhzKSB7XG4gICAgICAgICAgdGhpcy5fZ3JhcGggPSAnJztcbiAgICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnR1JBUEgnOlxuICAgICAgICBpZiAodGhpcy5fc3VwcG9ydHNOYW1lZEdyYXBocykgcmV0dXJuIHRoaXMuX3JlYWROYW1lZEdyYXBoTGFiZWw7XG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBuZXh0IHRva2VuIG11c3QgYmUgYSBzdWJqZWN0XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkU3ViamVjdCh0b2tlbik7XG4gICAgfVxuICB9IC8vICMjIyBgX3JlYWRFbnRpdHlgIHJlYWRzIGFuIElSSSwgcHJlZml4ZWQgbmFtZSwgYmxhbmsgbm9kZSwgb3IgdmFyaWFibGVcblxuXG4gIF9yZWFkRW50aXR5KHRva2VuLCBxdWFudGlmaWVyKSB7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAvLyBSZWFkIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgSVJJXG4gICAgICBjYXNlICdJUkknOlxuICAgICAgY2FzZSAndHlwZUlSSSc6XG4gICAgICAgIHZhciBpcmkgPSB0aGlzLl9yZXNvbHZlSVJJKHRva2VuLnZhbHVlKTtcblxuICAgICAgICBpZiAoaXJpID09PSBudWxsKSByZXR1cm4gdGhpcy5fZXJyb3IoJ0ludmFsaWQgSVJJJywgdG9rZW4pO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX25hbWVkTm9kZShpcmkpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFJlYWQgYSBwcmVmaXhlZCBuYW1lXG5cbiAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgY2FzZSAncHJlZml4ZWQnOlxuICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5fcHJlZml4ZXNbdG9rZW4ucHJlZml4XTtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuZGVmaW5lZCBwcmVmaXggXCInICsgdG9rZW4ucHJlZml4ICsgJzpcIicsIHRva2VuKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9uYW1lZE5vZGUocHJlZml4ICsgdG9rZW4udmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFJlYWQgYSBibGFuayBub2RlXG5cbiAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9ibGFua05vZGUodGhpcy5fcHJlZml4ZXNbdG9rZW4ucHJlZml4XSArIHRva2VuLnZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBSZWFkIGEgdmFyaWFibGVcblxuICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgdmFsdWUgPSB0aGlzLl92YXJpYWJsZSh0b2tlbi52YWx1ZS5zdWJzdHIoMSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBub3QgYW4gZW50aXR5XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgZW50aXR5IGJ1dCBnb3QgJyArIHRva2VuLnR5cGUsIHRva2VuKTtcbiAgICB9IC8vIEluIE4zIG1vZGUsIHJlcGxhY2UgdGhlIGVudGl0eSBpZiBpdCBpcyBxdWFudGlmaWVkXG5cblxuICAgIGlmICghcXVhbnRpZmllciAmJiB0aGlzLl9uM01vZGUgJiYgdmFsdWUuaWQgaW4gdGhpcy5fcXVhbnRpZmllZCkgdmFsdWUgPSB0aGlzLl9xdWFudGlmaWVkW3ZhbHVlLmlkXTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gLy8gIyMjIGBfcmVhZFN1YmplY3RgIHJlYWRzIGEgcXVhZCdzIHN1YmplY3RcblxuXG4gIF9yZWFkU3ViamVjdCh0b2tlbikge1xuICAgIHRoaXMuX3ByZWRpY2F0ZSA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICAvLyBTdGFydCBhIG5ldyBxdWFkIHdpdGggYSBuZXcgYmxhbmsgbm9kZSBhcyBzdWJqZWN0XG4gICAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCdibGFuaycsIHRoaXMuX2dyYXBoLCB0aGlzLl9zdWJqZWN0ID0gdGhpcy5fYmxhbmtOb2RlKCksIG51bGwsIG51bGwpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkQmxhbmtOb2RlSGVhZDtcblxuICAgICAgY2FzZSAnKCc6XG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IGxpc3RcbiAgICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2xpc3QnLCB0aGlzLl9ncmFwaCwgdGhpcy5SREZfTklMLCBudWxsLCBudWxsKTtcblxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRMaXN0SXRlbTtcblxuICAgICAgY2FzZSAneyc6XG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IGZvcm11bGFcbiAgICAgICAgaWYgKCF0aGlzLl9uM01vZGUpIHJldHVybiB0aGlzLl9lcnJvcignVW5leHBlY3RlZCBncmFwaCcsIHRva2VuKTtcblxuICAgICAgICB0aGlzLl9zYXZlQ29udGV4dCgnZm9ybXVsYScsIHRoaXMuX2dyYXBoLCB0aGlzLl9ncmFwaCA9IHRoaXMuX2JsYW5rTm9kZSgpLCBudWxsLCBudWxsKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3Q7XG5cbiAgICAgIGNhc2UgJ30nOlxuICAgICAgICAvLyBObyBzdWJqZWN0OyB0aGUgZ3JhcGggaW4gd2hpY2ggd2UgYXJlIHJlYWRpbmcgaXMgY2xvc2VkIGluc3RlYWRcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRQdW5jdHVhdGlvbih0b2tlbik7XG5cbiAgICAgIGNhc2UgJ0Bmb3JTb21lJzpcbiAgICAgICAgaWYgKCF0aGlzLl9uM01vZGUpIHJldHVybiB0aGlzLl9lcnJvcignVW5leHBlY3RlZCBcIkBmb3JTb21lXCInLCB0b2tlbik7XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcmVkaWNhdGUgPSB0aGlzLk4zX0ZPUlNPTUU7XG4gICAgICAgIHRoaXMuX3F1YW50aWZpZXIgPSB0aGlzLl9ibGFua05vZGU7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkUXVhbnRpZmllckxpc3Q7XG5cbiAgICAgIGNhc2UgJ0Bmb3JBbGwnOlxuICAgICAgICBpZiAoIXRoaXMuX24zTW9kZSkgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIFwiQGZvckFsbFwiJywgdG9rZW4pO1xuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJlZGljYXRlID0gdGhpcy5OM19GT1JBTEw7XG4gICAgICAgIHRoaXMuX3F1YW50aWZpZXIgPSB0aGlzLl92YXJpYWJsZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRRdWFudGlmaWVyTGlzdDtcblxuICAgICAgY2FzZSAnbGl0ZXJhbCc6XG4gICAgICAgIGlmICghdGhpcy5fbjNNb2RlKSByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuZXhwZWN0ZWQgbGl0ZXJhbCcsIHRva2VuKTtcblxuICAgICAgICBpZiAodG9rZW4ucHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2xpdGVyYWxWYWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wbGV0ZVN1YmplY3RMaXRlcmFsO1xuICAgICAgICB9IGVsc2UgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2xpdGVyYWwodG9rZW4udmFsdWUsIHRoaXMuX25hbWVkTm9kZSh0b2tlbi5wcmVmaXgpKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPDwnOlxuICAgICAgICBpZiAoIXRoaXMuX3N1cHBvcnRzUkRGU3RhcikgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIFJERiogc3ludGF4JywgdG9rZW4pO1xuXG4gICAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCc8PCcsIHRoaXMuX2dyYXBoLCBudWxsLCBudWxsLCBudWxsKTtcblxuICAgICAgICB0aGlzLl9ncmFwaCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkU3ViamVjdDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gUmVhZCB0aGUgc3ViamVjdCBlbnRpdHlcbiAgICAgICAgaWYgKCh0aGlzLl9zdWJqZWN0ID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gSW4gTjMgbW9kZSwgdGhlIHN1YmplY3QgbWlnaHQgYmUgYSBwYXRoXG5cbiAgICAgICAgaWYgKHRoaXMuX24zTW9kZSkgcmV0dXJuIHRoaXMuX2dldFBhdGhSZWFkZXIodGhpcy5fcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaCk7XG4gICAgfSAvLyBUaGUgbmV4dCB0b2tlbiBtdXN0IGJlIGEgcHJlZGljYXRlLFxuICAgIC8vIG9yLCBpZiB0aGUgc3ViamVjdCB3YXMgYWN0dWFsbHkgYSBncmFwaCBJUkksIGEgbmFtZWQgZ3JhcGhcblxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQcmVkaWNhdGVPck5hbWVkR3JhcGg7XG4gIH0gLy8gIyMjIGBfcmVhZFByZWRpY2F0ZWAgcmVhZHMgYSBxdWFkJ3MgcHJlZGljYXRlXG5cblxuICBfcmVhZFByZWRpY2F0ZSh0b2tlbikge1xuICAgIHZhciB0eXBlID0gdG9rZW4udHlwZTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaW52ZXJzZSc6XG4gICAgICAgIHRoaXMuX2ludmVyc2VQcmVkaWNhdGUgPSB0cnVlO1xuXG4gICAgICBjYXNlICdhYmJyZXZpYXRpb24nOlxuICAgICAgICB0aGlzLl9wcmVkaWNhdGUgPSB0aGlzLkFCQlJFVklBVElPTlNbdG9rZW4udmFsdWVdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnLic6XG4gICAgICBjYXNlICddJzpcbiAgICAgIGNhc2UgJ30nOlxuICAgICAgICAvLyBFeHBlY3RlZCBwcmVkaWNhdGUgZGlkbid0IGNvbWUsIG11c3QgaGF2ZSBiZWVuIHRyYWlsaW5nIHNlbWljb2xvblxuICAgICAgICBpZiAodGhpcy5fcHJlZGljYXRlID09PSBudWxsKSByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuZXhwZWN0ZWQgJyArIHR5cGUsIHRva2VuKTtcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnXScgPyB0aGlzLl9yZWFkQmxhbmtOb2RlVGFpbCh0b2tlbikgOiB0aGlzLl9yZWFkUHVuY3R1YXRpb24odG9rZW4pO1xuXG4gICAgICBjYXNlICc7JzpcbiAgICAgICAgLy8gQWRkaXRpb25hbCBzZW1pY29sb25zIGNhbiBiZSBzYWZlbHkgaWdub3JlZFxuICAgICAgICByZXR1cm4gdGhpcy5fcHJlZGljYXRlICE9PSBudWxsID8gdGhpcy5fcmVhZFByZWRpY2F0ZSA6IHRoaXMuX2Vycm9yKCdFeHBlY3RlZCBwcmVkaWNhdGUgYnV0IGdvdCA7JywgdG9rZW4pO1xuXG4gICAgICBjYXNlICdibGFuayc6XG4gICAgICAgIGlmICghdGhpcy5fbjNNb2RlKSByZXR1cm4gdGhpcy5fZXJyb3IoJ0Rpc2FsbG93ZWQgYmxhbmsgbm9kZSBhcyBwcmVkaWNhdGUnLCB0b2tlbik7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICgodGhpcy5fcHJlZGljYXRlID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICB9IC8vIFRoZSBuZXh0IHRva2VuIG11c3QgYmUgYW4gb2JqZWN0XG5cblxuICAgIHJldHVybiB0aGlzLl9yZWFkT2JqZWN0O1xuICB9IC8vICMjIyBgX3JlYWRPYmplY3RgIHJlYWRzIGEgcXVhZCdzIG9iamVjdFxuXG5cbiAgX3JlYWRPYmplY3QodG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAvLyBSZWd1bGFyIGxpdGVyYWwsIGNhbiBzdGlsbCBnZXQgYSBkYXRhdHlwZSBvciBsYW5ndWFnZVxuICAgICAgICBpZiAodG9rZW4ucHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2xpdGVyYWxWYWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkRGF0YVR5cGVPckxhbmc7XG4gICAgICAgIH0gLy8gUHJlLWRhdGF0eXBlZCBzdHJpbmcgbGl0ZXJhbCAocHJlZml4IHN0b3JlcyB0aGUgZGF0YXR5cGUpXG4gICAgICAgIGVsc2UgdGhpcy5fb2JqZWN0ID0gdGhpcy5fbGl0ZXJhbCh0b2tlbi52YWx1ZSwgdGhpcy5fbmFtZWROb2RlKHRva2VuLnByZWZpeCkpO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgcXVhZCB3aXRoIGEgbmV3IGJsYW5rIG5vZGUgYXMgc3ViamVjdFxuICAgICAgICB0aGlzLl9zYXZlQ29udGV4dCgnYmxhbmsnLCB0aGlzLl9ncmFwaCwgdGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLCB0aGlzLl9zdWJqZWN0ID0gdGhpcy5fYmxhbmtOb2RlKCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkQmxhbmtOb2RlSGVhZDtcblxuICAgICAgY2FzZSAnKCc6XG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IGxpc3RcbiAgICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2xpc3QnLCB0aGlzLl9ncmFwaCwgdGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLCB0aGlzLlJERl9OSUwpO1xuXG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZExpc3RJdGVtO1xuXG4gICAgICBjYXNlICd7JzpcbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgZm9ybXVsYVxuICAgICAgICBpZiAoIXRoaXMuX24zTW9kZSkgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIGdyYXBoJywgdG9rZW4pO1xuXG4gICAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCdmb3JtdWxhJywgdGhpcy5fZ3JhcGgsIHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSwgdGhpcy5fZ3JhcGggPSB0aGlzLl9ibGFua05vZGUoKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdWJqZWN0O1xuXG4gICAgICBjYXNlICc8PCc6XG4gICAgICAgIGlmICghdGhpcy5fc3VwcG9ydHNSREZTdGFyKSByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuZXhwZWN0ZWQgUkRGKiBzeW50YXgnLCB0b2tlbik7XG5cbiAgICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJzw8JywgdGhpcy5fZ3JhcGgsIHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSwgbnVsbCk7XG5cbiAgICAgICAgdGhpcy5fZ3JhcGggPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3Q7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFJlYWQgdGhlIG9iamVjdCBlbnRpdHlcbiAgICAgICAgaWYgKCh0aGlzLl9vYmplY3QgPSB0aGlzLl9yZWFkRW50aXR5KHRva2VuKSkgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBJbiBOMyBtb2RlLCB0aGUgb2JqZWN0IG1pZ2h0IGJlIGEgcGF0aFxuXG4gICAgICAgIGlmICh0aGlzLl9uM01vZGUpIHJldHVybiB0aGlzLl9nZXRQYXRoUmVhZGVyKHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKTtcbiAgfSAvLyAjIyMgYF9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBoYCByZWFkcyBhIHF1YWQncyBwcmVkaWNhdGUsIG9yIGEgbmFtZWQgZ3JhcGhcblxuXG4gIF9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBoKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLnR5cGUgPT09ICd7JyA/IHRoaXMuX3JlYWRHcmFwaCh0b2tlbikgOiB0aGlzLl9yZWFkUHJlZGljYXRlKHRva2VuKTtcbiAgfSAvLyAjIyMgYF9yZWFkR3JhcGhgIHJlYWRzIGEgZ3JhcGhcblxuXG4gIF9yZWFkR3JhcGgodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3snKSByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIGdyYXBoIGJ1dCBnb3QgJyArIHRva2VuLnR5cGUsIHRva2VuKTsgLy8gVGhlIFwic3ViamVjdFwiIHdlIHJlYWQgaXMgYWN0dWFsbHkgdGhlIEdSQVBIJ3MgbGFiZWxcblxuICAgIHRoaXMuX2dyYXBoID0gdGhpcy5fc3ViamVjdCwgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRTdWJqZWN0O1xuICB9IC8vICMjIyBgX3JlYWRCbGFua05vZGVIZWFkYCByZWFkcyB0aGUgaGVhZCBvZiBhIGJsYW5rIG5vZGVcblxuXG4gIF9yZWFkQmxhbmtOb2RlSGVhZCh0b2tlbikge1xuICAgIGlmICh0b2tlbi50eXBlID09PSAnXScpIHtcbiAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRCbGFua05vZGVUYWlsKHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJlZGljYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkUHJlZGljYXRlKHRva2VuKTtcbiAgICB9XG4gIH0gLy8gIyMjIGBfcmVhZEJsYW5rTm9kZVRhaWxgIHJlYWRzIHRoZSBlbmQgb2YgYSBibGFuayBub2RlXG5cblxuICBfcmVhZEJsYW5rTm9kZVRhaWwodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ10nKSByZXR1cm4gdGhpcy5fcmVhZEJsYW5rTm9kZVB1bmN0dWF0aW9uKHRva2VuKTsgLy8gU3RvcmUgYmxhbmsgbm9kZSBxdWFkXG5cbiAgICBpZiAodGhpcy5fc3ViamVjdCAhPT0gbnVsbCkgdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LCB0aGlzLl9wcmVkaWNhdGUsIHRoaXMuX29iamVjdCwgdGhpcy5fZ3JhcGgpOyAvLyBSZXN0b3JlIHRoZSBwYXJlbnQgY29udGV4dCBjb250YWluaW5nIHRoaXMgYmxhbmsgbm9kZVxuXG4gICAgdmFyIGVtcHR5ID0gdGhpcy5fcHJlZGljYXRlID09PSBudWxsO1xuXG4gICAgdGhpcy5fcmVzdG9yZUNvbnRleHQoKTsgLy8gSWYgdGhlIGJsYW5rIG5vZGUgd2FzIHRoZSBzdWJqZWN0LCBjb250aW51ZSByZWFkaW5nIHRoZSBwcmVkaWNhdGVcblxuXG4gICAgaWYgKHRoaXMuX29iamVjdCA9PT0gbnVsbCkgLy8gSWYgdGhlIGJsYW5rIG5vZGUgd2FzIGVtcHR5LCBpdCBjb3VsZCBiZSBhIG5hbWVkIGdyYXBoIGxhYmVsXG4gICAgICByZXR1cm4gZW1wdHkgPyB0aGlzLl9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBoIDogdGhpcy5fcmVhZFByZWRpY2F0ZUFmdGVyQmxhbms7IC8vIElmIHRoZSBibGFuayBub2RlIHdhcyB0aGUgb2JqZWN0LCByZXN0b3JlIHByZXZpb3VzIGNvbnRleHQgYW5kIHJlYWQgcHVuY3R1YXRpb25cbiAgICBlbHNlIHJldHVybiB0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCk7XG4gIH0gLy8gIyMjIGBfcmVhZFByZWRpY2F0ZUFmdGVyQmxhbmtgIHJlYWRzIGEgcHJlZGljYXRlIGFmdGVyIGFuIGFub255bW91cyBibGFuayBub2RlXG5cblxuICBfcmVhZFByZWRpY2F0ZUFmdGVyQmxhbmsodG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgJy4nOlxuICAgICAgY2FzZSAnfSc6XG4gICAgICAgIC8vIE5vIHByZWRpY2F0ZSBpcyBjb21pbmcgaWYgdGhlIHRyaXBsZSBpcyB0ZXJtaW5hdGVkIGhlcmVcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkUHVuY3R1YXRpb24odG9rZW4pO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFByZWRpY2F0ZSh0b2tlbik7XG4gICAgfVxuICB9IC8vICMjIyBgX3JlYWRMaXN0SXRlbWAgcmVhZHMgaXRlbXMgZnJvbSBhIGxpc3RcblxuXG4gIF9yZWFkTGlzdEl0ZW0odG9rZW4pIHtcbiAgICB2YXIgaXRlbSA9IG51bGwsXG4gICAgICAgIC8vIFRoZSBpdGVtIG9mIHRoZSBsaXN0XG4gICAgbGlzdCA9IG51bGwsXG4gICAgICAgIC8vIFRoZSBsaXN0IGl0c2VsZlxuICAgIHByZXZpb3VzTGlzdCA9IHRoaXMuX3N1YmplY3QsXG4gICAgICAgIC8vIFRoZSBwcmV2aW91cyBsaXN0IHRoYXQgY29udGFpbnMgdGhpcyBsaXN0XG4gICAgc3RhY2sgPSB0aGlzLl9jb250ZXh0U3RhY2ssXG4gICAgICAgIC8vIFRoZSBzdGFjayBvZiBwYXJlbnQgY29udGV4dHNcbiAgICBwYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXSxcbiAgICAgICAgLy8gVGhlIHBhcmVudCBjb250YWluaW5nIHRoZSBjdXJyZW50IGxpc3RcbiAgICBuZXh0ID0gdGhpcy5fcmVhZExpc3RJdGVtOyAvLyBUaGUgbmV4dCBmdW5jdGlvbiB0byBleGVjdXRlXG5cbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICAvLyBTdGFjayB0aGUgY3VycmVudCBsaXN0IHF1YWQgYW5kIHN0YXJ0IGEgbmV3IHF1YWQgd2l0aCBhIGJsYW5rIG5vZGUgYXMgc3ViamVjdFxuICAgICAgICB0aGlzLl9zYXZlQ29udGV4dCgnYmxhbmsnLCB0aGlzLl9ncmFwaCwgbGlzdCA9IHRoaXMuX2JsYW5rTm9kZSgpLCB0aGlzLlJERl9GSVJTVCwgdGhpcy5fc3ViamVjdCA9IGl0ZW0gPSB0aGlzLl9ibGFua05vZGUoKSk7XG5cbiAgICAgICAgbmV4dCA9IHRoaXMuX3JlYWRCbGFua05vZGVIZWFkO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKCc6XG4gICAgICAgIC8vIFN0YWNrIHRoZSBjdXJyZW50IGxpc3QgcXVhZCBhbmQgc3RhcnQgYSBuZXcgbGlzdFxuICAgICAgICB0aGlzLl9zYXZlQ29udGV4dCgnbGlzdCcsIHRoaXMuX2dyYXBoLCBsaXN0ID0gdGhpcy5fYmxhbmtOb2RlKCksIHRoaXMuUkRGX0ZJUlNULCB0aGlzLlJERl9OSUwpO1xuXG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIC8vIENsb3NpbmcgdGhlIGxpc3Q7IHJlc3RvcmUgdGhlIHBhcmVudCBjb250ZXh0XG4gICAgICAgIHRoaXMuX3Jlc3RvcmVDb250ZXh0KCk7IC8vIElmIHRoaXMgbGlzdCBpcyBjb250YWluZWQgd2l0aGluIGEgcGFyZW50IGxpc3QsIHJldHVybiB0aGUgbWVtYmVyc2hpcCBxdWFkIGhlcmUuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBgPHBhcmVudCBsaXN0IGVsZW1lbnQ+IHJkZjpmaXJzdCA8dGhpcyBsaXN0Pi5gLlxuXG5cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAhPT0gMCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXS50eXBlID09PSAnbGlzdCcpIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLCB0aGlzLl9vYmplY3QsIHRoaXMuX2dyYXBoKTsgLy8gV2FzIHRoaXMgbGlzdCB0aGUgcGFyZW50J3Mgc3ViamVjdD9cblxuICAgICAgICBpZiAodGhpcy5fcHJlZGljYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhlIG5leHQgdG9rZW4gaXMgdGhlIHByZWRpY2F0ZVxuICAgICAgICAgIG5leHQgPSB0aGlzLl9yZWFkUHJlZGljYXRlOyAvLyBObyBsaXN0IHRhaWwgaWYgdGhpcyB3YXMgYW4gZW1wdHkgbGlzdFxuXG4gICAgICAgICAgaWYgKHRoaXMuX3N1YmplY3QgPT09IHRoaXMuUkRGX05JTCkgcmV0dXJuIG5leHQ7XG4gICAgICAgIH0gLy8gVGhlIGxpc3Qgd2FzIGluIHRoZSBwYXJlbnQgY29udGV4dCdzIG9iamVjdFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHQgPSB0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCk7IC8vIE5vIGxpc3QgdGFpbCBpZiB0aGlzIHdhcyBhbiBlbXB0eSBsaXN0XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vYmplY3QgPT09IHRoaXMuUkRGX05JTCkgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfSAvLyBDbG9zZSB0aGUgbGlzdCBieSBtYWtpbmcgdGhlIGhlYWQgbmlsXG5cblxuICAgICAgICBsaXN0ID0gdGhpcy5SREZfTklMO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbGl0ZXJhbCc6XG4gICAgICAgIC8vIFJlZ3VsYXIgbGl0ZXJhbCwgY2FuIHN0aWxsIGdldCBhIGRhdGF0eXBlIG9yIGxhbmd1YWdlXG4gICAgICAgIGlmICh0b2tlbi5wcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fbGl0ZXJhbFZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgbmV4dCA9IHRoaXMuX3JlYWRMaXN0SXRlbURhdGFUeXBlT3JMYW5nO1xuICAgICAgICB9IC8vIFByZS1kYXRhdHlwZWQgc3RyaW5nIGxpdGVyYWwgKHByZWZpeCBzdG9yZXMgdGhlIGRhdGF0eXBlKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLl9saXRlcmFsKHRva2VuLnZhbHVlLCB0aGlzLl9uYW1lZE5vZGUodG9rZW4ucHJlZml4KSk7XG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneyc6XG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IGZvcm11bGFcbiAgICAgICAgaWYgKCF0aGlzLl9uM01vZGUpIHJldHVybiB0aGlzLl9lcnJvcignVW5leHBlY3RlZCBncmFwaCcsIHRva2VuKTtcblxuICAgICAgICB0aGlzLl9zYXZlQ29udGV4dCgnZm9ybXVsYScsIHRoaXMuX2dyYXBoLCB0aGlzLl9zdWJqZWN0LCB0aGlzLl9wcmVkaWNhdGUsIHRoaXMuX2dyYXBoID0gdGhpcy5fYmxhbmtOb2RlKCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkU3ViamVjdDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKChpdGVtID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICB9IC8vIENyZWF0ZSBhIG5ldyBibGFuayBub2RlIGlmIG5vIGl0ZW0gaGVhZCB3YXMgYXNzaWduZWQgeWV0XG5cblxuICAgIGlmIChsaXN0ID09PSBudWxsKSB0aGlzLl9zdWJqZWN0ID0gbGlzdCA9IHRoaXMuX2JsYW5rTm9kZSgpOyAvLyBJcyB0aGlzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0P1xuXG4gICAgaWYgKHByZXZpb3VzTGlzdCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBsaXN0IGlzIGVpdGhlciB0aGUgc3ViamVjdCBvciB0aGUgb2JqZWN0IG9mIGl0cyBwYXJlbnRcbiAgICAgIGlmIChwYXJlbnQucHJlZGljYXRlID09PSBudWxsKSBwYXJlbnQuc3ViamVjdCA9IGxpc3Q7ZWxzZSBwYXJlbnQub2JqZWN0ID0gbGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGludWUgdGhlIHByZXZpb3VzIGxpc3Qgd2l0aCB0aGUgY3VycmVudCBsaXN0XG4gICAgICB0aGlzLl9lbWl0KHByZXZpb3VzTGlzdCwgdGhpcy5SREZfUkVTVCwgbGlzdCwgdGhpcy5fZ3JhcGgpO1xuICAgIH0gLy8gSWYgYW4gaXRlbSB3YXMgcmVhZCwgYWRkIGl0IHRvIHRoZSBsaXN0XG5cblxuICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAvLyBJbiBOMyBtb2RlLCB0aGUgaXRlbSBtaWdodCBiZSBhIHBhdGhcbiAgICAgIGlmICh0aGlzLl9uM01vZGUgJiYgKHRva2VuLnR5cGUgPT09ICdJUkknIHx8IHRva2VuLnR5cGUgPT09ICdwcmVmaXhlZCcpKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb250ZXh0IHRvIGFkZCB0aGUgaXRlbSdzIHBhdGhcbiAgICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2l0ZW0nLCB0aGlzLl9ncmFwaCwgbGlzdCwgdGhpcy5SREZfRklSU1QsIGl0ZW0pO1xuXG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBpdGVtLCB0aGlzLl9wcmVkaWNhdGUgPSBudWxsOyAvLyBfcmVhZFBhdGggd2lsbCByZXN0b3JlIHRoZSBjb250ZXh0IGFuZCBvdXRwdXQgdGhlIGl0ZW1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UGF0aFJlYWRlcih0aGlzLl9yZWFkTGlzdEl0ZW0pO1xuICAgICAgfSAvLyBPdXRwdXQgdGhlIGl0ZW1cblxuXG4gICAgICB0aGlzLl9lbWl0KGxpc3QsIHRoaXMuUkRGX0ZJUlNULCBpdGVtLCB0aGlzLl9ncmFwaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH0gLy8gIyMjIGBfcmVhZERhdGFUeXBlT3JMYW5nYCByZWFkcyBhbiBfb3B0aW9uYWxfIGRhdGF0eXBlIG9yIGxhbmd1YWdlXG5cblxuICBfcmVhZERhdGFUeXBlT3JMYW5nKHRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBsZXRlT2JqZWN0TGl0ZXJhbCh0b2tlbiwgZmFsc2UpO1xuICB9IC8vICMjIyBgX3JlYWRMaXN0SXRlbURhdGFUeXBlT3JMYW5nYCByZWFkcyBhbiBfb3B0aW9uYWxfIGRhdGF0eXBlIG9yIGxhbmd1YWdlIGluIGEgbGlzdFxuXG5cbiAgX3JlYWRMaXN0SXRlbURhdGFUeXBlT3JMYW5nKHRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBsZXRlT2JqZWN0TGl0ZXJhbCh0b2tlbiwgdHJ1ZSk7XG4gIH0gLy8gIyMjIGBfY29tcGxldGVMaXRlcmFsYCBjb21wbGV0ZXMgYSBsaXRlcmFsIHdpdGggYW4gb3B0aW9uYWwgZGF0YXR5cGUgb3IgbGFuZ3VhZ2VcblxuXG4gIF9jb21wbGV0ZUxpdGVyYWwodG9rZW4pIHtcbiAgICAvLyBDcmVhdGUgYSBzaW1wbGUgc3RyaW5nIGxpdGVyYWwgYnkgZGVmYXVsdFxuICAgIGxldCBsaXRlcmFsID0gdGhpcy5fbGl0ZXJhbCh0aGlzLl9saXRlcmFsVmFsdWUpO1xuXG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAvLyBDcmVhdGUgYSBkYXRhdHlwZWQgbGl0ZXJhbFxuICAgICAgY2FzZSAndHlwZSc6XG4gICAgICBjYXNlICd0eXBlSVJJJzpcbiAgICAgICAgdmFyIGRhdGF0eXBlID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbik7XG5cbiAgICAgICAgaWYgKGRhdGF0eXBlID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gTm8gZGF0YXR5cGUgbWVhbnMgYW4gZXJyb3Igb2NjdXJyZWRcblxuICAgICAgICBsaXRlcmFsID0gdGhpcy5fbGl0ZXJhbCh0aGlzLl9saXRlcmFsVmFsdWUsIGRhdGF0eXBlKTtcbiAgICAgICAgdG9rZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIENyZWF0ZSBhIGxhbmd1YWdlLXRhZ2dlZCBzdHJpbmdcblxuICAgICAgY2FzZSAnbGFuZ2NvZGUnOlxuICAgICAgICBsaXRlcmFsID0gdGhpcy5fbGl0ZXJhbCh0aGlzLl9saXRlcmFsVmFsdWUsIHRva2VuLnZhbHVlKTtcbiAgICAgICAgdG9rZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBsaXRlcmFsXG4gICAgfTtcbiAgfSAvLyBDb21wbGV0ZXMgYSBsaXRlcmFsIGluIHN1YmplY3QgcG9zaXRpb25cblxuXG4gIF9jb21wbGV0ZVN1YmplY3RMaXRlcmFsKHRva2VuKSB7XG4gICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2NvbXBsZXRlTGl0ZXJhbCh0b2tlbikubGl0ZXJhbDtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaDtcbiAgfSAvLyBDb21wbGV0ZXMgYSBsaXRlcmFsIGluIG9iamVjdCBwb3NpdGlvblxuXG5cbiAgX2NvbXBsZXRlT2JqZWN0TGl0ZXJhbCh0b2tlbiwgbGlzdEl0ZW0pIHtcbiAgICBjb25zdCBjb21wbGV0ZWQgPSB0aGlzLl9jb21wbGV0ZUxpdGVyYWwodG9rZW4pO1xuXG4gICAgaWYgKCFjb21wbGV0ZWQpIHJldHVybjtcbiAgICB0aGlzLl9vYmplY3QgPSBjb21wbGV0ZWQubGl0ZXJhbDsgLy8gSWYgdGhpcyBsaXRlcmFsIHdhcyBwYXJ0IG9mIGEgbGlzdCwgd3JpdGUgdGhlIGl0ZW1cbiAgICAvLyAod2UgY291bGQgYWxzbyBjaGVjayB0aGUgY29udGV4dCBzdGFjaywgYnV0IHBhc3NpbmcgaW4gYSBmbGFnIGlzIGZhc3RlcilcblxuICAgIGlmIChsaXN0SXRlbSkgdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LCB0aGlzLlJERl9GSVJTVCwgdGhpcy5fb2JqZWN0LCB0aGlzLl9ncmFwaCk7IC8vIElmIHRoZSB0b2tlbiB3YXMgY29uc3VtZWQsIGNvbnRpbnVlIHdpdGggdGhlIHJlc3Qgb2YgdGhlIGlucHV0XG5cbiAgICBpZiAoY29tcGxldGVkLnRva2VuID09PSBudWxsKSByZXR1cm4gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpOyAvLyBPdGhlcndpc2UsIGNvbnN1bWUgdGhlIHRva2VuIG5vd1xuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZWFkQ2FsbGJhY2sgPSB0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkQ2FsbGJhY2soY29tcGxldGVkLnRva2VuKTtcbiAgICAgIH1cbiAgfSAvLyAjIyMgYF9yZWFkRm9ybXVsYVRhaWxgIHJlYWRzIHRoZSBlbmQgb2YgYSBmb3JtdWxhXG5cblxuICBfcmVhZEZvcm11bGFUYWlsKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd9JykgcmV0dXJuIHRoaXMuX3JlYWRQdW5jdHVhdGlvbih0b2tlbik7IC8vIFN0b3JlIHRoZSBsYXN0IHF1YWQgb2YgdGhlIGZvcm11bGFcblxuICAgIGlmICh0aGlzLl9zdWJqZWN0ICE9PSBudWxsKSB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSwgdGhpcy5fb2JqZWN0LCB0aGlzLl9ncmFwaCk7IC8vIFJlc3RvcmUgdGhlIHBhcmVudCBjb250ZXh0IGNvbnRhaW5pbmcgdGhpcyBmb3JtdWxhXG5cbiAgICB0aGlzLl9yZXN0b3JlQ29udGV4dCgpOyAvLyBJZiB0aGUgZm9ybXVsYSB3YXMgdGhlIHN1YmplY3QsIGNvbnRpbnVlIHJlYWRpbmcgdGhlIHByZWRpY2F0ZS5cbiAgICAvLyBJZiB0aGUgZm9ybXVsYSB3YXMgdGhlIG9iamVjdCwgcmVhZCBwdW5jdHVhdGlvbi5cblxuXG4gICAgcmV0dXJuIHRoaXMuX29iamVjdCA9PT0gbnVsbCA/IHRoaXMuX3JlYWRQcmVkaWNhdGUgOiB0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCk7XG4gIH0gLy8gIyMjIGBfcmVhZFB1bmN0dWF0aW9uYCByZWFkcyBwdW5jdHVhdGlvbiBiZXR3ZWVuIHF1YWRzIG9yIHF1YWQgcGFydHNcblxuXG4gIF9yZWFkUHVuY3R1YXRpb24odG9rZW4pIHtcbiAgICB2YXIgbmV4dCxcbiAgICAgICAgc3ViamVjdCA9IHRoaXMuX3N1YmplY3QsXG4gICAgICAgIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICAgIGludmVyc2VQcmVkaWNhdGUgPSB0aGlzLl9pbnZlcnNlUHJlZGljYXRlO1xuXG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAvLyBBIGNsb3NpbmcgYnJhY2UgZW5kcyBhIGdyYXBoXG4gICAgICBjYXNlICd9JzpcbiAgICAgICAgaWYgKHRoaXMuX2dyYXBoID09PSBudWxsKSByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuZXhwZWN0ZWQgZ3JhcGggY2xvc2luZycsIHRva2VuKTtcbiAgICAgICAgaWYgKHRoaXMuX24zTW9kZSkgcmV0dXJuIHRoaXMuX3JlYWRGb3JtdWxhVGFpbCh0b2tlbik7XG4gICAgICAgIHRoaXMuX2dyYXBoID0gbnVsbDtcbiAgICAgIC8vIEEgZG90IGp1c3QgZW5kcyB0aGUgc3RhdGVtZW50LCB3aXRob3V0IHNoYXJpbmcgYW55dGhpbmcgd2l0aCB0aGUgbmV4dFxuXG4gICAgICBjYXNlICcuJzpcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgICAgIG5leHQgPSB0aGlzLl9jb250ZXh0U3RhY2subGVuZ3RoID8gdGhpcy5fcmVhZFN1YmplY3QgOiB0aGlzLl9yZWFkSW5Ub3BDb250ZXh0O1xuICAgICAgICBpZiAoaW52ZXJzZVByZWRpY2F0ZSkgdGhpcy5faW52ZXJzZVByZWRpY2F0ZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFNlbWljb2xvbiBtZWFucyB0aGUgc3ViamVjdCBpcyBzaGFyZWQ7IHByZWRpY2F0ZSBhbmQgb2JqZWN0IGFyZSBkaWZmZXJlbnRcblxuICAgICAgY2FzZSAnOyc6XG4gICAgICAgIG5leHQgPSB0aGlzLl9yZWFkUHJlZGljYXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIENvbW1hIG1lYW5zIGJvdGggdGhlIHN1YmplY3QgYW5kIHByZWRpY2F0ZSBhcmUgc2hhcmVkOyB0aGUgb2JqZWN0IGlzIGRpZmZlcmVudFxuXG4gICAgICBjYXNlICcsJzpcbiAgICAgICAgbmV4dCA9IHRoaXMuX3JlYWRPYmplY3Q7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBBbiBlbnRpdHkgbWVhbnMgdGhpcyBpcyBhIHF1YWQgKG9ubHkgYWxsb3dlZCBpZiBub3QgYWxyZWFkeSBpbnNpZGUgYSBncmFwaClcbiAgICAgICAgaWYgKHRoaXMuX3N1cHBvcnRzUXVhZHMgJiYgdGhpcy5fZ3JhcGggPT09IG51bGwgJiYgKGdyYXBoID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXh0ID0gdGhpcy5fcmVhZFF1YWRQdW5jdHVhdGlvbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgcHVuY3R1YXRpb24gdG8gZm9sbG93IFwiJyArIHRoaXMuX29iamVjdC5pZCArICdcIicsIHRva2VuKTtcbiAgICB9IC8vIEEgcXVhZCBoYXMgYmVlbiBjb21wbGV0ZWQgbm93LCBzbyByZXR1cm4gaXRcblxuXG4gICAgaWYgKHN1YmplY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmVkaWNhdGUgPSB0aGlzLl9wcmVkaWNhdGUsXG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgICAgaWYgKCFpbnZlcnNlUHJlZGljYXRlKSB0aGlzLl9lbWl0KHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCk7ZWxzZSB0aGlzLl9lbWl0KG9iamVjdCwgcHJlZGljYXRlLCBzdWJqZWN0LCBncmFwaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH0gLy8gIyMjIGBfcmVhZEJsYW5rTm9kZVB1bmN0dWF0aW9uYCByZWFkcyBwdW5jdHVhdGlvbiBpbiBhIGJsYW5rIG5vZGVcblxuXG4gIF9yZWFkQmxhbmtOb2RlUHVuY3R1YXRpb24odG9rZW4pIHtcbiAgICB2YXIgbmV4dDtcblxuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgLy8gU2VtaWNvbG9uIG1lYW5zIHRoZSBzdWJqZWN0IGlzIHNoYXJlZDsgcHJlZGljYXRlIGFuZCBvYmplY3QgYXJlIGRpZmZlcmVudFxuICAgICAgY2FzZSAnOyc6XG4gICAgICAgIG5leHQgPSB0aGlzLl9yZWFkUHJlZGljYXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIENvbW1hIG1lYW5zIGJvdGggdGhlIHN1YmplY3QgYW5kIHByZWRpY2F0ZSBhcmUgc2hhcmVkOyB0aGUgb2JqZWN0IGlzIGRpZmZlcmVudFxuXG4gICAgICBjYXNlICcsJzpcbiAgICAgICAgbmV4dCA9IHRoaXMuX3JlYWRPYmplY3Q7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIHB1bmN0dWF0aW9uIHRvIGZvbGxvdyBcIicgKyB0aGlzLl9vYmplY3QuaWQgKyAnXCInLCB0b2tlbik7XG4gICAgfSAvLyBBIHF1YWQgaGFzIGJlZW4gY29tcGxldGVkIG5vdywgc28gcmV0dXJuIGl0XG5cblxuICAgIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLCB0aGlzLl9vYmplY3QsIHRoaXMuX2dyYXBoKTtcblxuICAgIHJldHVybiBuZXh0O1xuICB9IC8vICMjIyBgX3JlYWRRdWFkUHVuY3R1YXRpb25gIHJlYWRzIHB1bmN0dWF0aW9uIGFmdGVyIGEgcXVhZFxuXG5cbiAgX3JlYWRRdWFkUHVuY3R1YXRpb24odG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJy4nKSByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIGRvdCB0byBmb2xsb3cgcXVhZCcsIHRva2VuKTtcbiAgICByZXR1cm4gdGhpcy5fcmVhZEluVG9wQ29udGV4dDtcbiAgfSAvLyAjIyMgYF9yZWFkUHJlZml4YCByZWFkcyB0aGUgcHJlZml4IG9mIGEgcHJlZml4IGRlY2xhcmF0aW9uXG5cblxuICBfcmVhZFByZWZpeCh0b2tlbikge1xuICAgIGlmICh0b2tlbi50eXBlICE9PSAncHJlZml4JykgcmV0dXJuIHRoaXMuX2Vycm9yKCdFeHBlY3RlZCBwcmVmaXggdG8gZm9sbG93IEBwcmVmaXgnLCB0b2tlbik7XG4gICAgdGhpcy5fcHJlZml4ID0gdG9rZW4udmFsdWU7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQcmVmaXhJUkk7XG4gIH0gLy8gIyMjIGBfcmVhZFByZWZpeElSSWAgcmVhZHMgdGhlIElSSSBvZiBhIHByZWZpeCBkZWNsYXJhdGlvblxuXG5cbiAgX3JlYWRQcmVmaXhJUkkodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ0lSSScpIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgSVJJIHRvIGZvbGxvdyBwcmVmaXggXCInICsgdGhpcy5fcHJlZml4ICsgJzpcIicsIHRva2VuKTtcblxuICAgIHZhciBwcmVmaXhOb2RlID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbik7XG5cbiAgICB0aGlzLl9wcmVmaXhlc1t0aGlzLl9wcmVmaXhdID0gcHJlZml4Tm9kZS52YWx1ZTtcblxuICAgIHRoaXMuX3ByZWZpeENhbGxiYWNrKHRoaXMuX3ByZWZpeCwgcHJlZml4Tm9kZSk7XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZERlY2xhcmF0aW9uUHVuY3R1YXRpb247XG4gIH0gLy8gIyMjIGBfcmVhZEJhc2VJUklgIHJlYWRzIHRoZSBJUkkgb2YgYSBiYXNlIGRlY2xhcmF0aW9uXG5cblxuICBfcmVhZEJhc2VJUkkodG9rZW4pIHtcbiAgICB2YXIgaXJpID0gdG9rZW4udHlwZSA9PT0gJ0lSSScgJiYgdGhpcy5fcmVzb2x2ZUlSSSh0b2tlbi52YWx1ZSk7XG5cbiAgICBpZiAoIWlyaSkgcmV0dXJuIHRoaXMuX2Vycm9yKCdFeHBlY3RlZCB2YWxpZCBJUkkgdG8gZm9sbG93IGJhc2UgZGVjbGFyYXRpb24nLCB0b2tlbik7XG5cbiAgICB0aGlzLl9zZXRCYXNlKGlyaSk7XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZERlY2xhcmF0aW9uUHVuY3R1YXRpb247XG4gIH0gLy8gIyMjIGBfcmVhZE5hbWVkR3JhcGhMYWJlbGAgcmVhZHMgdGhlIGxhYmVsIG9mIGEgbmFtZWQgZ3JhcGhcblxuXG4gIF9yZWFkTmFtZWRHcmFwaExhYmVsKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlICdJUkknOlxuICAgICAgY2FzZSAnYmxhbmsnOlxuICAgICAgY2FzZSAncHJlZml4ZWQnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3QodG9rZW4pLCB0aGlzLl9yZWFkR3JhcGg7XG5cbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE5hbWVkR3JhcGhCbGFua0xhYmVsO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0ludmFsaWQgZ3JhcGggbGFiZWwnLCB0b2tlbik7XG4gICAgfVxuICB9IC8vICMjIyBgX3JlYWROYW1lZEdyYXBoTGFiZWxgIHJlYWRzIGEgYmxhbmsgbm9kZSBsYWJlbCBvZiBhIG5hbWVkIGdyYXBoXG5cblxuICBfcmVhZE5hbWVkR3JhcGhCbGFua0xhYmVsKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICddJykgcmV0dXJuIHRoaXMuX2Vycm9yKCdJbnZhbGlkIGdyYXBoIGxhYmVsJywgdG9rZW4pO1xuICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLl9ibGFua05vZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcmVhZEdyYXBoO1xuICB9IC8vICMjIyBgX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9uYCByZWFkcyB0aGUgcHVuY3R1YXRpb24gb2YgYSBkZWNsYXJhdGlvblxuXG5cbiAgX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9uKHRva2VuKSB7XG4gICAgLy8gU1BBUlFMLXN0eWxlIGRlY2xhcmF0aW9ucyBkb24ndCBoYXZlIHB1bmN0dWF0aW9uXG4gICAgaWYgKHRoaXMuX3NwYXJxbFN0eWxlKSB7XG4gICAgICB0aGlzLl9zcGFycWxTdHlsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRJblRvcENvbnRleHQodG9rZW4pO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlICE9PSAnLicpIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgZGVjbGFyYXRpb24gdG8gZW5kIHdpdGggYSBkb3QnLCB0b2tlbik7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRJblRvcENvbnRleHQ7XG4gIH0gLy8gUmVhZHMgYSBsaXN0IG9mIHF1YW50aWZpZWQgc3ltYm9scyBmcm9tIGEgQGZvclNvbWUgb3IgQGZvckFsbCBzdGF0ZW1lbnRcblxuXG4gIF9yZWFkUXVhbnRpZmllckxpc3QodG9rZW4pIHtcbiAgICB2YXIgZW50aXR5O1xuXG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlICdJUkknOlxuICAgICAgY2FzZSAncHJlZml4ZWQnOlxuICAgICAgICBpZiAoKGVudGl0eSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4sIHRydWUpKSAhPT0gdW5kZWZpbmVkKSBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkICcgKyB0b2tlbi50eXBlLCB0b2tlbik7XG4gICAgfSAvLyBXaXRob3V0IGV4cGxpY2l0IHF1YW50aWZpZXJzLCBtYXAgZW50aXRpZXMgdG8gYSBxdWFudGlmaWVkIGVudGl0eVxuXG5cbiAgICBpZiAoIXRoaXMuX2V4cGxpY2l0UXVhbnRpZmllcnMpIHRoaXMuX3F1YW50aWZpZWRbZW50aXR5LmlkXSA9IHRoaXMuX3F1YW50aWZpZXIodGhpcy5fYmxhbmtOb2RlKCkudmFsdWUpOyAvLyBXaXRoIGV4cGxpY2l0IHF1YW50aWZpZXJzLCBvdXRwdXQgdGhlIHJlaWZpZWQgcXVhbnRpZmllclxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBpdGVtLCBzdGFydCBhIG5ldyBxdWFudGlmaWVyIGxpc3RcbiAgICAgICAgaWYgKHRoaXMuX3N1YmplY3QgPT09IG51bGwpIHRoaXMuX2VtaXQodGhpcy5fZ3JhcGggfHwgdGhpcy5ERUZBVUxUR1JBUEgsIHRoaXMuX3ByZWRpY2F0ZSwgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2JsYW5rTm9kZSgpLCB0aGlzLlFVQU5USUZJRVJTX0dSQVBIKTsgLy8gT3RoZXJ3aXNlLCBjb250aW51ZSB0aGUgcHJldmlvdXMgbGlzdFxuICAgICAgICBlbHNlIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5SREZfUkVTVCwgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2JsYW5rTm9kZSgpLCB0aGlzLlFVQU5USUZJRVJTX0dSQVBIKTsgLy8gT3V0cHV0IHRoZSBsaXN0IGl0ZW1cblxuICAgICAgICB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuUkRGX0ZJUlNULCBlbnRpdHksIHRoaXMuUVVBTlRJRklFUlNfR1JBUEgpO1xuICAgICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkUXVhbnRpZmllclB1bmN0dWF0aW9uO1xuICB9IC8vIFJlYWRzIHB1bmN0dWF0aW9uIGZyb20gYSBAZm9yU29tZSBvciBAZm9yQWxsIHN0YXRlbWVudFxuXG5cbiAgX3JlYWRRdWFudGlmaWVyUHVuY3R1YXRpb24odG9rZW4pIHtcbiAgICAvLyBSZWFkIG1vcmUgcXVhbnRpZmllcnNcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJywnKSByZXR1cm4gdGhpcy5fcmVhZFF1YW50aWZpZXJMaXN0OyAvLyBFbmQgb2YgdGhlIHF1YW50aWZpZXIgbGlzdFxuICAgIGVsc2Uge1xuICAgICAgICAvLyBXaXRoIGV4cGxpY2l0IHF1YW50aWZpZXJzLCBjbG9zZSB0aGUgcXVhbnRpZmllciBsaXN0XG4gICAgICAgIGlmICh0aGlzLl9leHBsaWNpdFF1YW50aWZpZXJzKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LCB0aGlzLlJERl9SRVNULCB0aGlzLlJERl9OSUwsIHRoaXMuUVVBTlRJRklFUlNfR1JBUEgpO1xuXG4gICAgICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgICAgIH0gLy8gUmVhZCBhIGRvdFxuXG5cbiAgICAgICAgdGhpcy5fcmVhZENhbGxiYWNrID0gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZENhbGxiYWNrKHRva2VuKTtcbiAgICAgIH1cbiAgfSAvLyAjIyMgYF9nZXRQYXRoUmVhZGVyYCByZWFkcyBhIHBvdGVudGlhbCBwYXRoIGFuZCB0aGVuIHJlc3VtZXMgd2l0aCB0aGUgZ2l2ZW4gZnVuY3Rpb25cblxuXG4gIF9nZXRQYXRoUmVhZGVyKGFmdGVyUGF0aCkge1xuICAgIHRoaXMuX2FmdGVyUGF0aCA9IGFmdGVyUGF0aDtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFBhdGg7XG4gIH0gLy8gIyMjIGBfcmVhZFBhdGhgIHJlYWRzIGEgcG90ZW50aWFsIHBhdGhcblxuXG4gIF9yZWFkUGF0aCh0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgLy8gRm9yd2FyZCBwYXRoXG4gICAgICBjYXNlICchJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRGb3J3YXJkUGF0aDtcbiAgICAgIC8vIEJhY2t3YXJkIHBhdGhcblxuICAgICAgY2FzZSAnXic6XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkQmFja3dhcmRQYXRoO1xuICAgICAgLy8gTm90IGEgcGF0aDsgcmVzdW1lIHJlYWRpbmcgd2hlcmUgd2UgbGVmdCBvZmZcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5fY29udGV4dFN0YWNrLFxuICAgICAgICAgICAgcGFyZW50ID0gc3RhY2subGVuZ3RoICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdOyAvLyBJZiB3ZSB3ZXJlIHJlYWRpbmcgYSBsaXN0IGl0ZW0sIHdlIHN0aWxsIG5lZWQgdG8gb3V0cHV0IGl0XG5cbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gJ2l0ZW0nKSB7XG4gICAgICAgICAgLy8gVGhlIGxpc3QgaXRlbSBpcyB0aGUgcmVtYWluaW5nIHN1YmVqY3QgYWZ0ZXIgcmVhZGluZyB0aGUgcGF0aFxuICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fc3ViamVjdDsgLy8gU3dpdGNoIGJhY2sgdG8gdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RcblxuICAgICAgICAgIHRoaXMuX3Jlc3RvcmVDb250ZXh0KCk7IC8vIE91dHB1dCB0aGUgbGlzdCBpdGVtXG5cblxuICAgICAgICAgIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5SREZfRklSU1QsIGl0ZW0sIHRoaXMuX2dyYXBoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9hZnRlclBhdGgodG9rZW4pO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9yZWFkRm9yd2FyZFBhdGhgIHJlYWRzIGEgJyEnIHBhdGhcblxuXG4gIF9yZWFkRm9yd2FyZFBhdGgodG9rZW4pIHtcbiAgICB2YXIgc3ViamVjdCxcbiAgICAgICAgcHJlZGljYXRlLFxuICAgICAgICBvYmplY3QgPSB0aGlzLl9ibGFua05vZGUoKTsgLy8gVGhlIG5leHQgdG9rZW4gaXMgdGhlIHByZWRpY2F0ZVxuXG5cbiAgICBpZiAoKHByZWRpY2F0ZSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIElmIHdlIHdlcmUgcmVhZGluZyBhIHN1YmplY3QsIHJlcGxhY2UgdGhlIHN1YmplY3QgYnkgdGhlIHBhdGgncyBvYmplY3RcblxuICAgIGlmICh0aGlzLl9wcmVkaWNhdGUgPT09IG51bGwpIHN1YmplY3QgPSB0aGlzLl9zdWJqZWN0LCB0aGlzLl9zdWJqZWN0ID0gb2JqZWN0OyAvLyBJZiB3ZSB3ZXJlIHJlYWRpbmcgYW4gb2JqZWN0LCByZXBsYWNlIHRoZSBzdWJqZWN0IGJ5IHRoZSBwYXRoJ3Mgb2JqZWN0XG4gICAgZWxzZSBzdWJqZWN0ID0gdGhpcy5fb2JqZWN0LCB0aGlzLl9vYmplY3QgPSBvYmplY3Q7IC8vIEVtaXQgdGhlIHBhdGgncyBjdXJyZW50IHF1YWQgYW5kIHJlYWQgaXRzIG5leHQgc2VjdGlvblxuXG4gICAgdGhpcy5fZW1pdChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgdGhpcy5fZ3JhcGgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQYXRoO1xuICB9IC8vICMjIyBgX3JlYWRCYWNrd2FyZFBhdGhgIHJlYWRzIGEgJ14nIHBhdGhcblxuXG4gIF9yZWFkQmFja3dhcmRQYXRoKHRva2VuKSB7XG4gICAgdmFyIHN1YmplY3QgPSB0aGlzLl9ibGFua05vZGUoKSxcbiAgICAgICAgcHJlZGljYXRlLFxuICAgICAgICBvYmplY3Q7IC8vIFRoZSBuZXh0IHRva2VuIGlzIHRoZSBwcmVkaWNhdGVcblxuXG4gICAgaWYgKChwcmVkaWNhdGUgPSB0aGlzLl9yZWFkRW50aXR5KHRva2VuKSkgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBJZiB3ZSB3ZXJlIHJlYWRpbmcgYSBzdWJqZWN0LCByZXBsYWNlIHRoZSBzdWJqZWN0IGJ5IHRoZSBwYXRoJ3Mgc3ViamVjdFxuXG4gICAgaWYgKHRoaXMuX3ByZWRpY2F0ZSA9PT0gbnVsbCkgb2JqZWN0ID0gdGhpcy5fc3ViamVjdCwgdGhpcy5fc3ViamVjdCA9IHN1YmplY3Q7IC8vIElmIHdlIHdlcmUgcmVhZGluZyBhbiBvYmplY3QsIHJlcGxhY2UgdGhlIHN1YmplY3QgYnkgdGhlIHBhdGgncyBzdWJqZWN0XG4gICAgZWxzZSBvYmplY3QgPSB0aGlzLl9vYmplY3QsIHRoaXMuX29iamVjdCA9IHN1YmplY3Q7IC8vIEVtaXQgdGhlIHBhdGgncyBjdXJyZW50IHF1YWQgYW5kIHJlYWQgaXRzIG5leHQgc2VjdGlvblxuXG4gICAgdGhpcy5fZW1pdChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgdGhpcy5fZ3JhcGgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQYXRoO1xuICB9IC8vICMjIyBgX3JlYWRSREZTdGFyVGFpbE9yR3JhcGhgIHJlYWRzIHRoZSBncmFwaCBvZiBhIG5lc3RlZCBSREYqIHF1YWQgb3IgdGhlIGVuZCBvZiBhIG5lc3RlZCBSREYqIHRyaXBsZVxuXG5cbiAgX3JlYWRSREZTdGFyVGFpbE9yR3JhcGgodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJz4+Jykge1xuICAgICAgLy8gQW4gZW50aXR5IG1lYW5zIHRoaXMgaXMgYSBxdWFkIChvbmx5IGFsbG93ZWQgaWYgbm90IGFscmVhZHkgaW5zaWRlIGEgZ3JhcGgpXG4gICAgICBpZiAodGhpcy5fc3VwcG9ydHNRdWFkcyAmJiB0aGlzLl9ncmFwaCA9PT0gbnVsbCAmJiAodGhpcy5fZ3JhcGggPSB0aGlzLl9yZWFkRW50aXR5KHRva2VuKSkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX3JlYWRSREZTdGFyVGFpbDtcbiAgICAgIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgPj4gdG8gZm9sbG93IFwiJyArIHRoaXMuX29iamVjdC5pZCArICdcIicsIHRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZFJERlN0YXJUYWlsKHRva2VuKTtcbiAgfSAvLyAjIyMgYF9yZWFkUkRGU3RhclRhaWxgIHJlYWRzIHRoZSBlbmQgb2YgYSBuZXN0ZWQgUkRGKiB0cmlwbGVcblxuXG4gIF9yZWFkUkRGU3RhclRhaWwodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJz4+JykgcmV0dXJuIHRoaXMuX2Vycm9yKGBFeHBlY3RlZCA+PiBidXQgZ290ICR7dG9rZW4udHlwZX1gLCB0b2tlbik7IC8vIFJlYWQgdGhlIHF1YWQgYW5kIHJlc3RvcmUgdGhlIHByZXZpb3VzIGNvbnRleHRcblxuICAgIGNvbnN0IHF1YWQgPSB0aGlzLl9xdWFkKHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSwgdGhpcy5fb2JqZWN0LCB0aGlzLl9ncmFwaCB8fCB0aGlzLkRFRkFVTFRHUkFQSCk7XG5cbiAgICB0aGlzLl9yZXN0b3JlQ29udGV4dCgpOyAvLyBJZiB0aGUgdHJpcGxlIHdhcyB0aGUgc3ViamVjdCwgY29udGludWUgYnkgcmVhZGluZyB0aGUgcHJlZGljYXRlLlxuXG5cbiAgICBpZiAodGhpcy5fc3ViamVjdCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fc3ViamVjdCA9IHF1YWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFByZWRpY2F0ZTtcbiAgICB9IC8vIElmIHRoZSB0cmlwbGUgd2FzIHRoZSBvYmplY3QsIHJlYWQgY29udGV4dCBlbmQuXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX29iamVjdCA9IHF1YWQ7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCk7XG4gICAgICB9XG4gIH0gLy8gIyMjIGBfZ2V0Q29udGV4dEVuZFJlYWRlcmAgZ2V0cyB0aGUgbmV4dCByZWFkZXIgZnVuY3Rpb24gYXQgdGhlIGVuZCBvZiBhIGNvbnRleHRcblxuXG4gIF9nZXRDb250ZXh0RW5kUmVhZGVyKCkge1xuICAgIHZhciBjb250ZXh0U3RhY2sgPSB0aGlzLl9jb250ZXh0U3RhY2s7XG4gICAgaWYgKCFjb250ZXh0U3RhY2subGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVhZFB1bmN0dWF0aW9uO1xuXG4gICAgc3dpdGNoIChjb250ZXh0U3RhY2tbY29udGV4dFN0YWNrLmxlbmd0aCAtIDFdLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRCbGFua05vZGVUYWlsO1xuXG4gICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRMaXN0SXRlbTtcblxuICAgICAgY2FzZSAnZm9ybXVsYSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkRm9ybXVsYVRhaWw7XG5cbiAgICAgIGNhc2UgJzw8JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRSREZTdGFyVGFpbE9yR3JhcGg7XG4gICAgfVxuICB9IC8vICMjIyBgX2VtaXRgIHNlbmRzIGEgcXVhZCB0aHJvdWdoIHRoZSBjYWxsYmFja1xuXG5cbiAgX2VtaXQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sobnVsbCwgdGhpcy5fcXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGggfHwgdGhpcy5ERUZBVUxUR1JBUEgpKTtcbiAgfSAvLyAjIyMgYF9lcnJvcmAgZW1pdHMgYW4gZXJyb3IgbWVzc2FnZSB0aHJvdWdoIHRoZSBjYWxsYmFja1xuXG5cbiAgX2Vycm9yKG1lc3NhZ2UsIHRva2VuKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlICsgJyBvbiBsaW5lICcgKyB0b2tlbi5saW5lICsgJy4nKTtcbiAgICBlcnIuY29udGV4dCA9IHtcbiAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgIGxpbmU6IHRva2VuLmxpbmUsXG4gICAgICBwcmV2aW91c1Rva2VuOiB0aGlzLl9sZXhlci5wcmV2aW91c1Rva2VuXG4gICAgfTtcblxuICAgIHRoaXMuX2NhbGxiYWNrKGVycik7XG5cbiAgICB0aGlzLl9jYWxsYmFjayA9IG5vb3A7XG4gIH0gLy8gIyMjIGBfcmVzb2x2ZUlSSWAgcmVzb2x2ZXMgYW4gSVJJIGFnYWluc3QgdGhlIGJhc2UgcGF0aFxuXG5cbiAgX3Jlc29sdmVJUkkoaXJpKSB7XG4gICAgcmV0dXJuIC9eW2Etel1bYS16MC05Ky4tXSo6L2kudGVzdChpcmkpID8gaXJpIDogdGhpcy5fcmVzb2x2ZVJlbGF0aXZlSVJJKGlyaSk7XG4gIH0gLy8gIyMjIGBfcmVzb2x2ZVJlbGF0aXZlSVJJYCByZXNvbHZlcyBhbiBJUkkgYWdhaW5zdCB0aGUgYmFzZSBwYXRoLFxuICAvLyBhc3N1bWluZyB0aGF0IGEgYmFzZSBwYXRoIGhhcyBiZWVuIHNldCBhbmQgdGhhdCB0aGUgSVJJIGlzIGluZGVlZCByZWxhdGl2ZVxuXG5cbiAgX3Jlc29sdmVSZWxhdGl2ZUlSSShpcmkpIHtcbiAgICAvLyBBbiBlbXB0eSByZWxhdGl2ZSBJUkkgaW5kaWNhdGVzIHRoZSBiYXNlIElSSVxuICAgIGlmICghaXJpLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2Jhc2U7IC8vIERlY2lkZSByZXNvbHZpbmcgc3RyYXRlZ3kgYmFzZWQgaW4gdGhlIGZpcnN0IGNoYXJhY3RlclxuXG4gICAgc3dpdGNoIChpcmlbMF0pIHtcbiAgICAgIC8vIFJlc29sdmUgcmVsYXRpdmUgZnJhZ21lbnQgSVJJcyBhZ2FpbnN0IHRoZSBiYXNlIElSSVxuICAgICAgY2FzZSAnIyc6XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXNlICsgaXJpO1xuICAgICAgLy8gUmVzb2x2ZSByZWxhdGl2ZSBxdWVyeSBzdHJpbmcgSVJJcyBieSByZXBsYWNpbmcgdGhlIHF1ZXJ5IHN0cmluZ1xuXG4gICAgICBjYXNlICc/JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2UucmVwbGFjZSgvKD86XFw/LiopPyQvLCBpcmkpO1xuICAgICAgLy8gUmVzb2x2ZSByb290LXJlbGF0aXZlIElSSXMgYXQgdGhlIHJvb3Qgb2YgdGhlIGJhc2UgSVJJXG5cbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICAvLyBSZXNvbHZlIHNjaGVtZS1yZWxhdGl2ZSBJUklzIHRvIHRoZSBzY2hlbWVcbiAgICAgICAgcmV0dXJuIChpcmlbMV0gPT09ICcvJyA/IHRoaXMuX2Jhc2VTY2hlbWUgOiB0aGlzLl9iYXNlUm9vdCkgKyB0aGlzLl9yZW1vdmVEb3RTZWdtZW50cyhpcmkpO1xuICAgICAgLy8gUmVzb2x2ZSBhbGwgb3RoZXIgSVJJcyBhdCB0aGUgYmFzZSBJUkkncyBwYXRoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFJlbGF0aXZlIElSSXMgY2Fubm90IGNvbnRhaW4gYSBjb2xvbiBpbiB0aGUgZmlyc3QgcGF0aCBzZWdtZW50XG4gICAgICAgIHJldHVybiAvXlteLzpdKjovLnRlc3QoaXJpKSA/IG51bGwgOiB0aGlzLl9yZW1vdmVEb3RTZWdtZW50cyh0aGlzLl9iYXNlUGF0aCArIGlyaSk7XG4gICAgfVxuICB9IC8vICMjIyBgX3JlbW92ZURvdFNlZ21lbnRzYCByZXNvbHZlcyAnLi8nIGFuZCAnLi4vJyBwYXRoIHNlZ21lbnRzIGluIGFuIElSSSBhcyBwZXIgUkZDMzk4NlxuXG5cbiAgX3JlbW92ZURvdFNlZ21lbnRzKGlyaSkge1xuICAgIC8vIERvbid0IG1vZGlmeSB0aGUgSVJJIGlmIGl0IGRvZXMgbm90IGNvbnRhaW4gYW55IGRvdCBzZWdtZW50c1xuICAgIGlmICghLyhefFxcLylcXC5cXC4/KCR8Wy8jP10pLy50ZXN0KGlyaSkpIHJldHVybiBpcmk7IC8vIFN0YXJ0IHdpdGggYW4gaW1hZ2luYXJ5IHNsYXNoIGJlZm9yZSB0aGUgSVJJIGluIG9yZGVyIHRvIHJlc29sdmUgdHJhaWxpbmcgJy4vJyBhbmQgJy4uLydcblxuICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgbGVuZ3RoID0gaXJpLmxlbmd0aCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBwYXRoU3RhcnQgPSAtMSxcbiAgICAgICAgc2VnbWVudFN0YXJ0ID0gMCxcbiAgICAgICAgbmV4dCA9ICcvJztcblxuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKG5leHQpIHtcbiAgICAgICAgLy8gVGhlIHBhdGggc3RhcnRzIHdpdGggdGhlIGZpcnN0IHNsYXNoIGFmdGVyIHRoZSBhdXRob3JpdHlcbiAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgaWYgKHBhdGhTdGFydCA8IDApIHtcbiAgICAgICAgICAgIC8vIFNraXAgdHdvIHNsYXNoZXMgYmVmb3JlIHRoZSBhdXRob3JpdHlcbiAgICAgICAgICAgIGlmIChpcmlbKytpXSA9PT0gJy8nICYmIGlyaVsrK2ldID09PSAnLycpIC8vIFNraXAgdG8gc2xhc2ggYWZ0ZXIgdGhlIGF1dGhvcml0eVxuICAgICAgICAgICAgICB3aGlsZSAoKHBhdGhTdGFydCA9IGkgKyAxKSA8IGxlbmd0aCAmJiBpcmlbcGF0aFN0YXJ0XSAhPT0gJy8nKSBpID0gcGF0aFN0YXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBEb24ndCBtb2RpZnkgYSBxdWVyeSBzdHJpbmcgb3IgZnJhZ21lbnRcblxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgaSA9IGxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSGFuZGxlICcvLicgb3IgJy8uLicgcGF0aCBzZWdtZW50c1xuXG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgIGlmIChpcmlbaSArIDFdID09PSAnLicpIHtcbiAgICAgICAgICAgIG5leHQgPSBpcmlbKytpICsgMV07XG5cbiAgICAgICAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgYSAnLy4nIHNlZ21lbnRcbiAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGlyaS5zdWJzdHJpbmcoc2VnbWVudFN0YXJ0LCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgc2VnbWVudFN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBhIHRyYWlsaW5nICcvLicgc2VnbWVudFxuXG4gICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIGlyaS5zdWJzdHJpbmcoc2VnbWVudFN0YXJ0LCBpKSArIGlyaS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgYSAnLy4uJyBzZWdtZW50XG5cbiAgICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgbmV4dCA9IGlyaVsrK2kgKyAxXTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSB1bmRlZmluZWQgfHwgbmV4dCA9PT0gJy8nIHx8IG5leHQgPT09ICc/JyB8fCBuZXh0ID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBpcmkuc3Vic3RyaW5nKHNlZ21lbnRTdGFydCwgaSAtIDIpOyAvLyBUcnkgdG8gcmVtb3ZlIHRoZSBwYXJlbnQgcGF0aCBmcm9tIHJlc3VsdFxuXG4gICAgICAgICAgICAgICAgICBpZiAoKHNlZ21lbnRTdGFydCA9IHJlc3VsdC5sYXN0SW5kZXhPZignLycpKSA+PSBwYXRoU3RhcnQpIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHIoMCwgc2VnbWVudFN0YXJ0KTsgLy8gUmVtb3ZlIGEgdHJhaWxpbmcgJy8uLicgc2VnbWVudFxuXG4gICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gJy8nKSByZXR1cm4gcmVzdWx0ICsgJy8nICsgaXJpLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICAgICAgICBzZWdtZW50U3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgbmV4dCA9IGlyaVsrK2ldO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgKyBpcmkuc3Vic3RyaW5nKHNlZ21lbnRTdGFydCk7XG4gIH0gLy8gIyMgUHVibGljIG1ldGhvZHNcbiAgLy8gIyMjIGBwYXJzZWAgcGFyc2VzIHRoZSBOMyBpbnB1dCBhbmQgZW1pdHMgZWFjaCBwYXJzZWQgcXVhZCB0aHJvdWdoIHRoZSBjYWxsYmFja1xuXG5cbiAgcGFyc2UoaW5wdXQsIHF1YWRDYWxsYmFjaywgcHJlZml4Q2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIFRoZSByZWFkIGNhbGxiYWNrIGlzIHRoZSBuZXh0IGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gYSB0b2tlbiBhcnJpdmVzLlxuICAgIC8vIFdlIHN0YXJ0IHJlYWRpbmcgaW4gdGhlIHRvcCBjb250ZXh0LlxuXG4gICAgdGhpcy5fcmVhZENhbGxiYWNrID0gdGhpcy5fcmVhZEluVG9wQ29udGV4dDtcbiAgICB0aGlzLl9zcGFycWxTdHlsZSA9IGZhbHNlO1xuICAgIHRoaXMuX3ByZWZpeGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9wcmVmaXhlcy5fID0gdGhpcy5fYmxhbmtOb2RlUHJlZml4ID8gdGhpcy5fYmxhbmtOb2RlUHJlZml4LnN1YnN0cigyKSA6ICdiJyArIGJsYW5rTm9kZVByZWZpeCsrICsgJ18nO1xuICAgIHRoaXMuX3ByZWZpeENhbGxiYWNrID0gcHJlZml4Q2FsbGJhY2sgfHwgbm9vcDtcbiAgICB0aGlzLl9pbnZlcnNlUHJlZGljYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcXVhbnRpZmllZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIFBhcnNlIHN5bmNocm9ub3VzbHkgaWYgbm8gcXVhZCBjYWxsYmFjayBpcyBnaXZlblxuXG4gICAgaWYgKCFxdWFkQ2FsbGJhY2spIHtcbiAgICAgIHZhciBxdWFkcyA9IFtdLFxuICAgICAgICAgIGVycm9yO1xuXG4gICAgICB0aGlzLl9jYWxsYmFjayA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGUgPyBlcnJvciA9IGUgOiB0ICYmIHF1YWRzLnB1c2godCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCkuZXZlcnkoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZWFkQ2FsbGJhY2sgPSBzZWxmLl9yZWFkQ2FsbGJhY2sodG9rZW4pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICByZXR1cm4gcXVhZHM7XG4gICAgfSAvLyBQYXJzZSBhc3luY2hyb25vdXNseSBvdGhlcndpc2UsIGV4ZWN1dGluZyB0aGUgcmVhZCBjYWxsYmFjayB3aGVuIGEgdG9rZW4gYXJyaXZlc1xuXG5cbiAgICB0aGlzLl9jYWxsYmFjayA9IHF1YWRDYWxsYmFjaztcblxuICAgIHRoaXMuX2xleGVyLnRva2VuaXplKGlucHV0LCBmdW5jdGlvbiAoZXJyb3IsIHRva2VuKSB7XG4gICAgICBpZiAoZXJyb3IgIT09IG51bGwpIHNlbGYuX2NhbGxiYWNrKGVycm9yKSwgc2VsZi5fY2FsbGJhY2sgPSBub29wO2Vsc2UgaWYgKHNlbGYuX3JlYWRDYWxsYmFjaykgc2VsZi5fcmVhZENhbGxiYWNrID0gc2VsZi5fcmVhZENhbGxiYWNrKHRva2VuKTtcbiAgICB9KTtcbiAgfVxuXG59IC8vIFRoZSBlbXB0eSBmdW5jdGlvblxuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IE4zUGFyc2VyO1xuXG5mdW5jdGlvbiBub29wKCkge30gLy8gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciB3aXRoIHRoZSBnaXZlbiBkYXRhIGZhY3RvcnlcblxuXG5mdW5jdGlvbiBpbml0RGF0YUZhY3RvcnkocGFyc2VyLCBmYWN0b3J5KSB7XG4gIC8vIFNldCBmYWN0b3J5IG1ldGhvZHNcbiAgdmFyIG5hbWVkTm9kZSA9IGZhY3RvcnkubmFtZWROb2RlO1xuICBwYXJzZXIuX25hbWVkTm9kZSA9IG5hbWVkTm9kZTtcbiAgcGFyc2VyLl9ibGFua05vZGUgPSBmYWN0b3J5LmJsYW5rTm9kZTtcbiAgcGFyc2VyLl9saXRlcmFsID0gZmFjdG9yeS5saXRlcmFsO1xuICBwYXJzZXIuX3ZhcmlhYmxlID0gZmFjdG9yeS52YXJpYWJsZTtcbiAgcGFyc2VyLl9xdWFkID0gZmFjdG9yeS5xdWFkO1xuICBwYXJzZXIuREVGQVVMVEdSQVBIID0gZmFjdG9yeS5kZWZhdWx0R3JhcGgoKTsgLy8gU2V0IGNvbW1vbiBuYW1lZCBub2Rlc1xuXG4gIHBhcnNlci5SREZfRklSU1QgPSBuYW1lZE5vZGUoX0lSSXMuZGVmYXVsdC5yZGYuZmlyc3QpO1xuICBwYXJzZXIuUkRGX1JFU1QgPSBuYW1lZE5vZGUoX0lSSXMuZGVmYXVsdC5yZGYucmVzdCk7XG4gIHBhcnNlci5SREZfTklMID0gbmFtZWROb2RlKF9JUklzLmRlZmF1bHQucmRmLm5pbCk7XG4gIHBhcnNlci5OM19GT1JBTEwgPSBuYW1lZE5vZGUoX0lSSXMuZGVmYXVsdC5yLmZvckFsbCk7XG4gIHBhcnNlci5OM19GT1JTT01FID0gbmFtZWROb2RlKF9JUklzLmRlZmF1bHQuci5mb3JTb21lKTtcbiAgcGFyc2VyLkFCQlJFVklBVElPTlMgPSB7XG4gICAgJ2EnOiBuYW1lZE5vZGUoX0lSSXMuZGVmYXVsdC5yZGYudHlwZSksXG4gICAgJz0nOiBuYW1lZE5vZGUoX0lSSXMuZGVmYXVsdC5vd2wuc2FtZUFzKSxcbiAgICAnPic6IG5hbWVkTm9kZShfSVJJcy5kZWZhdWx0LmxvZy5pbXBsaWVzKVxuICB9O1xuICBwYXJzZXIuUVVBTlRJRklFUlNfR1JBUEggPSBuYW1lZE5vZGUoJ3VybjpuMzpxdWFudGlmaWVycycpO1xufVxuXG5pbml0RGF0YUZhY3RvcnkoTjNQYXJzZXIucHJvdG90eXBlLCBfTjNEYXRhRmFjdG9yeS5kZWZhdWx0KTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9OM0RhdGFGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vTjNEYXRhRmFjdG9yeVwiKSk7XG5cbnZhciBfcmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpO1xuXG52YXIgX0lSSXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0lSSXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLy8gKipOM1N0b3JlKiogb2JqZWN0cyBzdG9yZSBOMyBxdWFkcyBieSBncmFwaCBpbiBtZW1vcnkuXG4vLyAjIyBDb25zdHJ1Y3RvclxuY2xhc3MgTjNTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKHF1YWRzLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIG51bWJlciBvZiBxdWFkcyBpcyBpbml0aWFsbHkgemVyb1xuICAgIHRoaXMuX3NpemUgPSAwOyAvLyBgX2dyYXBoc2AgY29udGFpbnMgc3ViamVjdCwgcHJlZGljYXRlLCBhbmQgb2JqZWN0IGluZGV4ZXMgcGVyIGdyYXBoXG5cbiAgICB0aGlzLl9ncmFwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBgX2lkc2AgbWFwcyBlbnRpdGllcyBzdWNoIGFzIGBodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xL25hbWVgIHRvIG51bWJlcnMsXG4gICAgLy8gc2F2aW5nIG1lbW9yeSBieSB1c2luZyBvbmx5IG51bWJlcnMgYXMga2V5cyBpbiBgX2dyYXBoc2BcblxuICAgIHRoaXMuX2lkID0gMDtcbiAgICB0aGlzLl9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2lkc1snPjwnXSA9IDA7IC8vIGR1bW15IGVudHJ5LCBzbyB0aGUgZmlyc3QgYWN0dWFsIGtleSBpcyBub24temVyb1xuXG4gICAgdGhpcy5fZW50aXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBpbnZlcnNlIG9mIGBfaWRzYFxuICAgIC8vIGBfYmxhbmtOb2RlSW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBhdXRvbWF0aWNhbGx5IG5hbWVkIGJsYW5rIG5vZGVcblxuICAgIHRoaXMuX2JsYW5rTm9kZUluZGV4ID0gMDsgLy8gU2hpZnQgcGFyYW1ldGVycyBpZiBgcXVhZHNgIGlzIG5vdCBnaXZlblxuXG4gICAgaWYgKCFvcHRpb25zICYmIHF1YWRzICYmICFxdWFkc1swXSkgb3B0aW9ucyA9IHF1YWRzLCBxdWFkcyA9IG51bGw7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fZmFjdG9yeSA9IG9wdGlvbnMuZmFjdG9yeSB8fCBfTjNEYXRhRmFjdG9yeS5kZWZhdWx0OyAvLyBBZGQgcXVhZHMgaWYgcGFzc2VkXG5cbiAgICBpZiAocXVhZHMpIHRoaXMuYWRkUXVhZHMocXVhZHMpO1xuICB9IC8vICMjIFB1YmxpYyBwcm9wZXJ0aWVzXG4gIC8vICMjIyBgc2l6ZWAgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHF1YWRzIGluIHRoZSBzdG9yZVxuXG5cbiAgZ2V0IHNpemUoKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBxdWFkIGNvdW50IGlmIGlmIHdhcyBjYWNoZWRcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgaWYgKHNpemUgIT09IG51bGwpIHJldHVybiBzaXplOyAvLyBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBxdWFkcyBieSBjb3VudGluZyB0byB0aGUgZGVlcGVzdCBsZXZlbFxuXG4gICAgc2l6ZSA9IDA7XG4gICAgdmFyIGdyYXBocyA9IHRoaXMuX2dyYXBocyxcbiAgICAgICAgc3ViamVjdHMsXG4gICAgICAgIHN1YmplY3Q7XG5cbiAgICBmb3IgKHZhciBncmFwaEtleSBpbiBncmFwaHMpIGZvciAodmFyIHN1YmplY3RLZXkgaW4gc3ViamVjdHMgPSBncmFwaHNbZ3JhcGhLZXldLnN1YmplY3RzKSBmb3IgKHZhciBwcmVkaWNhdGVLZXkgaW4gc3ViamVjdCA9IHN1YmplY3RzW3N1YmplY3RLZXldKSBzaXplICs9IE9iamVjdC5rZXlzKHN1YmplY3RbcHJlZGljYXRlS2V5XSkubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3NpemUgPSBzaXplO1xuICB9IC8vICMjIFByaXZhdGUgbWV0aG9kc1xuICAvLyAjIyMgYF9hZGRUb0luZGV4YCBhZGRzIGEgcXVhZCB0byBhIHRocmVlLWxheWVyZWQgaW5kZXguXG4gIC8vIFJldHVybnMgaWYgdGhlIGluZGV4IGhhcyBjaGFuZ2VkLCBpZiB0aGUgZW50cnkgZGlkIG5vdCBhbHJlYWR5IGV4aXN0LlxuXG5cbiAgX2FkZFRvSW5kZXgoaW5kZXgwLCBrZXkwLCBrZXkxLCBrZXkyKSB7XG4gICAgLy8gQ3JlYXRlIGxheWVycyBhcyBuZWNlc3NhcnlcbiAgICB2YXIgaW5kZXgxID0gaW5kZXgwW2tleTBdIHx8IChpbmRleDBba2V5MF0gPSB7fSk7XG4gICAgdmFyIGluZGV4MiA9IGluZGV4MVtrZXkxXSB8fCAoaW5kZXgxW2tleTFdID0ge30pOyAvLyBTZXR0aW5nIHRoZSBrZXkgdG8gX2FueV8gdmFsdWUgc2lnbmFscyB0aGUgcHJlc2VuY2Ugb2YgdGhlIHF1YWRcblxuICAgIHZhciBleGlzdGVkID0gKGtleTIgaW4gaW5kZXgyKTtcbiAgICBpZiAoIWV4aXN0ZWQpIGluZGV4MltrZXkyXSA9IG51bGw7XG4gICAgcmV0dXJuICFleGlzdGVkO1xuICB9IC8vICMjIyBgX3JlbW92ZUZyb21JbmRleGAgcmVtb3ZlcyBhIHF1YWQgZnJvbSBhIHRocmVlLWxheWVyZWQgaW5kZXhcblxuXG4gIF9yZW1vdmVGcm9tSW5kZXgoaW5kZXgwLCBrZXkwLCBrZXkxLCBrZXkyKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBxdWFkIGZyb20gdGhlIGluZGV4XG4gICAgdmFyIGluZGV4MSA9IGluZGV4MFtrZXkwXSxcbiAgICAgICAgaW5kZXgyID0gaW5kZXgxW2tleTFdLFxuICAgICAgICBrZXk7XG4gICAgZGVsZXRlIGluZGV4MltrZXkyXTsgLy8gUmVtb3ZlIGludGVybWVkaWFyeSBpbmRleCBsYXllcnMgaWYgdGhleSBhcmUgZW1wdHlcblxuICAgIGZvciAoa2V5IGluIGluZGV4MikgcmV0dXJuO1xuXG4gICAgZGVsZXRlIGluZGV4MVtrZXkxXTtcblxuICAgIGZvciAoa2V5IGluIGluZGV4MSkgcmV0dXJuO1xuXG4gICAgZGVsZXRlIGluZGV4MFtrZXkwXTtcbiAgfSAvLyAjIyMgYF9maW5kSW5JbmRleGAgZmluZHMgYSBzZXQgb2YgcXVhZHMgaW4gYSB0aHJlZS1sYXllcmVkIGluZGV4LlxuICAvLyBUaGUgaW5kZXggYmFzZSBpcyBgaW5kZXgwYCBhbmQgdGhlIGtleXMgYXQgZWFjaCBsZXZlbCBhcmUgYGtleTBgLCBga2V5MWAsIGFuZCBga2V5MmAuXG4gIC8vIEFueSBvZiB0aGVzZSBrZXlzIGNhbiBiZSB1bmRlZmluZWQsIHdoaWNoIGlzIGludGVycHJldGVkIGFzIGEgd2lsZGNhcmQuXG4gIC8vIGBuYW1lMGAsIGBuYW1lMWAsIGFuZCBgbmFtZTJgIGFyZSB0aGUgbmFtZXMgb2YgdGhlIGtleXMgYXQgZWFjaCBsZXZlbCxcbiAgLy8gdXNlZCB3aGVuIHJlY29uc3RydWN0aW5nIHRoZSByZXN1bHRpbmcgcXVhZFxuICAvLyAoZm9yIGluc3RhbmNlOiBfc3ViamVjdF8sIF9wcmVkaWNhdGVfLCBhbmQgX29iamVjdF8pLlxuICAvLyBGaW5hbGx5LCBgZ3JhcGhgIHdpbGwgYmUgdGhlIGdyYXBoIG9mIHRoZSBjcmVhdGVkIHF1YWRzLlxuICAvLyBJZiBgY2FsbGJhY2tgIGlzIGdpdmVuLCBlYWNoIHJlc3VsdCBpcyBwYXNzZWQgdGhyb3VnaCBpdFxuICAvLyBhbmQgaXRlcmF0aW9uIGhhbHRzIHdoZW4gaXQgcmV0dXJucyB0cnV0aHkgZm9yIGFueSBxdWFkLlxuICAvLyBJZiBpbnN0ZWFkIGBhcnJheWAgaXMgZ2l2ZW4sIGVhY2ggcmVzdWx0IGlzIGFkZGVkIHRvIHRoZSBhcnJheS5cblxuXG4gIF9maW5kSW5JbmRleChpbmRleDAsIGtleTAsIGtleTEsIGtleTIsIG5hbWUwLCBuYW1lMSwgbmFtZTIsIGdyYXBoLCBjYWxsYmFjaywgYXJyYXkpIHtcbiAgICB2YXIgdG1wLFxuICAgICAgICBpbmRleDEsXG4gICAgICAgIGluZGV4MixcbiAgICAgICAgdmFyQ291bnQgPSAha2V5MCArICFrZXkxICsgIWtleTIsXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgbnVtYmVyIG9mIHZhcmlhYmxlcywga2V5cyBvciByZXZlcnNlIGluZGV4IGFyZSBmYXN0ZXJcbiAgICBlbnRpdHlLZXlzID0gdmFyQ291bnQgPiAxID8gT2JqZWN0LmtleXModGhpcy5faWRzKSA6IHRoaXMuX2VudGl0aWVzOyAvLyBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHVzZSBvbmx5IHRoYXQgcGFydCBvZiBpbmRleCAwLlxuXG4gICAgaWYgKGtleTApICh0bXAgPSBpbmRleDAsIGluZGV4MCA9IHt9KVtrZXkwXSA9IHRtcFtrZXkwXTtcblxuICAgIGZvciAodmFyIHZhbHVlMCBpbiBpbmRleDApIHtcbiAgICAgIHZhciBlbnRpdHkwID0gZW50aXR5S2V5c1t2YWx1ZTBdO1xuXG4gICAgICBpZiAoaW5kZXgxID0gaW5kZXgwW3ZhbHVlMF0pIHtcbiAgICAgICAgLy8gSWYgYSBrZXkgaXMgc3BlY2lmaWVkLCB1c2Ugb25seSB0aGF0IHBhcnQgb2YgaW5kZXggMS5cbiAgICAgICAgaWYgKGtleTEpICh0bXAgPSBpbmRleDEsIGluZGV4MSA9IHt9KVtrZXkxXSA9IHRtcFtrZXkxXTtcblxuICAgICAgICBmb3IgKHZhciB2YWx1ZTEgaW4gaW5kZXgxKSB7XG4gICAgICAgICAgdmFyIGVudGl0eTEgPSBlbnRpdHlLZXlzW3ZhbHVlMV07XG5cbiAgICAgICAgICBpZiAoaW5kZXgyID0gaW5kZXgxW3ZhbHVlMV0pIHtcbiAgICAgICAgICAgIC8vIElmIGEga2V5IGlzIHNwZWNpZmllZCwgdXNlIG9ubHkgdGhhdCBwYXJ0IG9mIGluZGV4IDIsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBrZXkyID8ga2V5MiBpbiBpbmRleDIgPyBba2V5Ml0gOiBbXSA6IE9iamVjdC5rZXlzKGluZGV4Mik7IC8vIENyZWF0ZSBxdWFkcyBmb3IgYWxsIGl0ZW1zIGZvdW5kIGluIGluZGV4IDIuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdmFsdWVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0OiBudWxsLFxuICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IG51bGxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcGFydHNbbmFtZTBdID0gKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Gcm9tSWQpKGVudGl0eTAsIHRoaXMuX2ZhY3RvcnkpO1xuICAgICAgICAgICAgICBwYXJ0c1tuYW1lMV0gPSAoMCwgX04zRGF0YUZhY3RvcnkudGVybUZyb21JZCkoZW50aXR5MSwgdGhpcy5fZmFjdG9yeSk7XG4gICAgICAgICAgICAgIHBhcnRzW25hbWUyXSA9ICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtRnJvbUlkKShlbnRpdHlLZXlzW3ZhbHVlc1tsXV0sIHRoaXMuX2ZhY3RvcnkpO1xuXG4gICAgICAgICAgICAgIHZhciBxdWFkID0gdGhpcy5fZmFjdG9yeS5xdWFkKHBhcnRzLnN1YmplY3QsIHBhcnRzLnByZWRpY2F0ZSwgcGFydHMub2JqZWN0LCAoMCwgX04zRGF0YUZhY3RvcnkudGVybUZyb21JZCkoZ3JhcGgsIHRoaXMuX2ZhY3RvcnkpKTtcblxuICAgICAgICAgICAgICBpZiAoYXJyYXkpIGFycmF5LnB1c2gocXVhZCk7ZWxzZSBpZiAoY2FsbGJhY2socXVhZCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfSAvLyAjIyMgYF9sb29wYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gYWxsIGtleXMgb2YgaW5kZXggMFxuXG5cbiAgX2xvb3AoaW5kZXgwLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGtleTAgaW4gaW5kZXgwKSBjYWxsYmFjayhrZXkwKTtcbiAgfSAvLyAjIyMgYF9sb29wQnlLZXkwYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gYWxsIGtleXMgb2YgYSBjZXJ0YWluIGVudHJ5IGluIGluZGV4IDBcblxuXG4gIF9sb29wQnlLZXkwKGluZGV4MCwga2V5MCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW5kZXgxLCBrZXkxO1xuXG4gICAgaWYgKGluZGV4MSA9IGluZGV4MFtrZXkwXSkge1xuICAgICAgZm9yIChrZXkxIGluIGluZGV4MSkgY2FsbGJhY2soa2V5MSk7XG4gICAgfVxuICB9IC8vICMjIyBgX2xvb3BCeUtleTFgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBnaXZlbiBrZXlzIG9mIGFsbCBlbnRyaWVzIGluIGluZGV4IDBcblxuXG4gIF9sb29wQnlLZXkxKGluZGV4MCwga2V5MSwgY2FsbGJhY2spIHtcbiAgICB2YXIga2V5MCwgaW5kZXgxO1xuXG4gICAgZm9yIChrZXkwIGluIGluZGV4MCkge1xuICAgICAgaW5kZXgxID0gaW5kZXgwW2tleTBdO1xuICAgICAgaWYgKGluZGV4MVtrZXkxXSkgY2FsbGJhY2soa2V5MCk7XG4gICAgfVxuICB9IC8vICMjIyBgX2xvb3BCeTJLZXlzYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gZ2l2ZW4ga2V5cyBvZiBjZXJ0YWluIGVudHJpZXMgaW4gaW5kZXggMlxuXG5cbiAgX2xvb3BCeTJLZXlzKGluZGV4MCwga2V5MCwga2V5MSwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW5kZXgxLCBpbmRleDIsIGtleTI7XG5cbiAgICBpZiAoKGluZGV4MSA9IGluZGV4MFtrZXkwXSkgJiYgKGluZGV4MiA9IGluZGV4MVtrZXkxXSkpIHtcbiAgICAgIGZvciAoa2V5MiBpbiBpbmRleDIpIGNhbGxiYWNrKGtleTIpO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9jb3VudEluSW5kZXhgIGNvdW50cyBtYXRjaGluZyBxdWFkcyBpbiBhIHRocmVlLWxheWVyZWQgaW5kZXguXG4gIC8vIFRoZSBpbmRleCBiYXNlIGlzIGBpbmRleDBgIGFuZCB0aGUga2V5cyBhdCBlYWNoIGxldmVsIGFyZSBga2V5MGAsIGBrZXkxYCwgYW5kIGBrZXkyYC5cbiAgLy8gQW55IG9mIHRoZXNlIGtleXMgY2FuIGJlIHVuZGVmaW5lZCwgd2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgYSB3aWxkY2FyZC5cblxuXG4gIF9jb3VudEluSW5kZXgoaW5kZXgwLCBrZXkwLCBrZXkxLCBrZXkyKSB7XG4gICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgdG1wLFxuICAgICAgICBpbmRleDEsXG4gICAgICAgIGluZGV4MjsgLy8gSWYgYSBrZXkgaXMgc3BlY2lmaWVkLCBjb3VudCBvbmx5IHRoYXQgcGFydCBvZiBpbmRleCAwXG5cbiAgICBpZiAoa2V5MCkgKHRtcCA9IGluZGV4MCwgaW5kZXgwID0ge30pW2tleTBdID0gdG1wW2tleTBdO1xuXG4gICAgZm9yICh2YXIgdmFsdWUwIGluIGluZGV4MCkge1xuICAgICAgaWYgKGluZGV4MSA9IGluZGV4MFt2YWx1ZTBdKSB7XG4gICAgICAgIC8vIElmIGEga2V5IGlzIHNwZWNpZmllZCwgY291bnQgb25seSB0aGF0IHBhcnQgb2YgaW5kZXggMVxuICAgICAgICBpZiAoa2V5MSkgKHRtcCA9IGluZGV4MSwgaW5kZXgxID0ge30pW2tleTFdID0gdG1wW2tleTFdO1xuXG4gICAgICAgIGZvciAodmFyIHZhbHVlMSBpbiBpbmRleDEpIHtcbiAgICAgICAgICBpZiAoaW5kZXgyID0gaW5kZXgxW3ZhbHVlMV0pIHtcbiAgICAgICAgICAgIC8vIElmIGEga2V5IGlzIHNwZWNpZmllZCwgY291bnQgdGhlIHF1YWQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBpZiAoa2V5Mikga2V5MiBpbiBpbmRleDIgJiYgY291bnQrKzsgLy8gT3RoZXJ3aXNlLCBjb3VudCBhbGwgcXVhZHNcbiAgICAgICAgICAgIGVsc2UgY291bnQgKz0gT2JqZWN0LmtleXMoaW5kZXgyKS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9IC8vICMjIyBgX2dldEdyYXBoc2AgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBnaXZlbiBncmFwaCxcbiAgLy8gb3IgYWxsIGdyYXBocyBpZiB0aGUgYXJndW1lbnQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG5cblxuICBfZ2V0R3JhcGhzKGdyYXBoKSB7XG4gICAgaWYgKCFpc1N0cmluZyhncmFwaCkpIHJldHVybiB0aGlzLl9ncmFwaHM7XG4gICAgdmFyIGdyYXBocyA9IHt9O1xuICAgIGdyYXBoc1tncmFwaF0gPSB0aGlzLl9ncmFwaHNbZ3JhcGhdO1xuICAgIHJldHVybiBncmFwaHM7XG4gIH0gLy8gIyMjIGBfdW5pcXVlRW50aXRpZXNgIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYW4gZW50aXR5IElEXG4gIC8vIGFuZCBwYXNzZXMgdGhlIGNvcnJlc3BvbmRpbmcgZW50aXR5IHRvIGNhbGxiYWNrIGlmIGl0IGhhc24ndCBvY2N1cnJlZCBiZWZvcmUuXG5cblxuICBfdW5pcXVlRW50aXRpZXMoY2FsbGJhY2spIHtcbiAgICB2YXIgdW5pcXVlSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgZW50aXRpZXMgPSB0aGlzLl9lbnRpdGllcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoIShpZCBpbiB1bmlxdWVJZHMpKSB7XG4gICAgICAgIHVuaXF1ZUlkc1tpZF0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjaygoMCwgX04zRGF0YUZhY3RvcnkudGVybUZyb21JZCkoZW50aXRpZXNbaWRdKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSAvLyAjIyBQdWJsaWMgbWV0aG9kc1xuICAvLyAjIyMgYGFkZFF1YWRgIGFkZHMgYSBuZXcgcXVhZCB0byB0aGUgc3RvcmUuXG4gIC8vIFJldHVybnMgaWYgdGhlIHF1YWQgaW5kZXggaGFzIGNoYW5nZWQsIGlmIHRoZSBxdWFkIGRpZCBub3QgYWxyZWFkeSBleGlzdC5cblxuXG4gIGFkZFF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgLy8gU2hpZnQgYXJndW1lbnRzIGlmIGEgcXVhZCBvYmplY3QgaXMgZ2l2ZW4gaW5zdGVhZCBvZiBjb21wb25lbnRzXG4gICAgaWYgKCFwcmVkaWNhdGUpIGdyYXBoID0gc3ViamVjdC5ncmFwaCwgb2JqZWN0ID0gc3ViamVjdC5vYmplY3QsIHByZWRpY2F0ZSA9IHN1YmplY3QucHJlZGljYXRlLCBzdWJqZWN0ID0gc3ViamVjdC5zdWJqZWN0OyAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuXG4gICAgc3ViamVjdCA9ICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoc3ViamVjdCk7XG4gICAgcHJlZGljYXRlID0gKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShwcmVkaWNhdGUpO1xuICAgIG9iamVjdCA9ICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkob2JqZWN0KTtcbiAgICBncmFwaCA9ICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoZ3JhcGgpOyAvLyBGaW5kIHRoZSBncmFwaCB0aGF0IHdpbGwgY29udGFpbiB0aGUgdHJpcGxlXG5cbiAgICB2YXIgZ3JhcGhJdGVtID0gdGhpcy5fZ3JhcGhzW2dyYXBoXTsgLy8gQ3JlYXRlIHRoZSBncmFwaCBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldFxuXG4gICAgaWYgKCFncmFwaEl0ZW0pIHtcbiAgICAgIGdyYXBoSXRlbSA9IHRoaXMuX2dyYXBoc1tncmFwaF0gPSB7XG4gICAgICAgIHN1YmplY3RzOiB7fSxcbiAgICAgICAgcHJlZGljYXRlczoge30sXG4gICAgICAgIG9iamVjdHM6IHt9XG4gICAgICB9OyAvLyBGcmVlemluZyBhIGdyYXBoIGhlbHBzIHN1YnNlcXVlbnQgYGFkZGAgcGVyZm9ybWFuY2UsXG4gICAgICAvLyBhbmQgcHJvcGVydGllcyB3aWxsIG5ldmVyIGJlIG1vZGlmaWVkIGFueXdheVxuXG4gICAgICBPYmplY3QuZnJlZXplKGdyYXBoSXRlbSk7XG4gICAgfSAvLyBTaW5jZSBlbnRpdGllcyBjYW4gb2Z0ZW4gYmUgbG9uZyBJUklzLCB3ZSBhdm9pZCBzdG9yaW5nIHRoZW0gaW4gZXZlcnkgaW5kZXguXG4gICAgLy8gSW5zdGVhZCwgd2UgaGF2ZSBhIHNlcGFyYXRlIGluZGV4IHRoYXQgbWFwcyBlbnRpdGllcyB0byBudW1iZXJzLFxuICAgIC8vIHdoaWNoIGFyZSB0aGVuIHVzZWQgYXMga2V5cyBpbiB0aGUgb3RoZXIgaW5kZXhlcy5cblxuXG4gICAgdmFyIGlkcyA9IHRoaXMuX2lkcztcbiAgICB2YXIgZW50aXRpZXMgPSB0aGlzLl9lbnRpdGllcztcbiAgICBzdWJqZWN0ID0gaWRzW3N1YmplY3RdIHx8IChpZHNbZW50aXRpZXNbKyt0aGlzLl9pZF0gPSBzdWJqZWN0XSA9IHRoaXMuX2lkKTtcbiAgICBwcmVkaWNhdGUgPSBpZHNbcHJlZGljYXRlXSB8fCAoaWRzW2VudGl0aWVzWysrdGhpcy5faWRdID0gcHJlZGljYXRlXSA9IHRoaXMuX2lkKTtcbiAgICBvYmplY3QgPSBpZHNbb2JqZWN0XSB8fCAoaWRzW2VudGl0aWVzWysrdGhpcy5faWRdID0gb2JqZWN0XSA9IHRoaXMuX2lkKTtcblxuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fYWRkVG9JbmRleChncmFwaEl0ZW0uc3ViamVjdHMsIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KTtcblxuICAgIHRoaXMuX2FkZFRvSW5kZXgoZ3JhcGhJdGVtLnByZWRpY2F0ZXMsIHByZWRpY2F0ZSwgb2JqZWN0LCBzdWJqZWN0KTtcblxuICAgIHRoaXMuX2FkZFRvSW5kZXgoZ3JhcGhJdGVtLm9iamVjdHMsIG9iamVjdCwgc3ViamVjdCwgcHJlZGljYXRlKTsgLy8gVGhlIGNhY2hlZCBxdWFkIGNvdW50IGlzIG5vdyBpbnZhbGlkXG5cblxuICAgIHRoaXMuX3NpemUgPSBudWxsO1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9IC8vICMjIyBgYWRkUXVhZHNgIGFkZHMgbXVsdGlwbGUgcXVhZHMgdG8gdGhlIHN0b3JlXG5cblxuICBhZGRRdWFkcyhxdWFkcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVhZHMubGVuZ3RoOyBpKyspIHRoaXMuYWRkUXVhZChxdWFkc1tpXSk7XG4gIH0gLy8gIyMjIGBpbXBvcnRgIGFkZHMgYSBzdHJlYW0gb2YgcXVhZHMgdG8gdGhlIHN0b3JlXG5cblxuICBpbXBvcnQoc3RyZWFtKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChxdWFkKSB7XG4gICAgICBzZWxmLmFkZFF1YWQocXVhZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfSAvLyAjIyMgYHJlbW92ZVF1YWRgIHJlbW92ZXMgYSBxdWFkIGZyb20gdGhlIHN0b3JlIGlmIGl0IGV4aXN0c1xuXG5cbiAgcmVtb3ZlUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAvLyBTaGlmdCBhcmd1bWVudHMgaWYgYSBxdWFkIG9iamVjdCBpcyBnaXZlbiBpbnN0ZWFkIG9mIGNvbXBvbmVudHNcbiAgICBpZiAoIXByZWRpY2F0ZSkgZ3JhcGggPSBzdWJqZWN0LmdyYXBoLCBvYmplY3QgPSBzdWJqZWN0Lm9iamVjdCwgcHJlZGljYXRlID0gc3ViamVjdC5wcmVkaWNhdGUsIHN1YmplY3QgPSBzdWJqZWN0LnN1YmplY3Q7IC8vIENvbnZlcnQgdGVybXMgdG8gaW50ZXJuYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG5cbiAgICBzdWJqZWN0ID0gKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShzdWJqZWN0KTtcbiAgICBwcmVkaWNhdGUgPSAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKHByZWRpY2F0ZSk7XG4gICAgb2JqZWN0ID0gKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShvYmplY3QpO1xuICAgIGdyYXBoID0gKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShncmFwaCk7IC8vIEZpbmQgaW50ZXJuYWwgaWRlbnRpZmllcnMgZm9yIGFsbCBjb21wb25lbnRzXG4gICAgLy8gYW5kIHZlcmlmeSB0aGUgcXVhZCBleGlzdHMuXG5cbiAgICB2YXIgZ3JhcGhJdGVtLFxuICAgICAgICBpZHMgPSB0aGlzLl9pZHMsXG4gICAgICAgIGdyYXBocyA9IHRoaXMuX2dyYXBocyxcbiAgICAgICAgc3ViamVjdHMsXG4gICAgICAgIHByZWRpY2F0ZXM7XG4gICAgaWYgKCEoc3ViamVjdCA9IGlkc1tzdWJqZWN0XSkgfHwgIShwcmVkaWNhdGUgPSBpZHNbcHJlZGljYXRlXSkgfHwgIShvYmplY3QgPSBpZHNbb2JqZWN0XSkgfHwgIShncmFwaEl0ZW0gPSBncmFwaHNbZ3JhcGhdKSB8fCAhKHN1YmplY3RzID0gZ3JhcGhJdGVtLnN1YmplY3RzW3N1YmplY3RdKSB8fCAhKHByZWRpY2F0ZXMgPSBzdWJqZWN0c1twcmVkaWNhdGVdKSB8fCAhKG9iamVjdCBpbiBwcmVkaWNhdGVzKSkgcmV0dXJuIGZhbHNlOyAvLyBSZW1vdmUgaXQgZnJvbSBhbGwgaW5kZXhlc1xuXG4gICAgdGhpcy5fcmVtb3ZlRnJvbUluZGV4KGdyYXBoSXRlbS5zdWJqZWN0cywgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuXG4gICAgdGhpcy5fcmVtb3ZlRnJvbUluZGV4KGdyYXBoSXRlbS5wcmVkaWNhdGVzLCBwcmVkaWNhdGUsIG9iamVjdCwgc3ViamVjdCk7XG5cbiAgICB0aGlzLl9yZW1vdmVGcm9tSW5kZXgoZ3JhcGhJdGVtLm9iamVjdHMsIG9iamVjdCwgc3ViamVjdCwgcHJlZGljYXRlKTtcblxuICAgIGlmICh0aGlzLl9zaXplICE9PSBudWxsKSB0aGlzLl9zaXplLS07IC8vIFJlbW92ZSB0aGUgZ3JhcGggaWYgaXQgaXMgZW1wdHlcblxuICAgIGZvciAoc3ViamVjdCBpbiBncmFwaEl0ZW0uc3ViamVjdHMpIHJldHVybiB0cnVlO1xuXG4gICAgZGVsZXRlIGdyYXBoc1tncmFwaF07XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gIyMjIGByZW1vdmVRdWFkc2AgcmVtb3ZlcyBtdWx0aXBsZSBxdWFkcyBmcm9tIHRoZSBzdG9yZVxuXG5cbiAgcmVtb3ZlUXVhZHMocXVhZHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1YWRzLmxlbmd0aDsgaSsrKSB0aGlzLnJlbW92ZVF1YWQocXVhZHNbaV0pO1xuICB9IC8vICMjIyBgcmVtb3ZlYCByZW1vdmVzIGEgc3RyZWFtIG9mIHF1YWRzIGZyb20gdGhlIHN0b3JlXG5cblxuICByZW1vdmUoc3RyZWFtKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChxdWFkKSB7XG4gICAgICBzZWxmLnJlbW92ZVF1YWQocXVhZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfSAvLyAjIyMgYHJlbW92ZU1hdGNoZXNgIHJlbW92ZXMgYWxsIG1hdGNoaW5nIHF1YWRzIGZyb20gdGhlIHN0b3JlXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIHJlbW92ZU1hdGNoZXMoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlKHRoaXMubWF0Y2goc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSk7XG4gIH0gLy8gIyMjIGBkZWxldGVHcmFwaGAgcmVtb3ZlcyBhbGwgdHJpcGxlcyB3aXRoIHRoZSBnaXZlbiBncmFwaCBmcm9tIHRoZSBzdG9yZVxuXG5cbiAgZGVsZXRlR3JhcGgoZ3JhcGgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVNYXRjaGVzKG51bGwsIG51bGwsIG51bGwsIGdyYXBoKTtcbiAgfSAvLyAjIyMgYGdldFF1YWRzYCByZXR1cm5zIGFuIGFycmF5IG9mIHF1YWRzIG1hdGNoaW5nIGEgcGF0dGVybi5cbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuXG5cbiAgZ2V0UXVhZHMoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgLy8gQ29udmVydCB0ZXJtcyB0byBpbnRlcm5hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICBzdWJqZWN0ID0gc3ViamVjdCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKHN1YmplY3QpO1xuICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZSAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKHByZWRpY2F0ZSk7XG4gICAgb2JqZWN0ID0gb2JqZWN0ICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkob2JqZWN0KTtcbiAgICBncmFwaCA9IGdyYXBoICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoZ3JhcGgpO1xuXG4gICAgdmFyIHF1YWRzID0gW10sXG4gICAgICAgIGdyYXBocyA9IHRoaXMuX2dldEdyYXBocyhncmFwaCksXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGlkcyA9IHRoaXMuX2lkcyxcbiAgICAgICAgc3ViamVjdElkLFxuICAgICAgICBwcmVkaWNhdGVJZCxcbiAgICAgICAgb2JqZWN0SWQ7IC8vIFRyYW5zbGF0ZSBJUklzIHRvIGludGVybmFsIGluZGV4IGtleXMuXG5cblxuICAgIGlmIChpc1N0cmluZyhzdWJqZWN0KSAmJiAhKHN1YmplY3RJZCA9IGlkc1tzdWJqZWN0XSkgfHwgaXNTdHJpbmcocHJlZGljYXRlKSAmJiAhKHByZWRpY2F0ZUlkID0gaWRzW3ByZWRpY2F0ZV0pIHx8IGlzU3RyaW5nKG9iamVjdCkgJiYgIShvYmplY3RJZCA9IGlkc1tvYmplY3RdKSkgcmV0dXJuIHF1YWRzO1xuXG4gICAgZm9yICh2YXIgZ3JhcGhJZCBpbiBncmFwaHMpIHtcbiAgICAgIC8vIE9ubHkgaWYgdGhlIHNwZWNpZmllZCBncmFwaCBjb250YWlucyB0cmlwbGVzLCB0aGVyZSBjYW4gYmUgcmVzdWx0c1xuICAgICAgaWYgKGNvbnRlbnQgPSBncmFwaHNbZ3JhcGhJZF0pIHtcbiAgICAgICAgLy8gQ2hvb3NlIHRoZSBvcHRpbWFsIGluZGV4LCBiYXNlZCBvbiB3aGF0IGZpZWxkcyBhcmUgcHJlc2VudFxuICAgICAgICBpZiAoc3ViamVjdElkKSB7XG4gICAgICAgICAgaWYgKG9iamVjdElkKSAvLyBJZiBzdWJqZWN0IGFuZCBvYmplY3QgYXJlIGdpdmVuLCB0aGUgb2JqZWN0IGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICAgIHRoaXMuX2ZpbmRJbkluZGV4KGNvbnRlbnQub2JqZWN0cywgb2JqZWN0SWQsIHN1YmplY3RJZCwgcHJlZGljYXRlSWQsICdvYmplY3QnLCAnc3ViamVjdCcsICdwcmVkaWNhdGUnLCBncmFwaElkLCBudWxsLCBxdWFkcyk7ZWxzZSAvLyBJZiBvbmx5IHN1YmplY3QgYW5kIHBvc3NpYmx5IHByZWRpY2F0ZSBhcmUgZ2l2ZW4sIHRoZSBzdWJqZWN0IGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICAgIHRoaXMuX2ZpbmRJbkluZGV4KGNvbnRlbnQuc3ViamVjdHMsIHN1YmplY3RJZCwgcHJlZGljYXRlSWQsIG51bGwsICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCBncmFwaElkLCBudWxsLCBxdWFkcyk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlZGljYXRlSWQpIC8vIElmIG9ubHkgcHJlZGljYXRlIGFuZCBwb3NzaWJseSBvYmplY3QgYXJlIGdpdmVuLCB0aGUgcHJlZGljYXRlIGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICB0aGlzLl9maW5kSW5JbmRleChjb250ZW50LnByZWRpY2F0ZXMsIHByZWRpY2F0ZUlkLCBvYmplY3RJZCwgbnVsbCwgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCAnc3ViamVjdCcsIGdyYXBoSWQsIG51bGwsIHF1YWRzKTtlbHNlIGlmIChvYmplY3RJZCkgLy8gSWYgb25seSBvYmplY3QgaXMgZ2l2ZW4sIHRoZSBvYmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgIHRoaXMuX2ZpbmRJbkluZGV4KGNvbnRlbnQub2JqZWN0cywgb2JqZWN0SWQsIG51bGwsIG51bGwsICdvYmplY3QnLCAnc3ViamVjdCcsICdwcmVkaWNhdGUnLCBncmFwaElkLCBudWxsLCBxdWFkcyk7ZWxzZSAvLyBJZiBub3RoaW5nIGlzIGdpdmVuLCBpdGVyYXRlIHN1YmplY3RzIGFuZCBwcmVkaWNhdGVzIGZpcnN0XG4gICAgICAgICAgdGhpcy5fZmluZEluSW5kZXgoY29udGVudC5zdWJqZWN0cywgbnVsbCwgbnVsbCwgbnVsbCwgJ3N1YmplY3QnLCAncHJlZGljYXRlJywgJ29iamVjdCcsIGdyYXBoSWQsIG51bGwsIHF1YWRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVhZHM7XG4gIH0gLy8gIyMjIGBtYXRjaGAgcmV0dXJucyBhIHN0cmVhbSBvZiBxdWFkcyBtYXRjaGluZyBhIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIG1hdGNoKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHZhciBzdHJlYW0gPSBuZXcgX3JlYWRhYmxlU3RyZWFtLlJlYWRhYmxlKHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KTsgLy8gSW5pdGlhbGl6ZSBzdHJlYW0gb25jZSBpdCBpcyBiZWluZyByZWFkXG5cbiAgICBzdHJlYW0uX3JlYWQgPSAoKSA9PiB7XG4gICAgICBmb3IgKHZhciBxdWFkIG9mIHRoaXMuZ2V0UXVhZHMoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSkgc3RyZWFtLnB1c2gocXVhZCk7XG5cbiAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9IC8vICMjIyBgY291bnRRdWFkc2AgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHF1YWRzIG1hdGNoaW5nIGEgcGF0dGVybi5cbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuXG5cbiAgY291bnRRdWFkcyhzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIHN1YmplY3QgPSBzdWJqZWN0ICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoc3ViamVjdCk7XG4gICAgcHJlZGljYXRlID0gcHJlZGljYXRlICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkocHJlZGljYXRlKTtcbiAgICBvYmplY3QgPSBvYmplY3QgJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShvYmplY3QpO1xuICAgIGdyYXBoID0gZ3JhcGggJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShncmFwaCk7XG5cbiAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICBncmFwaHMgPSB0aGlzLl9nZXRHcmFwaHMoZ3JhcGgpLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBpZHMgPSB0aGlzLl9pZHMsXG4gICAgICAgIHN1YmplY3RJZCxcbiAgICAgICAgcHJlZGljYXRlSWQsXG4gICAgICAgIG9iamVjdElkOyAvLyBUcmFuc2xhdGUgSVJJcyB0byBpbnRlcm5hbCBpbmRleCBrZXlzLlxuXG5cbiAgICBpZiAoaXNTdHJpbmcoc3ViamVjdCkgJiYgIShzdWJqZWN0SWQgPSBpZHNbc3ViamVjdF0pIHx8IGlzU3RyaW5nKHByZWRpY2F0ZSkgJiYgIShwcmVkaWNhdGVJZCA9IGlkc1twcmVkaWNhdGVdKSB8fCBpc1N0cmluZyhvYmplY3QpICYmICEob2JqZWN0SWQgPSBpZHNbb2JqZWN0XSkpIHJldHVybiAwO1xuXG4gICAgZm9yICh2YXIgZ3JhcGhJZCBpbiBncmFwaHMpIHtcbiAgICAgIC8vIE9ubHkgaWYgdGhlIHNwZWNpZmllZCBncmFwaCBjb250YWlucyB0cmlwbGVzLCB0aGVyZSBjYW4gYmUgcmVzdWx0c1xuICAgICAgaWYgKGNvbnRlbnQgPSBncmFwaHNbZ3JhcGhJZF0pIHtcbiAgICAgICAgLy8gQ2hvb3NlIHRoZSBvcHRpbWFsIGluZGV4LCBiYXNlZCBvbiB3aGF0IGZpZWxkcyBhcmUgcHJlc2VudFxuICAgICAgICBpZiAoc3ViamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QpIC8vIElmIHN1YmplY3QgYW5kIG9iamVjdCBhcmUgZ2l2ZW4sIHRoZSBvYmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgICAgY291bnQgKz0gdGhpcy5fY291bnRJbkluZGV4KGNvbnRlbnQub2JqZWN0cywgb2JqZWN0SWQsIHN1YmplY3RJZCwgcHJlZGljYXRlSWQpO2Vsc2UgLy8gSWYgb25seSBzdWJqZWN0IGFuZCBwb3NzaWJseSBwcmVkaWNhdGUgYXJlIGdpdmVuLCB0aGUgc3ViamVjdCBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLl9jb3VudEluSW5kZXgoY29udGVudC5zdWJqZWN0cywgc3ViamVjdElkLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWRpY2F0ZSkge1xuICAgICAgICAgIC8vIElmIG9ubHkgcHJlZGljYXRlIGFuZCBwb3NzaWJseSBvYmplY3QgYXJlIGdpdmVuLCB0aGUgcHJlZGljYXRlIGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICBjb3VudCArPSB0aGlzLl9jb3VudEluSW5kZXgoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQsIHN1YmplY3RJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgb25seSBvYmplY3QgaXMgcG9zc2libHkgZ2l2ZW4sIHRoZSBvYmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgIGNvdW50ICs9IHRoaXMuX2NvdW50SW5JbmRleChjb250ZW50Lm9iamVjdHMsIG9iamVjdElkLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfSAvLyAjIyMgYGZvckVhY2hgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBhbGwgcXVhZHMuXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGZvckVhY2goY2FsbGJhY2ssIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHRoaXMuc29tZShmdW5jdGlvbiAocXVhZCkge1xuICAgICAgY2FsbGJhY2socXVhZCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKTtcbiAgfSAvLyAjIyMgYGV2ZXJ5YCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gYWxsIHF1YWRzLFxuICAvLyBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgaXQgcmV0dXJucyB0cnV0aHkgZm9yIGFsbCB0aGVtLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBldmVyeShjYWxsYmFjaywgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgdmFyIHNvbWUgPSBmYWxzZTtcbiAgICB2YXIgZXZlcnkgPSAhdGhpcy5zb21lKGZ1bmN0aW9uIChxdWFkKSB7XG4gICAgICBzb21lID0gdHJ1ZTtcbiAgICAgIHJldHVybiAhY2FsbGJhY2socXVhZCk7XG4gICAgfSwgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKTtcbiAgICByZXR1cm4gc29tZSAmJiBldmVyeTtcbiAgfSAvLyAjIyMgYHNvbWVgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBhbGwgcXVhZHMsXG4gIC8vIGFuZCByZXR1cm5zIGB0cnVlYCBpZiBpdCByZXR1cm5zIHRydXRoeSBmb3IgYW55IG9mIHRoZW0uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIHNvbWUoY2FsbGJhY2ssIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIC8vIENvbnZlcnQgdGVybXMgdG8gaW50ZXJuYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgc3ViamVjdCA9IHN1YmplY3QgJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShzdWJqZWN0KTtcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUgJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShwcmVkaWNhdGUpO1xuICAgIG9iamVjdCA9IG9iamVjdCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKG9iamVjdCk7XG4gICAgZ3JhcGggPSBncmFwaCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKGdyYXBoKTtcblxuICAgIHZhciBncmFwaHMgPSB0aGlzLl9nZXRHcmFwaHMoZ3JhcGgpLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBpZHMgPSB0aGlzLl9pZHMsXG4gICAgICAgIHN1YmplY3RJZCxcbiAgICAgICAgcHJlZGljYXRlSWQsXG4gICAgICAgIG9iamVjdElkOyAvLyBUcmFuc2xhdGUgSVJJcyB0byBpbnRlcm5hbCBpbmRleCBrZXlzLlxuXG5cbiAgICBpZiAoaXNTdHJpbmcoc3ViamVjdCkgJiYgIShzdWJqZWN0SWQgPSBpZHNbc3ViamVjdF0pIHx8IGlzU3RyaW5nKHByZWRpY2F0ZSkgJiYgIShwcmVkaWNhdGVJZCA9IGlkc1twcmVkaWNhdGVdKSB8fCBpc1N0cmluZyhvYmplY3QpICYmICEob2JqZWN0SWQgPSBpZHNbb2JqZWN0XSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGdyYXBoSWQgaW4gZ3JhcGhzKSB7XG4gICAgICAvLyBPbmx5IGlmIHRoZSBzcGVjaWZpZWQgZ3JhcGggY29udGFpbnMgdHJpcGxlcywgdGhlcmUgY2FuIGJlIHJlc3VsdHNcbiAgICAgIGlmIChjb250ZW50ID0gZ3JhcGhzW2dyYXBoSWRdKSB7XG4gICAgICAgIC8vIENob29zZSB0aGUgb3B0aW1hbCBpbmRleCwgYmFzZWQgb24gd2hhdCBmaWVsZHMgYXJlIHByZXNlbnRcbiAgICAgICAgaWYgKHN1YmplY3RJZCkge1xuICAgICAgICAgIGlmIChvYmplY3RJZCkge1xuICAgICAgICAgICAgLy8gSWYgc3ViamVjdCBhbmQgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIG9iamVjdCBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgICBpZiAodGhpcy5fZmluZEluSW5kZXgoY29udGVudC5vYmplY3RzLCBvYmplY3RJZCwgc3ViamVjdElkLCBwcmVkaWNhdGVJZCwgJ29iamVjdCcsICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsIGdyYXBoSWQsIGNhbGxiYWNrLCBudWxsKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIC8vIElmIG9ubHkgc3ViamVjdCBhbmQgcG9zc2libHkgcHJlZGljYXRlIGFyZSBnaXZlbiwgdGhlIHN1YmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbmRJbkluZGV4KGNvbnRlbnQuc3ViamVjdHMsIHN1YmplY3RJZCwgcHJlZGljYXRlSWQsIG51bGwsICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCBncmFwaElkLCBjYWxsYmFjaywgbnVsbCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWRpY2F0ZUlkKSB7XG4gICAgICAgICAgLy8gSWYgb25seSBwcmVkaWNhdGUgYW5kIHBvc3NpYmx5IG9iamVjdCBhcmUgZ2l2ZW4sIHRoZSBwcmVkaWNhdGUgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgIGlmICh0aGlzLl9maW5kSW5JbmRleChjb250ZW50LnByZWRpY2F0ZXMsIHByZWRpY2F0ZUlkLCBvYmplY3RJZCwgbnVsbCwgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCAnc3ViamVjdCcsIGdyYXBoSWQsIGNhbGxiYWNrLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdElkKSB7XG4gICAgICAgICAgLy8gSWYgb25seSBvYmplY3QgaXMgZ2l2ZW4sIHRoZSBvYmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgIGlmICh0aGlzLl9maW5kSW5JbmRleChjb250ZW50Lm9iamVjdHMsIG9iamVjdElkLCBudWxsLCBudWxsLCAnb2JqZWN0JywgJ3N1YmplY3QnLCAncHJlZGljYXRlJywgZ3JhcGhJZCwgY2FsbGJhY2ssIG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSAvLyBJZiBub3RoaW5nIGlzIGdpdmVuLCBpdGVyYXRlIHN1YmplY3RzIGFuZCBwcmVkaWNhdGVzIGZpcnN0XG4gICAgICAgICAgaWYgKHRoaXMuX2ZpbmRJbkluZGV4KGNvbnRlbnQuc3ViamVjdHMsIG51bGwsIG51bGwsIG51bGwsICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCBncmFwaElkLCBjYWxsYmFjaywgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gIyMjIGBnZXRTdWJqZWN0c2AgcmV0dXJucyBhbGwgc3ViamVjdHMgdGhhdCBtYXRjaCB0aGUgcGF0dGVybi5cbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuXG5cbiAgZ2V0U3ViamVjdHMocHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB0aGlzLmZvclN1YmplY3RzKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXN1bHRzLnB1c2gocyk7XG4gICAgfSwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSAvLyAjIyMgYGZvclN1YmplY3RzYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gYWxsIHN1YmplY3RzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGZvclN1YmplY3RzKGNhbGxiYWNrLCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZSAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKHByZWRpY2F0ZSk7XG4gICAgb2JqZWN0ID0gb2JqZWN0ICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkob2JqZWN0KTtcbiAgICBncmFwaCA9IGdyYXBoICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoZ3JhcGgpO1xuXG4gICAgdmFyIGlkcyA9IHRoaXMuX2lkcyxcbiAgICAgICAgZ3JhcGhzID0gdGhpcy5fZ2V0R3JhcGhzKGdyYXBoKSxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgcHJlZGljYXRlSWQsXG4gICAgICAgIG9iamVjdElkO1xuXG4gICAgY2FsbGJhY2sgPSB0aGlzLl91bmlxdWVFbnRpdGllcyhjYWxsYmFjayk7IC8vIFRyYW5zbGF0ZSBJUklzIHRvIGludGVybmFsIGluZGV4IGtleXMuXG5cbiAgICBpZiAoaXNTdHJpbmcocHJlZGljYXRlKSAmJiAhKHByZWRpY2F0ZUlkID0gaWRzW3ByZWRpY2F0ZV0pIHx8IGlzU3RyaW5nKG9iamVjdCkgJiYgIShvYmplY3RJZCA9IGlkc1tvYmplY3RdKSkgcmV0dXJuO1xuXG4gICAgZm9yIChncmFwaCBpbiBncmFwaHMpIHtcbiAgICAgIC8vIE9ubHkgaWYgdGhlIHNwZWNpZmllZCBncmFwaCBjb250YWlucyB0cmlwbGVzLCB0aGVyZSBjYW4gYmUgcmVzdWx0c1xuICAgICAgaWYgKGNvbnRlbnQgPSBncmFwaHNbZ3JhcGhdKSB7XG4gICAgICAgIC8vIENob29zZSBvcHRpbWFsIGluZGV4IGJhc2VkIG9uIHdoaWNoIGZpZWxkcyBhcmUgd2lsZGNhcmRzXG4gICAgICAgIGlmIChwcmVkaWNhdGVJZCkge1xuICAgICAgICAgIGlmIChvYmplY3RJZCkgLy8gSWYgcHJlZGljYXRlIGFuZCBvYmplY3QgYXJlIGdpdmVuLCB0aGUgUE9TIGluZGV4IGlzIGJlc3QuXG4gICAgICAgICAgICB0aGlzLl9sb29wQnkyS2V5cyhjb250ZW50LnByZWRpY2F0ZXMsIHByZWRpY2F0ZUlkLCBvYmplY3RJZCwgY2FsbGJhY2spO2Vsc2UgLy8gSWYgb25seSBwcmVkaWNhdGUgaXMgZ2l2ZW4sIHRoZSBTUE8gaW5kZXggaXMgYmVzdC5cbiAgICAgICAgICAgIHRoaXMuX2xvb3BCeUtleTEoY29udGVudC5zdWJqZWN0cywgcHJlZGljYXRlSWQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3RJZCkgLy8gSWYgb25seSBvYmplY3QgaXMgZ2l2ZW4sIHRoZSBPU1AgaW5kZXggaXMgYmVzdC5cbiAgICAgICAgICB0aGlzLl9sb29wQnlLZXkwKGNvbnRlbnQub2JqZWN0cywgb2JqZWN0SWQsIGNhbGxiYWNrKTtlbHNlIC8vIElmIG5vIHBhcmFtcyBnaXZlbiwgaXRlcmF0ZSBhbGwgdGhlIHN1YmplY3RzXG4gICAgICAgICAgdGhpcy5fbG9vcChjb250ZW50LnN1YmplY3RzLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vICMjIyBgZ2V0UHJlZGljYXRlc2AgcmV0dXJucyBhbGwgcHJlZGljYXRlcyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBnZXRQcmVkaWNhdGVzKHN1YmplY3QsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHRoaXMuZm9yUHJlZGljYXRlcyhmdW5jdGlvbiAocCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHApO1xuICAgIH0sIHN1YmplY3QsIG9iamVjdCwgZ3JhcGgpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9IC8vICMjIyBgZm9yUHJlZGljYXRlc2AgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBwcmVkaWNhdGVzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGZvclByZWRpY2F0ZXMoY2FsbGJhY2ssIHN1YmplY3QsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIHN1YmplY3QgPSBzdWJqZWN0ICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoc3ViamVjdCk7XG4gICAgb2JqZWN0ID0gb2JqZWN0ICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkob2JqZWN0KTtcbiAgICBncmFwaCA9IGdyYXBoICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoZ3JhcGgpO1xuXG4gICAgdmFyIGlkcyA9IHRoaXMuX2lkcyxcbiAgICAgICAgZ3JhcGhzID0gdGhpcy5fZ2V0R3JhcGhzKGdyYXBoKSxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgc3ViamVjdElkLFxuICAgICAgICBvYmplY3RJZDtcblxuICAgIGNhbGxiYWNrID0gdGhpcy5fdW5pcXVlRW50aXRpZXMoY2FsbGJhY2spOyAvLyBUcmFuc2xhdGUgSVJJcyB0byBpbnRlcm5hbCBpbmRleCBrZXlzLlxuXG4gICAgaWYgKGlzU3RyaW5nKHN1YmplY3QpICYmICEoc3ViamVjdElkID0gaWRzW3N1YmplY3RdKSB8fCBpc1N0cmluZyhvYmplY3QpICYmICEob2JqZWN0SWQgPSBpZHNbb2JqZWN0XSkpIHJldHVybjtcblxuICAgIGZvciAoZ3JhcGggaW4gZ3JhcGhzKSB7XG4gICAgICAvLyBPbmx5IGlmIHRoZSBzcGVjaWZpZWQgZ3JhcGggY29udGFpbnMgdHJpcGxlcywgdGhlcmUgY2FuIGJlIHJlc3VsdHNcbiAgICAgIGlmIChjb250ZW50ID0gZ3JhcGhzW2dyYXBoXSkge1xuICAgICAgICAvLyBDaG9vc2Ugb3B0aW1hbCBpbmRleCBiYXNlZCBvbiB3aGljaCBmaWVsZHMgYXJlIHdpbGRjYXJkc1xuICAgICAgICBpZiAoc3ViamVjdElkKSB7XG4gICAgICAgICAgaWYgKG9iamVjdElkKSAvLyBJZiBzdWJqZWN0IGFuZCBvYmplY3QgYXJlIGdpdmVuLCB0aGUgT1NQIGluZGV4IGlzIGJlc3QuXG4gICAgICAgICAgICB0aGlzLl9sb29wQnkyS2V5cyhjb250ZW50Lm9iamVjdHMsIG9iamVjdElkLCBzdWJqZWN0SWQsIGNhbGxiYWNrKTtlbHNlIC8vIElmIG9ubHkgc3ViamVjdCBpcyBnaXZlbiwgdGhlIFNQTyBpbmRleCBpcyBiZXN0LlxuICAgICAgICAgICAgdGhpcy5fbG9vcEJ5S2V5MChjb250ZW50LnN1YmplY3RzLCBzdWJqZWN0SWQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3RJZCkgLy8gSWYgb25seSBvYmplY3QgaXMgZ2l2ZW4sIHRoZSBQT1MgaW5kZXggaXMgYmVzdC5cbiAgICAgICAgICB0aGlzLl9sb29wQnlLZXkxKGNvbnRlbnQucHJlZGljYXRlcywgb2JqZWN0SWQsIGNhbGxiYWNrKTtlbHNlIC8vIElmIG5vIHBhcmFtcyBnaXZlbiwgaXRlcmF0ZSBhbGwgdGhlIHByZWRpY2F0ZXMuXG4gICAgICAgICAgdGhpcy5fbG9vcChjb250ZW50LnByZWRpY2F0ZXMsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gIyMjIGBnZXRPYmplY3RzYCByZXR1cm5zIGFsbCBvYmplY3RzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGdldE9iamVjdHMoc3ViamVjdCwgcHJlZGljYXRlLCBncmFwaCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdGhpcy5mb3JPYmplY3RzKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXN1bHRzLnB1c2gobyk7XG4gICAgfSwgc3ViamVjdCwgcHJlZGljYXRlLCBncmFwaCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gLy8gIyMjIGBmb3JPYmplY3RzYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gYWxsIG9iamVjdHMgdGhhdCBtYXRjaCB0aGUgcGF0dGVybi5cbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuXG5cbiAgZm9yT2JqZWN0cyhjYWxsYmFjaywgc3ViamVjdCwgcHJlZGljYXRlLCBncmFwaCkge1xuICAgIC8vIENvbnZlcnQgdGVybXMgdG8gaW50ZXJuYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgc3ViamVjdCA9IHN1YmplY3QgJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShzdWJqZWN0KTtcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUgJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShwcmVkaWNhdGUpO1xuICAgIGdyYXBoID0gZ3JhcGggJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShncmFwaCk7XG5cbiAgICB2YXIgaWRzID0gdGhpcy5faWRzLFxuICAgICAgICBncmFwaHMgPSB0aGlzLl9nZXRHcmFwaHMoZ3JhcGgpLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBzdWJqZWN0SWQsXG4gICAgICAgIHByZWRpY2F0ZUlkO1xuXG4gICAgY2FsbGJhY2sgPSB0aGlzLl91bmlxdWVFbnRpdGllcyhjYWxsYmFjayk7IC8vIFRyYW5zbGF0ZSBJUklzIHRvIGludGVybmFsIGluZGV4IGtleXMuXG5cbiAgICBpZiAoaXNTdHJpbmcoc3ViamVjdCkgJiYgIShzdWJqZWN0SWQgPSBpZHNbc3ViamVjdF0pIHx8IGlzU3RyaW5nKHByZWRpY2F0ZSkgJiYgIShwcmVkaWNhdGVJZCA9IGlkc1twcmVkaWNhdGVdKSkgcmV0dXJuO1xuXG4gICAgZm9yIChncmFwaCBpbiBncmFwaHMpIHtcbiAgICAgIC8vIE9ubHkgaWYgdGhlIHNwZWNpZmllZCBncmFwaCBjb250YWlucyB0cmlwbGVzLCB0aGVyZSBjYW4gYmUgcmVzdWx0c1xuICAgICAgaWYgKGNvbnRlbnQgPSBncmFwaHNbZ3JhcGhdKSB7XG4gICAgICAgIC8vIENob29zZSBvcHRpbWFsIGluZGV4IGJhc2VkIG9uIHdoaWNoIGZpZWxkcyBhcmUgd2lsZGNhcmRzXG4gICAgICAgIGlmIChzdWJqZWN0SWQpIHtcbiAgICAgICAgICBpZiAocHJlZGljYXRlSWQpIC8vIElmIHN1YmplY3QgYW5kIHByZWRpY2F0ZSBhcmUgZ2l2ZW4sIHRoZSBTUE8gaW5kZXggaXMgYmVzdC5cbiAgICAgICAgICAgIHRoaXMuX2xvb3BCeTJLZXlzKGNvbnRlbnQuc3ViamVjdHMsIHN1YmplY3RJZCwgcHJlZGljYXRlSWQsIGNhbGxiYWNrKTtlbHNlIC8vIElmIG9ubHkgc3ViamVjdCBpcyBnaXZlbiwgdGhlIE9TUCBpbmRleCBpcyBiZXN0LlxuICAgICAgICAgICAgdGhpcy5fbG9vcEJ5S2V5MShjb250ZW50Lm9iamVjdHMsIHN1YmplY3RJZCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWRpY2F0ZUlkKSAvLyBJZiBvbmx5IHByZWRpY2F0ZSBpcyBnaXZlbiwgdGhlIFBPUyBpbmRleCBpcyBiZXN0LlxuICAgICAgICAgIHRoaXMuX2xvb3BCeUtleTAoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgY2FsbGJhY2spO2Vsc2UgLy8gSWYgbm8gcGFyYW1zIGdpdmVuLCBpdGVyYXRlIGFsbCB0aGUgb2JqZWN0cy5cbiAgICAgICAgICB0aGlzLl9sb29wKGNvbnRlbnQub2JqZWN0cywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyAjIyMgYGdldEdyYXBoc2AgcmV0dXJucyBhbGwgZ3JhcGhzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGdldEdyYXBocyhzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdGhpcy5mb3JHcmFwaHMoZnVuY3Rpb24gKGcpIHtcbiAgICAgIHJlc3VsdHMucHVzaChnKTtcbiAgICB9LCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gLy8gIyMjIGBmb3JHcmFwaHNgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBhbGwgZ3JhcGhzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGZvckdyYXBocyhjYWxsYmFjaywgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpIHtcbiAgICBmb3IgKHZhciBncmFwaCBpbiB0aGlzLl9ncmFwaHMpIHtcbiAgICAgIHRoaXMuc29tZShmdW5jdGlvbiAocXVhZCkge1xuICAgICAgICBjYWxsYmFjayhxdWFkLmdyYXBoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEhhbHQgaXRlcmF0aW9uIG9mIHNvbWUoKVxuICAgICAgfSwgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKTtcbiAgICB9XG4gIH0gLy8gIyMjIGBjcmVhdGVCbGFua05vZGVgIGNyZWF0ZXMgYSBuZXcgYmxhbmsgbm9kZSwgcmV0dXJuaW5nIGl0cyBuYW1lXG5cblxuICBjcmVhdGVCbGFua05vZGUoc3VnZ2VzdGVkTmFtZSkge1xuICAgIHZhciBuYW1lLCBpbmRleDsgLy8gR2VuZXJhdGUgYSBuYW1lIGJhc2VkIG9uIHRoZSBzdWdnZXN0ZWQgbmFtZVxuXG4gICAgaWYgKHN1Z2dlc3RlZE5hbWUpIHtcbiAgICAgIG5hbWUgPSBzdWdnZXN0ZWROYW1lID0gJ186JyArIHN1Z2dlc3RlZE5hbWUsIGluZGV4ID0gMTtcblxuICAgICAgd2hpbGUgKHRoaXMuX2lkc1tuYW1lXSkgbmFtZSA9IHN1Z2dlc3RlZE5hbWUgKyBpbmRleCsrO1xuICAgIH0gLy8gR2VuZXJhdGUgYSBnZW5lcmljIGJsYW5rIG5vZGUgbmFtZVxuICAgIGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbmFtZSA9ICdfOmInICsgdGhpcy5fYmxhbmtOb2RlSW5kZXgrKztcbiAgICAgICAgfSB3aGlsZSAodGhpcy5faWRzW25hbWVdKTtcbiAgICAgIH0gLy8gQWRkIHRoZSBibGFuayBub2RlIHRvIHRoZSBlbnRpdGllcywgYXZvaWRpbmcgdGhlIGdlbmVyYXRpb24gb2YgZHVwbGljYXRlc1xuXG5cbiAgICB0aGlzLl9pZHNbbmFtZV0gPSArK3RoaXMuX2lkO1xuICAgIHRoaXMuX2VudGl0aWVzW3RoaXMuX2lkXSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuYmxhbmtOb2RlKG5hbWUuc3Vic3RyKDIpKTtcbiAgfSAvLyAjIyMgYGV4dHJhY3RMaXN0c2AgZmluZHMgYW5kIHJlbW92ZXMgYWxsIGxpc3QgdHJpcGxlc1xuICAvLyBhbmQgcmV0dXJucyB0aGUgaXRlbXMgcGVyIGxpc3QuXG5cblxuICBleHRyYWN0TGlzdHMoe1xuICAgIHJlbW92ZSA9IGZhbHNlLFxuICAgIGlnbm9yZUVycm9ycyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHZhciBsaXN0cyA9IHt9OyAvLyBoYXMgc2NhbGFyIGtleXMgc28gY291bGQgYmUgYSBzaW1wbGUgT2JqZWN0XG5cbiAgICB2YXIgb25FcnJvciA9IGlnbm9yZUVycm9ycyA/ICgpID0+IHRydWUgOiAobm9kZSwgbWVzc2FnZSkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25vZGUudmFsdWV9ICR7bWVzc2FnZX1gKTtcbiAgICB9OyAvLyBUcmF2ZXJzZSBlYWNoIGxpc3QgZnJvbSBpdHMgdGFpbFxuXG4gICAgdmFyIHRhaWxzID0gdGhpcy5nZXRRdWFkcyhudWxsLCBfSVJJcy5kZWZhdWx0LnJkZi5yZXN0LCBfSVJJcy5kZWZhdWx0LnJkZi5uaWwsIG51bGwpO1xuICAgIHZhciB0b1JlbW92ZSA9IHJlbW92ZSA/IFsuLi50YWlsc10gOiBbXTtcbiAgICB0YWlscy5mb3JFYWNoKHRhaWxRdWFkID0+IHtcbiAgICAgIHZhciBpdGVtcyA9IFtdOyAvLyB0aGUgbWVtYmVycyBmb3VuZCBhcyBvYmplY3RzIG9mIHJkZjpmaXJzdCBxdWFkc1xuXG4gICAgICB2YXIgbWFsZm9ybWVkID0gZmFsc2U7IC8vIHNpZ25hbHMgd2hldGhlciB0aGUgY3VycmVudCBsaXN0IGlzIG1hbGZvcm1lZFxuXG4gICAgICB2YXIgaGVhZDsgLy8gdGhlIGhlYWQgb2YgdGhlIGxpc3QgKF86YjEgaW4gYWJvdmUgZXhhbXBsZSlcblxuICAgICAgdmFyIGhlYWRQb3M7IC8vIHNldCB0byBzdWJqZWN0IG9yIG9iamVjdCB3aGVuIGhlYWQgaXMgc2V0XG5cbiAgICAgIHZhciBncmFwaCA9IHRhaWxRdWFkLmdyYXBoOyAvLyBtYWtlIHN1cmUgbGlzdCBpcyBpbiBleGFjdGx5IG9uZSBncmFwaFxuICAgICAgLy8gVHJhdmVyc2UgdGhlIGxpc3QgZnJvbSB0YWlsIHRvIGVuZFxuXG4gICAgICB2YXIgY3VycmVudCA9IHRhaWxRdWFkLnN1YmplY3Q7XG5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmICFtYWxmb3JtZWQpIHtcbiAgICAgICAgdmFyIG9iamVjdFF1YWRzID0gdGhpcy5nZXRRdWFkcyhudWxsLCBudWxsLCBjdXJyZW50LCBudWxsKTtcbiAgICAgICAgdmFyIHN1YmplY3RRdWFkcyA9IHRoaXMuZ2V0UXVhZHMoY3VycmVudCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgcXVhZCxcbiAgICAgICAgICAgIGZpcnN0ID0gbnVsbCxcbiAgICAgICAgICAgIHJlc3QgPSBudWxsLFxuICAgICAgICAgICAgcGFyZW50ID0gbnVsbDsgLy8gRmluZCB0aGUgZmlyc3QgYW5kIHJlc3Qgb2YgdGhpcyBsaXN0IG5vZGVcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3ViamVjdFF1YWRzLmxlbmd0aCAmJiAhbWFsZm9ybWVkOyBpKyspIHtcbiAgICAgICAgICBxdWFkID0gc3ViamVjdFF1YWRzW2ldO1xuICAgICAgICAgIGlmICghcXVhZC5ncmFwaC5lcXVhbHMoZ3JhcGgpKSBtYWxmb3JtZWQgPSBvbkVycm9yKGN1cnJlbnQsICdub3QgY29uZmluZWQgdG8gc2luZ2xlIGdyYXBoJyk7ZWxzZSBpZiAoaGVhZCkgbWFsZm9ybWVkID0gb25FcnJvcihjdXJyZW50LCAnaGFzIG5vbi1saXN0IGFyY3Mgb3V0Jyk7IC8vIG9uZSByZGY6Zmlyc3RcbiAgICAgICAgICBlbHNlIGlmIChxdWFkLnByZWRpY2F0ZS52YWx1ZSA9PT0gX0lSSXMuZGVmYXVsdC5yZGYuZmlyc3QpIHtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0KSBtYWxmb3JtZWQgPSBvbkVycm9yKGN1cnJlbnQsICdoYXMgbXVsdGlwbGUgcmRmOmZpcnN0IGFyY3MnKTtlbHNlIHRvUmVtb3ZlLnB1c2goZmlyc3QgPSBxdWFkKTtcbiAgICAgICAgICAgIH0gLy8gb25lIHJkZjpyZXN0XG4gICAgICAgICAgICBlbHNlIGlmIChxdWFkLnByZWRpY2F0ZS52YWx1ZSA9PT0gX0lSSXMuZGVmYXVsdC5yZGYucmVzdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0KSBtYWxmb3JtZWQgPSBvbkVycm9yKGN1cnJlbnQsICdoYXMgbXVsdGlwbGUgcmRmOnJlc3QgYXJjcycpO2Vsc2UgdG9SZW1vdmUucHVzaChyZXN0ID0gcXVhZCk7XG4gICAgICAgICAgICAgIH0gLy8gYWxpZW4gdHJpcGxlXG4gICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdFF1YWRzLmxlbmd0aCkgbWFsZm9ybWVkID0gb25FcnJvcihjdXJyZW50LCAnY2FuXFwndCBiZSBzdWJqZWN0IGFuZCBvYmplY3QnKTtlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGhlYWQgPSBxdWFkOyAvLyBlLmcuIHsgKDEgMiAzKSA6cCA6byB9XG5cbiAgICAgICAgICAgICAgICAgIGhlYWRQb3MgPSAnc3ViamVjdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIHsgOnMgOnAgKDEgMikgfSBhcnJpdmVzIGhlcmUgd2l0aCBubyBoZWFkXG4gICAgICAgIC8vIHsgKDEgMikgOnAgOm8gfSBhcnJpdmVzIGhlcmUgd2l0aCBoZWFkIHNldCB0byB0aGUgbGlzdC5cblxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3RRdWFkcy5sZW5ndGggJiYgIW1hbGZvcm1lZDsgKytpKSB7XG4gICAgICAgICAgcXVhZCA9IG9iamVjdFF1YWRzW2ldO1xuICAgICAgICAgIGlmIChoZWFkKSBtYWxmb3JtZWQgPSBvbkVycm9yKGN1cnJlbnQsICdjYW5cXCd0IGhhdmUgY29yZWZlcmVuY2VzJyk7IC8vIG9uZSByZGY6cmVzdFxuICAgICAgICAgIGVsc2UgaWYgKHF1YWQucHJlZGljYXRlLnZhbHVlID09PSBfSVJJcy5kZWZhdWx0LnJkZi5yZXN0KSB7XG4gICAgICAgICAgICAgIGlmIChwYXJlbnQpIG1hbGZvcm1lZCA9IG9uRXJyb3IoY3VycmVudCwgJ2hhcyBpbmNvbWluZyByZGY6cmVzdCBhcmNzJyk7ZWxzZSBwYXJlbnQgPSBxdWFkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGVhZCA9IHF1YWQ7IC8vIGUuZy4geyA6cyA6cCAoMSAyKSB9XG5cbiAgICAgICAgICAgICAgaGVhZFBvcyA9ICdvYmplY3QnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIFN0b3JlIHRoZSBsaXN0IGl0ZW0gYW5kIGNvbnRpbnVlIHdpdGggcGFyZW50XG5cblxuICAgICAgICBpZiAoIWZpcnN0KSBtYWxmb3JtZWQgPSBvbkVycm9yKGN1cnJlbnQsICdoYXMgbm8gbGlzdCBoZWFkJyk7ZWxzZSBpdGVtcy51bnNoaWZ0KGZpcnN0Lm9iamVjdCk7XG4gICAgICAgIGN1cnJlbnQgPSBwYXJlbnQgJiYgcGFyZW50LnN1YmplY3Q7XG4gICAgICB9IC8vIERvbid0IHJlbW92ZSBhbnkgcXVhZHMgaWYgdGhlIGxpc3QgaXMgbWFsZm9ybWVkXG5cblxuICAgICAgaWYgKG1hbGZvcm1lZCkgcmVtb3ZlID0gZmFsc2U7IC8vIFN0b3JlIHRoZSBsaXN0IHVuZGVyIHRoZSB2YWx1ZSBvZiBpdHMgaGVhZFxuICAgICAgZWxzZSBpZiAoaGVhZCkgbGlzdHNbaGVhZFtoZWFkUG9zXS52YWx1ZV0gPSBpdGVtcztcbiAgICB9KTsgLy8gUmVtb3ZlIGxpc3QgcXVhZHMgaWYgcmVxdWVzdGVkXG5cbiAgICBpZiAocmVtb3ZlKSB0aGlzLnJlbW92ZVF1YWRzKHRvUmVtb3ZlKTtcbiAgICByZXR1cm4gbGlzdHM7XG4gIH1cblxufSAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGEgc3RyaW5nXG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gTjNTdG9yZTtcblxuZnVuY3Rpb24gaXNTdHJpbmcocykge1xuICByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnIHx8IHMgaW5zdGFuY2VvZiBTdHJpbmc7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfTjNQYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL04zUGFyc2VyXCIpKTtcblxudmFyIF9yZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoXCJyZWFkYWJsZS1zdHJlYW1cIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqTjNTdHJlYW1QYXJzZXIqKiBwYXJzZXMgYSB0ZXh0IHN0cmVhbSBpbnRvIGEgcXVhZCBzdHJlYW0uXG4vLyAjIyBDb25zdHJ1Y3RvclxuY2xhc3MgTjNTdHJlYW1QYXJzZXIgZXh0ZW5kcyBfcmVhZGFibGVTdHJlYW0uVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIGRlY29kZVN0cmluZ3M6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPSB0cnVlOyAvLyBTZXQgdXAgcGFyc2VyIHdpdGggZHVtbXkgc3RyZWFtIHRvIG9idGFpbiBgZGF0YWAgYW5kIGBlbmRgIGNhbGxiYWNrc1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBwYXJzZXIgPSBuZXcgX04zUGFyc2VyLmRlZmF1bHQob3B0aW9ucyksXG4gICAgICAgIG9uRGF0YSxcbiAgICAgICAgb25FbmQ7XG4gICAgcGFyc2VyLnBhcnNlKHtcbiAgICAgIG9uOiBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgICAgIG9uRGF0YSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgb25FbmQgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgLy8gSGFuZGxlIHF1YWRzIGJ5IHB1c2hpbmcgdGhlbSBkb3duIHRoZSBwaXBlbGluZVxuICAgIGZ1bmN0aW9uIChlcnJvciwgcXVhZCkge1xuICAgICAgZXJyb3IgJiYgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKSB8fCBxdWFkICYmIHNlbGYucHVzaChxdWFkKTtcbiAgICB9LCAvLyBFbWl0IHByZWZpeGVzIHRocm91Z2ggdGhlIGBwcmVmaXhgIGV2ZW50XG4gICAgZnVuY3Rpb24gKHByZWZpeCwgdXJpKSB7XG4gICAgICBzZWxmLmVtaXQoJ3ByZWZpeCcsIHByZWZpeCwgdXJpKTtcbiAgICB9KTsgLy8gSW1wbGVtZW50IFRyYW5zZm9ybSBtZXRob2RzIHRocm91Z2ggcGFyc2VyIGNhbGxiYWNrc1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgb25EYXRhKGNodW5rKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fZmx1c2ggPSBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgb25FbmQoKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9O1xuICB9IC8vICMjIyBQYXJzZXMgYSBzdHJlYW0gb2Ygc3RyaW5nc1xuXG5cbiAgaW1wb3J0KHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHNlbGYud3JpdGUoY2h1bmspO1xuICAgIH0pO1xuICAgIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbmQoKTtcbiAgICB9KTtcbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gTjNTdHJlYW1QYXJzZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpO1xuXG52YXIgX04zV3JpdGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9OM1dyaXRlclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqTjNTdHJlYW1Xcml0ZXIqKiBzZXJpYWxpemVzIGEgcXVhZCBzdHJlYW0gaW50byBhIHRleHQgc3RyZWFtLlxuLy8gIyMgQ29uc3RydWN0b3JcbmNsYXNzIE4zU3RyZWFtV3JpdGVyIGV4dGVuZHMgX3JlYWRhYmxlU3RyZWFtLlRyYW5zZm9ybSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBlbmNvZGluZzogJ3V0ZjgnXG4gICAgfSk7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5vYmplY3RNb2RlID0gdHJ1ZTsgLy8gU2V0IHVwIHdyaXRlciB3aXRoIGEgZHVtbXkgc3RyZWFtIG9iamVjdFxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3cml0ZXIgPSB0aGlzLl93cml0ZXIgPSBuZXcgX04zV3JpdGVyLmRlZmF1bHQoe1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIChxdWFkLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgc2VsZi5wdXNoKHF1YWQpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSxcbiAgICAgIGVuZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKTsgLy8gSW1wbGVtZW50IFRyYW5zZm9ybSBtZXRob2RzIG9uIHRvcCBvZiB3cml0ZXJcblxuICAgIHRoaXMuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChxdWFkLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgd3JpdGVyLmFkZFF1YWQocXVhZCwgZG9uZSk7XG4gICAgfTtcblxuICAgIHRoaXMuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHdyaXRlci5lbmQoZG9uZSk7XG4gICAgfTtcbiAgfSAvLyAjIyMgU2VyaWFsaXplcyBhIHN0cmVhbSBvZiBxdWFkc1xuXG5cbiAgaW1wb3J0KHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAocXVhZCkge1xuICAgICAgc2VsZi53cml0ZShxdWFkKTtcbiAgICB9KTtcbiAgICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW5kKCk7XG4gICAgfSk7XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcbiAgICBzdHJlYW0ub24oJ3ByZWZpeCcsIGZ1bmN0aW9uIChwcmVmaXgsIGlyaSkge1xuICAgICAgc2VsZi5fd3JpdGVyLmFkZFByZWZpeChwcmVmaXgsIGlyaSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBOM1N0cmVhbVdyaXRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNOYW1lZE5vZGUgPSBpc05hbWVkTm9kZTtcbmV4cG9ydHMuaXNCbGFua05vZGUgPSBpc0JsYW5rTm9kZTtcbmV4cG9ydHMuaXNMaXRlcmFsID0gaXNMaXRlcmFsO1xuZXhwb3J0cy5pc1ZhcmlhYmxlID0gaXNWYXJpYWJsZTtcbmV4cG9ydHMuaXNEZWZhdWx0R3JhcGggPSBpc0RlZmF1bHRHcmFwaDtcbmV4cG9ydHMuaW5EZWZhdWx0R3JhcGggPSBpbkRlZmF1bHRHcmFwaDtcbmV4cG9ydHMucHJlZml4ID0gcHJlZml4O1xuZXhwb3J0cy5wcmVmaXhlcyA9IHByZWZpeGVzO1xuXG52YXIgX04zRGF0YUZhY3RvcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL04zRGF0YUZhY3RvcnlcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyAqKk4zVXRpbCoqIHByb3ZpZGVzIE4zIHV0aWxpdHkgZnVuY3Rpb25zLlxuLy8gVGVzdHMgd2hldGhlciB0aGUgZ2l2ZW4gdGVybSByZXByZXNlbnRzIGFuIElSSVxuZnVuY3Rpb24gaXNOYW1lZE5vZGUodGVybSkge1xuICByZXR1cm4gISF0ZXJtICYmIHRlcm0udGVybVR5cGUgPT09ICdOYW1lZE5vZGUnO1xufSAvLyBUZXN0cyB3aGV0aGVyIHRoZSBnaXZlbiB0ZXJtIHJlcHJlc2VudHMgYSBibGFuayBub2RlXG5cblxuZnVuY3Rpb24gaXNCbGFua05vZGUodGVybSkge1xuICByZXR1cm4gISF0ZXJtICYmIHRlcm0udGVybVR5cGUgPT09ICdCbGFua05vZGUnO1xufSAvLyBUZXN0cyB3aGV0aGVyIHRoZSBnaXZlbiB0ZXJtIHJlcHJlc2VudHMgYSBsaXRlcmFsXG5cblxuZnVuY3Rpb24gaXNMaXRlcmFsKHRlcm0pIHtcbiAgcmV0dXJuICEhdGVybSAmJiB0ZXJtLnRlcm1UeXBlID09PSAnTGl0ZXJhbCc7XG59IC8vIFRlc3RzIHdoZXRoZXIgdGhlIGdpdmVuIHRlcm0gcmVwcmVzZW50cyBhIHZhcmlhYmxlXG5cblxuZnVuY3Rpb24gaXNWYXJpYWJsZSh0ZXJtKSB7XG4gIHJldHVybiAhIXRlcm0gJiYgdGVybS50ZXJtVHlwZSA9PT0gJ1ZhcmlhYmxlJztcbn0gLy8gVGVzdHMgd2hldGhlciB0aGUgZ2l2ZW4gdGVybSByZXByZXNlbnRzIHRoZSBkZWZhdWx0IGdyYXBoXG5cblxuZnVuY3Rpb24gaXNEZWZhdWx0R3JhcGgodGVybSkge1xuICByZXR1cm4gISF0ZXJtICYmIHRlcm0udGVybVR5cGUgPT09ICdEZWZhdWx0R3JhcGgnO1xufSAvLyBUZXN0cyB3aGV0aGVyIHRoZSBnaXZlbiBxdWFkIGlzIGluIHRoZSBkZWZhdWx0IGdyYXBoXG5cblxuZnVuY3Rpb24gaW5EZWZhdWx0R3JhcGgocXVhZCkge1xuICByZXR1cm4gaXNEZWZhdWx0R3JhcGgocXVhZC5ncmFwaCk7XG59IC8vIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByZXBlbmRzIHRoZSBnaXZlbiBJUkkgdG8gYSBsb2NhbCBuYW1lXG5cblxuZnVuY3Rpb24gcHJlZml4KGlyaSwgZmFjdG9yeSkge1xuICByZXR1cm4gcHJlZml4ZXMoe1xuICAgICcnOiBpcmlcbiAgfSwgZmFjdG9yeSkoJycpO1xufSAvLyBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgcmVnaXN0ZXJpbmcgYW5kIGV4cGFuZGluZyBwcmVmaXhlc1xuXG5cbmZ1bmN0aW9uIHByZWZpeGVzKGRlZmF1bHRQcmVmaXhlcywgZmFjdG9yeSkge1xuICAvLyBBZGQgYWxsIG9mIHRoZSBkZWZhdWx0IHByZWZpeGVzXG4gIHZhciBwcmVmaXhlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIgcHJlZml4IGluIGRlZmF1bHRQcmVmaXhlcykgcHJvY2Vzc1ByZWZpeChwcmVmaXgsIGRlZmF1bHRQcmVmaXhlc1twcmVmaXhdKTsgLy8gU2V0IHRoZSBkZWZhdWx0IGZhY3RvcnkgaWYgbm9uZSB3YXMgc3BlY2lmaWVkXG5cblxuICBmYWN0b3J5ID0gZmFjdG9yeSB8fCBfTjNEYXRhRmFjdG9yeS5kZWZhdWx0OyAvLyBSZWdpc3RlcnMgYSBuZXcgcHJlZml4IChpZiBhbiBJUkkgd2FzIHNwZWNpZmllZClcbiAgLy8gb3IgcmV0cmlldmVzIGEgZnVuY3Rpb24gdGhhdCBleHBhbmRzIGFuIGV4aXN0aW5nIHByZWZpeCAoaWYgbm8gSVJJIHdhcyBzcGVjaWZpZWQpXG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1ByZWZpeChwcmVmaXgsIGlyaSkge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBwcmVmaXggaWYgYW4gSVJJIGlzIHNwZWNpZmllZCBvciB0aGUgcHJlZml4IGRvZXNuJ3QgZXhpc3RcbiAgICBpZiAodHlwZW9mIGlyaSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgZXhwYW5kcyB0aGUgcHJlZml4XG4gICAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICBwcmVmaXhlc1twcmVmaXhdID0gZnVuY3Rpb24gKGxvY2FsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtsb2NhbF0gfHwgKGNhY2hlW2xvY2FsXSA9IGZhY3RvcnkubmFtZWROb2RlKGlyaSArIGxvY2FsKSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIShwcmVmaXggaW4gcHJlZml4ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJlZml4OiAnICsgcHJlZml4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ZXNbcHJlZml4XTtcbiAgfVxuXG4gIHJldHVybiBwcm9jZXNzUHJlZml4O1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX0lSSXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0lSSXNcIikpO1xuXG52YXIgX04zRGF0YUZhY3RvcnkgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9OM0RhdGFGYWN0b3J5XCIpKTtcblxudmFyIF9OM1V0aWwgPSByZXF1aXJlKFwiLi9OM1V0aWxcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyAqKk4zV3JpdGVyKiogd3JpdGVzIE4zIGRvY3VtZW50cy5cbmNvbnN0IERFRkFVTFRHUkFQSCA9IF9OM0RhdGFGYWN0b3J5LmRlZmF1bHQuZGVmYXVsdEdyYXBoKCk7XG5cbmNvbnN0IHtcbiAgcmRmLFxuICB4c2Rcbn0gPSBfSVJJcy5kZWZhdWx0OyAvLyBDaGFyYWN0ZXJzIGluIGxpdGVyYWxzIHRoYXQgcmVxdWlyZSBlc2NhcGluZ1xuXG52YXIgZXNjYXBlID0gL1tcIlxcXFxcXHRcXG5cXHJcXGJcXGZcXHUwMDAwLVxcdTAwMTlcXHVkODAwLVxcdWRiZmZdLyxcbiAgICBlc2NhcGVBbGwgPSAvW1wiXFxcXFxcdFxcblxcclxcYlxcZlxcdTAwMDAtXFx1MDAxOV18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXS9nLFxuICAgIGVzY2FwZWRDaGFyYWN0ZXJzID0ge1xuICAnXFxcXCc6ICdcXFxcXFxcXCcsXG4gICdcIic6ICdcXFxcXCInLFxuICAnXFx0JzogJ1xcXFx0JyxcbiAgJ1xcbic6ICdcXFxcbicsXG4gICdcXHInOiAnXFxcXHInLFxuICAnXFxiJzogJ1xcXFxiJyxcbiAgJ1xcZic6ICdcXFxcZidcbn07IC8vICMjIFBsYWNlaG9sZGVyIGNsYXNzIHRvIHJlcHJlc2VudCBhbHJlYWR5IHByZXR0eS1wcmludGVkIHRlcm1zXG5cbmNsYXNzIFNlcmlhbGl6ZWRUZXJtIGV4dGVuZHMgX04zRGF0YUZhY3RvcnkuVGVybSB7XG4gIC8vIFByZXR0eS1wcmludGVkIG5vZGVzIGFyZSBub3QgZXF1YWwgdG8gYW55IG90aGVyIG5vZGVcbiAgLy8gKGUuZy4sIFtdIGRvZXMgbm90IGVxdWFsIFtdKVxuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn0gLy8gIyMgQ29uc3RydWN0b3JcblxuXG5jbGFzcyBOM1dyaXRlciB7XG4gIGNvbnN0cnVjdG9yKG91dHB1dFN0cmVhbSwgb3B0aW9ucykge1xuICAgIC8vICMjIyBgX3ByZWZpeFJlZ2V4YCBtYXRjaGVzIGEgcHJlZml4ZWQgbmFtZSBvciBJUkkgdGhhdCBiZWdpbnMgd2l0aCBvbmUgb2YgdGhlIGFkZGVkIHByZWZpeGVzXG4gICAgdGhpcy5fcHJlZml4UmVnZXggPSAvJDBeLzsgLy8gU2hpZnQgYXJndW1lbnRzIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBub3QgYSBzdHJlYW1cblxuICAgIGlmIChvdXRwdXRTdHJlYW0gJiYgdHlwZW9mIG91dHB1dFN0cmVhbS53cml0ZSAhPT0gJ2Z1bmN0aW9uJykgb3B0aW9ucyA9IG91dHB1dFN0cmVhbSwgb3V0cHV0U3RyZWFtID0gbnVsbDtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9saXN0cyA9IG9wdGlvbnMubGlzdHM7IC8vIElmIG5vIG91dHB1dCBzdHJlYW0gZ2l2ZW4sIHNlbmQgdGhlIG91dHB1dCBhcyBzdHJpbmcgdGhyb3VnaCB0aGUgZW5kIGNhbGxiYWNrXG5cbiAgICBpZiAoIW91dHB1dFN0cmVhbSkge1xuICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtID0ge1xuICAgICAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICAgICAgICBvdXRwdXQgKz0gY2h1bms7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kOiBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgIGRvbmUgJiYgZG9uZShudWxsLCBvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5fZW5kU3RyZWFtID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtID0gb3V0cHV0U3RyZWFtO1xuICAgICAgdGhpcy5fZW5kU3RyZWFtID0gb3B0aW9ucy5lbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIW9wdGlvbnMuZW5kO1xuICAgIH0gLy8gSW5pdGlhbGl6ZSB3cml0ZXIsIGRlcGVuZGluZyBvbiB0aGUgZm9ybWF0XG5cblxuICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuXG4gICAgaWYgKCEvdHJpcGxlfHF1YWQvaS50ZXN0KG9wdGlvbnMuZm9ybWF0KSkge1xuICAgICAgdGhpcy5fZ3JhcGggPSBERUZBVUxUR1JBUEg7XG4gICAgICB0aGlzLl9wcmVmaXhJUklzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG9wdGlvbnMucHJlZml4ZXMgJiYgdGhpcy5hZGRQcmVmaXhlcyhvcHRpb25zLnByZWZpeGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd3JpdGVRdWFkID0gdGhpcy5fd3JpdGVRdWFkTGluZTtcbiAgICB9XG4gIH0gLy8gIyMgUHJpdmF0ZSBtZXRob2RzXG4gIC8vICMjIyBXaGV0aGVyIHRoZSBjdXJyZW50IGdyYXBoIGlzIHRoZSBkZWZhdWx0IGdyYXBoXG5cblxuICBnZXQgX2luRGVmYXVsdEdyYXBoKCkge1xuICAgIHJldHVybiBERUZBVUxUR1JBUEguZXF1YWxzKHRoaXMuX2dyYXBoKTtcbiAgfSAvLyAjIyMgYF93cml0ZWAgd3JpdGVzIHRoZSBhcmd1bWVudCB0byB0aGUgb3V0cHV0IHN0cmVhbVxuXG5cbiAgX3dyaXRlKHN0cmluZywgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vdXRwdXRTdHJlYW0ud3JpdGUoc3RyaW5nLCAndXRmOCcsIGNhbGxiYWNrKTtcbiAgfSAvLyAjIyMgYF93cml0ZVF1YWRgIHdyaXRlcyB0aGUgcXVhZCB0byB0aGUgb3V0cHV0IHN0cmVhbVxuXG5cbiAgX3dyaXRlUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgsIGRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gV3JpdGUgdGhlIGdyYXBoJ3MgbGFiZWwgaWYgaXQgaGFzIGNoYW5nZWRcbiAgICAgIGlmICghZ3JhcGguZXF1YWxzKHRoaXMuX2dyYXBoKSkge1xuICAgICAgICAvLyBDbG9zZSB0aGUgcHJldmlvdXMgZ3JhcGggYW5kIHN0YXJ0IHRoZSBuZXcgb25lXG4gICAgICAgIHRoaXMuX3dyaXRlKCh0aGlzLl9zdWJqZWN0ID09PSBudWxsID8gJycgOiB0aGlzLl9pbkRlZmF1bHRHcmFwaCA/ICcuXFxuJyA6ICdcXG59XFxuJykgKyAoREVGQVVMVEdSQVBILmVxdWFscyhncmFwaCkgPyAnJyA6IHRoaXMuX2VuY29kZUlyaU9yQmxhbmsoZ3JhcGgpICsgJyB7XFxuJykpO1xuXG4gICAgICAgIHRoaXMuX2dyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgfSAvLyBEb24ndCByZXBlYXQgdGhlIHN1YmplY3QgaWYgaXQncyB0aGUgc2FtZVxuXG5cbiAgICAgIGlmIChzdWJqZWN0LmVxdWFscyh0aGlzLl9zdWJqZWN0KSkge1xuICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIHByZWRpY2F0ZSBpZiBpdCdzIHRoZSBzYW1lXG4gICAgICAgIGlmIChwcmVkaWNhdGUuZXF1YWxzKHRoaXMuX3ByZWRpY2F0ZSkpIHRoaXMuX3dyaXRlKCcsICcgKyB0aGlzLl9lbmNvZGVPYmplY3Qob2JqZWN0KSwgZG9uZSk7IC8vIFNhbWUgc3ViamVjdCwgZGlmZmVyZW50IHByZWRpY2F0ZVxuICAgICAgICBlbHNlIHRoaXMuX3dyaXRlKCc7XFxuICAgICcgKyB0aGlzLl9lbmNvZGVQcmVkaWNhdGUodGhpcy5fcHJlZGljYXRlID0gcHJlZGljYXRlKSArICcgJyArIHRoaXMuX2VuY29kZU9iamVjdChvYmplY3QpLCBkb25lKTtcbiAgICAgIH0gLy8gRGlmZmVyZW50IHN1YmplY3Q7IHdyaXRlIHRoZSB3aG9sZSBxdWFkXG4gICAgICBlbHNlIHRoaXMuX3dyaXRlKCh0aGlzLl9zdWJqZWN0ID09PSBudWxsID8gJycgOiAnLlxcbicpICsgdGhpcy5fZW5jb2RlU3ViamVjdCh0aGlzLl9zdWJqZWN0ID0gc3ViamVjdCkgKyAnICcgKyB0aGlzLl9lbmNvZGVQcmVkaWNhdGUodGhpcy5fcHJlZGljYXRlID0gcHJlZGljYXRlKSArICcgJyArIHRoaXMuX2VuY29kZU9iamVjdChvYmplY3QpLCBkb25lKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZG9uZSAmJiBkb25lKGVycm9yKTtcbiAgICB9XG4gIH0gLy8gIyMjIGBfd3JpdGVRdWFkTGluZWAgd3JpdGVzIHRoZSBxdWFkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFzIGEgc2luZ2xlIGxpbmVcblxuXG4gIF93cml0ZVF1YWRMaW5lKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCwgZG9uZSkge1xuICAgIC8vIFdyaXRlIHRoZSBxdWFkIHdpdGhvdXQgcHJlZml4ZXNcbiAgICBkZWxldGUgdGhpcy5fcHJlZml4TWF0Y2g7XG5cbiAgICB0aGlzLl93cml0ZSh0aGlzLnF1YWRUb1N0cmluZyhzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpLCBkb25lKTtcbiAgfSAvLyAjIyMgYHF1YWRUb1N0cmluZ2Agc2VyaWFsaXplcyBhIHF1YWQgYXMgYSBzdHJpbmdcblxuXG4gIHF1YWRUb1N0cmluZyhzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3ViamVjdChzdWJqZWN0KSArICcgJyArIHRoaXMuX2VuY29kZUlyaU9yQmxhbmsocHJlZGljYXRlKSArICcgJyArIHRoaXMuX2VuY29kZU9iamVjdChvYmplY3QpICsgKGdyYXBoICYmIGdyYXBoLnZhbHVlID8gJyAnICsgdGhpcy5fZW5jb2RlSXJpT3JCbGFuayhncmFwaCkgKyAnIC5cXG4nIDogJyAuXFxuJyk7XG4gIH0gLy8gIyMjIGBxdWFkc1RvU3RyaW5nYCBzZXJpYWxpemVzIGFuIGFycmF5IG9mIHF1YWRzIGFzIGEgc3RyaW5nXG5cblxuICBxdWFkc1RvU3RyaW5nKHF1YWRzKSB7XG4gICAgcmV0dXJuIHF1YWRzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMucXVhZFRvU3RyaW5nKHQuc3ViamVjdCwgdC5wcmVkaWNhdGUsIHQub2JqZWN0LCB0LmdyYXBoKTtcbiAgICB9LCB0aGlzKS5qb2luKCcnKTtcbiAgfSAvLyAjIyMgYF9lbmNvZGVTdWJqZWN0YCByZXByZXNlbnRzIGEgc3ViamVjdFxuXG5cbiAgX2VuY29kZVN1YmplY3QoZW50aXR5KSB7XG4gICAgcmV0dXJuIGVudGl0eS50ZXJtVHlwZSA9PT0gJ1F1YWQnID8gdGhpcy5fZW5jb2RlUXVhZChlbnRpdHkpIDogdGhpcy5fZW5jb2RlSXJpT3JCbGFuayhlbnRpdHkpO1xuICB9IC8vICMjIyBgX2VuY29kZUlyaU9yQmxhbmtgIHJlcHJlc2VudHMgYW4gSVJJIG9yIGJsYW5rIG5vZGVcblxuXG4gIF9lbmNvZGVJcmlPckJsYW5rKGVudGl0eSkge1xuICAgIC8vIEEgYmxhbmsgbm9kZSBvciBsaXN0IGlzIHJlcHJlc2VudGVkIGFzLWlzXG4gICAgaWYgKGVudGl0eS50ZXJtVHlwZSAhPT0gJ05hbWVkTm9kZScpIHtcbiAgICAgIC8vIElmIGl0IGlzIGEgbGlzdCBoZWFkLCBwcmV0dHktcHJpbnQgaXRcbiAgICAgIGlmICh0aGlzLl9saXN0cyAmJiBlbnRpdHkudmFsdWUgaW4gdGhpcy5fbGlzdHMpIGVudGl0eSA9IHRoaXMubGlzdCh0aGlzLl9saXN0c1tlbnRpdHkudmFsdWVdKTtcbiAgICAgIHJldHVybiAnaWQnIGluIGVudGl0eSA/IGVudGl0eS5pZCA6ICdfOicgKyBlbnRpdHkudmFsdWU7XG4gICAgfSAvLyBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzXG5cblxuICAgIHZhciBpcmkgPSBlbnRpdHkudmFsdWU7XG4gICAgaWYgKGVzY2FwZS50ZXN0KGlyaSkpIGlyaSA9IGlyaS5yZXBsYWNlKGVzY2FwZUFsbCwgY2hhcmFjdGVyUmVwbGFjZXIpOyAvLyBUcnkgdG8gcmVwcmVzZW50IHRoZSBJUkkgYXMgcHJlZml4ZWQgbmFtZVxuXG4gICAgdmFyIHByZWZpeE1hdGNoID0gdGhpcy5fcHJlZml4UmVnZXguZXhlYyhpcmkpO1xuXG4gICAgcmV0dXJuICFwcmVmaXhNYXRjaCA/ICc8JyArIGlyaSArICc+JyA6ICFwcmVmaXhNYXRjaFsxXSA/IGlyaSA6IHRoaXMuX3ByZWZpeElSSXNbcHJlZml4TWF0Y2hbMV1dICsgcHJlZml4TWF0Y2hbMl07XG4gIH0gLy8gIyMjIGBfZW5jb2RlTGl0ZXJhbGAgcmVwcmVzZW50cyBhIGxpdGVyYWxcblxuXG4gIF9lbmNvZGVMaXRlcmFsKGxpdGVyYWwpIHtcbiAgICAvLyBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgdmFyIHZhbHVlID0gbGl0ZXJhbC52YWx1ZTtcbiAgICBpZiAoZXNjYXBlLnRlc3QodmFsdWUpKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoZXNjYXBlQWxsLCBjaGFyYWN0ZXJSZXBsYWNlcik7IC8vIFdyaXRlIHRoZSBsaXRlcmFsLCBwb3NzaWJseSB3aXRoIHR5cGUgb3IgbGFuZ3VhZ2VcblxuICAgIGlmIChsaXRlcmFsLmxhbmd1YWdlKSByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiQCcgKyBsaXRlcmFsLmxhbmd1YWdlO2Vsc2UgaWYgKGxpdGVyYWwuZGF0YXR5cGUudmFsdWUgIT09IHhzZC5zdHJpbmcpIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCJeXicgKyB0aGlzLl9lbmNvZGVJcmlPckJsYW5rKGxpdGVyYWwuZGF0YXR5cGUpO2Vsc2UgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG4gIH0gLy8gIyMjIGBfZW5jb2RlUHJlZGljYXRlYCByZXByZXNlbnRzIGEgcHJlZGljYXRlXG5cblxuICBfZW5jb2RlUHJlZGljYXRlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBwcmVkaWNhdGUudmFsdWUgPT09IHJkZi50eXBlID8gJ2EnIDogdGhpcy5fZW5jb2RlSXJpT3JCbGFuayhwcmVkaWNhdGUpO1xuICB9IC8vICMjIyBgX2VuY29kZU9iamVjdGAgcmVwcmVzZW50cyBhbiBvYmplY3RcblxuXG4gIF9lbmNvZGVPYmplY3Qob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QudGVybVR5cGUpIHtcbiAgICAgIGNhc2UgJ1F1YWQnOlxuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUXVhZChvYmplY3QpO1xuXG4gICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUxpdGVyYWwob2JqZWN0KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUlyaU9yQmxhbmsob2JqZWN0KTtcbiAgICB9XG4gIH0gLy8gIyMjIGBfZW5jb2RlUXVhZGAgZW5jb2RlcyBhbiBSREYqIHF1YWRcblxuXG4gIF9lbmNvZGVRdWFkKHtcbiAgICBzdWJqZWN0LFxuICAgIHByZWRpY2F0ZSxcbiAgICBvYmplY3QsXG4gICAgZ3JhcGhcbiAgfSkge1xuICAgIHJldHVybiBgPDwke3RoaXMuX2VuY29kZVN1YmplY3Qoc3ViamVjdCl9ICR7dGhpcy5fZW5jb2RlUHJlZGljYXRlKHByZWRpY2F0ZSl9ICR7dGhpcy5fZW5jb2RlT2JqZWN0KG9iamVjdCl9JHsoMCwgX04zVXRpbC5pc0RlZmF1bHRHcmFwaCkoZ3JhcGgpID8gJycgOiBgICR7dGhpcy5fZW5jb2RlSXJpT3JCbGFuayhncmFwaCl9YH0+PmA7XG4gIH0gLy8gIyMjIGBfYmxvY2tlZFdyaXRlYCByZXBsYWNlcyBgX3dyaXRlYCBhZnRlciB0aGUgd3JpdGVyIGhhcyBiZWVuIGNsb3NlZFxuXG5cbiAgX2Jsb2NrZWRXcml0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB3cml0ZSBiZWNhdXNlIHRoZSB3cml0ZXIgaGFzIGJlZW4gY2xvc2VkLicpO1xuICB9IC8vICMjIyBgYWRkUXVhZGAgYWRkcyB0aGUgcXVhZCB0byB0aGUgb3V0cHV0IHN0cmVhbVxuXG5cbiAgYWRkUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgsIGRvbmUpIHtcbiAgICAvLyBUaGUgcXVhZCB3YXMgZ2l2ZW4gYXMgYW4gb2JqZWN0LCBzbyBzaGlmdCBwYXJhbWV0ZXJzXG4gICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB0aGlzLl93cml0ZVF1YWQoc3ViamVjdC5zdWJqZWN0LCBzdWJqZWN0LnByZWRpY2F0ZSwgc3ViamVjdC5vYmplY3QsIHN1YmplY3QuZ3JhcGgsIHByZWRpY2F0ZSk7IC8vIFRoZSBvcHRpb25hbCBgZ3JhcGhgIHBhcmFtZXRlciB3YXMgbm90IHByb3ZpZGVkXG4gICAgZWxzZSBpZiAodHlwZW9mIGdyYXBoID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZVF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIERFRkFVTFRHUkFQSCwgZ3JhcGgpOyAvLyBUaGUgYGdyYXBoYCBwYXJhbWV0ZXIgd2FzIHByb3ZpZGVkXG4gICAgICBlbHNlIHRoaXMuX3dyaXRlUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGggfHwgREVGQVVMVEdSQVBILCBkb25lKTtcbiAgfSAvLyAjIyMgYGFkZFF1YWRzYCBhZGRzIHRoZSBxdWFkcyB0byB0aGUgb3V0cHV0IHN0cmVhbVxuXG5cbiAgYWRkUXVhZHMocXVhZHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1YWRzLmxlbmd0aDsgaSsrKSB0aGlzLmFkZFF1YWQocXVhZHNbaV0pO1xuICB9IC8vICMjIyBgYWRkUHJlZml4YCBhZGRzIHRoZSBwcmVmaXggdG8gdGhlIG91dHB1dCBzdHJlYW1cblxuXG4gIGFkZFByZWZpeChwcmVmaXgsIGlyaSwgZG9uZSkge1xuICAgIHZhciBwcmVmaXhlcyA9IHt9O1xuICAgIHByZWZpeGVzW3ByZWZpeF0gPSBpcmk7XG4gICAgdGhpcy5hZGRQcmVmaXhlcyhwcmVmaXhlcywgZG9uZSk7XG4gIH0gLy8gIyMjIGBhZGRQcmVmaXhlc2AgYWRkcyB0aGUgcHJlZml4ZXMgdG8gdGhlIG91dHB1dCBzdHJlYW1cblxuXG4gIGFkZFByZWZpeGVzKHByZWZpeGVzLCBkb25lKSB7XG4gICAgdmFyIHByZWZpeElSSXMgPSB0aGlzLl9wcmVmaXhJUklzLFxuICAgICAgICBoYXNQcmVmaXhlcyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgcHJlZml4IGluIHByZWZpeGVzKSB7XG4gICAgICB2YXIgaXJpID0gcHJlZml4ZXNbcHJlZml4XTtcbiAgICAgIGlmICh0eXBlb2YgaXJpICE9PSAnc3RyaW5nJykgaXJpID0gaXJpLnZhbHVlO1xuICAgICAgaGFzUHJlZml4ZXMgPSB0cnVlOyAvLyBGaW5pc2ggYSBwb3NzaWJsZSBwZW5kaW5nIHF1YWRcblxuICAgICAgaWYgKHRoaXMuX3N1YmplY3QgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fd3JpdGUodGhpcy5faW5EZWZhdWx0R3JhcGggPyAnLlxcbicgOiAnXFxufVxcbicpO1xuXG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsLCB0aGlzLl9ncmFwaCA9ICcnO1xuICAgICAgfSAvLyBTdG9yZSBhbmQgd3JpdGUgdGhlIHByZWZpeFxuXG5cbiAgICAgIHByZWZpeElSSXNbaXJpXSA9IHByZWZpeCArPSAnOic7XG5cbiAgICAgIHRoaXMuX3dyaXRlKCdAcHJlZml4ICcgKyBwcmVmaXggKyAnIDwnICsgaXJpICsgJz4uXFxuJyk7XG4gICAgfSAvLyBSZWNyZWF0ZSB0aGUgcHJlZml4IG1hdGNoZXJcblxuXG4gICAgaWYgKGhhc1ByZWZpeGVzKSB7XG4gICAgICB2YXIgSVJJbGlzdCA9ICcnLFxuICAgICAgICAgIHByZWZpeExpc3QgPSAnJztcblxuICAgICAgZm9yICh2YXIgcHJlZml4SVJJIGluIHByZWZpeElSSXMpIHtcbiAgICAgICAgSVJJbGlzdCArPSBJUklsaXN0ID8gJ3wnICsgcHJlZml4SVJJIDogcHJlZml4SVJJO1xuICAgICAgICBwcmVmaXhMaXN0ICs9IChwcmVmaXhMaXN0ID8gJ3wnIDogJycpICsgcHJlZml4SVJJc1twcmVmaXhJUkldO1xuICAgICAgfVxuXG4gICAgICBJUklsaXN0ID0gSVJJbGlzdC5yZXBsYWNlKC9bXFxdXFwvXFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcJF0vZywgJ1xcXFwkJicpO1xuICAgICAgdGhpcy5fcHJlZml4UmVnZXggPSBuZXcgUmVnRXhwKCdeKD86JyArIHByZWZpeExpc3QgKyAnKVteXFwvXSokfCcgKyAnXignICsgSVJJbGlzdCArICcpKFthLXpBLVpdW1xcXFwtX2EtekEtWjAtOV0qKSQnKTtcbiAgICB9IC8vIEVuZCBhIHByZWZpeCBibG9jayB3aXRoIGEgbmV3bGluZVxuXG5cbiAgICB0aGlzLl93cml0ZShoYXNQcmVmaXhlcyA/ICdcXG4nIDogJycsIGRvbmUpO1xuICB9IC8vICMjIyBgYmxhbmtgIGNyZWF0ZXMgYSBibGFuayBub2RlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnRcblxuXG4gIGJsYW5rKHByZWRpY2F0ZSwgb2JqZWN0KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJlZGljYXRlLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbGVuZ3RoOyAvLyBFbXB0eSBibGFuayBub2RlXG5cbiAgICBpZiAocHJlZGljYXRlID09PSB1bmRlZmluZWQpIGNoaWxkcmVuID0gW107IC8vIEJsYW5rIG5vZGUgcGFzc2VkIGFzIGJsYW5rKFRlcm0oXCJwcmVkaWNhdGVcIiksIFRlcm0oXCJvYmplY3RcIikpXG4gICAgZWxzZSBpZiAocHJlZGljYXRlLnRlcm1UeXBlKSBjaGlsZHJlbiA9IFt7XG4gICAgICAgIHByZWRpY2F0ZTogcHJlZGljYXRlLFxuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfV07IC8vIEJsYW5rIG5vZGUgcGFzc2VkIGFzIGJsYW5rKHsgcHJlZGljYXRlOiBwcmVkaWNhdGUsIG9iamVjdDogb2JqZWN0IH0pXG4gICAgICBlbHNlIGlmICghKCdsZW5ndGgnIGluIHByZWRpY2F0ZSkpIGNoaWxkcmVuID0gW3ByZWRpY2F0ZV07XG5cbiAgICBzd2l0Y2ggKGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gR2VuZXJhdGUgYW4gZW1wdHkgYmxhbmsgbm9kZVxuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gbmV3IFNlcmlhbGl6ZWRUZXJtKCdbXScpO1xuICAgICAgLy8gR2VuZXJhdGUgYSBub24tbmVzdGVkIG9uZS10cmlwbGUgYmxhbmsgbm9kZVxuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghKGNoaWxkLm9iamVjdCBpbnN0YW5jZW9mIFNlcmlhbGl6ZWRUZXJtKSkgcmV0dXJuIG5ldyBTZXJpYWxpemVkVGVybSgnWyAnICsgdGhpcy5fZW5jb2RlUHJlZGljYXRlKGNoaWxkLnByZWRpY2F0ZSkgKyAnICcgKyB0aGlzLl9lbmNvZGVPYmplY3QoY2hpbGQub2JqZWN0KSArICcgXScpO1xuICAgICAgLy8gR2VuZXJhdGUgYSBtdWx0aS10cmlwbGUgb3IgbmVzdGVkIGJsYW5rIG5vZGVcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGNvbnRlbnRzID0gJ1snOyAvLyBXcml0ZSBhbGwgdHJpcGxlcyBpbiBvcmRlclxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldOyAvLyBXcml0ZSBvbmx5IHRoZSBvYmplY3QgaXMgdGhlIHByZWRpY2F0ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXNcblxuICAgICAgICAgIGlmIChjaGlsZC5wcmVkaWNhdGUuZXF1YWxzKHByZWRpY2F0ZSkpIGNvbnRlbnRzICs9ICcsICcgKyB0aGlzLl9lbmNvZGVPYmplY3QoY2hpbGQub2JqZWN0KTsgLy8gT3RoZXJ3aXNlLCB3cml0ZSB0aGUgcHJlZGljYXRlIGFuZCB0aGUgb2JqZWN0XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRzICs9IChpID8gJztcXG4gICcgOiAnXFxuICAnKSArIHRoaXMuX2VuY29kZVByZWRpY2F0ZShjaGlsZC5wcmVkaWNhdGUpICsgJyAnICsgdGhpcy5fZW5jb2RlT2JqZWN0KGNoaWxkLm9iamVjdCk7XG4gICAgICAgICAgICAgIHByZWRpY2F0ZSA9IGNoaWxkLnByZWRpY2F0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU2VyaWFsaXplZFRlcm0oY29udGVudHMgKyAnXFxuXScpO1xuICAgIH1cbiAgfSAvLyAjIyMgYGxpc3RgIGNyZWF0ZXMgYSBsaXN0IG5vZGUgd2l0aCB0aGUgZ2l2ZW4gY29udGVudFxuXG5cbiAgbGlzdChlbGVtZW50cykge1xuICAgIHZhciBsZW5ndGggPSBlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggfHwgMCxcbiAgICAgICAgY29udGVudHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGNvbnRlbnRzW2ldID0gdGhpcy5fZW5jb2RlT2JqZWN0KGVsZW1lbnRzW2ldKTtcblxuICAgIHJldHVybiBuZXcgU2VyaWFsaXplZFRlcm0oJygnICsgY29udGVudHMuam9pbignICcpICsgJyknKTtcbiAgfSAvLyAjIyMgYGVuZGAgc2lnbmFscyB0aGUgZW5kIG9mIHRoZSBvdXRwdXQgc3RyZWFtXG5cblxuICBlbmQoZG9uZSkge1xuICAgIC8vIEZpbmlzaCBhIHBvc3NpYmxlIHBlbmRpbmcgcXVhZFxuICAgIGlmICh0aGlzLl9zdWJqZWN0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl93cml0ZSh0aGlzLl9pbkRlZmF1bHRHcmFwaCA/ICcuXFxuJyA6ICdcXG59XFxuJyk7XG5cbiAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgIH0gLy8gRGlzYWxsb3cgZnVydGhlciB3cml0aW5nXG5cblxuICAgIHRoaXMuX3dyaXRlID0gdGhpcy5fYmxvY2tlZFdyaXRlOyAvLyBUcnkgdG8gZW5kIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSwgZW5zdXJpbmcgZG9uZSBpcyBjYWxsZWQgZXhhY3RseSBvbmUgdGltZVxuXG4gICAgdmFyIHNpbmdsZURvbmUgPSBkb25lICYmIGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0KSB7XG4gICAgICBzaW5nbGVEb25lID0gbnVsbCwgZG9uZShlcnJvciwgcmVzdWx0KTtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2VuZFN0cmVhbSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX291dHB1dFN0cmVhbS5lbmQoc2luZ2xlRG9uZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvKiBlcnJvciBjbG9zaW5nIHN0cmVhbSAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIHNpbmdsZURvbmUgJiYgc2luZ2xlRG9uZSgpO1xuICB9XG5cbn0gLy8gUmVwbGFjZXMgYSBjaGFyYWN0ZXIgYnkgaXRzIGVzY2FwZWQgdmVyc2lvblxuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IE4zV3JpdGVyO1xuXG5mdW5jdGlvbiBjaGFyYWN0ZXJSZXBsYWNlcihjaGFyYWN0ZXIpIHtcbiAgLy8gUmVwbGFjZSBhIHNpbmdsZSBjaGFyYWN0ZXIgYnkgaXRzIGVzY2FwZWQgdmVyc2lvblxuICB2YXIgcmVzdWx0ID0gZXNjYXBlZENoYXJhY3RlcnNbY2hhcmFjdGVyXTtcblxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBSZXBsYWNlIGEgc2luZ2xlIGNoYXJhY3RlciB3aXRoIGl0cyA0LWJpdCB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZVxuICAgIGlmIChjaGFyYWN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXN1bHQgPSBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICByZXN1bHQgPSAnXFxcXHUwMDAwJy5zdWJzdHIoMCwgNiAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0O1xuICAgIH0gLy8gUmVwbGFjZSBhIHN1cnJvZ2F0ZSBwYWlyIHdpdGggaXRzIDgtYml0IHVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlXG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9ICgoY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDAgKyBjaGFyYWN0ZXIuY2hhckNvZGVBdCgxKSArIDB4MjQwMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXN1bHQgPSAnXFxcXFUwMDAwMDAwMCcuc3Vic3RyKDAsIDEwIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQ7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGV4ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zTGV4ZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJzZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zUGFyc2VyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV3JpdGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM1dyaXRlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0b3JlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM1N0b3JlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RyZWFtUGFyc2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM1N0cmVhbVBhcnNlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmVhbVdyaXRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNTdHJlYW1Xcml0ZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRhRmFjdG9yeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNEYXRhRmFjdG9yeS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRlcm1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zRGF0YUZhY3RvcnkuVGVybTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lZE5vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zRGF0YUZhY3RvcnkuTmFtZWROb2RlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpdGVyYWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zRGF0YUZhY3RvcnkuTGl0ZXJhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCbGFua05vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zRGF0YUZhY3RvcnkuQmxhbmtOb2RlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhcmlhYmxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM0RhdGFGYWN0b3J5LlZhcmlhYmxlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlZmF1bHRHcmFwaFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNEYXRhRmFjdG9yeS5EZWZhdWx0R3JhcGg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUXVhZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNEYXRhRmFjdG9yeS5RdWFkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyaXBsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNEYXRhRmFjdG9yeS5UcmlwbGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidGVybUZyb21JZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNEYXRhRmFjdG9yeS50ZXJtRnJvbUlkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRlcm1Ub0lkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkO1xuICB9XG59KTtcbmV4cG9ydHMuVXRpbCA9IHZvaWQgMDtcblxudmFyIF9OM0xleGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9OM0xleGVyXCIpKTtcblxudmFyIF9OM1BhcnNlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTjNQYXJzZXJcIikpO1xuXG52YXIgX04zV3JpdGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9OM1dyaXRlclwiKSk7XG5cbnZhciBfTjNTdG9yZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTjNTdG9yZVwiKSk7XG5cbnZhciBfTjNTdHJlYW1QYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL04zU3RyZWFtUGFyc2VyXCIpKTtcblxudmFyIF9OM1N0cmVhbVdyaXRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTjNTdHJlYW1Xcml0ZXJcIikpO1xuXG52YXIgVXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL04zVXRpbFwiKSk7XG5cbmV4cG9ydHMuVXRpbCA9IFV0aWw7XG5cbnZhciBfTjNEYXRhRmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL04zRGF0YUZhY3RvcnlcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCIvKipcbiAqIEJhc2UtTi9CYXNlLVggZW5jb2RpbmcvZGVjb2RpbmcgZnVuY3Rpb25zLlxuICpcbiAqIE9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGZyb20gYmFzZS14OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iYXNlLXhcbiAqXG4gKiBXaGljaCBpcyBNSVQgbGljZW5zZWQ6XG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IGJhc2UteCBjb250cmlidXRvcnMgKGMpIDIwMTZcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG52YXIgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLy8gYmFzZU4gYWxwaGFiZXQgaW5kZXhlc1xudmFyIF9yZXZlcnNlQWxwaGFiZXRzID0ge307XG5cbi8qKlxuICogQmFzZU4tZW5jb2RlcyBhIFVpbnQ4QXJyYXkgdXNpbmcgdGhlIGdpdmVuIGFscGhhYmV0LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgVWludDhBcnJheSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZW5jb2RlZCBjaGFyYWN0ZXJzIHBlciBsaW5lIHRvIHVzZSxcbiAqICAgICAgICAgIGRlZmF1bHRzIHRvIG5vbmUuXG4gKlxuICogQHJldHVybiB0aGUgYmFzZU4tZW5jb2RlZCBvdXRwdXQgc3RyaW5nLlxuICovXG5hcGkuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQsIGFscGhhYmV0LCBtYXhsaW5lKSB7XG4gIGlmKHR5cGVvZiBhbHBoYWJldCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFscGhhYmV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICBpZihtYXhsaW5lICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG1heGxpbmUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJtYXhsaW5lXCIgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICBpZighKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAvLyBhc3N1bWUgZm9yZ2UgYnl0ZSBidWZmZXJcbiAgICBvdXRwdXQgPSBfZW5jb2RlV2l0aEJ5dGVCdWZmZXIoaW5wdXQsIGFscGhhYmV0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gYWxwaGFiZXQuY2hhckF0KDApO1xuICAgIHZhciBkaWdpdHMgPSBbMF07XG4gICAgZm9yKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZvcih2YXIgaiA9IDAsIGNhcnJ5ID0gaW5wdXRbaV07IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDg7XG4gICAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgICBkaWdpdHMucHVzaChjYXJyeSAlIGJhc2UpO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIGJhc2UpIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgIGZvcihpID0gMDsgaW5wdXRbaV0gPT09IDAgJiYgaSA8IGlucHV0Lmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgb3V0cHV0ICs9IGZpcnN0O1xuICAgIH1cbiAgICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICAgIGZvcihpID0gZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBvdXRwdXQgKz0gYWxwaGFiZXRbZGlnaXRzW2ldXTtcbiAgICB9XG4gIH1cblxuICBpZihtYXhsaW5lKSB7XG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnLnsxLCcgKyBtYXhsaW5lICsgJ30nLCAnZycpO1xuICAgIG91dHB1dCA9IG91dHB1dC5tYXRjaChyZWdleCkuam9pbignXFxyXFxuJyk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZU4tZW5jb2RlZCAodXNpbmcgdGhlIGdpdmVuIGFscGhhYmV0KSBzdHJpbmcgdG8gYVxuICogVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJhc2VOLWVuY29kZWQgaW5wdXQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkuXG4gKi9cbmFwaS5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgYWxwaGFiZXQpIHtcbiAgaWYodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiaW5wdXRcIiBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG4gIGlmKHR5cGVvZiBhbHBoYWJldCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFscGhhYmV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIHZhciB0YWJsZSA9IF9yZXZlcnNlQWxwaGFiZXRzW2FscGhhYmV0XTtcbiAgaWYoIXRhYmxlKSB7XG4gICAgLy8gY29tcHV0ZSByZXZlcnNlIGFscGhhYmV0XG4gICAgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF0gPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRhYmxlW2FscGhhYmV0LmNoYXJDb2RlQXQoaSldID0gaTtcbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICB2YXIgYmFzZSA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgdmFyIGZpcnN0ID0gYWxwaGFiZXQuY2hhckF0KDApO1xuICB2YXIgYnl0ZXMgPSBbMF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IHRhYmxlW2lucHV0LmNoYXJDb2RlQXQoaSldO1xuICAgIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IHZhbHVlOyBqIDwgYnl0ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNhcnJ5ICs9IGJ5dGVzW2pdICogYmFzZTtcbiAgICAgIGJ5dGVzW2pdID0gY2FycnkgJiAweGZmO1xuICAgICAgY2FycnkgPj49IDg7XG4gICAgfVxuXG4gICAgd2hpbGUoY2FycnkgPiAwKSB7XG4gICAgICBieXRlcy5wdXNoKGNhcnJ5ICYgMHhmZik7XG4gICAgICBjYXJyeSA+Pj0gODtcbiAgICB9XG4gIH1cblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IodmFyIGsgPSAwOyBpbnB1dFtrXSA9PT0gZmlyc3QgJiYgayA8IGlucHV0Lmxlbmd0aCAtIDE7ICsraykge1xuICAgIGJ5dGVzLnB1c2goMCk7XG4gIH1cblxuICBpZih0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcy5yZXZlcnNlKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzLnJldmVyc2UoKSk7XG59O1xuXG5mdW5jdGlvbiBfZW5jb2RlV2l0aEJ5dGVCdWZmZXIoaW5wdXQsIGFscGhhYmV0KSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgdmFyIGRpZ2l0cyA9IFswXTtcbiAgZm9yKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoKCk7ICsraSkge1xuICAgIGZvcih2YXIgaiA9IDAsIGNhcnJ5ID0gaW5wdXQuYXQoaSk7IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSBiYXNlO1xuICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgfVxuXG4gICAgd2hpbGUoY2FycnkgPiAwKSB7XG4gICAgICBkaWdpdHMucHVzaChjYXJyeSAlIGJhc2UpO1xuICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dCA9ICcnO1xuXG4gIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gIGZvcihpID0gMDsgaW5wdXQuYXQoaSkgPT09IDAgJiYgaSA8IGlucHV0Lmxlbmd0aCgpIC0gMTsgKytpKSB7XG4gICAgb3V0cHV0ICs9IGZpcnN0O1xuICB9XG4gIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG4gIGZvcihpID0gZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuIiwiLyoqXG4gKiBOb2RlLmpzIG1vZHVsZSBmb3IgRm9yZ2UuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9uczoge1xuICAgIHVzZVB1cmVKYXZhU2NyaXB0OiBmYWxzZVxuICB9XG59O1xuIiwiLyoqXG4gKiBOb2RlLmpzIG1vZHVsZSBmb3IgRm9yZ2UgbWVzc2FnZSBkaWdlc3RzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UubWQgPSBmb3JnZS5tZCB8fCB7fTtcbmZvcmdlLm1kLmFsZ29yaXRobXMgPSBmb3JnZS5tZC5hbGdvcml0aG1zIHx8IHt9O1xuIiwiLyoqXG4gKiBTZWN1cmUgSGFzaCBBbGdvcml0aG0gd2l0aCAxNjAtYml0IGRpZ2VzdCAoU0hBLTEpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBzaGExID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGExID0gZm9yZ2Uuc2hhMSB8fCB7fTtcbmZvcmdlLm1kLnNoYTEgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTEgPSBzaGExO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTSEEtMSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMS5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG8gaW5pdGlhbGl6YXRpb24gYXMgbmVjZXNzYXJ5XG4gIGlmKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICBfaW5pdCgpO1xuICB9XG5cbiAgLy8gU0hBLTEgc3RhdGUgY29udGFpbnMgZml2ZSAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIF9zdGF0ZSA9IG51bGw7XG5cbiAgLy8gaW5wdXQgYnVmZmVyXG4gIHZhciBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZWQgZm9yIHdvcmQgc3RvcmFnZVxuICB2YXIgX3cgPSBuZXcgQXJyYXkoODApO1xuXG4gIC8vIG1lc3NhZ2UgZGlnZXN0IG9iamVjdFxuICB2YXIgbWQgPSB7XG4gICAgYWxnb3JpdGhtOiAnc2hhMScsXG4gICAgYmxvY2tMZW5ndGg6IDY0LFxuICAgIGRpZ2VzdExlbmd0aDogMjAsXG4gICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgbWVzc2FnZUxlbmd0aDogMCxcbiAgICAvLyB0cnVlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgLy8gc2l6ZSBvZiBtZXNzYWdlIGxlbmd0aCBpbiBieXRlc1xuICAgIG1lc3NhZ2VMZW5ndGhTaXplOiA4XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdXAgdG8gNTYtYml0IG1lc3NhZ2UgbGVuZ3RoIGZvciBjb252ZW5pZW5jZVxuICAgIG1kLm1lc3NhZ2VMZW5ndGggPSAwO1xuXG4gICAgLy8gZnVsbCBtZXNzYWdlIGxlbmd0aCAoc2V0IG1kLm1lc3NhZ2VMZW5ndGg2NCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkpXG4gICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoNjQgPSBbXTtcbiAgICB2YXIgaW50MzJzID0gbWQubWVzc2FnZUxlbmd0aFNpemUgLyA0O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGgucHVzaCgwKTtcbiAgICB9XG4gICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBfc3RhdGUgPSB7XG4gICAgICBoMDogMHg2NzQ1MjMwMSxcbiAgICAgIGgxOiAweEVGQ0RBQjg5LFxuICAgICAgaDI6IDB4OThCQURDRkUsXG4gICAgICBoMzogMHgxMDMyNTQ3NixcbiAgICAgIGg0OiAweEMzRDJFMUYwXG4gICAgfTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIC8vIHN0YXJ0IGRpZ2VzdCBhdXRvbWF0aWNhbGx5IGZvciBmaXJzdCB0aW1lXG4gIG1kLnN0YXJ0KCk7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRpZ2VzdCB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGlucHV0LiBUaGUgZ2l2ZW4gaW5wdXQgY2FuXG4gICAqIHRyZWF0ZWQgYXMgcmF3IGlucHV0IChubyBlbmNvZGluZyB3aWxsIGJlIGFwcGxpZWQpIG9yIGFuIGVuY29kaW5nIG9mXG4gICAqICd1dGY4JyBtYXliZSBnaXZlbiB0byBlbmNvZGUgdGhlIGlucHV0IHVzaW5nIFVURi04LlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIHRoZSBtZXNzYWdlIGlucHV0IHRvIHVwZGF0ZSB3aXRoLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnVwZGF0ZSA9IGZ1bmN0aW9uKG1zZywgZW5jb2RpbmcpIHtcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWVzc2FnZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICBtZC5tZXNzYWdlTGVuZ3RoICs9IGxlbjtcbiAgICBsZW4gPSBbKGxlbiAvIDB4MTAwMDAwMDAwKSA+Pj4gMCwgbGVuID4+PiAwXTtcbiAgICBmb3IodmFyIGkgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gKz0gbGVuWzFdO1xuICAgICAgbGVuWzFdID0gbGVuWzBdICsgKChtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID4+PiAwO1xuICAgICAgbGVuWzBdID0gKChsZW5bMV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgIH1cblxuICAgIC8vIGFkZCBieXRlcyB0byBpbnB1dCBidWZmZXJcbiAgICBfaW5wdXQucHV0Qnl0ZXMobXNnKTtcblxuICAgIC8vIHByb2Nlc3MgYnl0ZXNcbiAgICBfdXBkYXRlKF9zdGF0ZSwgX3csIF9pbnB1dCk7XG5cbiAgICAvLyBjb21wYWN0IGlucHV0IGJ1ZmZlciBldmVyeSAySyBvciBpZiBlbXB0eVxuICAgIGlmKF9pbnB1dC5yZWFkID4gMjA0OCB8fCBfaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIF9pbnB1dC5jb21wYWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgKi9cbiAgbWQuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgLyogTm90ZTogSGVyZSB3ZSBjb3B5IHRoZSByZW1haW5pbmcgYnl0ZXMgaW4gdGhlIGlucHV0IGJ1ZmZlciBhbmRcbiAgICBhZGQgdGhlIGFwcHJvcHJpYXRlIFNIQS0xIHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDRcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTEgcGFkZGluZyBieXRlcyBub3QgaW5pdGlhbGl6ZWQgeWV0XG52YXIgX3BhZGRpbmcgPSBudWxsO1xudmFyIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjb25zdGFudCB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBjcmVhdGUgcGFkZGluZ1xuICBfcGFkZGluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KTtcbiAgX3BhZGRpbmcgKz0gZm9yZ2UudXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCksIDY0KTtcblxuICAvLyBub3cgaW5pdGlhbGl6ZWRcbiAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgU0hBLTEgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0xIHN0YXRlIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB3IHRoZSBhcnJheSB0byB1c2UgdG8gc3RvcmUgd29yZHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHVwZGF0ZSB3aXRoLlxuICovXG5mdW5jdGlvbiBfdXBkYXRlKHMsIHcsIGJ5dGVzKSB7XG4gIC8vIGNvbnN1bWUgNTEyIGJpdCAoNjQgYnl0ZSkgY2h1bmtzXG4gIHZhciB0LCBhLCBiLCBjLCBkLCBlLCBmLCBpO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gODAgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMSBhbGdvcml0aG1cbiAgICAvLyBhbmQgZm9yIDMyLTc5IHVzaW5nIE1heCBMb2NrdHl1a2hpbidzIG9wdGltaXphdGlvblxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG5cbiAgICAvLyByb3VuZCAxXG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgdCA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg1QTgyNzk5OSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICBmb3IoOyBpIDwgMjA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSAzXSBeIHdbaSAtIDhdIF4gd1tpIC0gMTRdIF4gd1tpIC0gMTZdKTtcbiAgICAgIHQgPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg1QTgyNzk5OSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCAyXG4gICAgZm9yKDsgaSA8IDMyOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gM10gXiB3W2kgLSA4XSBeIHdbaSAtIDE0XSBeIHdbaSAtIDE2XSk7XG4gICAgICB0ID0gKHQgPDwgMSkgfCAodCA+Pj4gMzEpO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDZFRDlFQkExICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIGZvcig7IGkgPCA0MDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdKTtcbiAgICAgIHQgPSAodCA8PCAyKSB8ICh0ID4+PiAzMCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NkVEOUVCQTEgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgLy8gcm91bmQgM1xuICAgIGZvcig7IGkgPCA2MDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdKTtcbiAgICAgIHQgPSAodCA8PCAyKSB8ICh0ID4+PiAzMCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSAoYiAmIGMpIHwgKGQgJiAoYiBeIGMpKTtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg4RjFCQkNEQyArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCA0XG4gICAgZm9yKDsgaSA8IDgwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHhDQTYyQzFENiArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBoYXNoIHN0YXRlXG4gICAgcy5oMCA9IChzLmgwICsgYSkgfCAwO1xuICAgIHMuaDEgPSAocy5oMSArIGIpIHwgMDtcbiAgICBzLmgyID0gKHMuaDIgKyBjKSB8IDA7XG4gICAgcy5oMyA9IChzLmgzICsgZCkgfCAwO1xuICAgIHMuaDQgPSAocy5oNCArIGUpIHwgMDtcblxuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuIiwiLyoqXG4gKiBTZWN1cmUgSGFzaCBBbGdvcml0aG0gd2l0aCAyNTYtYml0IGRpZ2VzdCAoU0hBLTI1NikgaW1wbGVtZW50YXRpb24uXG4gKlxuICogU2VlIEZJUFMgMTgwLTIgZm9yIGRldGFpbHMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNoYTI1NiA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2Uuc2hhMjU2ID0gZm9yZ2Uuc2hhMjU2IHx8IHt9O1xuZm9yZ2UubWQuc2hhMjU2ID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5zaGEyNTYgPSBzaGEyNTY7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNIQS0yNTYgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gYSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKi9cbnNoYTI1Ni5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG8gaW5pdGlhbGl6YXRpb24gYXMgbmVjZXNzYXJ5XG4gIGlmKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICBfaW5pdCgpO1xuICB9XG5cbiAgLy8gU0hBLTI1NiBzdGF0ZSBjb250YWlucyBlaWdodCAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIF9zdGF0ZSA9IG51bGw7XG5cbiAgLy8gaW5wdXQgYnVmZmVyXG4gIHZhciBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZWQgZm9yIHdvcmQgc3RvcmFnZVxuICB2YXIgX3cgPSBuZXcgQXJyYXkoNjQpO1xuXG4gIC8vIG1lc3NhZ2UgZGlnZXN0IG9iamVjdFxuICB2YXIgbWQgPSB7XG4gICAgYWxnb3JpdGhtOiAnc2hhMjU2JyxcbiAgICBibG9ja0xlbmd0aDogNjQsXG4gICAgZGlnZXN0TGVuZ3RoOiAzMixcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDY0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGg2NCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9zdGF0ZSA9IHtcbiAgICAgIGgwOiAweDZBMDlFNjY3LFxuICAgICAgaDE6IDB4QkI2N0FFODUsXG4gICAgICBoMjogMHgzQzZFRjM3MixcbiAgICAgIGgzOiAweEE1NEZGNTNBLFxuICAgICAgaDQ6IDB4NTEwRTUyN0YsXG4gICAgICBoNTogMHg5QjA1Njg4QyxcbiAgICAgIGg2OiAweDFGODNEOUFCLFxuICAgICAgaDc6IDB4NUJFMENEMTlcbiAgICB9O1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgLy8gc3RhcnQgZGlnZXN0IGF1dG9tYXRpY2FsbHkgZm9yIGZpcnN0IHRpbWVcbiAgbWQuc3RhcnQoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGlnZXN0IHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgaW5wdXQuIFRoZSBnaXZlbiBpbnB1dCBjYW5cbiAgICogdHJlYXRlZCBhcyByYXcgaW5wdXQgKG5vIGVuY29kaW5nIHdpbGwgYmUgYXBwbGllZCkgb3IgYW4gZW5jb2Rpbmcgb2ZcbiAgICogJ3V0ZjgnIG1heWJlIGdpdmVuIHRvIGVuY29kZSB0aGUgaW5wdXQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgdGhlIG1lc3NhZ2UgaW5wdXQgdG8gdXBkYXRlIHdpdGguXG4gICAqIEBwYXJhbSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQudXBkYXRlID0gZnVuY3Rpb24obXNnLCBlbmNvZGluZykge1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIG1zZyA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtZXNzYWdlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgIG1kLm1lc3NhZ2VMZW5ndGggKz0gbGVuO1xuICAgIGxlbiA9IFsobGVuIC8gMHgxMDAwMDAwMDApID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICBsZW5bMV0gPSBsZW5bMF0gKyAoKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPj4+IDA7XG4gICAgICBsZW5bMF0gPSAoKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX3N0YXRlLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTI1NiBwYWRkaW5nLiBUaGVuIHdlIGRvIHRoZSBmaW5hbCB1cGRhdGVcbiAgICBvbiBhIGNvcHkgb2YgdGhlIHN0YXRlIHNvIHRoYXQgaWYgdGhlIHVzZXIgd2FudHMgdG8gZ2V0XG4gICAgaW50ZXJtZWRpYXRlIGRpZ2VzdHMgdGhleSBjYW4gZG8gc28uICovXG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBieXRlcyB0aGF0IG11c3QgYmUgYWRkZWQgdG8gdGhlIG1lc3NhZ2VcbiAgICB0byBlbnN1cmUgaXRzIGxlbmd0aCBpcyBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIuIEluIG90aGVyIHdvcmRzLFxuICAgIHRoZSBkYXRhIHRvIGJlIGRpZ2VzdGVkIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA1MTIgYml0cyAob3IgMTI4IGJ5dGVzKS5cbiAgICBUaGlzIGRhdGEgaW5jbHVkZXMgdGhlIG1lc3NhZ2UsIHNvbWUgcGFkZGluZywgYW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgbWVzc2FnZS4gU2luY2UgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZSB3aWxsIGJlIGVuY29kZWQgYXMgOCBieXRlcyAoNjRcbiAgICBiaXRzKSwgdGhhdCBtZWFucyB0aGF0IHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGRhdGEgbXVzdCBoYXZlIDU2IGJ5dGVzXG4gICAgKDQ0OCBiaXRzKSBvZiBtZXNzYWdlIGFuZCBwYWRkaW5nLiBUaGVyZWZvcmUsIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2VcbiAgICBwbHVzIHRoZSBwYWRkaW5nIG11c3QgYmUgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyIGJlY2F1c2VcbiAgICA1MTIgLSAxMjggPSA0NDguXG5cbiAgICBJbiBvcmRlciB0byBmaWxsIHVwIHRoZSBtZXNzYWdlIGxlbmd0aCBpdCBtdXN0IGJlIGZpbGxlZCB3aXRoXG4gICAgcGFkZGluZyB0aGF0IGJlZ2lucyB3aXRoIDEgYml0IGZvbGxvd2VkIGJ5IGFsbCAwIGJpdHMuIFBhZGRpbmdcbiAgICBtdXN0ICphbHdheXMqIGJlIHByZXNlbnQsIHNvIGlmIHRoZSBtZXNzYWdlIGxlbmd0aCBpcyBhbHJlYWR5XG4gICAgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLCB0aGVuIDUxMiBwYWRkaW5nIGJpdHMgbXVzdCBiZSBhZGRlZC4gKi9cblxuICAgIHZhciBmaW5hbEJsb2NrID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9pbnB1dC5ieXRlcygpKTtcblxuICAgIC8vIGNvbXB1dGUgcmVtYWluaW5nIHNpemUgdG8gYmUgZGlnZXN0ZWQgKGluY2x1ZGUgbWVzc2FnZSBsZW5ndGggc2l6ZSlcbiAgICB2YXIgcmVtYWluaW5nID0gKFxuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMV0gK1xuICAgICAgbWQubWVzc2FnZUxlbmd0aFNpemUpO1xuXG4gICAgLy8gYWRkIHBhZGRpbmcgZm9yIG92ZXJmbG93IGJsb2NrU2l6ZSAtIG92ZXJmbG93XG4gICAgLy8gX3BhZGRpbmcgc3RhcnRzIHdpdGggMSBieXRlIHdpdGggZmlyc3QgYml0IGlzIHNldCAoYnl0ZSB2YWx1ZSAxMjgpLCB0aGVuXG4gICAgLy8gdGhlcmUgbWF5IGJlIHVwIHRvIChibG9ja1NpemUgLSAxKSBvdGhlciBwYWQgYnl0ZXNcbiAgICB2YXIgb3ZlcmZsb3cgPSByZW1haW5pbmcgJiAobWQuYmxvY2tMZW5ndGggLSAxKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9wYWRkaW5nLnN1YnN0cigwLCBtZC5ibG9ja0xlbmd0aCAtIG92ZXJmbG93KSk7XG5cbiAgICAvLyBzZXJpYWxpemUgbWVzc2FnZSBsZW5ndGggaW4gYml0cyBpbiBiaWctZW5kaWFuIG9yZGVyOyBzaW5jZSBsZW5ndGhcbiAgICAvLyBpcyBzdG9yZWQgaW4gYnl0ZXMgd2UgbXVsdGlwbHkgYnkgOCBhbmQgYWRkIGNhcnJ5IGZyb20gbmV4dCBpbnRcbiAgICB2YXIgbmV4dCwgY2Fycnk7XG4gICAgdmFyIGJpdHMgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFswXSAqIDg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgbmV4dCA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2kgKyAxXSAqIDg7XG4gICAgICBjYXJyeSA9IChuZXh0IC8gMHgxMDAwMDAwMDApID4+PiAwO1xuICAgICAgYml0cyArPSBjYXJyeTtcbiAgICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyA+Pj4gMCk7XG4gICAgICBiaXRzID0gbmV4dCA+Pj4gMDtcbiAgICB9XG4gICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzKTtcblxuICAgIHZhciBzMiA9IHtcbiAgICAgIGgwOiBfc3RhdGUuaDAsXG4gICAgICBoMTogX3N0YXRlLmgxLFxuICAgICAgaDI6IF9zdGF0ZS5oMixcbiAgICAgIGgzOiBfc3RhdGUuaDMsXG4gICAgICBoNDogX3N0YXRlLmg0LFxuICAgICAgaDU6IF9zdGF0ZS5oNSxcbiAgICAgIGg2OiBfc3RhdGUuaDYsXG4gICAgICBoNzogX3N0YXRlLmg3XG4gICAgfTtcbiAgICBfdXBkYXRlKHMyLCBfdywgZmluYWxCbG9jayk7XG4gICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDApO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDEpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDIpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDMpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDQpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDUpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDYpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDcpO1xuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIHJldHVybiBtZDtcbn07XG5cbi8vIHNoYS0yNTYgcGFkZGluZyBieXRlcyBub3QgaW5pdGlhbGl6ZWQgeWV0XG52YXIgX3BhZGRpbmcgPSBudWxsO1xudmFyIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vLyB0YWJsZSBvZiBjb25zdGFudHNcbnZhciBfayA9IG51bGw7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgNjQpO1xuXG4gIC8vIGNyZWF0ZSBLIHRhYmxlIGZvciBTSEEtMjU2XG4gIF9rID0gW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gICAgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuICAgIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYyxcbiAgICAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gICAgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuICAgIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMyxcbiAgICAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gICAgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuICAgIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJdO1xuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBTSEEtMjU2IHN0YXRlIHdpdGggdGhlIGdpdmVuIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzIHRoZSBTSEEtMjU2IHN0YXRlIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB3IHRoZSBhcnJheSB0byB1c2UgdG8gc3RvcmUgd29yZHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHVwZGF0ZSB3aXRoLlxuICovXG5mdW5jdGlvbiBfdXBkYXRlKHMsIHcsIGJ5dGVzKSB7XG4gIC8vIGNvbnN1bWUgNTEyIGJpdCAoNjQgYnl0ZSkgY2h1bmtzXG4gIHZhciB0MSwgdDIsIHMwLCBzMSwgY2gsIG1haiwgaSwgYSwgYiwgYywgZCwgZSwgZiwgZywgaDtcbiAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aCgpO1xuICB3aGlsZShsZW4gPj0gNjQpIHtcbiAgICAvLyB0aGUgdyBhcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHNpeHRlZW4gMzItYml0IGJpZy1lbmRpYW4gd29yZHNcbiAgICAvLyBhbmQgdGhlbiBleHRlbmRlZCBpbnRvIDY0IDMyLWJpdCB3b3JkcyBhY2NvcmRpbmcgdG8gU0hBLTI1NlxuICAgIGZvcihpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHdbaV0gPSBieXRlcy5nZXRJbnQzMigpO1xuICAgIH1cbiAgICBmb3IoOyBpIDwgNjQ7ICsraSkge1xuICAgICAgLy8gWE9SIHdvcmQgMiB3b3JkcyBhZ28gcm90IHJpZ2h0IDE3LCByb3QgcmlnaHQgMTksIHNoZnQgcmlnaHQgMTBcbiAgICAgIHQxID0gd1tpIC0gMl07XG4gICAgICB0MSA9XG4gICAgICAgICgodDEgPj4+IDE3KSB8ICh0MSA8PCAxNSkpIF5cbiAgICAgICAgKCh0MSA+Pj4gMTkpIHwgKHQxIDw8IDEzKSkgXlxuICAgICAgICAodDEgPj4+IDEwKTtcbiAgICAgIC8vIFhPUiB3b3JkIDE1IHdvcmRzIGFnbyByb3QgcmlnaHQgNywgcm90IHJpZ2h0IDE4LCBzaGZ0IHJpZ2h0IDNcbiAgICAgIHQyID0gd1tpIC0gMTVdO1xuICAgICAgdDIgPVxuICAgICAgICAoKHQyID4+PiA3KSB8ICh0MiA8PCAyNSkpIF5cbiAgICAgICAgKCh0MiA+Pj4gMTgpIHwgKHQyIDw8IDE0KSkgXlxuICAgICAgICAodDIgPj4+IDMpO1xuICAgICAgLy8gc3VtKHQxLCB3b3JkIDcgYWdvLCB0Miwgd29yZCAxNiBhZ28pIG1vZHVsbyAyXjMyXG4gICAgICB3W2ldID0gKHQxICsgd1tpIC0gN10gKyB0MiArIHdbaSAtIDE2XSkgfCAwO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgaGFzaCB2YWx1ZSBmb3IgdGhpcyBjaHVua1xuICAgIGEgPSBzLmgwO1xuICAgIGIgPSBzLmgxO1xuICAgIGMgPSBzLmgyO1xuICAgIGQgPSBzLmgzO1xuICAgIGUgPSBzLmg0O1xuICAgIGYgPSBzLmg1O1xuICAgIGcgPSBzLmg2O1xuICAgIGggPSBzLmg3O1xuXG4gICAgLy8gcm91bmQgZnVuY3Rpb25cbiAgICBmb3IoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAvLyBTdW0xKGUpXG4gICAgICBzMSA9XG4gICAgICAgICgoZSA+Pj4gNikgfCAoZSA8PCAyNikpIF5cbiAgICAgICAgKChlID4+PiAxMSkgfCAoZSA8PCAyMSkpIF5cbiAgICAgICAgKChlID4+PiAyNSkgfCAoZSA8PCA3KSk7XG4gICAgICAvLyBDaChlLCBmLCBnKSAob3B0aW1pemVkIHRoZSBzYW1lIHdheSBhcyBTSEEtMSlcbiAgICAgIGNoID0gZyBeIChlICYgKGYgXiBnKSk7XG4gICAgICAvLyBTdW0wKGEpXG4gICAgICBzMCA9XG4gICAgICAgICgoYSA+Pj4gMikgfCAoYSA8PCAzMCkpIF5cbiAgICAgICAgKChhID4+PiAxMykgfCAoYSA8PCAxOSkpIF5cbiAgICAgICAgKChhID4+PiAyMikgfCAoYSA8PCAxMCkpO1xuICAgICAgLy8gTWFqKGEsIGIsIGMpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgbWFqID0gKGEgJiBiKSB8IChjICYgKGEgXiBiKSk7XG5cbiAgICAgIC8vIG1haW4gYWxnb3JpdGhtXG4gICAgICB0MSA9IGggKyBzMSArIGNoICsgX2tbaV0gKyB3W2ldO1xuICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgIGggPSBnO1xuICAgICAgZyA9IGY7XG4gICAgICBmID0gZTtcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgLy8gY2FuJ3QgdHJ1bmNhdGUgd2l0aCBgfCAwYFxuICAgICAgZSA9IChkICsgdDEpID4+PiAwO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gYjtcbiAgICAgIGIgPSBhO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICAvLyBjYW4ndCB0cnVuY2F0ZSB3aXRoIGB8IDBgXG4gICAgICBhID0gKHQxICsgdDIpID4+PiAwO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBoYXNoIHN0YXRlXG4gICAgcy5oMCA9IChzLmgwICsgYSkgfCAwO1xuICAgIHMuaDEgPSAocy5oMSArIGIpIHwgMDtcbiAgICBzLmgyID0gKHMuaDIgKyBjKSB8IDA7XG4gICAgcy5oMyA9IChzLmgzICsgZCkgfCAwO1xuICAgIHMuaDQgPSAocy5oNCArIGUpIHwgMDtcbiAgICBzLmg1ID0gKHMuaDUgKyBmKSB8IDA7XG4gICAgcy5oNiA9IChzLmg2ICsgZykgfCAwO1xuICAgIHMuaDcgPSAocy5oNyArIGgpIHwgMDtcbiAgICBsZW4gLT0gNjQ7XG4gIH1cbn1cbiIsIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdlYiBhcHBsaWNhdGlvbnMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxOCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG52YXIgYmFzZU4gPSByZXF1aXJlKCcuL2Jhc2VOJyk7XG5cbi8qIFV0aWxpdGllcyBBUEkgKi9cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS51dGlsID0gZm9yZ2UudXRpbCB8fCB7fTtcblxuLy8gZGVmaW5lIHNldEltbWVkaWF0ZSBhbmQgbmV4dFRpY2tcbihmdW5jdGlvbigpIHtcbiAgLy8gdXNlIG5hdGl2ZSBuZXh0VGljayAodW5sZXNzIHdlJ3JlIGluIHdlYnBhY2spXG4gIC8vIHdlYnBhY2sgKG9yIGJldHRlciBub2RlLWxpYnMtYnJvd3NlciBwb2x5ZmlsbCkgc2V0cyBwcm9jZXNzLmJyb3dzZXIuXG4gIC8vIHRoaXMgd2F5IHdlIGNhbiBkZXRlY3Qgd2VicGFjayBwcm9wZXJseVxuICBpZih0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5uZXh0VGljayAmJiAhcHJvY2Vzcy5icm93c2VyKSB7XG4gICAgdXRpbC5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBvbHlmaWxsIHNldEltbWVkaWF0ZSB3aXRoIG5leHRUaWNrLCBvbGRlciB2ZXJzaW9ucyBvZiBub2RlXG4gICAgICAvLyAodGhvc2Ugdy9vIHNldEltbWVkaWF0ZSkgd29uJ3QgdG90YWxseSBzdGFydmUgSU9cbiAgICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gdXRpbC5uZXh0VGljaztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcG9seWZpbGwgbmV4dFRpY2sgd2l0aCBuYXRpdmUgc2V0SW1tZWRpYXRlXG4gIGlmKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2V0SW1tZWRpYXRlLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTsgfTtcbiAgICB1dGlsLm5leHRUaWNrID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogTm90ZTogQSBwb2x5ZmlsbCB1cGdyYWRlIHBhdHRlcm4gaXMgdXNlZCBoZXJlIHRvIGFsbG93IGNvbWJpbmluZ1xuICBwb2x5ZmlsbHMuIEZvciBleGFtcGxlLCBNdXRhdGlvbk9ic2VydmVyIGlzIGZhc3QsIGJ1dCBibG9ja3MgVUkgdXBkYXRlcyxcbiAgc28gaXQgbmVlZHMgdG8gYWxsb3cgVUkgdXBkYXRlcyBwZXJpb2RpY2FsbHksIHNvIGl0IGZhbGxzIGJhY2sgb25cbiAgcG9zdE1lc3NhZ2Ugb3Igc2V0VGltZW91dC4gKi9cblxuICAvLyBwb2x5ZmlsbCB3aXRoIHNldFRpbWVvdXRcbiAgdXRpbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICB9O1xuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIHBvc3RNZXNzYWdlXG4gIGlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBtc2cgPSAnZm9yZ2Uuc2V0SW1tZWRpYXRlJztcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgdXRpbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgLy8gb25seSBzZW5kIG1lc3NhZ2Ugd2hlbiBvbmUgaGFzbid0IGJlZW4gc2VudCBpblxuICAgICAgLy8gdGhlIGN1cnJlbnQgdHVybiBvZiB0aGUgZXZlbnQgbG9vcFxuICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UobXNnLCAnKicpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgaWYoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YSA9PT0gbXNnKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgICAgY29weS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlciwgdHJ1ZSk7XG4gIH1cblxuICAvLyB1cGdyYWRlIHBvbHlmaWxsIHRvIHVzZSBNdXRhdGlvbk9ic2VydmVyXG4gIGlmKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHBvbHlmaWxsIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciBhdHRyID0gdHJ1ZTtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHkgPSBjYWxsYmFja3Muc2xpY2UoKTtcbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29weS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9KS5vYnNlcnZlKGRpdiwge2F0dHJpYnV0ZXM6IHRydWV9KTtcbiAgICB2YXIgb2xkU2V0SW1tZWRpYXRlID0gdXRpbC5zZXRJbW1lZGlhdGU7XG4gICAgdXRpbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgaWYoRGF0ZS5ub3coKSAtIG5vdyA+IDE1KSB7XG4gICAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIG9sZFNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIC8vIG9ubHkgdHJpZ2dlciBvYnNlcnZlciB3aGVuIGl0IGhhc24ndCBiZWVuIHRyaWdnZXJlZCBpblxuICAgICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICAgIGlmKGNhbGxiYWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhJywgYXR0ciA9ICFhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB1dGlsLm5leHRUaWNrID0gdXRpbC5zZXRJbW1lZGlhdGU7XG59KSgpO1xuXG4vLyBjaGVjayBpZiBydW5uaW5nIHVuZGVyIE5vZGUuanNcbnV0aWwuaXNOb2RlanMgPVxuICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG5cblxuLy8gJ3NlbGYnIHdpbGwgYWxzbyB3b3JrIGluIFdlYiBXb3JrZXJzIChpbnN0YW5jZSBvZiBXb3JrZXJHbG9iYWxTY29wZSkgd2hpbGVcbi8vIGl0IHdpbGwgcG9pbnQgdG8gYHdpbmRvd2AgaW4gdGhlIG1haW4gdGhyZWFkLlxuLy8gVG8gcmVtYWluIGNvbXBhdGlibGUgd2l0aCBvbGRlciBicm93c2Vycywgd2UgZmFsbCBiYWNrIHRvICd3aW5kb3cnIGlmICdzZWxmJ1xuLy8gaXMgbm90IGF2YWlsYWJsZS5cbnV0aWwuZ2xvYmFsU2NvcGUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmKHV0aWwuaXNOb2RlanMpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHNlbGY7XG59KSgpO1xuXG4vLyBkZWZpbmUgaXNBcnJheVxudXRpbC5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vLyBkZWZpbmUgaXNBcnJheUJ1ZmZlclxudXRpbC5pc0FycmF5QnVmZmVyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuXG4vLyBkZWZpbmUgaXNBcnJheUJ1ZmZlclZpZXdcbnV0aWwuaXNBcnJheUJ1ZmZlclZpZXcgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ICYmIHV0aWwuaXNBcnJheUJ1ZmZlcih4LmJ1ZmZlcikgJiYgeC5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEVuc3VyZSBhIGJpdHMgcGFyYW0gaXMgOCwgMTYsIDI0LCBvciAzMi4gVXNlZCB0byB2YWxpZGF0ZSBpbnB1dCBmb3JcbiAqIGFsZ29yaXRobXMgd2hlcmUgYml0IG1hbmlwdWxhdGlvbiwgSmF2YVNjcmlwdCBsaW1pdGF0aW9ucywgYW5kL29yIGFsZ29yaXRobVxuICogZGVzaWduIG9ubHkgYWxsb3cgZm9yIGJ5dGUgb3BlcmF0aW9ucyBvZiBhIGxpbWl0ZWQgc2l6ZS5cbiAqXG4gKiBAcGFyYW0gbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBUaHJvdyBFcnJvciBpZiBuIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIF9jaGVja0JpdHNQYXJhbShuKSB7XG4gIGlmKCEobiA9PT0gOCB8fCBuID09PSAxNiB8fCBuID09PSAyNCB8fCBuID09PSAzMikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgOCwgMTYsIDI0LCBvciAzMiBiaXRzIHN1cHBvcnRlZDogJyArIG4pO1xuICB9XG59XG5cbi8vIFRPRE86IHNldCBCeXRlQnVmZmVyIHRvIGJlc3QgYXZhaWxhYmxlIGJhY2tpbmdcbnV0aWwuQnl0ZUJ1ZmZlciA9IEJ5dGVTdHJpbmdCdWZmZXI7XG5cbi8qKiBCdWZmZXIgdy9CaW5hcnlTdHJpbmcgYmFja2luZyAqL1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIGZvciBhIGJpbmFyeSBzdHJpbmcgYmFja2VkIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBbYl0gdGhlIGJ5dGVzIHRvIHdyYXAgKGVpdGhlciBlbmNvZGVkIGFzIHN0cmluZywgb25lIGJ5dGUgcGVyXG4gKiAgICAgICAgICBjaGFyYWN0ZXIsIG9yIGFzIGFuIEFycmF5QnVmZmVyIG9yIFR5cGVkIEFycmF5KS5cbiAqL1xuZnVuY3Rpb24gQnl0ZVN0cmluZ0J1ZmZlcihiKSB7XG4gIC8vIFRPRE86IHVwZGF0ZSB0byBtYXRjaCBEYXRhQnVmZmVyIEFQSVxuXG4gIC8vIHRoZSBkYXRhIGluIHRoaXMgYnVmZmVyXG4gIHRoaXMuZGF0YSA9ICcnO1xuICAvLyB0aGUgcG9pbnRlciBmb3IgcmVhZGluZyBmcm9tIHRoaXMgYnVmZmVyXG4gIHRoaXMucmVhZCA9IDA7XG5cbiAgaWYodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5kYXRhID0gYjtcbiAgfSBlbHNlIGlmKHV0aWwuaXNBcnJheUJ1ZmZlcihiKSB8fCB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGIpKSB7XG4gICAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYiBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgdGhpcy5kYXRhID0gYi50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnZlcnQgbmF0aXZlIGJ1ZmZlciB0byBmb3JnZSBidWZmZXJcbiAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IG5hdGl2ZSBidWZmZXJzIGludGVybmFsbHkgaW5zdGVhZFxuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5kYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0aGlzLnB1dEJ5dGUoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmKGIgaW5zdGFuY2VvZiBCeXRlU3RyaW5nQnVmZmVyIHx8XG4gICAgKHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYi5kYXRhID09PSAnc3RyaW5nJyAmJlxuICAgIHR5cGVvZiBiLnJlYWQgPT09ICdudW1iZXInKSkge1xuICAgIC8vIGNvcHkgZXhpc3RpbmcgYnVmZmVyXG4gICAgdGhpcy5kYXRhID0gYi5kYXRhO1xuICAgIHRoaXMucmVhZCA9IGIucmVhZDtcbiAgfVxuXG4gIC8vIHVzZWQgZm9yIHY4IG9wdGltaXphdGlvblxuICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCA9IDA7XG59XG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIgPSBCeXRlU3RyaW5nQnVmZmVyO1xuXG4vKiBOb3RlOiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBmb3IgVjgtYmFzZWQgYnJvd3NlcnMuIFdoZW4gVjggY29uY2F0ZW5hdGVzXG4gIGEgc3RyaW5nLCB0aGUgc3RyaW5ncyBhcmUgb25seSBqb2luZWQgbG9naWNhbGx5IHVzaW5nIGEgXCJjb25zIHN0cmluZ1wiIG9yXG4gIFwiY29uc3RydWN0ZWQvY29uY2F0ZW5hdGVkIHN0cmluZ1wiLiBUaGVzZSBjb250YWluZXJzIGtlZXAgcmVmZXJlbmNlcyB0byBvbmVcbiAgYW5vdGhlciBhbmQgY2FuIHJlc3VsdCBpbiB2ZXJ5IGxhcmdlIG1lbW9yeSB1c2FnZS4gRm9yIGV4YW1wbGUsIGlmIGEgMk1CXG4gIHN0cmluZyBpcyBjb25zdHJ1Y3RlZCBieSBjb25jYXRlbmF0aW5nIDQgYnl0ZXMgdG9nZXRoZXIgYXQgYSB0aW1lLCB0aGVcbiAgbWVtb3J5IHVzYWdlIHdpbGwgYmUgfjQ0TUI7IHNvIH4yMnggaW5jcmVhc2UuIFRoZSBzdHJpbmdzIGFyZSBvbmx5IGpvaW5lZFxuICB0b2dldGhlciB3aGVuIGFuIG9wZXJhdGlvbiByZXF1aXJpbmcgdGhlaXIgam9pbmluZyB0YWtlcyBwbGFjZSwgc3VjaCBhc1xuICBzdWJzdHIoKS4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhZGRpbmcgZGF0YSB0byB0aGlzIGJ1ZmZlciB0byBlbnN1cmVcbiAgdGhlc2UgdHlwZXMgb2Ygc3RyaW5ncyBhcmUgcGVyaW9kaWNhbGx5IGpvaW5lZCB0byByZWR1Y2UgdGhlIG1lbW9yeVxuICBmb290cHJpbnQuICovXG52YXIgX01BWF9DT05TVFJVQ1RFRF9TVFJJTkdfTEVOR1RIID0gNDA5NjtcbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcgPSBmdW5jdGlvbih4KSB7XG4gIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoICs9IHg7XG4gIGlmKHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID4gX01BWF9DT05TVFJVQ1RFRF9TVFJJTkdfTEVOR1RIKSB7XG4gICAgLy8gdGhpcyBzdWJzdHIoKSBzaG91bGQgY2F1c2UgdGhlIGNvbnN0cnVjdGVkIHN0cmluZyB0byBqb2luXG4gICAgdGhpcy5kYXRhLnN1YnN0cigwLCAxKTtcbiAgICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGggLSB0aGlzLnJlYWQ7XG59O1xuXG4vKipcbiAqIEdldHMgd2hldGhlciBvciBub3QgdGhpcyBidWZmZXIgaXMgZW1wdHkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgYnVmZmVyIGlzIGVtcHR5LCBmYWxzZSBpZiBub3QuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGgoKSA8PSAwO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIgTiB0aW1lcy5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHZhbHVlIGIgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZmlsbFdpdGhCeXRlID0gZnVuY3Rpb24oYiwgbikge1xuICBiID0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgdmFyIGQgPSB0aGlzLmRhdGE7XG4gIHdoaWxlKG4gPiAwKSB7XG4gICAgaWYobiAmIDEpIHtcbiAgICAgIGQgKz0gYjtcbiAgICB9XG4gICAgbiA+Pj49IDE7XG4gICAgaWYobiA+IDApIHtcbiAgICAgIGIgKz0gYjtcbiAgICB9XG4gIH1cbiAgdGhpcy5kYXRhID0gZDtcbiAgdGhpcy5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyhuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyAoYXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcpIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdGhpcy5kYXRhICs9IGJ5dGVzO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKGJ5dGVzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgVVRGLTE2IGVuY29kZWQgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyh1dGlsLmVuY29kZVV0Zjgoc3RyKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYW4gbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgYnl0ZXMgPSAnJztcbiAgZG8ge1xuICAgIG4gLT0gODtcbiAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IG4pICYgMHhGRik7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhieXRlcyk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgLy8gcHV0SW50IGNoZWNrcyBuXG4gIGlmKGkgPCAwKSB7XG4gICAgaSArPSAyIDw8IChuIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBnaXZlbiBidWZmZXIgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gcHV0IGludG8gdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnVmZmVyLmdldEJ5dGVzKCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBmcm9tIHRoaXMgYnVmZmVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IDEuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAyNCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNik7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAzKSA8PCAyNCk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlXG4gKiByZWFkIHBvaW50ZXIgYnkgY2VpbChuLzgpLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIHJ2YWwgPSAwO1xuICBkbyB7XG4gICAgLy8gVE9ETzogVXNlIChydmFsICogMHgxMDApIGlmIGFkZGluZyBzdXBwb3J0IGZvciAzMyB0byA1MyBiaXRzLlxuICAgIHJ2YWwgPSAocnZhbCA8PCA4KSArIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbiAgICBuIC09IDg7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciwgdXNpbmdcbiAqIHR3bydzIGNvbXBsZW1lbnQsIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0U2lnbmVkSW50ID0gZnVuY3Rpb24obikge1xuICAvLyBnZXRJbnQgY2hlY2tzIG5cbiAgdmFyIHggPSB0aGlzLmdldEludChuKTtcbiAgdmFyIG1heCA9IDIgPDwgKG4gLSAyKTtcbiAgaWYoeCA+PSBtYXgpIHtcbiAgICB4IC09IG1heCA8PCAxO1xuICB9XG4gIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlcyBvdXQgYXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgYW5kIGNsZWFycyB0aGVtIGZyb20gdGhlXG4gKiBidWZmZXIuIE5vdGUgdGhhdCB0aGUgcmVzdWx0aW5nIHN0cmluZyBpcyBiaW5hcnkgZW5jb2RlZCAoaW4gbm9kZS5qcyB0aGlzXG4gKiBlbmNvZGluZyBpcyByZWZlcnJlZCB0byBhcyBgYmluYXJ5YCwgaXQgaXMgKm5vdCogYHV0ZjhgKS5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLCB1bmRlZmluZWQgb3IgbnVsbCBmb3IgYWxsLlxuICpcbiAqIEByZXR1cm4gYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgcnZhbDtcbiAgaWYoY291bnQpIHtcbiAgICAvLyByZWFkIGNvdW50IGJ5dGVzXG4gICAgY291bnQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBjb3VudCk7XG4gICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB0aGlzLnJlYWQgKz0gY291bnQ7XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMCkge1xuICAgIHJ2YWwgPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGFsbCBieXRlcywgb3B0aW1pemUgdG8gb25seSBjb3B5IHdoZW4gbmVlZGVkXG4gICAgcnZhbCA9ICh0aGlzLnJlYWQgPT09IDApID8gdGhpcy5kYXRhIDogdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIG9mIHRoZSBieXRlcyBmcm9tIHRoaXMgYnVmZmVyIHdpdGhvdXRcbiAqIG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdldCwgb21pdCB0byBnZXQgYWxsLlxuICpcbiAqIEByZXR1cm4gYSBzdHJpbmcgZnVsbCBvZiBiaW5hcnkgZW5jb2RlZCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgcmV0dXJuICh0eXBlb2YoY291bnQpID09PSAndW5kZWZpbmVkJyA/XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCkgOlxuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyBpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cigwLCB0aGlzLnJlYWQgKyBpKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShiKSArXG4gICAgdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQgKyBpICsgMSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5kYXRhLmxlbmd0aCAtIDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjb3B5LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGMgPSB1dGlsLmNyZWF0ZUJ1ZmZlcih0aGlzLmRhdGEpO1xuICBjLnJlYWQgPSB0aGlzLnJlYWQ7XG4gIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9ICcnO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hvcnRlbnMgdGhpcyBidWZmZXIgYnkgdHJpbWluZyBieXRlcyBvZmYgb2YgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byB0cmltIG9mZi5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoKCkgLSBjb3VudCk7XG4gIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHIodGhpcy5yZWFkLCBsZW4pO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYiA9IHRoaXMuZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmKGIgPCAxNikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgVVRGLTE2IHN0cmluZyAoc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICpcbiAqIEByZXR1cm4gYSBVVEYtMTYgc3RyaW5nLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgodGhpcy5ieXRlcygpKTtcbn07XG5cbi8qKiBFbmQgQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqIEJ1ZmZlciB3L1VJbnQ4QXJyYXkgYmFja2luZyAqL1xuXG4vKipcbiAqIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxuICpcbiAqIENvbnN0cnVjdG9yIGZvciBhbiBBcnJheUJ1ZmZlci1iYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogVGhlIGJ1ZmZlciBtYXkgYmUgY29uc3RydWN0ZWQgZnJvbSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBhXG4gKiBUeXBlZEFycmF5LlxuICpcbiAqIElmIGEgc3RyaW5nIGlzIGdpdmVuLCBpdHMgZW5jb2Rpbmcgc2hvdWxkIGJlIHByb3ZpZGVkIGFzIGFuIG9wdGlvbixcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGRlZmF1bHQgdG8gJ2JpbmFyeScuIEEgJ2JpbmFyeScgc3RyaW5nIGlzIGVuY29kZWQgc3VjaFxuICogdGhhdCBlYWNoIGNoYXJhY3RlciBpcyBvbmUgYnl0ZSBpbiBsZW5ndGggYW5kIHNpemUuXG4gKlxuICogSWYgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBUeXBlZEFycmF5IGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWRcbiAqICpkaXJlY3RseSogd2l0aG91dCBhbnkgY29weWluZy4gTm90ZSB0aGF0LCBpZiBhIHdyaXRlIHRvIHRoZSBidWZmZXIgcmVxdWlyZXNcbiAqIG1vcmUgc3BhY2UsIHRoZSBidWZmZXIgd2lsbCBhbGxvY2F0ZSBhIG5ldyBiYWNraW5nIEFycmF5QnVmZmVyIHRvXG4gKiBhY2NvbW1vZGF0ZS4gVGhlIHN0YXJ0aW5nIHJlYWQgYW5kIHdyaXRlIG9mZnNldHMgZm9yIHRoZSBidWZmZXIgbWF5IGJlXG4gKiBnaXZlbiBhcyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBbYl0gdGhlIGluaXRpYWwgYnl0ZXMgZm9yIHRoaXMgYnVmZmVyLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW3JlYWRPZmZzZXRdIHRoZSBzdGFydGluZyByZWFkIG9mZnNldCB0byB1c2UgKGRlZmF1bHQ6IDApLlxuICogICAgICAgICAgW3dyaXRlT2Zmc2V0XSB0aGUgc3RhcnRpbmcgd3JpdGUgb2Zmc2V0IHRvIHVzZSAoZGVmYXVsdDogdGhlXG4gKiAgICAgICAgICAgIGxlbmd0aCBvZiB0aGUgZmlyc3QgcGFyYW1ldGVyKS5cbiAqICAgICAgICAgIFtncm93U2l6ZV0gdGhlIG1pbmltdW0gYW1vdW50LCBpbiBieXRlcywgdG8gZ3JvdyB0aGUgYnVmZmVyIGJ5IHRvXG4gKiAgICAgICAgICAgIGFjY29tbW9kYXRlIHdyaXRlcyAoZGVmYXVsdDogMTAyNCkuXG4gKiAgICAgICAgICBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyAoJ2JpbmFyeScsICd1dGY4JywgJ3V0ZjE2JywgJ2hleCcpIGZvciB0aGVcbiAqICAgICAgICAgICAgZmlyc3QgcGFyYW1ldGVyLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICovXG5mdW5jdGlvbiBEYXRhQnVmZmVyKGIsIG9wdGlvbnMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvaW50ZXJzIGZvciByZWFkIGZyb20vd3JpdGUgdG8gYnVmZmVyXG4gIHRoaXMucmVhZCA9IG9wdGlvbnMucmVhZE9mZnNldCB8fCAwO1xuICB0aGlzLmdyb3dTaXplID0gb3B0aW9ucy5ncm93U2l6ZSB8fCAxMDI0O1xuXG4gIHZhciBpc0FycmF5QnVmZmVyID0gdXRpbC5pc0FycmF5QnVmZmVyKGIpO1xuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGIpO1xuICBpZihpc0FycmF5QnVmZmVyIHx8IGlzQXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgLy8gdXNlIEFycmF5QnVmZmVyIGRpcmVjdGx5XG4gICAgaWYoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGp1c3QgcmVhZC93cml0ZSBvZmZzZXQgYmFzZWQgb24gdGhlIHR5cGUgb2Ygdmlld1xuICAgICAgLy8gb3Igc3BlY2lmeSB0aGF0IHRoaXMgbXVzdCBiZSBkb25lIGluIHRoZSBvcHRpb25zIC4uLiB0aGF0IHRoZVxuICAgICAgLy8gb2Zmc2V0cyBhcmUgYnl0ZS1iYXNlZFxuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMud3JpdGUgPSAoJ3dyaXRlT2Zmc2V0JyBpbiBvcHRpb25zID9cbiAgICAgIG9wdGlvbnMud3JpdGVPZmZzZXQgOiB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB0byBlbXB0eSBhcnJheSBidWZmZXIgYW5kIGFkZCBhbnkgZ2l2ZW4gYnl0ZXMgdXNpbmcgcHV0Qnl0ZXNcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIHRoaXMud3JpdGUgPSAwO1xuXG4gIGlmKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wdXRCeXRlcyhiKTtcbiAgfVxuXG4gIGlmKCd3cml0ZU9mZnNldCcgaW4gb3B0aW9ucykge1xuICAgIHRoaXMud3JpdGUgPSBvcHRpb25zLndyaXRlT2Zmc2V0O1xuICB9XG59XG51dGlsLkRhdGFCdWZmZXIgPSBEYXRhQnVmZmVyO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndyaXRlIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogRW5zdXJlcyB0aGlzIGJ1ZmZlciBoYXMgZW5vdWdoIGVtcHR5IHNwYWNlIHRvIGFjY29tbW9kYXRlIHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGJ5dGVzLiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgbWF5IGJlIGdpdmVuIHRoYXQgaW5kaWNhdGVzIGEgbWluaW11bVxuICogYW1vdW50IHRvIGdyb3cgdGhlIGJ1ZmZlciBpZiBuZWNlc3NhcnkuIElmIHRoZSBwYXJhbWV0ZXIgaXMgbm90IGdpdmVuLFxuICogdGhlIGJ1ZmZlciB3aWxsIGJlIGdyb3duIGJ5IHNvbWUgcHJldmlvdXNseS1zcGVjaWZpZWQgZGVmYXVsdCBhbW91bnRcbiAqIG9yIGhldXJpc3RpYy5cbiAqXG4gKiBAcGFyYW0gYW1vdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gYWNjb21tb2RhdGUuXG4gKiBAcGFyYW0gW2dyb3dTaXplXSB0aGUgbWluaW11bSBhbW91bnQsIGluIGJ5dGVzLCB0byBncm93IHRoZSBidWZmZXIgYnkgaWZcbiAqICAgICAgICAgIG5lY2Vzc2FyeS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5hY2NvbW1vZGF0ZSA9IGZ1bmN0aW9uKGFtb3VudCwgZ3Jvd1NpemUpIHtcbiAgaWYodGhpcy5sZW5ndGgoKSA+PSBhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm93U2l6ZSA9IE1hdGgubWF4KGdyb3dTaXplIHx8IHRoaXMuZ3Jvd1NpemUsIGFtb3VudCk7XG5cbiAgLy8gZ3JvdyBidWZmZXJcbiAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KFxuICAgIHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5ieXRlT2Zmc2V0LCB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICsgZ3Jvd1NpemUpO1xuICBkc3Quc2V0KHNyYyk7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QuYnVmZmVyKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgxKTtcbiAgdGhpcy5kYXRhLnNldFVpbnQ4KHRoaXMud3JpdGUrKywgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUobik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB0aGlzLmRhdGEuc2V0VWludDgoYik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYnl0ZXMgaW4gdGhpcyBidWZmZXIuIFRoZSBieXRlcyBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcsIGFuXG4gKiBBcnJheUJ1ZmZlciwgYSBEYXRhVmlldywgb3IgYSBUeXBlZEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gcHV0LlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyICgnYmluYXJ5JywgJ3V0ZjgnLFxuICogICAgICAgICAgJ3V0ZjE2JywgJ2hleCcpLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcywgZW5jb2RpbmcpIHtcbiAgaWYodXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gc3JjLmJ5dGVMZW5ndGggLSBzcmMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmFjY29tbW9kYXRlKGxlbik7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLndyaXRlICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmKHV0aWwuaXNBcnJheUJ1ZmZlcihieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIHRoaXMuYWNjb21tb2RhdGUoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyKTtcbiAgICBkc3Quc2V0KHNyYywgdGhpcy53cml0ZSk7XG4gICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGJ5dGVzIGlzIGEgdXRpbC5EYXRhQnVmZmVyIG9yIGVxdWl2YWxlbnRcbiAgaWYoYnl0ZXMgaW5zdGFuY2VvZiB1dGlsLkRhdGFCdWZmZXIgfHxcbiAgICAodHlwZW9mIGJ5dGVzID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBieXRlcy5yZWFkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYnl0ZXMud3JpdGUgPT09ICdudW1iZXInICYmXG4gICAgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcy5kYXRhKSkpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuZGF0YS5ieXRlTGVuZ3RoLCBieXRlcy5yZWFkLCBieXRlcy5sZW5ndGgoKSk7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmRhdGEuYnl0ZUxlbmd0aCwgdGhpcy53cml0ZSk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMud3JpdGUgKz0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZihieXRlcyBpbnN0YW5jZW9mIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlcikge1xuICAgIC8vIGNvcHkgYmluYXJ5IHN0cmluZyBhbmQgcHJvY2VzcyBhcyB0aGUgc2FtZSBhcyBhIHN0cmluZyBwYXJhbWV0ZXIgYmVsb3dcbiAgICBieXRlcyA9IGJ5dGVzLmRhdGE7XG4gICAgZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgfVxuXG4gIC8vIHN0cmluZyBjb252ZXJzaW9uXG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ2JpbmFyeSc7XG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmlldztcblxuICAgIC8vIGRlY29kZSBmcm9tIHN0cmluZ1xuICAgIGlmKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gMikpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5oZXguZGVjb2RlKGJ5dGVzLCB2aWV3LCB0aGlzLndyaXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZihlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJ5dGVzLmxlbmd0aCAvIDQpICogMyk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTggYnl0ZXNcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAvLyBlbmNvZGUgYXMgVVRGLTggdGhlbiBkZWNvZGUgc3RyaW5nIGFzIHJhdyBiaW5hcnlcbiAgICAgIGJ5dGVzID0gdXRpbC5lbmNvZGVVdGY4KGJ5dGVzKTtcbiAgICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIHN0cmluZyBhcyByYXcgYmluYXJ5XG4gICAgaWYoZW5jb2RpbmcgPT09ICdiaW5hcnknIHx8IGVuY29kaW5nID09PSAncmF3Jykge1xuICAgICAgLy8gb25lIGJ5dGUgcGVyIGNoYXJhY3RlclxuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShieXRlcy5sZW5ndGgpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5yYXcuZGVjb2RlKHZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTE2IGJ5dGVzXG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGYxNicpIHtcbiAgICAgIC8vIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCAqIDIpO1xuICAgICAgdmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC50ZXh0LnV0ZjE2LmVuY29kZSh2aWV3KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxuXG4gIHRocm93IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogJyArIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogUHV0cyB0aGUgZ2l2ZW4gYnVmZmVyIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHB1dCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHRoaXMucHV0Qnl0ZXMoYnVmZmVyKTtcbiAgYnVmZmVyLmNsZWFyKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyBmb3IgdGhlIHN0cmluZyAoZGVmYXVsdDogJ3V0ZjE2JykuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoc3RyLCAndXRmMTYnKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpID4+IDggJiAweEZGRkYpO1xuICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlLCBpID4+IDE2ICYgMHhGRik7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGEuc2V0SW50MzIodGhpcy53cml0ZSwgaSk7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDB4RkYpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgMHhGRkZGLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGksIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGFuIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuIC8gOCk7XG4gIGRvIHtcbiAgICBuIC09IDg7XG4gICAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSsrLCAoaSA+PiBuKSAmIDB4RkYpO1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHRoaXMuYWNjb21tb2RhdGUobiAvIDgpO1xuICBpZihpIDwgMCkge1xuICAgIGkgKz0gMiA8PCAobiAtIDEpO1xuICB9XG4gIHJldHVybiB0aGlzLnB1dEludChpLCBuKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgZnJvbSB0aGlzIGJ1ZmZlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSAxLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQsIHRydWUpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQgKyAxLCB0cnVlKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkLCB0cnVlKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGVcbiAqIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICAvLyBUT0RPOiBVc2UgKHJ2YWwgKiAweDEwMCkgaWYgYWRkaW5nIHN1cHBvcnQgZm9yIDMzIHRvIDUzIGJpdHMuXG4gICAgcnZhbCA9IChydmFsIDw8IDgpICsgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xuICAgIG4gLT0gODtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLCB1c2luZ1xuICogdHdvJ3MgY29tcGxlbWVudCwgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIC8vIGdldEludCBjaGVja3MgblxuICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICB2YXIgbWF4ID0gMiA8PCAobiAtIDIpO1xuICBpZih4ID49IG1heCkge1xuICAgIHggLT0gbWF4IDw8IDE7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIFJlYWRzIGJ5dGVzIG91dCBhcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGVcbiAqIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLCB1bmRlZmluZWQgb3IgbnVsbCBmb3IgYWxsLlxuICpcbiAqIEByZXR1cm4gYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcyBtZXRob2QsIGl0IGlzIHBvb3JseSBuYW1lZCBhbmRcbiAgLy8gdGhpcy50b1N0cmluZygnYmluYXJ5JykgcmVwbGFjZXMgaXRcbiAgLy8gYWRkIGEgdG9UeXBlZEFycmF5KCkvdG9BcnJheUJ1ZmZlcigpIGZ1bmN0aW9uXG4gIHZhciBydmFsO1xuICBpZihjb3VudCkge1xuICAgIC8vIHJlYWQgY291bnQgYnl0ZXNcbiAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpO1xuICAgIHRoaXMucmVhZCArPSBjb3VudDtcbiAgfSBlbHNlIGlmKGNvdW50ID09PSAwKSB7XG4gICAgcnZhbCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgYWxsIGJ5dGVzLCBvcHRpbWl6ZSB0byBvbmx5IGNvcHkgd2hlbiBuZWVkZWRcbiAgICBydmFsID0gKHRoaXMucmVhZCA9PT0gMCkgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dFxuICogbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIGJpbmFyeSBlbmNvZGVkIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcyBtZXRob2QsIGl0IGlzIHBvb3JseSBuYW1lZCwgYWRkIFwiZ2V0U3RyaW5nKClcIlxuICByZXR1cm4gKHR5cGVvZihjb3VudCkgPT09ICd1bmRlZmluZWQnID9cbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKSA6XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLnJlYWQgKyBpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgdGhpcy5kYXRhLnNldFVpbnQ4KGksIGIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBieXRlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHJldHVybiB0aGUgbGFzdCBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLndyaXRlIC0gMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNvcHkuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IHV0aWwuRGF0YUJ1ZmZlcih0aGlzKTtcbn07XG5cbi8qKlxuICogQ29tcGFjdHMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMucmVhZCA+IDApIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5yZWFkKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoZHN0KTtcbiAgICB0aGlzLndyaXRlIC09IHRoaXMucmVhZDtcbiAgICB0aGlzLnJlYWQgPSAwO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgdGhpcy5yZWFkID0gdGhpcy53cml0ZSA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTaG9ydGVucyB0aGlzIGJ1ZmZlciBieSB0cmltaW5nIGJ5dGVzIG9mZiBvZiB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHRyaW0gb2ZmLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihjb3VudCkge1xuICB0aGlzLndyaXRlID0gTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgoKSAtIGNvdW50KTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkLCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAnJztcbiAgZm9yKHZhciBpID0gdGhpcy5yZWFkOyBpIDwgdGhpcy5kYXRhLmJ5dGVMZW5ndGg7ICsraSkge1xuICAgIHZhciBiID0gdGhpcy5kYXRhLmdldFVpbnQ4KGkpO1xuICAgIGlmKGIgPCAxNikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgc3RyaW5nLCB1c2luZyB0aGUgZ2l2ZW4gZW5jb2RpbmcuIElmIG5vXG4gKiBlbmNvZGluZyBpcyBnaXZlbiwgJ3V0ZjgnIChVVEYtOCkgaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0gW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgdG8gdXNlOiAnYmluYXJ5JywgJ3V0ZjgnLCAndXRmMTYnLCAnaGV4JyxcbiAqICAgICAgICAgICdiYXNlNjQnIChkZWZhdWx0OiAndXRmOCcpLlxuICpcbiAqIEByZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEsIHRoaXMucmVhZCwgdGhpcy5sZW5ndGgoKSk7XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIGVuY29kZSB0byBzdHJpbmdcbiAgaWYoZW5jb2RpbmcgPT09ICdiaW5hcnknIHx8IGVuY29kaW5nID09PSAncmF3Jykge1xuICAgIHJldHVybiB1dGlsLmJpbmFyeS5yYXcuZW5jb2RlKHZpZXcpO1xuICB9XG4gIGlmKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgIHJldHVybiB1dGlsLmJpbmFyeS5oZXguZW5jb2RlKHZpZXcpO1xuICB9XG4gIGlmKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlNjQuZW5jb2RlKHZpZXcpO1xuICB9XG5cbiAgLy8gZGVjb2RlIHRvIHRleHRcbiAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmOC5kZWNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICd1dGYxNicpIHtcbiAgICByZXR1cm4gdXRpbC50ZXh0LnV0ZjE2LmRlY29kZSh2aWV3KTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbn07XG5cbi8qKiBFbmQgQnVmZmVyIHcvVUludDhBcnJheSBiYWNraW5nICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGJ1ZmZlciB0aGF0IHN0b3JlcyBieXRlcy4gQSB2YWx1ZSBtYXkgYmUgZ2l2ZW4gdG8gcG9wdWxhdGUgdGhlXG4gKiBidWZmZXIgd2l0aCBkYXRhLiBUaGlzIHZhbHVlIGNhbiBlaXRoZXIgYmUgc3RyaW5nIG9mIGVuY29kZWQgYnl0ZXMgb3IgYVxuICogcmVndWxhciBzdHJpbmcgb2YgY2hhcmFjdGVycy4gV2hlbiBwYXNzaW5nIGEgc3RyaW5nIG9mIGJpbmFyeSBlbmNvZGVkXG4gKiBieXRlcywgdGhlIGVuY29kaW5nIGByYXdgIHNob3VsZCBiZSBnaXZlbi4gVGhpcyBpcyBhbHNvIHRoZSBkZWZhdWx0LiBXaGVuXG4gKiBwYXNzaW5nIGEgc3RyaW5nIG9mIGNoYXJhY3RlcnMsIHRoZSBlbmNvZGluZyBgdXRmOGAgc2hvdWxkIGJlIGdpdmVuLlxuICpcbiAqIEBwYXJhbSBbaW5wdXRdIGEgc3RyaW5nIHdpdGggZW5jb2RlZCBieXRlcyB0byBzdG9yZSBpbiB0aGUgYnVmZmVyLlxuICogQHBhcmFtIFtlbmNvZGluZ10gKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAqL1xudXRpbC5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbihpbnB1dCwgZW5jb2RpbmcpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlLCB1c2UgbmV3IEJ5dGVCdWZmZXIoKSBpbnN0ZWFkXG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3Jhdyc7XG4gIGlmKGlucHV0ICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgIGlucHV0ID0gdXRpbC5lbmNvZGVVdGY4KGlucHV0KTtcbiAgfVxuICByZXR1cm4gbmV3IHV0aWwuQnl0ZUJ1ZmZlcihpbnB1dCk7XG59O1xuXG4vKipcbiAqIEZpbGxzIGEgc3RyaW5nIHdpdGggYSBwYXJ0aWN1bGFyIHZhbHVlLiBJZiB5b3Ugd2FudCB0aGUgc3RyaW5nIHRvIGJlIGEgYnl0ZVxuICogc3RyaW5nLCBwYXNzIGluIFN0cmluZy5mcm9tQ2hhckNvZGUodGhlQnl0ZSkuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNoYXJhY3RlciB0byBmaWxsIHRoZSBzdHJpbmcgd2l0aCwgdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAqICAgICAgICAgIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoIGEgYnl0ZSB2YWx1ZS5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBvZiB2YWx1ZSBjIHRvIGZpbGwgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBmaWxsZWQgc3RyaW5nLlxuICovXG51dGlsLmZpbGxTdHJpbmcgPSBmdW5jdGlvbihjLCBuKSB7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlKG4gPiAwKSB7XG4gICAgaWYobiAmIDEpIHtcbiAgICAgIHMgKz0gYztcbiAgICB9XG4gICAgbiA+Pj49IDE7XG4gICAgaWYobiA+IDApIHtcbiAgICAgIGMgKz0gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgcGVyIGJ5dGUgWE9SIGJldHdlZW4gdHdvIGJ5dGUgc3RyaW5ncyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGFcbiAqIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gczEgZmlyc3Qgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIHMyIHNlY29uZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIFhPUi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBYT1InZCByZXN1bHQuXG4gKi9cbnV0aWwueG9yQnl0ZXMgPSBmdW5jdGlvbihzMSwgczIsIG4pIHtcbiAgdmFyIHMzID0gJyc7XG4gIHZhciBiID0gJyc7XG4gIHZhciB0ID0gJyc7XG4gIHZhciBpID0gMDtcbiAgdmFyIGMgPSAwO1xuICBmb3IoOyBuID4gMDsgLS1uLCArK2kpIHtcbiAgICBiID0gczEuY2hhckNvZGVBdChpKSBeIHMyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYoYyA+PSAxMCkge1xuICAgICAgczMgKz0gdDtcbiAgICAgIHQgPSAnJztcbiAgICAgIGMgPSAwO1xuICAgIH1cbiAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gICAgKytjO1xuICB9XG4gIHMzICs9IHQ7XG4gIHJldHVybiBzMztcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggc3RyaW5nIGludG8gYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaGV4IHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuaGV4VG9CeXRlcyA9IGZ1bmN0aW9uKGhleCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmhleC5kZWNvZGUgaW5zdGVhZC5cIlxuICB2YXIgcnZhbCA9ICcnO1xuICB2YXIgaSA9IDA7XG4gIGlmKGhleC5sZW5ndGggJiAxID09IDEpIHtcbiAgICAvLyBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGNvbnZlcnQgZmlyc3QgY2hhcmFjdGVyIGFsb25lXG4gICAgaSA9IDE7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleFswXSwgMTYpKTtcbiAgfVxuICAvLyBjb252ZXJ0IDIgY2hhcmFjdGVycyAoMSBieXRlKSBhdCBhIHRpbWVcbiAgZm9yKDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJ2YWwgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNikpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIHRvIGhleC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuYnl0ZXNUb0hleCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHJldHVybiB1dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcykudG9IZXgoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gMzItYml0IGludGVnZXIgdG8gNC1iaWctZW5kaWFuIGJ5dGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUgc3RyaW5nLlxuICovXG51dGlsLmludDMyVG9CeXRlcyA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIChcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8vIGJhc2U2NCBjaGFyYWN0ZXJzLCByZXZlcnNlIG1hcHBpbmdcbnZhciBfYmFzZTY0ID1cbiAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbnZhciBfYmFzZTY0SWR4ID0gW1xuLyo0MyAtNDMgPSAwKi9cbi8qJysnLCAgMSwgIDIsICAzLCcvJyAqL1xuICAgNjIsIC0xLCAtMSwgLTEsIDYzLFxuXG4vKicwJywnMScsJzInLCczJywnNCcsJzUnLCc2JywnNycsJzgnLCc5JyAqL1xuICAgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNTgsIDU5LCA2MCwgNjEsXG5cbi8qMTUsIDE2LCAxNywnPScsIDE5LCAyMCwgMjEgKi9cbiAgLTEsIC0xLCAtMSwgNjQsIC0xLCAtMSwgLTEsXG5cbi8qNjUgLSA0MyA9IDIyKi9cbi8qJ0EnLCdCJywnQycsJ0QnLCdFJywnRicsJ0cnLCdIJywnSScsJ0onLCdLJywnTCcsJ00nLCAqL1xuICAgMCwgIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgMTAsIDExLCAxMixcblxuLyonTicsJ08nLCdQJywnUScsJ1InLCdTJywnVCcsJ1UnLCdWJywnVycsJ1gnLCdZJywnWicgKi9cbiAgIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LFxuXG4vKjkxIC0gNDMgPSA0OCAqL1xuLyo0OCwgNDksIDUwLCA1MSwgNTIsIDUzICovXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG5cbi8qOTcgLSA0MyA9IDU0Ki9cbi8qJ2EnLCdiJywnYycsJ2QnLCdlJywnZicsJ2cnLCdoJywnaScsJ2onLCdrJywnbCcsJ20nICovXG4gICAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCxcblxuLyonbicsJ28nLCdwJywncScsJ3InLCdzJywndCcsJ3UnLCd2JywndycsJ3gnLCd5JywneicgKi9cbiAgIDM5LCA0MCwgNDEsIDQyLCA0MywgNDQsIDQ1LCA0NiwgNDcsIDQ4LCA0OSwgNTAsIDUxXG5dO1xuXG4vLyBiYXNlNTggY2hhcmFjdGVycyAoQml0Y29pbiBhbHBoYWJldClcbnZhciBfYmFzZTU4ID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonO1xuXG4vKipcbiAqIEJhc2U2NCBlbmNvZGVzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gYmFzZTY0LWVuY29kZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbmNvZGVkIGNoYXJhY3RlcnMgcGVyIGxpbmUgdG8gdXNlLFxuICogICAgICAgICAgZGVmYXVsdHMgdG8gbm9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiYXNlNjQtZW5jb2RlZCBvdXRwdXQuXG4gKi9cbnV0aWwuZW5jb2RlNjQgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUgaW5zdGVhZC5cIlxuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgIGNocjIgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMyA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcblxuICAgIC8vIGVuY29kZSA0IGNoYXJhY3RlciBncm91cFxuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoY2hyMSA+PiAyKTtcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCkpO1xuICAgIGlmKGlzTmFOKGNocjIpKSB7XG4gICAgICBsaW5lICs9ICc9PSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpO1xuICAgICAgbGluZSArPSBpc05hTihjaHIzKSA/ICc9JyA6IF9iYXNlNjQuY2hhckF0KGNocjMgJiA2Myk7XG4gICAgfVxuXG4gICAgaWYobWF4bGluZSAmJiBsaW5lLmxlbmd0aCA+IG1heGxpbmUpIHtcbiAgICAgIG91dHB1dCArPSBsaW5lLnN1YnN0cigwLCBtYXhsaW5lKSArICdcXHJcXG4nO1xuICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKG1heGxpbmUpO1xuICAgIH1cbiAgfVxuICBvdXRwdXQgKz0gbGluZTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQmFzZTY0IGRlY29kZXMgYSBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZTY0LWVuY29kZWQgaW5wdXQuXG4gKlxuICogQHJldHVybiB0aGUgYmluYXJ5IGVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmRlY29kZTY0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5iYXNlNjQuZGVjb2RlIGluc3RlYWQuXCJcblxuICAvLyByZW1vdmUgYWxsIG5vbi1iYXNlNjQgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBlbmMxID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMiA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzMgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmM0ID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG5cbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpKTtcbiAgICBpZihlbmMzICE9PSA2NCkge1xuICAgICAgLy8gZGVjb2RlZCBhdCBsZWFzdCAyIGJ5dGVzXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKSk7XG4gICAgICBpZihlbmM0ICE9PSA2NCkge1xuICAgICAgICAvLyBkZWNvZGVkIDMgYnl0ZXNcbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChlbmMzICYgMykgPDwgNikgfCBlbmM0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgb2YgY2hhcmFjdGVycyAoYSBzdGFuZGFyZCBKYXZhU2NyaXB0XG4gKiBzdHJpbmcpIGFzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIHdoZXJlIHRoZSBieXRlcyByZXByZXNlbnRcbiAqIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgb2YgY2hhcmFjdGVycy4gTm9uLUFTQ0lJIGNoYXJhY3RlcnMgd2lsbCBiZVxuICogZW5jb2RlZCBhcyBtdWx0aXBsZSBieXRlcyBhY2NvcmRpbmcgdG8gVVRGLTguXG4gKlxuICogQHBhcmFtIHN0ciBhIHN0YW5kYXJkIHN0cmluZyBvZiBjaGFyYWN0ZXJzIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZW5jb2RlVXRmOCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIHRoYXQgY29udGFpbnMgYnl0ZXMgdGhhdFxuICogcmVwcmVzZW50IGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgb2YgY2hhcmFjdGVycyAtLSBpbnRvIGFcbiAqIHN0cmluZyBvZiBjaGFyYWN0ZXJzIChhIHN0YW5kYXJkIEphdmFTY3JpcHQgc3RyaW5nKS5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdGFuZGFyZCBzdHJpbmcgb2YgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5kZWNvZGVVdGY4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufTtcblxuLy8gYmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIHRvb2xzXG4vLyBGSVhNRTogRXhwZXJpbWVudGFsLiBEbyBub3QgdXNlIHlldC5cbnV0aWwuYmluYXJ5ID0ge1xuICByYXc6IHt9LFxuICBoZXg6IHt9LFxuICBiYXNlNjQ6IHt9LFxuICBiYXNlNTg6IHt9LFxuICBiYXNlTiA6IHtcbiAgICBlbmNvZGU6IGJhc2VOLmVuY29kZSxcbiAgICBkZWNvZGU6IGJhc2VOLmRlY29kZVxuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBVaW50OEFycmF5IGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nLiBUaGlzIGVuY29kaW5nIHVzZXNcbiAqIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUgZm9yIGVhY2ggY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgVWludDhBcnJheSB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgYmluYXJ5LWVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmJpbmFyeS5yYXcuZW5jb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIHRvIGEgVWludDhBcnJheS4gVGhpcyBlbmNvZGluZyB1c2VzXG4gKiBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1IGZvciBlYWNoIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkucmF3LmRlY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICB9XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaiA9IG9mZnNldDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIG91dFtqKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dDtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhICdiaW5hcnknIHN0cmluZywgQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBUeXBlZEFycmF5LCBvclxuICogQnl0ZUJ1ZmZlciBhcyBhIHN0cmluZyBvZiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5iaW5hcnkuaGV4LmVuY29kZSA9IHV0aWwuYnl0ZXNUb0hleDtcblxuLyoqXG4gKiBEZWNvZGVzIGEgaGV4LWVuY29kZWQgc3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaGV4IHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LmhleC5kZWNvZGUgPSBmdW5jdGlvbihoZXgsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoaGV4Lmxlbmd0aCAvIDIpKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGkgPSAwLCBqID0gb2Zmc2V0O1xuICBpZihoZXgubGVuZ3RoICYgMSkge1xuICAgIC8vIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgY29udmVydCBmaXJzdCBjaGFyYWN0ZXIgYWxvbmVcbiAgICBpID0gMTtcbiAgICBvdXRbaisrXSA9IHBhcnNlSW50KGhleFswXSwgMTYpO1xuICB9XG4gIC8vIGNvbnZlcnQgMiBjaGFyYWN0ZXJzICgxIGJ5dGUpIGF0IGEgdGltZVxuICBmb3IoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgb3V0W2orK10gPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gIH1cbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dDtcbn07XG5cbi8qKlxuICogQmFzZTY0LWVuY29kZXMgYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgVWludDhBcnJheSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZW5jb2RlZCBjaGFyYWN0ZXJzIHBlciBsaW5lIHRvIHVzZSxcbiAqICAgICAgICAgIGRlZmF1bHRzIHRvIG5vbmUuXG4gKlxuICogQHJldHVybiB0aGUgYmFzZTY0LWVuY29kZWQgb3V0cHV0IHN0cmluZy5cbiAqL1xudXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUoaSA8IGlucHV0LmJ5dGVMZW5ndGgpIHtcbiAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICBjaHIyID0gaW5wdXRbaSsrXTtcbiAgICBjaHIzID0gaW5wdXRbaSsrXTtcblxuICAgIC8vIGVuY29kZSA0IGNoYXJhY3RlciBncm91cFxuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoY2hyMSA+PiAyKTtcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCkpO1xuICAgIGlmKGlzTmFOKGNocjIpKSB7XG4gICAgICBsaW5lICs9ICc9PSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpO1xuICAgICAgbGluZSArPSBpc05hTihjaHIzKSA/ICc9JyA6IF9iYXNlNjQuY2hhckF0KGNocjMgJiA2Myk7XG4gICAgfVxuXG4gICAgaWYobWF4bGluZSAmJiBsaW5lLmxlbmd0aCA+IG1heGxpbmUpIHtcbiAgICAgIG91dHB1dCArPSBsaW5lLnN1YnN0cigwLCBtYXhsaW5lKSArICdcXHJcXG4nO1xuICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKG1heGxpbmUpO1xuICAgIH1cbiAgfVxuICBvdXRwdXQgKz0gbGluZTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlNjQtZW5jb2RlZCBpbnB1dCBzdHJpbmcuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwoaW5wdXQubGVuZ3RoIC8gNCkgKiAzKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbGwgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcblxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gIHZhciBpID0gMCwgaiA9IG9mZnNldDtcblxuICB3aGlsZShpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgZW5jMSA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzIgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMzID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jNCA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuXG4gICAgb3V0W2orK10gPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgIGlmKGVuYzMgIT09IDY0KSB7XG4gICAgICAvLyBkZWNvZGVkIGF0IGxlYXN0IDIgYnl0ZXNcbiAgICAgIG91dFtqKytdID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICBpZihlbmM0ICE9PSA2NCkge1xuICAgICAgICAvLyBkZWNvZGVkIDMgYnl0ZXNcbiAgICAgICAgb3V0W2orK10gPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHJlc3VsdCBpcyB0aGUgZXhhY3QgZGVjb2RlZCBsZW5ndGhcbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dC5zdWJhcnJheSgwLCBqKTtcbn07XG5cbi8vIGFkZCBzdXBwb3J0IGZvciBiYXNlNTggZW5jb2RpbmcvZGVjb2Rpbmcgd2l0aCBCaXRjb2luIGFscGhhYmV0XG51dGlsLmJpbmFyeS5iYXNlNTguZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2VOLmVuY29kZShpbnB1dCwgX2Jhc2U1OCwgbWF4bGluZSk7XG59O1xudXRpbC5iaW5hcnkuYmFzZTU4LmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlTi5kZWNvZGUoaW5wdXQsIF9iYXNlNTgsIG1heGxpbmUpO1xufTtcblxuLy8gdGV4dCBlbmNvZGluZy9kZWNvZGluZyB0b29sc1xuLy8gRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG51dGlsLnRleHQgPSB7XG4gIHV0Zjg6IHt9LFxuICB1dGYxNjoge31cbn07XG5cbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIFVURi04IGluIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC50ZXh0LnV0ZjguZW5jb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICBzdHIgPSB1dGlsLmVuY29kZVV0Zjgoc3RyKTtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICB9XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaiA9IG9mZnNldDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIG91dFtqKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgVVRGLTggY29udGVudHMgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGRlY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICovXG51dGlsLnRleHQudXRmOC5kZWNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gdXRpbC5kZWNvZGVVdGY4KFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIFVURi0xNiBpbiBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwudGV4dC51dGYxNi5lbmNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoICogMik7XG4gIH1cbiAgdmFyIHZpZXcgPSBuZXcgVWludDE2QXJyYXkob3V0LmJ1ZmZlcik7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaiA9IG9mZnNldDtcbiAgdmFyIGsgPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICB2aWV3W2srK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBqICs9IDI7XG4gIH1cbiAgcmV0dXJuIG91dHB1dCA/IChqIC0gb2Zmc2V0KSA6IG91dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgVVRGLTE2IGNvbnRlbnRzIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgVWludDhBcnJheSB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAqL1xudXRpbC50ZXh0LnV0ZjE2LmRlY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShieXRlcy5idWZmZXIpKTtcbn07XG5cbi8qKlxuICogRGVmbGF0ZXMgdGhlIGdpdmVuIGRhdGEgdXNpbmcgYSBmbGFzaCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBkYXRhLlxuICogQHBhcmFtIHJhdyB0cnVlIHRvIHJldHVybiBvbmx5IHJhdyBkZWZsYXRlIGRhdGEsIGZhbHNlIHRvIGluY2x1ZGUgemxpYlxuICogICAgICAgICAgaGVhZGVyIGFuZCB0cmFpbGVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlZmxhdGVkIGRhdGEgYXMgYSBzdHJpbmcuXG4gKi9cbnV0aWwuZGVmbGF0ZSA9IGZ1bmN0aW9uKGFwaSwgYnl0ZXMsIHJhdykge1xuICBieXRlcyA9IHV0aWwuZGVjb2RlNjQoYXBpLmRlZmxhdGUodXRpbC5lbmNvZGU2NChieXRlcykpLnJ2YWwpO1xuXG4gIC8vIHN0cmlwIHpsaWIgaGVhZGVyIGFuZCB0cmFpbGVyIGlmIG5lY2Vzc2FyeVxuICBpZihyYXcpIHtcbiAgICAvLyB6bGliIGhlYWRlciBpcyAyIGJ5dGVzIChDTUYsRkxHKSB3aGVyZSBGTEcgaW5kaWNhdGVzIHRoYXRcbiAgICAvLyB0aGVyZSBpcyBhIDQtYnl0ZSBESUNUIChhbGRlci0zMikgYmxvY2sgYmVmb3JlIHRoZSBkYXRhIGlmXG4gICAgLy8gaXRzIDV0aCBiaXQgaXMgc2V0XG4gICAgdmFyIHN0YXJ0ID0gMjtcbiAgICB2YXIgZmxnID0gYnl0ZXMuY2hhckNvZGVBdCgxKTtcbiAgICBpZihmbGcgJiAweDIwKSB7XG4gICAgICBzdGFydCA9IDY7XG4gICAgfVxuICAgIC8vIHpsaWIgdHJhaWxlciBpcyA0IGJ5dGVzIG9mIGFkbGVyLTMyXG4gICAgYnl0ZXMgPSBieXRlcy5zdWJzdHJpbmcoc3RhcnQsIGJ5dGVzLmxlbmd0aCAtIDQpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLyoqXG4gKiBJbmZsYXRlcyB0aGUgZ2l2ZW4gZGF0YSB1c2luZyBhIGZsYXNoIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGRhdGEuXG4gKiBAcGFyYW0gcmF3IHRydWUgaWYgdGhlIGluY29taW5nIGRhdGEgaGFzIG5vIHpsaWIgaGVhZGVyIG9yIHRyYWlsZXIgYW5kIGlzXG4gKiAgICAgICAgICByYXcgREVGTEFURSBkYXRhLlxuICpcbiAqIEByZXR1cm4gdGhlIGluZmxhdGVkIGRhdGEgYXMgYSBzdHJpbmcsIG51bGwgb24gZXJyb3IuXG4gKi9cbnV0aWwuaW5mbGF0ZSA9IGZ1bmN0aW9uKGFwaSwgYnl0ZXMsIHJhdykge1xuICAvLyBUT0RPOiBhZGQgemxpYiBoZWFkZXIgYW5kIHRyYWlsZXIgaWYgbmVjZXNzYXJ5L3Bvc3NpYmxlXG4gIHZhciBydmFsID0gYXBpLmluZmxhdGUodXRpbC5lbmNvZGU2NChieXRlcykpLnJ2YWw7XG4gIHJldHVybiAocnZhbCA9PT0gbnVsbCkgPyBudWxsIDogdXRpbC5kZWNvZGU2NChydmFsKTtcbn07XG5cbi8qKlxuICogU2V0cyBhIHN0b3JhZ2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBvYmogdGhlIHN0b3JhZ2Ugb2JqZWN0LCBudWxsIHRvIHJlbW92ZS5cbiAqL1xudmFyIF9zZXRTdG9yYWdlT2JqZWN0ID0gZnVuY3Rpb24oYXBpLCBpZCwgb2JqKSB7XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgfVxuXG4gIHZhciBydmFsO1xuICBpZihvYmogPT09IG51bGwpIHtcbiAgICBydmFsID0gYXBpLnJlbW92ZUl0ZW0oaWQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGpzb24tZW5jb2RlIGFuZCBiYXNlNjQtZW5jb2RlIG9iamVjdFxuICAgIG9iaiA9IHV0aWwuZW5jb2RlNjQoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgcnZhbCA9IGFwaS5zZXRJdGVtKGlkLCBvYmopO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBvdGVudGlhbCBmbGFzaCBlcnJvclxuICBpZih0eXBlb2YocnZhbCkgIT09ICd1bmRlZmluZWQnICYmIHJ2YWwucnZhbCAhPT0gdHJ1ZSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihydmFsLmVycm9yLm1lc3NhZ2UpO1xuICAgIGVycm9yLmlkID0gcnZhbC5lcnJvci5pZDtcbiAgICBlcnJvci5uYW1lID0gcnZhbC5lcnJvci5uYW1lO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgYSBzdG9yYWdlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgc3RvcmFnZSBvYmplY3QgZW50cnkgb3IgbnVsbCBpZiBub25lIGV4aXN0cy5cbiAqL1xudmFyIF9nZXRTdG9yYWdlT2JqZWN0ID0gZnVuY3Rpb24oYXBpLCBpZCkge1xuICBpZighYXBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gIH1cblxuICAvLyBnZXQgdGhlIGV4aXN0aW5nIGVudHJ5XG4gIHZhciBydmFsID0gYXBpLmdldEl0ZW0oaWQpO1xuXG4gIC8qIE5vdGU6IFdlIGNoZWNrIGFwaS5pbml0IGJlY2F1c2Ugd2UgY2FuJ3QgZG8gKGFwaSA9PSBsb2NhbFN0b3JhZ2UpXG4gICAgb24gSUUgYmVjYXVzZSBvZiBcIkNsYXNzIGRvZXNuJ3Qgc3VwcG9ydCBBdXRvbWF0aW9uXCIgZXhjZXB0aW9uLiBPbmx5XG4gICAgdGhlIGZsYXNoIGFwaSBoYXMgYW4gaW5pdCBtZXRob2Qgc28gdGhpcyB3b3JrcyB0b28sIGJ1dCB3ZSBuZWVkIGFcbiAgICBiZXR0ZXIgc29sdXRpb24gaW4gdGhlIGZ1dHVyZS4gKi9cblxuICAvLyBmbGFzaCByZXR1cm5zIGl0ZW0gd3JhcHBlZCBpbiBhbiBvYmplY3QsIGhhbmRsZSBzcGVjaWFsIGNhc2VcbiAgaWYoYXBpLmluaXQpIHtcbiAgICBpZihydmFsLnJ2YWwgPT09IG51bGwpIHtcbiAgICAgIGlmKHJ2YWwuZXJyb3IpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJ2YWwuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGVycm9yLmlkID0gcnZhbC5lcnJvci5pZDtcbiAgICAgICAgZXJyb3IubmFtZSA9IHJ2YWwuZXJyb3IubmFtZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICAvLyBubyBlcnJvciwgYnV0IGFsc28gbm8gaXRlbVxuICAgICAgcnZhbCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgPSBydmFsLnJ2YWw7XG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlIGRlY29kaW5nXG4gIGlmKHJ2YWwgIT09IG51bGwpIHtcbiAgICAvLyBiYXNlNjQtZGVjb2RlIGFuZCBqc29uLWRlY29kZSBkYXRhXG4gICAgcnZhbCA9IEpTT04ucGFyc2UodXRpbC5kZWNvZGU2NChydmFsKSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU3RvcmVzIGFuIGl0ZW0gaW4gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgZm9yIHRoZSBpdGVtIChhbnkgamF2YXNjcmlwdCBvYmplY3QvcHJpbWl0aXZlKS5cbiAqL1xudmFyIF9zZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBkYXRhKSB7XG4gIC8vIGdldCBzdG9yYWdlIG9iamVjdFxuICB2YXIgb2JqID0gX2dldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCk7XG4gIGlmKG9iaiA9PT0gbnVsbCkge1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBzdG9yYWdlIG9iamVjdFxuICAgIG9iaiA9IHt9O1xuICB9XG4gIC8vIHVwZGF0ZSBrZXlcbiAgb2JqW2tleV0gPSBkYXRhO1xuXG4gIC8vIHNldCBzdG9yYWdlIG9iamVjdFxuICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBvYmopO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGl0ZW0gZnJvbSBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKlxuICogQHJldHVybiB0aGUgaXRlbS5cbiAqL1xudmFyIF9nZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5KSB7XG4gIC8vIGdldCBzdG9yYWdlIG9iamVjdFxuICB2YXIgcnZhbCA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgLy8gcmV0dXJuIGRhdGEgYXQga2V5XG4gICAgcnZhbCA9IChrZXkgaW4gcnZhbCkgPyBydmFsW2tleV0gOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqL1xudmFyIF9yZW1vdmVJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5KSB7XG4gIC8vIGdldCBzdG9yYWdlIG9iamVjdFxuICB2YXIgb2JqID0gX2dldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCk7XG4gIGlmKG9iaiAhPT0gbnVsbCAmJiBrZXkgaW4gb2JqKSB7XG4gICAgLy8gcmVtb3ZlIGtleVxuICAgIGRlbGV0ZSBvYmpba2V5XTtcblxuICAgIC8vIHNlZSBpZiBlbnRyeSBoYXMgbm8ga2V5cyByZW1haW5pbmdcbiAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgIGZvcih2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYoZW1wdHkpIHtcbiAgICAgIC8vIHJlbW92ZSBlbnRyeSBlbnRpcmVseSBpZiBubyBrZXlzIGFyZSBsZWZ0XG4gICAgICBvYmogPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHNldCBzdG9yYWdlIG9iamVjdFxuICAgIF9zZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQsIG9iaik7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBsb2NhbCBkaXNrIHN0b3JhZ2UgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gSUQuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICovXG52YXIgX2NsZWFySXRlbXMgPSBmdW5jdGlvbihhcGksIGlkKSB7XG4gIF9zZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQsIG51bGwpO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIHN0b3JhZ2UgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGZ1bmMgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gYXJncyB0aGUgYXJndW1lbnRzIGZvciB0aGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0gbG9jYXRpb24gdGhlIGxvY2F0aW9uIGFyZ3VtZW50LlxuICpcbiAqIEByZXR1cm4gdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbi5cbiAqL1xudmFyIF9jYWxsU3RvcmFnZUZ1bmN0aW9uID0gZnVuY3Rpb24oZnVuYywgYXJncywgbG9jYXRpb24pIHtcbiAgdmFyIHJ2YWwgPSBudWxsO1xuXG4gIC8vIGRlZmF1bHQgc3RvcmFnZSB0eXBlc1xuICBpZih0eXBlb2YobG9jYXRpb24pID09PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2F0aW9uID0gWyd3ZWInLCAnZmxhc2gnXTtcbiAgfVxuXG4gIC8vIGFwcGx5IHN0b3JhZ2UgdHlwZXMgaW4gb3JkZXIgb2YgcHJlZmVyZW5jZVxuICB2YXIgdHlwZTtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIGV4Y2VwdGlvbiA9IG51bGw7XG4gIGZvcih2YXIgaWR4IGluIGxvY2F0aW9uKSB7XG4gICAgdHlwZSA9IGxvY2F0aW9uW2lkeF07XG4gICAgdHJ5IHtcbiAgICAgIGlmKHR5cGUgPT09ICdmbGFzaCcgfHwgdHlwZSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGlmKGFyZ3NbMF0gPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXNoIGxvY2FsIHN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBydmFsID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgZG9uZSA9ICh0eXBlID09PSAnZmxhc2gnKTtcbiAgICAgIH1cbiAgICAgIGlmKHR5cGUgPT09ICd3ZWInIHx8IHR5cGUgPT09ICdib3RoJykge1xuICAgICAgICBhcmdzWzBdID0gbG9jYWxTdG9yYWdlO1xuICAgICAgICBydmFsID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaChleCkge1xuICAgICAgZXhjZXB0aW9uID0gZXg7XG4gICAgfVxuICAgIGlmKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmKCFkb25lKSB7XG4gICAgdGhyb3cgZXhjZXB0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFN0b3JlcyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogVGhlIGF2YWlsYWJsZSB0eXBlcyBvZiBsb2NhbCBzdG9yYWdlIGluY2x1ZGUgJ2ZsYXNoJywgJ3dlYicsIGFuZCAnYm90aCcuXG4gKlxuICogVGhlIHR5cGUgJ2ZsYXNoJyByZWZlcnMgdG8gZmxhc2ggbG9jYWwgc3RvcmFnZSAoU2hhcmVkT2JqZWN0KS4gSW4gb3JkZXJcbiAqIHRvIHVzZSBmbGFzaCBsb2NhbCBzdG9yYWdlLCB0aGUgJ2FwaScgcGFyYW1ldGVyIG11c3QgYmUgdmFsaWQuIFRoZSB0eXBlXG4gKiAnd2ViJyByZWZlcnMgdG8gV2ViU3RvcmFnZSwgaWYgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLiBUaGUgdHlwZSAnYm90aCdcbiAqIHJlZmVycyB0byBzdG9yaW5nIHVzaW5nIGJvdGggJ2ZsYXNoJyBhbmQgJ3dlYicsIG5vdCBqdXN0IG9uZSBvciB0aGVcbiAqIG90aGVyLlxuICpcbiAqIFRoZSBsb2NhdGlvbiBhcnJheSBzaG91bGQgbGlzdCB0aGUgc3RvcmFnZSB0eXBlcyB0byB1c2UgaW4gb3JkZXIgb2ZcbiAqIHByZWZlcmVuY2U6XG4gKlxuICogWydmbGFzaCddOiBmbGFzaCBvbmx5IHN0b3JhZ2VcbiAqIFsnd2ViJ106IHdlYiBvbmx5IHN0b3JhZ2VcbiAqIFsnYm90aCddOiB0cnkgdG8gc3RvcmUgaW4gYm90aFxuICogWydmbGFzaCcsJ3dlYiddOiBzdG9yZSBpbiBmbGFzaCBmaXJzdCwgYnV0IGlmIG5vdCBhdmFpbGFibGUsICd3ZWInXG4gKiBbJ3dlYicsJ2ZsYXNoJ106IHN0b3JlIGluIHdlYiBmaXJzdCwgYnV0IGlmIG5vdCBhdmFpbGFibGUsICdmbGFzaCdcbiAqXG4gKiBUaGUgbG9jYXRpb24gYXJyYXkgZGVmYXVsdHMgdG86IFsnd2ViJywgJ2ZsYXNoJ11cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UsIG51bGwgdG8gdXNlIG9ubHkgV2ViU3RvcmFnZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgZm9yIHRoZSBpdGVtIChhbnkgamF2YXNjcmlwdCBvYmplY3QvcHJpbWl0aXZlKS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwuc2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgZGF0YSwgbG9jYXRpb24pIHtcbiAgX2NhbGxTdG9yYWdlRnVuY3Rpb24oX3NldEl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGl0ZW0gb24gbG9jYWwgZGlzay5cbiAqXG4gKiBTZXQgc2V0SXRlbSgpIGZvciBkZXRhaWxzIG9uIHN0b3JhZ2UgdHlwZXMuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLCBudWxsIHRvIHVzZSBvbmx5IFdlYlN0b3JhZ2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgaXRlbS5cbiAqL1xudXRpbC5nZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBsb2NhdGlvbikge1xuICByZXR1cm4gX2NhbGxTdG9yYWdlRnVuY3Rpb24oX2dldEl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gb24gbG9jYWwgZGlzay5cbiAqXG4gKiBTZXQgc2V0SXRlbSgpIGZvciBkZXRhaWxzIG9uIHN0b3JhZ2UgdHlwZXMuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9yZW1vdmVJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBsb2NhbCBkaXNrIHN0b3JhZ2UgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gSUQuXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSBpZiBmbGFzaCBpcyBhdmFpbGFibGUuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5jbGVhckl0ZW1zID0gZnVuY3Rpb24oYXBpLCBpZCwgbG9jYXRpb24pIHtcbiAgX2NhbGxTdG9yYWdlRnVuY3Rpb24oX2NsZWFySXRlbXMsIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIHNjaGVtZSwgaG9zdCwgYW5kIHBvcnQgZnJvbSBhbiBodHRwKHMpIHVybC5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSB1cmwgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCB1cmwgb2JqZWN0IG9yIG51bGwgaWYgdGhlIHVybCBpcyBpbnZhbGlkLlxuICovXG51dGlsLnBhcnNlVXJsID0gZnVuY3Rpb24oc3RyKSB7XG4gIC8vIEZJWE1FOiB0aGlzIHJlZ2V4IGxvb2tzIGEgYml0IGJyb2tlblxuICB2YXIgcmVnZXggPSAvXihodHRwcz8pOlxcL1xcLyhbXjomXlxcL10qKTo/KFxcZCopKC4qKSQvZztcbiAgcmVnZXgubGFzdEluZGV4ID0gMDtcbiAgdmFyIG0gPSByZWdleC5leGVjKHN0cik7XG4gIHZhciB1cmwgPSAobSA9PT0gbnVsbCkgPyBudWxsIDoge1xuICAgIGZ1bGw6IHN0cixcbiAgICBzY2hlbWU6IG1bMV0sXG4gICAgaG9zdDogbVsyXSxcbiAgICBwb3J0OiBtWzNdLFxuICAgIHBhdGg6IG1bNF1cbiAgfTtcbiAgaWYodXJsKSB7XG4gICAgdXJsLmZ1bGxIb3N0ID0gdXJsLmhvc3Q7XG4gICAgaWYodXJsLnBvcnQpIHtcbiAgICAgIGlmKHVybC5wb3J0ICE9PSA4MCAmJiB1cmwuc2NoZW1lID09PSAnaHR0cCcpIHtcbiAgICAgICAgdXJsLmZ1bGxIb3N0ICs9ICc6JyArIHVybC5wb3J0O1xuICAgICAgfSBlbHNlIGlmKHVybC5wb3J0ICE9PSA0NDMgJiYgdXJsLnNjaGVtZSA9PT0gJ2h0dHBzJykge1xuICAgICAgICB1cmwuZnVsbEhvc3QgKz0gJzonICsgdXJsLnBvcnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHVybC5zY2hlbWUgPT09ICdodHRwJykge1xuICAgICAgdXJsLnBvcnQgPSA4MDtcbiAgICB9IGVsc2UgaWYodXJsLnNjaGVtZSA9PT0gJ2h0dHBzJykge1xuICAgICAgdXJsLnBvcnQgPSA0NDM7XG4gICAgfVxuICAgIHVybC5mdWxsID0gdXJsLnNjaGVtZSArICc6Ly8nICsgdXJsLmZ1bGxIb3N0O1xuICB9XG4gIHJldHVybiB1cmw7XG59O1xuXG4vKiBTdG9yYWdlIGZvciBxdWVyeSB2YXJpYWJsZXMgKi9cbnZhciBfcXVlcnlWYXJpYWJsZXMgPSBudWxsO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHdpbmRvdyBsb2NhdGlvbiBxdWVyeSB2YXJpYWJsZXMuIFF1ZXJ5IGlzIHBhcnNlZCBvbiB0aGUgZmlyc3RcbiAqIGNhbGwgYW5kIHRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBvbiBzdWJzZXF1ZW50IGNhbGxzLiBUaGUgbWFwcGluZ1xuICogaXMgZnJvbSBrZXlzIHRvIGFuIGFycmF5IG9mIHZhbHVlcy4gUGFyYW1ldGVycyB3aXRob3V0IHZhbHVlcyB3aWxsIGhhdmVcbiAqIGFuIG9iamVjdCBrZXkgc2V0IGJ1dCBubyB2YWx1ZSBhZGRlZCB0byB0aGUgdmFsdWUgYXJyYXkuIFZhbHVlcyBhcmVcbiAqIHVuZXNjYXBlZC5cbiAqXG4gKiAuLi4/azE9djEmazI9djI6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl0sXG4gKiAgIFwiazJcIjogW1widjJcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazE9djI6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIiwgXCJ2MlwiXVxuICogfVxuICpcbiAqIC4uLj9rMT12MSZrMjpcbiAqIHtcbiAqICAgXCJrMVwiOiBbXCJ2MVwiXSxcbiAqICAgXCJrMlwiOiBbXVxuICogfVxuICpcbiAqIC4uLj9rMT12MSZrMTpcbiAqIHtcbiAqICAgXCJrMVwiOiBbXCJ2MVwiXVxuICogfVxuICpcbiAqIC4uLj9rMSZrMTpcbiAqIHtcbiAqICAgXCJrMVwiOiBbXVxuICogfVxuICpcbiAqIEBwYXJhbSBxdWVyeSB0aGUgcXVlcnkgc3RyaW5nIHRvIHBhcnNlIChvcHRpb25hbCwgZGVmYXVsdCB0byBjYWNoZWRcbiAqICAgICAgICAgIHJlc3VsdHMgZnJvbSBwYXJzaW5nIHdpbmRvdyBsb2NhdGlvbiBzZWFyY2ggcXVlcnkpLlxuICpcbiAqIEByZXR1cm4gb2JqZWN0IG1hcHBpbmcga2V5cyB0byB2YXJpYWJsZXMuXG4gKi9cbnV0aWwuZ2V0UXVlcnlWYXJpYWJsZXMgPSBmdW5jdGlvbihxdWVyeSkge1xuICB2YXIgcGFyc2UgPSBmdW5jdGlvbihxKSB7XG4gICAgdmFyIHJ2YWwgPSB7fTtcbiAgICB2YXIga3ZwYWlycyA9IHEuc3BsaXQoJyYnKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwga3ZwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBvcyA9IGt2cGFpcnNbaV0uaW5kZXhPZignPScpO1xuICAgICAgdmFyIGtleTtcbiAgICAgIHZhciB2YWw7XG4gICAgICBpZihwb3MgPiAwKSB7XG4gICAgICAgIGtleSA9IGt2cGFpcnNbaV0uc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICAgIHZhbCA9IGt2cGFpcnNbaV0uc3Vic3RyaW5nKHBvcyArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0ga3ZwYWlyc1tpXTtcbiAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmKCEoa2V5IGluIHJ2YWwpKSB7XG4gICAgICAgIHJ2YWxba2V5XSA9IFtdO1xuICAgICAgfVxuICAgICAgLy8gZGlzYWxsb3cgb3ZlcnJpZGluZyBvYmplY3QgcHJvdG90eXBlIGtleXNcbiAgICAgIGlmKCEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBydmFsW2tleV0ucHVzaCh1bmVzY2FwZSh2YWwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgIHZhciBydmFsO1xuICAgaWYodHlwZW9mKHF1ZXJ5KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgLy8gc2V0IGNhY2hlZCB2YXJpYWJsZXMgaWYgbmVlZGVkXG4gICAgIGlmKF9xdWVyeVZhcmlhYmxlcyA9PT0gbnVsbCkge1xuICAgICAgIGlmKHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgICAgIC8vIHBhcnNlIHdpbmRvdyBzZWFyY2ggcXVlcnlcbiAgICAgICAgICBfcXVlcnlWYXJpYWJsZXMgPSBwYXJzZSh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBxdWVyeSB2YXJpYWJsZXMgYXZhaWxhYmxlXG4gICAgICAgICAgX3F1ZXJ5VmFyaWFibGVzID0ge307XG4gICAgICAgfVxuICAgICB9XG4gICAgIHJ2YWwgPSBfcXVlcnlWYXJpYWJsZXM7XG4gICB9IGVsc2Uge1xuICAgICAvLyBwYXJzZSBnaXZlbiBxdWVyeVxuICAgICBydmFsID0gcGFyc2UocXVlcnkpO1xuICAgfVxuICAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIGZyYWdtZW50IGludG8gYSBwYXRoIGFuZCBxdWVyeS4gVGhpcyBtZXRob2Qgd2lsbCB0YWtlIGEgVVJJXG4gKiBmcmFnbWVudCBhbmQgYnJlYWsgaXQgdXAgYXMgaWYgaXQgd2VyZSB0aGUgbWFpbiBVUkkuIEZvciBleGFtcGxlOlxuICogICAgL2Jhci9iYXo/YT0xJmI9MlxuICogcmVzdWx0cyBpbjpcbiAqICAgIHtcbiAqICAgICAgIHBhdGg6IFtcImJhclwiLCBcImJhelwiXSxcbiAqICAgICAgIHF1ZXJ5OiB7XCJrMVwiOiBbXCJ2MVwiXSwgXCJrMlwiOiBbXCJ2MlwiXX1cbiAqICAgIH1cbiAqXG4gKiBAcmV0dXJuIG9iamVjdCB3aXRoIGEgcGF0aCBhcnJheSBhbmQgcXVlcnkgb2JqZWN0LlxuICovXG51dGlsLnBhcnNlRnJhZ21lbnQgPSBmdW5jdGlvbihmcmFnbWVudCkge1xuICAvLyBkZWZhdWx0IHRvIHdob2xlIGZyYWdtZW50XG4gIHZhciBmcCA9IGZyYWdtZW50O1xuICB2YXIgZnEgPSAnJztcbiAgLy8gc3BsaXQgaW50byBwYXRoIGFuZCBxdWVyeSBpZiBwb3NzaWJsZSBhdCB0aGUgZmlyc3QgJz8nXG4gIHZhciBwb3MgPSBmcmFnbWVudC5pbmRleE9mKCc/Jyk7XG4gIGlmKHBvcyA+IDApIHtcbiAgICBmcCA9IGZyYWdtZW50LnN1YnN0cmluZygwLCBwb3MpO1xuICAgIGZxID0gZnJhZ21lbnQuc3Vic3RyaW5nKHBvcyArIDEpO1xuICB9XG4gIC8vIHNwbGl0IHBhdGggYmFzZWQgb24gJy8nIGFuZCBpZ25vcmUgZmlyc3QgZWxlbWVudCBpZiBlbXB0eVxuICB2YXIgcGF0aCA9IGZwLnNwbGl0KCcvJyk7XG4gIGlmKHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoWzBdID09PSAnJykge1xuICAgIHBhdGguc2hpZnQoKTtcbiAgfVxuICAvLyBjb252ZXJ0IHF1ZXJ5IGludG8gb2JqZWN0XG4gIHZhciBxdWVyeSA9IChmcSA9PT0gJycpID8ge30gOiB1dGlsLmdldFF1ZXJ5VmFyaWFibGVzKGZxKTtcblxuICByZXR1cm4ge1xuICAgIHBhdGhTdHJpbmc6IGZwLFxuICAgIHF1ZXJ5U3RyaW5nOiBmcSxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeVxuICB9O1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIHJlcXVlc3Qgb3V0IG9mIGEgVVJJLWxpa2UgcmVxdWVzdCBzdHJpbmcuIFRoaXMgaXMgaW50ZW5kZWQgdG9cbiAqIGJlIHVzZWQgd2hlcmUgYSBmcmFnbWVudCBpZCAoYWZ0ZXIgYSBVUkkgJyMnKSBpcyBwYXJzZWQgYXMgYSBVUkkgd2l0aFxuICogcGF0aCBhbmQgcXVlcnkgcGFydHMuIFRoZSBzdHJpbmcgc2hvdWxkIGhhdmUgYSBwYXRoIGJlZ2lubmluZyBhbmRcbiAqIGRlbGltaXRlZCBieSAnLycgYW5kIG9wdGlvbmFsIHF1ZXJ5IHBhcmFtZXRlcnMgZm9sbG93aW5nIGEgJz8nLiBUaGVcbiAqIHF1ZXJ5IHNob3VsZCBiZSBhIHN0YW5kYXJkIFVSTCBzZXQgb2Yga2V5IHZhbHVlIHBhaXJzIGRlbGltaXRlZCBieVxuICogJyYnLiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdGhlIGluaXRpYWwgJy8nIG9uIHRoZSBwYXRoIGlzIG5vdFxuICogcmVxdWlyZWQuIFRoZSByZXF1ZXN0IG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBBUEksIChmdWxseSBkZXNjcmliZWRcbiAqIGluIHRoZSBtZXRob2QgY29kZSk6XG4gKiAgICB7XG4gKiAgICAgICBwYXRoOiA8dGhlIHBhdGggc3RyaW5nIHBhcnQ+LlxuICogICAgICAgcXVlcnk6IDx0aGUgcXVlcnkgc3RyaW5nIHBhcnQ+LFxuICogICAgICAgZ2V0UGF0aChpKTogZ2V0IHBhcnQgb3IgYWxsIG9mIHRoZSBzcGxpdCBwYXRoIGFycmF5LFxuICogICAgICAgZ2V0UXVlcnkoaywgaSk6IGdldCBwYXJ0IG9yIGFsbCBvZiBhIHF1ZXJ5IGtleSBhcnJheSxcbiAqICAgICAgIGdldFF1ZXJ5TGFzdChrLCBfZGVmYXVsdCk6IGdldCBsYXN0IGVsZW1lbnQgb2YgYSBxdWVyeSBrZXkgYXJyYXkuXG4gKiAgICB9XG4gKlxuICogQHJldHVybiBvYmplY3Qgd2l0aCByZXF1ZXN0IHBhcmFtZXRlcnMuXG4gKi9cbnV0aWwubWFrZVJlcXVlc3QgPSBmdW5jdGlvbihyZXFTdHJpbmcpIHtcbiAgdmFyIGZyYWcgPSB1dGlsLnBhcnNlRnJhZ21lbnQocmVxU3RyaW5nKTtcbiAgdmFyIHJlcSA9IHtcbiAgICAvLyBmdWxsIHBhdGggc3RyaW5nXG4gICAgcGF0aDogZnJhZy5wYXRoU3RyaW5nLFxuICAgIC8vIGZ1bGwgcXVlcnkgc3RyaW5nXG4gICAgcXVlcnk6IGZyYWcucXVlcnlTdHJpbmcsXG4gICAgLyoqXG4gICAgICogR2V0IHBhdGggb3IgZWxlbWVudCBpbiBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIGkgb3B0aW9uYWwgcGF0aCBpbmRleC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gcGF0aCBvciBwYXJ0IG9mIHBhdGggaWYgaSBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBnZXRQYXRoOiBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gKHR5cGVvZihpKSA9PT0gJ3VuZGVmaW5lZCcpID8gZnJhZy5wYXRoIDogZnJhZy5wYXRoW2ldO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHF1ZXJ5LCB2YWx1ZXMgZm9yIGEga2V5LCBvciB2YWx1ZSBmb3IgYSBrZXkgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gayBvcHRpb25hbCBxdWVyeSBrZXkuXG4gICAgICogQHBhcmFtIGkgb3B0aW9uYWwgcXVlcnkga2V5IGluZGV4LlxuICAgICAqXG4gICAgICogQHJldHVybiBxdWVyeSwgdmFsdWVzIGZvciBhIGtleSwgb3IgdmFsdWUgZm9yIGEga2V5IGluZGV4LlxuICAgICAqL1xuICAgIGdldFF1ZXJ5OiBmdW5jdGlvbihrLCBpKSB7XG4gICAgICB2YXIgcnZhbDtcbiAgICAgIGlmKHR5cGVvZihrKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcnZhbCA9IGZyYWcucXVlcnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsID0gZnJhZy5xdWVyeVtrXTtcbiAgICAgICAgaWYocnZhbCAmJiB0eXBlb2YoaSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgIHJ2YWwgPSBydmFsW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9LFxuICAgIGdldFF1ZXJ5TGFzdDogZnVuY3Rpb24oaywgX2RlZmF1bHQpIHtcbiAgICAgIHZhciBydmFsO1xuICAgICAgdmFyIHZhbHMgPSByZXEuZ2V0UXVlcnkoayk7XG4gICAgICBpZih2YWxzKSB7XG4gICAgICAgIHJ2YWwgPSB2YWxzW3ZhbHMubGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsID0gX2RlZmF1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgVVJJIG91dCBvZiBhIHBhdGgsIGFuIG9iamVjdCB3aXRoIHF1ZXJ5IHBhcmFtZXRlcnMsIGFuZCBhXG4gKiBmcmFnbWVudC4gVXNlcyBqUXVlcnkucGFyYW0oKSBpbnRlcm5hbGx5IGZvciBxdWVyeSBzdHJpbmcgY3JlYXRpb24uXG4gKiBJZiB0aGUgcGF0aCBpcyBhbiBhcnJheSwgaXQgd2lsbCBiZSBqb2luZWQgd2l0aCAnLycuXG4gKlxuICogQHBhcmFtIHBhdGggc3RyaW5nIHBhdGggb3IgYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBxdWVyeSBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzLiAob3B0aW9uYWwpXG4gKiBAcGFyYW0gZnJhZ21lbnQgZnJhZ21lbnQgc3RyaW5nLiAob3B0aW9uYWwpXG4gKlxuICogQHJldHVybiBzdHJpbmcgb2JqZWN0IHdpdGggcmVxdWVzdCBwYXJhbWV0ZXJzLlxuICovXG51dGlsLm1ha2VMaW5rID0gZnVuY3Rpb24ocGF0aCwgcXVlcnksIGZyYWdtZW50KSB7XG4gIC8vIGpvaW4gcGF0aCBwYXJ0cyBpZiBuZWVkZWRcbiAgcGF0aCA9IGpRdWVyeS5pc0FycmF5KHBhdGgpID8gcGF0aC5qb2luKCcvJykgOiBwYXRoO1xuXG4gIHZhciBxc3RyID0galF1ZXJ5LnBhcmFtKHF1ZXJ5IHx8IHt9KTtcbiAgZnJhZ21lbnQgPSBmcmFnbWVudCB8fCAnJztcbiAgcmV0dXJuIHBhdGggK1xuICAgICgocXN0ci5sZW5ndGggPiAwKSA/ICgnPycgKyBxc3RyKSA6ICcnKSArXG4gICAgKChmcmFnbWVudC5sZW5ndGggPiAwKSA/ICgnIycgKyBmcmFnbWVudCkgOiAnJyk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBlbXB0eS5cbiAqXG4gKiBUYWtlbiBmcm9tOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QtZnJvbS1qc29uLzY3OTkzNyM2Nzk5MzdcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY2hlY2suXG4gKi9cbnV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgd2l0aCBzaW1wbGUgcHJpbnRmLXN0eWxlIGludGVycG9sYXRpb24uXG4gKlxuICogJSU6IGxpdGVyYWwgJyUnXG4gKiAlcywlbzogY29udmVydCBuZXh0IGFyZ3VtZW50IGludG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGZvcm1hdCB0aGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSAuLi4gYXJndW1lbnRzIHRvIGludGVycG9sYXRlIGludG8gdGhlIGZvcm1hdCBzdHJpbmcuXG4gKi9cbnV0aWwuZm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gIHZhciByZSA9IC8lLi9nO1xuICAvLyBjdXJyZW50IG1hdGNoXG4gIHZhciBtYXRjaDtcbiAgLy8gY3VycmVudCBwYXJ0XG4gIHZhciBwYXJ0O1xuICAvLyBjdXJyZW50IGFyZyBpbmRleFxuICB2YXIgYXJnaSA9IDA7XG4gIC8vIGNvbGxlY3RlZCBwYXJ0cyB0byByZWNvbWJpbmUgbGF0ZXJcbiAgdmFyIHBhcnRzID0gW107XG4gIC8vIGxhc3QgaW5kZXggZm91bmRcbiAgdmFyIGxhc3QgPSAwO1xuICAvLyBsb29wIHdoaWxlIG1hdGNoZXMgcmVtYWluXG4gIHdoaWxlKChtYXRjaCA9IHJlLmV4ZWMoZm9ybWF0KSkpIHtcbiAgICBwYXJ0ID0gZm9ybWF0LnN1YnN0cmluZyhsYXN0LCByZS5sYXN0SW5kZXggLSAyKTtcbiAgICAvLyBkb24ndCBhZGQgZW1wdHkgc3RyaW5ncyAoaWUsIHBhcnRzIGJldHdlZW4gJXMlcylcbiAgICBpZihwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGxhc3QgPSByZS5sYXN0SW5kZXg7XG4gICAgLy8gc3dpdGNoIG9uICUgY29kZVxuICAgIHZhciBjb2RlID0gbWF0Y2hbMF1bMV07XG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICBjYXNlICdzJzpcbiAgICBjYXNlICdvJzpcbiAgICAgIC8vIGNoZWNrIGlmIGVub3VnaCBhcmd1bWVudHMgd2VyZSBnaXZlblxuICAgICAgaWYoYXJnaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChhcmd1bWVudHNbYXJnaSsrICsgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaCgnPD8+Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBGSVhNRTogZG8gcHJvcGVyIGZvcm1hdGluZyBmb3IgbnVtYmVycywgZXRjXG4gICAgLy9jYXNlICdmJzpcbiAgICAvL2Nhc2UgJ2QnOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcGFydHMucHVzaCgnJScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhcnRzLnB1c2goJzwlJyArIGNvZGUgKyAnPz4nKTtcbiAgICB9XG4gIH1cbiAgLy8gYWRkIHRyYWlsaW5nIHBhcnQgb2YgZm9ybWF0IHN0cmluZ1xuICBwYXJ0cy5wdXNoKGZvcm1hdC5zdWJzdHJpbmcobGFzdCkpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0NS9qYXZhc2NyaXB0LW51bWJlcmZvcm1hdC0tcG9ydGVkLWZyb20tcGhwL1xuICovXG51dGlsLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCkge1xuICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vY3Jlc3RpZGcuY29tKVxuICAvLyArICAgICBidWdmaXggYnk6IEJlbmphbWluIEx1cHRvblxuICAvLyArICAgICBidWdmaXggYnk6IEFsbGFuIEplbnNlbiAoaHR0cDovL3d3dy53aW50ZXJuZXQubm8pXG4gIC8vICsgICAgcmV2aXNlZCBieTogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuICAvLyAqICAgICBleGFtcGxlIDE6IG51bWJlcl9mb3JtYXQoMTIzNC41Njc4LCAyLCAnLicsICcnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjM0LjU3XG5cbiAgdmFyIG4gPSBudW1iZXIsIGMgPSBpc05hTihkZWNpbWFscyA9IE1hdGguYWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHM7XG4gIHZhciBkID0gZGVjX3BvaW50ID09PSB1bmRlZmluZWQgPyAnLCcgOiBkZWNfcG9pbnQ7XG4gIHZhciB0ID0gdGhvdXNhbmRzX3NlcCA9PT0gdW5kZWZpbmVkID9cbiAgICcuJyA6IHRob3VzYW5kc19zZXAsIHMgPSBuIDwgMCA/ICctJyA6ICcnO1xuICB2YXIgaSA9IHBhcnNlSW50KChuID0gTWF0aC5hYnMoK24gfHwgMCkudG9GaXhlZChjKSksIDEwKSArICcnO1xuICB2YXIgaiA9IChpLmxlbmd0aCA+IDMpID8gaS5sZW5ndGggJSAzIDogMDtcbiAgcmV0dXJuIHMgKyAoaiA/IGkuc3Vic3RyKDAsIGopICsgdCA6ICcnKSArXG4gICAgaS5zdWJzdHIoaikucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csICckMScgKyB0KSArXG4gICAgKGMgPyBkICsgTWF0aC5hYnMobiAtIGkpLnRvRml4ZWQoYykuc2xpY2UoMikgOiAnJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBieXRlIHNpemUuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0OS9mb3JtYXQtaHVtYW5pemUtZmlsZS1ieXRlLXNpemUtcHJlc2VudGF0aW9uLWluLWphdmFzY3JpcHQvXG4gKi9cbnV0aWwuZm9ybWF0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYoc2l6ZSA+PSAxMDczNzQxODI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDczNzQxODI0LCAyLCAnLicsICcnKSArICcgR2lCJztcbiAgfSBlbHNlIGlmKHNpemUgPj0gMTA0ODU3Nikge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA0ODU3NiwgMiwgJy4nLCAnJykgKyAnIE1pQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwMjQpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwMjQsIDApICsgJyBLaUInO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplLCAwKSArICcgYnl0ZXMnO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IG9yIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBvciBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSA0LWJ5dGUgSVB2NiBvciAxNi1ieXRlIElQdjYgYWRkcmVzcyBvciBudWxsIGlmIHRoZSBhZGRyZXNzIGNhbid0XG4gKiAgICAgICAgIGJlIHBhcnNlZC5cbiAqL1xudXRpbC5ieXRlc0Zyb21JUCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlmKGlwLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc0Zyb21JUHY0KGlwKTtcbiAgfVxuICBpZihpcC5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NihpcCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlwID0gaXAuc3BsaXQoJy4nKTtcbiAgaWYoaXAubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaXAubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbnVtID0gcGFyc2VJbnQoaXBbaV0sIDEwKTtcbiAgICBpZihpc05hTihudW0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYi5wdXRCeXRlKG51bSk7XG4gIH1cbiAgcmV0dXJuIGIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW50byBieXRlcyAoaW4gbmV0d29yayBvcmRlcikuXG4gKlxuICogQHBhcmFtIGlwIHRoZSBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSAxNi1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NiA9IGZ1bmN0aW9uKGlwKSB7XG4gIHZhciBibGFua3MgPSAwO1xuICBpcCA9IGlwLnNwbGl0KCc6JykuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICBpZihlLmxlbmd0aCA9PT0gMCkgKytibGFua3M7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICB2YXIgemVyb3MgPSAoOCAtIGlwLmxlbmd0aCArIGJsYW5rcykgKiAyO1xuICB2YXIgYiA9IHV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICBpZighaXBbaV0gfHwgaXBbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBiLmZpbGxXaXRoQnl0ZSgwLCB6ZXJvcyk7XG4gICAgICB6ZXJvcyA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGJ5dGVzID0gdXRpbC5oZXhUb0J5dGVzKGlwW2ldKTtcbiAgICBpZihieXRlcy5sZW5ndGggPCAyKSB7XG4gICAgICBiLnB1dEJ5dGUoMCk7XG4gICAgfVxuICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciAxNi1ieXRlcyBpbnRvXG4gKiBhbiBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmUgaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiA0IG9yIDE2IGJ5dGVzLFxuICogICAgICAgICByZXNwZWN0aXZlbHksIGFyZSBnaXZlbiwgb3RoZXJ3aXNlIG51bGwuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYoYnl0ZXMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjQoYnl0ZXMpO1xuICB9XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gMTYpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc1RvSVB2NihieXRlcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpcCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpcC5wdXNoKGJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICB9XG4gIHJldHVybiBpcC5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDE2LWJ5dGVzIGludG8gYW4gSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZXMgbXVzdCBiZVxuICogaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NiA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgdmFyIHplcm9Hcm91cHMgPSBbXTtcbiAgdmFyIHplcm9NYXhHcm91cCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBoZXggPSB1dGlsLmJ5dGVzVG9IZXgoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0pO1xuICAgIC8vIGNhbm9uaWNhbGl6ZSB6ZXJvIHJlcHJlc2VudGF0aW9uXG4gICAgd2hpbGUoaGV4WzBdID09PSAnMCcgJiYgaGV4ICE9PSAnMCcpIHtcbiAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGlmKGhleCA9PT0gJzAnKSB7XG4gICAgICB2YXIgbGFzdCA9IHplcm9Hcm91cHNbemVyb0dyb3Vwcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBpZHggPSBpcC5sZW5ndGg7XG4gICAgICBpZighbGFzdCB8fCBpZHggIT09IGxhc3QuZW5kICsgMSkge1xuICAgICAgICB6ZXJvR3JvdXBzLnB1c2goe3N0YXJ0OiBpZHgsIGVuZDogaWR4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0LmVuZCA9IGlkeDtcbiAgICAgICAgaWYoKGxhc3QuZW5kIC0gbGFzdC5zdGFydCkgPlxuICAgICAgICAgICh6ZXJvR3JvdXBzW3plcm9NYXhHcm91cF0uZW5kIC0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLnN0YXJ0KSkge1xuICAgICAgICAgIHplcm9NYXhHcm91cCA9IHplcm9Hcm91cHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpcC5wdXNoKGhleCk7XG4gIH1cbiAgaWYoemVyb0dyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGdyb3VwID0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdO1xuICAgIC8vIG9ubHkgc2hvcnRlbiBncm91cCBvZiBsZW5ndGggPiAwXG4gICAgaWYoZ3JvdXAuZW5kIC0gZ3JvdXAuc3RhcnQgPiAwKSB7XG4gICAgICBpcC5zcGxpY2UoZ3JvdXAuc3RhcnQsIGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ICsgMSwgJycpO1xuICAgICAgaWYoZ3JvdXAuc3RhcnQgPT09IDApIHtcbiAgICAgICAgaXAudW5zaGlmdCgnJyk7XG4gICAgICB9XG4gICAgICBpZihncm91cC5lbmQgPT09IDcpIHtcbiAgICAgICAgaXAucHVzaCgnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpcC5qb2luKCc6Jyk7XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHByb2Nlc3NlcyB0aGF0IGNhbiBiZSBydW4gY29uY3VycmVudGx5LiBJZlxuICogY3JlYXRpbmcgV2ViIFdvcmtlcnMsIGtlZXAgaW4gbWluZCB0aGF0IHRoZSBtYWluIEphdmFTY3JpcHQgcHJvY2VzcyBuZWVkc1xuICogaXRzIG93biBjb3JlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIHVwZGF0ZSB0cnVlIHRvIGZvcmNlIGFuIHVwZGF0ZSAobm90IHVzZSB0aGUgY2FjaGVkIHZhbHVlKS5cbiAqIEBwYXJhbSBjYWxsYmFjayhlcnIsIG1heCkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnV0aWwuZXN0aW1hdGVDb3JlcyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoJ2NvcmVzJyBpbiB1dGlsICYmICFvcHRpb25zLnVwZGF0ZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICdoYXJkd2FyZUNvbmN1cnJlbmN5JyBpbiBuYXZpZ2F0b3IgJiZcbiAgICBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSA+IDApIHtcbiAgICB1dGlsLmNvcmVzID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gd29ya2VycyBub3QgYXZhaWxhYmxlXG4gICAgdXRpbC5jb3JlcyA9IDE7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNhbid0IGVzdGltYXRlLCBkZWZhdWx0IHRvIDJcbiAgICB1dGlsLmNvcmVzID0gMjtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cblxuICAvLyBjcmVhdGUgd29ya2VyIGNvbmN1cnJlbmN5IGVzdGltYXRpb24gY29kZSBhcyBibG9iXG4gIHZhciBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnLFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBydW4gd29ya2VyIGZvciA0IG1zXG4gICAgICAgIHZhciBzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBldCA9IHN0ICsgNDtcbiAgICAgICAgd2hpbGUoRGF0ZS5ub3coKSA8IGV0KTtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7c3Q6IHN0LCBldDogZXR9KTtcbiAgICAgIH0pO1xuICAgIH0udG9TdHJpbmcoKSxcbiAgJykoKSddLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSkpO1xuXG4gIC8vIHRha2UgNSBzYW1wbGVzIHVzaW5nIDE2IHdvcmtlcnNcbiAgc2FtcGxlKFtdLCA1LCAxNik7XG5cbiAgZnVuY3Rpb24gc2FtcGxlKG1heCwgc2FtcGxlcywgbnVtV29ya2Vycykge1xuICAgIGlmKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIGdldCBvdmVybGFwIGF2ZXJhZ2VcbiAgICAgIHZhciBhdmcgPSBNYXRoLmZsb29yKG1heC5yZWR1Y2UoZnVuY3Rpb24oYXZnLCB4KSB7XG4gICAgICAgIHJldHVybiBhdmcgKyB4O1xuICAgICAgfSwgMCkgLyBtYXgubGVuZ3RoKTtcbiAgICAgIHV0aWwuY29yZXMgPSBNYXRoLm1heCgxLCBhdmcpO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgICB9XG4gICAgbWFwKG51bVdvcmtlcnMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgbWF4LnB1c2gocmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpKTtcbiAgICAgIHNhbXBsZShtYXgsIHNhbXBsZXMgLSAxLCBudW1Xb3JrZXJzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcChudW1Xb3JrZXJzLCBjYWxsYmFjaykge1xuICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZS5kYXRhKTtcbiAgICAgICAgaWYocmVzdWx0cy5sZW5ndGggPT09IG51bVdvcmtlcnMpIHtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgICB3b3JrZXJzW2ldLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3b3JrZXJzLnB1c2god29ya2VyKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5wb3N0TWVzc2FnZShpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWR1Y2UobnVtV29ya2VycywgcmVzdWx0cykge1xuICAgIC8vIGZpbmQgb3ZlcmxhcHBpbmcgdGltZSB3aW5kb3dzXG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IG51bVdvcmtlcnM7ICsrbikge1xuICAgICAgdmFyIHIxID0gcmVzdWx0c1tuXTtcbiAgICAgIHZhciBvdmVybGFwID0gb3ZlcmxhcHNbbl0gPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgICAgaWYobiA9PT0gaSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByMiA9IHJlc3VsdHNbaV07XG4gICAgICAgIGlmKChyMS5zdCA+IHIyLnN0ICYmIHIxLnN0IDwgcjIuZXQpIHx8XG4gICAgICAgICAgKHIyLnN0ID4gcjEuc3QgJiYgcjIuc3QgPCByMS5ldCkpIHtcbiAgICAgICAgICBvdmVybGFwLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZ2V0IG1heGltdW0gb3ZlcmxhcHMgLi4uIGRvbid0IGluY2x1ZGUgb3ZlcmxhcHBpbmcgd29ya2VyIGl0c2VsZlxuICAgIC8vIGFzIHRoZSBtYWluIEpTIHByb2Nlc3Mgd2FzIGFsc28gYmVpbmcgc2NoZWR1bGVkIGR1cmluZyB0aGUgd29yayBhbmRcbiAgICAvLyB3b3VsZCBoYXZlIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgZXN0aW1hdGUgYW55d2F5XG4gICAgcmV0dXJuIG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbihtYXgsIG92ZXJsYXApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIG92ZXJsYXAubGVuZ3RoKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgcXVldWUtbWljcm90YXNrLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5sZXQgcHJvbWlzZVxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJ1xuICA/IHF1ZXVlTWljcm90YXNrLmJpbmQoZ2xvYmFsVGhpcylcbiAgLy8gcmV1c2UgcmVzb2x2ZWQgcHJvbWlzZSwgYW5kIGFsbG9jYXRlIGl0IGxhemlseVxuICA6IGNiID0+IChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKVxuICAgIC50aGVuKGNiKVxuICAgIC5jYXRjaChlcnIgPT4gc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGVyciB9LCAwKSlcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQXN5bmNBbGdvcml0aG0ge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWF4Q2FsbFN0YWNrRGVwdGggPSA1MDAsXG4gICAgbWF4VG90YWxDYWxsU3RhY2tEZXB0aCA9IDB4RkZGRkZGRkYsXG4gICAgLy8gbWlsbGlzZWNvbmRzXG4gICAgdGltZVNsaWNlID0gMTBcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5zY2hlZHVsZSA9IHt9O1xuICAgIHRoaXMuc2NoZWR1bGUuTUFYX0RFUFRIID0gbWF4Q2FsbFN0YWNrRGVwdGg7XG4gICAgdGhpcy5zY2hlZHVsZS5NQVhfVE9UQUxfREVQVEggPSBtYXhUb3RhbENhbGxTdGFja0RlcHRoO1xuICAgIHRoaXMuc2NoZWR1bGUuZGVwdGggPSAwO1xuICAgIHRoaXMuc2NoZWR1bGUudG90YWxEZXB0aCA9IDA7XG4gICAgdGhpcy5zY2hlZHVsZS50aW1lU2xpY2UgPSB0aW1lU2xpY2U7XG4gIH1cblxuICAvLyBkbyBzb21lIHdvcmsgaW4gYSB0aW1lIHNsaWNlLCBidXQgaW4gc2VyaWFsXG4gIGRvV29yayhmbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzY2hlZHVsZSA9IHRoaXMuc2NoZWR1bGU7XG5cbiAgICBpZihzY2hlZHVsZS50b3RhbERlcHRoID49IHNjaGVkdWxlLk1BWF9UT1RBTF9ERVBUSCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcbiAgICAgICAgJ01heGltdW0gdG90YWwgY2FsbCBzdGFjayBkZXB0aCBleGNlZWRlZDsgY2Fub25pY2FsaXphdGlvbiBhYm9ydGluZy4nKSk7XG4gICAgfVxuXG4gICAgKGZ1bmN0aW9uIHdvcmsoKSB7XG4gICAgICBpZihzY2hlZHVsZS5kZXB0aCA9PT0gc2NoZWR1bGUuTUFYX0RFUFRIKSB7XG4gICAgICAgIC8vIHN0YWNrIHRvbyBkZWVwLCBydW4gb24gbmV4dCB0aWNrXG4gICAgICAgIHNjaGVkdWxlLmRlcHRoID0gMDtcbiAgICAgICAgc2NoZWR1bGUucnVubmluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdXRpbC5uZXh0VGljayh3b3JrKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgbm90IHlldCBydW5uaW5nLCBmb3JjZSBydW5cbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZighc2NoZWR1bGUucnVubmluZykge1xuICAgICAgICBzY2hlZHVsZS5zdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIHNjaGVkdWxlLmRlYWRsaW5lID0gc2NoZWR1bGUuc3RhcnQgKyBzY2hlZHVsZS50aW1lU2xpY2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IHNob3VsZCBhbHNvIGluY2x1ZGUgYW4gZXN0aW1hdGUgb2YgZXhwZWN0ZWRXb3JrVGltZVxuICAgICAgaWYobm93IDwgc2NoZWR1bGUuZGVhZGxpbmUpIHtcbiAgICAgICAgc2NoZWR1bGUucnVubmluZyA9IHRydWU7XG4gICAgICAgIHNjaGVkdWxlLmRlcHRoKys7XG4gICAgICAgIHNjaGVkdWxlLnRvdGFsRGVwdGgrKztcbiAgICAgICAgcmV0dXJuIGZuKChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgIHNjaGVkdWxlLmRlcHRoLS07XG4gICAgICAgICAgc2NoZWR1bGUudG90YWxEZXB0aC0tO1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdCBlbm91Z2ggdGltZSBsZWZ0IGluIHRoaXMgc2xpY2UsIHJ1biBhZnRlciBsZXR0aW5nIGJyb3dzZXJcbiAgICAgIC8vIGRvIHNvbWUgb3RoZXIgdGhpbmdzXG4gICAgICBzY2hlZHVsZS5kZXB0aCA9IDA7XG4gICAgICBzY2hlZHVsZS5ydW5uaW5nID0gZmFsc2U7XG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSh3b3JrKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLy8gYXN5bmNocm9ub3VzbHkgbG9vcFxuICBmb3JFYWNoKGl0ZXJhYmxlLCBmbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgaXRlcmF0b3I7XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgbGV0IGxlbmd0aDtcbiAgICBpZihBcnJheS5pc0FycmF5KGl0ZXJhYmxlKSkge1xuICAgICAgbGVuZ3RoID0gaXRlcmFibGUubGVuZ3RoO1xuICAgICAgaXRlcmF0b3IgPSAoKSA9PiB7XG4gICAgICAgIGlmKGlkeCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yLnZhbHVlID0gaXRlcmFibGVbaWR4KytdO1xuICAgICAgICBpdGVyYXRvci5rZXkgPSBpZHg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZXJhYmxlKTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgaXRlcmF0b3IgPSAoKSA9PiB7XG4gICAgICAgIGlmKGlkeCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yLmtleSA9IGtleXNbaWR4KytdO1xuICAgICAgICBpdGVyYXRvci52YWx1ZSA9IGl0ZXJhYmxlW2l0ZXJhdG9yLmtleV07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAoZnVuY3Rpb24gaXRlcmF0ZShlcnIpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmKGl0ZXJhdG9yKCkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZG9Xb3JrKCgpID0+IGZuKGl0ZXJhdG9yLnZhbHVlLCBpdGVyYXRvci5rZXksIGl0ZXJhdGUpKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8vIGFzeW5jaHJvbm91cyB3YXRlcmZhbGxcbiAgd2F0ZXJmYWxsKGZucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBzZWxmLmZvckVhY2goXG4gICAgICBmbnMsIChmbiwgaWR4LCBjYWxsYmFjaykgPT4gc2VsZi5kb1dvcmsoZm4sIGNhbGxiYWNrKSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gYXN5bmNocm9ub3VzIHdoaWxlXG4gIHdoaWxzdChjb25kaXRpb24sIGZuLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIChmdW5jdGlvbiBsb29wKGVycikge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgaWYoIWNvbmRpdGlvbigpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgc2VsZi5kb1dvcmsoZm4sIGxvb3ApO1xuICAgIH0pKCk7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSWRlbnRpZmllcklzc3VlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElkZW50aWZpZXJJc3N1ZXIuIEEgSWRlbnRpZmllcklzc3VlciBpc3N1ZXMgdW5pcXVlXG4gICAqIGlkZW50aWZpZXJzLCBrZWVwaW5nIHRyYWNrIG9mIGFueSBwcmV2aW91c2x5IGlzc3VlZCBpZGVudGlmaWVycy5cbiAgICpcbiAgICogQHBhcmFtIHByZWZpeCB0aGUgcHJlZml4IHRvIHVzZSAoJzxwcmVmaXg+PGNvdW50ZXI+JykuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwcmVmaXgpIHtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgIHRoaXMuZXhpc3RpbmcgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhpcyBJZGVudGlmaWVySXNzdWVyLlxuICAgKlxuICAgKiBAcmV0dXJuIGEgY29weSBvZiB0aGlzIElkZW50aWZpZXJJc3N1ZXIuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IElkZW50aWZpZXJJc3N1ZXIodGhpcy5wcmVmaXgpO1xuICAgIGNvcHkuY291bnRlciA9IHRoaXMuY291bnRlcjtcbiAgICBjb3B5LmV4aXN0aW5nID0gdXRpbC5jbG9uZSh0aGlzLmV4aXN0aW5nKTtcbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuZXcgaWRlbnRpZmllciBmb3IgdGhlIGdpdmVuIG9sZCBpZGVudGlmaWVyLCB3aGVyZSBpZiBubyBvbGRcbiAgICogaWRlbnRpZmllciBpcyBnaXZlbiBhIG5ldyBpZGVudGlmaWVyIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gW29sZF0gdGhlIG9sZCBpZGVudGlmaWVyIHRvIGdldCB0aGUgbmV3IGlkZW50aWZpZXIgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBuZXcgaWRlbnRpZmllci5cbiAgICovXG4gIGdldElkKG9sZCkge1xuICAgIC8vIHJldHVybiBleGlzdGluZyBvbGQgaWRlbnRpZmllclxuICAgIGlmKG9sZCAmJiBvbGQgaW4gdGhpcy5leGlzdGluZykge1xuICAgICAgcmV0dXJuIHRoaXMuZXhpc3Rpbmdbb2xkXTtcbiAgICB9XG5cbiAgICAvLyBnZXQgbmV4dCBpZGVudGlmaWVyXG4gICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMucHJlZml4ICsgdGhpcy5jb3VudGVyO1xuICAgIHRoaXMuY291bnRlciArPSAxO1xuXG4gICAgLy8gc2F2ZSBtYXBwaW5nXG4gICAgaWYob2xkKSB7XG4gICAgICB0aGlzLmV4aXN0aW5nW29sZF0gPSBpZGVudGlmaWVyO1xuICAgIH1cblxuICAgIHJldHVybiBpZGVudGlmaWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2xkIGlkZW50aWZlciBoYXMgYWxyZWFkeSBiZWVuIGFzc2lnbmVkIGEgbmV3XG4gICAqIGlkZW50aWZpZXIuXG4gICAqXG4gICAqIEBwYXJhbSBvbGQgdGhlIG9sZCBpZGVudGlmaWVyIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIG9sZCBpZGVudGlmaWVyIGhhcyBiZWVuIGFzc2lnbmVkIGEgbmV3IGlkZW50aWZpZXIsXG4gICAqICAgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgaGFzSWQob2xkKSB7XG4gICAgcmV0dXJuIChvbGQgaW4gdGhpcy5leGlzdGluZyk7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmb3JnZSA9IHJlcXVpcmUoJ25vZGUtZm9yZ2UvbGliL2ZvcmdlJyk7XG5yZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9tZCcpO1xucmVxdWlyZSgnbm9kZS1mb3JnZS9saWIvc2hhMScpO1xucmVxdWlyZSgnbm9kZS1mb3JnZS9saWIvc2hhMjU2Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTWVzc2FnZURpZ2VzdCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE1lc3NhZ2VEaWdlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhbGdvcml0aG0pIHtcbiAgICB0aGlzLm1kID0gZm9yZ2UubWRbYWxnb3JpdGhtXS5jcmVhdGUoKTtcbiAgfVxuXG4gIHVwZGF0ZShtc2cpIHtcbiAgICB0aGlzLm1kLnVwZGF0ZShtc2csICd1dGY4Jyk7XG4gIH1cblxuICBkaWdlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWQuZGlnZXN0KCkudG9IZXgoKTtcbiAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuY29uc3QgVEVSTVMgPSBbJ3N1YmplY3QnLCAncHJlZGljYXRlJywgJ29iamVjdCcsICdncmFwaCddO1xuY29uc3QgUkRGID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMnO1xuY29uc3QgUkRGX0xBTkdTVFJJTkcgPSBSREYgKyAnbGFuZ1N0cmluZyc7XG5jb25zdCBYU0RfU1RSSU5HID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI3N0cmluZyc7XG5cbi8vIGJ1aWxkIHJlZ2V4ZXNcbmNvbnN0IFJFR0VYID0ge307XG4oKCkgPT4ge1xuICBjb25zdCBpcmkgPSAnKD86PChbXjpdKzpbXj5dKik+KSc7XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi90dXJ0bGUvI2dyYW1tYXItcHJvZHVjdGlvbi1CTEFOS19OT0RFX0xBQkVMXG4gIGNvbnN0IFBOX0NIQVJTX0JBU0UgPVxuICAgICdBLVonICsgJ2EteicgK1xuICAgICdcXHUwMEMwLVxcdTAwRDYnICtcbiAgICAnXFx1MDBEOC1cXHUwMEY2JyArXG4gICAgJ1xcdTAwRjgtXFx1MDJGRicgK1xuICAgICdcXHUwMzcwLVxcdTAzN0QnICtcbiAgICAnXFx1MDM3Ri1cXHUxRkZGJyArXG4gICAgJ1xcdTIwMEMtXFx1MjAwRCcgK1xuICAgICdcXHUyMDcwLVxcdTIxOEYnICtcbiAgICAnXFx1MkMwMC1cXHUyRkVGJyArXG4gICAgJ1xcdTMwMDEtXFx1RDdGRicgK1xuICAgICdcXHVGOTAwLVxcdUZEQ0YnICtcbiAgICAnXFx1RkRGMC1cXHVGRkZEJztcbiAgICAvLyBUT0RPOlxuICAgIC8vJ1xcdTEwMDAwLVxcdUVGRkZGJztcbiAgY29uc3QgUE5fQ0hBUlNfVSA9XG4gICAgUE5fQ0hBUlNfQkFTRSArXG4gICAgJ18nO1xuICBjb25zdCBQTl9DSEFSUyA9XG4gICAgUE5fQ0hBUlNfVSArXG4gICAgJzAtOScgK1xuICAgICctJyArXG4gICAgJ1xcdTAwQjcnICtcbiAgICAnXFx1MDMwMC1cXHUwMzZGJyArXG4gICAgJ1xcdTIwM0YtXFx1MjA0MCc7XG4gIGNvbnN0IEJMQU5LX05PREVfTEFCRUwgPVxuICAgICcoXzonICtcbiAgICAgICcoPzpbJyArIFBOX0NIQVJTX1UgKyAnMC05XSknICtcbiAgICAgICcoPzooPzpbJyArIFBOX0NIQVJTICsgJy5dKSooPzpbJyArIFBOX0NIQVJTICsgJ10pKT8nICtcbiAgICAnKSc7XG4gIGNvbnN0IGJub2RlID0gQkxBTktfTk9ERV9MQUJFTDtcbiAgY29uc3QgcGxhaW4gPSAnXCIoW15cIlxcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlwiXFxcXFxcXFxdKikqKVwiJztcbiAgY29uc3QgZGF0YXR5cGUgPSAnKD86XFxcXF5cXFxcXicgKyBpcmkgKyAnKSc7XG4gIGNvbnN0IGxhbmd1YWdlID0gJyg/OkAoW2EtekEtWl0rKD86LVthLXpBLVowLTldKykqKSknO1xuICBjb25zdCBsaXRlcmFsID0gJyg/OicgKyBwbGFpbiArICcoPzonICsgZGF0YXR5cGUgKyAnfCcgKyBsYW5ndWFnZSArICcpPyknO1xuICBjb25zdCB3cyA9ICdbIFxcXFx0XSsnO1xuICBjb25zdCB3c28gPSAnWyBcXFxcdF0qJztcblxuICAvLyBkZWZpbmUgcXVhZCBwYXJ0IHJlZ2V4ZXNcbiAgY29uc3Qgc3ViamVjdCA9ICcoPzonICsgaXJpICsgJ3wnICsgYm5vZGUgKyAnKScgKyB3cztcbiAgY29uc3QgcHJvcGVydHkgPSBpcmkgKyB3cztcbiAgY29uc3Qgb2JqZWN0ID0gJyg/OicgKyBpcmkgKyAnfCcgKyBibm9kZSArICd8JyArIGxpdGVyYWwgKyAnKScgKyB3c287XG4gIGNvbnN0IGdyYXBoTmFtZSA9ICcoPzpcXFxcLnwoPzooPzonICsgaXJpICsgJ3wnICsgYm5vZGUgKyAnKScgKyB3c28gKyAnXFxcXC4pKSc7XG5cbiAgLy8gZW5kIG9mIGxpbmUgYW5kIGVtcHR5IHJlZ2V4ZXNcbiAgUkVHRVguZW9sbiA9IC8oPzpcXHJcXG4pfCg/Olxcbil8KD86XFxyKS9nO1xuICBSRUdFWC5lbXB0eSA9IG5ldyBSZWdFeHAoJ14nICsgd3NvICsgJyQnKTtcblxuICAvLyBmdWxsIHF1YWQgcmVnZXhcbiAgUkVHRVgucXVhZCA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICsgd3NvICsgc3ViamVjdCArIHByb3BlcnR5ICsgb2JqZWN0ICsgZ3JhcGhOYW1lICsgd3NvICsgJyQnKTtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTlF1YWRzIHtcbiAgLyoqXG4gICAqIFBhcnNlcyBSREYgaW4gdGhlIGZvcm0gb2YgTi1RdWFkcy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IHRoZSBOLVF1YWRzIGlucHV0IHRvIHBhcnNlLlxuICAgKlxuICAgKiBAcmV0dXJuIGFuIFJERiBkYXRhc2V0IChhbiBhcnJheSBvZiBxdWFkcyBwZXIgaHR0cDovL3JkZi5qcy5vcmcvKS5cbiAgICovXG4gIHN0YXRpYyBwYXJzZShpbnB1dCkge1xuICAgIC8vIGJ1aWxkIFJERiBkYXRhc2V0XG4gICAgY29uc3QgZGF0YXNldCA9IFtdO1xuXG4gICAgY29uc3QgZ3JhcGhzID0ge307XG5cbiAgICAvLyBzcGxpdCBOLVF1YWQgaW5wdXQgaW50byBsaW5lc1xuICAgIGNvbnN0IGxpbmVzID0gaW5wdXQuc3BsaXQoUkVHRVguZW9sbik7XG4gICAgbGV0IGxpbmVOdW1iZXIgPSAwO1xuICAgIGZvcihjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBsaW5lTnVtYmVyKys7XG5cbiAgICAgIC8vIHNraXAgZW1wdHkgbGluZXNcbiAgICAgIGlmKFJFR0VYLmVtcHR5LnRlc3QobGluZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIHF1YWRcbiAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChSRUdFWC5xdWFkKTtcbiAgICAgIGlmKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTi1RdWFkcyBwYXJzZSBlcnJvciBvbiBsaW5lICcgKyBsaW5lTnVtYmVyICsgJy4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIFJERiBxdWFkXG4gICAgICBjb25zdCBxdWFkID0ge307XG5cbiAgICAgIC8vIGdldCBzdWJqZWN0XG4gICAgICBpZihtYXRjaFsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1YWQuc3ViamVjdCA9IHt0ZXJtVHlwZTogJ05hbWVkTm9kZScsIHZhbHVlOiBtYXRjaFsxXX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWFkLnN1YmplY3QgPSB7dGVybVR5cGU6ICdCbGFua05vZGUnLCB2YWx1ZTogbWF0Y2hbMl19O1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgcHJlZGljYXRlXG4gICAgICBxdWFkLnByZWRpY2F0ZSA9IHt0ZXJtVHlwZTogJ05hbWVkTm9kZScsIHZhbHVlOiBtYXRjaFszXX07XG5cbiAgICAgIC8vIGdldCBvYmplY3RcbiAgICAgIGlmKG1hdGNoWzRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVhZC5vYmplY3QgPSB7dGVybVR5cGU6ICdOYW1lZE5vZGUnLCB2YWx1ZTogbWF0Y2hbNF19O1xuICAgICAgfSBlbHNlIGlmKG1hdGNoWzVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVhZC5vYmplY3QgPSB7dGVybVR5cGU6ICdCbGFua05vZGUnLCB2YWx1ZTogbWF0Y2hbNV19O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVhZC5vYmplY3QgPSB7XG4gICAgICAgICAgdGVybVR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRhdGF0eXBlOiB7XG4gICAgICAgICAgICB0ZXJtVHlwZTogJ05hbWVkTm9kZSdcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmKG1hdGNoWzddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBxdWFkLm9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IG1hdGNoWzddO1xuICAgICAgICB9IGVsc2UgaWYobWF0Y2hbOF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHF1YWQub2JqZWN0LmRhdGF0eXBlLnZhbHVlID0gUkRGX0xBTkdTVFJJTkc7XG4gICAgICAgICAgcXVhZC5vYmplY3QubGFuZ3VhZ2UgPSBtYXRjaFs4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWFkLm9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IFhTRF9TVFJJTkc7XG4gICAgICAgIH1cbiAgICAgICAgcXVhZC5vYmplY3QudmFsdWUgPSBfdW5lc2NhcGUobWF0Y2hbNl0pO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgZ3JhcGhcbiAgICAgIGlmKG1hdGNoWzldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVhZC5ncmFwaCA9IHtcbiAgICAgICAgICB0ZXJtVHlwZTogJ05hbWVkTm9kZScsXG4gICAgICAgICAgdmFsdWU6IG1hdGNoWzldXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYobWF0Y2hbMTBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVhZC5ncmFwaCA9IHtcbiAgICAgICAgICB0ZXJtVHlwZTogJ0JsYW5rTm9kZScsXG4gICAgICAgICAgdmFsdWU6IG1hdGNoWzEwXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVhZC5ncmFwaCA9IHtcbiAgICAgICAgICB0ZXJtVHlwZTogJ0RlZmF1bHRHcmFwaCcsXG4gICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgYWRkIHF1YWQgaWYgaXQgaXMgdW5pcXVlIGluIGl0cyBncmFwaFxuICAgICAgaWYoIShxdWFkLmdyYXBoLnZhbHVlIGluIGdyYXBocykpIHtcbiAgICAgICAgZ3JhcGhzW3F1YWQuZ3JhcGgudmFsdWVdID0gW3F1YWRdO1xuICAgICAgICBkYXRhc2V0LnB1c2gocXVhZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcXVhZHMgPSBncmFwaHNbcXVhZC5ncmFwaC52YWx1ZV07XG4gICAgICAgIGZvcihjb25zdCBxIG9mIHF1YWRzKSB7XG4gICAgICAgICAgaWYoX2NvbXBhcmVUcmlwbGVzKHEsIHF1YWQpKSB7XG4gICAgICAgICAgICB1bmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih1bmlxdWUpIHtcbiAgICAgICAgICBxdWFkcy5wdXNoKHF1YWQpO1xuICAgICAgICAgIGRhdGFzZXQucHVzaChxdWFkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIFJERiBkYXRhc2V0IHRvIE4tUXVhZHMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhc2V0IChhcnJheSBvZiBxdWFkcykgdGhlIFJERiBkYXRhc2V0IHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIE4tUXVhZHMgc3RyaW5nLlxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZShkYXRhc2V0KSB7XG4gICAgaWYoIUFycmF5LmlzQXJyYXkoZGF0YXNldCkpIHtcbiAgICAgIGRhdGFzZXQgPSBOUXVhZHMubGVnYWN5RGF0YXNldFRvUXVhZHMoZGF0YXNldCk7XG4gICAgfVxuICAgIGNvbnN0IHF1YWRzID0gW107XG4gICAgZm9yKGNvbnN0IHF1YWQgb2YgZGF0YXNldCkge1xuICAgICAgcXVhZHMucHVzaChOUXVhZHMuc2VyaWFsaXplUXVhZChxdWFkKSk7XG4gICAgfVxuICAgIHJldHVybiBxdWFkcy5zb3J0KCkuam9pbignJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gUkRGIHF1YWQgdG8gYW4gTi1RdWFkIHN0cmluZyAoYSBzaW5nbGUgcXVhZCkuXG4gICAqXG4gICAqIEBwYXJhbSBxdWFkIHRoZSBSREYgcXVhZCBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBOLVF1YWQgc3RyaW5nLlxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZVF1YWQocXVhZCkge1xuICAgIGNvbnN0IHMgPSBxdWFkLnN1YmplY3Q7XG4gICAgY29uc3QgcCA9IHF1YWQucHJlZGljYXRlO1xuICAgIGNvbnN0IG8gPSBxdWFkLm9iamVjdDtcbiAgICBjb25zdCBnID0gcXVhZC5ncmFwaDtcblxuICAgIGxldCBucXVhZCA9ICcnO1xuXG4gICAgLy8gc3ViamVjdCBhbmQgcHJlZGljYXRlIGNhbiBvbmx5IGJlIE5hbWVkTm9kZSBvciBCbGFua05vZGVcbiAgICBbcywgcF0uZm9yRWFjaCh0ZXJtID0+IHtcbiAgICAgIGlmKHRlcm0udGVybVR5cGUgPT09ICdOYW1lZE5vZGUnKSB7XG4gICAgICAgIG5xdWFkICs9ICc8JyArIHRlcm0udmFsdWUgKyAnPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBucXVhZCArPSB0ZXJtLnZhbHVlO1xuICAgICAgfVxuICAgICAgbnF1YWQgKz0gJyAnO1xuICAgIH0pO1xuXG4gICAgLy8gb2JqZWN0IGlzIE5hbWVkTm9kZSwgQmxhbmtOb2RlLCBvciBMaXRlcmFsXG4gICAgaWYoby50ZXJtVHlwZSA9PT0gJ05hbWVkTm9kZScpIHtcbiAgICAgIG5xdWFkICs9ICc8JyArIG8udmFsdWUgKyAnPic7XG4gICAgfSBlbHNlIGlmKG8udGVybVR5cGUgPT09ICdCbGFua05vZGUnKSB7XG4gICAgICBucXVhZCArPSBvLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBucXVhZCArPSAnXCInICsgX2VzY2FwZShvLnZhbHVlKSArICdcIic7XG4gICAgICBpZihvLmRhdGF0eXBlLnZhbHVlID09PSBSREZfTEFOR1NUUklORykge1xuICAgICAgICBpZihvLmxhbmd1YWdlKSB7XG4gICAgICAgICAgbnF1YWQgKz0gJ0AnICsgby5sYW5ndWFnZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKG8uZGF0YXR5cGUudmFsdWUgIT09IFhTRF9TVFJJTkcpIHtcbiAgICAgICAgbnF1YWQgKz0gJ15ePCcgKyBvLmRhdGF0eXBlLnZhbHVlICsgJz4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdyYXBoIGNhbiBvbmx5IGJlIE5hbWVkTm9kZSBvciBCbGFua05vZGUgKG9yIERlZmF1bHRHcmFwaCwgYnV0IHRoYXRcbiAgICAvLyBkb2VzIG5vdCBhZGQgdG8gYG5xdWFkYClcbiAgICBpZihnLnRlcm1UeXBlID09PSAnTmFtZWROb2RlJykge1xuICAgICAgbnF1YWQgKz0gJyA8JyArIGcudmFsdWUgKyAnPic7XG4gICAgfSBlbHNlIGlmKGcudGVybVR5cGUgPT09ICdCbGFua05vZGUnKSB7XG4gICAgICBucXVhZCArPSAnICcgKyBnLnZhbHVlO1xuICAgIH1cblxuICAgIG5xdWFkICs9ICcgLlxcbic7XG4gICAgcmV0dXJuIG5xdWFkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbGVnYWN5LWZvcm1hdHRlZCBkYXRhc2V0IHRvIGFuIGFycmF5IG9mIHF1YWRzIGRhdGFzZXQgcGVyXG4gICAqIGh0dHA6Ly9yZGYuanMub3JnLy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGFzZXQgdGhlIGxlZ2FjeSBkYXRhc2V0IHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGFycmF5IG9mIHF1YWRzIGRhdGFzZXQuXG4gICAqL1xuICBzdGF0aWMgbGVnYWN5RGF0YXNldFRvUXVhZHMoZGF0YXNldCkge1xuICAgIGNvbnN0IHF1YWRzID0gW107XG5cbiAgICBjb25zdCB0ZXJtVHlwZU1hcCA9IHtcbiAgICAgICdibGFuayBub2RlJzogJ0JsYW5rTm9kZScsXG4gICAgICBJUkk6ICdOYW1lZE5vZGUnLFxuICAgICAgbGl0ZXJhbDogJ0xpdGVyYWwnXG4gICAgfTtcblxuICAgIGZvcihjb25zdCBncmFwaE5hbWUgaW4gZGF0YXNldCkge1xuICAgICAgY29uc3QgdHJpcGxlcyA9IGRhdGFzZXRbZ3JhcGhOYW1lXTtcbiAgICAgIHRyaXBsZXMuZm9yRWFjaCh0cmlwbGUgPT4ge1xuICAgICAgICBjb25zdCBxdWFkID0ge307XG4gICAgICAgIGZvcihjb25zdCBjb21wb25lbnROYW1lIGluIHRyaXBsZSkge1xuICAgICAgICAgIGNvbnN0IG9sZENvbXBvbmVudCA9IHRyaXBsZVtjb21wb25lbnROYW1lXTtcbiAgICAgICAgICBjb25zdCBuZXdDb21wb25lbnQgPSB7XG4gICAgICAgICAgICB0ZXJtVHlwZTogdGVybVR5cGVNYXBbb2xkQ29tcG9uZW50LnR5cGVdLFxuICAgICAgICAgICAgdmFsdWU6IG9sZENvbXBvbmVudC52YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYobmV3Q29tcG9uZW50LnRlcm1UeXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIG5ld0NvbXBvbmVudC5kYXRhdHlwZSA9IHtcbiAgICAgICAgICAgICAgdGVybVR5cGU6ICdOYW1lZE5vZGUnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYoJ2RhdGF0eXBlJyBpbiBvbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgbmV3Q29tcG9uZW50LmRhdGF0eXBlLnZhbHVlID0gb2xkQ29tcG9uZW50LmRhdGF0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoJ2xhbmd1YWdlJyBpbiBvbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgaWYoISgnZGF0YXR5cGUnIGluIG9sZENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBuZXdDb21wb25lbnQuZGF0YXR5cGUudmFsdWUgPSBSREZfTEFOR1NUUklORztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXdDb21wb25lbnQubGFuZ3VhZ2UgPSBvbGRDb21wb25lbnQubGFuZ3VhZ2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYoISgnZGF0YXR5cGUnIGluIG9sZENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgbmV3Q29tcG9uZW50LmRhdGF0eXBlLnZhbHVlID0gWFNEX1NUUklORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcXVhZFtjb21wb25lbnROYW1lXSA9IG5ld0NvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZihncmFwaE5hbWUgPT09ICdAZGVmYXVsdCcpIHtcbiAgICAgICAgICBxdWFkLmdyYXBoID0ge1xuICAgICAgICAgICAgdGVybVR5cGU6ICdEZWZhdWx0R3JhcGgnLFxuICAgICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWFkLmdyYXBoID0ge1xuICAgICAgICAgICAgdGVybVR5cGU6IGdyYXBoTmFtZS5zdGFydHNXaXRoKCdfOicpID8gJ0JsYW5rTm9kZScgOiAnTmFtZWROb2RlJyxcbiAgICAgICAgICAgIHZhbHVlOiBncmFwaE5hbWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHF1YWRzLnB1c2gocXVhZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVhZHM7XG4gIH1cbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIFJERiB0cmlwbGVzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0gdDEgdGhlIGZpcnN0IHRyaXBsZS5cbiAqIEBwYXJhbSB0MiB0aGUgc2Vjb25kIHRyaXBsZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHRyaXBsZXMgYXJlIHRoZSBzYW1lLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9jb21wYXJlVHJpcGxlcyh0MSwgdDIpIHtcbiAgZm9yKGNvbnN0IGsgaW4gdDEpIHtcbiAgICBpZih0MVtrXS50ZXJtVHlwZSAhPT0gdDJba10udGVybVR5cGUgfHwgdDFba10udmFsdWUgIT09IHQyW2tdLnZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmKHQxLm9iamVjdC50ZXJtVHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIChcbiAgICAodDEub2JqZWN0LmRhdGF0eXBlLnRlcm1UeXBlID09PSB0Mi5vYmplY3QuZGF0YXR5cGUudGVybVR5cGUpICYmXG4gICAgKHQxLm9iamVjdC5kYXRhdHlwZS52YWx1ZSA9PT0gdDIub2JqZWN0LmRhdGF0eXBlLnZhbHVlKSAmJlxuICAgICh0MS5vYmplY3QubGFuZ3VhZ2UgPT09IHQyLm9iamVjdC5sYW5ndWFnZSlcbiAgKTtcbn1cblxuY29uc3QgX2VzY2FwZVJlZ2V4ID0gL1tcIlxcXFxcXG5cXHJdL2c7XG4vKipcbiAqIEVzY2FwZSBzdHJpbmcgdG8gTi1RdWFkcyBsaXRlcmFsXG4gKi9cbmZ1bmN0aW9uIF9lc2NhcGUocykge1xuICByZXR1cm4gcy5yZXBsYWNlKF9lc2NhcGVSZWdleCwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBzd2l0Y2gobWF0Y2gpIHtcbiAgICAgIGNhc2UgJ1wiJzogcmV0dXJuICdcXFxcXCInO1xuICAgICAgY2FzZSAnXFxcXCc6IHJldHVybiAnXFxcXFxcXFwnO1xuICAgICAgY2FzZSAnXFxuJzogcmV0dXJuICdcXFxcbic7XG4gICAgICBjYXNlICdcXHInOiByZXR1cm4gJ1xcXFxyJztcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBfdW5lc2NhcGVSZWdleCA9XG4gIC8oPzpcXFxcKFt0Ym5yZlwiJ1xcXFxdKSl8KD86XFxcXHUoWzAtOUEtRmEtZl17NH0pKXwoPzpcXFxcVShbMC05QS1GYS1mXXs4fSkpL2c7XG4vKipcbiAqIFVuZXNjYXBlIE4tUXVhZHMgbGl0ZXJhbCB0byBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gX3VuZXNjYXBlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShfdW5lc2NhcGVSZWdleCwgZnVuY3Rpb24obWF0Y2gsIGNvZGUsIHUsIFUpIHtcbiAgICBpZihjb2RlKSB7XG4gICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlICd0JzogcmV0dXJuICdcXHQnO1xuICAgICAgICBjYXNlICdiJzogcmV0dXJuICdcXGInO1xuICAgICAgICBjYXNlICduJzogcmV0dXJuICdcXG4nO1xuICAgICAgICBjYXNlICdyJzogcmV0dXJuICdcXHInO1xuICAgICAgICBjYXNlICdmJzogcmV0dXJuICdcXGYnO1xuICAgICAgICBjYXNlICdcIic6IHJldHVybiAnXCInO1xuICAgICAgICBjYXNlICdcXCcnOiByZXR1cm4gJ1xcJyc7XG4gICAgICAgIGNhc2UgJ1xcXFwnOiByZXR1cm4gJ1xcXFwnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZih1KSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh1LCAxNikpO1xuICAgIH1cbiAgICBpZihVKSB7XG4gICAgICAvLyBGSVhNRTogc3VwcG9ydCBsYXJnZXIgdmFsdWVzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFUgZXNjYXBlJyk7XG4gICAgfVxuICB9KTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRPRE86IGNvbnZlcnQgdG8gRVM2IGl0ZXJhYmxlXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUGVybXV0YXRvciB7XG4gIC8qKlxuICAgKiBBIFBlcm11dGF0b3IgaXRlcmF0ZXMgb3ZlciBhbGwgcG9zc2libGUgcGVybXV0YXRpb25zIG9mIHRoZSBnaXZlbiBhcnJheVxuICAgKiBvZiBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIGxpc3QgdGhlIGFycmF5IG9mIGVsZW1lbnRzIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxpc3QpIHtcbiAgICAvLyBvcmlnaW5hbCBhcnJheVxuICAgIHRoaXMubGlzdCA9IGxpc3Quc29ydCgpO1xuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlIHBlcm11dGF0aW9uc1xuICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIC8vIGRpcmVjdGlvbmFsIGluZm8gZm9yIHBlcm11dGF0aW9uIGFsZ29yaXRobVxuICAgIHRoaXMubGVmdCA9IHt9O1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLmxlZnRbbGlzdFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYW5vdGhlciBwZXJtdXRhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGFub3RoZXIgcGVybXV0YXRpb24sIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGhhc05leHQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmRvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmV4dCBwZXJtdXRhdGlvbi4gQ2FsbCBoYXNOZXh0KCkgdG8gZW5zdXJlIHRoZXJlIGlzIGFub3RoZXIgb25lXG4gICAqIGZpcnN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBuZXh0IHBlcm11dGF0aW9uLlxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICAvLyBjb3B5IGN1cnJlbnQgcGVybXV0YXRpb25cbiAgICBjb25zdCBydmFsID0gdGhpcy5saXN0LnNsaWNlKCk7XG5cbiAgICAvKiBDYWxjdWxhdGUgdGhlIG5leHQgcGVybXV0YXRpb24gdXNpbmcgdGhlIFN0ZWluaGF1cy1Kb2huc29uLVRyb3R0ZXJcbiAgICAgcGVybXV0YXRpb24gYWxnb3JpdGhtLiAqL1xuXG4gICAgLy8gZ2V0IGxhcmdlc3QgbW9iaWxlIGVsZW1lbnQga1xuICAgIC8vIChtb2JpbGU6IGVsZW1lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBvbmUgaXQgaXMgbG9va2luZyBhdClcbiAgICBsZXQgayA9IG51bGw7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5saXN0Lmxlbmd0aDtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmxpc3RbaV07XG4gICAgICBjb25zdCBsZWZ0ID0gdGhpcy5sZWZ0W2VsZW1lbnRdO1xuICAgICAgaWYoKGsgPT09IG51bGwgfHwgZWxlbWVudCA+IGspICYmXG4gICAgICAgICgobGVmdCAmJiBpID4gMCAmJiBlbGVtZW50ID4gdGhpcy5saXN0W2kgLSAxXSkgfHxcbiAgICAgICAgKCFsZWZ0ICYmIGkgPCAobGVuZ3RoIC0gMSkgJiYgZWxlbWVudCA+IHRoaXMubGlzdFtpICsgMV0pKSkge1xuICAgICAgICBrID0gZWxlbWVudDtcbiAgICAgICAgcG9zID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHBlcm11dGF0aW9uc1xuICAgIGlmKGsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3YXAgayBhbmQgdGhlIGVsZW1lbnQgaXQgaXMgbG9va2luZyBhdFxuICAgICAgY29uc3Qgc3dhcCA9IHRoaXMubGVmdFtrXSA/IHBvcyAtIDEgOiBwb3MgKyAxO1xuICAgICAgdGhpcy5saXN0W3Bvc10gPSB0aGlzLmxpc3Rbc3dhcF07XG4gICAgICB0aGlzLmxpc3Rbc3dhcF0gPSBrO1xuXG4gICAgICAvLyByZXZlcnNlIHRoZSBkaXJlY3Rpb24gb2YgYWxsIGVsZW1lbnRzIGxhcmdlciB0aGFuIGtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBpZih0aGlzLmxpc3RbaV0gPiBrKSB7XG4gICAgICAgICAgdGhpcy5sZWZ0W3RoaXMubGlzdFtpXV0gPSAhdGhpcy5sZWZ0W3RoaXMubGlzdFtpXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfVxufTtcblxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXN5bmNBbGdvcml0aG0gPSByZXF1aXJlKCcuL0FzeW5jQWxnb3JpdGhtJyk7XG5jb25zdCBJZGVudGlmaWVySXNzdWVyID0gcmVxdWlyZSgnLi9JZGVudGlmaWVySXNzdWVyJyk7XG5jb25zdCBNZXNzYWdlRGlnZXN0ID0gcmVxdWlyZSgnLi9NZXNzYWdlRGlnZXN0Jyk7XG5jb25zdCBQZXJtdXRhdG9yID0gcmVxdWlyZSgnLi9QZXJtdXRhdG9yJyk7XG5jb25zdCBOUXVhZHMgPSByZXF1aXJlKCcuL05RdWFkcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCBQT1NJVElPTlMgPSB7c3ViamVjdDogJ3MnLCBvYmplY3Q6ICdvJywgZ3JhcGg6ICdnJ307XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVVJETkEyMDE1IGV4dGVuZHMgQXN5bmNBbGdvcml0aG0ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5uYW1lID0gJ1VSRE5BMjAxNSc7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgdGhpcy5ibGFua05vZGVJbmZvID0ge307XG4gICAgdGhpcy5oYXNoVG9CbGFua05vZGVzID0ge307XG4gICAgdGhpcy5jYW5vbmljYWxJc3N1ZXIgPSBuZXcgSWRlbnRpZmllcklzc3VlcignXzpjMTRuJyk7XG4gICAgdGhpcy5oYXNoQWxnb3JpdGhtID0gJ3NoYTI1Nic7XG4gICAgdGhpcy5xdWFkcztcbiAgfVxuXG4gIC8vIDQuNCkgTm9ybWFsaXphdGlvbiBBbGdvcml0aG1cbiAgbWFpbihkYXRhc2V0LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuc2NoZWR1bGUuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgc2VsZi5xdWFkcyA9IGRhdGFzZXQ7XG5cbiAgICAvLyAxKSBDcmVhdGUgdGhlIG5vcm1hbGl6YXRpb24gc3RhdGUuXG5cbiAgICAvLyBOb3RlOiBPcHRpbWl6ZSBieSBnZW5lcmF0aW5nIG5vbi1ub3JtYWxpemVkIGJsYW5rIG5vZGUgbWFwIGNvbmN1cnJlbnRseS5cbiAgICBjb25zdCBub25Ob3JtYWxpemVkID0ge307XG5cbiAgICBzZWxmLndhdGVyZmFsbChbXG4gICAgICBjYWxsYmFjayA9PiB7XG4gICAgICAgIC8vIDIpIEZvciBldmVyeSBxdWFkIGluIGlucHV0IGRhdGFzZXQ6XG4gICAgICAgIHNlbGYuZm9yRWFjaChkYXRhc2V0LCAocXVhZCwgaWR4LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIC8vIDIuMSkgRm9yIGVhY2ggYmxhbmsgbm9kZSB0aGF0IG9jY3VycyBpbiB0aGUgcXVhZCwgYWRkIGEgcmVmZXJlbmNlXG4gICAgICAgICAgLy8gdG8gdGhlIHF1YWQgdXNpbmcgdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpbiB0aGUgYmxhbmsgbm9kZSB0b1xuICAgICAgICAgIC8vIHF1YWRzIG1hcCwgY3JlYXRpbmcgYSBuZXcgZW50cnkgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgIHNlbGYuZm9yRWFjaENvbXBvbmVudChxdWFkLCBjb21wb25lbnQgPT4ge1xuICAgICAgICAgICAgaWYoY29tcG9uZW50LnRlcm1UeXBlICE9PSAnQmxhbmtOb2RlJykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9IGNvbXBvbmVudC52YWx1ZTtcbiAgICAgICAgICAgIGlmKGlkIGluIHNlbGYuYmxhbmtOb2RlSW5mbykge1xuICAgICAgICAgICAgICBzZWxmLmJsYW5rTm9kZUluZm9baWRdLnF1YWRzLnB1c2gocXVhZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub25Ob3JtYWxpemVkW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgIHNlbGYuYmxhbmtOb2RlSW5mb1tpZF0gPSB7cXVhZHM6IFtxdWFkXX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICB9LFxuICAgICAgY2FsbGJhY2sgPT4ge1xuICAgICAgICAvLyAzKSBDcmVhdGUgYSBsaXN0IG9mIG5vbi1ub3JtYWxpemVkIGJsYW5rIG5vZGUgaWRlbnRpZmllcnNcbiAgICAgICAgLy8gbm9uLW5vcm1hbGl6ZWQgaWRlbnRpZmllcnMgYW5kIHBvcHVsYXRlIGl0IHVzaW5nIHRoZSBrZXlzIGZyb20gdGhlXG4gICAgICAgIC8vIGJsYW5rIG5vZGUgdG8gcXVhZHMgbWFwLlxuICAgICAgICAvLyBOb3RlOiBXZSB1c2UgYSBtYXAgaGVyZSBhbmQgaXQgd2FzIGdlbmVyYXRlZCBkdXJpbmcgc3RlcCAyLlxuXG4gICAgICAgIC8vIDQpIEluaXRpYWxpemUgc2ltcGxlLCBhIGJvb2xlYW4gZmxhZywgdG8gdHJ1ZS5cbiAgICAgICAgbGV0IHNpbXBsZSA9IHRydWU7XG5cbiAgICAgICAgLy8gNSkgV2hpbGUgc2ltcGxlIGlzIHRydWUsIGlzc3VlIGNhbm9uaWNhbCBpZGVudGlmaWVycyBmb3IgYmxhbmsgbm9kZXM6XG4gICAgICAgIHNlbGYud2hpbHN0KCgpID0+IHNpbXBsZSwgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIC8vIDUuMSkgU2V0IHNpbXBsZSB0byBmYWxzZS5cbiAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIDUuMikgQ2xlYXIgaGFzaCB0byBibGFuayBub2RlcyBtYXAuXG4gICAgICAgICAgc2VsZi5oYXNoVG9CbGFua05vZGVzID0ge307XG5cbiAgICAgICAgICBzZWxmLndhdGVyZmFsbChbXG4gICAgICAgICAgICBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAgIC8vIDUuMykgRm9yIGVhY2ggYmxhbmsgbm9kZSBpZGVudGlmaWVyIGlkZW50aWZpZXIgaW5cbiAgICAgICAgICAgICAgLy8gbm9uLW5vcm1hbGl6ZWQgaWRlbnRpZmllcnM6XG4gICAgICAgICAgICAgIHNlbGYuZm9yRWFjaChub25Ob3JtYWxpemVkLCAodmFsdWUsIGlkLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIDUuMy4xKSBDcmVhdGUgYSBoYXNoLCBoYXNoLCBhY2NvcmRpbmcgdG8gdGhlIEhhc2ggRmlyc3RcbiAgICAgICAgICAgICAgICAvLyBEZWdyZWUgUXVhZHMgYWxnb3JpdGhtLlxuICAgICAgICAgICAgICAgIHNlbGYuaGFzaEZpcnN0RGVncmVlUXVhZHMoaWQsIChlcnIsIGhhc2gpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIDUuMy4yKSBBZGQgaGFzaCBhbmQgaWRlbnRpZmllciB0byBoYXNoIHRvIGJsYW5rIG5vZGVzIG1hcCxcbiAgICAgICAgICAgICAgICAgIC8vIGNyZWF0aW5nIGEgbmV3IGVudHJ5IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAgIGlmKGhhc2ggaW4gc2VsZi5oYXNoVG9CbGFua05vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGFzaFRvQmxhbmtOb2Rlc1toYXNoXS5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGFzaFRvQmxhbmtOb2Rlc1toYXNoXSA9IFtpZF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICAvLyA1LjQpIEZvciBlYWNoIGhhc2ggdG8gaWRlbnRpZmllciBsaXN0IG1hcHBpbmcgaW4gaGFzaCB0byBibGFua1xuICAgICAgICAgICAgICAvLyBub2RlcyBtYXAsIGxleGljb2dyYXBoaWNhbGx5LXNvcnRlZCBieSBoYXNoOlxuICAgICAgICAgICAgICBjb25zdCBoYXNoZXMgPSBPYmplY3Qua2V5cyhzZWxmLmhhc2hUb0JsYW5rTm9kZXMpLnNvcnQoKTtcbiAgICAgICAgICAgICAgc2VsZi5mb3JFYWNoKGhhc2hlcywgKGhhc2gsIGksIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gNS40LjEpIElmIHRoZSBsZW5ndGggb2YgaWRlbnRpZmllciBsaXN0IGlzIGdyZWF0ZXIgdGhhbiAxLFxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHRvIHRoZSBuZXh0IG1hcHBpbmcuXG4gICAgICAgICAgICAgICAgY29uc3QgaWRMaXN0ID0gc2VsZi5oYXNoVG9CbGFua05vZGVzW2hhc2hdO1xuICAgICAgICAgICAgICAgIGlmKGlkTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyA1LjQuMikgVXNlIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZyBjYW5vbmljYWxcbiAgICAgICAgICAgICAgICAvLyBpc3N1ZXIgYW5kIHRoZSBzaW5nbGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGluIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAvLyBsaXN0LCBpZGVudGlmaWVyLCB0byBpc3N1ZSBhIGNhbm9uaWNhbCByZXBsYWNlbWVudCBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgY2hhbmdpbmcgYGdldElkYCB0byBgaXNzdWVgXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBpZExpc3RbMF07XG4gICAgICAgICAgICAgICAgc2VsZi5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQoaWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gNS40LjMpIFJlbW92ZSBpZGVudGlmaWVyIGZyb20gbm9uLW5vcm1hbGl6ZWQgaWRlbnRpZmllcnMuXG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vbk5vcm1hbGl6ZWRbaWRdO1xuXG4gICAgICAgICAgICAgICAgLy8gNS40LjQpIFJlbW92ZSBoYXNoIGZyb20gdGhlIGhhc2ggdG8gYmxhbmsgbm9kZXMgbWFwLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmhhc2hUb0JsYW5rTm9kZXNbaGFzaF07XG5cbiAgICAgICAgICAgICAgICAvLyA1LjQuNSkgU2V0IHNpbXBsZSB0byB0cnVlLlxuICAgICAgICAgICAgICAgIHNpbXBsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgfSxcbiAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgLy8gNikgRm9yIGVhY2ggaGFzaCB0byBpZGVudGlmaWVyIGxpc3QgbWFwcGluZyBpbiBoYXNoIHRvIGJsYW5rIG5vZGVzXG4gICAgICAgIC8vIG1hcCwgbGV4aWNvZ3JhcGhpY2FsbHktc29ydGVkIGJ5IGhhc2g6XG4gICAgICAgIGNvbnN0IGhhc2hlcyA9IE9iamVjdC5rZXlzKHNlbGYuaGFzaFRvQmxhbmtOb2Rlcykuc29ydCgpO1xuICAgICAgICBzZWxmLmZvckVhY2goaGFzaGVzLCAoaGFzaCwgaWR4LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIC8vIDYuMSkgQ3JlYXRlIGhhc2ggcGF0aCBsaXN0IHdoZXJlIGVhY2ggaXRlbSB3aWxsIGJlIGEgcmVzdWx0IG9mXG4gICAgICAgICAgLy8gcnVubmluZyB0aGUgSGFzaCBOLURlZ3JlZSBRdWFkcyBhbGdvcml0aG0uXG4gICAgICAgICAgY29uc3QgaGFzaFBhdGhMaXN0ID0gW107XG5cbiAgICAgICAgICAvLyA2LjIpIEZvciBlYWNoIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpZGVudGlmaWVyIGluIGlkZW50aWZpZXIgbGlzdDpcbiAgICAgICAgICBjb25zdCBpZExpc3QgPSBzZWxmLmhhc2hUb0JsYW5rTm9kZXNbaGFzaF07XG4gICAgICAgICAgc2VsZi53YXRlcmZhbGwoW1xuICAgICAgICAgICAgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICBzZWxmLmZvckVhY2goaWRMaXN0LCAoaWQsIGlkeCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAvLyA2LjIuMSkgSWYgYSBjYW5vbmljYWwgaWRlbnRpZmllciBoYXMgYWxyZWFkeSBiZWVuIGlzc3VlZCBmb3JcbiAgICAgICAgICAgICAgICAvLyBpZGVudGlmaWVyLCBjb250aW51ZSB0byB0aGUgbmV4dCBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgIGlmKHNlbGYuY2Fub25pY2FsSXNzdWVyLmhhc0lkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gNi4yLjIpIENyZWF0ZSB0ZW1wb3JhcnkgaXNzdWVyLCBhbiBpZGVudGlmaWVyIGlzc3VlclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemVkIHdpdGggdGhlIHByZWZpeCBfOmIuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNzdWVyID0gbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YicpO1xuXG4gICAgICAgICAgICAgICAgLy8gNi4yLjMpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmcgdGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgLy8gaXNzdWVyIGFuZCBpZGVudGlmaWVyLCB0byBpc3N1ZSBhIG5ldyB0ZW1wb3JhcnkgYmxhbmsgbm9kZVxuICAgICAgICAgICAgICAgIC8vIGlkZW50aWZpZXIgZm9yIGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgaXNzdWVyLmdldElkKGlkKTtcblxuICAgICAgICAgICAgICAgIC8vIDYuMi40KSBSdW4gdGhlIEhhc2ggTi1EZWdyZWUgUXVhZHMgYWxnb3JpdGhtLCBwYXNzaW5nXG4gICAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IGlzc3VlciwgYW5kIGFwcGVuZCB0aGUgcmVzdWx0IHRvIHRoZSBoYXNoIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgICAgIHNlbGYuaGFzaE5EZWdyZWVRdWFkcyhpZCwgaXNzdWVyLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGhhc2hQYXRoTGlzdC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICAvLyA2LjMpIEZvciBlYWNoIHJlc3VsdCBpbiB0aGUgaGFzaCBwYXRoIGxpc3QsXG4gICAgICAgICAgICAgIC8vIGxleGljb2dyYXBoaWNhbGx5LXNvcnRlZCBieSB0aGUgaGFzaCBpbiByZXN1bHQ6XG4gICAgICAgICAgICAgIC8vIFRPRE86IHVzZSBgU3RyaW5nLmxvY2FsZUNvbXBhcmVgP1xuICAgICAgICAgICAgICBoYXNoUGF0aExpc3Quc29ydCgoYSwgYikgPT5cbiAgICAgICAgICAgICAgICAoYS5oYXNoIDwgYi5oYXNoKSA/IC0xIDogKChhLmhhc2ggPiBiLmhhc2gpID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgc2VsZi5mb3JFYWNoKGhhc2hQYXRoTGlzdCwgKHJlc3VsdCwgaWR4LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIDYuMy4xKSBGb3IgZWFjaCBibGFuayBub2RlIGlkZW50aWZpZXIsIGV4aXN0aW5nIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3YXMgaXNzdWVkIGEgdGVtcG9yYXJ5IGlkZW50aWZpZXIgYnkgaWRlbnRpZmllciBpc3N1ZXJcbiAgICAgICAgICAgICAgICAvLyBpbiByZXN1bHQsIGlzc3VlIGEgY2Fub25pY2FsIGlkZW50aWZpZXIsIGluIHRoZSBzYW1lIG9yZGVyLFxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZyBjYW5vbmljYWxcbiAgICAgICAgICAgICAgICAvLyBpc3N1ZXIgYW5kIGV4aXN0aW5nIGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgZm9yKGNvbnN0IGV4aXN0aW5nIGluIHJlc3VsdC5pc3N1ZXIuZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuY2Fub25pY2FsSXNzdWVyLmdldElkKGV4aXN0aW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgfSwgY2FsbGJhY2sgPT4ge1xuICAgICAgICAvKiBOb3RlOiBBdCB0aGlzIHBvaW50IGFsbCBibGFuayBub2RlcyBpbiB0aGUgc2V0IG9mIFJERiBxdWFkcyBoYXZlIGJlZW5cbiAgICAgICAgYXNzaWduZWQgY2Fub25pY2FsIGlkZW50aWZpZXJzLCB3aGljaCBoYXZlIGJlZW4gc3RvcmVkIGluIHRoZSBjYW5vbmljYWxcbiAgICAgICAgaXNzdWVyLiBIZXJlIGVhY2ggcXVhZCBpcyB1cGRhdGVkIGJ5IGFzc2lnbmluZyBlYWNoIG9mIGl0cyBibGFuayBub2Rlc1xuICAgICAgICBpdHMgbmV3IGlkZW50aWZpZXIuICovXG5cbiAgICAgICAgLy8gNykgRm9yIGVhY2ggcXVhZCwgcXVhZCwgaW4gaW5wdXQgZGF0YXNldDpcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuICAgICAgICBzZWxmLndhdGVyZmFsbChbXG4gICAgICAgICAgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgc2VsZi5mb3JFYWNoKHNlbGYucXVhZHMsIChxdWFkLCBpZHgsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgIC8vIDcuMSkgQ3JlYXRlIGEgY29weSwgcXVhZCBjb3B5LCBvZiBxdWFkIGFuZCByZXBsYWNlIGFueSBleGlzdGluZ1xuICAgICAgICAgICAgICAvLyBibGFuayBub2RlIGlkZW50aWZpZXJzIHVzaW5nIHRoZSBjYW5vbmljYWwgaWRlbnRpZmllcnNcbiAgICAgICAgICAgICAgLy8gcHJldmlvdXNseSBpc3N1ZWQgYnkgY2Fub25pY2FsIGlzc3Vlci5cbiAgICAgICAgICAgICAgLy8gTm90ZTogV2Ugb3B0aW1pemUgYXdheSB0aGUgY29weSBoZXJlLlxuICAgICAgICAgICAgICBzZWxmLmZvckVhY2hDb21wb25lbnQocXVhZCwgY29tcG9uZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZihjb21wb25lbnQudGVybVR5cGUgPT09ICdCbGFua05vZGUnICYmXG4gICAgICAgICAgICAgICAgICAhY29tcG9uZW50LnZhbHVlLnN0YXJ0c1dpdGgoc2VsZi5jYW5vbmljYWxJc3N1ZXIucHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnZhbHVlID0gc2VsZi5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQoY29tcG9uZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyA3LjIpIEFkZCBxdWFkIGNvcHkgdG8gdGhlIG5vcm1hbGl6ZWQgZGF0YXNldC5cbiAgICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKE5RdWFkcy5zZXJpYWxpemVRdWFkKHF1YWQpKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIC8vIHNvcnQgbm9ybWFsaXplZCBvdXRwdXRcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQuc29ydCgpO1xuXG4gICAgICAgICAgICAvLyA4KSBSZXR1cm4gdGhlIG5vcm1hbGl6ZWQgZGF0YXNldC5cbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZWQuam9pbignJyk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIF0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICBdLCBlcnIgPT4gY2FsbGJhY2soZXJyLCByZXN1bHQpKTtcbiAgfVxuXG4gIC8vIDQuNikgSGFzaCBGaXJzdCBEZWdyZWUgUXVhZHNcbiAgaGFzaEZpcnN0RGVncmVlUXVhZHMoaWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyByZXR1cm4gY2FjaGVkIGhhc2hcbiAgICBjb25zdCBpbmZvID0gc2VsZi5ibGFua05vZGVJbmZvW2lkXTtcbiAgICBpZignaGFzaCcgaW4gaW5mbykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGluZm8uaGFzaCk7XG4gICAgfVxuXG4gICAgLy8gMSkgSW5pdGlhbGl6ZSBucXVhZHMgdG8gYW4gZW1wdHkgbGlzdC4gSXQgd2lsbCBiZSB1c2VkIHRvIHN0b3JlIHF1YWRzIGluXG4gICAgLy8gTi1RdWFkcyBmb3JtYXQuXG4gICAgY29uc3QgbnF1YWRzID0gW107XG5cbiAgICAvLyAyKSBHZXQgdGhlIGxpc3Qgb2YgcXVhZHMgcXVhZHMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWZlcmVuY2UgYmxhbmsgbm9kZVxuICAgIC8vIGlkZW50aWZpZXIgaW4gdGhlIGJsYW5rIG5vZGUgdG8gcXVhZHMgbWFwLlxuICAgIGNvbnN0IHF1YWRzID0gaW5mby5xdWFkcztcblxuICAgIC8vIDMpIEZvciBlYWNoIHF1YWQgcXVhZCBpbiBxdWFkczpcbiAgICBzZWxmLmZvckVhY2gocXVhZHMsIChxdWFkLCBpZHgsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAvLyAzLjEpIFNlcmlhbGl6ZSB0aGUgcXVhZCBpbiBOLVF1YWRzIGZvcm1hdCB3aXRoIHRoZSBmb2xsb3dpbmcgc3BlY2lhbFxuICAgICAgLy8gcnVsZTpcblxuICAgICAgLy8gMy4xLjEpIElmIGFueSBjb21wb25lbnQgaW4gcXVhZCBpcyBhbiBibGFuayBub2RlLCB0aGVuIHNlcmlhbGl6ZSBpdFxuICAgICAgLy8gdXNpbmcgYSBzcGVjaWFsIGlkZW50aWZpZXIgYXMgZm9sbG93czpcbiAgICAgIGNvbnN0IGNvcHkgPSB7cHJlZGljYXRlOiBxdWFkLnByZWRpY2F0ZX07XG4gICAgICBzZWxmLmZvckVhY2hDb21wb25lbnQocXVhZCwgKGNvbXBvbmVudCwga2V5KSA9PiB7XG4gICAgICAgIC8vIDMuMS4yKSBJZiB0aGUgYmxhbmsgbm9kZSdzIGV4aXN0aW5nIGJsYW5rIG5vZGUgaWRlbnRpZmllciBtYXRjaGVzIHRoZVxuICAgICAgICAvLyByZWZlcmVuY2UgYmxhbmsgbm9kZSBpZGVudGlmaWVyIHRoZW4gdXNlIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXJcbiAgICAgICAgLy8gXzphLCBvdGhlcndpc2UsIHVzZSB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIF86ei5cbiAgICAgICAgY29weVtrZXldID0gc2VsZi5tb2RpZnlGaXJzdERlZ3JlZUNvbXBvbmVudChpZCwgY29tcG9uZW50LCBrZXkpO1xuICAgICAgfSk7XG4gICAgICBucXVhZHMucHVzaChOUXVhZHMuc2VyaWFsaXplUXVhZChjb3B5KSk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICAvLyA0KSBTb3J0IG5xdWFkcyBpbiBsZXhpY29ncmFwaGljYWwgb3JkZXIuXG4gICAgICBucXVhZHMuc29ydCgpO1xuXG4gICAgICAvLyA1KSBSZXR1cm4gdGhlIGhhc2ggdGhhdCByZXN1bHRzIGZyb20gcGFzc2luZyB0aGUgc29ydGVkLCBqb2luZWQgbnF1YWRzXG4gICAgICAvLyB0aHJvdWdoIHRoZSBoYXNoIGFsZ29yaXRobS5cbiAgICAgIGNvbnN0IG1kID0gbmV3IE1lc3NhZ2VEaWdlc3Qoc2VsZi5oYXNoQWxnb3JpdGhtKTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBucXVhZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbWQudXBkYXRlKG5xdWFkc1tpXSk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiByZXByZXNlbnQgYXMgYnl0ZSBidWZmZXIgaW5zdGVhZCB0byBjdXQgbWVtb3J5IHVzYWdlIGluIGhhbGZcbiAgICAgIGluZm8uaGFzaCA9IG1kLmRpZ2VzdCgpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgaW5mby5oYXNoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIDQuNykgSGFzaCBSZWxhdGVkIEJsYW5rIE5vZGVcbiAgaGFzaFJlbGF0ZWRCbGFua05vZGUocmVsYXRlZCwgcXVhZCwgaXNzdWVyLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIDEpIFNldCB0aGUgaWRlbnRpZmllciB0byB1c2UgZm9yIHJlbGF0ZWQsIHByZWZlcnJpbmcgZmlyc3QgdGhlIGNhbm9uaWNhbFxuICAgIC8vIGlkZW50aWZpZXIgZm9yIHJlbGF0ZWQgaWYgaXNzdWVkLCBzZWNvbmQgdGhlIGlkZW50aWZpZXIgaXNzdWVkIGJ5IGlzc3VlclxuICAgIC8vIGlmIGlzc3VlZCwgYW5kIGxhc3QsIGlmIG5lY2Vzc2FyeSwgdGhlIHJlc3VsdCBvZiB0aGUgSGFzaCBGaXJzdCBEZWdyZWVcbiAgICAvLyBRdWFkcyBhbGdvcml0aG0sIHBhc3NpbmcgcmVsYXRlZC5cbiAgICBsZXQgaWQ7XG4gICAgc2VsZi53YXRlcmZhbGwoW1xuICAgICAgY2FsbGJhY2sgPT4ge1xuICAgICAgICBpZihzZWxmLmNhbm9uaWNhbElzc3Vlci5oYXNJZChyZWxhdGVkKSkge1xuICAgICAgICAgIGlkID0gc2VsZi5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQocmVsYXRlZCk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNzdWVyLmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICAgICAgaWQgPSBpc3N1ZXIuZ2V0SWQocmVsYXRlZCk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5oYXNoRmlyc3REZWdyZWVRdWFkcyhyZWxhdGVkLCAoZXJyLCBoYXNoKSA9PiB7XG4gICAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWQgPSBoYXNoO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIF0sIGVyciA9PiB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIDIpIEluaXRpYWxpemUgYSBzdHJpbmcgaW5wdXQgdG8gdGhlIHZhbHVlIG9mIHBvc2l0aW9uLlxuICAgICAgLy8gTm90ZTogV2UgdXNlIGEgaGFzaCBvYmplY3QgaW5zdGVhZC5cbiAgICAgIGNvbnN0IG1kID0gbmV3IE1lc3NhZ2VEaWdlc3Qoc2VsZi5oYXNoQWxnb3JpdGhtKTtcbiAgICAgIG1kLnVwZGF0ZShwb3NpdGlvbik7XG5cbiAgICAgIC8vIDMpIElmIHBvc2l0aW9uIGlzIG5vdCBnLCBhcHBlbmQgPCwgdGhlIHZhbHVlIG9mIHRoZSBwcmVkaWNhdGUgaW4gcXVhZCxcbiAgICAgIC8vIGFuZCA+IHRvIGlucHV0LlxuICAgICAgaWYocG9zaXRpb24gIT09ICdnJykge1xuICAgICAgICBtZC51cGRhdGUoc2VsZi5nZXRSZWxhdGVkUHJlZGljYXRlKHF1YWQpKTtcbiAgICAgIH1cblxuICAgICAgLy8gNCkgQXBwZW5kIGlkZW50aWZpZXIgdG8gaW5wdXQuXG4gICAgICBtZC51cGRhdGUoaWQpO1xuXG4gICAgICAvLyA1KSBSZXR1cm4gdGhlIGhhc2ggdGhhdCByZXN1bHRzIGZyb20gcGFzc2luZyBpbnB1dCB0aHJvdWdoIHRoZSBoYXNoXG4gICAgICAvLyBhbGdvcml0aG0uXG4gICAgICAvLyBUT0RPOiByZXByZXNlbnQgYXMgYnl0ZSBidWZmZXIgaW5zdGVhZCB0byBjdXQgbWVtb3J5IHVzYWdlIGluIGhhbGZcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBtZC5kaWdlc3QoKSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyA0LjgpIEhhc2ggTi1EZWdyZWUgUXVhZHNcbiAgaGFzaE5EZWdyZWVRdWFkcyhpZCwgaXNzdWVyLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gMSkgQ3JlYXRlIGEgaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcCBmb3Igc3RvcmluZyBoYXNoZXMgdGhhdFxuICAgIC8vIGlkZW50aWZ5IHJlbGF0ZWQgYmxhbmsgbm9kZXMuXG4gICAgLy8gTm90ZTogMikgYW5kIDMpIGhhbmRsZWQgd2l0aGluIGBjcmVhdGVIYXNoVG9SZWxhdGVkYFxuICAgIGxldCBoYXNoVG9SZWxhdGVkO1xuICAgIGNvbnN0IG1kID0gbmV3IE1lc3NhZ2VEaWdlc3Qoc2VsZi5oYXNoQWxnb3JpdGhtKTtcbiAgICBzZWxmLndhdGVyZmFsbChbXG4gICAgICBjYWxsYmFjayA9PiBzZWxmLmNyZWF0ZUhhc2hUb1JlbGF0ZWQoaWQsIGlzc3VlciwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGhhc2hUb1JlbGF0ZWQgPSByZXN1bHQ7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KSxcbiAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgLy8gNCkgQ3JlYXRlIGFuIGVtcHR5IHN0cmluZywgZGF0YSB0byBoYXNoLlxuICAgICAgICAvLyBOb3RlOiBXZSBjcmVhdGVkIGEgaGFzaCBvYmplY3QgYG1kYCBhYm92ZSBpbnN0ZWFkLlxuXG4gICAgICAgIC8vIDUpIEZvciBlYWNoIHJlbGF0ZWQgaGFzaCB0byBibGFuayBub2RlIGxpc3QgbWFwcGluZyBpbiBoYXNoIHRvXG4gICAgICAgIC8vIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwLCBzb3J0ZWQgbGV4aWNvZ3JhcGhpY2FsbHkgYnkgcmVsYXRlZCBoYXNoOlxuICAgICAgICBjb25zdCBoYXNoZXMgPSBPYmplY3Qua2V5cyhoYXNoVG9SZWxhdGVkKS5zb3J0KCk7XG4gICAgICAgIHNlbGYuZm9yRWFjaChoYXNoZXMsIChoYXNoLCBpZHgsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgLy8gNS4xKSBBcHBlbmQgdGhlIHJlbGF0ZWQgaGFzaCB0byB0aGUgZGF0YSB0byBoYXNoLlxuICAgICAgICAgIG1kLnVwZGF0ZShoYXNoKTtcblxuICAgICAgICAgIC8vIDUuMikgQ3JlYXRlIGEgc3RyaW5nIGNob3NlbiBwYXRoLlxuICAgICAgICAgIGxldCBjaG9zZW5QYXRoID0gJyc7XG5cbiAgICAgICAgICAvLyA1LjMpIENyZWF0ZSBhbiB1bnNldCBjaG9zZW4gaXNzdWVyIHZhcmlhYmxlLlxuICAgICAgICAgIGxldCBjaG9zZW5Jc3N1ZXI7XG5cbiAgICAgICAgICAvLyA1LjQpIEZvciBlYWNoIHBlcm11dGF0aW9uIG9mIGJsYW5rIG5vZGUgbGlzdDpcbiAgICAgICAgICBjb25zdCBwZXJtdXRhdG9yID0gbmV3IFBlcm11dGF0b3IoaGFzaFRvUmVsYXRlZFtoYXNoXSk7XG4gICAgICAgICAgc2VsZi53aGlsc3QoKCkgPT4gcGVybXV0YXRvci5oYXNOZXh0KCksIG5leHRQZXJtdXRhdGlvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwZXJtdXRhdGlvbiA9IHBlcm11dGF0b3IubmV4dCgpO1xuXG4gICAgICAgICAgICAvLyA1LjQuMSkgQ3JlYXRlIGEgY29weSBvZiBpc3N1ZXIsIGlzc3VlciBjb3B5LlxuICAgICAgICAgICAgbGV0IGlzc3VlckNvcHkgPSBpc3N1ZXIuY2xvbmUoKTtcblxuICAgICAgICAgICAgLy8gNS40LjIpIENyZWF0ZSBhIHN0cmluZyBwYXRoLlxuICAgICAgICAgICAgbGV0IHBhdGggPSAnJztcblxuICAgICAgICAgICAgLy8gNS40LjMpIENyZWF0ZSBhIHJlY3Vyc2lvbiBsaXN0LCB0byBzdG9yZSBibGFuayBub2RlIGlkZW50aWZpZXJzXG4gICAgICAgICAgICAvLyB0aGF0IG11c3QgYmUgcmVjdXJzaXZlbHkgcHJvY2Vzc2VkIGJ5IHRoaXMgYWxnb3JpdGhtLlxuICAgICAgICAgICAgY29uc3QgcmVjdXJzaW9uTGlzdCA9IFtdO1xuXG4gICAgICAgICAgICBzZWxmLndhdGVyZmFsbChbXG4gICAgICAgICAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgICAvLyA1LjQuNCkgRm9yIGVhY2ggcmVsYXRlZCBpbiBwZXJtdXRhdGlvbjpcbiAgICAgICAgICAgICAgICBzZWxmLmZvckVhY2gocGVybXV0YXRpb24sIChyZWxhdGVkLCBpZHgsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyA1LjQuNC4xKSBJZiBhIGNhbm9uaWNhbCBpZGVudGlmaWVyIGhhcyBiZWVuIGlzc3VlZCBmb3JcbiAgICAgICAgICAgICAgICAgIC8vIHJlbGF0ZWQsIGFwcGVuZCBpdCB0byBwYXRoLlxuICAgICAgICAgICAgICAgICAgaWYoc2VsZi5jYW5vbmljYWxJc3N1ZXIuaGFzSWQocmVsYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBzZWxmLmNhbm9uaWNhbElzc3Vlci5nZXRJZChyZWxhdGVkKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDUuNC40LjIpIE90aGVyd2lzZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gNS40LjQuMi4xKSBJZiBpc3N1ZXIgY29weSBoYXMgbm90IGlzc3VlZCBhbiBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciByZWxhdGVkLCBhcHBlbmQgcmVsYXRlZCB0byByZWN1cnNpb24gbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgaWYoIWlzc3VlckNvcHkuaGFzSWQocmVsYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZWN1cnNpb25MaXN0LnB1c2gocmVsYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gNS40LjQuMi4yKSBVc2UgdGhlIElzc3VlIElkZW50aWZpZXIgYWxnb3JpdGhtLCBwYXNzaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzc3VlciBjb3B5IGFuZCByZWxhdGVkIGFuZCBhcHBlbmQgdGhlIHJlc3VsdCB0byBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IGlzc3VlckNvcHkuZ2V0SWQocmVsYXRlZCk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vIDUuNC40LjMpIElmIGNob3NlbiBwYXRoIGlzIG5vdCBlbXB0eSBhbmQgdGhlIGxlbmd0aCBvZiBwYXRoXG4gICAgICAgICAgICAgICAgICAvLyBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiBjaG9zZW4gcGF0aCBhbmRcbiAgICAgICAgICAgICAgICAgIC8vIHBhdGggaXMgbGV4aWNvZ3JhcGhpY2FsbHkgZ3JlYXRlciB0aGFuIGNob3NlbiBwYXRoLCB0aGVuXG4gICAgICAgICAgICAgICAgICAvLyBza2lwIHRvIHRoZSBuZXh0IHBlcm11dGF0aW9uLlxuICAgICAgICAgICAgICAgICAgLy8gTm90ZTogQ29tcGFyaW5nIHBhdGggbGVuZ3RoIHRvIGNob3NlbiBwYXRoIGxlbmd0aCBjYW4gYmVcbiAgICAgICAgICAgICAgICAgIC8vIG9wdGltaXplZCBhd2F5OyBvbmx5IGNvbXBhcmUgbGV4aWNvZ3JhcGhpY2FsbHkuXG4gICAgICAgICAgICAgICAgICBpZihjaG9zZW5QYXRoLmxlbmd0aCAhPT0gMCAmJiBwYXRoID4gY2hvc2VuUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogbWF5IGNhdXNlIGluYWNjdXJhdGUgdG90YWwgZGVwdGggY2FsY3VsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRQZXJtdXRhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgICAvLyA1LjQuNSkgRm9yIGVhY2ggcmVsYXRlZCBpbiByZWN1cnNpb24gbGlzdDpcbiAgICAgICAgICAgICAgICBzZWxmLmZvckVhY2gocmVjdXJzaW9uTGlzdCwgKHJlbGF0ZWQsIGlkeCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgIC8vIDUuNC41LjEpIFNldCByZXN1bHQgdG8gdGhlIHJlc3VsdCBvZiByZWN1cnNpdmVseSBleGVjdXRpbmdcbiAgICAgICAgICAgICAgICAgIC8vIHRoZSBIYXNoIE4tRGVncmVlIFF1YWRzIGFsZ29yaXRobSwgcGFzc2luZyByZWxhdGVkIGZvclxuICAgICAgICAgICAgICAgICAgLy8gaWRlbnRpZmllciBhbmQgaXNzdWVyIGNvcHkgZm9yIHBhdGggaWRlbnRpZmllciBpc3N1ZXIuXG4gICAgICAgICAgICAgICAgICBzZWxmLmhhc2hORGVncmVlUXVhZHMocmVsYXRlZCwgaXNzdWVyQ29weSwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gNS40LjUuMikgVXNlIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBpc3N1ZXIgY29weSBhbmQgcmVsYXRlZCBhbmQgYXBwZW5kIHRoZSByZXN1bHQgdG8gcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBpc3N1ZXJDb3B5LmdldElkKHJlbGF0ZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIDUuNC41LjMpIEFwcGVuZCA8LCB0aGUgaGFzaCBpbiByZXN1bHQsIGFuZCA+IHRvIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gJzwnICsgcmVzdWx0Lmhhc2ggKyAnPic7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gNS40LjUuNCkgU2V0IGlzc3VlciBjb3B5IHRvIHRoZSBpZGVudGlmaWVyIGlzc3VlciBpblxuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIGlzc3VlckNvcHkgPSByZXN1bHQuaXNzdWVyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIDUuNC41LjUpIElmIGNob3NlbiBwYXRoIGlzIG5vdCBlbXB0eSBhbmQgdGhlIGxlbmd0aCBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBwYXRoIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mIGNob3NlblxuICAgICAgICAgICAgICAgICAgICAvLyBwYXRoIGFuZCBwYXRoIGlzIGxleGljb2dyYXBoaWNhbGx5IGdyZWF0ZXIgdGhhbiBjaG9zZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0aCwgdGhlbiBza2lwIHRvIHRoZSBuZXh0IHBlcm11dGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBDb21wYXJpbmcgcGF0aCBsZW5ndGggdG8gY2hvc2VuIHBhdGggbGVuZ3RoIGNhbiBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgYXdheTsgb25seSBjb21wYXJlIGxleGljb2dyYXBoaWNhbGx5LlxuICAgICAgICAgICAgICAgICAgICBpZihjaG9zZW5QYXRoLmxlbmd0aCAhPT0gMCAmJiBwYXRoID4gY2hvc2VuUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBtYXkgY2F1c2UgaW5hY2N1cmF0ZSB0b3RhbCBkZXB0aCBjYWxjdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0UGVybXV0YXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAgICAgLy8gNS40LjYpIElmIGNob3NlbiBwYXRoIGlzIGVtcHR5IG9yIHBhdGggaXMgbGV4aWNvZ3JhcGhpY2FsbHlcbiAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gY2hvc2VuIHBhdGgsIHNldCBjaG9zZW4gcGF0aCB0byBwYXRoIGFuZCBjaG9zZW5cbiAgICAgICAgICAgICAgICAvLyBpc3N1ZXIgdG8gaXNzdWVyIGNvcHkuXG4gICAgICAgICAgICAgICAgaWYoY2hvc2VuUGF0aC5sZW5ndGggPT09IDAgfHwgcGF0aCA8IGNob3NlblBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIGNob3NlblBhdGggPSBwYXRoO1xuICAgICAgICAgICAgICAgICAgY2hvc2VuSXNzdWVyID0gaXNzdWVyQ29weTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSwgbmV4dFBlcm11dGF0aW9uKTtcbiAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyA1LjUpIEFwcGVuZCBjaG9zZW4gcGF0aCB0byBkYXRhIHRvIGhhc2guXG4gICAgICAgICAgICBtZC51cGRhdGUoY2hvc2VuUGF0aCk7XG5cbiAgICAgICAgICAgIC8vIDUuNikgUmVwbGFjZSBpc3N1ZXIsIGJ5IHJlZmVyZW5jZSwgd2l0aCBjaG9zZW4gaXNzdWVyLlxuICAgICAgICAgICAgaXNzdWVyID0gY2hvc2VuSXNzdWVyO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIF0sIGVyciA9PiB7XG4gICAgICAvLyA2KSBSZXR1cm4gaXNzdWVyIGFuZCB0aGUgaGFzaCB0aGF0IHJlc3VsdHMgZnJvbSBwYXNzaW5nIGRhdGEgdG8gaGFzaFxuICAgICAgLy8gdGhyb3VnaCB0aGUgaGFzaCBhbGdvcml0aG0uXG4gICAgICBjYWxsYmFjayhlcnIsIHtoYXNoOiBtZC5kaWdlc3QoKSwgaXNzdWVyfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIG1vZGlmeWluZyBjb21wb25lbnQgZHVyaW5nIEhhc2ggRmlyc3QgRGVncmVlIFF1YWRzXG4gIG1vZGlmeUZpcnN0RGVncmVlQ29tcG9uZW50KGlkLCBjb21wb25lbnQpIHtcbiAgICBpZihjb21wb25lbnQudGVybVR5cGUgIT09ICdCbGFua05vZGUnKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cbiAgICBjb21wb25lbnQgPSB1dGlsLmNsb25lKGNvbXBvbmVudCk7XG4gICAgY29tcG9uZW50LnZhbHVlID0gKGNvbXBvbmVudC52YWx1ZSA9PT0gaWQgPyAnXzphJyA6ICdfOnonKTtcbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBnZXR0aW5nIGEgcmVsYXRlZCBwcmVkaWNhdGVcbiAgZ2V0UmVsYXRlZFByZWRpY2F0ZShxdWFkKSB7XG4gICAgcmV0dXJuICc8JyArIHF1YWQucHJlZGljYXRlLnZhbHVlICsgJz4nO1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjcmVhdGluZyBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwXG4gIGNyZWF0ZUhhc2hUb1JlbGF0ZWQoaWQsIGlzc3VlciwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIDEpIENyZWF0ZSBhIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXAgZm9yIHN0b3JpbmcgaGFzaGVzIHRoYXRcbiAgICAvLyBpZGVudGlmeSByZWxhdGVkIGJsYW5rIG5vZGVzLlxuICAgIGNvbnN0IGhhc2hUb1JlbGF0ZWQgPSB7fTtcblxuICAgIC8vIDIpIEdldCBhIHJlZmVyZW5jZSwgcXVhZHMsIHRvIHRoZSBsaXN0IG9mIHF1YWRzIGluIHRoZSBibGFuayBub2RlIHRvXG4gICAgLy8gcXVhZHMgbWFwIGZvciB0aGUga2V5IGlkZW50aWZpZXIuXG4gICAgY29uc3QgcXVhZHMgPSBzZWxmLmJsYW5rTm9kZUluZm9baWRdLnF1YWRzO1xuXG4gICAgLy8gMykgRm9yIGVhY2ggcXVhZCBpbiBxdWFkczpcbiAgICBzZWxmLmZvckVhY2gocXVhZHMsIChxdWFkLCBpZHgsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAvLyAzLjEpIEZvciBlYWNoIGNvbXBvbmVudCBpbiBxdWFkLCBpZiBjb21wb25lbnQgaXMgdGhlIHN1YmplY3QsIG9iamVjdCxcbiAgICAgIC8vIGFuZCBncmFwaCBuYW1lIGFuZCBpdCBpcyBhIGJsYW5rIG5vZGUgdGhhdCBpcyBub3QgaWRlbnRpZmllZCBieVxuICAgICAgLy8gaWRlbnRpZmllcjpcbiAgICAgIHNlbGYuZm9yRWFjaChxdWFkLCAoY29tcG9uZW50LCBrZXksIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGlmKGtleSA9PT0gJ3ByZWRpY2F0ZScgfHxcbiAgICAgICAgICAhKGNvbXBvbmVudC50ZXJtVHlwZSA9PT0gJ0JsYW5rTm9kZScgJiYgY29tcG9uZW50LnZhbHVlICE9PSBpZCkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuMSkgU2V0IGhhc2ggdG8gdGhlIHJlc3VsdCBvZiB0aGUgSGFzaCBSZWxhdGVkIEJsYW5rIE5vZGVcbiAgICAgICAgLy8gYWxnb3JpdGhtLCBwYXNzaW5nIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgZm9yIGNvbXBvbmVudCBhc1xuICAgICAgICAvLyByZWxhdGVkLCBxdWFkLCBwYXRoIGlkZW50aWZpZXIgaXNzdWVyIGFzIGlzc3VlciwgYW5kIHBvc2l0aW9uIGFzXG4gICAgICAgIC8vIGVpdGhlciBzLCBvLCBvciBnIGJhc2VkIG9uIHdoZXRoZXIgY29tcG9uZW50IGlzIGEgc3ViamVjdCwgb2JqZWN0LFxuICAgICAgICAvLyBncmFwaCBuYW1lLCByZXNwZWN0aXZlbHkuXG4gICAgICAgIGNvbnN0IHJlbGF0ZWQgPSBjb21wb25lbnQudmFsdWU7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gUE9TSVRJT05TW2tleV07XG4gICAgICAgIHNlbGYuaGFzaFJlbGF0ZWRCbGFua05vZGUoXG4gICAgICAgICAgcmVsYXRlZCwgcXVhZCwgaXNzdWVyLCBwb3NpdGlvbiwgKGVyciwgaGFzaCkgPT4ge1xuICAgICAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMy4xLjIpIEFkZCBhIG1hcHBpbmcgb2YgaGFzaCB0byB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGZvclxuICAgICAgICAgICAgLy8gY29tcG9uZW50IHRvIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXAsIGFkZGluZyBhbiBlbnRyeSBhc1xuICAgICAgICAgICAgLy8gbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYoaGFzaCBpbiBoYXNoVG9SZWxhdGVkKSB7XG4gICAgICAgICAgICAgIGhhc2hUb1JlbGF0ZWRbaGFzaF0ucHVzaChyZWxhdGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhhc2hUb1JlbGF0ZWRbaGFzaF0gPSBbcmVsYXRlZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH0sIGVyciA9PiBjYWxsYmFjayhlcnIsIGhhc2hUb1JlbGF0ZWQpKTtcbiAgfVxuXG4gIC8vIGhlbHBlciB0aGF0IGl0ZXJhdGVzIG92ZXIgcXVhZCBjb21wb25lbnRzIChza2lwcyBwcmVkaWNhdGUpXG4gIGZvckVhY2hDb21wb25lbnQocXVhZCwgb3ApIHtcbiAgICBmb3IoY29uc3Qga2V5IGluIHF1YWQpIHtcbiAgICAgIC8vIHNraXAgYHByZWRpY2F0ZWBcbiAgICAgIGlmKGtleSA9PT0gJ3ByZWRpY2F0ZScpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvcChxdWFkW2tleV0sIGtleSwgcXVhZCk7XG4gICAgfVxuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNiBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IElkZW50aWZpZXJJc3N1ZXIgPSByZXF1aXJlKCcuL0lkZW50aWZpZXJJc3N1ZXInKTtcbmNvbnN0IE1lc3NhZ2VEaWdlc3QgPSByZXF1aXJlKCcuL01lc3NhZ2VEaWdlc3QnKTtcbmNvbnN0IFBlcm11dGF0b3IgPSByZXF1aXJlKCcuL1Blcm11dGF0b3InKTtcbmNvbnN0IE5RdWFkcyA9IHJlcXVpcmUoJy4vTlF1YWRzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmNvbnN0IFBPU0lUSU9OUyA9IHtzdWJqZWN0OiAncycsIG9iamVjdDogJ28nLCBncmFwaDogJ2cnfTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVUkROQTIwMTVTeW5jIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uYW1lID0gJ1VSRE5BMjAxNSc7XG4gICAgdGhpcy5ibGFua05vZGVJbmZvID0ge307XG4gICAgdGhpcy5oYXNoVG9CbGFua05vZGVzID0ge307XG4gICAgdGhpcy5jYW5vbmljYWxJc3N1ZXIgPSBuZXcgSWRlbnRpZmllcklzc3VlcignXzpjMTRuJyk7XG4gICAgdGhpcy5oYXNoQWxnb3JpdGhtID0gJ3NoYTI1Nic7XG4gICAgdGhpcy5xdWFkcztcbiAgfVxuXG4gIC8vIDQuNCkgTm9ybWFsaXphdGlvbiBBbGdvcml0aG1cbiAgbWFpbihkYXRhc2V0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5xdWFkcyA9IGRhdGFzZXQ7XG5cbiAgICAvLyAxKSBDcmVhdGUgdGhlIG5vcm1hbGl6YXRpb24gc3RhdGUuXG5cbiAgICAvLyBOb3RlOiBPcHRpbWl6ZSBieSBnZW5lcmF0aW5nIG5vbi1ub3JtYWxpemVkIGJsYW5rIG5vZGUgbWFwIGNvbmN1cnJlbnRseS5cbiAgICBjb25zdCBub25Ob3JtYWxpemVkID0ge307XG5cbiAgICAvLyAyKSBGb3IgZXZlcnkgcXVhZCBpbiBpbnB1dCBkYXRhc2V0OlxuICAgIGZvcihjb25zdCBxdWFkIG9mIGRhdGFzZXQpIHtcbiAgICAgIC8vIDIuMSkgRm9yIGVhY2ggYmxhbmsgbm9kZSB0aGF0IG9jY3VycyBpbiB0aGUgcXVhZCwgYWRkIGEgcmVmZXJlbmNlXG4gICAgICAvLyB0byB0aGUgcXVhZCB1c2luZyB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGluIHRoZSBibGFuayBub2RlIHRvXG4gICAgICAvLyBxdWFkcyBtYXAsIGNyZWF0aW5nIGEgbmV3IGVudHJ5IGlmIG5lY2Vzc2FyeS5cbiAgICAgIHNlbGYuZm9yRWFjaENvbXBvbmVudChxdWFkLCBjb21wb25lbnQgPT4ge1xuICAgICAgICBpZihjb21wb25lbnQudGVybVR5cGUgIT09ICdCbGFua05vZGUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gY29tcG9uZW50LnZhbHVlO1xuICAgICAgICBpZihpZCBpbiBzZWxmLmJsYW5rTm9kZUluZm8pIHtcbiAgICAgICAgICBzZWxmLmJsYW5rTm9kZUluZm9baWRdLnF1YWRzLnB1c2gocXVhZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9uTm9ybWFsaXplZFtpZF0gPSB0cnVlO1xuICAgICAgICAgIHNlbGYuYmxhbmtOb2RlSW5mb1tpZF0gPSB7cXVhZHM6IFtxdWFkXX07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIDMpIENyZWF0ZSBhIGxpc3Qgb2Ygbm9uLW5vcm1hbGl6ZWQgYmxhbmsgbm9kZSBpZGVudGlmaWVyc1xuICAgIC8vIG5vbi1ub3JtYWxpemVkIGlkZW50aWZpZXJzIGFuZCBwb3B1bGF0ZSBpdCB1c2luZyB0aGUga2V5cyBmcm9tIHRoZVxuICAgIC8vIGJsYW5rIG5vZGUgdG8gcXVhZHMgbWFwLlxuICAgIC8vIE5vdGU6IFdlIHVzZSBhIG1hcCBoZXJlIGFuZCBpdCB3YXMgZ2VuZXJhdGVkIGR1cmluZyBzdGVwIDIuXG5cbiAgICAvLyA0KSBJbml0aWFsaXplIHNpbXBsZSwgYSBib29sZWFuIGZsYWcsIHRvIHRydWUuXG4gICAgbGV0IHNpbXBsZSA9IHRydWU7XG5cbiAgICAvLyA1KSBXaGlsZSBzaW1wbGUgaXMgdHJ1ZSwgaXNzdWUgY2Fub25pY2FsIGlkZW50aWZpZXJzIGZvciBibGFuayBub2RlczpcbiAgICB3aGlsZShzaW1wbGUpIHtcbiAgICAgIC8vIDUuMSkgU2V0IHNpbXBsZSB0byBmYWxzZS5cbiAgICAgIHNpbXBsZSA9IGZhbHNlO1xuXG4gICAgICAvLyA1LjIpIENsZWFyIGhhc2ggdG8gYmxhbmsgbm9kZXMgbWFwLlxuICAgICAgc2VsZi5oYXNoVG9CbGFua05vZGVzID0ge307XG5cbiAgICAgIC8vIDUuMykgRm9yIGVhY2ggYmxhbmsgbm9kZSBpZGVudGlmaWVyIGlkZW50aWZpZXIgaW4gbm9uLW5vcm1hbGl6ZWRcbiAgICAgIC8vIGlkZW50aWZpZXJzOlxuICAgICAgZm9yKGNvbnN0IGlkIGluIG5vbk5vcm1hbGl6ZWQpIHtcbiAgICAgICAgLy8gNS4zLjEpIENyZWF0ZSBhIGhhc2gsIGhhc2gsIGFjY29yZGluZyB0byB0aGUgSGFzaCBGaXJzdCBEZWdyZWVcbiAgICAgICAgLy8gUXVhZHMgYWxnb3JpdGhtLlxuICAgICAgICBjb25zdCBoYXNoID0gc2VsZi5oYXNoRmlyc3REZWdyZWVRdWFkcyhpZCk7XG5cbiAgICAgICAgLy8gNS4zLjIpIEFkZCBoYXNoIGFuZCBpZGVudGlmaWVyIHRvIGhhc2ggdG8gYmxhbmsgbm9kZXMgbWFwLFxuICAgICAgICAvLyBjcmVhdGluZyBhIG5ldyBlbnRyeSBpZiBuZWNlc3NhcnkuXG4gICAgICAgIGlmKGhhc2ggaW4gc2VsZi5oYXNoVG9CbGFua05vZGVzKSB7XG4gICAgICAgICAgc2VsZi5oYXNoVG9CbGFua05vZGVzW2hhc2hdLnB1c2goaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuaGFzaFRvQmxhbmtOb2Rlc1toYXNoXSA9IFtpZF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNS40KSBGb3IgZWFjaCBoYXNoIHRvIGlkZW50aWZpZXIgbGlzdCBtYXBwaW5nIGluIGhhc2ggdG8gYmxhbmtcbiAgICAgIC8vIG5vZGVzIG1hcCwgbGV4aWNvZ3JhcGhpY2FsbHktc29ydGVkIGJ5IGhhc2g6XG4gICAgICBjb25zdCBoYXNoZXMgPSBPYmplY3Qua2V5cyhzZWxmLmhhc2hUb0JsYW5rTm9kZXMpLnNvcnQoKTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBoYXNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLy8gNS40LjEpIElmIHRoZSBsZW5ndGggb2YgaWRlbnRpZmllciBsaXN0IGlzIGdyZWF0ZXIgdGhhbiAxLFxuICAgICAgICAvLyBjb250aW51ZSB0byB0aGUgbmV4dCBtYXBwaW5nLlxuICAgICAgICBjb25zdCBoYXNoID0gaGFzaGVzW2ldO1xuICAgICAgICBjb25zdCBpZExpc3QgPSBzZWxmLmhhc2hUb0JsYW5rTm9kZXNbaGFzaF07XG4gICAgICAgIGlmKGlkTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LjQuMikgVXNlIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZyBjYW5vbmljYWxcbiAgICAgICAgLy8gaXNzdWVyIGFuZCB0aGUgc2luZ2xlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpbiBpZGVudGlmaWVyXG4gICAgICAgIC8vIGxpc3QsIGlkZW50aWZpZXIsIHRvIGlzc3VlIGEgY2Fub25pY2FsIHJlcGxhY2VtZW50IGlkZW50aWZpZXJcbiAgICAgICAgLy8gZm9yIGlkZW50aWZpZXIuXG4gICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGNoYW5naW5nIGBnZXRJZGAgdG8gYGlzc3VlYFxuICAgICAgICBjb25zdCBpZCA9IGlkTGlzdFswXTtcbiAgICAgICAgc2VsZi5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQoaWQpO1xuXG4gICAgICAgIC8vIDUuNC4zKSBSZW1vdmUgaWRlbnRpZmllciBmcm9tIG5vbi1ub3JtYWxpemVkIGlkZW50aWZpZXJzLlxuICAgICAgICBkZWxldGUgbm9uTm9ybWFsaXplZFtpZF07XG5cbiAgICAgICAgLy8gNS40LjQpIFJlbW92ZSBoYXNoIGZyb20gdGhlIGhhc2ggdG8gYmxhbmsgbm9kZXMgbWFwLlxuICAgICAgICBkZWxldGUgc2VsZi5oYXNoVG9CbGFua05vZGVzW2hhc2hdO1xuXG4gICAgICAgIC8vIDUuNC41KSBTZXQgc2ltcGxlIHRvIHRydWUuXG4gICAgICAgIHNpbXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNikgRm9yIGVhY2ggaGFzaCB0byBpZGVudGlmaWVyIGxpc3QgbWFwcGluZyBpbiBoYXNoIHRvIGJsYW5rIG5vZGVzIG1hcCxcbiAgICAvLyBsZXhpY29ncmFwaGljYWxseS1zb3J0ZWQgYnkgaGFzaDpcbiAgICBjb25zdCBoYXNoZXMgPSBPYmplY3Qua2V5cyhzZWxmLmhhc2hUb0JsYW5rTm9kZXMpLnNvcnQoKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgaGFzaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyA2LjEpIENyZWF0ZSBoYXNoIHBhdGggbGlzdCB3aGVyZSBlYWNoIGl0ZW0gd2lsbCBiZSBhIHJlc3VsdCBvZlxuICAgICAgLy8gcnVubmluZyB0aGUgSGFzaCBOLURlZ3JlZSBRdWFkcyBhbGdvcml0aG0uXG4gICAgICBjb25zdCBoYXNoUGF0aExpc3QgPSBbXTtcblxuICAgICAgLy8gNi4yKSBGb3IgZWFjaCBibGFuayBub2RlIGlkZW50aWZpZXIgaWRlbnRpZmllciBpbiBpZGVudGlmaWVyIGxpc3Q6XG4gICAgICBjb25zdCBoYXNoID0gaGFzaGVzW2ldO1xuICAgICAgY29uc3QgaWRMaXN0ID0gc2VsZi5oYXNoVG9CbGFua05vZGVzW2hhc2hdO1xuICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGlkTGlzdC5sZW5ndGg7ICsraikge1xuICAgICAgICAvLyA2LjIuMSkgSWYgYSBjYW5vbmljYWwgaWRlbnRpZmllciBoYXMgYWxyZWFkeSBiZWVuIGlzc3VlZCBmb3JcbiAgICAgICAgLy8gaWRlbnRpZmllciwgY29udGludWUgdG8gdGhlIG5leHQgaWRlbnRpZmllci5cbiAgICAgICAgY29uc3QgaWQgPSBpZExpc3Rbal07XG4gICAgICAgIGlmKHNlbGYuY2Fub25pY2FsSXNzdWVyLmhhc0lkKGlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNi4yLjIpIENyZWF0ZSB0ZW1wb3JhcnkgaXNzdWVyLCBhbiBpZGVudGlmaWVyIGlzc3VlclxuICAgICAgICAvLyBpbml0aWFsaXplZCB3aXRoIHRoZSBwcmVmaXggXzpiLlxuICAgICAgICBjb25zdCBpc3N1ZXIgPSBuZXcgSWRlbnRpZmllcklzc3VlcignXzpiJyk7XG5cbiAgICAgICAgLy8gNi4yLjMpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmcgdGVtcG9yYXJ5XG4gICAgICAgIC8vIGlzc3VlciBhbmQgaWRlbnRpZmllciwgdG8gaXNzdWUgYSBuZXcgdGVtcG9yYXJ5IGJsYW5rIG5vZGVcbiAgICAgICAgLy8gaWRlbnRpZmllciBmb3IgaWRlbnRpZmllci5cbiAgICAgICAgaXNzdWVyLmdldElkKGlkKTtcblxuICAgICAgICAvLyA2LjIuNCkgUnVuIHRoZSBIYXNoIE4tRGVncmVlIFF1YWRzIGFsZ29yaXRobSwgcGFzc2luZ1xuICAgICAgICAvLyB0ZW1wb3JhcnkgaXNzdWVyLCBhbmQgYXBwZW5kIHRoZSByZXN1bHQgdG8gdGhlIGhhc2ggcGF0aCBsaXN0LlxuICAgICAgICBjb25zdCByZXN1bHQgPSBzZWxmLmhhc2hORGVncmVlUXVhZHMoaWQsIGlzc3Vlcik7XG4gICAgICAgIGhhc2hQYXRoTGlzdC5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDYuMykgRm9yIGVhY2ggcmVzdWx0IGluIHRoZSBoYXNoIHBhdGggbGlzdCxcbiAgICAgIC8vIGxleGljb2dyYXBoaWNhbGx5LXNvcnRlZCBieSB0aGUgaGFzaCBpbiByZXN1bHQ6XG4gICAgICAvLyBUT0RPOiB1c2UgYFN0cmluZy5sb2NhbGVDb21wYXJlYD9cbiAgICAgIGhhc2hQYXRoTGlzdC5zb3J0KChhLCBiKSA9PlxuICAgICAgICAoYS5oYXNoIDwgYi5oYXNoKSA/IC0xIDogKChhLmhhc2ggPiBiLmhhc2gpID8gMSA6IDApKTtcbiAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBoYXNoUGF0aExpc3QubGVuZ3RoOyArK2opIHtcbiAgICAgICAgLy8gNi4zLjEpIEZvciBlYWNoIGJsYW5rIG5vZGUgaWRlbnRpZmllciwgZXhpc3RpbmcgaWRlbnRpZmllcixcbiAgICAgICAgLy8gdGhhdCB3YXMgaXNzdWVkIGEgdGVtcG9yYXJ5IGlkZW50aWZpZXIgYnkgaWRlbnRpZmllciBpc3N1ZXJcbiAgICAgICAgLy8gaW4gcmVzdWx0LCBpc3N1ZSBhIGNhbm9uaWNhbCBpZGVudGlmaWVyLCBpbiB0aGUgc2FtZSBvcmRlcixcbiAgICAgICAgLy8gdXNpbmcgdGhlIElzc3VlIElkZW50aWZpZXIgYWxnb3JpdGhtLCBwYXNzaW5nIGNhbm9uaWNhbFxuICAgICAgICAvLyBpc3N1ZXIgYW5kIGV4aXN0aW5nIGlkZW50aWZpZXIuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhhc2hQYXRoTGlzdFtqXTtcbiAgICAgICAgZm9yKGNvbnN0IGV4aXN0aW5nIGluIHJlc3VsdC5pc3N1ZXIuZXhpc3RpbmcpIHtcbiAgICAgICAgICBzZWxmLmNhbm9uaWNhbElzc3Vlci5nZXRJZChleGlzdGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBOb3RlOiBBdCB0aGlzIHBvaW50IGFsbCBibGFuayBub2RlcyBpbiB0aGUgc2V0IG9mIFJERiBxdWFkcyBoYXZlIGJlZW5cbiAgICBhc3NpZ25lZCBjYW5vbmljYWwgaWRlbnRpZmllcnMsIHdoaWNoIGhhdmUgYmVlbiBzdG9yZWQgaW4gdGhlIGNhbm9uaWNhbFxuICAgIGlzc3Vlci4gSGVyZSBlYWNoIHF1YWQgaXMgdXBkYXRlZCBieSBhc3NpZ25pbmcgZWFjaCBvZiBpdHMgYmxhbmsgbm9kZXNcbiAgICBpdHMgbmV3IGlkZW50aWZpZXIuICovXG5cbiAgICAvLyA3KSBGb3IgZWFjaCBxdWFkLCBxdWFkLCBpbiBpbnB1dCBkYXRhc2V0OlxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2VsZi5xdWFkcy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gNy4xKSBDcmVhdGUgYSBjb3B5LCBxdWFkIGNvcHksIG9mIHF1YWQgYW5kIHJlcGxhY2UgYW55IGV4aXN0aW5nXG4gICAgICAvLyBibGFuayBub2RlIGlkZW50aWZpZXJzIHVzaW5nIHRoZSBjYW5vbmljYWwgaWRlbnRpZmllcnNcbiAgICAgIC8vIHByZXZpb3VzbHkgaXNzdWVkIGJ5IGNhbm9uaWNhbCBpc3N1ZXIuXG4gICAgICAvLyBOb3RlOiBXZSBvcHRpbWl6ZSBhd2F5IHRoZSBjb3B5IGhlcmUuXG4gICAgICBjb25zdCBxdWFkID0gc2VsZi5xdWFkc1tpXTtcbiAgICAgIHNlbGYuZm9yRWFjaENvbXBvbmVudChxdWFkLCBjb21wb25lbnQgPT4ge1xuICAgICAgICBpZihjb21wb25lbnQudGVybVR5cGUgPT09ICdCbGFua05vZGUnICYmXG4gICAgICAgICAgIWNvbXBvbmVudC52YWx1ZS5zdGFydHNXaXRoKHNlbGYuY2Fub25pY2FsSXNzdWVyLnByZWZpeCkpIHtcbiAgICAgICAgICBjb21wb25lbnQudmFsdWUgPSBzZWxmLmNhbm9uaWNhbElzc3Vlci5nZXRJZChjb21wb25lbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIDcuMikgQWRkIHF1YWQgY29weSB0byB0aGUgbm9ybWFsaXplZCBkYXRhc2V0LlxuICAgICAgbm9ybWFsaXplZC5wdXNoKE5RdWFkcy5zZXJpYWxpemVRdWFkKHF1YWQpKTtcbiAgICB9XG5cbiAgICAvLyBzb3J0IG5vcm1hbGl6ZWQgb3V0cHV0XG4gICAgbm9ybWFsaXplZC5zb3J0KCk7XG5cbiAgICAvLyA4KSBSZXR1cm4gdGhlIG5vcm1hbGl6ZWQgZGF0YXNldC5cbiAgICByZXR1cm4gbm9ybWFsaXplZC5qb2luKCcnKTtcbiAgfVxuXG4gIC8vIDQuNikgSGFzaCBGaXJzdCBEZWdyZWUgUXVhZHNcbiAgaGFzaEZpcnN0RGVncmVlUXVhZHMoaWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIHJldHVybiBjYWNoZWQgaGFzaFxuICAgIGNvbnN0IGluZm8gPSBzZWxmLmJsYW5rTm9kZUluZm9baWRdO1xuICAgIGlmKCdoYXNoJyBpbiBpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5oYXNoO1xuICAgIH1cblxuICAgIC8vIDEpIEluaXRpYWxpemUgbnF1YWRzIHRvIGFuIGVtcHR5IGxpc3QuIEl0IHdpbGwgYmUgdXNlZCB0byBzdG9yZSBxdWFkcyBpblxuICAgIC8vIE4tUXVhZHMgZm9ybWF0LlxuICAgIGNvbnN0IG5xdWFkcyA9IFtdO1xuXG4gICAgLy8gMikgR2V0IHRoZSBsaXN0IG9mIHF1YWRzIGBxdWFkc2AgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWZlcmVuY2UgYmxhbmsgbm9kZVxuICAgIC8vIGlkZW50aWZpZXIgaW4gdGhlIGJsYW5rIG5vZGUgdG8gcXVhZHMgbWFwLlxuICAgIGNvbnN0IHF1YWRzID0gaW5mby5xdWFkcztcblxuICAgIC8vIDMpIEZvciBlYWNoIHF1YWQgYHF1YWRgIGluIGBxdWFkc2A6XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHF1YWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBxdWFkID0gcXVhZHNbaV07XG5cbiAgICAgIC8vIDMuMSkgU2VyaWFsaXplIHRoZSBxdWFkIGluIE4tUXVhZHMgZm9ybWF0IHdpdGggdGhlIGZvbGxvd2luZyBzcGVjaWFsXG4gICAgICAvLyBydWxlOlxuXG4gICAgICAvLyAzLjEuMSkgSWYgYW55IGNvbXBvbmVudCBpbiBxdWFkIGlzIGFuIGJsYW5rIG5vZGUsIHRoZW4gc2VyaWFsaXplIGl0XG4gICAgICAvLyB1c2luZyBhIHNwZWNpYWwgaWRlbnRpZmllciBhcyBmb2xsb3dzOlxuICAgICAgY29uc3QgY29weSA9IHtwcmVkaWNhdGU6IHF1YWQucHJlZGljYXRlfTtcbiAgICAgIHNlbGYuZm9yRWFjaENvbXBvbmVudChxdWFkLCAoY29tcG9uZW50LCBrZXkpID0+IHtcbiAgICAgICAgLy8gMy4xLjIpIElmIHRoZSBibGFuayBub2RlJ3MgZXhpc3RpbmcgYmxhbmsgbm9kZSBpZGVudGlmaWVyIG1hdGNoZXNcbiAgICAgICAgLy8gdGhlIHJlZmVyZW5jZSBibGFuayBub2RlIGlkZW50aWZpZXIgdGhlbiB1c2UgdGhlIGJsYW5rIG5vZGVcbiAgICAgICAgLy8gaWRlbnRpZmllciBfOmEsIG90aGVyd2lzZSwgdXNlIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgXzp6LlxuICAgICAgICBjb3B5W2tleV0gPSBzZWxmLm1vZGlmeUZpcnN0RGVncmVlQ29tcG9uZW50KGlkLCBjb21wb25lbnQsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIG5xdWFkcy5wdXNoKE5RdWFkcy5zZXJpYWxpemVRdWFkKGNvcHkpKTtcbiAgICB9XG5cbiAgICAvLyA0KSBTb3J0IG5xdWFkcyBpbiBsZXhpY29ncmFwaGljYWwgb3JkZXIuXG4gICAgbnF1YWRzLnNvcnQoKTtcblxuICAgIC8vIDUpIFJldHVybiB0aGUgaGFzaCB0aGF0IHJlc3VsdHMgZnJvbSBwYXNzaW5nIHRoZSBzb3J0ZWQsIGpvaW5lZCBucXVhZHNcbiAgICAvLyB0aHJvdWdoIHRoZSBoYXNoIGFsZ29yaXRobS5cbiAgICBjb25zdCBtZCA9IG5ldyBNZXNzYWdlRGlnZXN0KHNlbGYuaGFzaEFsZ29yaXRobSk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IG5xdWFkcy5sZW5ndGg7ICsraSkge1xuICAgICAgbWQudXBkYXRlKG5xdWFkc1tpXSk7XG4gICAgfVxuICAgIC8vIFRPRE86IHJlcHJlc2VudCBhcyBieXRlIGJ1ZmZlciBpbnN0ZWFkIHRvIGN1dCBtZW1vcnkgdXNhZ2UgaW4gaGFsZlxuICAgIGluZm8uaGFzaCA9IG1kLmRpZ2VzdCgpO1xuICAgIHJldHVybiBpbmZvLmhhc2g7XG4gIH1cblxuICAvLyA0LjcpIEhhc2ggUmVsYXRlZCBCbGFuayBOb2RlXG4gIGhhc2hSZWxhdGVkQmxhbmtOb2RlKHJlbGF0ZWQsIHF1YWQsIGlzc3VlciwgcG9zaXRpb24pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIDEpIFNldCB0aGUgaWRlbnRpZmllciB0byB1c2UgZm9yIHJlbGF0ZWQsIHByZWZlcnJpbmcgZmlyc3QgdGhlIGNhbm9uaWNhbFxuICAgIC8vIGlkZW50aWZpZXIgZm9yIHJlbGF0ZWQgaWYgaXNzdWVkLCBzZWNvbmQgdGhlIGlkZW50aWZpZXIgaXNzdWVkIGJ5IGlzc3VlclxuICAgIC8vIGlmIGlzc3VlZCwgYW5kIGxhc3QsIGlmIG5lY2Vzc2FyeSwgdGhlIHJlc3VsdCBvZiB0aGUgSGFzaCBGaXJzdCBEZWdyZWVcbiAgICAvLyBRdWFkcyBhbGdvcml0aG0sIHBhc3NpbmcgcmVsYXRlZC5cbiAgICBsZXQgaWQ7XG4gICAgaWYoc2VsZi5jYW5vbmljYWxJc3N1ZXIuaGFzSWQocmVsYXRlZCkpIHtcbiAgICAgIGlkID0gc2VsZi5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQocmVsYXRlZCk7XG4gICAgfSBlbHNlIGlmKGlzc3Vlci5oYXNJZChyZWxhdGVkKSkge1xuICAgICAgaWQgPSBpc3N1ZXIuZ2V0SWQocmVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gc2VsZi5oYXNoRmlyc3REZWdyZWVRdWFkcyhyZWxhdGVkKTtcbiAgICB9XG5cbiAgICAvLyAyKSBJbml0aWFsaXplIGEgc3RyaW5nIGlucHV0IHRvIHRoZSB2YWx1ZSBvZiBwb3NpdGlvbi5cbiAgICAvLyBOb3RlOiBXZSB1c2UgYSBoYXNoIG9iamVjdCBpbnN0ZWFkLlxuICAgIGNvbnN0IG1kID0gbmV3IE1lc3NhZ2VEaWdlc3Qoc2VsZi5oYXNoQWxnb3JpdGhtKTtcbiAgICBtZC51cGRhdGUocG9zaXRpb24pO1xuXG4gICAgLy8gMykgSWYgcG9zaXRpb24gaXMgbm90IGcsIGFwcGVuZCA8LCB0aGUgdmFsdWUgb2YgdGhlIHByZWRpY2F0ZSBpbiBxdWFkLFxuICAgIC8vIGFuZCA+IHRvIGlucHV0LlxuICAgIGlmKHBvc2l0aW9uICE9PSAnZycpIHtcbiAgICAgIG1kLnVwZGF0ZShzZWxmLmdldFJlbGF0ZWRQcmVkaWNhdGUocXVhZCkpO1xuICAgIH1cblxuICAgIC8vIDQpIEFwcGVuZCBpZGVudGlmaWVyIHRvIGlucHV0LlxuICAgIG1kLnVwZGF0ZShpZCk7XG5cbiAgICAvLyA1KSBSZXR1cm4gdGhlIGhhc2ggdGhhdCByZXN1bHRzIGZyb20gcGFzc2luZyBpbnB1dCB0aHJvdWdoIHRoZSBoYXNoXG4gICAgLy8gYWxnb3JpdGhtLlxuICAgIC8vIFRPRE86IHJlcHJlc2VudCBhcyBieXRlIGJ1ZmZlciBpbnN0ZWFkIHRvIGN1dCBtZW1vcnkgdXNhZ2UgaW4gaGFsZlxuICAgIHJldHVybiBtZC5kaWdlc3QoKTtcbiAgfVxuXG4gIC8vIDQuOCkgSGFzaCBOLURlZ3JlZSBRdWFkc1xuICBoYXNoTkRlZ3JlZVF1YWRzKGlkLCBpc3N1ZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIDEpIENyZWF0ZSBhIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXAgZm9yIHN0b3JpbmcgaGFzaGVzIHRoYXRcbiAgICAvLyBpZGVudGlmeSByZWxhdGVkIGJsYW5rIG5vZGVzLlxuICAgIC8vIE5vdGU6IDIpIGFuZCAzKSBoYW5kbGVkIHdpdGhpbiBgY3JlYXRlSGFzaFRvUmVsYXRlZGBcbiAgICBjb25zdCBtZCA9IG5ldyBNZXNzYWdlRGlnZXN0KHNlbGYuaGFzaEFsZ29yaXRobSk7XG4gICAgY29uc3QgaGFzaFRvUmVsYXRlZCA9IHNlbGYuY3JlYXRlSGFzaFRvUmVsYXRlZChpZCwgaXNzdWVyKTtcblxuICAgIC8vIDQpIENyZWF0ZSBhbiBlbXB0eSBzdHJpbmcsIGRhdGEgdG8gaGFzaC5cbiAgICAvLyBOb3RlOiBXZSBjcmVhdGVkIGEgaGFzaCBvYmplY3QgYG1kYCBhYm92ZSBpbnN0ZWFkLlxuXG4gICAgLy8gNSkgRm9yIGVhY2ggcmVsYXRlZCBoYXNoIHRvIGJsYW5rIG5vZGUgbGlzdCBtYXBwaW5nIGluIGhhc2ggdG8gcmVsYXRlZFxuICAgIC8vIGJsYW5rIG5vZGVzIG1hcCwgc29ydGVkIGxleGljb2dyYXBoaWNhbGx5IGJ5IHJlbGF0ZWQgaGFzaDpcbiAgICBjb25zdCBoYXNoZXMgPSBPYmplY3Qua2V5cyhoYXNoVG9SZWxhdGVkKS5zb3J0KCk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGhhc2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gNS4xKSBBcHBlbmQgdGhlIHJlbGF0ZWQgaGFzaCB0byB0aGUgZGF0YSB0byBoYXNoLlxuICAgICAgY29uc3QgaGFzaCA9IGhhc2hlc1tpXTtcbiAgICAgIG1kLnVwZGF0ZShoYXNoKTtcblxuICAgICAgLy8gNS4yKSBDcmVhdGUgYSBzdHJpbmcgY2hvc2VuIHBhdGguXG4gICAgICBsZXQgY2hvc2VuUGF0aCA9ICcnO1xuXG4gICAgICAvLyA1LjMpIENyZWF0ZSBhbiB1bnNldCBjaG9zZW4gaXNzdWVyIHZhcmlhYmxlLlxuICAgICAgbGV0IGNob3Nlbklzc3VlcjtcblxuICAgICAgLy8gNS40KSBGb3IgZWFjaCBwZXJtdXRhdGlvbiBvZiBibGFuayBub2RlIGxpc3Q6XG4gICAgICBjb25zdCBwZXJtdXRhdG9yID0gbmV3IFBlcm11dGF0b3IoaGFzaFRvUmVsYXRlZFtoYXNoXSk7XG4gICAgICB3aGlsZShwZXJtdXRhdG9yLmhhc05leHQoKSkge1xuICAgICAgICBjb25zdCBwZXJtdXRhdGlvbiA9IHBlcm11dGF0b3IubmV4dCgpO1xuXG4gICAgICAgIC8vIDUuNC4xKSBDcmVhdGUgYSBjb3B5IG9mIGlzc3VlciwgaXNzdWVyIGNvcHkuXG4gICAgICAgIGxldCBpc3N1ZXJDb3B5ID0gaXNzdWVyLmNsb25lKCk7XG5cbiAgICAgICAgLy8gNS40LjIpIENyZWF0ZSBhIHN0cmluZyBwYXRoLlxuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuXG4gICAgICAgIC8vIDUuNC4zKSBDcmVhdGUgYSByZWN1cnNpb24gbGlzdCwgdG8gc3RvcmUgYmxhbmsgbm9kZSBpZGVudGlmaWVyc1xuICAgICAgICAvLyB0aGF0IG11c3QgYmUgcmVjdXJzaXZlbHkgcHJvY2Vzc2VkIGJ5IHRoaXMgYWxnb3JpdGhtLlxuICAgICAgICBjb25zdCByZWN1cnNpb25MaXN0ID0gW107XG5cbiAgICAgICAgLy8gNS40LjQpIEZvciBlYWNoIHJlbGF0ZWQgaW4gcGVybXV0YXRpb246XG4gICAgICAgIGxldCBuZXh0UGVybXV0YXRpb24gPSBmYWxzZTtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHBlcm11dGF0aW9uLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgLy8gNS40LjQuMSkgSWYgYSBjYW5vbmljYWwgaWRlbnRpZmllciBoYXMgYmVlbiBpc3N1ZWQgZm9yXG4gICAgICAgICAgLy8gcmVsYXRlZCwgYXBwZW5kIGl0IHRvIHBhdGguXG4gICAgICAgICAgY29uc3QgcmVsYXRlZCA9IHBlcm11dGF0aW9uW2pdO1xuICAgICAgICAgIGlmKHNlbGYuY2Fub25pY2FsSXNzdWVyLmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICAgICAgICBwYXRoICs9IHNlbGYuY2Fub25pY2FsSXNzdWVyLmdldElkKHJlbGF0ZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyA1LjQuNC4yKSBPdGhlcndpc2U6XG4gICAgICAgICAgICAvLyA1LjQuNC4yLjEpIElmIGlzc3VlciBjb3B5IGhhcyBub3QgaXNzdWVkIGFuIGlkZW50aWZpZXIgZm9yXG4gICAgICAgICAgICAvLyByZWxhdGVkLCBhcHBlbmQgcmVsYXRlZCB0byByZWN1cnNpb24gbGlzdC5cbiAgICAgICAgICAgIGlmKCFpc3N1ZXJDb3B5Lmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICAgICAgICAgIHJlY3Vyc2lvbkxpc3QucHVzaChyZWxhdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDUuNC40LjIuMikgVXNlIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZ1xuICAgICAgICAgICAgLy8gaXNzdWVyIGNvcHkgYW5kIHJlbGF0ZWQgYW5kIGFwcGVuZCB0aGUgcmVzdWx0IHRvIHBhdGguXG4gICAgICAgICAgICBwYXRoICs9IGlzc3VlckNvcHkuZ2V0SWQocmVsYXRlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNS40LjQuMykgSWYgY2hvc2VuIHBhdGggaXMgbm90IGVtcHR5IGFuZCB0aGUgbGVuZ3RoIG9mIHBhdGhcbiAgICAgICAgICAvLyBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiBjaG9zZW4gcGF0aCBhbmRcbiAgICAgICAgICAvLyBwYXRoIGlzIGxleGljb2dyYXBoaWNhbGx5IGdyZWF0ZXIgdGhhbiBjaG9zZW4gcGF0aCwgdGhlblxuICAgICAgICAgIC8vIHNraXAgdG8gdGhlIG5leHQgcGVybXV0YXRpb24uXG4gICAgICAgICAgLy8gTm90ZTogQ29tcGFyaW5nIHBhdGggbGVuZ3RoIHRvIGNob3NlbiBwYXRoIGxlbmd0aCBjYW4gYmUgb3B0aW1pemVkXG4gICAgICAgICAgLy8gYXdheTsgb25seSBjb21wYXJlIGxleGljb2dyYXBoaWNhbGx5LlxuICAgICAgICAgIGlmKGNob3NlblBhdGgubGVuZ3RoICE9PSAwICYmIHBhdGggPiBjaG9zZW5QYXRoKSB7XG4gICAgICAgICAgICBuZXh0UGVybXV0YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYobmV4dFBlcm11dGF0aW9uKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LjQuNSkgRm9yIGVhY2ggcmVsYXRlZCBpbiByZWN1cnNpb24gbGlzdDpcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHJlY3Vyc2lvbkxpc3QubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAvLyA1LjQuNS4xKSBTZXQgcmVzdWx0IHRvIHRoZSByZXN1bHQgb2YgcmVjdXJzaXZlbHkgZXhlY3V0aW5nXG4gICAgICAgICAgLy8gdGhlIEhhc2ggTi1EZWdyZWUgUXVhZHMgYWxnb3JpdGhtLCBwYXNzaW5nIHJlbGF0ZWQgZm9yXG4gICAgICAgICAgLy8gaWRlbnRpZmllciBhbmQgaXNzdWVyIGNvcHkgZm9yIHBhdGggaWRlbnRpZmllciBpc3N1ZXIuXG4gICAgICAgICAgY29uc3QgcmVsYXRlZCA9IHJlY3Vyc2lvbkxpc3Rbal07XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gc2VsZi5oYXNoTkRlZ3JlZVF1YWRzKHJlbGF0ZWQsIGlzc3VlckNvcHkpO1xuXG4gICAgICAgICAgLy8gNS40LjUuMikgVXNlIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZyBpc3N1ZXJcbiAgICAgICAgICAvLyBjb3B5IGFuZCByZWxhdGVkIGFuZCBhcHBlbmQgdGhlIHJlc3VsdCB0byBwYXRoLlxuICAgICAgICAgIHBhdGggKz0gaXNzdWVyQ29weS5nZXRJZChyZWxhdGVkKTtcblxuICAgICAgICAgIC8vIDUuNC41LjMpIEFwcGVuZCA8LCB0aGUgaGFzaCBpbiByZXN1bHQsIGFuZCA+IHRvIHBhdGguXG4gICAgICAgICAgcGF0aCArPSAnPCcgKyByZXN1bHQuaGFzaCArICc+JztcblxuICAgICAgICAgIC8vIDUuNC41LjQpIFNldCBpc3N1ZXIgY29weSB0byB0aGUgaWRlbnRpZmllciBpc3N1ZXIgaW5cbiAgICAgICAgICAvLyByZXN1bHQuXG4gICAgICAgICAgaXNzdWVyQ29weSA9IHJlc3VsdC5pc3N1ZXI7XG5cbiAgICAgICAgICAvLyA1LjQuNS41KSBJZiBjaG9zZW4gcGF0aCBpcyBub3QgZW1wdHkgYW5kIHRoZSBsZW5ndGggb2YgcGF0aFxuICAgICAgICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mIGNob3NlbiBwYXRoIGFuZFxuICAgICAgICAgIC8vIHBhdGggaXMgbGV4aWNvZ3JhcGhpY2FsbHkgZ3JlYXRlciB0aGFuIGNob3NlbiBwYXRoLCB0aGVuXG4gICAgICAgICAgLy8gc2tpcCB0byB0aGUgbmV4dCBwZXJtdXRhdGlvbi5cbiAgICAgICAgICAvLyBOb3RlOiBDb21wYXJpbmcgcGF0aCBsZW5ndGggdG8gY2hvc2VuIHBhdGggbGVuZ3RoIGNhbiBiZSBvcHRpbWl6ZWRcbiAgICAgICAgICAvLyBhd2F5OyBvbmx5IGNvbXBhcmUgbGV4aWNvZ3JhcGhpY2FsbHkuXG4gICAgICAgICAgaWYoY2hvc2VuUGF0aC5sZW5ndGggIT09IDAgJiYgcGF0aCA+IGNob3NlblBhdGgpIHtcbiAgICAgICAgICAgIG5leHRQZXJtdXRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihuZXh0UGVybXV0YXRpb24pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuNC42KSBJZiBjaG9zZW4gcGF0aCBpcyBlbXB0eSBvciBwYXRoIGlzIGxleGljb2dyYXBoaWNhbGx5XG4gICAgICAgIC8vIGxlc3MgdGhhbiBjaG9zZW4gcGF0aCwgc2V0IGNob3NlbiBwYXRoIHRvIHBhdGggYW5kIGNob3NlblxuICAgICAgICAvLyBpc3N1ZXIgdG8gaXNzdWVyIGNvcHkuXG4gICAgICAgIGlmKGNob3NlblBhdGgubGVuZ3RoID09PSAwIHx8IHBhdGggPCBjaG9zZW5QYXRoKSB7XG4gICAgICAgICAgY2hvc2VuUGF0aCA9IHBhdGg7XG4gICAgICAgICAgY2hvc2VuSXNzdWVyID0gaXNzdWVyQ29weTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA1LjUpIEFwcGVuZCBjaG9zZW4gcGF0aCB0byBkYXRhIHRvIGhhc2guXG4gICAgICBtZC51cGRhdGUoY2hvc2VuUGF0aCk7XG5cbiAgICAgIC8vIDUuNikgUmVwbGFjZSBpc3N1ZXIsIGJ5IHJlZmVyZW5jZSwgd2l0aCBjaG9zZW4gaXNzdWVyLlxuICAgICAgaXNzdWVyID0gY2hvc2VuSXNzdWVyO1xuICAgIH1cblxuICAgIC8vIDYpIFJldHVybiBpc3N1ZXIgYW5kIHRoZSBoYXNoIHRoYXQgcmVzdWx0cyBmcm9tIHBhc3NpbmcgZGF0YSB0byBoYXNoXG4gICAgLy8gdGhyb3VnaCB0aGUgaGFzaCBhbGdvcml0aG0uXG4gICAgcmV0dXJuIHtoYXNoOiBtZC5kaWdlc3QoKSwgaXNzdWVyfTtcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgbW9kaWZ5aW5nIGNvbXBvbmVudCBkdXJpbmcgSGFzaCBGaXJzdCBEZWdyZWUgUXVhZHNcbiAgbW9kaWZ5Rmlyc3REZWdyZWVDb21wb25lbnQoaWQsIGNvbXBvbmVudCkge1xuICAgIGlmKGNvbXBvbmVudC50ZXJtVHlwZSAhPT0gJ0JsYW5rTm9kZScpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuICAgIGNvbXBvbmVudCA9IHV0aWwuY2xvbmUoY29tcG9uZW50KTtcbiAgICBjb21wb25lbnQudmFsdWUgPSAoY29tcG9uZW50LnZhbHVlID09PSBpZCA/ICdfOmEnIDogJ186eicpO1xuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIGdldHRpbmcgYSByZWxhdGVkIHByZWRpY2F0ZVxuICBnZXRSZWxhdGVkUHJlZGljYXRlKHF1YWQpIHtcbiAgICByZXR1cm4gJzwnICsgcXVhZC5wcmVkaWNhdGUudmFsdWUgKyAnPic7XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIGNyZWF0aW5nIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXBcbiAgY3JlYXRlSGFzaFRvUmVsYXRlZChpZCwgaXNzdWVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyAxKSBDcmVhdGUgYSBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwIGZvciBzdG9yaW5nIGhhc2hlcyB0aGF0XG4gICAgLy8gaWRlbnRpZnkgcmVsYXRlZCBibGFuayBub2Rlcy5cbiAgICBjb25zdCBoYXNoVG9SZWxhdGVkID0ge307XG5cbiAgICAvLyAyKSBHZXQgYSByZWZlcmVuY2UsIHF1YWRzLCB0byB0aGUgbGlzdCBvZiBxdWFkcyBpbiB0aGUgYmxhbmsgbm9kZSB0b1xuICAgIC8vIHF1YWRzIG1hcCBmb3IgdGhlIGtleSBpZGVudGlmaWVyLlxuICAgIGNvbnN0IHF1YWRzID0gc2VsZi5ibGFua05vZGVJbmZvW2lkXS5xdWFkcztcblxuICAgIC8vIDMpIEZvciBlYWNoIHF1YWQgaW4gcXVhZHM6XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHF1YWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyAzLjEpIEZvciBlYWNoIGNvbXBvbmVudCBpbiBxdWFkLCBpZiBjb21wb25lbnQgaXMgdGhlIHN1YmplY3QsIG9iamVjdCxcbiAgICAgIC8vIGFuZCBncmFwaCBuYW1lIGFuZCBpdCBpcyBhIGJsYW5rIG5vZGUgdGhhdCBpcyBub3QgaWRlbnRpZmllZCBieVxuICAgICAgLy8gaWRlbnRpZmllcjpcbiAgICAgIGNvbnN0IHF1YWQgPSBxdWFkc1tpXTtcbiAgICAgIGZvcihjb25zdCBrZXkgaW4gcXVhZCkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBxdWFkW2tleV07XG4gICAgICAgIGlmKGtleSA9PT0gJ3ByZWRpY2F0ZScgfHxcbiAgICAgICAgICAhKGNvbXBvbmVudC50ZXJtVHlwZSA9PT0gJ0JsYW5rTm9kZScgJiYgY29tcG9uZW50LnZhbHVlICE9PSBpZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuMSkgU2V0IGhhc2ggdG8gdGhlIHJlc3VsdCBvZiB0aGUgSGFzaCBSZWxhdGVkIEJsYW5rIE5vZGVcbiAgICAgICAgLy8gYWxnb3JpdGhtLCBwYXNzaW5nIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgZm9yIGNvbXBvbmVudCBhc1xuICAgICAgICAvLyByZWxhdGVkLCBxdWFkLCBwYXRoIGlkZW50aWZpZXIgaXNzdWVyIGFzIGlzc3VlciwgYW5kIHBvc2l0aW9uIGFzXG4gICAgICAgIC8vIGVpdGhlciBzLCBvLCBvciBnIGJhc2VkIG9uIHdoZXRoZXIgY29tcG9uZW50IGlzIGEgc3ViamVjdCwgb2JqZWN0LFxuICAgICAgICAvLyBncmFwaCBuYW1lLCByZXNwZWN0aXZlbHkuXG4gICAgICAgIGNvbnN0IHJlbGF0ZWQgPSBjb21wb25lbnQudmFsdWU7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gUE9TSVRJT05TW2tleV07XG4gICAgICAgIGNvbnN0IGhhc2ggPSBzZWxmLmhhc2hSZWxhdGVkQmxhbmtOb2RlKHJlbGF0ZWQsIHF1YWQsIGlzc3VlciwgcG9zaXRpb24pO1xuXG4gICAgICAgIC8vIDMuMS4yKSBBZGQgYSBtYXBwaW5nIG9mIGhhc2ggdG8gdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBmb3JcbiAgICAgICAgLy8gY29tcG9uZW50IHRvIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXAsIGFkZGluZyBhbiBlbnRyeSBhc1xuICAgICAgICAvLyBuZWNlc3NhcnkuXG4gICAgICAgIGlmKGhhc2ggaW4gaGFzaFRvUmVsYXRlZCkge1xuICAgICAgICAgIGhhc2hUb1JlbGF0ZWRbaGFzaF0ucHVzaChyZWxhdGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNoVG9SZWxhdGVkW2hhc2hdID0gW3JlbGF0ZWRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2hUb1JlbGF0ZWQ7XG4gIH1cblxuICAvLyBoZWxwZXIgdGhhdCBpdGVyYXRlcyBvdmVyIHF1YWQgY29tcG9uZW50cyAoc2tpcHMgcHJlZGljYXRlKVxuICBmb3JFYWNoQ29tcG9uZW50KHF1YWQsIG9wKSB7XG4gICAgZm9yKGNvbnN0IGtleSBpbiBxdWFkKSB7XG4gICAgICAvLyBza2lwIGBwcmVkaWNhdGVgXG4gICAgICBpZihrZXkgPT09ICdwcmVkaWNhdGUnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb3AocXVhZFtrZXldLCBrZXksIHF1YWQpO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFVSRE5BMjAxNSA9IHJlcXVpcmUoJy4vVVJETkEyMDE1Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVVJETkEyMDEyIGV4dGVuZHMgVVJETkEyMDE1IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMubmFtZSA9ICdVUkdOQTIwMTInO1xuICAgIHRoaXMuaGFzaEFsZ29yaXRobSA9ICdzaGExJztcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgbW9kaWZ5aW5nIGNvbXBvbmVudCBkdXJpbmcgSGFzaCBGaXJzdCBEZWdyZWUgUXVhZHNcbiAgbW9kaWZ5Rmlyc3REZWdyZWVDb21wb25lbnQoaWQsIGNvbXBvbmVudCwga2V5KSB7XG4gICAgaWYoY29tcG9uZW50LnRlcm1UeXBlICE9PSAnQmxhbmtOb2RlJykge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG4gICAgY29tcG9uZW50ID0gdXRpbC5jbG9uZShjb21wb25lbnQpO1xuICAgIGlmKGtleSA9PT0gJ25hbWUnKSB7XG4gICAgICBjb21wb25lbnQudmFsdWUgPSAnXzpnJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gKGNvbXBvbmVudC52YWx1ZSA9PT0gaWQgPyAnXzphJyA6ICdfOnonKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgZ2V0dGluZyBhIHJlbGF0ZWQgcHJlZGljYXRlXG4gIGdldFJlbGF0ZWRQcmVkaWNhdGUocXVhZCkge1xuICAgIHJldHVybiBxdWFkLnByZWRpY2F0ZS52YWx1ZTtcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgY3JlYXRpbmcgaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcFxuICBjcmVhdGVIYXNoVG9SZWxhdGVkKGlkLCBpc3N1ZXIsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyAxKSBDcmVhdGUgYSBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwIGZvciBzdG9yaW5nIGhhc2hlcyB0aGF0XG4gICAgLy8gaWRlbnRpZnkgcmVsYXRlZCBibGFuayBub2Rlcy5cbiAgICBjb25zdCBoYXNoVG9SZWxhdGVkID0ge307XG5cbiAgICAvLyAyKSBHZXQgYSByZWZlcmVuY2UsIHF1YWRzLCB0byB0aGUgbGlzdCBvZiBxdWFkcyBpbiB0aGUgYmxhbmsgbm9kZSB0b1xuICAgIC8vIHF1YWRzIG1hcCBmb3IgdGhlIGtleSBpZGVudGlmaWVyLlxuICAgIGNvbnN0IHF1YWRzID0gc2VsZi5ibGFua05vZGVJbmZvW2lkXS5xdWFkcztcblxuICAgIC8vIDMpIEZvciBlYWNoIHF1YWQgaW4gcXVhZHM6XG4gICAgc2VsZi5mb3JFYWNoKHF1YWRzLCAocXVhZCwgaWR4LCBjYWxsYmFjaykgPT4ge1xuICAgICAgLy8gMy4xKSBJZiB0aGUgcXVhZCdzIHN1YmplY3QgaXMgYSBibGFuayBub2RlIHRoYXQgZG9lcyBub3QgbWF0Y2hcbiAgICAgIC8vIGlkZW50aWZpZXIsIHNldCBoYXNoIHRvIHRoZSByZXN1bHQgb2YgdGhlIEhhc2ggUmVsYXRlZCBCbGFuayBOb2RlXG4gICAgICAvLyBhbGdvcml0aG0sIHBhc3NpbmcgdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBmb3Igc3ViamVjdCBhcyByZWxhdGVkLFxuICAgICAgLy8gcXVhZCwgcGF0aCBpZGVudGlmaWVyIGlzc3VlciBhcyBpc3N1ZXIsIGFuZCBwIGFzIHBvc2l0aW9uLlxuICAgICAgbGV0IHBvc2l0aW9uO1xuICAgICAgbGV0IHJlbGF0ZWQ7XG4gICAgICBpZihxdWFkLnN1YmplY3QudGVybVR5cGUgPT09ICdCbGFua05vZGUnICYmIHF1YWQuc3ViamVjdC52YWx1ZSAhPT0gaWQpIHtcbiAgICAgICAgcmVsYXRlZCA9IHF1YWQuc3ViamVjdC52YWx1ZTtcbiAgICAgICAgcG9zaXRpb24gPSAncCc7XG4gICAgICB9IGVsc2UgaWYoXG4gICAgICAgIHF1YWQub2JqZWN0LnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJyAmJiBxdWFkLm9iamVjdC52YWx1ZSAhPT0gaWQpIHtcbiAgICAgICAgLy8gMy4yKSBPdGhlcndpc2UsIGlmIHF1YWQncyBvYmplY3QgaXMgYSBibGFuayBub2RlIHRoYXQgZG9lcyBub3QgbWF0Y2hcbiAgICAgICAgLy8gaWRlbnRpZmllciwgdG8gdGhlIHJlc3VsdCBvZiB0aGUgSGFzaCBSZWxhdGVkIEJsYW5rIE5vZGUgYWxnb3JpdGhtLFxuICAgICAgICAvLyBwYXNzaW5nIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgZm9yIG9iamVjdCBhcyByZWxhdGVkLCBxdWFkLCBwYXRoXG4gICAgICAgIC8vIGlkZW50aWZpZXIgaXNzdWVyIGFzIGlzc3VlciwgYW5kIHIgYXMgcG9zaXRpb24uXG4gICAgICAgIHJlbGF0ZWQgPSBxdWFkLm9iamVjdC52YWx1ZTtcbiAgICAgICAgcG9zaXRpb24gPSAncic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAzLjMpIE90aGVyd2lzZSwgY29udGludWUgdG8gdGhlIG5leHQgcXVhZC5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgICAvLyAzLjQpIEFkZCBhIG1hcHBpbmcgb2YgaGFzaCB0byB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGZvciB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCB0aGF0IG1hdGNoZWQgKHN1YmplY3Qgb3Igb2JqZWN0KSB0byBoYXNoIHRvIHJlbGF0ZWQgYmxhbmtcbiAgICAgIC8vIG5vZGVzIG1hcCwgYWRkaW5nIGFuIGVudHJ5IGFzIG5lY2Vzc2FyeS5cbiAgICAgIHNlbGYuaGFzaFJlbGF0ZWRCbGFua05vZGUoXG4gICAgICAgIHJlbGF0ZWQsIHF1YWQsIGlzc3VlciwgcG9zaXRpb24sIChlcnIsIGhhc2gpID0+IHtcbiAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoYXNoIGluIGhhc2hUb1JlbGF0ZWQpIHtcbiAgICAgICAgICAgIGhhc2hUb1JlbGF0ZWRbaGFzaF0ucHVzaChyZWxhdGVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzaFRvUmVsYXRlZFtoYXNoXSA9IFtyZWxhdGVkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IGNhbGxiYWNrKGVyciwgaGFzaFRvUmVsYXRlZCkpO1xuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNiBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFVSRE5BMjAxNVN5bmMgPSByZXF1aXJlKCcuL1VSRE5BMjAxNVN5bmMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVUkROQTIwMTJTeW5jIGV4dGVuZHMgVVJETkEyMDE1U3luYyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lID0gJ1VSR05BMjAxMic7XG4gICAgdGhpcy5oYXNoQWxnb3JpdGhtID0gJ3NoYTEnO1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBtb2RpZnlpbmcgY29tcG9uZW50IGR1cmluZyBIYXNoIEZpcnN0IERlZ3JlZSBRdWFkc1xuICBtb2RpZnlGaXJzdERlZ3JlZUNvbXBvbmVudChpZCwgY29tcG9uZW50LCBrZXkpIHtcbiAgICBpZihjb21wb25lbnQudGVybVR5cGUgIT09ICdCbGFua05vZGUnKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cbiAgICBjb21wb25lbnQgPSB1dGlsLmNsb25lKGNvbXBvbmVudCk7XG4gICAgaWYoa2V5ID09PSAnbmFtZScpIHtcbiAgICAgIGNvbXBvbmVudC52YWx1ZSA9ICdfOmcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnQudmFsdWUgPSAoY29tcG9uZW50LnZhbHVlID09PSBpZCA/ICdfOmEnIDogJ186eicpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBnZXR0aW5nIGEgcmVsYXRlZCBwcmVkaWNhdGVcbiAgZ2V0UmVsYXRlZFByZWRpY2F0ZShxdWFkKSB7XG4gICAgcmV0dXJuIHF1YWQucHJlZGljYXRlLnZhbHVlO1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjcmVhdGluZyBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwXG4gIGNyZWF0ZUhhc2hUb1JlbGF0ZWQoaWQsIGlzc3Vlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gMSkgQ3JlYXRlIGEgaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcCBmb3Igc3RvcmluZyBoYXNoZXMgdGhhdFxuICAgIC8vIGlkZW50aWZ5IHJlbGF0ZWQgYmxhbmsgbm9kZXMuXG4gICAgY29uc3QgaGFzaFRvUmVsYXRlZCA9IHt9O1xuXG4gICAgLy8gMikgR2V0IGEgcmVmZXJlbmNlLCBxdWFkcywgdG8gdGhlIGxpc3Qgb2YgcXVhZHMgaW4gdGhlIGJsYW5rIG5vZGUgdG9cbiAgICAvLyBxdWFkcyBtYXAgZm9yIHRoZSBrZXkgaWRlbnRpZmllci5cbiAgICBjb25zdCBxdWFkcyA9IHNlbGYuYmxhbmtOb2RlSW5mb1tpZF0ucXVhZHM7XG5cbiAgICAvLyAzKSBGb3IgZWFjaCBxdWFkIGluIHF1YWRzOlxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBxdWFkcy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gMy4xKSBJZiB0aGUgcXVhZCdzIHN1YmplY3QgaXMgYSBibGFuayBub2RlIHRoYXQgZG9lcyBub3QgbWF0Y2hcbiAgICAgIC8vIGlkZW50aWZpZXIsIHNldCBoYXNoIHRvIHRoZSByZXN1bHQgb2YgdGhlIEhhc2ggUmVsYXRlZCBCbGFuayBOb2RlXG4gICAgICAvLyBhbGdvcml0aG0sIHBhc3NpbmcgdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBmb3Igc3ViamVjdCBhcyByZWxhdGVkLFxuICAgICAgLy8gcXVhZCwgcGF0aCBpZGVudGlmaWVyIGlzc3VlciBhcyBpc3N1ZXIsIGFuZCBwIGFzIHBvc2l0aW9uLlxuICAgICAgY29uc3QgcXVhZCA9IHF1YWRzW2ldO1xuICAgICAgbGV0IHBvc2l0aW9uO1xuICAgICAgbGV0IHJlbGF0ZWQ7XG4gICAgICBpZihxdWFkLnN1YmplY3QudGVybVR5cGUgPT09ICdCbGFua05vZGUnICYmIHF1YWQuc3ViamVjdC52YWx1ZSAhPT0gaWQpIHtcbiAgICAgICAgcmVsYXRlZCA9IHF1YWQuc3ViamVjdC52YWx1ZTtcbiAgICAgICAgcG9zaXRpb24gPSAncCc7XG4gICAgICB9IGVsc2UgaWYoXG4gICAgICAgIHF1YWQub2JqZWN0LnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJyAmJiBxdWFkLm9iamVjdC52YWx1ZSAhPT0gaWQpIHtcbiAgICAgICAgLy8gMy4yKSBPdGhlcndpc2UsIGlmIHF1YWQncyBvYmplY3QgaXMgYSBibGFuayBub2RlIHRoYXQgZG9lcyBub3QgbWF0Y2hcbiAgICAgICAgLy8gaWRlbnRpZmllciwgdG8gdGhlIHJlc3VsdCBvZiB0aGUgSGFzaCBSZWxhdGVkIEJsYW5rIE5vZGUgYWxnb3JpdGhtLFxuICAgICAgICAvLyBwYXNzaW5nIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgZm9yIG9iamVjdCBhcyByZWxhdGVkLCBxdWFkLCBwYXRoXG4gICAgICAgIC8vIGlkZW50aWZpZXIgaXNzdWVyIGFzIGlzc3VlciwgYW5kIHIgYXMgcG9zaXRpb24uXG4gICAgICAgIHJlbGF0ZWQgPSBxdWFkLm9iamVjdC52YWx1ZTtcbiAgICAgICAgcG9zaXRpb24gPSAncic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAzLjMpIE90aGVyd2lzZSwgY29udGludWUgdG8gdGhlIG5leHQgcXVhZC5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyAzLjQpIEFkZCBhIG1hcHBpbmcgb2YgaGFzaCB0byB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGZvciB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCB0aGF0IG1hdGNoZWQgKHN1YmplY3Qgb3Igb2JqZWN0KSB0byBoYXNoIHRvIHJlbGF0ZWQgYmxhbmtcbiAgICAgIC8vIG5vZGVzIG1hcCwgYWRkaW5nIGFuIGVudHJ5IGFzIG5lY2Vzc2FyeS5cbiAgICAgIGNvbnN0IGhhc2ggPSBzZWxmLmhhc2hSZWxhdGVkQmxhbmtOb2RlKHJlbGF0ZWQsIHF1YWQsIGlzc3VlciwgcG9zaXRpb24pO1xuICAgICAgaWYoaGFzaCBpbiBoYXNoVG9SZWxhdGVkKSB7XG4gICAgICAgIGhhc2hUb1JlbGF0ZWRbaGFzaF0ucHVzaChyZWxhdGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc2hUb1JlbGF0ZWRbaGFzaF0gPSBbcmVsYXRlZF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2hUb1JlbGF0ZWQ7XG4gIH1cbn07XG4iLCIvKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBSREYgRGF0YXNldCBOb3JtYWxpemF0aW9uIHNwZWNpZmljYXRpb24uXG4gKiBUaGlzIGxpYnJhcnkgd29ya3MgaW4gdGhlIGJyb3dzZXIgYW5kIG5vZGUuanMuXG4gKlxuICogQlNEIDMtQ2xhdXNlIExpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBEaWdpdGFsIEJhemFhciwgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTXG4gKiBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEFcbiAqIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBVUkROQTIwMTUgPSByZXF1aXJlKCcuL1VSRE5BMjAxNScpO1xuY29uc3QgVVJHTkEyMDEyID0gcmVxdWlyZSgnLi9VUkdOQTIwMTInKTtcbmNvbnN0IFVSRE5BMjAxNVN5bmMgPSByZXF1aXJlKCcuL1VSRE5BMjAxNVN5bmMnKTtcbmNvbnN0IFVSR05BMjAxMlN5bmMgPSByZXF1aXJlKCcuL1VSR05BMjAxMlN5bmMnKTtcblxuLy8gb3B0aW9uYWwgbmF0aXZlIHN1cHBvcnRcbmxldCByZGZDYW5vbml6ZU5hdGl2ZTtcbnRyeSB7XG4gIHJkZkNhbm9uaXplTmF0aXZlID0gcmVxdWlyZSgncmRmLWNhbm9uaXplLW5hdGl2ZScpO1xufSBjYXRjaChlKSB7fVxuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vLyBleHBvc2UgaGVscGVyc1xuYXBpLk5RdWFkcyA9IHJlcXVpcmUoJy4vTlF1YWRzJyk7XG5hcGkuSWRlbnRpZmllcklzc3VlciA9IHJlcXVpcmUoJy4vSWRlbnRpZmllcklzc3VlcicpO1xuXG4vKipcbiAqIEdldCBvciBzZXQgbmF0aXZlIEFQSS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBuYXRpdmUgQVBJLlxuICpcbiAqIEByZXR1cm4gdGhlIGN1cnJlbnRseSBzZXQgbmF0aXZlIEFQSS5cbiAqL1xuYXBpLl9yZGZDYW5vbml6ZU5hdGl2ZSA9IGZ1bmN0aW9uKGFwaSkge1xuICBpZihhcGkpIHtcbiAgICByZGZDYW5vbml6ZU5hdGl2ZSA9IGFwaTtcbiAgfVxuICByZXR1cm4gcmRmQ2Fub25pemVOYXRpdmU7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGNhbm9uaXplcyBhbiBSREYgZGF0YXNldC5cbiAqXG4gKiBAcGFyYW0gZGF0YXNldCB0aGUgZGF0YXNldCB0byBjYW5vbml6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGFsZ29yaXRobSB0aGUgY2Fub25pY2FsaXphdGlvbiBhbGdvcml0aG0gdG8gdXNlLCBgVVJETkEyMDE1YCBvclxuICogICAgICAgICAgICBgVVJHTkEyMDEyYC5cbiAqICAgICAgICAgIFt1c2VOYXRpdmVdIHVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gKGRlZmF1bHQ6IGZhbHNlKS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBjYW5vbmljYWwpXSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjYW5vbmljYWxpemVkIFJERiBEYXRhc2V0LlxuICovXG5hcGkuY2Fub25pemUgPSB1dGlsLmNhbGxiYWNraWZ5KGFzeW5jIGZ1bmN0aW9uKGRhdGFzZXQsIG9wdGlvbnMpIHtcbiAgbGV0IGNhbGxiYWNrO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNhbGxiYWNrID0gKGVyciwgY2Fub25pY2FsKSA9PiB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICAvKmlmKG9wdGlvbnMuZm9ybWF0ID09PSAnYXBwbGljYXRpb24vbi1xdWFkcycpIHtcbiAgICAgICAgY2Fub25pY2FsID0gY2Fub25pY2FsLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgY2Fub25pY2FsID0gX3BhcnNlTlF1YWRzKGNhbm9uaWNhbC5qb2luKCcnKSk7Ki9cblxuICAgICAgcmVzb2x2ZShjYW5vbmljYWwpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIGJhY2stY29tcGF0IHdpdGggbGVnYWN5IGRhdGFzZXRcbiAgaWYoIUFycmF5LmlzQXJyYXkoZGF0YXNldCkpIHtcbiAgICBkYXRhc2V0ID0gYXBpLk5RdWFkcy5sZWdhY3lEYXRhc2V0VG9RdWFkcyhkYXRhc2V0KTtcbiAgfVxuXG4gIC8vIFRPRE86IGNvbnZlcnQgYWxnb3JpdGhtcyB0byBQcm9taXNlLWJhc2VkIGFzeW5jXG4gIGlmKG9wdGlvbnMudXNlTmF0aXZlKSB7XG4gICAgaWYocmRmQ2Fub25pemVOYXRpdmUpIHtcbiAgICAgIHJkZkNhbm9uaXplTmF0aXZlLmNhbm9uaXplKGRhdGFzZXQsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZGYtY2Fub25pemUtbmF0aXZlIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICdVUkROQTIwMTUnKSB7XG4gICAgICBuZXcgVVJETkEyMDE1KG9wdGlvbnMpLm1haW4oZGF0YXNldCwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZihvcHRpb25zLmFsZ29yaXRobSA9PT0gJ1VSR05BMjAxMicpIHtcbiAgICAgIG5ldyBVUkdOQTIwMTIob3B0aW9ucykubWFpbihkYXRhc2V0LCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmKCEoJ2FsZ29yaXRobScgaW4gb3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gUkRGIERhdGFzZXQgQ2Fub25pY2FsaXphdGlvbiBhbGdvcml0aG0gc3BlY2lmaWVkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIFJERiBEYXRhc2V0IENhbm9uaWNhbGl6YXRpb24gYWxnb3JpdGhtOiAnICsgb3B0aW9ucy5hbGdvcml0aG0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufSk7XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBjYW5vbml6ZXMgYW4gUkRGIGRhdGFzZXQuXG4gKlxuICogQHBhcmFtIGRhdGFzZXQgdGhlIGRhdGFzZXQgdG8gY2Fub25pemUuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGNhbm9uaWNhbGl6YXRpb24gYWxnb3JpdGhtIHRvIHVzZSwgYFVSRE5BMjAxNWAgb3JcbiAqICAgICAgICAgICAgYFVSR05BMjAxMmAuXG4gKiAgICAgICAgICBbdXNlTmF0aXZlXSB1c2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIChkZWZhdWx0OiBmYWxzZSkuXG4gKlxuICogQHJldHVybiB0aGUgUkRGIGRhdGFzZXQgaW4gY2Fub25pY2FsIGZvcm0uXG4gKi9cbmFwaS5jYW5vbml6ZVN5bmMgPSBmdW5jdGlvbihkYXRhc2V0LCBvcHRpb25zKSB7XG4gIC8vIGJhY2stY29tcGF0IHdpdGggbGVnYWN5IGRhdGFzZXRcbiAgaWYoIUFycmF5LmlzQXJyYXkoZGF0YXNldCkpIHtcbiAgICBkYXRhc2V0ID0gYXBpLk5RdWFkcy5sZWdhY3lEYXRhc2V0VG9RdWFkcyhkYXRhc2V0KTtcbiAgfVxuXG4gIGlmKG9wdGlvbnMudXNlTmF0aXZlKSB7XG4gICAgaWYocmRmQ2Fub25pemVOYXRpdmUpIHtcbiAgICAgIHJldHVybiByZGZDYW5vbml6ZU5hdGl2ZS5jYW5vbml6ZVN5bmMoZGF0YXNldCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigncmRmLWNhbm9uaXplLW5hdGl2ZSBub3QgYXZhaWxhYmxlJyk7XG4gIH1cbiAgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICdVUkROQTIwMTUnKSB7XG4gICAgcmV0dXJuIG5ldyBVUkROQTIwMTVTeW5jKG9wdGlvbnMpLm1haW4oZGF0YXNldCk7XG4gIH0gZWxzZSBpZihvcHRpb25zLmFsZ29yaXRobSA9PT0gJ1VSR05BMjAxMicpIHtcbiAgICByZXR1cm4gbmV3IFVSR05BMjAxMlN5bmMob3B0aW9ucykubWFpbihkYXRhc2V0KTtcbiAgfVxuICBpZighKCdhbGdvcml0aG0nIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBSREYgRGF0YXNldCBDYW5vbmljYWxpemF0aW9uIGFsZ29yaXRobSBzcGVjaWZpZWQuJyk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdJbnZhbGlkIFJERiBEYXRhc2V0IENhbm9uaWNhbGl6YXRpb24gYWxnb3JpdGhtOiAnICsgb3B0aW9ucy5hbGdvcml0aG0pO1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGRlZmluZSBzZXRJbW1lZGlhdGUgYW5kIG5leHRUaWNrXG4vLy8vIG5leHRUaWNrIGltcGxlbWVudGF0aW9uIHdpdGggYnJvd3Nlci1jb21wYXRpYmxlIGZhbGxiYWNrIC8vLy9cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Nhb2xhbi9hc3luYy9ibG9iL21hc3Rlci9saWIvYXN5bmMuanNcblxuLy8gY2FwdHVyZSB0aGUgZ2xvYmFsIHJlZmVyZW5jZSB0byBndWFyZCBhZ2FpbnN0IGZha2VUaW1lciBtb2Nrc1xuY29uc3QgX3NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgc2V0SW1tZWRpYXRlO1xuXG5jb25zdCBfZGVsYXkgPSBfc2V0SW1tZWRpYXRlID9cbiAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIChmb3IgSUUxMCBjb21wYXRpYmlsaXR5KVxuICBmbiA9PiBfc2V0SW1tZWRpYXRlKGZuKSA6XG4gIGZuID0+IHNldFRpbWVvdXQoZm4sIDApO1xuXG5pZih0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgYXBpLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbn0gZWxzZSB7XG4gIGFwaS5uZXh0VGljayA9IF9kZWxheTtcbn1cbmFwaS5zZXRJbW1lZGlhdGUgPSBfc2V0SW1tZWRpYXRlID8gX2RlbGF5IDogYXBpLm5leHRUaWNrO1xuXG4vKipcbiAqIENsb25lcyBhbiBvYmplY3QsIGFycmF5LCBvciBzdHJpbmcvbnVtYmVyLiBJZiBhIHR5cGVkIEphdmFTY3JpcHQgb2JqZWN0XG4gKiBpcyBnaXZlbiwgc3VjaCBhcyBhIERhdGUsIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gY2xvbmUuXG4gKlxuICogQHJldHVybiB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5hcGkuY2xvbmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZih2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgbGV0IHJ2YWw7XG4gICAgaWYoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJ2YWwgPSBbXTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBydmFsW2ldID0gYXBpLmNsb25lKHZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXBpLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcnZhbCA9IHt9O1xuICAgICAgZm9yKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBydmFsW2tleV0gPSBhcGkuY2xvbmUodmFsdWVba2V5XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIE9iamVjdCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNPYmplY3QgPSB2ID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc1VuZGVmaW5lZCA9IHYgPT4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnO1xuXG5hcGkuY2FsbGJhY2tpZnkgPSBmbiA9PiB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmdzLnBvcCgpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBfaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBfaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIG51bGwsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIF9pbnZva2VDYWxsYmFjayhjYWxsYmFjaywgZXJyLCByZXN1bHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICB9IGNhdGNoKHVuaGFuZGxlZEVycm9yKSB7XG4gICAgLy8gdGhyb3cgdW5oYW5kbGVkIGVycm9ycyB0byBwcmV2ZW50IFwidW5oYW5kbGVkIHJlamVjdGVkIHByb21pc2VcIlxuICAgIC8vIGFuZCBzaW11bGF0ZSB3aGF0IHdvdWxkIGhhdmUgaGFwcGVuZWQgaW4gYSBwcm9taXNlbGVzcyBBUElcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRocm93IHVuaGFuZGxlZEVycm9yO1xuICAgIH0pO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9CbGFua05vZGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9EYXRhRmFjdG9yeVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL0RlZmF1bHRHcmFwaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL0xpdGVyYWxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9OYW1lZE5vZGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9RdWFkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvVmFyaWFibGVcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJsYW5rTm9kZSA9IHZvaWQgMDtcbi8qKlxuICogQSB0ZXJtIHRoYXQgcmVwcmVzZW50cyBhbiBSREYgYmxhbmsgbm9kZSB3aXRoIGEgbGFiZWwuXG4gKi9cbmNsYXNzIEJsYW5rTm9kZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy50ZXJtVHlwZSA9ICdCbGFua05vZGUnO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gISFvdGhlciAmJiBvdGhlci50ZXJtVHlwZSA9PT0gJ0JsYW5rTm9kZScgJiYgb3RoZXIudmFsdWUgPT09IHRoaXMudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5CbGFua05vZGUgPSBCbGFua05vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbGFua05vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFGYWN0b3J5ID0gdm9pZCAwO1xuY29uc3QgQmxhbmtOb2RlXzEgPSByZXF1aXJlKFwiLi9CbGFua05vZGVcIik7XG5jb25zdCBEZWZhdWx0R3JhcGhfMSA9IHJlcXVpcmUoXCIuL0RlZmF1bHRHcmFwaFwiKTtcbmNvbnN0IExpdGVyYWxfMSA9IHJlcXVpcmUoXCIuL0xpdGVyYWxcIik7XG5jb25zdCBOYW1lZE5vZGVfMSA9IHJlcXVpcmUoXCIuL05hbWVkTm9kZVwiKTtcbmNvbnN0IFF1YWRfMSA9IHJlcXVpcmUoXCIuL1F1YWRcIik7XG5jb25zdCBWYXJpYWJsZV8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVcIik7XG5sZXQgZGF0YUZhY3RvcnlDb3VudGVyID0gMDtcbi8qKlxuICogQSBmYWN0b3J5IGZvciBpbnN0YW50aWF0aW5nIFJERiB0ZXJtcyBhbmQgcXVhZHMuXG4gKi9cbmNsYXNzIERhdGFGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmxhbmtOb2RlQ291bnRlciA9IDA7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmJsYW5rTm9kZVByZWZpeCA9IG9wdGlvbnMuYmxhbmtOb2RlUHJlZml4IHx8IGBkZl8ke2RhdGFGYWN0b3J5Q291bnRlcisrfV9gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIElSSSBmb3IgdGhlIG5hbWVkIG5vZGUuXG4gICAgICogQHJldHVybiBBIG5ldyBpbnN0YW5jZSBvZiBOYW1lZE5vZGUuXG4gICAgICogQHNlZSBOYW1lZE5vZGVcbiAgICAgKi9cbiAgICBuYW1lZE5vZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGVfMS5OYW1lZE5vZGUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG9wdGlvbmFsIGJsYW5rIG5vZGUgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJuIEEgbmV3IGluc3RhbmNlIG9mIEJsYW5rTm9kZS5cbiAgICAgKiAgICAgICAgIElmIHRoZSBgdmFsdWVgIHBhcmFtZXRlciBpcyB1bmRlZmluZWQgYSBuZXcgaWRlbnRpZmllclxuICAgICAqICAgICAgICAgZm9yIHRoZSBibGFuayBub2RlIGlzIGdlbmVyYXRlZCBmb3IgZWFjaCBjYWxsLlxuICAgICAqIEBzZWUgQmxhbmtOb2RlXG4gICAgICovXG4gICAgYmxhbmtOb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxhbmtOb2RlXzEuQmxhbmtOb2RlKHZhbHVlIHx8IGAke3RoaXMuYmxhbmtOb2RlUHJlZml4fSR7dGhpcy5ibGFua05vZGVDb3VudGVyKyt9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAgICAgICAgICAgICAgVGhlIGxpdGVyYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlT3JEYXRhdHlwZSBUaGUgb3B0aW9uYWwgbGFuZ3VhZ2Ugb3IgZGF0YXR5cGUuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBgbGFuZ3VhZ2VPckRhdGF0eXBlYCBpcyBhIE5hbWVkTm9kZSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gaXQgaXMgdXNlZCBmb3IgdGhlIHZhbHVlIG9mIGBOYW1lZE5vZGUuZGF0YXR5cGVgLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgT3RoZXJ3aXNlIGBsYW5ndWFnZU9yRGF0YXR5cGVgIGlzIHVzZWQgZm9yIHRoZSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgYE5hbWVkTm9kZS5sYW5ndWFnZWAuXG4gICAgICogQHJldHVybiBBIG5ldyBpbnN0YW5jZSBvZiBMaXRlcmFsLlxuICAgICAqIEBzZWUgTGl0ZXJhbFxuICAgICAqL1xuICAgIGxpdGVyYWwodmFsdWUsIGxhbmd1YWdlT3JEYXRhdHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxfMS5MaXRlcmFsKHZhbHVlLCBsYW5ndWFnZU9yRGF0YXR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhcmlhYmxlIG5hbWVcbiAgICAgKiBAcmV0dXJuIEEgbmV3IGluc3RhbmNlIG9mIFZhcmlhYmxlLlxuICAgICAqIEBzZWUgVmFyaWFibGVcbiAgICAgKi9cbiAgICB2YXJpYWJsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlXzEuVmFyaWFibGUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIERlZmF1bHRHcmFwaC5cbiAgICAgKi9cbiAgICBkZWZhdWx0R3JhcGgoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0R3JhcGhfMS5EZWZhdWx0R3JhcGguSU5TVEFOQ0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzdWJqZWN0ICAgVGhlIHF1YWQgc3ViamVjdCB0ZXJtLlxuICAgICAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHF1YWQgcHJlZGljYXRlIHRlcm0uXG4gICAgICogQHBhcmFtIG9iamVjdCAgICBUaGUgcXVhZCBvYmplY3QgdGVybS5cbiAgICAgKiBAcGFyYW0gZ3JhcGggICAgIFRoZSBxdWFkIGdyYXBoIHRlcm0uXG4gICAgICogQHJldHVybiBBIG5ldyBpbnN0YW5jZSBvZiBRdWFkLlxuICAgICAqIEBzZWUgUXVhZFxuICAgICAqL1xuICAgIHF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhZF8xLlF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoIHx8IHRoaXMuZGVmYXVsdEdyYXBoKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgdGhlIGdpdmVuIHRlcm0gdXNpbmcgdGhpcyBkYXRhIGZhY3RvcnkuXG4gICAgICogQHBhcmFtIG9yaWdpbmFsIEFuIFJERiB0ZXJtLlxuICAgICAqIEByZXR1cm4gQSBkZWVwIGNvcHkgb2YgdGhlIGdpdmVuIHRlcm0uXG4gICAgICovXG4gICAgZnJvbVRlcm0ob3JpZ2luYWwpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIG5hc3R5IGFueSBjYXN0cyB3aGVuIHRoaXMgVFMgYnVnIGhhcyBiZWVuIGZpeGVkOlxuICAgICAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNjkzM1xuICAgICAgICBzd2l0Y2ggKG9yaWdpbmFsLnRlcm1UeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdOYW1lZE5vZGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVkTm9kZShvcmlnaW5hbC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdCbGFua05vZGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJsYW5rTm9kZShvcmlnaW5hbC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWwubGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbChvcmlnaW5hbC52YWx1ZSwgb3JpZ2luYWwubGFuZ3VhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsLmRhdGF0eXBlLmVxdWFscyhMaXRlcmFsXzEuTGl0ZXJhbC5YU0RfU1RSSU5HKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsKG9yaWdpbmFsLnZhbHVlLCB0aGlzLmZyb21UZXJtKG9yaWdpbmFsLmRhdGF0eXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpdGVyYWwob3JpZ2luYWwudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnVmFyaWFibGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlKG9yaWdpbmFsLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0RlZmF1bHRHcmFwaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEdyYXBoKCk7XG4gICAgICAgICAgICBjYXNlICdRdWFkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWFkKHRoaXMuZnJvbVRlcm0ob3JpZ2luYWwuc3ViamVjdCksIHRoaXMuZnJvbVRlcm0ob3JpZ2luYWwucHJlZGljYXRlKSwgdGhpcy5mcm9tVGVybShvcmlnaW5hbC5vYmplY3QpLCB0aGlzLmZyb21UZXJtKG9yaWdpbmFsLmdyYXBoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiBxdWFkIHVzaW5nIHRoaXMgZGF0YSBmYWN0b3J5LlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbCBBbiBSREYgcXVhZC5cbiAgICAgKiBAcmV0dXJuIEEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiBxdWFkLlxuICAgICAqL1xuICAgIGZyb21RdWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21UZXJtKG9yaWdpbmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGludGVybmFsIGJsYW5rIG5vZGUgY291bnRlci5cbiAgICAgKi9cbiAgICByZXNldEJsYW5rTm9kZUNvdW50ZXIoKSB7XG4gICAgICAgIHRoaXMuYmxhbmtOb2RlQ291bnRlciA9IDA7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhRmFjdG9yeSA9IERhdGFGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YUZhY3RvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmF1bHRHcmFwaCA9IHZvaWQgMDtcbi8qKlxuICogQSBzaW5nbGV0b24gdGVybSBpbnN0YW5jZSB0aGF0IHJlcHJlc2VudHMgdGhlIGRlZmF1bHQgZ3JhcGguXG4gKiBJdCdzIG9ubHkgYWxsb3dlZCB0byBhc3NpZ24gYSBEZWZhdWx0R3JhcGggdG8gdGhlIC5ncmFwaCBwcm9wZXJ0eSBvZiBhIFF1YWQuXG4gKi9cbmNsYXNzIERlZmF1bHRHcmFwaCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGVybVR5cGUgPSAnRGVmYXVsdEdyYXBoJztcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yXG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gISFvdGhlciAmJiBvdGhlci50ZXJtVHlwZSA9PT0gJ0RlZmF1bHRHcmFwaCc7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0R3JhcGggPSBEZWZhdWx0R3JhcGg7XG5EZWZhdWx0R3JhcGguSU5TVEFOQ0UgPSBuZXcgRGVmYXVsdEdyYXBoKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWZhdWx0R3JhcGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpdGVyYWwgPSB2b2lkIDA7XG5jb25zdCBOYW1lZE5vZGVfMSA9IHJlcXVpcmUoXCIuL05hbWVkTm9kZVwiKTtcbi8qKlxuICogQSB0ZXJtIHRoYXQgcmVwcmVzZW50cyBhbiBSREYgbGl0ZXJhbCwgY29udGFpbmluZyBhIHN0cmluZyB3aXRoIGFuIG9wdGlvbmFsIGxhbmd1YWdlIHRhZyBvciBkYXRhdHlwZS5cbiAqL1xuY2xhc3MgTGl0ZXJhbCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIGxhbmd1YWdlT3JEYXRhdHlwZSkge1xuICAgICAgICB0aGlzLnRlcm1UeXBlID0gJ0xpdGVyYWwnO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2VPckRhdGF0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlT3JEYXRhdHlwZTtcbiAgICAgICAgICAgIHRoaXMuZGF0YXR5cGUgPSBMaXRlcmFsLlJERl9MQU5HVUFHRV9TVFJJTkc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2VPckRhdGF0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmxhbmd1YWdlID0gJyc7XG4gICAgICAgICAgICB0aGlzLmRhdGF0eXBlID0gbGFuZ3VhZ2VPckRhdGF0eXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYW5ndWFnZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5kYXRhdHlwZSA9IExpdGVyYWwuWFNEX1NUUklORztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICEhb3RoZXIgJiYgb3RoZXIudGVybVR5cGUgPT09ICdMaXRlcmFsJyAmJiBvdGhlci52YWx1ZSA9PT0gdGhpcy52YWx1ZSAmJlxuICAgICAgICAgICAgb3RoZXIubGFuZ3VhZ2UgPT09IHRoaXMubGFuZ3VhZ2UgJiYgb3RoZXIuZGF0YXR5cGUuZXF1YWxzKHRoaXMuZGF0YXR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGl0ZXJhbCA9IExpdGVyYWw7XG5MaXRlcmFsLlJERl9MQU5HVUFHRV9TVFJJTkcgPSBuZXcgTmFtZWROb2RlXzEuTmFtZWROb2RlKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjbGFuZ1N0cmluZycpO1xuTGl0ZXJhbC5YU0RfU1RSSU5HID0gbmV3IE5hbWVkTm9kZV8xLk5hbWVkTm9kZSgnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjc3RyaW5nJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaXRlcmFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYW1lZE5vZGUgPSB2b2lkIDA7XG4vKipcbiAqIEEgdGVybSB0aGF0IGNvbnRhaW5zIGFuIElSSS5cbiAqL1xuY2xhc3MgTmFtZWROb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRlcm1UeXBlID0gJ05hbWVkTm9kZSc7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAhIW90aGVyICYmIG90aGVyLnRlcm1UeXBlID09PSAnTmFtZWROb2RlJyAmJiBvdGhlci52YWx1ZSA9PT0gdGhpcy52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWVkTm9kZSA9IE5hbWVkTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5hbWVkTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVhZCA9IHZvaWQgMDtcbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgRGVmYXVsdEdyYXBoIHJlcHJlc2VudHMgdGhlIGRlZmF1bHQgZ3JhcGguXG4gKiBJdCdzIG9ubHkgYWxsb3dlZCB0byBhc3NpZ24gYSBEZWZhdWx0R3JhcGggdG8gdGhlIC5ncmFwaCBwcm9wZXJ0eSBvZiBhIFF1YWQuXG4gKi9cbmNsYXNzIFF1YWQge1xuICAgIGNvbnN0cnVjdG9yKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgICAgICB0aGlzLnRlcm1UeXBlID0gJ1F1YWQnO1xuICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgLy8gYHx8ICFvdGhlci50ZXJtVHlwZWAgaXMgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggb2xkIGZhY3RvcmllcyB3aXRob3V0IFJERiogc3VwcG9ydC5cbiAgICAgICAgcmV0dXJuICEhb3RoZXIgJiYgKG90aGVyLnRlcm1UeXBlID09PSAnUXVhZCcgfHwgIW90aGVyLnRlcm1UeXBlKSAmJlxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0LmVxdWFscyhvdGhlci5zdWJqZWN0KSAmJlxuICAgICAgICAgICAgdGhpcy5wcmVkaWNhdGUuZXF1YWxzKG90aGVyLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LmVxdWFscyhvdGhlci5vYmplY3QpICYmXG4gICAgICAgICAgICB0aGlzLmdyYXBoLmVxdWFscyhvdGhlci5ncmFwaCk7XG4gICAgfVxufVxuZXhwb3J0cy5RdWFkID0gUXVhZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1YWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlID0gdm9pZCAwO1xuLyoqXG4gKiBBIHRlcm0gdGhhdCByZXByZXNlbnRzIGEgdmFyaWFibGUuXG4gKi9cbmNsYXNzIFZhcmlhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRlcm1UeXBlID0gJ1ZhcmlhYmxlJztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICEhb3RoZXIgJiYgb3RoZXIudGVybVR5cGUgPT09ICdWYXJpYWJsZScgJiYgb3RoZXIudmFsdWUgPT09IHRoaXMudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZSA9IFZhcmlhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFyaWFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvSUFjdGl2ZVRhZ1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL0lIdG1sUGFyc2VMaXN0ZW5lclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL0lSZGZhUGF0dGVyblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL1JkZmFQYXJzZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9SZGZhUHJvZmlsZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL1V0aWxcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JQWN0aXZlVGFnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVJkZmFQYXR0ZXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZGZhUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgaHRtbHBhcnNlcjJfMSA9IHJlcXVpcmUoXCJodG1scGFyc2VyMlwiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IElOSVRJQUxfQ09OVEVYVF9YSFRNTCA9IHJlcXVpcmUoXCIuL2luaXRpYWwtY29udGV4dC14aHRtbC5qc29uXCIpO1xuY29uc3QgSU5JVElBTF9DT05URVhUID0gcmVxdWlyZShcIi4vaW5pdGlhbC1jb250ZXh0Lmpzb25cIik7XG5jb25zdCBSZGZhUHJvZmlsZV8xID0gcmVxdWlyZShcIi4vUmRmYVByb2ZpbGVcIik7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi9VdGlsXCIpO1xuLyoqXG4gKiBBIHN0cmVhbSB0cmFuc2Zvcm1lciB0aGF0IHBhcnNlcyBSREZhICh0ZXh0KSBzdHJlYW1zIHRvIGFuIHtAbGluayBSREYuU3RyZWFtfS5cbiAqL1xuY2xhc3MgUmRmYVBhcnNlciBleHRlbmRzIHN0cmVhbV8xLlRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcih7IHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVUYWdTdGFjayA9IFtdO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51dGlsID0gbmV3IFV0aWxfMS5VdGlsKG9wdGlvbnMuZGF0YUZhY3RvcnksIG9wdGlvbnMuYmFzZUlSSSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEdyYXBoID0gb3B0aW9ucy5kZWZhdWx0R3JhcGggfHwgdGhpcy51dGlsLmRhdGFGYWN0b3J5LmRlZmF1bHRHcmFwaCgpO1xuICAgICAgICBjb25zdCBwcm9maWxlID0gb3B0aW9ucy5jb250ZW50VHlwZSA/IFV0aWxfMS5VdGlsLmNvbnRlbnRUeXBlVG9Qcm9maWxlKG9wdGlvbnMuY29udGVudFR5cGUpIDogb3B0aW9ucy5wcm9maWxlIHx8ICcnO1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcyB8fCBSZGZhUHJvZmlsZV8xLlJERkFfRkVBVFVSRVNbcHJvZmlsZV07XG4gICAgICAgIHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIgPSBvcHRpb25zLmh0bWxQYXJzZUxpc3RlbmVyO1xuICAgICAgICB0aGlzLnJkZmFQYXR0ZXJucyA9IHRoaXMuZmVhdHVyZXMuY29weVJkZmFQYXR0ZXJucyA/IHt9IDogbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmRmYVBhdHRlcm5Db3BpZXMgPSB0aGlzLmZlYXR1cmVzLmNvcHlSZGZhUGF0dGVybnMgPyB7fSA6IG51bGw7XG4gICAgICAgIHRoaXMucGFyc2VyID0gdGhpcy5pbml0aWFsaXplUGFyc2VyKHByb2ZpbGUgPT09ICd4bWwnKTtcbiAgICAgICAgdGhpcy5hY3RpdmVUYWdTdGFjay5wdXNoKHtcbiAgICAgICAgICAgIGluY29tcGxldGVUcmlwbGVzOiBbXSxcbiAgICAgICAgICAgIGlubGlzdDogZmFsc2UsXG4gICAgICAgICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSxcbiAgICAgICAgICAgIGxpc3RNYXBwaW5nOiB7fSxcbiAgICAgICAgICAgIGxpc3RNYXBwaW5nTG9jYWw6IHt9LFxuICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICBwcmVmaXhlc0FsbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBJTklUSUFMX0NPTlRFWFRbJ0Bjb250ZXh0J10pLCB0aGlzLmZlYXR1cmVzLnhodG1sSW5pdGlhbENvbnRleHQgPyBJTklUSUFMX0NPTlRFWFRfWEhUTUxbJ0Bjb250ZXh0J10gOiB7fSksXG4gICAgICAgICAgICBwcmVmaXhlc0N1c3RvbToge30sXG4gICAgICAgICAgICBza2lwRWxlbWVudDogZmFsc2UsXG4gICAgICAgICAgICB2b2NhYjogb3B0aW9ucy52b2NhYixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gdGV4dCBzdHJlYW0gaW50byBhIHF1YWQgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7Tm9kZUpTLkV2ZW50RW1pdHRlcn0gc3RyZWFtIEEgdGV4dCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7UkRGLlN0cmVhbX0gQSBxdWFkIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbXBvcnQoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBzdHJlYW1fMS5QYXNzVGhyb3VnaCh7IHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIChlcnJvcikgPT4gcGFyc2VkLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgKGRhdGEpID0+IG91dHB1dC5wdXNoKGRhdGEpKTtcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiBvdXRwdXQucHVzaChudWxsKSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IG91dHB1dC5waXBlKG5ldyBSZGZhUGFyc2VyKHRoaXMub3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5wYXJzZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5wYXJzZXIuZW5kKCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIG9uVGFnT3BlbihuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8vIERldGVybWluZSB0aGUgcGFyZW50IHRhZyAoaWdub3JlIHNraXBwZWQgdGFncylcbiAgICAgICAgbGV0IHBhcmVudFRhZ0kgPSB0aGlzLmFjdGl2ZVRhZ1N0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChwYXJlbnRUYWdJID4gMCAmJiB0aGlzLmFjdGl2ZVRhZ1N0YWNrW3BhcmVudFRhZ0ldLnNraXBFbGVtZW50KSB7XG4gICAgICAgICAgICBwYXJlbnRUYWdJLS07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudFRhZyA9IHRoaXMuYWN0aXZlVGFnU3RhY2tbcGFyZW50VGFnSV07XG4gICAgICAgIC8vIElmIHdlIHNraXBwZWQgYSB0YWcsIG1ha2Ugc3VyZSB3ZSBETyB1c2UgdGhlIGxhbmcsIHByZWZpeGVzIGFuZCB2b2NhYiBvZiB0aGUgc2tpcHBlZCB0YWdcbiAgICAgICAgaWYgKHBhcmVudFRhZ0kgIT09IHRoaXMuYWN0aXZlVGFnU3RhY2subGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcGFyZW50VGFnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRUYWcpLCB7IGxhbmd1YWdlOiB0aGlzLmFjdGl2ZVRhZ1N0YWNrW3RoaXMuYWN0aXZlVGFnU3RhY2subGVuZ3RoIC0gMV0ubGFuZ3VhZ2UsIHByZWZpeGVzQWxsOiB0aGlzLmFjdGl2ZVRhZ1N0YWNrW3RoaXMuYWN0aXZlVGFnU3RhY2subGVuZ3RoIC0gMV0ucHJlZml4ZXNBbGwsIHByZWZpeGVzQ3VzdG9tOiB0aGlzLmFjdGl2ZVRhZ1N0YWNrW3RoaXMuYWN0aXZlVGFnU3RhY2subGVuZ3RoIC0gMV0ucHJlZml4ZXNDdXN0b20sIHZvY2FiOiB0aGlzLmFjdGl2ZVRhZ1N0YWNrW3RoaXMuYWN0aXZlVGFnU3RhY2subGVuZ3RoIC0gMV0udm9jYWIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGFjdGl2ZSB0YWcgYW5kIGluaGVyaXQgbGFuZ3VhZ2Ugc2NvcGUgYW5kIGJhc2VJUkkgZnJvbSBwYXJlbnRcbiAgICAgICAgY29uc3QgYWN0aXZlVGFnID0ge1xuICAgICAgICAgICAgY29sbGVjdENoaWxkVGFnczogcGFyZW50VGFnLmNvbGxlY3RDaGlsZFRhZ3MsXG4gICAgICAgICAgICBpbmNvbXBsZXRlVHJpcGxlczogW10sXG4gICAgICAgICAgICBpbmxpc3Q6ICdpbmxpc3QnIGluIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBsaXN0TWFwcGluZzogW10sXG4gICAgICAgICAgICBsaXN0TWFwcGluZ0xvY2FsOiBwYXJlbnRUYWcubGlzdE1hcHBpbmcsXG4gICAgICAgICAgICBsb2NhbEJhc2VJUkk6IHBhcmVudFRhZy5sb2NhbEJhc2VJUkksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcHJlZml4ZXNBbGw6IG51bGwsXG4gICAgICAgICAgICBwcmVmaXhlc0N1c3RvbTogbnVsbCxcbiAgICAgICAgICAgIHNraXBFbGVtZW50OiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3RpdmVUYWdTdGFjay5wdXNoKGFjdGl2ZVRhZyk7XG4gICAgICAgIC8vIFNhdmUgdGhlIHRhZyBjb250ZW50cyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGFjdGl2ZVRhZy5jb2xsZWN0Q2hpbGRUYWdzKSB7XG4gICAgICAgICAgICAvLyBBZGQgZXhwbGljaXRseSBkZWZpbmVkIHhtbG5zLCB4bWxuczoqIGFuZCBwcmVmaXhlcyB0byBhdHRyaWJ1dGVzLCBhcyByZXF1aXJlZCBieSB0aGUgc3BlYyAoU3RlcCAxMSwgbm90ZSlcbiAgICAgICAgICAgIC8vIFNvcnQgcHJlZml4ZXMgYWxwaGFiZXRpY2FsbHkgZm9yIGRldGVybWluaXN0aWMgbmFtZXNwYWNlIGRlY2xhcmF0aW9uIG9yZGVyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBPYmplY3Qua2V5cyhwYXJlbnRUYWcucHJlZml4ZXNDdXN0b20pLnNvcnQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHBhcmVudFRhZy5wcmVmaXhlc0N1c3RvbVtwcmVmaXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZUtleSA9IHByZWZpeCA9PT0gJycgPyAneG1sbnMnIDogJ3htbG5zOicgKyBwcmVmaXg7XG4gICAgICAgICAgICAgICAgaWYgKCEoYXR0cmlidXRlS2V5IGluIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlS2V5XSA9IHN1ZmZpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzU2VyaWFsaXplZCA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcCgoa2V5KSA9PiBgJHtrZXl9PVwiJHthdHRyaWJ1dGVzW2tleV19XCJgKS5qb2luKCcgJyk7XG4gICAgICAgICAgICBhY3RpdmVUYWcudGV4dCA9IFtgPCR7bmFtZX0ke2F0dHJpYnV0ZXNTZXJpYWxpemVkID8gJyAnICsgYXR0cmlidXRlc1NlcmlhbGl6ZWQgOiAnJ30+YF07XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlcy5za2lwSGFuZGxpbmdYbWxMaXRlcmFsQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsbG93VGVybXNJblJlbFByZWRpY2F0ZXMgPSB0cnVlO1xuICAgICAgICBsZXQgYWxsb3dUZXJtc0luUmV2UHJlZGljYXRlcyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzLm9ubHlBbGxvd1VyaVJlbFJldklmUHJvcGVydHkpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBpbGxlZ2FsIHJlbC9yZXYgdmFsdWVzIHdoZW4gcHJvcGVydHkgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKCdwcm9wZXJ0eScgaW4gYXR0cmlidXRlcyAmJiAncmVsJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dUZXJtc0luUmVsUHJlZGljYXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnJlbC5pbmRleE9mKCc6JykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3Byb3BlcnR5JyBpbiBhdHRyaWJ1dGVzICYmICdyZXYnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBhbGxvd1Rlcm1zSW5SZXZQcmVkaWNhdGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMucmV2LmluZGV4T2YoJzonKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMucmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcy5jb3B5UmRmYVBhdHRlcm5zKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSB0YWcgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAocGFyZW50VGFnLmNvbGxlY3RlZFBhdHRlcm5UYWcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuVGFnID0ge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByb290UGF0dGVybjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGFyZW50VGFnLmNvbGxlY3RlZFBhdHRlcm5UYWcuY2hpbGRyZW4ucHVzaChwYXR0ZXJuVGFnKTtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcuY29sbGVjdGVkUGF0dGVyblRhZyA9IHBhdHRlcm5UYWc7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgdGFncyB3aXRoIHR5cGUgcmRmYTpQYXR0ZXJuIGFzIHBhdHRlcm5zXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy50eXBlb2YgPT09ICdyZGZhOlBhdHRlcm4nKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFnLmNvbGxlY3RlZFBhdHRlcm5UYWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VGFnLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdFBhdHRlcm46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zdGFudGlhdGUgcGF0dGVybnMgb24gcmRmYTpjb3B5XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5wcm9wZXJ0eSA9PT0gJ3JkZmE6Y29weScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3B5VGFyZ2V0UGF0dGVybklkID0gYXR0cmlidXRlcy5yZXNvdXJjZSB8fCBhdHRyaWJ1dGVzLmhyZWYgfHwgYXR0cmlidXRlcy5zcmM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmRmYVBhdHRlcm5zW2NvcHlUYXJnZXRQYXR0ZXJuSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFBhdHRlcm5Db3B5KHBhcmVudFRhZywgdGhpcy5yZGZhUGF0dGVybnNbY29weVRhcmdldFBhdHRlcm5JZF0sIGNvcHlUYXJnZXRQYXR0ZXJuSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdSZGZhUGF0dGVybkNvcGllc1tjb3B5VGFyZ2V0UGF0dGVybklkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmRmYVBhdHRlcm5Db3BpZXNbY29weVRhcmdldFBhdHRlcm5JZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZGZhUGF0dGVybkNvcGllc1tjb3B5VGFyZ2V0UGF0dGVybklkXS5wdXNoKHBhcmVudFRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA8YmFzZT4gdGFncyBvdmVycmlkZSB0aGUgYmFzZUlSSSBvZiB0aGUgd2hvbGUgZG9jdW1lbnRcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXMuYmFzZVRhZyAmJiBuYW1lID09PSAnYmFzZScgJiYgYXR0cmlidXRlcy5ocmVmKSB7XG4gICAgICAgICAgICB0aGlzLnV0aWwuYmFzZUlSSSA9IHRoaXMudXRpbC5nZXRCYXNlSVJJKGF0dHJpYnV0ZXMuaHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgLy8geG1sOmJhc2UgYXR0cmlidXRlcyBvdmVycmlkZSB0aGUgYmFzZUlSSSBvZiB0aGUgY3VycmVudCB0YWcgYW5kIGNoaWxkcmVuXG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzLnhtbEJhc2UgJiYgYXR0cmlidXRlc1sneG1sOmJhc2UnXSkge1xuICAgICAgICAgICAgYWN0aXZlVGFnLmxvY2FsQmFzZUlSSSA9IHRoaXMudXRpbC5nZXRCYXNlSVJJKGF0dHJpYnV0ZXNbJ3htbDpiYXNlJ10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIDx0aW1lPiB0YWdzIHNldCBhbiBpbml0aWFsIGRhdGF0eXBlXG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzLnRpbWVUYWcgJiYgbmFtZSA9PT0gJ3RpbWUnICYmICFhdHRyaWJ1dGVzLmRhdGF0eXBlKSB7XG4gICAgICAgICAgICBhY3RpdmVUYWcuaW50ZXJwcmV0T2JqZWN0QXNUaW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9jZXNzaW5nIGJhc2VkIG9uIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9yZGZhLWNvcmUvI3NfcmRmYWluZGV0YWlsXG4gICAgICAgIC8vIDE6IGluaXRpYWxpemUgdmFsdWVzXG4gICAgICAgIGxldCBuZXdTdWJqZWN0O1xuICAgICAgICBsZXQgY3VycmVudE9iamVjdFJlc291cmNlO1xuICAgICAgICBsZXQgdHlwZWRSZXNvdXJjZTtcbiAgICAgICAgLy8gMjogaGFuZGxlIHZvY2FiIGF0dHJpYnV0ZSB0byBzZXQgYWN0aXZlIHZvY2FidWxhcnlcbiAgICAgICAgLy8gVm9jYWIgc2V0cyB0aGUgYWN0aXZlIHZvY2FidWxhcnlcbiAgICAgICAgaWYgKCd2b2NhYicgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMudm9jYWIpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcudm9jYWIgPSBhdHRyaWJ1dGVzLnZvY2FiO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZSh0aGlzLnV0aWwuZ2V0QmFzZUlyaVRlcm0oYWN0aXZlVGFnKSwgdGhpcy51dGlsLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShVdGlsXzEuVXRpbC5SREZBICsgJ3VzZXNWb2NhYnVsYXJ5JyksIHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoYWN0aXZlVGFnLnZvY2FiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB2b2NhYiBpcyBzZXQgdG8gJycsIHRoZW4gd2UgZmFsbGJhY2sgdG8gdGhlIHJvb3Qgdm9jYWIgYXMgZGVmaW5lZCB2aWEgdGhlIHBhcnNlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy52b2NhYiA9IHRoaXMuYWN0aXZlVGFnU3RhY2tbMF0udm9jYWI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVUYWcudm9jYWIgPSBwYXJlbnRUYWcudm9jYWI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMzogaGFuZGxlIHByZWZpeGVzXG4gICAgICAgIGFjdGl2ZVRhZy5wcmVmaXhlc0N1c3RvbSA9IFV0aWxfMS5VdGlsLnBhcnNlUHJlZml4ZXMoYXR0cmlidXRlcywgcGFyZW50VGFnLnByZWZpeGVzQ3VzdG9tLCB0aGlzLmZlYXR1cmVzLnhtbG5zUHJlZml4TWFwcGluZ3MpO1xuICAgICAgICBhY3RpdmVUYWcucHJlZml4ZXNBbGwgPSBPYmplY3Qua2V5cyhhY3RpdmVUYWcucHJlZml4ZXNDdXN0b20pLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRUYWcucHJlZml4ZXNBbGwpLCBhY3RpdmVUYWcucHJlZml4ZXNDdXN0b20pIDogcGFyZW50VGFnLnByZWZpeGVzQWxsO1xuICAgICAgICAvLyBIYW5kbGUgcm9sZSBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXMucm9sZUF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGVzLnJvbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvbGVTdWJqZWN0ID0gYXR0cmlidXRlcy5pZFxuICAgICAgICAgICAgICAgID8gdGhpcy51dGlsLmNyZWF0ZUlyaSgnIycgKyBhdHRyaWJ1dGVzLmlkLCBhY3RpdmVUYWcsIGZhbHNlLCBmYWxzZSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgOiB0aGlzLnV0aWwuY3JlYXRlQmxhbmtOb2RlKCk7XG4gICAgICAgICAgICAvLyBUZW1wb3JhcmlseSBvdmVycmlkZSB2b2NhYlxuICAgICAgICAgICAgY29uc3Qgdm9jYWJPbGQgPSBhY3RpdmVUYWcudm9jYWI7XG4gICAgICAgICAgICBhY3RpdmVUYWcudm9jYWIgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiMnO1xuICAgICAgICAgICAgZm9yIChjb25zdCByb2xlIG9mIHRoaXMudXRpbC5jcmVhdGVWb2NhYklyaXMoYXR0cmlidXRlcy5yb2xlLCBhY3RpdmVUYWcsIHRydWUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShyb2xlU3ViamVjdCwgdGhpcy51dGlsLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZSgnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNyb2xlJyksIHJvbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlVGFnLnZvY2FiID0gdm9jYWJPbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNDogaGFuZGxlIGxhbmd1YWdlXG4gICAgICAgIC8vIFNhdmUgbGFuZ3VhZ2UgYXR0cmlidXRlIHZhbHVlIGluIGFjdGl2ZSB0YWdcbiAgICAgICAgaWYgKCd4bWw6bGFuZycgaW4gYXR0cmlidXRlcyB8fCAodGhpcy5mZWF0dXJlcy5sYW5nQXR0cmlidXRlICYmICdsYW5nJyBpbiBhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgYWN0aXZlVGFnLmxhbmd1YWdlID0gYXR0cmlidXRlc1sneG1sOmxhbmcnXSB8fCBhdHRyaWJ1dGVzLmxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVUYWcubGFuZ3VhZ2UgPSBwYXJlbnRUYWcubGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNSb290VGFnID0gdGhpcy5hY3RpdmVUYWdTdGFjay5sZW5ndGggPT09IDI7XG4gICAgICAgIGlmICghKCdyZWwnIGluIGF0dHJpYnV0ZXMpICYmICEoJ3JldicgaW4gYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgIC8vIDU6IERldGVybWluZSB0aGUgbmV3IHN1YmplY3Qgd2hlbiByZWwgYW5kIHJldiBhcmUgbm90IHByZXNlbnRcbiAgICAgICAgICAgIGlmICgncHJvcGVydHknIGluIGF0dHJpYnV0ZXMgJiYgISgnY29udGVudCcgaW4gYXR0cmlidXRlcykgJiYgISgnZGF0YXR5cGUnIGluIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gNS4xOiBwcm9wZXJ0eSBpcyBwcmVzZW50LCBidXQgbm90IGNvbnRlbnQgYW5kIGRhdGF0eXBlXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIG5ldyBzdWJqZWN0XG4gICAgICAgICAgICAgICAgaWYgKCdhYm91dCcgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWJqZWN0ID0gdGhpcy51dGlsLmNyZWF0ZUlyaShhdHRyaWJ1dGVzLmFib3V0LCBhY3RpdmVUYWcsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFnLmV4cGxpY2l0TmV3U3ViamVjdCA9ICEhbmV3U3ViamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSb290VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRUYWcub2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3QgPSBwYXJlbnRUYWcub2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHlwZVxuICAgICAgICAgICAgICAgIGlmICgndHlwZW9mJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnYWJvdXQnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlSXJpKGF0dHJpYnV0ZXMuYWJvdXQsIGFjdGl2ZVRhZywgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZWRSZXNvdXJjZSAmJiBpc1Jvb3RUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzb3VyY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZWRSZXNvdXJjZSAmJiAncmVzb3VyY2UnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlSXJpKGF0dHJpYnV0ZXMucmVzb3VyY2UsIGFjdGl2ZVRhZywgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZWRSZXNvdXJjZSAmJiAoJ2hyZWYnIGluIGF0dHJpYnV0ZXMgfHwgJ3NyYycgaW4gYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlSXJpKGF0dHJpYnV0ZXMuaHJlZiB8fCBhdHRyaWJ1dGVzLnNyYywgYWN0aXZlVGFnLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZWRSZXNvdXJjZSAmJiB0aGlzLmlzSW5oZXJpdFN1YmplY3RJbkhlYWRCb2R5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc291cmNlID0gbmV3U3ViamVjdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVkUmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlQmxhbmtOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9iamVjdFJlc291cmNlID0gdHlwZWRSZXNvdXJjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyA1LjJcbiAgICAgICAgICAgICAgICBpZiAoJ2Fib3V0JyBpbiBhdHRyaWJ1dGVzIHx8ICdyZXNvdXJjZScgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWJqZWN0ID0gdGhpcy51dGlsLmNyZWF0ZUlyaShhdHRyaWJ1dGVzLmFib3V0IHx8IGF0dHJpYnV0ZXMucmVzb3VyY2UsIGFjdGl2ZVRhZywgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWcuZXhwbGljaXROZXdTdWJqZWN0ID0gISFuZXdTdWJqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5ld1N1YmplY3QgJiYgKCdocmVmJyBpbiBhdHRyaWJ1dGVzIHx8ICdzcmMnIGluIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3QgPSB0aGlzLnV0aWwuY3JlYXRlSXJpKGF0dHJpYnV0ZXMuaHJlZiB8fCBhdHRyaWJ1dGVzLnNyYywgYWN0aXZlVGFnLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWcuZXhwbGljaXROZXdTdWJqZWN0ID0gISFuZXdTdWJqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5ld1N1YmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUm9vdFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3ViamVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0luaGVyaXRTdWJqZWN0SW5IZWFkQm9keShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3ViamVjdCA9IHBhcmVudFRhZy5vYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJ3R5cGVvZicgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3ViamVjdCA9IHRoaXMudXRpbC5jcmVhdGVCbGFua05vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy5leHBsaWNpdE5ld1N1YmplY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudFRhZy5vYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3QgPSBwYXJlbnRUYWcub2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ3Byb3BlcnR5JyBpbiBhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy5za2lwRWxlbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoJ3R5cGVvZicgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc291cmNlID0gbmV3U3ViamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGVpdGhlciByZWwgb3IgcmV2IGlzIHByZXNlbnRcbiAgICAgICAgICAgIC8vIDY6IERldGVybWluZSB0aGUgbmV3IHN1YmplY3Qgd2hlbiByZWwgb3IgcmV2IGFyZSBwcmVzZW50XG4gICAgICAgICAgICAvLyBEZWZpbmUgbmV3IHN1YmplY3RcbiAgICAgICAgICAgIGlmICgnYWJvdXQnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBuZXdTdWJqZWN0ID0gdGhpcy51dGlsLmNyZWF0ZUlyaShhdHRyaWJ1dGVzLmFib3V0LCBhY3RpdmVUYWcsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcuZXhwbGljaXROZXdTdWJqZWN0ID0gISFuZXdTdWJqZWN0O1xuICAgICAgICAgICAgICAgIGlmICgndHlwZW9mJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzb3VyY2UgPSBuZXdTdWJqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUm9vdFRhZykge1xuICAgICAgICAgICAgICAgIG5ld1N1YmplY3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50VGFnLm9iamVjdCkge1xuICAgICAgICAgICAgICAgIG5ld1N1YmplY3QgPSBwYXJlbnRUYWcub2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVmaW5lIG9iamVjdFxuICAgICAgICAgICAgaWYgKCdyZXNvdXJjZScgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRPYmplY3RSZXNvdXJjZSA9IHRoaXMudXRpbC5jcmVhdGVJcmkoYXR0cmlidXRlcy5yZXNvdXJjZSwgYWN0aXZlVGFnLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRPYmplY3RSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmICgnaHJlZicgaW4gYXR0cmlidXRlcyB8fCAnc3JjJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYmplY3RSZXNvdXJjZSA9IHRoaXMudXRpbC5jcmVhdGVJcmkoYXR0cmlidXRlcy5ocmVmIHx8IGF0dHJpYnV0ZXMuc3JjLCBhY3RpdmVUYWcsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCd0eXBlb2YnIGluIGF0dHJpYnV0ZXMgJiYgISgnYWJvdXQnIGluIGF0dHJpYnV0ZXMpICYmICF0aGlzLmlzSW5oZXJpdFN1YmplY3RJbkhlYWRCb2R5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYmplY3RSZXNvdXJjZSA9IHRoaXMudXRpbC5jcmVhdGVCbGFua05vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdHlwZWQgcmVzb3VyY2VcbiAgICAgICAgICAgIGlmICgndHlwZW9mJyBpbiBhdHRyaWJ1dGVzICYmICEoJ2Fib3V0JyBpbiBhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW5oZXJpdFN1YmplY3RJbkhlYWRCb2R5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzb3VyY2UgPSBuZXdTdWJqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWRSZXNvdXJjZSA9IGN1cnJlbnRPYmplY3RSZXNvdXJjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNzogSWYgYSB0eXBlZCByZXNvdXJjZSB3YXMgZGVmaW5lZCwgZW1pdCBpdCBhcyBhIHRyaXBsZVxuICAgICAgICBpZiAodHlwZWRSZXNvdXJjZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMudXRpbC5jcmVhdGVWb2NhYklyaXMoYXR0cmlidXRlcy50eXBlb2YsIGFjdGl2ZVRhZywgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUodGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKHR5cGVkUmVzb3VyY2UsIGFjdGl2ZVRhZyksIHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoVXRpbF8xLlV0aWwuUkRGICsgJ3R5cGUnKSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gODogUmVzZXQgbGlzdCBtYXBwaW5nIGlmIHdlIGhhdmUgYSBuZXcgc3ViamVjdFxuICAgICAgICBpZiAobmV3U3ViamVjdCkge1xuICAgICAgICAgICAgYWN0aXZlVGFnLmxpc3RNYXBwaW5nID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gOTogSWYgYW4gb2JqZWN0IHdhcyBkZWZpbmVkLCBlbWl0IHRyaXBsZXMgZm9yIGl0XG4gICAgICAgIGlmIChjdXJyZW50T2JqZWN0UmVzb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBsaXN0IG1hcHBpbmdcbiAgICAgICAgICAgIGlmICgncmVsJyBpbiBhdHRyaWJ1dGVzICYmICdpbmxpc3QnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMucmVsLCBhY3RpdmVUYWcsIGFsbG93VGVybXNJblJlbFByZWRpY2F0ZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RNYXBwaW5nKGFjdGl2ZVRhZywgbmV3U3ViamVjdCwgcHJlZGljYXRlLCBjdXJyZW50T2JqZWN0UmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERldGVybWluZSBwcmVkaWNhdGVzIHVzaW5nIHJlbCBvciByZXYgKHVubGVzcyByZWwgYW5kIGlubGlzdCBhcmUgcHJlc2VudClcbiAgICAgICAgICAgIGlmICghKCdyZWwnIGluIGF0dHJpYnV0ZXMgJiYgJ2lubGlzdCcgaW4gYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3JlbCcgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMucmVsLCBhY3RpdmVUYWcsIGFsbG93VGVybXNJblJlbFByZWRpY2F0ZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaShuZXdTdWJqZWN0LCBhY3RpdmVUYWcpLCBwcmVkaWNhdGUsIHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaShjdXJyZW50T2JqZWN0UmVzb3VyY2UsIGFjdGl2ZVRhZykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgncmV2JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIHRoaXMudXRpbC5jcmVhdGVWb2NhYklyaXMoYXR0cmlidXRlcy5yZXYsIGFjdGl2ZVRhZywgYWxsb3dUZXJtc0luUmV2UHJlZGljYXRlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUodGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKGN1cnJlbnRPYmplY3RSZXNvdXJjZSwgYWN0aXZlVGFnKSwgcHJlZGljYXRlLCB0aGlzLnV0aWwuZ2V0UmVzb3VyY2VPckJhc2VJcmkobmV3U3ViamVjdCwgYWN0aXZlVGFnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gMTA6IFN0b3JlIGluY29tcGxldGUgdHJpcGxlcyBpZiB3ZSBkb24ndCBoYXZlIGFuIG9iamVjdCwgYnV0IHdlIGRvIGhhdmUgcHJlZGljYXRlc1xuICAgICAgICBpZiAoIWN1cnJlbnRPYmplY3RSZXNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCdyZWwnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ2lubGlzdCcgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMucmVsLCBhY3RpdmVUYWcsIGFsbG93VGVybXNJblJlbFByZWRpY2F0ZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0TWFwcGluZyhhY3RpdmVUYWcsIG5ld1N1YmplY3QsIHByZWRpY2F0ZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWcuaW5jb21wbGV0ZVRyaXBsZXMucHVzaCh7IHByZWRpY2F0ZSwgcmV2ZXJzZTogZmFsc2UsIGxpc3Q6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIHRoaXMudXRpbC5jcmVhdGVWb2NhYklyaXMoYXR0cmlidXRlcy5yZWwsIGFjdGl2ZVRhZywgYWxsb3dUZXJtc0luUmVsUHJlZGljYXRlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWcuaW5jb21wbGV0ZVRyaXBsZXMucHVzaCh7IHByZWRpY2F0ZSwgcmV2ZXJzZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3JldicgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIHRoaXMudXRpbC5jcmVhdGVWb2NhYklyaXMoYXR0cmlidXRlcy5yZXYsIGFjdGl2ZVRhZywgYWxsb3dUZXJtc0luUmV2UHJlZGljYXRlcywgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy5pbmNvbXBsZXRlVHJpcGxlcy5wdXNoKHsgcHJlZGljYXRlLCByZXZlcnNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBhIGJsYW5rIG5vZGUgb2JqZWN0LCBzbyB0aGUgY2hpbGRyZW4gY2FuIG1ha2UgdXNlIG9mIHRoaXMgd2hlbiBjb21wbGV0aW5nIHRoZSB0cmlwbGVzXG4gICAgICAgICAgICBpZiAoYWN0aXZlVGFnLmluY29tcGxldGVUcmlwbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50T2JqZWN0UmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlQmxhbmtOb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gMTE6IERldGVybWluZSBjdXJyZW50IHByb3BlcnR5IHZhbHVlXG4gICAgICAgIGlmICgncHJvcGVydHknIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcmVkaWNhdGVzXG4gICAgICAgICAgICBhY3RpdmVUYWcucHJlZGljYXRlcyA9IHRoaXMudXRpbC5jcmVhdGVWb2NhYklyaXMoYXR0cmlidXRlcy5wcm9wZXJ0eSwgYWN0aXZlVGFnLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBTYXZlIGRhdGF0eXBlIGF0dHJpYnV0ZSB2YWx1ZSBpbiBhY3RpdmUgdGFnXG4gICAgICAgICAgICBsZXQgbG9jYWxPYmplY3RSZXNvdXJjZTtcbiAgICAgICAgICAgIGlmICgnZGF0YXR5cGUnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcuZGF0YXR5cGUgPSB0aGlzLnV0aWwuY3JlYXRlSXJpKGF0dHJpYnV0ZXMuZGF0YXR5cGUsIGFjdGl2ZVRhZywgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUYWcuZGF0YXR5cGVcbiAgICAgICAgICAgICAgICAgICAgJiYgKGFjdGl2ZVRhZy5kYXRhdHlwZS52YWx1ZSA9PT0gVXRpbF8xLlV0aWwuUkRGICsgJ1hNTExpdGVyYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAodGhpcy5mZWF0dXJlcy5odG1sRGF0YXR5cGUgJiYgYWN0aXZlVGFnLmRhdGF0eXBlLnZhbHVlID09PSBVdGlsXzEuVXRpbC5SREYgKyAnSFRNTCcpKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWcuY29sbGVjdENoaWxkVGFncyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGRldGVybWluZSByZXNvdXJjZVxuICAgICAgICAgICAgICAgIGlmICghKCdyZXYnIGluIGF0dHJpYnV0ZXMpICYmICEoJ3JlbCcgaW4gYXR0cmlidXRlcykgJiYgISgnY29udGVudCcgaW4gYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdyZXNvdXJjZScgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxPYmplY3RSZXNvdXJjZSA9IHRoaXMudXRpbC5jcmVhdGVJcmkoYXR0cmlidXRlcy5yZXNvdXJjZSwgYWN0aXZlVGFnLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbE9iamVjdFJlc291cmNlICYmICdocmVmJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbE9iamVjdFJlc291cmNlID0gdGhpcy51dGlsLmNyZWF0ZUlyaShhdHRyaWJ1dGVzLmhyZWYsIGFjdGl2ZVRhZywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsT2JqZWN0UmVzb3VyY2UgJiYgJ3NyYycgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxPYmplY3RSZXNvdXJjZSA9IHRoaXMudXRpbC5jcmVhdGVJcmkoYXR0cmlidXRlcy5zcmMsIGFjdGl2ZVRhZywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3R5cGVvZicgaW4gYXR0cmlidXRlcyAmJiAhKCdhYm91dCcgaW4gYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxPYmplY3RSZXNvdXJjZSA9IHR5cGVkUmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdjb250ZW50JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gRW1pdCB0cmlwbGVzIGJhc2VkIG9uIGNvbnRlbnQgYXR0cmlidXRlIGhhcyBwcmVmZXJlbmNlIG92ZXIgdGV4dCBjb250ZW50XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy51dGlsLmNyZWF0ZUxpdGVyYWwoYXR0cmlidXRlcy5jb250ZW50LCBhY3RpdmVUYWcpO1xuICAgICAgICAgICAgICAgIGlmICgnaW5saXN0JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIGFjdGl2ZVRhZy5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RNYXBwaW5nKGFjdGl2ZVRhZywgbmV3U3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKG5ld1N1YmplY3QsIGFjdGl2ZVRhZyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIGFjdGl2ZVRhZy5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVuc2V0IHByZWRpY2F0ZSB0byBhdm9pZCB0ZXh0IGNvbnRlbnRzIHRvIHByb2R1Y2UgbmV3IHRyaXBsZXNcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcucHJlZGljYXRlcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZlYXR1cmVzLmRhdGV0aW1lQXR0cmlidXRlICYmICdkYXRldGltZScgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy5pbnRlcnByZXRPYmplY3RBc1RpbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIERhdGV0aW1lIGF0dHJpYnV0ZSBvbiB0aW1lIHRhZyBoYXMgcHJlZmVyZW5jZSBvdmVyIHRleHQgY29udGVudFxuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMudXRpbC5jcmVhdGVMaXRlcmFsKGF0dHJpYnV0ZXMuZGF0ZXRpbWUsIGFjdGl2ZVRhZyk7XG4gICAgICAgICAgICAgICAgaWYgKCdpbmxpc3QnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgYWN0aXZlVGFnLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdE1hcHBpbmcoYWN0aXZlVGFnLCBuZXdTdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnV0aWwuZ2V0UmVzb3VyY2VPckJhc2VJcmkobmV3U3ViamVjdCwgYWN0aXZlVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgYWN0aXZlVGFnLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5zZXQgcHJlZGljYXRlIHRvIGF2b2lkIHRleHQgY29udGVudHMgdG8gcHJvZHVjZSBuZXcgdHJpcGxlc1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy5wcmVkaWNhdGVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsT2JqZWN0UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBFbWl0IHRyaXBsZXMgZm9yIGFsbCByZXNvdXJjZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKGxvY2FsT2JqZWN0UmVzb3VyY2UsIGFjdGl2ZVRhZyk7XG4gICAgICAgICAgICAgICAgaWYgKCdpbmxpc3QnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgYWN0aXZlVGFnLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdE1hcHBpbmcoYWN0aXZlVGFnLCBuZXdTdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnV0aWwuZ2V0UmVzb3VyY2VPckJhc2VJcmkobmV3U3ViamVjdCwgYWN0aXZlVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgYWN0aXZlVGFnLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5zZXQgcHJlZGljYXRlIHRvIGF2b2lkIHRleHQgY29udGVudHMgdG8gcHJvZHVjZSBuZXcgdHJpcGxlc1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy5wcmVkaWNhdGVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAxMjogQ29tcGxldGUgaW5jb21wbGV0ZSB0cmlwbGVzXG4gICAgICAgIGxldCBpbmNvbXBsZXRlVHJpcGxlc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWFjdGl2ZVRhZy5za2lwRWxlbWVudCAmJiBuZXdTdWJqZWN0ICYmIHBhcmVudFRhZy5pbmNvbXBsZXRlVHJpcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbmNvbXBsZXRlVHJpcGxlc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKHBhcmVudFRhZy5zdWJqZWN0LCBhY3RpdmVUYWcpO1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKG5ld1N1YmplY3QsIGFjdGl2ZVRhZyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluY29tcGxldGVUcmlwbGUgb2YgcGFyZW50VGFnLmluY29tcGxldGVUcmlwbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmNvbXBsZXRlVHJpcGxlLnJldmVyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY29tcGxldGVUcmlwbGUubGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgYWN0aXZlIHRhZyB0aGF0IGRlZmluZWQgdGhlIGxpc3QgYnkgZ29pbmcgdXAgdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3RJbkxpc3RUYWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlVGFnU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUYWdTdGFja1tpXS5pbmxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RJbkxpc3RUYWcgPSB0aGlzLmFjdGl2ZVRhZ1N0YWNrW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdEluTGlzdFRhZyBpcyBndWFyYW50ZWVkIHRvIGJlIG5vbi1udWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RNYXBwaW5nKGZpcnN0SW5MaXN0VGFnLCBuZXdTdWJqZWN0LCBpbmNvbXBsZXRlVHJpcGxlLnByZWRpY2F0ZSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShzdWJqZWN0LCBpbmNvbXBsZXRlVHJpcGxlLnByZWRpY2F0ZSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKG9iamVjdCwgaW5jb21wbGV0ZVRyaXBsZS5wcmVkaWNhdGUsIHN1YmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluY29tcGxldGVUcmlwbGVzQ29tcGxldGVkICYmIHBhcmVudFRhZy5pbmNvbXBsZXRlVHJpcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhY3RpdmVUYWcuaW5jb21wbGV0ZVRyaXBsZXMgPSBhY3RpdmVUYWcuaW5jb21wbGV0ZVRyaXBsZXMuY29uY2F0KHBhcmVudFRhZy5pbmNvbXBsZXRlVHJpcGxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMTM6IFNhdmUgZXZhbHVhdGlvbiBjb250ZXh0IGludG8gYWN0aXZlIHRhZ1xuICAgICAgICBhY3RpdmVUYWcuc3ViamVjdCA9IG5ld1N1YmplY3QgfHwgcGFyZW50VGFnLnN1YmplY3Q7XG4gICAgICAgIGFjdGl2ZVRhZy5vYmplY3QgPSBjdXJyZW50T2JqZWN0UmVzb3VyY2UgfHwgbmV3U3ViamVjdDtcbiAgICB9XG4gICAgb25UZXh0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlVGFnID0gdGhpcy5hY3RpdmVUYWdTdGFja1t0aGlzLmFjdGl2ZVRhZ1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBDb2xsZWN0IHRleHQgaW4gcGF0dGVybiB0YWcgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzLmNvcHlSZGZhUGF0dGVybnMgJiYgYWN0aXZlVGFnLmNvbGxlY3RlZFBhdHRlcm5UYWcpIHtcbiAgICAgICAgICAgIGFjdGl2ZVRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnLnRleHQucHVzaChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYXZlIHRoZSB0ZXh0IGluc2lkZSB0aGUgYWN0aXZlIHRhZ1xuICAgICAgICBpZiAoIWFjdGl2ZVRhZy50ZXh0KSB7XG4gICAgICAgICAgICBhY3RpdmVUYWcudGV4dCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVRhZy50ZXh0LnB1c2goZGF0YSk7XG4gICAgfVxuICAgIG9uVGFnQ2xvc2UoKSB7XG4gICAgICAgIC8vIEdldCB0aGUgYWN0aXZlIHRhZ1xuICAgICAgICBjb25zdCBhY3RpdmVUYWcgPSB0aGlzLmFjdGl2ZVRhZ1N0YWNrW3RoaXMuYWN0aXZlVGFnU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhcmVudFRhZyA9IHRoaXMuYWN0aXZlVGFnU3RhY2tbdGhpcy5hY3RpdmVUYWdTdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgaWYgKCEoYWN0aXZlVGFnLmNvbGxlY3RDaGlsZFRhZ3MgJiYgcGFyZW50VGFnLmNvbGxlY3RDaGlsZFRhZ3MgJiYgdGhpcy5mZWF0dXJlcy5za2lwSGFuZGxpbmdYbWxMaXRlcmFsQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkZXRlY3QgYSBmaW5hbGl6ZWQgcmRmYTpQYXR0ZXJuIHRhZywgc3RvcmUgaXRcbiAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmVzLmNvcHlSZGZhUGF0dGVybnMgJiYgYWN0aXZlVGFnLmNvbGxlY3RlZFBhdHRlcm5UYWdcbiAgICAgICAgICAgICAgICAmJiBhY3RpdmVUYWcuY29sbGVjdGVkUGF0dGVyblRhZy5yb290UGF0dGVybikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5JZCA9IGFjdGl2ZVRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnLmF0dHJpYnV0ZXMucmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHJlc291cmNlIGFuZCB0eXBlb2YgYXR0cmlidXRlcyB0byBhdm9pZCBpdCBiZWluZyBzZWVuIGFzIGEgbmV3IHBhdHRlcm5cbiAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlVGFnLmNvbGxlY3RlZFBhdHRlcm5UYWcuYXR0cmlidXRlcy5yZXNvdXJjZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlVGFnLmNvbGxlY3RlZFBhdHRlcm5UYWcuYXR0cmlidXRlcy50eXBlb2Y7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHBhdHRlcm5cbiAgICAgICAgICAgICAgICB0aGlzLnJkZmFQYXR0ZXJuc1twYXR0ZXJuSWRdID0gYWN0aXZlVGFnLmNvbGxlY3RlZFBhdHRlcm5UYWc7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgYWxsIHBlbmRpbmcgY29waWVzIGZvciB0aGlzIHBhdHRlcm5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nUmRmYVBhdHRlcm5Db3BpZXNbcGF0dGVybklkXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnBlbmRpbmdSZGZhUGF0dGVybkNvcGllc1twYXR0ZXJuSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRQYXR0ZXJuQ29weSh0YWcsIGFjdGl2ZVRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnLCBwYXR0ZXJuSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZGZhUGF0dGVybkNvcGllc1twYXR0ZXJuSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGFjdGl2ZSB0YWcgZnJvbSB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVtaXQgYWxsIHRyaXBsZXMgdGhhdCB3ZXJlIGRldGVybWluZWQgaW4gdGhlIGFjdGl2ZSB0YWdcbiAgICAgICAgICAgIGlmIChhY3RpdmVUYWcucHJlZGljYXRlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnV0aWwuZ2V0UmVzb3VyY2VPckJhc2VJcmkoYWN0aXZlVGFnLnN1YmplY3QsIGFjdGl2ZVRhZyk7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRTZWdtZW50cyA9IGFjdGl2ZVRhZy50ZXh0IHx8IFtdO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUYWcuY29sbGVjdENoaWxkVGFncyAmJiBwYXJlbnRUYWcuY29sbGVjdENoaWxkVGFncykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW5zaWRlIGFuIFhNTExpdGVyYWwgY2hpbGQgdGhhdCBhbHNvIGhhcyBSREZhIGNvbnRlbnQsIGlnbm9yZSB0aGUgdGFnIG5hbWUgdGhhdCB3YXMgY29sbGVjdGVkLlxuICAgICAgICAgICAgICAgICAgICB0ZXh0U2VnbWVudHMgPSB0ZXh0U2VnbWVudHMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMudXRpbC5jcmVhdGVMaXRlcmFsKHRleHRTZWdtZW50cy5qb2luKCcnKSwgYWN0aXZlVGFnKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVGFnLmlubGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiBhY3RpdmVUYWcucHJlZGljYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0TWFwcGluZyhhY3RpdmVUYWcsIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgYWN0aXZlVGFnLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGV4dCwgdW5sZXNzIHRoZSBwYXJlbnQgaXMgYWxzbyBjb2xsZWN0aW5nIHRleHRcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFRhZy5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy50ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAxNDogSGFuZGxlIGxvY2FsIGxpc3QgbWFwcGluZ1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVRhZy5vYmplY3QgJiYgT2JqZWN0LmtleXMoYWN0aXZlVGFnLmxpc3RNYXBwaW5nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaShhY3RpdmVUYWcub2JqZWN0LCBhY3RpdmVUYWcpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlVmFsdWUgaW4gYWN0aXZlVGFnLmxpc3RNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUocHJlZGljYXRlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBhY3RpdmVUYWcubGlzdE1hcHBpbmdbcHJlZGljYXRlVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vbi1lbXB0eSBsaXN0LCBlbWl0IGxpbmtlZCBsaXN0IG9mIHJkZjpmaXJzdCBhbmQgcmRmOnJlc3QgY2hhaW5zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibm9kZXMgPSB2YWx1ZXMubWFwKCgpID0+IHRoaXMudXRpbC5jcmVhdGVCbGFua05vZGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaSh2YWx1ZXNbaV0sIGFjdGl2ZVRhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKGJub2Rlc1tpXSwgdGhpcy51dGlsLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShVdGlsXzEuVXRpbC5SREYgKyAnZmlyc3QnKSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUoYm5vZGVzW2ldLCB0aGlzLnV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKFV0aWxfMS5VdGlsLlJERiArICdyZXN0JyksIChpIDwgdmFsdWVzLmxlbmd0aCAtIDEpID8gYm5vZGVzW2kgKyAxXSA6IHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoVXRpbF8xLlV0aWwuUkRGICsgJ25pbCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgdHJpcGxlIGZvciB0aGUgZmlyc3QgbGlua2VkIGxpc3QgY2hhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShzdWJqZWN0LCBwcmVkaWNhdGUsIGJub2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eSBsaXN0LCBqdXN0IGVtaXQgcmRmOm5pbFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKHN1YmplY3QsIHByZWRpY2F0ZSwgdGhpcy51dGlsLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShVdGlsXzEuVXRpbC5SREYgKyAnbmlsJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYWN0aXZlIHRhZyBmcm9tIHRoZSBzdGFja1xuICAgICAgICB0aGlzLmFjdGl2ZVRhZ1N0YWNrLnBvcCgpO1xuICAgICAgICAvLyBTYXZlIHRoZSB0YWcgY29udGVudHMgaWYgbmVlZGVkXG4gICAgICAgIGlmIChhY3RpdmVUYWcuY29sbGVjdENoaWxkVGFncyAmJiBhY3RpdmVUYWcudGV4dCkge1xuICAgICAgICAgICAgYWN0aXZlVGFnLnRleHQucHVzaChgPC8ke2FjdGl2ZVRhZy5uYW1lfT5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBzdGlsbCBoYXZlIHRleHQgY29udGVudHMsIHRyeSB0byBhcHBlbmQgaXQgdG8gdGhlIHBhcmVudCB0YWdcbiAgICAgICAgaWYgKGFjdGl2ZVRhZy50ZXh0ICYmIHBhcmVudFRhZykge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRUYWcudGV4dCkge1xuICAgICAgICAgICAgICAgIHBhcmVudFRhZy50ZXh0ID0gYWN0aXZlVGFnLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRUYWcudGV4dCA9IHBhcmVudFRhZy50ZXh0LmNvbmNhdChhY3RpdmVUYWcudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzLmNvcHlSZGZhUGF0dGVybnMpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMuY29weVJkZmFQYXR0ZXJucyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gRW1pdCBhbGwgdW5yZWZlcmVuY2VkIHBhdHRlcm5zXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm5JZCBpbiB0aGlzLnJkZmFQYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnJkZmFQYXR0ZXJuc1twYXR0ZXJuSWRdO1xuICAgICAgICAgICAgICAgIGlmICghcGF0dGVybi5yZWZlcmVuY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uYXR0cmlidXRlcy50eXBlb2YgPSAncmRmYTpQYXR0ZXJuJztcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5hdHRyaWJ1dGVzLnJlc291cmNlID0gcGF0dGVybklkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRQYXR0ZXJuQ29weShwYXR0ZXJuLnBhcmVudFRhZywgcGF0dGVybiwgcGF0dGVybklkKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5yZWZlcmVuY2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXR0ZXJuLmF0dHJpYnV0ZXMudHlwZW9mO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGF0dGVybi5hdHRyaWJ1dGVzLnJlc291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVtaXQgYWxsIHVucmVmZXJlbmNlZCBjb3B5IGxpbmtzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm5JZCBpbiB0aGlzLnBlbmRpbmdSZGZhUGF0dGVybkNvcGllcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFyZW50VGFnIG9mIHRoaXMucGVuZGluZ1JkZmFQYXR0ZXJuQ29waWVzW3BhdHRlcm5JZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWdTdGFjay5wdXNoKHBhcmVudFRhZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UYWdPcGVuKCdsaW5rJywgeyBwcm9wZXJ0eTogJ3JkZmE6Y29weScsIGhyZWY6IHBhdHRlcm5JZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRhZ0Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFnU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlcy5jb3B5UmRmYVBhdHRlcm5zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbmV3IHN1YmplY3QgY2FuIGJlIGluaGVyaXRlZCBmcm9tIHRoZSBwYXJlbnQgb2JqZWN0XG4gICAgICogaWYgdGhlIHJlc291cmNlIGRlZmluZXMgbm8gbmV3IHN1YmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGN1cnJlbnQgdGFnIG5hbWUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IElmIHRoZSBzdWJqZWN0IGNhbiBiZSBpbmhlcml0ZWQuXG4gICAgICovXG4gICAgaXNJbmhlcml0U3ViamVjdEluSGVhZEJvZHkobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlcy5pbmhlcml0U3ViamVjdEluSGVhZEJvZHkgJiYgKG5hbWUgPT09ICdoZWFkJyB8fCBuYW1lID09PSAnYm9keScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0IG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwcmVkaWNhdGUgYW5kIG9iamVjdCBpbiB0aGUgYWN0aXZlIHRhZy5cbiAgICAgKiBAcGFyYW0ge0lBY3RpdmVUYWd9IGFjdGl2ZVRhZyBUaGUgYWN0aXZlIHRhZy5cbiAgICAgKiBAcGFyYW0ge1Rlcm0gfCBib29sZWFufSBzdWJqZWN0IEEgc3ViamVjdCB0ZXJtLCB0aGlzIHdpbGwgb25seSBiZSB1c2VkIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIGxpc3RcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGFjdGl2ZVRhZy5leHBsaWNpdE5ld1N1YmplY3QgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge1Rlcm19IHByZWRpY2F0ZSBBIHByZWRpY2F0ZSB0ZXJtLlxuICAgICAqIEBwYXJhbSB7VGVybSB8IGJvb2xlYW59IGN1cnJlbnRPYmplY3RSZXNvdXJjZSBUaGUgY3VycmVudCBvYmplY3QgcmVzb3VyY2UuXG4gICAgICovXG4gICAgYWRkTGlzdE1hcHBpbmcoYWN0aXZlVGFnLCBzdWJqZWN0LCBwcmVkaWNhdGUsIGN1cnJlbnRPYmplY3RSZXNvdXJjZSkge1xuICAgICAgICBpZiAoYWN0aXZlVGFnLmV4cGxpY2l0TmV3U3ViamVjdCkge1xuICAgICAgICAgICAgY29uc3QgYk5vZGUgPSB0aGlzLnV0aWwuY3JlYXRlQmxhbmtOb2RlKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUodGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKHN1YmplY3QsIGFjdGl2ZVRhZyksIHByZWRpY2F0ZSwgYk5vZGUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKGJOb2RlLCB0aGlzLnV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKFV0aWxfMS5VdGlsLlJERiArICdmaXJzdCcpLCB0aGlzLnV0aWwuZ2V0UmVzb3VyY2VPckJhc2VJcmkoY3VycmVudE9iamVjdFJlc291cmNlLCBhY3RpdmVUYWcpKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShiTm9kZSwgdGhpcy51dGlsLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShVdGlsXzEuVXRpbC5SREYgKyAncmVzdCcpLCB0aGlzLnV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKFV0aWxfMS5VdGlsLlJERiArICduaWwnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJlZGljYXRlTGlzdCA9IGFjdGl2ZVRhZy5saXN0TWFwcGluZ0xvY2FsW3ByZWRpY2F0ZS52YWx1ZV07XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZUxpc3QpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcubGlzdE1hcHBpbmdMb2NhbFtwcmVkaWNhdGUudmFsdWVdID0gcHJlZGljYXRlTGlzdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRPYmplY3RSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHByZWRpY2F0ZUxpc3QucHVzaChjdXJyZW50T2JqZWN0UmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgdGhlIGdpdmVuIHRyaXBsZSB0byB0aGUgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7VGVybX0gc3ViamVjdCBBIHN1YmplY3QgdGVybS5cbiAgICAgKiBAcGFyYW0ge1Rlcm19IHByZWRpY2F0ZSBBIHByZWRpY2F0ZSB0ZXJtLlxuICAgICAqIEBwYXJhbSB7VGVybX0gb2JqZWN0IEFuIG9iamVjdCB0ZXJtLlxuICAgICAqL1xuICAgIGVtaXRUcmlwbGUoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgSVJJc1xuICAgICAgICBpZiAoKHN1YmplY3QudGVybVR5cGUgPT09ICdOYW1lZE5vZGUnICYmIHN1YmplY3QudmFsdWUuaW5kZXhPZignOicpIDwgMClcbiAgICAgICAgICAgIHx8IChwcmVkaWNhdGUudGVybVR5cGUgPT09ICdOYW1lZE5vZGUnICYmIHByZWRpY2F0ZS52YWx1ZS5pbmRleE9mKCc6JykgPCAwKVxuICAgICAgICAgICAgfHwgKG9iamVjdC50ZXJtVHlwZSA9PT0gJ05hbWVkTm9kZScgJiYgb2JqZWN0LnZhbHVlLmluZGV4T2YoJzonKSA8IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoKHRoaXMudXRpbC5kYXRhRmFjdG9yeS5xdWFkKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCB0aGlzLmRlZmF1bHRHcmFwaCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IGFuIGluc3RhbnRpYXRpb24gb2YgdGhlIGdpdmVuIHBhdHRlcm4gd2l0aCB0aGUgZ2l2ZW4gcGFyZW50IHRhZy5cbiAgICAgKiBAcGFyYW0ge0lBY3RpdmVUYWd9IHBhcmVudFRhZyBUaGUgcGFyZW50IHRhZyB0byBpbnN0YW50aWF0ZSBpbi5cbiAgICAgKiBAcGFyYW0ge0lSZGZhUGF0dGVybn0gcGF0dGVybiBUaGUgcGF0dGVybiB0byBpbnN0YW50aWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdFBhdHRlcm5JZCBUaGUgcGF0dGVybiBpZC5cbiAgICAgKi9cbiAgICBlbWl0UGF0dGVybkNvcHkocGFyZW50VGFnLCBwYXR0ZXJuLCByb290UGF0dGVybklkKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFnU3RhY2sucHVzaChwYXJlbnRUYWcpO1xuICAgICAgICBwYXR0ZXJuLnJlZmVyZW5jZWQgPSB0cnVlO1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCBibGFuayBub2RlcyB3aXRoaW4gcGF0dGVybnMgYXJlIGluc3RhbnRpYXRlZCBvbmx5IG9uY2UuXG4gICAgICAgIC8vIEFsbCBuZXh0IHBhdHRlcm4gY29waWVzIHdpbGwgcmV1c2UgdGhlIGluc3RhbnRpYXRlZCBibGFuayBub2RlcyBmcm9tIHRoZSBmaXJzdCBwYXR0ZXJuLlxuICAgICAgICBpZiAoIXBhdHRlcm4uY29uc3RydWN0ZWRCbGFua05vZGVzKSB7XG4gICAgICAgICAgICBwYXR0ZXJuLmNvbnN0cnVjdGVkQmxhbmtOb2RlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy51dGlsLmJsYW5rTm9kZUZhY3RvcnkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYk5vZGUgPSB0aGlzLnV0aWwuZGF0YUZhY3RvcnkuYmxhbmtOb2RlKCk7XG4gICAgICAgICAgICAgICAgcGF0dGVybi5jb25zdHJ1Y3RlZEJsYW5rTm9kZXMucHVzaChiTm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJOb2RlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBibGFua05vZGVJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLnV0aWwuYmxhbmtOb2RlRmFjdG9yeSA9ICgpID0+IHBhdHRlcm4uY29uc3RydWN0ZWRCbGFua05vZGVzW2JsYW5rTm9kZUluZGV4KytdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGx5IGV2ZXJ5dGhpbmcgd2l0aGluIHRoZSBwYXR0ZXJuXG4gICAgICAgIHRoaXMuZW1pdFBhdHRlcm5Db3B5QWJzb2x1dGUocGF0dGVybiwgdHJ1ZSwgcm9vdFBhdHRlcm5JZCk7XG4gICAgICAgIHRoaXMudXRpbC5ibGFua05vZGVGYWN0b3J5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVUYWdTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBhbiBpbnN0YW50aWF0aW9uIG9mIHRoZSBnaXZlbiBwYXR0ZXJuIHdpdGggdGhlIGdpdmVuIHBhcmVudCB0YWcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBwcm9iYWJseSBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LFxuICAgICAqIGNhbGwge0BsaW5rIGVtaXRQYXR0ZXJuQ29weX0gaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SVJkZmFQYXR0ZXJufSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIGluc3RhbnRpYXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcm9vdCBJZiB0aGlzIGlzIHRoZSByb290IGNhbGwgZm9yIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb290UGF0dGVybklkIFRoZSBwYXR0ZXJuIGlkLlxuICAgICAqL1xuICAgIGVtaXRQYXR0ZXJuQ29weUFic29sdXRlKHBhdHRlcm4sIHJvb3QsIHJvb3RQYXR0ZXJuSWQpIHtcbiAgICAgICAgLy8gU3RvcCBvbiBkZXRlY3Rpb24gb2YgY3ljbGljIHBhdHRlcm5zXG4gICAgICAgIGlmICghcm9vdCAmJiBwYXR0ZXJuLmF0dHJpYnV0ZXMucHJvcGVydHkgPT09ICdyZGZhOmNvcHknICYmIHBhdHRlcm4uYXR0cmlidXRlcy5ocmVmID09PSByb290UGF0dGVybklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblRhZ09wZW4ocGF0dGVybi5uYW1lLCBwYXR0ZXJuLmF0dHJpYnV0ZXMpO1xuICAgICAgICBmb3IgKGNvbnN0IHRleHQgb2YgcGF0dGVybi50ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm9uVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHBhdHRlcm4uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFBhdHRlcm5Db3B5QWJzb2x1dGUoY2hpbGQsIGZhbHNlLCByb290UGF0dGVybklkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uVGFnQ2xvc2UoKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVBhcnNlcih4bWxNb2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgaHRtbHBhcnNlcjJfMS5QYXJzZXIoe1xuICAgICAgICAgICAgb25jbG9zZXRhZzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UYWdDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5odG1sUGFyc2VMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odG1sUGFyc2VMaXN0ZW5lci5vblRhZ0Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmVuZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIub25FbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9ub3BlbnRhZzogKG5hbWUsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGFnT3BlbihuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIub25UYWdPcGVuKG5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb250ZXh0OiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UZXh0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5odG1sUGFyc2VMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odG1sUGFyc2VMaXN0ZW5lci5vblRleHQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGRlY29kZUVudGl0aWVzOiB0cnVlLFxuICAgICAgICAgICAgcmVjb2duaXplU2VsZkNsb3Npbmc6IHRydWUsXG4gICAgICAgICAgICB4bWxNb2RlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJkZmFQYXJzZXIgPSBSZGZhUGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmRmYVBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUkRGQV9DT05URU5UVFlQRVMgPSBleHBvcnRzLlJERkFfRkVBVFVSRVMgPSB2b2lkIDA7XG4vKipcbiAqIEEgbWFwcGluZyBvZiBSREZhIHByb2ZpbGUgdG8gYSBmZWF0dXJlcyBvYmplY3QuXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlOm9iamVjdC1saXRlcmFsLXNvcnQta2V5c1xuZXhwb3J0cy5SREZBX0ZFQVRVUkVTID0ge1xuICAgICcnOiB7XG4gICAgICAgIGJhc2VUYWc6IHRydWUsXG4gICAgICAgIHhtbEJhc2U6IHRydWUsXG4gICAgICAgIGxhbmdBdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIG9ubHlBbGxvd1VyaVJlbFJldklmUHJvcGVydHk6IHRydWUsXG4gICAgICAgIGluaGVyaXRTdWJqZWN0SW5IZWFkQm9keTogdHJ1ZSxcbiAgICAgICAgZGF0ZXRpbWVBdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIHRpbWVUYWc6IHRydWUsXG4gICAgICAgIGh0bWxEYXRhdHlwZTogdHJ1ZSxcbiAgICAgICAgY29weVJkZmFQYXR0ZXJuczogdHJ1ZSxcbiAgICAgICAgeG1sbnNQcmVmaXhNYXBwaW5nczogdHJ1ZSxcbiAgICAgICAgeGh0bWxJbml0aWFsQ29udGV4dDogdHJ1ZSxcbiAgICAgICAgcm9sZUF0dHJpYnV0ZTogdHJ1ZSxcbiAgICB9LFxuICAgICdjb3JlJzoge1xuICAgICAgICBiYXNlVGFnOiBmYWxzZSxcbiAgICAgICAgeG1sQmFzZTogZmFsc2UsXG4gICAgICAgIGxhbmdBdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIG9ubHlBbGxvd1VyaVJlbFJldklmUHJvcGVydHk6IHRydWUsXG4gICAgICAgIGluaGVyaXRTdWJqZWN0SW5IZWFkQm9keTogZmFsc2UsXG4gICAgICAgIGRhdGV0aW1lQXR0cmlidXRlOiBmYWxzZSxcbiAgICAgICAgdGltZVRhZzogZmFsc2UsXG4gICAgICAgIGh0bWxEYXRhdHlwZTogZmFsc2UsXG4gICAgICAgIGNvcHlSZGZhUGF0dGVybnM6IHRydWUsXG4gICAgICAgIHhtbG5zUHJlZml4TWFwcGluZ3M6IHRydWUsXG4gICAgICAgIHhodG1sSW5pdGlhbENvbnRleHQ6IGZhbHNlLFxuICAgICAgICByb2xlQXR0cmlidXRlOiBmYWxzZSxcbiAgICB9LFxuICAgICdodG1sJzoge1xuICAgICAgICBiYXNlVGFnOiB0cnVlLFxuICAgICAgICB4bWxCYXNlOiBmYWxzZSxcbiAgICAgICAgbGFuZ0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgb25seUFsbG93VXJpUmVsUmV2SWZQcm9wZXJ0eTogdHJ1ZSxcbiAgICAgICAgaW5oZXJpdFN1YmplY3RJbkhlYWRCb2R5OiB0cnVlLFxuICAgICAgICBkYXRldGltZUF0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgdGltZVRhZzogdHJ1ZSxcbiAgICAgICAgaHRtbERhdGF0eXBlOiB0cnVlLFxuICAgICAgICBjb3B5UmRmYVBhdHRlcm5zOiB0cnVlLFxuICAgICAgICB4bWxuc1ByZWZpeE1hcHBpbmdzOiB0cnVlLFxuICAgICAgICB4aHRtbEluaXRpYWxDb250ZXh0OiBmYWxzZSxcbiAgICAgICAgcm9sZUF0dHJpYnV0ZTogdHJ1ZSxcbiAgICB9LFxuICAgICd4aHRtbCc6IHtcbiAgICAgICAgYmFzZVRhZzogdHJ1ZSxcbiAgICAgICAgeG1sQmFzZTogZmFsc2UsXG4gICAgICAgIGxhbmdBdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIG9ubHlBbGxvd1VyaVJlbFJldklmUHJvcGVydHk6IHRydWUsXG4gICAgICAgIGluaGVyaXRTdWJqZWN0SW5IZWFkQm9keTogdHJ1ZSxcbiAgICAgICAgZGF0ZXRpbWVBdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIHRpbWVUYWc6IHRydWUsXG4gICAgICAgIGh0bWxEYXRhdHlwZTogdHJ1ZSxcbiAgICAgICAgY29weVJkZmFQYXR0ZXJuczogdHJ1ZSxcbiAgICAgICAgeG1sbnNQcmVmaXhNYXBwaW5nczogdHJ1ZSxcbiAgICAgICAgeGh0bWxJbml0aWFsQ29udGV4dDogdHJ1ZSxcbiAgICAgICAgcm9sZUF0dHJpYnV0ZTogdHJ1ZSxcbiAgICB9LFxuICAgICd4bWwnOiB7XG4gICAgICAgIGJhc2VUYWc6IGZhbHNlLFxuICAgICAgICB4bWxCYXNlOiB0cnVlLFxuICAgICAgICBsYW5nQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICBvbmx5QWxsb3dVcmlSZWxSZXZJZlByb3BlcnR5OiBmYWxzZSxcbiAgICAgICAgaW5oZXJpdFN1YmplY3RJbkhlYWRCb2R5OiBmYWxzZSxcbiAgICAgICAgZGF0ZXRpbWVBdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIHRpbWVUYWc6IHRydWUsXG4gICAgICAgIGh0bWxEYXRhdHlwZTogZmFsc2UsXG4gICAgICAgIGNvcHlSZGZhUGF0dGVybnM6IGZhbHNlLFxuICAgICAgICB4bWxuc1ByZWZpeE1hcHBpbmdzOiB0cnVlLFxuICAgICAgICB4aHRtbEluaXRpYWxDb250ZXh0OiBmYWxzZSxcbiAgICAgICAgcm9sZUF0dHJpYnV0ZTogdHJ1ZSxcbiAgICB9LFxufTtcbi8vIHRzbGludDplbmFibGU6b2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzXG4vLyB0c2xpbnQ6ZGlzYWJsZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXNcbmV4cG9ydHMuUkRGQV9DT05URU5UVFlQRVMgPSB7XG4gICAgLy8gSFRNTFxuICAgICd0ZXh0L2h0bWwnOiAnaHRtbCcsXG4gICAgLy8gWEhUTUxcbiAgICAnYXBwbGljYXRpb24veGh0bWwreG1sJzogJ3hodG1sJyxcbiAgICAvLyBYTUxcbiAgICAnYXBwbGljYXRpb24veG1sJzogJ3htbCcsXG4gICAgJ3RleHQveG1sJzogJ3htbCcsXG4gICAgJ2ltYWdlL3N2Zyt4bWwnOiAneG1sJyxcbn07XG4vLyB0c2xpbnQ6ZW5hYmxlOm9iamVjdC1saXRlcmFsLXNvcnQta2V5c1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmRmYVByb2ZpbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlV0aWwgPSB2b2lkIDA7XG5jb25zdCByZWxhdGl2ZV90b19hYnNvbHV0ZV9pcmlfMSA9IHJlcXVpcmUoXCJyZWxhdGl2ZS10by1hYnNvbHV0ZS1pcmlcIik7XG5jb25zdCBSZGZhUHJvZmlsZV8xID0gcmVxdWlyZShcIi4vUmRmYVByb2ZpbGVcIik7XG5jb25zdCByZGZfZGF0YV9mYWN0b3J5XzEgPSByZXF1aXJlKFwicmRmLWRhdGEtZmFjdG9yeVwiKTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zLlxuICovXG5jbGFzcyBVdGlsIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhRmFjdG9yeSwgYmFzZUlSSSkge1xuICAgICAgICB0aGlzLmRhdGFGYWN0b3J5ID0gZGF0YUZhY3RvcnkgfHwgbmV3IHJkZl9kYXRhX2ZhY3RvcnlfMS5EYXRhRmFjdG9yeSgpO1xuICAgICAgICB0aGlzLmJhc2VJUkkgPSB0aGlzLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShiYXNlSVJJIHx8ICcnKTtcbiAgICAgICAgdGhpcy5iYXNlSVJJRG9jdW1lbnQgPSB0aGlzLmJhc2VJUkk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBwcmVmaXhlcyBvZiB0aGUgY3VycmVudCB0YWcncyBhdHRyaWJ1dGVzLlxuICAgICAqIEBwYXJhbSB7e1twOiBzdHJpbmddOiBzdHJpbmd9fSBhdHRyaWJ1dGVzIEEgdGFnJ3MgYXR0cmlidXRlcy5cbiAgICAgKiBAcGFyYW0ge3tbcDogc3RyaW5nXTogc3RyaW5nfX0gcGFyZW50UHJlZml4ZXMgVGhlIHByZWZpeGVzIGZyb20gdGhlIHBhcmVudCB0YWcuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB4bWxuc1ByZWZpeE1hcHBpbmdzIElmIHByZWZpeGVzIHNob3VsZCBiZSBleHRyYWN0ZWQgZnJvbSB4bWxuc1ByZWZpeE1hcHBpbmdzLlxuICAgICAqIEByZXR1cm4ge3tbcDogc3RyaW5nXTogc3RyaW5nfX0gVGhlIG5ldyBwcmVmaXhlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VQcmVmaXhlcyhhdHRyaWJ1dGVzLCBwYXJlbnRQcmVmaXhlcywgeG1sbnNQcmVmaXhNYXBwaW5ncykge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsUHJlZml4ZXMgPSB7fTtcbiAgICAgICAgaWYgKHhtbG5zUHJlZml4TWFwcGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlLnN0YXJ0c1dpdGgoJ3htbG5zJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByZWZpeGVzW2F0dHJpYnV0ZS5zdWJzdHIoNildID0gYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcy5wcmVmaXggfHwgT2JqZWN0LmtleXMoYWRkaXRpb25hbFByZWZpeGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXhlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50UHJlZml4ZXMpLCBhZGRpdGlvbmFsUHJlZml4ZXMpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZWZpeE1hdGNoO1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgd2hpbGUgKHByZWZpeE1hdGNoID0gVXRpbC5QUkVGSVhfUkVHRVguZXhlYyhhdHRyaWJ1dGVzLnByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ZXNbcHJlZml4TWF0Y2hbMV1dID0gcHJlZml4TWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFByZWZpeGVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGFuZCB0aGUgZ2l2ZW4gdGVybSB2YWx1ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gcHJlZml4ZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlcm0gQSB0ZXJtIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7e1twOiBzdHJpbmddOiBzdHJpbmd9W119IHByZWZpeGVzIFRoZSBhdmFpbGFibGUgcHJlZml4ZXMuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBbiBleHBhbmRlZCBVUkwsIG9yIHRoZSB0ZXJtIGFzLWlzLlxuICAgICAqL1xuICAgIHN0YXRpYyBleHBhbmRQcmVmaXhlZFRlcm0odGVybSwgYWN0aXZlVGFnKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB0ZXJtIGlzIHByZWZpeGVkXG4gICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSB0ZXJtLmluZGV4T2YoJzonKTtcbiAgICAgICAgbGV0IHByZWZpeDtcbiAgICAgICAgbGV0IGxvY2FsO1xuICAgICAgICBpZiAoY29sb25JbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBwcmVmaXggPSB0ZXJtLnN1YnN0cigwLCBjb2xvbkluZGV4KTtcbiAgICAgICAgICAgIGxvY2FsID0gdGVybS5zdWJzdHIoY29sb25JbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4cGFuZCBkZWZhdWx0IG5hbWVzcGFjZVxuICAgICAgICBpZiAocHJlZml4ID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiIycgKyBsb2NhbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gZXhwYW5kIHRoZSBwcmVmaXhcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4RWxlbWVudCA9IGFjdGl2ZVRhZy5wcmVmaXhlc0FsbFtwcmVmaXhdO1xuICAgICAgICAgICAgaWYgKHByZWZpeEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4RWxlbWVudCArIGxvY2FsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBleHBhbmQgdGhlIHRlcm1cbiAgICAgICAgaWYgKHRlcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkVGVybSA9IGFjdGl2ZVRhZy5wcmVmaXhlc0FsbFt0ZXJtLnRvTG9jYWxlTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKGV4cGFuZGVkVGVybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZFRlcm07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBJUkkgaXMgdmFsaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlyaSBBIHBvdGVudGlhbCBJUkkuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGdpdmVuIElSSSBpcyB2YWxpZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZElyaShpcmkpIHtcbiAgICAgICAgcmV0dXJuIFV0aWwuSVJJX1JFR0VYLnRlc3QoaXJpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBSREZhIHByb2ZpbGUgZnJvbSB0aGUgZ2l2ZW4gY29udGVudCB0eXBlLlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBkZWZhdWx0IFJERmEgcHJvZmlsZSAoYWxsIGZlYXR1cmVzIGVuYWJsZWQpIGZvciB1bmtub3duIGNvbnRlbnQgdHlwZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIEEgY29udGVudCB0eXBlLlxuICAgICAqIEByZXR1cm5zIHtSZGZhUHJvZmlsZX0gQW4gUkRGYSBwcm9maWxlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb250ZW50VHlwZVRvUHJvZmlsZShjb250ZW50VHlwZSkge1xuICAgICAgICByZXR1cm4gUmRmYVByb2ZpbGVfMS5SREZBX0NPTlRFTlRUWVBFU1tjb250ZW50VHlwZV0gfHwgJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYmFzZSBJUkkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VJcmlWYWx1ZSBBIGJhc2UgSVJJIHZhbHVlLlxuICAgICAqIEByZXR1cm4gQSBiYXNlIElSSSBuYW1lZCBub2RlLlxuICAgICAqL1xuICAgIGdldEJhc2VJUkkoYmFzZUlyaVZhbHVlKSB7XG4gICAgICAgIGxldCBocmVmID0gYmFzZUlyaVZhbHVlO1xuICAgICAgICBjb25zdCBmcmFnbWVudEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gICAgICAgIGlmIChmcmFnbWVudEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnN1YnN0cigwLCBmcmFnbWVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhRmFjdG9yeS5uYW1lZE5vZGUocmVsYXRpdmVfdG9fYWJzb2x1dGVfaXJpXzEucmVzb2x2ZShocmVmLCB0aGlzLmJhc2VJUkkudmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRlcm0gaXMgYSBib29sZWFuLCByZXR1cm4gdGhlIGJhc2VJUkksIG90aGVyd2lzZSByZXR1cm4gdGhlIHRlcm0gYXMtaXMuXG4gICAgICogQHBhcmFtIHtUZXJtIHwgYm9vbGVhbn0gdGVybSBBIHRlcm0gb3IgYm9vbGVhbiwgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoZSBiYXNlSVJJLlxuICAgICAqIEBwYXJhbSB7SUFjdGl2ZVRhZ30gYWN0aXZlVGFnIEFuIGFjdGl2ZSB0YWcuXG4gICAgICogQHJldHVybnMge1Rlcm19IEEgdGVybS5cbiAgICAgKi9cbiAgICBnZXRSZXNvdXJjZU9yQmFzZUlyaSh0ZXJtLCBhY3RpdmVUYWcpIHtcbiAgICAgICAgcmV0dXJuIHRlcm0gPT09IHRydWUgPyB0aGlzLmdldEJhc2VJcmlUZXJtKGFjdGl2ZVRhZykgOiB0ZXJtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGFjdGl2ZSBiYXNlIElSSSBhcyBhbiBSREYgdGVybS5cbiAgICAgKiBAcGFyYW0ge0lBY3RpdmVUYWd9IGFjdGl2ZVRhZyBUaGUgYWN0aXZlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtOYW1lZE5vZGV9IFRoZSBiYXNlIElSSSB0ZXJtLlxuICAgICAqL1xuICAgIGdldEJhc2VJcmlUZXJtKGFjdGl2ZVRhZykge1xuICAgICAgICByZXR1cm4gYWN0aXZlVGFnLmxvY2FsQmFzZUlSSSB8fCB0aGlzLmJhc2VJUkk7XG4gICAgfVxuICAgIGNyZWF0ZVZvY2FiSXJpcyh0ZXJtcywgYWN0aXZlVGFnLCBhbGxvd1Rlcm1zLCBhbGxvd0JsYW5rTm9kZSkge1xuICAgICAgICByZXR1cm4gdGVybXMuc3BsaXQoL1xccysvKVxuICAgICAgICAgICAgLmZpbHRlcigodGVybSkgPT4gdGVybSAmJiAoYWxsb3dUZXJtcyB8fCB0ZXJtLmluZGV4T2YoJzonKSA+PSAwKSlcbiAgICAgICAgICAgIC5tYXAoKHByb3BlcnR5KSA9PiB0aGlzLmNyZWF0ZUlyaShwcm9wZXJ0eSwgYWN0aXZlVGFnLCB0cnVlLCB0cnVlLCBhbGxvd0JsYW5rTm9kZSkpXG4gICAgICAgICAgICAuZmlsdGVyKCh0ZXJtKSA9PiB0ZXJtICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbGl0ZXJhbCBub2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaXRlcmFsIFRoZSBsaXRlcmFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7SUFjdGl2ZVRhZ30gYWN0aXZlVGFnIFRoZSBjdXJyZW50IGFjdGl2ZSB0YWcuXG4gICAgICogQHJldHVybiB7TGl0ZXJhbH0gQSBuZXcgbGl0ZXJhbCBub2RlLlxuICAgICAqL1xuICAgIGNyZWF0ZUxpdGVyYWwobGl0ZXJhbCwgYWN0aXZlVGFnKSB7XG4gICAgICAgIGlmIChhY3RpdmVUYWcuaW50ZXJwcmV0T2JqZWN0QXNUaW1lICYmICFhY3RpdmVUYWcuZGF0YXR5cGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgVXRpbC5USU1FX1JFR0VYRVMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbC5tYXRjaChlbnRyeS5yZWdleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFnLmRhdGF0eXBlID0gdGhpcy5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoVXRpbC5YU0QgKyBlbnRyeS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFGYWN0b3J5LmxpdGVyYWwobGl0ZXJhbCwgYWN0aXZlVGFnLmRhdGF0eXBlIHx8IGFjdGl2ZVRhZy5sYW5ndWFnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGJsYW5rIG5vZGUuXG4gICAgICogQHJldHVybnMge0JsYW5rTm9kZX0gQSBuZXcgYmxhbmsgbm9kZS5cbiAgICAgKi9cbiAgICBjcmVhdGVCbGFua05vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJsYW5rTm9kZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsYW5rTm9kZUZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhRmFjdG9yeS5ibGFua05vZGUoKTtcbiAgICB9XG4gICAgY3JlYXRlSXJpKHRlcm0sIGFjdGl2ZVRhZywgdm9jYWIsIGFsbG93U2FmZUN1cmllLCBhbGxvd0JsYW5rTm9kZSkge1xuICAgICAgICB0ZXJtID0gdGVybSB8fCAnJztcbiAgICAgICAgaWYgKCFhbGxvd1NhZmVDdXJpZSkge1xuICAgICAgICAgICAgaWYgKCF2b2NhYikge1xuICAgICAgICAgICAgICAgIHRlcm0gPSByZWxhdGl2ZV90b19hYnNvbHV0ZV9pcmlfMS5yZXNvbHZlKHRlcm0sIHRoaXMuZ2V0QmFzZUlyaVRlcm0oYWN0aXZlVGFnKS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVV0aWwuaXNWYWxpZElyaSh0ZXJtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZhY3RvcnkubmFtZWROb2RlKHRlcm0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBzdHJpY3QgQ1VSSUVzXG4gICAgICAgIGlmICh0ZXJtLmxlbmd0aCA+IDAgJiYgdGVybVswXSA9PT0gJ1snICYmIHRlcm1bdGVybS5sZW5ndGggLSAxXSA9PT0gJ10nKSB7XG4gICAgICAgICAgICB0ZXJtID0gdGVybS5zdWJzdHIoMSwgdGVybS5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgIC8vIFN0cmljdCBDVVJJRXMgTVVTVCBoYXZlIGEgcHJlZml4IHNlcGFyYXRvclxuICAgICAgICAgICAgaWYgKHRlcm0uaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBibGFuayBub2Rlc1xuICAgICAgICBpZiAodGVybS5zdGFydHNXaXRoKCdfOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxsb3dCbGFua05vZGUgPyB0aGlzLmRhdGFGYWN0b3J5LmJsYW5rTm9kZSh0ZXJtLnN1YnN0cigyKSB8fCAnYl9pZGVudGl0eScpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdm9jYWIgSVJJc1xuICAgICAgICBpZiAodm9jYWIpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVUYWcudm9jYWIgJiYgdGVybS5pbmRleE9mKCc6JykgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZhY3RvcnkubmFtZWROb2RlKGFjdGl2ZVRhZy52b2NhYiArIHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBwcmVmaXhlZCBJUklzXG4gICAgICAgIGxldCBpcmkgPSBVdGlsLmV4cGFuZFByZWZpeGVkVGVybSh0ZXJtLCBhY3RpdmVUYWcpO1xuICAgICAgICAvLyBSZXNvbHZlIGFnYWluc3QgYmFzZUlSSSBpZiBpbiBiYXNlLW1vZGUsIG9yIGlmIHRoZSB0ZXJtIHdhcyBhIHByZWZpeGVkIHJlbGF0aXZlIElSSVxuICAgICAgICBpZiAoIXZvY2FiKSB7XG4gICAgICAgICAgICBpcmkgPSByZWxhdGl2ZV90b19hYnNvbHV0ZV9pcmlfMS5yZXNvbHZlKGlyaSwgdGhpcy5nZXRCYXNlSXJpVGVybShhY3RpdmVUYWcpLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXJtICE9PSBpcmkpIHtcbiAgICAgICAgICAgIGlyaSA9IHJlbGF0aXZlX3RvX2Fic29sdXRlX2lyaV8xLnJlc29sdmUoaXJpLCB0aGlzLmJhc2VJUklEb2N1bWVudC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFVdGlsLmlzVmFsaWRJcmkoaXJpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZhY3RvcnkubmFtZWROb2RlKGlyaSk7XG4gICAgfVxufVxuZXhwb3J0cy5VdGlsID0gVXRpbDtcblV0aWwuUkRGID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMnO1xuVXRpbC5YU0QgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjJztcblV0aWwuUkRGQSA9ICdodHRwOi8vd3d3LnczLm9yZy9ucy9yZGZhIyc7XG5VdGlsLlBSRUZJWF9SRUdFWCA9IC9cXHMqKFteOlxcc10qKSo6XFxzKihbXlxcc10qKSpcXHMqL2c7XG5VdGlsLlRJTUVfUkVHRVhFUyA9IFtcbiAgICB7XG4gICAgICAgIHJlZ2V4OiAvXi0/UChbMC05XStZKT8oWzAtOV0rTSk/KFswLTldK0QpPyhUKFswLTldK0gpPyhbMC05XStNKT8oWzAtOV0rKFxcLlswLTldKT9TKT8pPyQvLFxuICAgICAgICB0eXBlOiAnZHVyYXRpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICByZWdleDogL15bMC05XSstWzAtOV1bMC05XS1bMC05XVswLTldVFswLTldWzAtOV06WzAtOV1bMC05XTpbMC05XVswLTldKChaPyl8KFtcXCstXVswLTldWzAtOV06WzAtOV1bMC05XSkpJC8sXG4gICAgICAgIHR5cGU6ICdkYXRlVGltZScsXG4gICAgfSxcbiAgICB7IHJlZ2V4OiAvXlswLTldKy1bMC05XVswLTldLVswLTldWzAtOV1aPyQvLCB0eXBlOiAnZGF0ZScgfSxcbiAgICB7IHJlZ2V4OiAvXlswLTldWzAtOV06WzAtOV1bMC05XTpbMC05XVswLTldKChaPyl8KFtcXCstXVswLTldWzAtOV06WzAtOV1bMC05XSkpJC8sIHR5cGU6ICd0aW1lJyB9LFxuICAgIHsgcmVnZXg6IC9eWzAtOV0rLVswLTldWzAtOV0kLywgdHlwZTogJ2dZZWFyTW9udGgnIH0sXG4gICAgeyByZWdleDogL15bMC05XSskLywgdHlwZTogJ2dZZWFyJyB9LFxuXTtcblV0aWwuSVJJX1JFR0VYID0gL14oW0EtWmEtel1bQS1aYS16MC05Ky0uXSp8Xyk6W14gXCI8Pnt9fFxcXFxcXFtcXF1gXSokLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVV0aWwuanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkBjb250ZXh0XCI6IHtcbiAgICBcImFsdGVybmF0ZVwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjYWx0ZXJuYXRlXCIsXG4gICAgXCJhcHBlbmRpeFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjYXBwZW5kaXhcIixcbiAgICBcImNpdGVcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2NpdGVcIixcbiAgICBcImJvb2ttYXJrXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNib29rbWFya1wiLFxuICAgIFwiY29udGVudHNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2NvbnRlbnRzXCIsXG4gICAgXCJjaGFwdGVyXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNjaGFwdGVyXCIsXG4gICAgXCJjb3B5cmlnaHRcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2NvcHlyaWdodFwiLFxuICAgIFwiZmlyc3RcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2ZpcnN0XCIsXG4gICAgXCJnbG9zc2FyeVwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjZ2xvc3NhcnlcIixcbiAgICBcImhlbHBcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2hlbHBcIixcbiAgICBcImljb25cIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2ljb25cIixcbiAgICBcImluZGV4XCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNpbmRleFwiLFxuICAgIFwibGFzdFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjbGFzdFwiLFxuICAgIFwibGljZW5zZVwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjbGljZW5zZVwiLFxuICAgIFwibWV0YVwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjbWV0YVwiLFxuICAgIFwibmV4dFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjbmV4dFwiLFxuICAgIFwicHJldlwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjcHJldlwiLFxuICAgIFwicHJldmlvdXNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI3ByZXZpb3VzXCIsXG4gICAgXCJzZWN0aW9uXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNzZWN0aW9uXCIsXG4gICAgXCJzdGFydFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjc3RhcnRcIixcbiAgICBcInN0eWxlc2hlZXRcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI3N0eWxlc2hlZXRcIixcbiAgICBcInN1YnNlY3Rpb25cIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI3N1YnNlY3Rpb25cIixcbiAgICBcInRvcFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjdG9wXCIsXG4gICAgXCJ1cFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjdXBcIixcbiAgICBcInAzcHYxXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNwM3B2MVwiXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJAY29udGV4dFwiOiB7XG4gICAgXCJhc1wiOiBcImh0dHBzOi8vd3d3LnczLm9yZy9ucy9hY3Rpdml0eXN0cmVhbXMjXCIsXG4gICAgXCJjYXRcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9kY2F0I1wiLFxuICAgIFwiY2NcIjogXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcIixcbiAgICBcImNudFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDgvY29udGVudCNcIixcbiAgICBcImNzdndcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9jc3Z3I1wiLFxuICAgIFwiY3RhZ1wiOiBcImh0dHA6Ly9jb21tb250YWcub3JnL25zI1wiLFxuICAgIFwiZGNcIjogXCJodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvXCIsXG4gICAgXCJkYzExXCI6IFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cIixcbiAgICBcImRjYXRcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9kY2F0I1wiLFxuICAgIFwiZGN0ZXJtc1wiOiBcImh0dHA6Ly9wdXJsLm9yZy9kYy90ZXJtcy9cIixcbiAgICBcImRxdlwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL2RxdiNcIixcbiAgICBcImR1dlwiOiBcImh0dHBzOi8vd3d3LnczLm9yZy9UUi92b2NhYi1kdXYjXCIsXG4gICAgXCJlYXJsXCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvZWFybCNcIixcbiAgICBcImZvYWZcIjogXCJodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xL1wiLFxuICAgIFwiZ2xkcFwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL3Blb3BsZSNcIixcbiAgICBcImdyXCI6IFwiaHR0cDovL3B1cmwub3JnL2dvb2RyZWxhdGlvbnMvdjEjXCIsXG4gICAgXCJncmRkbFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDMvZy9kYXRhLXZpZXcjXCIsXG4gICAgXCJodFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDYvaHR0cCNcIixcbiAgICBcImljYWxcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAyLzEyL2NhbC9pY2FsdHpkI1wiLFxuICAgIFwibGRwXCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvbGRwI1wiLFxuICAgIFwibWFcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9tYS1vbnQjXCIsXG4gICAgXCJvYVwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL29hI1wiLFxuICAgIFwib2RybFwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL29kcmwvMi9cIixcbiAgICBcIm9nXCI6IFwiaHR0cDovL29ncC5tZS9ucyNcIixcbiAgICBcIm9yZ1wiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL29yZyNcIixcbiAgICBcIm93bFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDIvMDcvb3dsI1wiLFxuICAgIFwicHJvdlwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL3Byb3YjXCIsXG4gICAgXCJwdHJcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDA5L3BvaW50ZXJzI1wiLFxuICAgIFwicWJcIjogXCJodHRwOi8vcHVybC5vcmcvbGlua2VkLWRhdGEvY3ViZSNcIixcbiAgICBcInJldlwiOiBcImh0dHA6Ly9wdXJsLm9yZy9zdHVmZi9yZXYjXCIsXG4gICAgXCJyZGZcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXCIsXG4gICAgXCJyZGZhXCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvcmRmYSNcIixcbiAgICBcInJkZnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzAxL3JkZi1zY2hlbWEjXCIsXG4gICAgXCJyaWZcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDA3L3JpZiNcIixcbiAgICBcInJyXCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvcjJybWwjXCIsXG4gICAgXCJzY2hlbWFcIjogXCJodHRwOi8vc2NoZW1hLm9yZy9cIixcbiAgICBcInNkXCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvc3BhcnFsLXNlcnZpY2UtZGVzY3JpcHRpb24jXCIsXG4gICAgXCJzaW9jXCI6IFwiaHR0cDovL3JkZnMub3JnL3Npb2MvbnMjXCIsXG4gICAgXCJza29zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwNC8wMi9za29zL2NvcmUjXCIsXG4gICAgXCJza29zeGxcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDA4LzA1L3Nrb3MteGwjXCIsXG4gICAgXCJzc25cIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9zc24vXCIsXG4gICAgXCJzb3NhXCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvc29zYS9cIixcbiAgICBcInRpbWVcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDA2L3RpbWUjXCIsXG4gICAgXCJ2XCI6IFwiaHR0cDovL3JkZi5kYXRhLXZvY2FidWxhcnkub3JnLyNcIixcbiAgICBcInZjYXJkXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwNi92Y2FyZC9ucyNcIixcbiAgICBcInZvaWRcIjogXCJodHRwOi8vcmRmcy5vcmcvbnMvdm9pZCNcIixcbiAgICBcIndkclwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDcvMDUvcG93ZGVyI1wiLFxuICAgIFwid2Ryc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDcvMDUvcG93ZGVyLXMjXCIsXG4gICAgXCJ4aHZcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI1wiLFxuICAgIFwieG1sXCI6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gICAgXCJ4c2RcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNcIixcbiAgICBcImRlc2NyaWJlZGJ5XCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwNy8wNS9wb3dkZXItcyNkZXNjcmliZWRieVwiLFxuICAgIFwibGljZW5zZVwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjbGljZW5zZVwiLFxuICAgIFwicm9sZVwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjcm9sZVwiXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjb2RlcyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgcmV0dXJuIF9CYXNlLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTtcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZTtcbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gJ1RoZSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInICsgbmFtZSArICdcIic7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9XG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYWN0dWFsKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YnLCAnc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ1RoZSAnICsgbmFtZSArICcgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdDYW5ub3QgY2FsbCAnICsgbmFtZSArICcgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfVU5LTk9XTl9FTkNPRElORycsIGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HLFxuICAgIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcbiAgY2IoZXIpO1xuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07IC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH0gLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuXG5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59OyAvLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3RyYW5zZm9ybSgpJykpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcblxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07IC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG5cbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7IC8vIFRPRE8oQnJpZGdlQVIpOiBXcml0ZSBhIHRlc3QgZm9yIHRoZXNlIHR3byBlcnJvciBjYXNlc1xuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wKCk7XG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuLyogPHJlcGxhY2VtZW50PiAqL1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5cblxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gICAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcblxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7IC8vIGRyYWluIGV2ZW50IGZsYWcuXG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcblxuICB0aGlzLmVuZGluZyA9IGZhbHNlOyAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlOyAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcblxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cblxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG5cbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlOyAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG5cbiAgdGhpcy5jb3JrZWQgPSAwOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOyAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG5cbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG5cblxuICB0aGlzLndyaXRlY2IgPSBudWxsOyAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7IC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuXG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTsgLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG5cblxudmFyIHJlYWxIYXNJbnN0YW5jZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7IC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeS5cblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59IC8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cblxuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbn0gLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuXG5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XG4gIH1cblxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pOyAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7IC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpO2Vsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cblxuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59IC8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5cblxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7IC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG5cbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7IC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfSAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG5cblxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcblxuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuYXV0b0Rlc3Ryb3kgJiYgclN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuXG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzcy5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcblxuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfSAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuXG5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcblxudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xuXG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTsgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXG4gICAgLy8gd2UgY2FuIGJlIGV4cGVjdGluZyBlaXRoZXIgJ2VuZCcgb3JcbiAgICAvLyAnZXJyb3InXG5cbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5cbmZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXRlcltrRW5kZWRdKSB7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG5cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcblxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRW5kZWRdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG5cblxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cblxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIGRlc3Ryb3koZXJyLCBjYikgaXMgYSBwcml2YXRlIEFQSVxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXG4gIC8vIFJlYWRhYmxlIGNsYXNzIHRoaXMgaXMgYXR0YWNoZWQgdG9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG5cbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcblxuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwge1xuICAgIHZhbHVlOiBzdHJlYW0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHtcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07IC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcblxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcblxuICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgIG4gLT0gcC5kYXRhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpO1xuICBlbWl0Q2xvc2VOVChzZWxmKTtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9lbmQtb2Ytc3RyZWFtIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG5cbiAgdmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24gb25sZWdhY3lmaW5pc2goKSB7XG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG4gIH07XG5cbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuXG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciByZWFkYWJsZUVuZGVkID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkO1xuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcblxuICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgdmFyIGVycjtcblxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uIG9ucmVxdWVzdCgpIHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIH07XG5cbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXG59O1xuIiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW9zO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5cbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTsgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpO1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cblxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cblxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDtcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xuICByZXR1cm4gc3RyZWFtcy5wb3AoKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpO1xuICB9XG5cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9JTlZBTElEX09QVF9WQUxVRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcblxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuXG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfSAvLyBEZWZhdWx0IHZhbHVlXG5cblxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9saWIvUmVzb2x2ZVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gcmVsYXRpdmUgSVJJIHRvIGFuIGFic29sdXRlIElSSVxuICogYnkgdGFraW5nIGludG8gYWNjb3VudCB0aGUgZ2l2ZW4gb3B0aW9uYWwgYmFzZUlSSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVJUkkgVGhlIHJlbGF0aXZlIElSSSB0byBjb252ZXJ0IHRvIGFuIGFic29sdXRlIElSSS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlSVJJIFRoZSBvcHRpb25hbCBiYXNlIElSSS5cbiAqIEByZXR1cm4ge3N0cmluZ30gYW4gYWJzb2x1dGUgSVJJLlxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlSVJJLCBiYXNlSVJJKSB7XG4gICAgYmFzZUlSSSA9IGJhc2VJUkkgfHwgJyc7XG4gICAgY29uc3QgYmFzZUZyYWdtZW50UG9zID0gYmFzZUlSSS5pbmRleE9mKCcjJyk7XG4gICAgLy8gSWdub3JlIGFueSBmcmFnbWVudHMgaW4gdGhlIGJhc2UgSVJJXG4gICAgaWYgKGJhc2VGcmFnbWVudFBvcyA+IDApIHtcbiAgICAgICAgYmFzZUlSSSA9IGJhc2VJUkkuc3Vic3RyKDAsIGJhc2VGcmFnbWVudFBvcyk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgZW1wdHkgdmFsdWUgZGlyZWN0bHkgdG8gYmFzZSBJUklcbiAgICBpZiAoIXJlbGF0aXZlSVJJLmxlbmd0aCkge1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgYmFzZUlSSSBNVVNUIGJlIGFic29sdXRlLCBvdGhlcndpc2Ugd2UgZXJyb3JcbiAgICAgICAgaWYgKGJhc2VJUkkuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBpbnZhbGlkIGJhc2VJUkkgJyR7YmFzZUlSSX0nIGZvciB2YWx1ZSAnJHtyZWxhdGl2ZUlSSX0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VJUkk7XG4gICAgfVxuICAgIC8vIElmIHRoZSB2YWx1ZSBzdGFydHMgd2l0aCBhIHF1ZXJ5IGNoYXJhY3RlciwgY29uY2F0IGRpcmVjdGx5IChidXQgc3RyaXAgdGhlIGV4aXN0aW5nIHF1ZXJ5KVxuICAgIGlmIChyZWxhdGl2ZUlSSS5zdGFydHNXaXRoKCc/JykpIHtcbiAgICAgICAgY29uc3QgYmFzZVF1ZXJ5UG9zID0gYmFzZUlSSS5pbmRleE9mKCc/Jyk7XG4gICAgICAgIGlmIChiYXNlUXVlcnlQb3MgPiAwKSB7XG4gICAgICAgICAgICBiYXNlSVJJID0gYmFzZUlSSS5zdWJzdHIoMCwgYmFzZVF1ZXJ5UG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZUlSSSArIHJlbGF0aXZlSVJJO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgdmFsdWUgc3RhcnRzIHdpdGggYSBmcmFnbWVudCBjaGFyYWN0ZXIsIGNvbmNhdCBkaXJlY3RseVxuICAgIGlmIChyZWxhdGl2ZUlSSS5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJUkkgKyByZWxhdGl2ZUlSSTtcbiAgICB9XG4gICAgLy8gSWdub3JlIGJhc2VJUkkgaWYgaXQgaXMgZW1wdHlcbiAgICBpZiAoIWJhc2VJUkkubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlQ29sb25Qb3MgPSByZWxhdGl2ZUlSSS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmIChyZWxhdGl2ZUNvbG9uUG9zIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBpbnZhbGlkIHJlbGF0aXZlIElSSSAnJHtyZWxhdGl2ZUlSSX0nIGZvciBhIG1pc3NpbmcgYmFzZUlSSWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVEb3RTZWdtZW50c09mUGF0aChyZWxhdGl2ZUlSSSwgcmVsYXRpdmVDb2xvblBvcyk7XG4gICAgfVxuICAgIC8vIElnbm9yZSBiYXNlSVJJIGlmIHRoZSB2YWx1ZSBpcyBhYnNvbHV0ZVxuICAgIGNvbnN0IHZhbHVlQ29sb25Qb3MgPSByZWxhdGl2ZUlSSS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKHZhbHVlQ29sb25Qb3MgPj0gMCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRG90U2VnbWVudHNPZlBhdGgocmVsYXRpdmVJUkksIHZhbHVlQ29sb25Qb3MpO1xuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgYmFzZUlSSSBNVVNUIGJlIGFic29sdXRlLCBvdGhlcndpc2Ugd2UgZXJyb3JcbiAgICBjb25zdCBiYXNlQ29sb25Qb3MgPSBiYXNlSVJJLmluZGV4T2YoJzonKTtcbiAgICBpZiAoYmFzZUNvbG9uUG9zIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGludmFsaWQgYmFzZUlSSSAnJHtiYXNlSVJJfScgZm9yIHZhbHVlICcke3JlbGF0aXZlSVJJfSdgKTtcbiAgICB9XG4gICAgY29uc3QgYmFzZUlSSVNjaGVtZSA9IGJhc2VJUkkuc3Vic3RyKDAsIGJhc2VDb2xvblBvcyArIDEpO1xuICAgIC8vIEluaGVyaXQgdGhlIGJhc2VJUkkgc2NoZW1lIGlmIHRoZSB2YWx1ZSBzdGFydHMgd2l0aCAnLy8nXG4gICAgaWYgKHJlbGF0aXZlSVJJLmluZGV4T2YoJy8vJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJUklTY2hlbWUgKyByZW1vdmVEb3RTZWdtZW50c09mUGF0aChyZWxhdGl2ZUlSSSwgdmFsdWVDb2xvblBvcyk7XG4gICAgfVxuICAgIC8vIENoZWNrIGNhc2VzIHdoZXJlICc6Ly8nIG9jY3VycyBpbiB0aGUgYmFzZUlSSSwgYW5kIHdoZXJlIHRoZXJlIGlzIG5vICcvJyBhZnRlciBhICc6JyBhbnltb3JlLlxuICAgIGxldCBiYXNlU2xhc2hBZnRlckNvbG9uUG9zO1xuICAgIGlmIChiYXNlSVJJLmluZGV4T2YoJy8vJywgYmFzZUNvbG9uUG9zKSA9PT0gYmFzZUNvbG9uUG9zICsgMSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBhZGRpdGlvbmFsICcvJyBhZnRlciB0aGUgJy8vJy5cbiAgICAgICAgYmFzZVNsYXNoQWZ0ZXJDb2xvblBvcyA9IGJhc2VJUkkuaW5kZXhPZignLycsIGJhc2VDb2xvblBvcyArIDMpO1xuICAgICAgICBpZiAoYmFzZVNsYXNoQWZ0ZXJDb2xvblBvcyA8IDApIHtcbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgJy8nIGZvbGxvd3MgdGhlICc6Ly8nLCBhcHBlbmQgdGhlIHZhbHVlIGFmdGVyIGEgJy8nLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBwcmVmaXggdGhlIHZhbHVlIHdpdGggb25seSB0aGUgYmFzZUlSSSBzY2hlbWUuXG4gICAgICAgICAgICBpZiAoYmFzZUlSSS5sZW5ndGggPiBiYXNlQ29sb25Qb3MgKyAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VJUkkgKyAnLycgKyByZW1vdmVEb3RTZWdtZW50c09mUGF0aChyZWxhdGl2ZUlSSSwgdmFsdWVDb2xvblBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZUlSSVNjaGVtZSArIHJlbW92ZURvdFNlZ21lbnRzT2ZQYXRoKHJlbGF0aXZlSVJJLCB2YWx1ZUNvbG9uUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IGV2ZW4gYSBzaW5nbGUgJy8nIGFmdGVyIHRoZSAnOidcbiAgICAgICAgYmFzZVNsYXNoQWZ0ZXJDb2xvblBvcyA9IGJhc2VJUkkuaW5kZXhPZignLycsIGJhc2VDb2xvblBvcyArIDEpO1xuICAgICAgICBpZiAoYmFzZVNsYXNoQWZ0ZXJDb2xvblBvcyA8IDApIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSAnLycgYWZ0ZXIgdGhlICc6JyxcbiAgICAgICAgICAgIC8vIHByZWZpeCB0aGUgdmFsdWUgd2l0aCBvbmx5IHRoZSBiYXNlSVJJIHNjaGVtZS5cbiAgICAgICAgICAgIHJldHVybiBiYXNlSVJJU2NoZW1lICsgcmVtb3ZlRG90U2VnbWVudHNPZlBhdGgocmVsYXRpdmVJUkksIHZhbHVlQ29sb25Qb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSB2YWx1ZSBzdGFydHMgd2l0aCBhICcvJywgdGhlbiBwcmVmaXggaXQgd2l0aCBldmVyeXRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgZWZmZWN0aXZlIHNsYXNoIG9mIHRoZSBiYXNlIElSSS5cbiAgICBpZiAocmVsYXRpdmVJUkkuaW5kZXhPZignLycpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiYXNlSVJJLnN1YnN0cigwLCBiYXNlU2xhc2hBZnRlckNvbG9uUG9zKSArIHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlSVJJKTtcbiAgICB9XG4gICAgbGV0IGJhc2VJUklQYXRoID0gYmFzZUlSSS5zdWJzdHIoYmFzZVNsYXNoQWZ0ZXJDb2xvblBvcyk7XG4gICAgY29uc3QgYmFzZUlSSUxhc3RTbGFzaFBvcyA9IGJhc2VJUklQYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGxhc3QgJy8nIGluIHRoZSBiYXNlSVJJIHBhdGhcbiAgICBpZiAoYmFzZUlSSUxhc3RTbGFzaFBvcyA+PSAwICYmIGJhc2VJUklMYXN0U2xhc2hQb3MgPCBiYXNlSVJJUGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGJhc2VJUklQYXRoID0gYmFzZUlSSVBhdGguc3Vic3RyKDAsIGJhc2VJUklMYXN0U2xhc2hQb3MgKyAxKTtcbiAgICAgICAgLy8gQWxzbyByZW1vdmUgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgcmVsYXRpdmUgcGF0aCBpZiBpdCBzdGFydHMgd2l0aCAnLicgKGFuZCBub3QgJy4uJyBvciAnLi8nKVxuICAgICAgICAvLyBUaGlzIGNoYW5nZSBpcyBvbmx5IGFsbG93ZWQgaWYgdGhlcmUgaXMgc29tZXRoaW5nIGVsc2UgZm9sbG93aW5nIHRoZSBwYXRoXG4gICAgICAgIGlmIChyZWxhdGl2ZUlSSVswXSA9PT0gJy4nICYmIHJlbGF0aXZlSVJJWzFdICE9PSAnLicgJiYgcmVsYXRpdmVJUklbMV0gIT09ICcvJyAmJiByZWxhdGl2ZUlSSVsyXSkge1xuICAgICAgICAgICAgcmVsYXRpdmVJUkkgPSByZWxhdGl2ZUlSSS5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJlZml4IHRoZSB2YWx1ZSB3aXRoIHRoZSBiYXNlSVJJIHBhdGggd2hlcmVcbiAgICByZWxhdGl2ZUlSSSA9IGJhc2VJUklQYXRoICsgcmVsYXRpdmVJUkk7XG4gICAgLy8gUmVtb3ZlIGRvdCBzZWdtZW50IGZyb20gdGhlIElSSVxuICAgIHJlbGF0aXZlSVJJID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmVJUkkpO1xuICAgIC8vIFByZWZpeCBvdXIgdHJhbnNmb3JtZWQgdmFsdWUgd2l0aCB0aGUgcGFydCBvZiB0aGUgYmFzZUlSSSB1bnRpbCB0aGUgZmlyc3QgJy8nIGFmdGVyIHRoZSBmaXJzdCAnOicuXG4gICAgcmV0dXJuIGJhc2VJUkkuc3Vic3RyKDAsIGJhc2VTbGFzaEFmdGVyQ29sb25Qb3MpICsgcmVsYXRpdmVJUkk7XG59XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlO1xuLyoqXG4gKiBSZW1vdmUgZG90IHNlZ21lbnRzIGZyb20gdGhlIGdpdmVuIHBhdGgsXG4gKiBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzM5ODYudHh0IChwYWdlIDMyKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIEFuIElSSSBwYXRoLlxuICogQHJldHVybiB7c3RyaW5nfSBBIHBhdGgsIHdpbGwgYWx3YXlzIHN0YXJ0IHdpdGggYSAnLycuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKHBhdGgpIHtcbiAgICAvLyBQcmVwYXJlIGEgYnVmZmVyIHdpdGggc2VnbWVudHMgYmV0d2VlbiBlYWNoICcvLlxuICAgIC8vIEVhY2ggc2VnbWVudCByZXByZXNlbnRzIGFuIGFycmF5IG9mIGNoYXJhY3RlcnMuXG4gICAgY29uc3Qgc2VnbWVudEJ1ZmZlcnMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBwYXRoLmxlbmd0aCkge1xuICAgICAgICAvLyBSZW1vdmUgJy8uJyBvciAnLy4uJ1xuICAgICAgICBzd2l0Y2ggKHBhdGhbaV0pIHtcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIGlmIChwYXRoW2kgKyAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoW2kgKyAyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBhIG5ldyBzZWdtZW50IGlmIHdlIGZpbmQgYW4gaW52YWxpZCBjaGFyYWN0ZXIgYWZ0ZXIgdGhlICcuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NoYXJhY3RlckFsbG93ZWRBZnRlclJlbGF0aXZlUGF0aFNlZ21lbnQocGF0aFtpICsgM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gdG8gcGFyZW50IGRpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIHJlbW92ZSBhIHBhcmVudCBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50QnVmZmVycy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGVuZCB3aXRoIGEgc2xhc2ggaWYgdGhlcmUgaXMgYSB0cmFpbGluZyAnLy4uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoW2kgKyAzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWZmZXJzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgc2VnbWVudCBpZiB3ZSBmaW5kIGFuIGludmFsaWQgY2hhcmFjdGVyIGFmdGVyIHRoZSAnLidcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDaGFyYWN0ZXJBbGxvd2VkQWZ0ZXJSZWxhdGl2ZVBhdGhTZWdtZW50KHBhdGhbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWZmZXJzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGVuZCB3aXRoIGEgc2xhc2ggaWYgdGhlcmUgaXMgYSB0cmFpbGluZyAnLy4nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdGhbaSArIDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHbyB0byB0aGUgY3VycmVudCBkaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgICAgICAgIC8vIFF1ZXJ5IGFuZCBmcmFnbWVudCBzdHJpbmcgc2hvdWxkIGJlIGFwcGVuZGVkIHVuY2hhbmdlZFxuICAgICAgICAgICAgICAgIGlmICghc2VnbWVudEJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWZmZXJzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWdtZW50QnVmZmVyc1tzZWdtZW50QnVmZmVycy5sZW5ndGggLSAxXS5wdXNoKHBhdGguc3Vic3RyKGkpKTtcbiAgICAgICAgICAgICAgICAvLyBCcmVhayB0aGUgd2hpbGUgbG9vcFxuICAgICAgICAgICAgICAgIGkgPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gTm90IGEgc3BlY2lhbCBjaGFyYWN0ZXIsIGp1c3QgYXBwZW5kIGl0IHRvIG91ciBidWZmZXJcbiAgICAgICAgICAgICAgICBpZiAoIXNlZ21lbnRCdWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50QnVmZmVycy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1ZmZlcnNbc2VnbWVudEJ1ZmZlcnMubGVuZ3RoIC0gMV0ucHVzaChwYXRoW2ldKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcvJyArIHNlZ21lbnRCdWZmZXJzLm1hcCgoYnVmZmVyKSA9PiBidWZmZXIuam9pbignJykpLmpvaW4oJy8nKTtcbn1cbmV4cG9ydHMucmVtb3ZlRG90U2VnbWVudHMgPSByZW1vdmVEb3RTZWdtZW50cztcbi8qKlxuICogUmVtb3ZlcyBkb3Qgc2VnbWVudHMgb2YgdGhlIGdpdmVuIElSSS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpcmkgQW4gSVJJIChvciBwYXJ0IG9mIElSSSkuXG4gKiBAcGFyYW0ge251bWJlcn0gY29sb25Qb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0ICc6JyBpbiB0aGUgSVJJLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSVJJIHdoZXJlIGRvdCBzZWdtZW50cyB3ZXJlIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzT2ZQYXRoKGlyaSwgY29sb25Qb3NpdGlvbikge1xuICAgIC8vIERldGVybWluZSB3aGVyZSB3ZSBzaG91bGQgc3RhcnQgbG9va2luZyBmb3IgdGhlIGZpcnN0ICcvJyB0aGF0IGluZGljYXRlcyB0aGUgc3RhcnQgb2YgdGhlIHBhdGhcbiAgICBsZXQgc2VhcmNoT2Zmc2V0ID0gY29sb25Qb3NpdGlvbiArIDE7XG4gICAgaWYgKGNvbG9uUG9zaXRpb24gPj0gMCkge1xuICAgICAgICBpZiAoaXJpW2NvbG9uUG9zaXRpb24gKyAxXSA9PT0gJy8nICYmIGlyaVtjb2xvblBvc2l0aW9uICsgMl0gPT09ICcvJykge1xuICAgICAgICAgICAgc2VhcmNoT2Zmc2V0ID0gY29sb25Qb3NpdGlvbiArIDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpcmlbMF0gPT09ICcvJyAmJiBpcmlbMV0gPT09ICcvJykge1xuICAgICAgICAgICAgc2VhcmNoT2Zmc2V0ID0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHBhdGhcbiAgICBjb25zdCBwYXRoU2VwYXJhdG9yID0gaXJpLmluZGV4T2YoJy8nLCBzZWFyY2hPZmZzZXQpO1xuICAgIGlmIChwYXRoU2VwYXJhdG9yIDwgMCkge1xuICAgICAgICByZXR1cm4gaXJpO1xuICAgIH1cbiAgICBjb25zdCBiYXNlID0gaXJpLnN1YnN0cigwLCBwYXRoU2VwYXJhdG9yKTtcbiAgICBjb25zdCBwYXRoID0gaXJpLnN1YnN0cihwYXRoU2VwYXJhdG9yKTtcbiAgICAvLyBSZW1vdmUgZG90IHNlZ21lbnRzIGZyb20gdGhlIHBhdGhcbiAgICByZXR1cm4gYmFzZSArIHJlbW92ZURvdFNlZ21lbnRzKHBhdGgpO1xufVxuZXhwb3J0cy5yZW1vdmVEb3RTZWdtZW50c09mUGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzT2ZQYXRoO1xuZnVuY3Rpb24gaXNDaGFyYWN0ZXJBbGxvd2VkQWZ0ZXJSZWxhdGl2ZVBhdGhTZWdtZW50KGNoYXJhY3Rlcikge1xuICAgIHJldHVybiAhY2hhcmFjdGVyIHx8IGNoYXJhY3RlciA9PT0gJyMnIHx8IGNoYXJhY3RlciA9PT0gJz8nIHx8IGNoYXJhY3RlciA9PT0gJy8nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzb2x2ZS5qcy5tYXAiLCIvKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuU3RyZWFtLmZpbmlzaGVkID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKVxuU3RyZWFtLnBpcGVsaW5lID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJylcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZYWxsaXN0KSB7XG4gIFlhbGxpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyOyB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgICAgeWllbGQgd2Fsa2VyLnZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG5cbiAgcmV0dXJuIG5leHRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQgLyosIC4uLm5vZGVzICovKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDFcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHZhciByZXQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpXG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbFxuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gaW5zZXJ0KHRoaXMsIHdhbGtlciwgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2XG4gICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dFxuICAgIHdhbGtlci5uZXh0ID0gcFxuICB9XG4gIHRoaXMuaGVhZCA9IHRhaWxcbiAgdGhpcy50YWlsID0gaGVhZFxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBpbnNlcnQgKHNlbGYsIG5vZGUsIHZhbHVlKSB7XG4gIHZhciBpbnNlcnRlZCA9IG5vZGUgPT09IHNlbGYuaGVhZCA/XG4gICAgbmV3IE5vZGUodmFsdWUsIG51bGwsIG5vZGUsIHNlbGYpIDpcbiAgICBuZXcgTm9kZSh2YWx1ZSwgbm9kZSwgbm9kZS5uZXh0LCBzZWxmKVxuXG4gIGlmIChpbnNlcnRlZC5uZXh0ID09PSBudWxsKSB7XG4gICAgc2VsZi50YWlsID0gaW5zZXJ0ZWRcbiAgfVxuICBpZiAoaW5zZXJ0ZWQucHJldiA9PT0gbnVsbCkge1xuICAgIHNlbGYuaGVhZCA9IGluc2VydGVkXG4gIH1cblxuICBzZWxmLmxlbmd0aCsrXG5cbiAgcmV0dXJuIGluc2VydGVkXG59XG5cbmZ1bmN0aW9uIHB1c2ggKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi50YWlsID0gbmV3IE5vZGUoaXRlbSwgc2VsZi50YWlsLCBudWxsLCBzZWxmKVxuICBpZiAoIXNlbGYuaGVhZCkge1xuICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gdW5zaGlmdCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLmhlYWQgPSBuZXcgTm9kZShpdGVtLCBudWxsLCBzZWxmLmhlYWQsIHNlbGYpXG4gIGlmICghc2VsZi50YWlsKSB7XG4gICAgc2VsZi50YWlsID0gc2VsZi5oZWFkXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiBOb2RlICh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpXG4gIH1cblxuICB0aGlzLmxpc3QgPSBsaXN0XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gdGhpc1xuICAgIHRoaXMucHJldiA9IHByZXZcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByZXYgPSBudWxsXG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHRoaXNcbiAgICB0aGlzLm5leHQgPSBuZXh0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5uZXh0ID0gbnVsbFxuICB9XG59XG5cbnRyeSB7XG4gIC8vIGFkZCBpZiBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3IgaXMgcHJlc2VudFxuICByZXF1aXJlKCcuL2l0ZXJhdG9yLmpzJykoWWFsbGlzdClcbn0gY2F0Y2ggKGVyKSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgU3RvcmUgPSByZXF1aXJlKCduMycpLlN0b3JlO1xuY29uc3QgUGFyc2VyID0gcmVxdWlyZSgnbjMnKS5QYXJzZXI7XG5jb25zdCBqc29ubGQgPSByZXF1aXJlKCdqc29ubGQnKTtcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGU7XG5jb25zdCBSZGZhUGFyc2VyID0gcmVxdWlyZSgncmRmYS1zdHJlYW1pbmctcGFyc2VyJykuUmRmYVBhcnNlcjtcbmNvbnN0IE1pY3JvZGF0YVBhcnNlciA9IHJlcXVpcmUoJ21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlcicpLk1pY3JvZGF0YVJkZlBhcnNlcjtcblxuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMuanMnKTtcblxuLyoqXG4gKiBQYXJzZXMganNvbi1sZCB0byBxdWFkcyBpbnRvIHRoZSBuMy5TdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVybCAtIG1haW4gc2hhcGUgVVJMXG4gKiBAcmV0dXJuIHtQcm9taXNlPFN0b3JlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VKc29uTGQodGV4dCwgYmFzZVVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgIGNvbnN0IG5xdWFkcyA9IGF3YWl0IGpzb25sZC50b1JERihkYXRhLCB7Zm9ybWF0OiAnYXBwbGljYXRpb24vbi1xdWFkcycsIGJhc2U6IGJhc2VVcmx9KTtcbiAgICByZXR1cm4gcGFyc2VOUXVhZHMobnF1YWRzLCBiYXNlVXJsKTtcbn1cblxuXG4vKipcbiAqIFBhcnNlIFJERmEgdG8gcXVhZHMgaW50byB0aGUgbjMuU3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gaW5wdXQgZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVcmwgLSBtYWluIHNoYXBlIFVSTFxuICogQHJldHVybiB7UHJvbWlzZTxTdG9yZT59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlUmRmYSh0ZXh0LCBiYXNlVXJsKSB7XG4gICAgY29uc3QgdGV4dFN0cmVhbSA9IG5ldyBSZWFkYWJsZSgpO1xuICAgIHRleHRTdHJlYW0ucHVzaCh0ZXh0KTtcbiAgICB0ZXh0U3RyZWFtLnB1c2gobnVsbCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICBjb25zdCBzdG9yZSA9IG5ldyBTdG9yZSgpO1xuICAgICAgICBjb25zdCByZGZhUGFyc2VyID0gbmV3IFJkZmFQYXJzZXIoe2Jhc2VJUkk6IGJhc2VVcmwsIGNvbnRlbnRUeXBlOiAndGV4dC9odG1sJ30pO1xuICAgICAgICB0ZXh0U3RyZWFtLnBpcGUocmRmYVBhcnNlcilcbiAgICAgICAgICAgIC5vbignZGF0YScsIHF1YWQgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3JlLmFkZFF1YWQocXVhZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdlcnJvcicsIGVyciA9PiByZWooZXJyKSlcbiAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZS5nZXRRdWFkcygpLmxlbmd0aCA9PT0gMCkgcmVzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgcmVzKHN0b3JlKVxuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogUGFyc2VzIG1pY3JvZGF0YSB0byBxdWFkcyBpbnRvIHRoZSBuMy5TdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVybCAtIG1haW4gc2hhcGUgVVJMXG4gKiBAcmV0dXJuIHtQcm9taXNlPFN0b3JlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VNaWNyb2RhdGEodGV4dCwgYmFzZVVybCkge1xuICAgIGNvbnN0IHRleHRTdHJlYW0gPSBuZXcgUmVhZGFibGUoKTtcbiAgICB0ZXh0U3RyZWFtLnB1c2godGV4dCk7XG4gICAgdGV4dFN0cmVhbS5wdXNoKG51bGwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBuZXcgU3RvcmUoKTtcbiAgICAgICAgY29uc3QgcmRmYVBhcnNlciA9IG5ldyBNaWNyb2RhdGFQYXJzZXIoe2Jhc2VJUkk6IGJhc2VVcmx9KTtcbiAgICAgICAgdGV4dFN0cmVhbS5waXBlKHJkZmFQYXJzZXIpXG4gICAgICAgICAgICAub24oJ2RhdGEnLCBxdWFkID0+IHtcbiAgICAgICAgICAgICAgICBzdG9yZS5hZGRRdWFkKHF1YWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZXJyb3InLCBlcnIgPT4gcmVqKGVycikpXG4gICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmUuZ2V0UXVhZHMoKS5sZW5ndGggPT09IDApIHJlcyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJlcyhzdG9yZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVXJsIC0gbWFpbiBzaGFwZSBVUkxcbiAqIEByZXR1cm4ge1N0b3JlfVxuICovXG5mdW5jdGlvbiBwYXJzZU5RdWFkcyh0ZXh0LCBiYXNlVXJsKSB7XG4gICAgY29uc3QgdHVydGxlUGFyc2VyID0gbmV3IFBhcnNlcih7XG4gICAgICAgIGZvcm1hdDogJ2FwcGxpY2F0aW9uL24tcXVhZHMnLFxuICAgICAgICBiYXNlSVJJOiBiYXNlVXJsLFxuICAgIH0pO1xuICAgIGNvbnN0IHN0b3JlID0gbmV3IFN0b3JlKCk7XG4gICAgdHVydGxlUGFyc2VyLnBhcnNlKHRleHQpLmZvckVhY2gocXVhZCA9PiB7XG4gICAgICAgIHN0b3JlLmFkZFF1YWQocXVhZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0b3JlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVybCAtIG1haW4gc2hhcGUgVVJMXG4gKiBAcmV0dXJuIHtTdG9yZX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VUdXJ0bGUodGV4dCwgYmFzZVVybCkge1xuICAgIGNvbnN0IHR1cnRsZVBhcnNlciA9IG5ldyBQYXJzZXIoe1xuICAgICAgICBmb3JtYXQ6ICd0ZXh0L3R1cnRsZScsXG4gICAgICAgIGJhc2VJUkk6IGJhc2VVcmwsXG4gICAgfSk7XG4gICAgY29uc3Qgc3RvcmUgPSBuZXcgU3RvcmUoKTtcbiAgICB0dXJ0bGVQYXJzZXIucGFyc2UodGV4dCkuZm9yRWFjaChxdWFkID0+IHtcbiAgICAgICAgc3RvcmUuYWRkUXVhZChxdWFkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciB0cnlpbmcgdG8gcGFyc2UgaW5wdXQgdGV4dCBpbnRvIGEgY2VydGFpbiBmb3JtYXRcbiAqIEBwYXJhbSB7Kn0gcGFyc2VyIHBhcnNlciBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2U8dW5kZWZpbmVkfFN0b3JlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdHJ5UGFyc2UocGFyc2VyKSB7XG4gICAgbGV0IHF1YWRzO1xuICAgIHRyeSB7XG4gICAgICAgIHF1YWRzID0gYXdhaXQgcGFyc2VyKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gcXVhZHM7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBpbnB1dCB0byBxdWFkc1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gbWFpbiBzaGFwZSBVUkxcbiAqIEByZXR1cm5zIHtQcm9taXNlPFN0b3JlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3RyaW5nVG9RdWFkcyh0ZXh0LCB1cmwpIHtcbiAgICBjb25zdCBqc29uUGFyc2VyID0gYXN5bmMgKCkgPT4gYXdhaXQgcGFyc2VKc29uTGQodGV4dCwgdXJsKTtcbiAgICBjb25zdCBtaWNyb2RhdGFQYXJzZXIgPSBhc3luYyAoKSA9PiBhd2FpdCBwYXJzZU1pY3JvZGF0YSh0ZXh0LCB1cmwpO1xuICAgIGNvbnN0IHJkZmFQYXJzZXIgPSBhc3luYyAoKSA9PiBhd2FpdCBwYXJzZVJkZmEodGV4dCwgdXJsKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0cnlQYXJzZShqc29uUGFyc2VyKSB8fFxuICAgICAgICBhd2FpdCB0cnlQYXJzZShtaWNyb2RhdGFQYXJzZXIpIHx8XG4gICAgICAgIGF3YWl0IHRyeVBhcnNlKHJkZmFQYXJzZXIpO1xuICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCB8fCByZXMuZ2V0UXVhZHMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkRGF0YUVycm9yKCdFcnJvciB3aGlsZSBwYXJzaW5nIHRoZSBkYXRhLiAnICtcbiAgICAgICAgICAgICdUaGlzIGNvdWxkIGJlIGNhdXNlZCBieSBpbmNvcnJlY3QgZGF0YSBvciBpbmNvcnJlY3QgZGF0YSBmb3JtYXQuICcgK1xuICAgICAgICAgICAgJ1Bvc3NpYmxlIGZvcm1hdHM6IGpzb24tbGQsIG1pY3JvZGF0YSwgcmRmYScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwYXJzZUpzb25MZDogcGFyc2VKc29uTGQsXG4gICAgcGFyc2VNaWNyb2RhdGE6IHBhcnNlTWljcm9kYXRhLFxuICAgIHBhcnNlUmRmYTogcGFyc2VSZGZhLFxuICAgIHBhcnNlTlF1YWRzOiBwYXJzZU5RdWFkcyxcbiAgICBwYXJzZVR1cnRsZTogcGFyc2VUdXJ0bGUsXG4gICAgc3RyaW5nVG9RdWFkczogc3RyaW5nVG9RdWFkcyxcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHN0cmluZ1RvUXVhZHM6IHJlcXVpcmUoJy4vcGFyc2VyJykuc3RyaW5nVG9RdWFkcyxcbiAgICBwYXJzZUpzb25MZDogcmVxdWlyZSgnLi9wYXJzZXInKS5wYXJzZUpzb25MZCxcbiAgICBwYXJzZU1pY3JvZGF0YTogcmVxdWlyZSgnLi9wYXJzZXInKS5wYXJzZU1pY3JvZGF0YSxcbiAgICBwYXJzZVJkZmE6IHJlcXVpcmUoJy4vcGFyc2VyJykucGFyc2VSZGZhLFxuICAgIHBhcnNlTlF1YWRzOiByZXF1aXJlKCcuL3BhcnNlcicpLnBhcnNlTlF1YWRzLFxuICAgIHJhbmRvbVVybDogcmVxdWlyZSgnLi91dGlsJykucmFuZG9tVXJsLFxuICAgIHF1YWRzVG9TaGFwZXM6IHJlcXVpcmUoJy4vdXRpbCcpLnF1YWRzVG9TaGFwZXNcbn0iLCIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XG5cbmNvbnN0IGpzb25sZCA9IHJlcXVpcmUoJ2pzb25sZCcpO1xuY29uc3QgbjMgPSByZXF1aXJlKCduMycpO1xuY29uc3QgU3RvcmUgPSBuMy5TdG9yZTtcbmNvbnN0IFJkZmFQYXJzZXIgPSByZXF1aXJlKCdyZGZhLXN0cmVhbWluZy1wYXJzZXInKS5SZGZhUGFyc2VyO1xuXG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbi8qKlxuICogTG9hZHMgcmVsYXRlZCBkYXRhIChzaGFwZXMsIGNvbnRleHQsIGV0Yy4pIGZyb20gcmVtb3RlIG9yIGxvY2FsIHNvdXJjZVxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmsgdXJsIHRvIHRoZSByZW1vdGUgc291cmNlIG9yIGxvY2FsIHBhdGhcbiAqIEByZXR1cm4geyp9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWREYXRhKGxpbmspIHtcbiAgICBpZiAobGluay5tYXRjaChcIl5odHRwcz86Ly9cIikpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBheGlvcy5nZXQobGluaykpLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMobGluaykudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZXMgZnJvbSBvYmplY3RzIGFycmF5XG4gKiBAcGFyYW0ge1tvYmplY3RdfSBpdGVtc1xuICogQHBhcmFtIHtbc3RyaW5nXX0ga2V5c1xuICogQHJldHVybnMge1tvYmplY3RdfVxuICovXG5mdW5jdGlvbiB1bmlxdWVCeShpdGVtcywga2V5cykge1xuICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGxldCB2YWwgPSAnJztcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB2YWwgKz0gaXRlbVtrZXldKTtcbiAgICAgICAgcmV0dXJuIHNlZW4uaGFzT3duUHJvcGVydHkodmFsKSA/IGZhbHNlIDogKHNlZW5bdmFsXSA9IHRydWUpO1xuICAgIH0pXG59XG5cbi8qKlxuICogIEdlbmVyYXRlcyByYW5kb20gVVJMIGFzIGJhc2VcbiAqICBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiAgQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByYW5kb21VcmwobGVuZ3RoID0gMTYpIHtcbiAgICBsZXQgcmVzdWx0ID0gJ2h0dHBzOi8vZXhhbXBsZS5vcmcvJztcbiAgICBjb25zdCBjaGFyYWN0ZXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBjaGFyYWN0ZXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZpbmRzIHN0cm9uZ2x5IGNvbm5lY3RlZCBjb21wb25lbnRzIGluIHRoZSBkYXRhIGdyYXBoXG4gKiBAcGFyYW0ge1N0b3JlfSBzdG9yZVxuICogQHJldHVybiB7TWFwPHN0cmluZywgbnVtYmVyPn0gLSBtYXAgZnJvbSBzdWJqZWN0IHVyaXMgdG9cbiAqIGNvbXBvbmVudCBpZHNcbiAqL1xuZnVuY3Rpb24gc3Ryb25nbHlDb25uZWN0ZWRDb21wb25lbnRzKHN0b3JlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbLi4ubmV3IFNldChzdG9yZS5nZXRTdWJqZWN0cygpXG4gICAgICAgIC5tYXAoeCA9PiB4LmlkKSldO1xuXG4gICAgY29uc3Qgb3JkZXIgPSBbXTtcbiAgICBsZXQgY29tcG9uZW50ID0gW107XG4gICAgbGV0IGNvbXBvbmVudElkeCA9IDA7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB1c2VkID0gbmV3IE1hcCgpO1xuXG4gICAgY29uc3QgZm9yd2FyZERmcyA9ICh2KSA9PiB7XG4gICAgICAgIHVzZWQuc2V0KHYsIHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHF1YWQgb2Ygc3RvcmUuZ2V0UXVhZHModiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5jbHVkZXMocXVhZC5vYmplY3QuaWQpICYmICF1c2VkLmdldChxdWFkLm9iamVjdC5pZCkpXG4gICAgICAgICAgICAgICAgZm9yd2FyZERmcyhxdWFkLm9iamVjdC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgb3JkZXIucHVzaCh2KTtcbiAgICB9XG5cbiAgICBjb25zdCBiYWNrd2FyZERmcyA9ICh2KSA9PiB7XG4gICAgICAgIHVzZWQuc2V0KHYsIHRydWUpO1xuICAgICAgICBjb21wb25lbnQucHVzaCh2KTtcbiAgICAgICAgZm9yIChjb25zdCBxdWFkIG9mIHN0b3JlLmdldFF1YWRzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2KSkge1xuICAgICAgICAgICAgaWYgKCF1c2VkLmdldChxdWFkLnN1YmplY3QuaWQpKVxuICAgICAgICAgICAgICAgIGJhY2t3YXJkRGZzKHF1YWQuc3ViamVjdC5pZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHVzZWQuc2V0KG5vZGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKCF1c2VkLmdldChub2RlKSlcbiAgICAgICAgICAgIGZvcndhcmREZnMobm9kZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlcykgdXNlZC5zZXQobm9kZSwgZmFsc2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG9yZGVyW25vZGVzLmxlbmd0aC0xLWldO1xuICAgICAgICBpZiAoIXVzZWQuZ2V0KG5vZGUpKSB7XG4gICAgICAgICAgICBiYWNrd2FyZERmcyhub2RlKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKHggPT4gY29tcG9uZW50cy5zZXQoeCwgY29tcG9uZW50SWR4KSk7XG4gICAgICAgICAgICBjb21wb25lbnRJZHgrKztcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG4vKipcbiAqIFBhcnNlcyBxdWFkcyB0byBtdWx0aXBsZSBzdG9yZXMgd2hpY2ggcmVwcmVzZW50IHJvb3Qgbm9kZXNcbiAqIGluIHRoZSBkYXRhIGdyYXBoXG4gKiBAcGFyYW0ge1N0b3JlfSBzdG9yZVxuICovXG5mdW5jdGlvbiBxdWFkc1RvU2hhcGVzKHN0b3JlKSB7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IHN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50cyhzdG9yZSk7XG4gICAgY29uc3Qgbm90Um9vdCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHF1YWQgb2Ygc3RvcmUuZ2V0UXVhZHMoKSkge1xuICAgICAgICBpZiAoY29tcG9uZW50cy5oYXMocXVhZC5zdWJqZWN0LmlkKSAmJlxuICAgICAgICAgICAgY29tcG9uZW50cy5oYXMocXVhZC5vYmplY3QuaWQpICYmXG4gICAgICAgICAgICBjb21wb25lbnRzLmdldChxdWFkLnN1YmplY3QuaWQpICE9PSBjb21wb25lbnRzLmdldChxdWFkLm9iamVjdC5pZCkpIHtcbiAgICAgICAgICAgIG5vdFJvb3QuYWRkKGNvbXBvbmVudHMuZ2V0KHF1YWQub2JqZWN0LmlkKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzaGFwZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbbm9kZSwgY29tcG9uZW50XSBvZiBjb21wb25lbnRzLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoIW5vdFJvb3QuaGFzKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHNoYXBlcy5zZXQobm9kZSwgZ2V0U2hhcGUobm9kZSwgc3RvcmUsIHNoYXBlcywgW10pKTtcbiAgICAgICAgICAgIG5vdFJvb3QuYWRkKGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlcztcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBnZXRzIGFsbCB0cmlwbGVzLCByZWxhdGVkIHRvIHRoZSBzaGFwZVxuICogQHBhcmFtIHthbnl9IGlkIC0gaWQgb2YgdGhlIGNvbnN0cnVjdGVkIHNoYXBlXG4gKiBAcGFyYW0ge1N0b3JlfSBzdG9yZSAtIHN0b3JlLCBjb250YWluaW5nIGFsbCB0aGUgdHJpcGxlc1xuICogQHBhcmFtIHtNYXA8YW55LCBTdG9yZT59IHNoYXBlcyAtIG1hcCBbaWQgLT4gc2hhcGUgU3RvcmVdXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IHBhcnNlZCAtIGFycmF5IGZvciB0cmFja2luZyByZWN1cnNpdmUgbG9vcHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2hhcGUoaWQsIHN0b3JlLCBzaGFwZXMsIHBhcnNlZCkge1xuICAgIGNvbnN0IHNoYXBlUXVhZHMgPSBzdG9yZS5nZXRRdWFkcyhpZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIGlmIChzaGFwZVF1YWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHBhcnNlZC5wdXNoKGlkKTtcbiAgICBmb3IgKGNvbnN0IHF1YWQgb2Ygc3RvcmUuZ2V0UXVhZHMoaWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKSkge1xuICAgICAgICBpZiAocGFyc2VkLmluY2x1ZGVzKHF1YWQub2JqZWN0LmlkKSkge1xuICAgICAgICAgICAgc2hhcGVRdWFkcy5wdXNoKHF1YWQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5lc3RlZFN0b3JlO1xuICAgICAgICBpZiAoc2hhcGVzLmdldChxdWFkLm9iamVjdCkpIHtcbiAgICAgICAgICAgIG5lc3RlZFN0b3JlID0gc2hhcGVzLmdldChxdWFkLm9iamVjdC5pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXN0ZWRTdG9yZSA9IGdldFNoYXBlKHF1YWQub2JqZWN0LmlkLCBzdG9yZSwgc2hhcGVzLCBwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXN0ZWRTdG9yZSAmJiBuZXN0ZWRTdG9yZS5nZXRRdWFkcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNoYXBlUXVhZHMucHVzaCguLi5uZXN0ZWRTdG9yZS5nZXRRdWFkcygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaGFwZVN0b3JlID0gbmV3IFN0b3JlKCk7XG4gICAgZm9yIChjb25zdCBxdWFkIG9mIHNoYXBlUXVhZHMpIHtcbiAgICAgICAgc2hhcGVTdG9yZS5hZGRRdWFkKHF1YWQpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGVTdG9yZTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByYW5kb21Vcmw6IHJhbmRvbVVybCxcbiAgICBsb2FkRGF0YTogbG9hZERhdGEsXG4gICAgdW5pcXVlQnk6IHVuaXF1ZUJ5LFxuICAgIHF1YWRzVG9TaGFwZXM6IHF1YWRzVG9TaGFwZXMsXG59OyJdfQ==
