(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.schemarama = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var InvalidDataError = /*#__PURE__*/function (_Error) {
  (0, _inherits2["default"])(InvalidDataError, _Error);

  var _super = _createSuper(InvalidDataError);

  function InvalidDataError(message) {
    var _this;

    (0, _classCallCheck2["default"])(this, InvalidDataError);
    _this = _super.call(this, message);
    _this.name = "InvalidDataError";
    return _this;
  }

  return InvalidDataError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

var ShexValidationError = /*#__PURE__*/function (_Error2) {
  (0, _inherits2["default"])(ShexValidationError, _Error2);

  var _super2 = _createSuper(ShexValidationError);

  function ShexValidationError(message) {
    var _this2;

    (0, _classCallCheck2["default"])(this, ShexValidationError);
    _this2 = _super2.call(this, message);
    _this2.name = "ShexValidationError";
    return _this2;
  }

  return ShexValidationError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

module.exports = {
  InvalidDataError: InvalidDataError,
  ShexValidationError: ShexValidationError
};

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"@babel/runtime/helpers/wrapNativeSuper":29}],2:[function(require,module,exports){
"use strict";

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

},{}],3:[function(require,module,exports){
"use strict";

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

},{}],4:[function(require,module,exports){
"use strict";

var arrayLikeToArray = require("./arrayLikeToArray");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

},{"./arrayLikeToArray":2}],5:[function(require,module,exports){
"use strict";

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

},{}],6:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

},{}],7:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

},{}],8:[function(require,module,exports){
"use strict";

var setPrototypeOf = require("./setPrototypeOf");

var isNativeReflectConstruct = require("./isNativeReflectConstruct");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

},{"./isNativeReflectConstruct":15,"./setPrototypeOf":23}],9:[function(require,module,exports){
"use strict";

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

},{}],10:[function(require,module,exports){
"use strict";

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

},{}],11:[function(require,module,exports){
"use strict";

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

},{}],12:[function(require,module,exports){
"use strict";

var setPrototypeOf = require("./setPrototypeOf");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

},{"./setPrototypeOf":23}],13:[function(require,module,exports){
"use strict";

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

},{}],14:[function(require,module,exports){
"use strict";

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;

},{}],15:[function(require,module,exports){
"use strict";

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

},{}],16:[function(require,module,exports){
"use strict";

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

},{}],17:[function(require,module,exports){
"use strict";

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

},{}],18:[function(require,module,exports){
"use strict";

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

},{}],19:[function(require,module,exports){
"use strict";

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

},{}],20:[function(require,module,exports){
"use strict";

var objectWithoutPropertiesLoose = require("./objectWithoutPropertiesLoose");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;

},{"./objectWithoutPropertiesLoose":21}],21:[function(require,module,exports){
"use strict";

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

},{}],22:[function(require,module,exports){
"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

var assertThisInitialized = require("./assertThisInitialized");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

},{"./assertThisInitialized":5,"@babel/runtime/helpers/typeof":27}],23:[function(require,module,exports){
"use strict";

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

},{}],24:[function(require,module,exports){
"use strict";

var arrayWithHoles = require("./arrayWithHoles");

var iterableToArrayLimit = require("./iterableToArrayLimit");

var unsupportedIterableToArray = require("./unsupportedIterableToArray");

var nonIterableRest = require("./nonIterableRest");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

},{"./arrayWithHoles":3,"./iterableToArrayLimit":17,"./nonIterableRest":18,"./unsupportedIterableToArray":28}],25:[function(require,module,exports){
"use strict";

var arrayWithHoles = require("./arrayWithHoles");

var iterableToArray = require("./iterableToArray");

var unsupportedIterableToArray = require("./unsupportedIterableToArray");

var nonIterableRest = require("./nonIterableRest");

function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
}

module.exports = _toArray;

},{"./arrayWithHoles":3,"./iterableToArray":16,"./nonIterableRest":18,"./unsupportedIterableToArray":28}],26:[function(require,module,exports){
"use strict";

var arrayWithoutHoles = require("./arrayWithoutHoles");

var iterableToArray = require("./iterableToArray");

var unsupportedIterableToArray = require("./unsupportedIterableToArray");

var nonIterableSpread = require("./nonIterableSpread");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

},{"./arrayWithoutHoles":4,"./iterableToArray":16,"./nonIterableSpread":19,"./unsupportedIterableToArray":28}],27:[function(require,module,exports){
"use strict";

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

},{}],28:[function(require,module,exports){
"use strict";

var arrayLikeToArray = require("./arrayLikeToArray");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

},{"./arrayLikeToArray":2}],29:[function(require,module,exports){
"use strict";

var getPrototypeOf = require("./getPrototypeOf");

var setPrototypeOf = require("./setPrototypeOf");

var isNativeFunction = require("./isNativeFunction");

var construct = require("./construct");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;

},{"./construct":8,"./getPrototypeOf":11,"./isNativeFunction":14,"./setPrototypeOf":23}],30:[function(require,module,exports){
"use strict";

module.exports = require("regenerator-runtime");

},{"regenerator-runtime":187}],31:[function(require,module,exports){
"use strict";

module.exports = require('./lib/axios');

},{"./lib/axios":33}],32:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var settle = require('./../core/settle');

var cookies = require('./../helpers/cookies');

var buildURL = require('./../helpers/buildURL');

var buildFullPath = require('../core/buildFullPath');

var parseHeaders = require('./../helpers/parseHeaders');

var isURLSameOrigin = require('./../helpers/isURLSameOrigin');

var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    if ((utils.isBlob(requestData) || utils.isFile(requestData)) && requestData.type) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = unescape(encodeURIComponent(config.auth.password)) || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

},{"../core/buildFullPath":39,"../core/createError":40,"./../core/settle":44,"./../helpers/buildURL":48,"./../helpers/cookies":50,"./../helpers/isURLSameOrigin":52,"./../helpers/parseHeaders":54,"./../utils":56}],33:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var bind = require('./helpers/bind');

var Axios = require('./core/Axios');

var mergeConfig = require('./core/mergeConfig');

var defaults = require('./defaults');
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel'); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = require('./helpers/spread');
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports["default"] = axios;

},{"./cancel/Cancel":34,"./cancel/CancelToken":35,"./cancel/isCancel":36,"./core/Axios":37,"./core/mergeConfig":43,"./defaults":46,"./helpers/bind":47,"./helpers/spread":55,"./utils":56}],34:[function(require,module,exports){
'use strict';
/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

},{}],35:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":34}],36:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],37:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var buildURL = require('../helpers/buildURL');

var InterceptorManager = require('./InterceptorManager');

var dispatchRequest = require('./dispatchRequest');

var mergeConfig = require('./mergeConfig');
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  } // Hook up interceptors middleware


  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

},{"../helpers/buildURL":48,"./../utils":56,"./InterceptorManager":38,"./dispatchRequest":41,"./mergeConfig":43}],38:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":56}],39:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');

var combineURLs = require('../helpers/combineURLs');
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

},{"../helpers/combineURLs":49,"../helpers/isAbsoluteURL":51}],40:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":42}],41:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

var transformData = require('./transformData');

var isCancel = require('../cancel/isCancel');

var defaults = require('../defaults');
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":36,"../defaults":46,"./../utils":56,"./transformData":45}],42:[function(require,module,exports){
'use strict';
/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

},{}],43:[function(require,module,exports){
'use strict';

var utils = require('../utils');
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }

    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, mergeDeepProperties);
  return config;
};

},{"../utils":56}],44:[function(require,module,exports){
'use strict';

var createError = require('./createError');
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

},{"./createError":40}],45:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

},{"./../utils":56}],46:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('./utils');

var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

}).call(this)}).call(this,require('_process'))

},{"./adapters/http":32,"./adapters/xhr":32,"./helpers/normalizeHeaderName":53,"./utils":56,"_process":142}],47:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

},{}],48:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":56}],49:[function(require,module,exports){
'use strict';
/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

},{}],50:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

},{"./../utils":56}],51:[function(require,module,exports){
'use strict';
/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],52:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

},{"./../utils":56}],53:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":56}],54:[function(require,module,exports){
'use strict';

var utils = require('./../utils'); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

},{"./../utils":56}],55:[function(require,module,exports){
'use strict';
/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],56:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var bind = require('./helpers/bind');
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && (0, _typeof2["default"])(val) === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */


function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if ((0, _typeof2["default"])(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */


function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }

  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

},{"./helpers/bind":47,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],57:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

},{}],58:[function(require,module,exports){
"use strict";

},{}],59:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58}],60:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var base64 = require('base64-js');

var ieee754 = require('ieee754');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  } // Return an augmented `Uint8Array` instance


  var buf = new Uint8Array(length);
  buf.__proto__ = Buffer.prototype;
  return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }

    return allocUnsafe(arg);
  }

  return from(arg, encodingOrOffset, length);
} // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97


if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value);
  }

  if (value == null) {
    throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + (0, _typeof2["default"])(value));
  }

  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }

  var valueOf = value.valueOf && value.valueOf();

  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }

  var b = fromObject(value);
  if (b) return b;

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + (0, _typeof2["default"])(value));
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148


Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }

  return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);

  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }

  return buf;
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }

  var buf;

  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  } // Return an augmented `Uint8Array` instance


  buf.__proto__ = Buffer.prototype;
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }

    return fromArrayLike(obj);
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf);
    }

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + (0, _typeof2["default"])(string));
  }

  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }

  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + (0, _typeof2["default"])(target));
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  }

  var strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;

    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

  newBuf.__proto__ = Buffer.prototype;
  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;

    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166


function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}

function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27,"base64-js":57,"buffer":60,"ieee754":88}],61:[function(require,module,exports){
/* jshint esversion: 6 */

/* jslint node: true */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

module.exports = function (object) {
  return serialize(object);

  function serialize(object) {
    if (object === null || (0, _typeof2["default"])(object) !== 'object' || object.toJSON != null) {
      return JSON.stringify(object);
    }

    if (Array.isArray(object) && object.length === 0) {
      return '[]';
    }

    if (Array.isArray(object) && object.length === 1) {
      return '[' + serialize(object[0]) + ']';
    }

    if (Array.isArray(object)) {
      return '[' + object.reduce(function (t, cv, ci) {
        t = ci === 1 ? serialize(t) : t;
        return t + ',' + serialize(cv);
      }) + ']';
    }

    var keys = Object.keys(object);

    if (keys.length === 0) {
      return '{}';
    }

    if (keys.length === 1) {
      return '{' + serialize(keys[0]) + ':' + serialize(object[keys[0]]) + '}';
    }

    return '{' + keys.sort().reduce(function (t, cv, ci) {
      t = ci === 1 ? serialize(t) + ':' + serialize(object[t]) : t;
      return t + ',' + serialize(cv) + ':' + serialize(object[cv]);
    }) + '}';
  }
};

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attributeNames = exports.elementNames = void 0;
exports.elementNames = new Map([["altglyph", "altGlyph"], ["altglyphdef", "altGlyphDef"], ["altglyphitem", "altGlyphItem"], ["animatecolor", "animateColor"], ["animatemotion", "animateMotion"], ["animatetransform", "animateTransform"], ["clippath", "clipPath"], ["feblend", "feBlend"], ["fecolormatrix", "feColorMatrix"], ["fecomponenttransfer", "feComponentTransfer"], ["fecomposite", "feComposite"], ["feconvolvematrix", "feConvolveMatrix"], ["fediffuselighting", "feDiffuseLighting"], ["fedisplacementmap", "feDisplacementMap"], ["fedistantlight", "feDistantLight"], ["fedropshadow", "feDropShadow"], ["feflood", "feFlood"], ["fefunca", "feFuncA"], ["fefuncb", "feFuncB"], ["fefuncg", "feFuncG"], ["fefuncr", "feFuncR"], ["fegaussianblur", "feGaussianBlur"], ["feimage", "feImage"], ["femerge", "feMerge"], ["femergenode", "feMergeNode"], ["femorphology", "feMorphology"], ["feoffset", "feOffset"], ["fepointlight", "fePointLight"], ["fespecularlighting", "feSpecularLighting"], ["fespotlight", "feSpotLight"], ["fetile", "feTile"], ["feturbulence", "feTurbulence"], ["foreignobject", "foreignObject"], ["glyphref", "glyphRef"], ["lineargradient", "linearGradient"], ["radialgradient", "radialGradient"], ["textpath", "textPath"]]);
exports.attributeNames = new Map([["definitionurl", "definitionURL"], ["attributename", "attributeName"], ["attributetype", "attributeType"], ["basefrequency", "baseFrequency"], ["baseprofile", "baseProfile"], ["calcmode", "calcMode"], ["clippathunits", "clipPathUnits"], ["diffuseconstant", "diffuseConstant"], ["edgemode", "edgeMode"], ["filterunits", "filterUnits"], ["glyphref", "glyphRef"], ["gradienttransform", "gradientTransform"], ["gradientunits", "gradientUnits"], ["kernelmatrix", "kernelMatrix"], ["kernelunitlength", "kernelUnitLength"], ["keypoints", "keyPoints"], ["keysplines", "keySplines"], ["keytimes", "keyTimes"], ["lengthadjust", "lengthAdjust"], ["limitingconeangle", "limitingConeAngle"], ["markerheight", "markerHeight"], ["markerunits", "markerUnits"], ["markerwidth", "markerWidth"], ["maskcontentunits", "maskContentUnits"], ["maskunits", "maskUnits"], ["numoctaves", "numOctaves"], ["pathlength", "pathLength"], ["patterncontentunits", "patternContentUnits"], ["patterntransform", "patternTransform"], ["patternunits", "patternUnits"], ["pointsatx", "pointsAtX"], ["pointsaty", "pointsAtY"], ["pointsatz", "pointsAtZ"], ["preservealpha", "preserveAlpha"], ["preserveaspectratio", "preserveAspectRatio"], ["primitiveunits", "primitiveUnits"], ["refx", "refX"], ["refy", "refY"], ["repeatcount", "repeatCount"], ["repeatdur", "repeatDur"], ["requiredextensions", "requiredExtensions"], ["requiredfeatures", "requiredFeatures"], ["specularconstant", "specularConstant"], ["specularexponent", "specularExponent"], ["spreadmethod", "spreadMethod"], ["startoffset", "startOffset"], ["stddeviation", "stdDeviation"], ["stitchtiles", "stitchTiles"], ["surfacescale", "surfaceScale"], ["systemlanguage", "systemLanguage"], ["tablevalues", "tableValues"], ["targetx", "targetX"], ["targety", "targetY"], ["textlength", "textLength"], ["viewbox", "viewBox"], ["viewtarget", "viewTarget"], ["xchannelselector", "xChannelSelector"], ["ychannelselector", "yChannelSelector"], ["zoomandpan", "zoomAndPan"]]);

},{}],63:[function(require,module,exports){
"use strict";

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Module dependencies
 */

var ElementType = __importStar(require("domelementtype"));

var entities_1 = require("entities");
/*
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser, see
 * https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */


var foreignNames_1 = require("./foreignNames");

var unencodedElements = new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
/**
 * Format attributes
 */

function formatAttributes(attributes, opts) {
  if (!attributes) return;
  return Object.keys(attributes).map(function (key) {
    var _a, _b;

    var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";

    if (opts.xmlMode === "foreign") {
      /* Fix up mixed-case attribute names */
      key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }

    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }

    return key + "=\"" + (opts.decodeEntities ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + "\"";
  }).join(" ");
}
/**
 * Self-enclosing tags
 */


var singleTag = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */

function render(node, options) {
  if (options === void 0) {
    options = {};
  } // TODO: This is a bit hacky.


  var nodes = Array.isArray(node) || node.cheerio ? node : [node];
  var output = "";

  for (var i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }

  return output;
}

exports["default"] = render;

function renderNode(node, options) {
  switch (node.type) {
    case "root":
      return render(node.children, options);

    case ElementType.Directive:
      return renderDirective(node);

    case ElementType.Comment:
      return renderComment(node);

    case ElementType.CDATA:
      return renderCdata(node);

    default:
      return ElementType.isTag(node) ? renderTag(node, options) : renderText(node, options);
  }
}

var foreignModeIntegrationPoints = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]);
var foreignElements = new Set(["svg", "math"]);

function renderTag(elem, opts) {
  var _a; // Handle SVG / MathML in HTML


  if (opts.xmlMode === "foreign") {
    /* Fix up mixed-case element names */
    elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    /* Exit foreign mode at integration points */

    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = __assign(__assign({}, opts), {
        xmlMode: false
      });
    }
  }

  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = __assign(__assign({}, opts), {
      xmlMode: "foreign"
    });
  }

  var tag = "<" + elem.name;
  var attribs = formatAttributes(elem.attribs, opts);

  if (attribs) {
    tag += " " + attribs;
  }

  if (elem.children.length === 0 && (opts.xmlMode ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
  opts.selfClosingTags !== false : // User explicitly asked for self-closing tags, even in HTML mode
  opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode) tag += " ";
    tag += "/>";
  } else {
    tag += ">";

    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }

    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += "</" + elem.name + ">";
    }
  }

  return tag;
}

function renderDirective(elem) {
  return "<" + elem.data + ">";
}

function renderText(elem, opts) {
  var data = elem.data || ""; // If entities weren't decoded, no need to encode them back

  if (opts.decodeEntities && !(elem.parent && unencodedElements.has(elem.parent.name))) {
    data = entities_1.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return "<![CDATA[" + elem.children[0].data + "]]>";
}

function renderComment(elem) {
  return "<!--" + elem.data + "-->";
}

},{"./foreignNames":62,"domelementtype":64,"entities":78}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.isTag = void 0;
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */

function isTag(elem) {
  return elem.type === "tag"
  /* Tag */
  || elem.type === "script"
  /* Script */
  || elem.type === "style"
  /* Style */
  ;
}

exports.isTag = isTag; // Exports for backwards compatibility

/** Type for Text */

exports.Text = "text"
/* Text */
;
/** Type for <? ... ?> */

exports.Directive = "directive"
/* Directive */
;
/** Type for <!-- ... --> */

exports.Comment = "comment"
/* Comment */
;
/** Type for <script> tags */

exports.Script = "script"
/* Script */
;
/** Type for <style> tags */

exports.Style = "style"
/* Style */
;
/** Type for Any tag */

exports.Tag = "tag"
/* Tag */
;
/** Type for <![CDATA[ ... ]]> */

exports.CDATA = "cdata"
/* CDATA */
;
/** Type for <!doctype ...> */

exports.Doctype = "doctype"
/* Doctype */
;

},{}],65:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomHandler = void 0;

var node_1 = require("./node");

__exportStar(require("./node"), exports);

var reWhitespace = /\s+/g; // Default options

var defaultOpts = {
  normalizeWhitespace: false,
  withStartIndices: false,
  withEndIndices: false
};

var DomHandler =
/** @class */
function () {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  function DomHandler(callback, options, elementCB) {
    /** The constructed DOM */
    this.dom = [];
    /** Indicated whether parsing has been completed. */

    this._done = false;
    /** Stack of open tags. */

    this._tagStack = [];
    /** A data node that is still being written to. */

    this._lastNode = null;
    /** Reference to the parser instance. Used for location information. */

    this._parser = null; // Make it possible to skip arguments, for backwards-compatibility

    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }

    if ((0, _typeof2["default"])(callback) === "object") {
      options = callback;
      callback = undefined;
    }

    this._callback = callback !== null && callback !== void 0 ? callback : null;
    this._options = options !== null && options !== void 0 ? options : defaultOpts;
    this._elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }

  DomHandler.prototype.onparserinit = function (parser) {
    this._parser = parser;
  }; // Resets the handler back to starting state


  DomHandler.prototype.onreset = function () {
    var _a;

    this.dom = [];
    this._done = false;
    this._tagStack = [];
    this._lastNode = null;
    this._parser = (_a = this._parser) !== null && _a !== void 0 ? _a : null;
  }; // Signals the handler that parsing is done


  DomHandler.prototype.onend = function () {
    if (this._done) return;
    this._done = true;
    this._parser = null;
    this.handleCallback(null);
  };

  DomHandler.prototype.onerror = function (error) {
    this.handleCallback(error);
  };

  DomHandler.prototype.onclosetag = function () {
    this._lastNode = null;

    var elem = this._tagStack.pop();

    if (!elem || !this._parser) {
      return;
    }

    if (this._options.withEndIndices) {
      elem.endIndex = this._parser.endIndex;
    }

    if (this._elementCB) this._elementCB(elem);
  };

  DomHandler.prototype.onopentag = function (name, attribs) {
    var element = new node_1.Element(name, attribs);
    this.addNode(element);

    this._tagStack.push(element);
  };

  DomHandler.prototype.ontext = function (data) {
    var normalize = this._options.normalizeWhitespace;
    var _lastNode = this._lastNode;

    if (_lastNode && _lastNode.type === "text"
    /* Text */
    ) {
        if (normalize) {
          _lastNode.data = (_lastNode.data + data).replace(reWhitespace, " ");
        } else {
          _lastNode.data += data;
        }
      } else {
      if (normalize) {
        data = data.replace(reWhitespace, " ");
      }

      var node = new node_1.Text(data);
      this.addNode(node);
      this._lastNode = node;
    }
  };

  DomHandler.prototype.oncomment = function (data) {
    if (this._lastNode && this._lastNode.type === "comment"
    /* Comment */
    ) {
        this._lastNode.data += data;
        return;
      }

    var node = new node_1.Comment(data);
    this.addNode(node);
    this._lastNode = node;
  };

  DomHandler.prototype.oncommentend = function () {
    this._lastNode = null;
  };

  DomHandler.prototype.oncdatastart = function () {
    var text = new node_1.Text("");
    var node = new node_1.NodeWithChildren("cdata"
    /* CDATA */
    , [text]);
    this.addNode(node);
    text.parent = node;
    this._lastNode = text;
  };

  DomHandler.prototype.oncdataend = function () {
    this._lastNode = null;
  };

  DomHandler.prototype.onprocessinginstruction = function (name, data) {
    var node = new node_1.ProcessingInstruction(name, data);
    this.addNode(node);
  };

  DomHandler.prototype.handleCallback = function (error) {
    if (typeof this._callback === "function") {
      this._callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  };

  DomHandler.prototype.addNode = function (node) {
    var parent = this._tagStack[this._tagStack.length - 1];
    var siblings = parent ? parent.children : this.dom;
    var previousSibling = siblings[siblings.length - 1];

    if (this._parser) {
      if (this._options.withStartIndices) {
        node.startIndex = this._parser.startIndex;
      }

      if (this._options.withEndIndices) {
        node.endIndex = this._parser.endIndex;
      }
    }

    siblings.push(node);

    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }

    if (parent) {
      node.parent = parent;
    }

    this._lastNode = null;
  };

  DomHandler.prototype.addDataNode = function (node) {
    this.addNode(node);
    this._lastNode = node;
  };

  return DomHandler;
}();

exports.DomHandler = DomHandler;
exports["default"] = DomHandler;

},{"./node":66,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],66:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneNode = exports.Element = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var nodeTypes = new Map([["tag"
/* Tag */
, 1], ["script"
/* Script */
, 1], ["style"
/* Style */
, 1], ["directive"
/* Directive */
, 1], ["text"
/* Text */
, 3], ["cdata"
/* CDATA */
, 4], ["comment"
/* Comment */
, 8]]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */

var Node =
/** @class */
function () {
  /**
   *
   * @param type The type of the node.
   */
  function Node(type) {
    this.type = type;
    /** Parent of the node */

    this.parent = null;
    /** Previous sibling */

    this.prev = null;
    /** Next sibling */

    this.next = null;
    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */

    this.startIndex = null;
    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */

    this.endIndex = null;
  }

  Object.defineProperty(Node.prototype, "nodeType", {
    // Read-only aliases
    get: function get() {
      var _a;

      return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "parentNode", {
    // Read-write aliases for properties
    get: function get() {
      return this.parent;
    },
    set: function set(parent) {
      this.parent = parent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "previousSibling", {
    get: function get() {
      return this.prev;
    },
    set: function set(prev) {
      this.prev = prev;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "nextSibling", {
    get: function get() {
      return this.next;
    },
    set: function set(next) {
      this.next = next;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */

  Node.prototype.cloneNode = function (recursive) {
    if (recursive === void 0) {
      recursive = false;
    }

    return cloneNode(this, recursive);
  };

  return Node;
}();

exports.Node = Node;

var DataNode =
/** @class */
function (_super) {
  __extends(DataNode, _super);
  /**
   * @param type The type of the node
   * @param data The content of the data node
   */


  function DataNode(type, data) {
    var _this = _super.call(this, type) || this;

    _this.data = data;
    return _this;
  }

  Object.defineProperty(DataNode.prototype, "nodeValue", {
    get: function get() {
      return this.data;
    },
    set: function set(data) {
      this.data = data;
    },
    enumerable: false,
    configurable: true
  });
  return DataNode;
}(Node);

exports.DataNode = DataNode;

var Text =
/** @class */
function (_super) {
  __extends(Text, _super);

  function Text(data) {
    return _super.call(this, "text"
    /* Text */
    , data) || this;
  }

  return Text;
}(DataNode);

exports.Text = Text;

var Comment =
/** @class */
function (_super) {
  __extends(Comment, _super);

  function Comment(data) {
    return _super.call(this, "comment"
    /* Comment */
    , data) || this;
  }

  return Comment;
}(DataNode);

exports.Comment = Comment;

var ProcessingInstruction =
/** @class */
function (_super) {
  __extends(ProcessingInstruction, _super);

  function ProcessingInstruction(name, data) {
    var _this = _super.call(this, "directive"
    /* Directive */
    , data) || this;

    _this.name = name;
    return _this;
  }

  return ProcessingInstruction;
}(DataNode);

exports.ProcessingInstruction = ProcessingInstruction;

var NodeWithChildren =
/** @class */
function (_super) {
  __extends(NodeWithChildren, _super);
  /**
   *
   * @param type Type of the node.
   * @param children Children of the node. Only certain node types can have children.
   */


  function NodeWithChildren(type, children) {
    var _this = _super.call(this, type) || this;

    _this.children = children;
    return _this;
  }

  Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
    // Aliases
    get: function get() {
      var _a;

      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
    get: function get() {
      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
    get: function get() {
      return this.children;
    },
    set: function set(children) {
      this.children = children;
    },
    enumerable: false,
    configurable: true
  });
  return NodeWithChildren;
}(Node);

exports.NodeWithChildren = NodeWithChildren;

var Element =
/** @class */
function (_super) {
  __extends(Element, _super);
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */


  function Element(name, attribs, children) {
    if (children === void 0) {
      children = [];
    }

    var _this = _super.call(this, name === "script" ? "script"
    /* Script */
    : name === "style" ? "style"
    /* Style */
    : "tag"
    /* Tag */
    , children) || this;

    _this.name = name;
    _this.attribs = attribs;
    _this.attribs = attribs;
    return _this;
  }

  Object.defineProperty(Element.prototype, "tagName", {
    // DOM Level 1 aliases
    get: function get() {
      return this.name;
    },
    set: function set(name) {
      this.name = name;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Element.prototype, "attributes", {
    get: function get() {
      var _this = this;

      return Object.keys(this.attribs).map(function (name) {
        return {
          name: name,
          value: _this.attribs[name]
        };
      });
    },
    enumerable: false,
    configurable: true
  });
  return Element;
}(NodeWithChildren);

exports.Element = Element;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */

function cloneNode(node, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }

  switch (node.type) {
    case "text"
    /* Text */
    :
      return new Text(node.data);

    case "directive"
    /* Directive */
    :
      {
        var instr = node;
        return new ProcessingInstruction(instr.name, instr.data);
      }

    case "comment"
    /* Comment */
    :
      return new Comment(node.data);

    case "tag"
    /* Tag */
    :
    case "script"
    /* Script */
    :
    case "style"
    /* Style */
    :
      {
        var elem = node;
        var children = recursive ? cloneChildren(elem.children) : [];
        var clone_1 = new Element(elem.name, __assign({}, elem.attribs), children);
        children.forEach(function (child) {
          return child.parent = clone_1;
        });
        return clone_1;
      }

    case "cdata"
    /* CDATA */
    :
      {
        var cdata = node;
        var children = recursive ? cloneChildren(cdata.children) : [];
        var clone_2 = new NodeWithChildren("cdata"
        /* CDATA */
        , children);
        children.forEach(function (child) {
          return child.parent = clone_2;
        });
        return clone_2;
      }

    case "doctype"
    /* Doctype */
    :
      {
        // This type isn't used yet.
        throw new Error("Not implemented yet: ElementType.Doctype case");
      }
  }
}

exports.cloneNode = cloneNode;

function cloneChildren(childs) {
  var children = childs.map(function (child) {
    return cloneNode(child, true);
  });

  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }

  return children;
}

},{}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;

var tagtypes_1 = require("./tagtypes");
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */


function removeSubsets(nodes) {
  var idx = nodes.length;
  /*
   * Check if each node (or one of its ancestors) is already contained in the
   * array.
   */

  while (--idx >= 0) {
    var node = nodes[idx];
    /*
     * Remove the node if it is not unique.
     * We are going through the array from the end, so we only
     * have to check nodes that preceed the node under consideration in the array.
     */

    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }

    for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }

  return nodes;
}

exports.removeSubsets = removeSubsets;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */

function compareDocumentPosition(nodeA, nodeB) {
  var aParents = [];
  var bParents = [];

  if (nodeA === nodeB) {
    return 0;
  }

  var current = tagtypes_1.hasChildren(nodeA) ? nodeA : nodeA.parent;

  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }

  current = tagtypes_1.hasChildren(nodeB) ? nodeB : nodeB.parent;

  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }

  var maxIdx = Math.min(aParents.length, bParents.length);
  var idx = 0;

  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }

  if (idx === 0) {
    return 1
    /* DISCONNECTED */
    ;
  }

  var sharedParent = aParents[idx - 1];
  var siblings = sharedParent.children;
  var aSibling = aParents[idx];
  var bSibling = bParents[idx];

  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return 4
      /* FOLLOWING */
      | 16
      /* CONTAINED_BY */
      ;
    }

    return 4
    /* FOLLOWING */
    ;
  }

  if (sharedParent === nodeA) {
    return 2
    /* PRECEDING */
    | 8
    /* CONTAINS */
    ;
  }

  return 2
  /* PRECEDING */
  ;
}

exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */

function uniqueSort(nodes) {
  nodes = nodes.filter(function (node, i, arr) {
    return !arr.includes(node, i + 1);
  });
  nodes.sort(function (a, b) {
    var relative = compareDocumentPosition(a, b);

    if (relative & 2
    /* PRECEDING */
    ) {
        return -1;
      } else if (relative & 4
    /* FOLLOWING */
    ) {
        return 1;
      }

    return 0;
  });
  return nodes;
}

exports.uniqueSort = uniqueSort;

},{"./tagtypes":73}],68:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./stringify"), exports);

__exportStar(require("./traversal"), exports);

__exportStar(require("./manipulation"), exports);

__exportStar(require("./querying"), exports);

__exportStar(require("./legacy"), exports);

__exportStar(require("./helpers"), exports);

__exportStar(require("./tagtypes"), exports);

},{"./helpers":67,"./legacy":69,"./manipulation":70,"./querying":71,"./stringify":72,"./tagtypes":73,"./traversal":74}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;

var querying_1 = require("./querying");

var tagtypes_1 = require("./tagtypes");

var Checks = {
  tag_name: function tag_name(name) {
    if (typeof name === "function") {
      return function (elem) {
        return tagtypes_1.isTag(elem) && name(elem.name);
      };
    } else if (name === "*") {
      return tagtypes_1.isTag;
    }

    return function (elem) {
      return tagtypes_1.isTag(elem) && elem.name === name;
    };
  },
  tag_type: function tag_type(type) {
    if (typeof type === "function") {
      return function (elem) {
        return type(elem.type);
      };
    }

    return function (elem) {
      return elem.type === type;
    };
  },
  tag_contains: function tag_contains(data) {
    if (typeof data === "function") {
      return function (elem) {
        return tagtypes_1.isText(elem) && data(elem.data);
      };
    }

    return function (elem) {
      return tagtypes_1.isText(elem) && elem.data === data;
    };
  }
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */

function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function (elem) {
      return tagtypes_1.isTag(elem) && value(elem.attribs[attrib]);
    };
  }

  return function (elem) {
    return tagtypes_1.isTag(elem) && elem.attribs[attrib] === value;
  };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */


function combineFuncs(a, b) {
  return function (elem) {
    return a(elem) || b(elem);
  };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */


function compileTest(options) {
  var funcs = Object.keys(options).map(function (key) {
    var value = options[key];
    return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */


function testElement(options, node) {
  var test = compileTest(options);
  return test ? test(node) : true;
}

exports.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */

function getElements(options, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }

  var test = compileTest(options);
  return test ? querying_1.filter(test, nodes, recurse, limit) : [];
}

exports.getElements = getElements;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */

function getElementById(id, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }

  if (!Array.isArray(nodes)) nodes = [nodes];
  return querying_1.findOne(getAttribCheck("id", id), nodes, recurse);
}

exports.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */

function getElementsByTagName(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }

  if (limit === void 0) {
    limit = Infinity;
  }

  return querying_1.filter(Checks.tag_name(tagName), nodes, recurse, limit);
}

exports.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */

function getElementsByTagType(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }

  if (limit === void 0) {
    limit = Infinity;
  }

  return querying_1.filter(Checks.tag_type(type), nodes, recurse, limit);
}

exports.getElementsByTagType = getElementsByTagType;

},{"./querying":71,"./tagtypes":73}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */

function removeElement(elem) {
  if (elem.prev) elem.prev.next = elem.next;
  if (elem.next) elem.next.prev = elem.prev;

  if (elem.parent) {
    var childs = elem.parent.children;
    childs.splice(childs.lastIndexOf(elem), 1);
  }
}

exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */

function replaceElement(elem, replacement) {
  var prev = replacement.prev = elem.prev;

  if (prev) {
    prev.next = replacement;
  }

  var next = replacement.next = elem.next;

  if (next) {
    next.prev = replacement;
  }

  var parent = replacement.parent = elem.parent;

  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
  }
}

exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */

function appendChild(elem, child) {
  removeElement(child);
  child.next = null;
  child.parent = elem;

  if (elem.children.push(child) > 1) {
    var sibling = elem.children[elem.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}

exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */

function append(elem, next) {
  removeElement(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;

  if (currNext) {
    currNext.prev = next;

    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}

exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */

function prependChild(elem, child) {
  removeElement(child);
  child.parent = elem;
  child.prev = null;

  if (elem.children.unshift(child) !== 1) {
    var sibling = elem.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}

exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */

function prepend(elem, prev) {
  removeElement(prev);
  var parent = elem.parent;

  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }

  if (elem.prev) {
    elem.prev.next = prev;
  }

  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

exports.prepend = prepend;

},{}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;

var tagtypes_1 = require("./tagtypes");
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */


function filter(test, node, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }

  if (limit === void 0) {
    limit = Infinity;
  }

  if (!Array.isArray(node)) node = [node];
  return find(test, node, recurse, limit);
}

exports.filter = filter;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */

function find(test, nodes, recurse, limit) {
  var result = [];

  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var elem = nodes_1[_i];

    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0) break;
    }

    if (recurse && tagtypes_1.hasChildren(elem) && elem.children.length > 0) {
      var children = find(test, elem.children, recurse, limit);
      result.push.apply(result, children);
      limit -= children.length;
      if (limit <= 0) break;
    }
  }

  return result;
}

exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */

function findOneChild(test, nodes) {
  return nodes.find(test);
}

exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */

function findOne(test, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }

  var elem = null;

  for (var i = 0; i < nodes.length && !elem; i++) {
    var checked = nodes[i];

    if (!tagtypes_1.isTag(checked)) {
      continue;
    } else if (test(checked)) {
      elem = checked;
    } else if (recurse && checked.children.length > 0) {
      elem = findOne(test, checked.children);
    }
  }

  return elem;
}

exports.findOne = findOne;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */

function existsOne(test, nodes) {
  return nodes.some(function (checked) {
    return tagtypes_1.isTag(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
  });
}

exports.existsOne = existsOne;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */

function findAll(test, nodes) {
  var _a;

  var result = [];
  var stack = nodes.filter(tagtypes_1.isTag);
  var elem;

  while (elem = stack.shift()) {
    var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(tagtypes_1.isTag);

    if (children && children.length > 0) {
      stack.unshift.apply(stack, children);
    }

    if (test(elem)) result.push(elem);
  }

  return result;
}

exports.findAll = findAll;

},{"./tagtypes":73}],72:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;

var tagtypes_1 = require("./tagtypes");

var dom_serializer_1 = __importDefault(require("dom-serializer"));
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */


function getOuterHTML(node, options) {
  return dom_serializer_1["default"](node, options);
}

exports.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */

function getInnerHTML(node, options) {
  return tagtypes_1.hasChildren(node) ? node.children.map(function (node) {
    return getOuterHTML(node, options);
  }).join("") : "";
}

exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */

function getText(node) {
  if (Array.isArray(node)) return node.map(getText).join("");
  if (tagtypes_1.isTag(node)) return node.name === "br" ? "\n" : getText(node.children);
  if (tagtypes_1.isCDATA(node)) return getText(node.children);
  if (tagtypes_1.isText(node)) return node.data;
  return "";
}

exports.getText = getText;

},{"./tagtypes":73,"dom-serializer":63}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasChildren = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;

var domelementtype_1 = require("domelementtype");
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */


function isTag(node) {
  return domelementtype_1.isTag(node);
}

exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren`, `false` otherwise.
 */

function isCDATA(node) {
  return node.type === "cdata"
  /* CDATA */
  ;
}

exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `DataNode`, `false` otherwise.
 */

function isText(node) {
  return node.type === "text"
  /* Text */
  ;
}

exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `DataNode`, `false` otherwise.
 */

function isComment(node) {
  return node.type === "comment"
  /* Comment */
  ;
}

exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */

function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}

exports.hasChildren = hasChildren;

},{"domelementtype":64}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;

var tagtypes_1 = require("./tagtypes");

var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */

function getChildren(elem) {
  var _a;

  return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}

exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */

function getParent(elem) {
  return elem.parent || null;
}

exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */

function getSiblings(elem) {
  var _a, _b;

  var parent = getParent(elem);
  if (parent != null) return getChildren(parent);
  var siblings = [elem];
  var prev = elem.prev,
      next = elem.next;

  while (prev != null) {
    siblings.unshift(prev);
    _a = prev, prev = _a.prev;
  }

  while (next != null) {
    siblings.push(next);
    _b = next, next = _b.next;
  }

  return siblings;
}

exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */

function getAttributeValue(elem, name) {
  var _a;

  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}

exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */

function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}

exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */

function getName(elem) {
  return elem.name;
}

exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */

function nextElementSibling(elem) {
  var _a;

  var next = elem.next;

  while (next !== null && !tagtypes_1.isTag(next)) {
    _a = next, next = _a.next;
  }

  return next;
}

exports.nextElementSibling = nextElementSibling;

},{"./tagtypes":73}],75:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;

var entities_json_1 = __importDefault(require("./maps/entities.json"));

var legacy_json_1 = __importDefault(require("./maps/legacy.json"));

var xml_json_1 = __importDefault(require("./maps/xml.json"));

var decode_codepoint_1 = __importDefault(require("./decode_codepoint"));

exports.decodeXML = getStrictDecoder(xml_json_1["default"]);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1["default"]);

function getStrictDecoder(map) {
  var keys = Object.keys(map).join("|");
  var replace = getReplacer(map);
  keys += "|#[xX][\\da-fA-F]+|#\\d+";
  var re = new RegExp("&(?:" + keys + ");", "g");
  return function (str) {
    return String(str).replace(re, replace);
  };
}

var sorter = function sorter(a, b) {
  return a < b ? 1 : -1;
};

exports.decodeHTML = function () {
  var legacy = Object.keys(legacy_json_1["default"]).sort(sorter);
  var keys = Object.keys(entities_json_1["default"]).sort(sorter);

  for (var i = 0, j = 0; i < keys.length; i++) {
    if (legacy[j] === keys[i]) {
      keys[i] += ";?";
      j++;
    } else {
      keys[i] += ";";
    }
  }

  var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
  var replace = getReplacer(entities_json_1["default"]);

  function replacer(str) {
    if (str.substr(-1) !== ";") str += ";";
    return replace(str);
  } // TODO consider creating a merged map


  return function (str) {
    return String(str).replace(re, replacer);
  };
}();

function getReplacer(map) {
  return function replace(str) {
    if (str.charAt(1) === "#") {
      var secondChar = str.charAt(2);

      if (secondChar === "X" || secondChar === "x") {
        return decode_codepoint_1["default"](parseInt(str.substr(3), 16));
      }

      return decode_codepoint_1["default"](parseInt(str.substr(2), 10));
    }

    return map[str.slice(1, -1)];
  };
}

},{"./decode_codepoint":76,"./maps/entities.json":80,"./maps/legacy.json":81,"./maps/xml.json":82}],76:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var decode_json_1 = __importDefault(require("./maps/decode.json")); // Modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119


function decodeCodePoint(codePoint) {
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return "\uFFFD";
  }

  if (codePoint in decode_json_1["default"]) {
    codePoint = decode_json_1["default"][codePoint];
  }

  var output = "";

  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }

  output += String.fromCharCode(codePoint);
  return output;
}

exports["default"] = decodeCodePoint;

},{"./maps/decode.json":79}],77:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.escape = exports.encodeHTML = exports.encodeXML = void 0;

var xml_json_1 = __importDefault(require("./maps/xml.json"));

var inverseXML = getInverseObj(xml_json_1["default"]);
var xmlReplacer = getInverseReplacer(inverseXML);
exports.encodeXML = getInverse(inverseXML, xmlReplacer);

var entities_json_1 = __importDefault(require("./maps/entities.json"));

var inverseHTML = getInverseObj(entities_json_1["default"]);
var htmlReplacer = getInverseReplacer(inverseHTML);
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);

function getInverseObj(obj) {
  return Object.keys(obj).sort().reduce(function (inverse, name) {
    inverse[obj[name]] = "&" + name + ";";
    return inverse;
  }, {});
}

function getInverseReplacer(inverse) {
  var single = [];
  var multiple = [];

  for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
    var k = _a[_i];

    if (k.length === 1) {
      // Add value to single array
      single.push("\\" + k);
    } else {
      // Add value to multiple array
      multiple.push(k);
    }
  } // Add ranges to single characters.


  single.sort();

  for (var start = 0; start < single.length - 1; start++) {
    // Find the end of a run of characters
    var end = start;

    while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
      end += 1;
    }

    var count = 1 + end - start; // We want to replace at least three characters

    if (count < 3) continue;
    single.splice(start, count, single[start] + "-" + single[end]);
  }

  multiple.unshift("[" + single.join("") + "]");
  return new RegExp(multiple.join("|"), "g");
}

var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;

function singleCharReplacer(c) {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  return "&#x" + c.codePointAt(0).toString(16).toUpperCase() + ";";
}

function getInverse(inverse, re) {
  return function (data) {
    return data.replace(re, function (name) {
      return inverse[name];
    }).replace(reNonASCII, singleCharReplacer);
  };
}

var reXmlChars = getInverseReplacer(inverseXML);

function escape(data) {
  return data.replace(reXmlChars, singleCharReplacer).replace(reNonASCII, singleCharReplacer);
}

exports.escape = escape;

},{"./maps/entities.json":80,"./maps/xml.json":82}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escape = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;

var decode_1 = require("./decode");

var encode_1 = require("./encode");
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */


function decode(data, level) {
  return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}

exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */

function decodeStrict(data, level) {
  return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}

exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 */

function encode(data, level) {
  return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}

exports.encode = encode;

var encode_2 = require("./encode");

Object.defineProperty(exports, "encodeXML", {
  enumerable: true,
  get: function get() {
    return encode_2.encodeXML;
  }
});
Object.defineProperty(exports, "encodeHTML", {
  enumerable: true,
  get: function get() {
    return encode_2.encodeHTML;
  }
});
Object.defineProperty(exports, "escape", {
  enumerable: true,
  get: function get() {
    return encode_2.escape;
  }
}); // Legacy aliases

Object.defineProperty(exports, "encodeHTML4", {
  enumerable: true,
  get: function get() {
    return encode_2.encodeHTML;
  }
});
Object.defineProperty(exports, "encodeHTML5", {
  enumerable: true,
  get: function get() {
    return encode_2.encodeHTML;
  }
});

var decode_2 = require("./decode");

Object.defineProperty(exports, "decodeXML", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeXML;
  }
});
Object.defineProperty(exports, "decodeHTML", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTML;
  }
});
Object.defineProperty(exports, "decodeHTMLStrict", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTMLStrict;
  }
}); // Legacy aliases

Object.defineProperty(exports, "decodeHTML4", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTML;
  }
});
Object.defineProperty(exports, "decodeHTML5", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTML;
  }
});
Object.defineProperty(exports, "decodeHTML4Strict", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTMLStrict;
  }
});
Object.defineProperty(exports, "decodeHTML5Strict", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeHTMLStrict;
  }
});
Object.defineProperty(exports, "decodeXMLStrict", {
  enumerable: true,
  get: function get() {
    return decode_2.decodeXML;
  }
});

},{"./decode":75,"./encode":77}],79:[function(require,module,exports){
module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}

},{}],80:[function(require,module,exports){
module.exports={"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\"","QUOT":"\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""}

},{}],81:[function(require,module,exports){
module.exports={"Aacute":"","aacute":"","Acirc":"","acirc":"","acute":"","AElig":"","aelig":"","Agrave":"","agrave":"","amp":"&","AMP":"&","Aring":"","aring":"","Atilde":"","atilde":"","Auml":"","auml":"","brvbar":"","Ccedil":"","ccedil":"","cedil":"","cent":"","copy":"","COPY":"","curren":"","deg":"","divide":"","Eacute":"","eacute":"","Ecirc":"","ecirc":"","Egrave":"","egrave":"","ETH":"","eth":"","Euml":"","euml":"","frac12":"","frac14":"","frac34":"","gt":">","GT":">","Iacute":"","iacute":"","Icirc":"","icirc":"","iexcl":"","Igrave":"","igrave":"","iquest":"","Iuml":"","iuml":"","laquo":"","lt":"<","LT":"<","macr":"","micro":"","middot":"","nbsp":"","not":"","Ntilde":"","ntilde":"","Oacute":"","oacute":"","Ocirc":"","ocirc":"","Ograve":"","ograve":"","ordf":"","ordm":"","Oslash":"","oslash":"","Otilde":"","otilde":"","Ouml":"","ouml":"","para":"","plusmn":"","pound":"","quot":"\"","QUOT":"\"","raquo":"","reg":"","REG":"","sect":"","shy":"","sup1":"","sup2":"","sup3":"","szlig":"","THORN":"","thorn":"","times":"","Uacute":"","uacute":"","Ucirc":"","ucirc":"","Ugrave":"","ugrave":"","uml":"","Uuml":"","uuml":"","Yacute":"","yacute":"","yen":"","yuml":""}

},{}],82:[function(require,module,exports){
module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

},{}],83:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var R = (typeof Reflect === "undefined" ? "undefined" : (0, _typeof2["default"])(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + (0, _typeof2["default"])(listener));
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    var errorListener; // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.

    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],84:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseFeed = exports.FeedHandler = void 0;

var domhandler_1 = __importDefault(require("domhandler"));

var DomUtils = __importStar(require("domutils"));

var Parser_1 = require("./Parser");

var FeedItemMediaMedium;

(function (FeedItemMediaMedium) {
  FeedItemMediaMedium[FeedItemMediaMedium["image"] = 0] = "image";
  FeedItemMediaMedium[FeedItemMediaMedium["audio"] = 1] = "audio";
  FeedItemMediaMedium[FeedItemMediaMedium["video"] = 2] = "video";
  FeedItemMediaMedium[FeedItemMediaMedium["document"] = 3] = "document";
  FeedItemMediaMedium[FeedItemMediaMedium["executable"] = 4] = "executable";
})(FeedItemMediaMedium || (FeedItemMediaMedium = {}));

var FeedItemMediaExpression;

(function (FeedItemMediaExpression) {
  FeedItemMediaExpression[FeedItemMediaExpression["sample"] = 0] = "sample";
  FeedItemMediaExpression[FeedItemMediaExpression["full"] = 1] = "full";
  FeedItemMediaExpression[FeedItemMediaExpression["nonstop"] = 2] = "nonstop";
})(FeedItemMediaExpression || (FeedItemMediaExpression = {})); // TODO: Consume data as it is coming in


var FeedHandler =
/** @class */
function (_super) {
  __extends(FeedHandler, _super);
  /**
   *
   * @param callback
   * @param options
   */


  function FeedHandler(callback, options) {
    var _this = this;

    if ((0, _typeof2["default"])(callback) === "object") {
      callback = undefined;
      options = callback;
    }

    _this = _super.call(this, callback, options) || this;
    return _this;
  }

  FeedHandler.prototype.onend = function () {
    var _a, _b;

    var feed = {};
    var feedRoot = getOneElement(isValidFeed, this.dom);

    if (feedRoot) {
      if (feedRoot.name === "feed") {
        var childs = feedRoot.children;
        feed.type = "atom";
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        var href = getAttribute("href", getOneElement("link", childs));

        if (href) {
          feed.link = href;
        }

        addConditionally(feed, "description", "subtitle", childs);
        var updated = fetch("updated", childs);

        if (updated) {
          feed.updated = new Date(updated);
        }

        addConditionally(feed, "author", "email", childs, true);
        feed.items = getElements("entry", childs).map(function (item) {
          var entry = {};
          var children = item.children;
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href = getAttribute("href", getOneElement("link", children));

          if (href) {
            entry.link = href;
          }

          var description = fetch("summary", children) || fetch("content", children);

          if (description) {
            entry.description = description;
          }

          var pubDate = fetch("updated", children);

          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }

          entry.media = getMediaElements(children);
          return entry;
        });
      } else {
        var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
        feed.type = feedRoot.name.substr(0, 3);
        feed.id = "";
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        var updated = fetch("lastBuildDate", childs);

        if (updated) {
          feed.updated = new Date(updated);
        }

        addConditionally(feed, "author", "managingEditor", childs, true);
        feed.items = getElements("item", feedRoot.children).map(function (item) {
          var entry = {};
          var children = item.children;
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch("pubDate", children);
          if (pubDate) entry.pubDate = new Date(pubDate);
          entry.media = getMediaElements(children);
          return entry;
        });
      }
    }

    this.feed = feed;
    this.handleCallback(feedRoot ? null : Error("couldn't find root of feed"));
  };

  return FeedHandler;
}(domhandler_1["default"]);

exports.FeedHandler = FeedHandler;

function getMediaElements(where) {
  return getElements("media:content", where).map(function (elem) {
    var media = {
      medium: elem.attribs.medium,
      isDefault: !!elem.attribs.isDefault
    };

    if (elem.attribs.url) {
      media.url = elem.attribs.url;
    }

    if (elem.attribs.fileSize) {
      media.fileSize = parseInt(elem.attribs.fileSize, 10);
    }

    if (elem.attribs.type) {
      media.type = elem.attribs.type;
    }

    if (elem.attribs.expression) {
      media.expression = elem.attribs.expression;
    }

    if (elem.attribs.bitrate) {
      media.bitrate = parseInt(elem.attribs.bitrate, 10);
    }

    if (elem.attribs.framerate) {
      media.framerate = parseInt(elem.attribs.framerate, 10);
    }

    if (elem.attribs.samplingrate) {
      media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
    }

    if (elem.attribs.channels) {
      media.channels = parseInt(elem.attribs.channels, 10);
    }

    if (elem.attribs.duration) {
      media.duration = parseInt(elem.attribs.duration, 10);
    }

    if (elem.attribs.height) {
      media.height = parseInt(elem.attribs.height, 10);
    }

    if (elem.attribs.width) {
      media.width = parseInt(elem.attribs.width, 10);
    }

    if (elem.attribs.lang) {
      media.lang = elem.attribs.lang;
    }

    return media;
  });
}

function getElements(tagName, where) {
  return DomUtils.getElementsByTagName(tagName, where, true);
}

function getOneElement(tagName, node) {
  return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
}

function fetch(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }

  return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
}

function getAttribute(name, elem) {
  if (!elem) {
    return null;
  }

  var attribs = elem.attribs;
  return attribs[name];
}

function addConditionally(obj, prop, what, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }

  var tmp = fetch(what, where, recurse);
  if (tmp) obj[prop] = tmp;
}

function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

var defaultOptions = {
  xmlMode: true
};
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this option, you probably want to set `xmlMode` to `true`.
 */

function parseFeed(feed, options) {
  if (options === void 0) {
    options = defaultOptions;
  }

  var handler = new FeedHandler(options);
  new Parser_1.Parser(handler, options).end(feed);
  return handler.feed;
}

exports.parseFeed = parseFeed;

},{"./Parser":85,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27,"domhandler":65,"domutils":68}],85:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = void 0;

var Tokenizer_1 = __importDefault(require("./Tokenizer"));

var formTags = new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]);
var pTag = new Set(["p"]);
var openImpliesClose = {
  tr: new Set(["tr", "th", "td"]),
  th: new Set(["th"]),
  td: new Set(["thead", "th", "td"]),
  body: new Set(["head", "link", "script"]),
  li: new Set(["li"]),
  p: pTag,
  h1: pTag,
  h2: pTag,
  h3: pTag,
  h4: pTag,
  h5: pTag,
  h6: pTag,
  select: formTags,
  input: formTags,
  output: formTags,
  button: formTags,
  datalist: formTags,
  textarea: formTags,
  option: new Set(["option"]),
  optgroup: new Set(["optgroup", "option"]),
  dd: new Set(["dt", "dd"]),
  dt: new Set(["dt", "dd"]),
  address: pTag,
  article: pTag,
  aside: pTag,
  blockquote: pTag,
  details: pTag,
  div: pTag,
  dl: pTag,
  fieldset: pTag,
  figcaption: pTag,
  figure: pTag,
  footer: pTag,
  form: pTag,
  header: pTag,
  hr: pTag,
  main: pTag,
  nav: pTag,
  ol: pTag,
  pre: pTag,
  section: pTag,
  table: pTag,
  ul: pTag,
  rt: new Set(["rt", "rp"]),
  rp: new Set(["rt", "rp"]),
  tbody: new Set(["thead", "tbody"]),
  tfoot: new Set(["thead", "tbody"])
};
var voidElements = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]);
var reNameEnd = /\s|\//;

var Parser =
/** @class */
function () {
  function Parser(cbs, options) {
    if (options === void 0) {
      options = {};
    }

    var _a, _b, _c, _d, _e;
    /** The start index of the last event. */


    this.startIndex = 0;
    /** The end index of the last event. */

    this.endIndex = null;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.options = options;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1["default"])(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }

  Parser.prototype.updatePosition = function (initialOffset) {
    if (this.endIndex === null) {
      if (this.tokenizer.sectionStart <= initialOffset) {
        this.startIndex = 0;
      } else {
        this.startIndex = this.tokenizer.sectionStart - initialOffset;
      }
    } else {
      this.startIndex = this.endIndex + 1;
    }

    this.endIndex = this.tokenizer.getAbsoluteIndex();
  }; // Tokenizer event handlers


  Parser.prototype.ontext = function (data) {
    var _a, _b;

    this.updatePosition(1);
    this.endIndex--;
    (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
  };

  Parser.prototype.onopentagname = function (name) {
    var _a, _b;

    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }

    this.tagname = name;

    if (!this.options.xmlMode && Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
      var el = void 0;

      while (this.stack.length > 0 && openImpliesClose[name].has(el = this.stack[this.stack.length - 1])) {
        this.onclosetag(el);
      }
    }

    if (this.options.xmlMode || !voidElements.has(name)) {
      this.stack.push(name);

      if (foreignContextElements.has(name)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name)) {
        this.foreignContext.push(false);
      }
    }

    (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);
    if (this.cbs.onopentag) this.attribs = {};
  };

  Parser.prototype.onopentagend = function () {
    var _a, _b;

    this.updatePosition(1);

    if (this.attribs) {
      (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);
      this.attribs = null;
    }

    if (!this.options.xmlMode && this.cbs.onclosetag && voidElements.has(this.tagname)) {
      this.cbs.onclosetag(this.tagname);
    }

    this.tagname = "";
  };

  Parser.prototype.onclosetag = function (name) {
    this.updatePosition(1);

    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }

    if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
      this.foreignContext.pop();
    }

    if (this.stack.length && (this.options.xmlMode || !voidElements.has(name))) {
      var pos = this.stack.lastIndexOf(name);

      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          pos = this.stack.length - pos;

          while (pos--) {
            // We know the stack has sufficient elements.
            this.cbs.onclosetag(this.stack.pop());
          }
        } else this.stack.length = pos;
      } else if (name === "p" && !this.options.xmlMode) {
        this.onopentagname(name);
        this.closeCurrentTag();
      }
    } else if (!this.options.xmlMode && (name === "br" || name === "p")) {
      this.onopentagname(name);
      this.closeCurrentTag();
    }
  };

  Parser.prototype.onselfclosingtag = function () {
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag();
    } else {
      this.onopentagend();
    }
  };

  Parser.prototype.closeCurrentTag = function () {
    var _a, _b;

    var name = this.tagname;
    this.onopentagend();
    /*
     * Self-closing tags will be on the top of the stack
     * (cheaper check than in onclosetag)
     */

    if (this.stack[this.stack.length - 1] === name) {
      (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name);
      this.stack.pop();
    }
  };

  Parser.prototype.onattribname = function (name) {
    if (this.lowerCaseAttributeNames) {
      name = name.toLowerCase();
    }

    this.attribname = name;
  };

  Parser.prototype.onattribdata = function (value) {
    this.attribvalue += value;
  };

  Parser.prototype.onattribend = function (quote) {
    var _a, _b;

    (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);

    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }

    this.attribname = "";
    this.attribvalue = "";
  };

  Parser.prototype.getInstructionName = function (value) {
    var idx = value.search(reNameEnd);
    var name = idx < 0 ? value : value.substr(0, idx);

    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }

    return name;
  };

  Parser.prototype.ondeclaration = function (value) {
    if (this.cbs.onprocessinginstruction) {
      var name_1 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
    }
  };

  Parser.prototype.onprocessinginstruction = function (value) {
    if (this.cbs.onprocessinginstruction) {
      var name_2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
    }
  };

  Parser.prototype.oncomment = function (value) {
    var _a, _b, _c, _d;

    this.updatePosition(4);
    (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
  };

  Parser.prototype.oncdata = function (value) {
    var _a, _b, _c, _d, _e, _f;

    this.updatePosition(1);

    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      this.oncomment("[CDATA[" + value + "]]");
    }
  };

  Parser.prototype.onerror = function (err) {
    var _a, _b;

    (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };

  Parser.prototype.onend = function () {
    var _a, _b;

    if (this.cbs.onclosetag) {
      for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i])) {
        ;
      }
    }

    (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */


  Parser.prototype.reset = function () {
    var _a, _b, _c, _d;

    (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack = [];
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
  };
  /**
   * Parses a complete document and pushes it to the handler.
   *
   * @param data Document to parse.
   */


  Parser.prototype.parseComplete = function (data) {
    this.reset();
    this.end(data);
  };
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */


  Parser.prototype.write = function (chunk) {
    this.tokenizer.write(chunk);
  };
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */


  Parser.prototype.end = function (chunk) {
    this.tokenizer.end(chunk);
  };
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */


  Parser.prototype.pause = function () {
    this.tokenizer.pause();
  };
  /**
   * Resumes parsing after `pause` was called.
   */


  Parser.prototype.resume = function () {
    this.tokenizer.resume();
  };
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */


  Parser.prototype.parseChunk = function (chunk) {
    this.write(chunk);
  };
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */


  Parser.prototype.done = function (chunk) {
    this.end(chunk);
  };

  return Parser;
}();

exports.Parser = Parser;

},{"./Tokenizer":86}],86:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var decode_codepoint_1 = __importDefault(require("entities/lib/decode_codepoint"));

var entities_json_1 = __importDefault(require("entities/lib/maps/entities.json"));

var legacy_json_1 = __importDefault(require("entities/lib/maps/legacy.json"));

var xml_json_1 = __importDefault(require("entities/lib/maps/xml.json"));

function whitespace(c) {
  return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function isASCIIAlpha(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
}

function ifElseState(upper, SUCCESS, FAILURE) {
  var lower = upper.toLowerCase();

  if (upper === lower) {
    return function (t, c) {
      if (c === lower) {
        t._state = SUCCESS;
      } else {
        t._state = FAILURE;
        t._index--;
      }
    };
  }

  return function (t, c) {
    if (c === lower || c === upper) {
      t._state = SUCCESS;
    } else {
      t._state = FAILURE;
      t._index--;
    }
  };
}

function consumeSpecialNameChar(upper, NEXT_STATE) {
  var lower = upper.toLowerCase();
  return function (t, c) {
    if (c === lower || c === upper) {
      t._state = NEXT_STATE;
    } else {
      t._state = 3
      /* InTagName */
      ;
      t._index--; // Consume the token again
    }
  };
}

var stateBeforeCdata1 = ifElseState("C", 24
/* BeforeCdata2 */
, 16
/* InDeclaration */
);
var stateBeforeCdata2 = ifElseState("D", 25
/* BeforeCdata3 */
, 16
/* InDeclaration */
);
var stateBeforeCdata3 = ifElseState("A", 26
/* BeforeCdata4 */
, 16
/* InDeclaration */
);
var stateBeforeCdata4 = ifElseState("T", 27
/* BeforeCdata5 */
, 16
/* InDeclaration */
);
var stateBeforeCdata5 = ifElseState("A", 28
/* BeforeCdata6 */
, 16
/* InDeclaration */
);
var stateBeforeScript1 = consumeSpecialNameChar("R", 35
/* BeforeScript2 */
);
var stateBeforeScript2 = consumeSpecialNameChar("I", 36
/* BeforeScript3 */
);
var stateBeforeScript3 = consumeSpecialNameChar("P", 37
/* BeforeScript4 */
);
var stateBeforeScript4 = consumeSpecialNameChar("T", 38
/* BeforeScript5 */
);
var stateAfterScript1 = ifElseState("R", 40
/* AfterScript2 */
, 1
/* Text */
);
var stateAfterScript2 = ifElseState("I", 41
/* AfterScript3 */
, 1
/* Text */
);
var stateAfterScript3 = ifElseState("P", 42
/* AfterScript4 */
, 1
/* Text */
);
var stateAfterScript4 = ifElseState("T", 43
/* AfterScript5 */
, 1
/* Text */
);
var stateBeforeStyle1 = consumeSpecialNameChar("Y", 45
/* BeforeStyle2 */
);
var stateBeforeStyle2 = consumeSpecialNameChar("L", 46
/* BeforeStyle3 */
);
var stateBeforeStyle3 = consumeSpecialNameChar("E", 47
/* BeforeStyle4 */
);
var stateAfterStyle1 = ifElseState("Y", 49
/* AfterStyle2 */
, 1
/* Text */
);
var stateAfterStyle2 = ifElseState("L", 50
/* AfterStyle3 */
, 1
/* Text */
);
var stateAfterStyle3 = ifElseState("E", 51
/* AfterStyle4 */
, 1
/* Text */
);
var stateBeforeSpecialT = consumeSpecialNameChar("I", 54
/* BeforeTitle1 */
);
var stateBeforeTitle1 = consumeSpecialNameChar("T", 55
/* BeforeTitle2 */
);
var stateBeforeTitle2 = consumeSpecialNameChar("L", 56
/* BeforeTitle3 */
);
var stateBeforeTitle3 = consumeSpecialNameChar("E", 57
/* BeforeTitle4 */
);
var stateAfterSpecialTEnd = ifElseState("I", 58
/* AfterTitle1 */
, 1
/* Text */
);
var stateAfterTitle1 = ifElseState("T", 59
/* AfterTitle2 */
, 1
/* Text */
);
var stateAfterTitle2 = ifElseState("L", 60
/* AfterTitle3 */
, 1
/* Text */
);
var stateAfterTitle3 = ifElseState("E", 61
/* AfterTitle4 */
, 1
/* Text */
);
var stateBeforeEntity = ifElseState("#", 63
/* BeforeNumericEntity */
, 64
/* InNamedEntity */
);
var stateBeforeNumericEntity = ifElseState("X", 66
/* InHexEntity */
, 65
/* InNumericEntity */
);

var Tokenizer =
/** @class */
function () {
  function Tokenizer(options, cbs) {
    var _a;
    /** The current state the tokenizer is in. */


    this._state = 1
    /* Text */
    ;
    /** The read buffer. */

    this.buffer = "";
    /** The beginning of the section that is currently being read. */

    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */

    this._index = 0;
    /**
     * Data that has already been processed will be removed from the buffer occasionally.
     * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
     */

    this.bufferOffset = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */

    this.baseState = 1
    /* Text */
    ;
    /** For special parsing behavior inside of script and style tags. */

    this.special = 1
    /* None */
    ;
    /** Indicates whether the tokenizer has been paused. */

    this.running = true;
    /** Indicates whether the tokenizer has finished running / `.end` has been called. */

    this.ended = false;
    this.cbs = cbs;
    this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
    this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;
  }

  Tokenizer.prototype.reset = function () {
    this._state = 1
    /* Text */
    ;
    this.buffer = "";
    this.sectionStart = 0;
    this._index = 0;
    this.bufferOffset = 0;
    this.baseState = 1
    /* Text */
    ;
    this.special = 1
    /* None */
    ;
    this.running = true;
    this.ended = false;
  };

  Tokenizer.prototype.write = function (chunk) {
    if (this.ended) this.cbs.onerror(Error(".write() after done!"));
    this.buffer += chunk;
    this.parse();
  };

  Tokenizer.prototype.end = function (chunk) {
    if (this.ended) this.cbs.onerror(Error(".end() after done!"));
    if (chunk) this.write(chunk);
    this.ended = true;
    if (this.running) this.finish();
  };

  Tokenizer.prototype.pause = function () {
    this.running = false;
  };

  Tokenizer.prototype.resume = function () {
    this.running = true;

    if (this._index < this.buffer.length) {
      this.parse();
    }

    if (this.ended) {
      this.finish();
    }
  };
  /**
   * The current index within all of the written data.
   */


  Tokenizer.prototype.getAbsoluteIndex = function () {
    return this.bufferOffset + this._index;
  };

  Tokenizer.prototype.stateText = function (c) {
    if (c === "<") {
      if (this._index > this.sectionStart) {
        this.cbs.ontext(this.getSection());
      }

      this._state = 2
      /* BeforeTagName */
      ;
      this.sectionStart = this._index;
    } else if (this.decodeEntities && c === "&" && (this.special === 1
    /* None */
    || this.special === 4
    /* Title */
    )) {
      if (this._index > this.sectionStart) {
        this.cbs.ontext(this.getSection());
      }

      this.baseState = 1
      /* Text */
      ;
      this._state = 62
      /* BeforeEntity */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateBeforeTagName = function (c) {
    if (c === "/") {
      this._state = 5
      /* BeforeClosingTagName */
      ;
    } else if (c === "<") {
      this.cbs.ontext(this.getSection());
      this.sectionStart = this._index;
    } else if (c === ">" || this.special !== 1
    /* None */
    || whitespace(c)) {
      this._state = 1
      /* Text */
      ;
    } else if (c === "!") {
      this._state = 15
      /* BeforeDeclaration */
      ;
      this.sectionStart = this._index + 1;
    } else if (c === "?") {
      this._state = 17
      /* InProcessingInstruction */
      ;
      this.sectionStart = this._index + 1;
    } else if (!isASCIIAlpha(c)) {
      this._state = 1
      /* Text */
      ;
    } else {
      this._state = !this.xmlMode && (c === "s" || c === "S") ? 32
      /* BeforeSpecialS */
      : !this.xmlMode && (c === "t" || c === "T") ? 52
      /* BeforeSpecialT */
      : 3
      /* InTagName */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateInTagName = function (c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this.emitToken("onopentagname");
      this._state = 8
      /* BeforeAttributeName */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
    if (whitespace(c)) {// Ignore
    } else if (c === ">") {
      this._state = 1
      /* Text */
      ;
    } else if (this.special !== 1
    /* None */
    ) {
        if (c === "s" || c === "S") {
          this._state = 33
          /* BeforeSpecialSEnd */
          ;
        } else if (c === "t" || c === "T") {
          this._state = 53
          /* BeforeSpecialTEnd */
          ;
        } else {
          this._state = 1
          /* Text */
          ;
          this._index--;
        }
      } else if (!isASCIIAlpha(c)) {
      this._state = 20
      /* InSpecialComment */
      ;
      this.sectionStart = this._index;
    } else {
      this._state = 6
      /* InClosingTagName */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateInClosingTagName = function (c) {
    if (c === ">" || whitespace(c)) {
      this.emitToken("onclosetag");
      this._state = 7
      /* AfterClosingTagName */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateAfterClosingTagName = function (c) {
    // Skip everything until ">"
    if (c === ">") {
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    }
  };

  Tokenizer.prototype.stateBeforeAttributeName = function (c) {
    if (c === ">") {
      this.cbs.onopentagend();
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    } else if (c === "/") {
      this._state = 4
      /* InSelfClosingTag */
      ;
    } else if (!whitespace(c)) {
      this._state = 9
      /* InAttributeName */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateInSelfClosingTag = function (c) {
    if (c === ">") {
      this.cbs.onselfclosingtag();
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
      this.special = 1
      /* None */
      ; // Reset special state, in case of self-closing special tags
    } else if (!whitespace(c)) {
      this._state = 8
      /* BeforeAttributeName */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateInAttributeName = function (c) {
    if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
      this.cbs.onattribname(this.getSection());
      this.sectionStart = -1;
      this._state = 10
      /* AfterAttributeName */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateAfterAttributeName = function (c) {
    if (c === "=") {
      this._state = 11
      /* BeforeAttributeValue */
      ;
    } else if (c === "/" || c === ">") {
      this.cbs.onattribend(undefined);
      this._state = 8
      /* BeforeAttributeName */
      ;
      this._index--;
    } else if (!whitespace(c)) {
      this.cbs.onattribend(undefined);
      this._state = 9
      /* InAttributeName */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
    if (c === '"') {
      this._state = 12
      /* InAttributeValueDq */
      ;
      this.sectionStart = this._index + 1;
    } else if (c === "'") {
      this._state = 13
      /* InAttributeValueSq */
      ;
      this.sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
      this._state = 14
      /* InAttributeValueNq */
      ;
      this.sectionStart = this._index;
      this._index--; // Reconsume token
    }
  };

  Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
    if (c === quote) {
      this.emitToken("onattribdata");
      this.cbs.onattribend(quote);
      this._state = 8
      /* BeforeAttributeName */
      ;
    } else if (this.decodeEntities && c === "&") {
      this.emitToken("onattribdata");
      this.baseState = this._state;
      this._state = 62
      /* BeforeEntity */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
    this.handleInAttributeValue(c, '"');
  };

  Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
    this.handleInAttributeValue(c, "'");
  };

  Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
    if (whitespace(c) || c === ">") {
      this.emitToken("onattribdata");
      this.cbs.onattribend(null);
      this._state = 8
      /* BeforeAttributeName */
      ;
      this._index--;
    } else if (this.decodeEntities && c === "&") {
      this.emitToken("onattribdata");
      this.baseState = this._state;
      this._state = 62
      /* BeforeEntity */
      ;
      this.sectionStart = this._index;
    }
  };

  Tokenizer.prototype.stateBeforeDeclaration = function (c) {
    this._state = c === "[" ? 23
    /* BeforeCdata1 */
    : c === "-" ? 18
    /* BeforeComment */
    : 16
    /* InDeclaration */
    ;
  };

  Tokenizer.prototype.stateInDeclaration = function (c) {
    if (c === ">") {
      this.cbs.ondeclaration(this.getSection());
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    }
  };

  Tokenizer.prototype.stateInProcessingInstruction = function (c) {
    if (c === ">") {
      this.cbs.onprocessinginstruction(this.getSection());
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    }
  };

  Tokenizer.prototype.stateBeforeComment = function (c) {
    if (c === "-") {
      this._state = 19
      /* InComment */
      ;
      this.sectionStart = this._index + 1;
    } else {
      this._state = 16
      /* InDeclaration */
      ;
    }
  };

  Tokenizer.prototype.stateInComment = function (c) {
    if (c === "-") this._state = 21
    /* AfterComment1 */
    ;
  };

  Tokenizer.prototype.stateInSpecialComment = function (c) {
    if (c === ">") {
      this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    }
  };

  Tokenizer.prototype.stateAfterComment1 = function (c) {
    if (c === "-") {
      this._state = 22
      /* AfterComment2 */
      ;
    } else {
      this._state = 19
      /* InComment */
      ;
    }
  };

  Tokenizer.prototype.stateAfterComment2 = function (c) {
    if (c === ">") {
      // Remove 2 trailing chars
      this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    } else if (c !== "-") {
      this._state = 19
      /* InComment */
      ;
    } // Else: stay in AFTER_COMMENT_2 (`--->`)

  };

  Tokenizer.prototype.stateBeforeCdata6 = function (c) {
    if (c === "[") {
      this._state = 29
      /* InCdata */
      ;
      this.sectionStart = this._index + 1;
    } else {
      this._state = 16
      /* InDeclaration */
      ;
      this._index--;
    }
  };

  Tokenizer.prototype.stateInCdata = function (c) {
    if (c === "]") this._state = 30
    /* AfterCdata1 */
    ;
  };

  Tokenizer.prototype.stateAfterCdata1 = function (c) {
    if (c === "]") this._state = 31
    /* AfterCdata2 */
    ;else this._state = 29
    /* InCdata */
    ;
  };

  Tokenizer.prototype.stateAfterCdata2 = function (c) {
    if (c === ">") {
      // Remove 2 trailing chars
      this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
      this._state = 1
      /* Text */
      ;
      this.sectionStart = this._index + 1;
    } else if (c !== "]") {
      this._state = 29
      /* InCdata */
      ;
    } // Else: stay in AFTER_CDATA_2 (`]]]>`)

  };

  Tokenizer.prototype.stateBeforeSpecialS = function (c) {
    if (c === "c" || c === "C") {
      this._state = 34
      /* BeforeScript1 */
      ;
    } else if (c === "t" || c === "T") {
      this._state = 44
      /* BeforeStyle1 */
      ;
    } else {
      this._state = 3
      /* InTagName */
      ;
      this._index--; // Consume the token again
    }
  };

  Tokenizer.prototype.stateBeforeSpecialSEnd = function (c) {
    if (this.special === 2
    /* Script */
    && (c === "c" || c === "C")) {
      this._state = 39
      /* AfterScript1 */
      ;
    } else if (this.special === 3
    /* Style */
    && (c === "t" || c === "T")) {
      this._state = 48
      /* AfterStyle1 */
      ;
    } else this._state = 1
    /* Text */
    ;
  };

  Tokenizer.prototype.stateBeforeSpecialLast = function (c, special) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this.special = special;
    }

    this._state = 3
    /* InTagName */
    ;
    this._index--; // Consume the token again
  };

  Tokenizer.prototype.stateAfterSpecialLast = function (c, sectionStartOffset) {
    if (c === ">" || whitespace(c)) {
      this.special = 1
      /* None */
      ;
      this._state = 6
      /* InClosingTagName */
      ;
      this.sectionStart = this._index - sectionStartOffset;
      this._index--; // Reconsume the token
    } else this._state = 1
    /* Text */
    ;
  }; // For entities terminated with a semicolon


  Tokenizer.prototype.parseFixedEntity = function (map) {
    if (map === void 0) {
      map = this.xmlMode ? xml_json_1["default"] : entities_json_1["default"];
    } // Offset = 1


    if (this.sectionStart + 1 < this._index) {
      var entity = this.buffer.substring(this.sectionStart + 1, this._index);

      if (Object.prototype.hasOwnProperty.call(map, entity)) {
        this.emitPartial(map[entity]);
        this.sectionStart = this._index + 1;
      }
    }
  }; // Parses legacy entities (without trailing semicolon)


  Tokenizer.prototype.parseLegacyEntity = function () {
    var start = this.sectionStart + 1; // The max length of legacy entities is 6

    var limit = Math.min(this._index - start, 6);

    while (limit >= 2) {
      // The min length of legacy entities is 2
      var entity = this.buffer.substr(start, limit);

      if (Object.prototype.hasOwnProperty.call(legacy_json_1["default"], entity)) {
        this.emitPartial(legacy_json_1["default"][entity]);
        this.sectionStart += limit + 1;
        return;
      }

      limit--;
    }
  };

  Tokenizer.prototype.stateInNamedEntity = function (c) {
    if (c === ";") {
      this.parseFixedEntity(); // Retry as legacy entity if entity wasn't parsed

      if (this.baseState === 1
      /* Text */
      && this.sectionStart + 1 < this._index && !this.xmlMode) {
        this.parseLegacyEntity();
      }

      this._state = this.baseState;
    } else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
      if (this.xmlMode || this.sectionStart + 1 === this._index) {// Ignore
      } else if (this.baseState !== 1
      /* Text */
      ) {
          if (c !== "=") {
            // Parse as legacy entity, without allowing additional characters.
            this.parseFixedEntity(legacy_json_1["default"]);
          }
        } else {
        this.parseLegacyEntity();
      }

      this._state = this.baseState;
      this._index--;
    }
  };

  Tokenizer.prototype.decodeNumericEntity = function (offset, base, strict) {
    var sectionStart = this.sectionStart + offset;

    if (sectionStart !== this._index) {
      // Parse entity
      var entity = this.buffer.substring(sectionStart, this._index);
      var parsed = parseInt(entity, base);
      this.emitPartial(decode_codepoint_1["default"](parsed));
      this.sectionStart = strict ? this._index + 1 : this._index;
    }

    this._state = this.baseState;
  };

  Tokenizer.prototype.stateInNumericEntity = function (c) {
    if (c === ";") {
      this.decodeNumericEntity(2, 10, true);
    } else if (c < "0" || c > "9") {
      if (!this.xmlMode) {
        this.decodeNumericEntity(2, 10, false);
      } else {
        this._state = this.baseState;
      }

      this._index--;
    }
  };

  Tokenizer.prototype.stateInHexEntity = function (c) {
    if (c === ";") {
      this.decodeNumericEntity(3, 16, true);
    } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
      if (!this.xmlMode) {
        this.decodeNumericEntity(3, 16, false);
      } else {
        this._state = this.baseState;
      }

      this._index--;
    }
  };

  Tokenizer.prototype.cleanup = function () {
    if (this.sectionStart < 0) {
      this.buffer = "";
      this.bufferOffset += this._index;
      this._index = 0;
    } else if (this.running) {
      if (this._state === 1
      /* Text */
      ) {
          if (this.sectionStart !== this._index) {
            this.cbs.ontext(this.buffer.substr(this.sectionStart));
          }

          this.buffer = "";
          this.bufferOffset += this._index;
          this._index = 0;
        } else if (this.sectionStart === this._index) {
        // The section just started
        this.buffer = "";
        this.bufferOffset += this._index;
        this._index = 0;
      } else {
        // Remove everything unnecessary
        this.buffer = this.buffer.substr(this.sectionStart);
        this._index -= this.sectionStart;
        this.bufferOffset += this.sectionStart;
      }

      this.sectionStart = 0;
    }
  };
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */


  Tokenizer.prototype.parse = function () {
    while (this._index < this.buffer.length && this.running) {
      var c = this.buffer.charAt(this._index);

      if (this._state === 1
      /* Text */
      ) {
          this.stateText(c);
        } else if (this._state === 12
      /* InAttributeValueDq */
      ) {
          this.stateInAttributeValueDoubleQuotes(c);
        } else if (this._state === 9
      /* InAttributeName */
      ) {
          this.stateInAttributeName(c);
        } else if (this._state === 19
      /* InComment */
      ) {
          this.stateInComment(c);
        } else if (this._state === 20
      /* InSpecialComment */
      ) {
          this.stateInSpecialComment(c);
        } else if (this._state === 8
      /* BeforeAttributeName */
      ) {
          this.stateBeforeAttributeName(c);
        } else if (this._state === 3
      /* InTagName */
      ) {
          this.stateInTagName(c);
        } else if (this._state === 6
      /* InClosingTagName */
      ) {
          this.stateInClosingTagName(c);
        } else if (this._state === 2
      /* BeforeTagName */
      ) {
          this.stateBeforeTagName(c);
        } else if (this._state === 10
      /* AfterAttributeName */
      ) {
          this.stateAfterAttributeName(c);
        } else if (this._state === 13
      /* InAttributeValueSq */
      ) {
          this.stateInAttributeValueSingleQuotes(c);
        } else if (this._state === 11
      /* BeforeAttributeValue */
      ) {
          this.stateBeforeAttributeValue(c);
        } else if (this._state === 5
      /* BeforeClosingTagName */
      ) {
          this.stateBeforeClosingTagName(c);
        } else if (this._state === 7
      /* AfterClosingTagName */
      ) {
          this.stateAfterClosingTagName(c);
        } else if (this._state === 32
      /* BeforeSpecialS */
      ) {
          this.stateBeforeSpecialS(c);
        } else if (this._state === 21
      /* AfterComment1 */
      ) {
          this.stateAfterComment1(c);
        } else if (this._state === 14
      /* InAttributeValueNq */
      ) {
          this.stateInAttributeValueNoQuotes(c);
        } else if (this._state === 4
      /* InSelfClosingTag */
      ) {
          this.stateInSelfClosingTag(c);
        } else if (this._state === 16
      /* InDeclaration */
      ) {
          this.stateInDeclaration(c);
        } else if (this._state === 15
      /* BeforeDeclaration */
      ) {
          this.stateBeforeDeclaration(c);
        } else if (this._state === 22
      /* AfterComment2 */
      ) {
          this.stateAfterComment2(c);
        } else if (this._state === 18
      /* BeforeComment */
      ) {
          this.stateBeforeComment(c);
        } else if (this._state === 33
      /* BeforeSpecialSEnd */
      ) {
          this.stateBeforeSpecialSEnd(c);
        } else if (this._state === 53
      /* BeforeSpecialTEnd */
      ) {
          stateAfterSpecialTEnd(this, c);
        } else if (this._state === 39
      /* AfterScript1 */
      ) {
          stateAfterScript1(this, c);
        } else if (this._state === 40
      /* AfterScript2 */
      ) {
          stateAfterScript2(this, c);
        } else if (this._state === 41
      /* AfterScript3 */
      ) {
          stateAfterScript3(this, c);
        } else if (this._state === 34
      /* BeforeScript1 */
      ) {
          stateBeforeScript1(this, c);
        } else if (this._state === 35
      /* BeforeScript2 */
      ) {
          stateBeforeScript2(this, c);
        } else if (this._state === 36
      /* BeforeScript3 */
      ) {
          stateBeforeScript3(this, c);
        } else if (this._state === 37
      /* BeforeScript4 */
      ) {
          stateBeforeScript4(this, c);
        } else if (this._state === 38
      /* BeforeScript5 */
      ) {
          this.stateBeforeSpecialLast(c, 2
          /* Script */
          );
        } else if (this._state === 42
      /* AfterScript4 */
      ) {
          stateAfterScript4(this, c);
        } else if (this._state === 43
      /* AfterScript5 */
      ) {
          this.stateAfterSpecialLast(c, 6);
        } else if (this._state === 44
      /* BeforeStyle1 */
      ) {
          stateBeforeStyle1(this, c);
        } else if (this._state === 29
      /* InCdata */
      ) {
          this.stateInCdata(c);
        } else if (this._state === 45
      /* BeforeStyle2 */
      ) {
          stateBeforeStyle2(this, c);
        } else if (this._state === 46
      /* BeforeStyle3 */
      ) {
          stateBeforeStyle3(this, c);
        } else if (this._state === 47
      /* BeforeStyle4 */
      ) {
          this.stateBeforeSpecialLast(c, 3
          /* Style */
          );
        } else if (this._state === 48
      /* AfterStyle1 */
      ) {
          stateAfterStyle1(this, c);
        } else if (this._state === 49
      /* AfterStyle2 */
      ) {
          stateAfterStyle2(this, c);
        } else if (this._state === 50
      /* AfterStyle3 */
      ) {
          stateAfterStyle3(this, c);
        } else if (this._state === 51
      /* AfterStyle4 */
      ) {
          this.stateAfterSpecialLast(c, 5);
        } else if (this._state === 52
      /* BeforeSpecialT */
      ) {
          stateBeforeSpecialT(this, c);
        } else if (this._state === 54
      /* BeforeTitle1 */
      ) {
          stateBeforeTitle1(this, c);
        } else if (this._state === 55
      /* BeforeTitle2 */
      ) {
          stateBeforeTitle2(this, c);
        } else if (this._state === 56
      /* BeforeTitle3 */
      ) {
          stateBeforeTitle3(this, c);
        } else if (this._state === 57
      /* BeforeTitle4 */
      ) {
          this.stateBeforeSpecialLast(c, 4
          /* Title */
          );
        } else if (this._state === 58
      /* AfterTitle1 */
      ) {
          stateAfterTitle1(this, c);
        } else if (this._state === 59
      /* AfterTitle2 */
      ) {
          stateAfterTitle2(this, c);
        } else if (this._state === 60
      /* AfterTitle3 */
      ) {
          stateAfterTitle3(this, c);
        } else if (this._state === 61
      /* AfterTitle4 */
      ) {
          this.stateAfterSpecialLast(c, 5);
        } else if (this._state === 17
      /* InProcessingInstruction */
      ) {
          this.stateInProcessingInstruction(c);
        } else if (this._state === 64
      /* InNamedEntity */
      ) {
          this.stateInNamedEntity(c);
        } else if (this._state === 23
      /* BeforeCdata1 */
      ) {
          stateBeforeCdata1(this, c);
        } else if (this._state === 62
      /* BeforeEntity */
      ) {
          stateBeforeEntity(this, c);
        } else if (this._state === 24
      /* BeforeCdata2 */
      ) {
          stateBeforeCdata2(this, c);
        } else if (this._state === 25
      /* BeforeCdata3 */
      ) {
          stateBeforeCdata3(this, c);
        } else if (this._state === 30
      /* AfterCdata1 */
      ) {
          this.stateAfterCdata1(c);
        } else if (this._state === 31
      /* AfterCdata2 */
      ) {
          this.stateAfterCdata2(c);
        } else if (this._state === 26
      /* BeforeCdata4 */
      ) {
          stateBeforeCdata4(this, c);
        } else if (this._state === 27
      /* BeforeCdata5 */
      ) {
          stateBeforeCdata5(this, c);
        } else if (this._state === 28
      /* BeforeCdata6 */
      ) {
          this.stateBeforeCdata6(c);
        } else if (this._state === 66
      /* InHexEntity */
      ) {
          this.stateInHexEntity(c);
        } else if (this._state === 65
      /* InNumericEntity */
      ) {
          this.stateInNumericEntity(c); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        } else if (this._state === 63
      /* BeforeNumericEntity */
      ) {
          stateBeforeNumericEntity(this, c);
        } else {
        this.cbs.onerror(Error("unknown _state"), this._state);
      }

      this._index++;
    }

    this.cleanup();
  };

  Tokenizer.prototype.finish = function () {
    // If there is remaining data, emit it in a reasonable way
    if (this.sectionStart < this._index) {
      this.handleTrailingData();
    }

    this.cbs.onend();
  };

  Tokenizer.prototype.handleTrailingData = function () {
    var data = this.buffer.substr(this.sectionStart);

    if (this._state === 29
    /* InCdata */
    || this._state === 30
    /* AfterCdata1 */
    || this._state === 31
    /* AfterCdata2 */
    ) {
        this.cbs.oncdata(data);
      } else if (this._state === 19
    /* InComment */
    || this._state === 21
    /* AfterComment1 */
    || this._state === 22
    /* AfterComment2 */
    ) {
        this.cbs.oncomment(data);
      } else if (this._state === 64
    /* InNamedEntity */
    && !this.xmlMode) {
      this.parseLegacyEntity();

      if (this.sectionStart < this._index) {
        this._state = this.baseState;
        this.handleTrailingData();
      }
    } else if (this._state === 65
    /* InNumericEntity */
    && !this.xmlMode) {
      this.decodeNumericEntity(2, 10, false);

      if (this.sectionStart < this._index) {
        this._state = this.baseState;
        this.handleTrailingData();
      }
    } else if (this._state === 66
    /* InHexEntity */
    && !this.xmlMode) {
      this.decodeNumericEntity(3, 16, false);

      if (this.sectionStart < this._index) {
        this._state = this.baseState;
        this.handleTrailingData();
      }
    } else if (this._state !== 3
    /* InTagName */
    && this._state !== 8
    /* BeforeAttributeName */
    && this._state !== 11
    /* BeforeAttributeValue */
    && this._state !== 10
    /* AfterAttributeName */
    && this._state !== 9
    /* InAttributeName */
    && this._state !== 13
    /* InAttributeValueSq */
    && this._state !== 12
    /* InAttributeValueDq */
    && this._state !== 14
    /* InAttributeValueNq */
    && this._state !== 6
    /* InClosingTagName */
    ) {
        this.cbs.ontext(data);
      }
    /*
     * Else, ignore remaining data
     * TODO add a way to remove current tag
     */

  };

  Tokenizer.prototype.getSection = function () {
    return this.buffer.substring(this.sectionStart, this._index);
  };

  Tokenizer.prototype.emitToken = function (name) {
    this.cbs[name](this.getSection());
    this.sectionStart = -1;
  };

  Tokenizer.prototype.emitPartial = function (value) {
    if (this.baseState !== 1
    /* Text */
    ) {
        this.cbs.onattribdata(value); // TODO implement the new event
      } else {
      this.cbs.ontext(value);
    }
  };

  return Tokenizer;
}();

exports["default"] = Tokenizer;

},{"entities/lib/decode_codepoint":76,"entities/lib/maps/entities.json":80,"entities/lib/maps/legacy.json":81,"entities/lib/maps/xml.json":82}],87:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.DomHandler = exports.Parser = void 0;

var Parser_1 = require("./Parser");

Object.defineProperty(exports, "Parser", {
  enumerable: true,
  get: function get() {
    return Parser_1.Parser;
  }
});

var domhandler_1 = require("domhandler");

Object.defineProperty(exports, "DomHandler", {
  enumerable: true,
  get: function get() {
    return domhandler_1.DomHandler;
  }
});
Object.defineProperty(exports, "DefaultHandler", {
  enumerable: true,
  get: function get() {
    return domhandler_1.DomHandler;
  }
}); // Helper methods

/**
 * Parses data, returns the resulting DOM.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */

function parseDOM(data, options) {
  var handler = new domhandler_1.DomHandler(void 0, options);
  new Parser_1.Parser(handler, options).end(data);
  return handler.dom;
}

exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param cb A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
 */

function createDomStream(cb, options, elementCb) {
  var handler = new domhandler_1.DomHandler(cb, options, elementCb);
  return new Parser_1.Parser(handler, options);
}

exports.createDomStream = createDomStream;

var Tokenizer_1 = require("./Tokenizer");

Object.defineProperty(exports, "Tokenizer", {
  enumerable: true,
  get: function get() {
    return __importDefault(Tokenizer_1)["default"];
  }
});

var ElementType = __importStar(require("domelementtype"));

exports.ElementType = ElementType;
/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */

__exportStar(require("./FeedHandler"), exports);

exports.DomUtils = __importStar(require("domutils"));

var FeedHandler_1 = require("./FeedHandler");

Object.defineProperty(exports, "RssHandler", {
  enumerable: true,
  get: function get() {
    return FeedHandler_1.FeedHandler;
  }
});

},{"./FeedHandler":84,"./Parser":85,"./Tokenizer":86,"domelementtype":64,"domhandler":65,"domutils":68}],88:[function(require,module,exports){
"use strict";

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],89:[function(require,module,exports){
"use strict";

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function TempCtor() {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

},{}],90:[function(require,module,exports){
/*
 * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('./types'),
    _isArray = _require.isArray,
    _isObject = _require.isObject,
    _isString = _require.isString;

var _require2 = require('./util'),
    _asArray = _require2.asArray;

var _require3 = require('./url'),
    prependBase = _require3.prependBase;

var JsonLdError = require('./JsonLdError');

var ResolvedContext = require('./ResolvedContext');

var MAX_CONTEXT_URLS = 10;

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a ContextResolver.
   *
   * @param sharedCache a shared LRU cache with `get` and `set` APIs.
   */
  function ContextResolver(_ref) {
    var sharedCache = _ref.sharedCache;
    (0, _classCallCheck2["default"])(this, ContextResolver);
    this.perOpCache = new Map();
    this.sharedCache = sharedCache;
  }

  (0, _createClass2["default"])(ContextResolver, [{
    key: "resolve",
    value: function () {
      var _resolve = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref2) {
        var activeCtx, context, documentLoader, base, _ref2$cycles, cycles, allResolved, _iterator, _step, ctx, _resolved, key, resolved;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                activeCtx = _ref2.activeCtx, context = _ref2.context, documentLoader = _ref2.documentLoader, base = _ref2.base, _ref2$cycles = _ref2.cycles, cycles = _ref2$cycles === void 0 ? new Set() : _ref2$cycles;

                // process `@context`
                if (context && _isObject(context) && context['@context']) {
                  context = context['@context'];
                } // context is one or more contexts


                context = _asArray(context); // resolve each context in the array

                allResolved = [];
                _iterator = _createForOfIteratorHelper(context);
                _context.prev = 5;

                _iterator.s();

              case 7:
                if ((_step = _iterator.n()).done) {
                  _context.next = 27;
                  break;
                }

                ctx = _step.value;

                if (!_isString(ctx)) {
                  _context.next = 17;
                  break;
                }

                // see if `ctx` has been resolved before...
                _resolved = this._get(ctx);

                if (_resolved) {
                  _context.next = 15;
                  break;
                }

                _context.next = 14;
                return this._resolveRemoteContext({
                  activeCtx: activeCtx,
                  url: ctx,
                  documentLoader: documentLoader,
                  base: base,
                  cycles: cycles
                });

              case 14:
                _resolved = _context.sent;

              case 15:
                // add to output and continue
                if (_isArray(_resolved)) {
                  allResolved.push.apply(allResolved, (0, _toConsumableArray2["default"])(_resolved));
                } else {
                  allResolved.push(_resolved);
                }

                return _context.abrupt("continue", 25);

              case 17:
                if (!(ctx === null)) {
                  _context.next = 20;
                  break;
                }

                // handle `null` context, nothing to cache
                allResolved.push(new ResolvedContext({
                  document: null
                }));
                return _context.abrupt("continue", 25);

              case 20:
                if (!_isObject(ctx)) {
                  _throwInvalidLocalContext(context);
                } // context is an object, get/create `ResolvedContext` for it


                key = JSON.stringify(ctx);
                resolved = this._get(key);

                if (!resolved) {
                  // create a new static `ResolvedContext` and cache it
                  resolved = new ResolvedContext({
                    document: ctx
                  });

                  this._cacheResolvedContext({
                    key: key,
                    resolved: resolved,
                    tag: 'static'
                  });
                }

                allResolved.push(resolved);

              case 25:
                _context.next = 7;
                break;

              case 27:
                _context.next = 32;
                break;

              case 29:
                _context.prev = 29;
                _context.t0 = _context["catch"](5);

                _iterator.e(_context.t0);

              case 32:
                _context.prev = 32;

                _iterator.f();

                return _context.finish(32);

              case 35:
                return _context.abrupt("return", allResolved);

              case 36:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[5, 29, 32, 35]]);
      }));

      function resolve(_x) {
        return _resolve.apply(this, arguments);
      }

      return resolve;
    }()
  }, {
    key: "_get",
    value: function _get(key) {
      // get key from per operation cache; no `tag` is used with this cache so
      // any retrieved context will always be the same during a single operation
      var resolved = this.perOpCache.get(key);

      if (!resolved) {
        // see if the shared cache has a `static` entry for this URL
        var tagMap = this.sharedCache.get(key);

        if (tagMap) {
          resolved = tagMap.get('static');

          if (resolved) {
            this.perOpCache.set(key, resolved);
          }
        }
      }

      return resolved;
    }
  }, {
    key: "_cacheResolvedContext",
    value: function _cacheResolvedContext(_ref3) {
      var key = _ref3.key,
          resolved = _ref3.resolved,
          tag = _ref3.tag;
      this.perOpCache.set(key, resolved);

      if (tag !== undefined) {
        var tagMap = this.sharedCache.get(key);

        if (!tagMap) {
          tagMap = new Map();
          this.sharedCache.set(key, tagMap);
        }

        tagMap.set(tag, resolved);
      }

      return resolved;
    }
  }, {
    key: "_resolveRemoteContext",
    value: function () {
      var _resolveRemoteContext2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref4) {
        var activeCtx, url, documentLoader, base, cycles, _yield$this$_fetchCon, context, remoteDoc, resolved;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                activeCtx = _ref4.activeCtx, url = _ref4.url, documentLoader = _ref4.documentLoader, base = _ref4.base, cycles = _ref4.cycles;
                // resolve relative URL and fetch context
                url = prependBase(base, url);
                _context2.next = 4;
                return this._fetchContext({
                  activeCtx: activeCtx,
                  url: url,
                  documentLoader: documentLoader,
                  cycles: cycles
                });

              case 4:
                _yield$this$_fetchCon = _context2.sent;
                context = _yield$this$_fetchCon.context;
                remoteDoc = _yield$this$_fetchCon.remoteDoc;
                // update base according to remote document and resolve any relative URLs
                base = remoteDoc.documentUrl || url;

                _resolveContextUrls({
                  context: context,
                  base: base
                }); // resolve, cache, and return context


                _context2.next = 11;
                return this.resolve({
                  activeCtx: activeCtx,
                  context: context,
                  documentLoader: documentLoader,
                  base: base,
                  cycles: cycles
                });

              case 11:
                resolved = _context2.sent;

                this._cacheResolvedContext({
                  key: url,
                  resolved: resolved,
                  tag: remoteDoc.tag
                });

                return _context2.abrupt("return", resolved);

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _resolveRemoteContext(_x2) {
        return _resolveRemoteContext2.apply(this, arguments);
      }

      return _resolveRemoteContext;
    }()
  }, {
    key: "_fetchContext",
    value: function () {
      var _fetchContext2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref5) {
        var activeCtx, url, documentLoader, cycles, context, remoteDoc;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                activeCtx = _ref5.activeCtx, url = _ref5.url, documentLoader = _ref5.documentLoader, cycles = _ref5.cycles;

                if (!(cycles.size > MAX_CONTEXT_URLS)) {
                  _context3.next = 3;
                  break;
                }

                throw new JsonLdError('Maximum number of @context URLs exceeded.', 'jsonld.ContextUrlError', {
                  code: activeCtx.processingMode === 'json-ld-1.0' ? 'loading remote context failed' : 'context overflow',
                  max: MAX_CONTEXT_URLS
                });

              case 3:
                if (!cycles.has(url)) {
                  _context3.next = 5;
                  break;
                }

                throw new JsonLdError('Cyclical @context URLs detected.', 'jsonld.ContextUrlError', {
                  code: activeCtx.processingMode === 'json-ld-1.0' ? 'recursive context inclusion' : 'context overflow',
                  url: url
                });

              case 5:
                // track cycles
                cycles.add(url);
                _context3.prev = 6;
                _context3.next = 9;
                return documentLoader(url);

              case 9:
                remoteDoc = _context3.sent;
                context = remoteDoc.document || null; // parse string context as JSON

                if (_isString(context)) {
                  context = JSON.parse(context);
                }

                _context3.next = 17;
                break;

              case 14:
                _context3.prev = 14;
                _context3.t0 = _context3["catch"](6);
                throw new JsonLdError('Dereferencing a URL did not result in a valid JSON-LD object. ' + 'Possible causes are an inaccessible URL perhaps due to ' + 'a same-origin policy (ensure the server uses CORS if you are ' + 'using client-side JavaScript), too many redirects, a ' + 'non-JSON response, or more than one HTTP Link Header was ' + 'provided for a remote context.', 'jsonld.InvalidUrl', {
                  code: 'loading remote context failed',
                  url: url,
                  cause: _context3.t0
                });

              case 17:
                if (_isObject(context)) {
                  _context3.next = 19;
                  break;
                }

                throw new JsonLdError('Dereferencing a URL did not result in a JSON object. The ' + 'response was valid JSON, but it was not a JSON object.', 'jsonld.InvalidUrl', {
                  code: 'invalid remote context',
                  url: url
                });

              case 19:
                // use empty context if no @context key is present
                if (!('@context' in context)) {
                  context = {
                    '@context': {}
                  };
                } else {
                  context = {
                    '@context': context['@context']
                  };
                } // append @context URL to context if given


                if (remoteDoc.contextUrl) {
                  if (!_isArray(context['@context'])) {
                    context['@context'] = [context['@context']];
                  }

                  context['@context'].push(remoteDoc.contextUrl);
                }

                return _context3.abrupt("return", {
                  context: context,
                  remoteDoc: remoteDoc
                });

              case 22:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[6, 14]]);
      }));

      function _fetchContext(_x3) {
        return _fetchContext2.apply(this, arguments);
      }

      return _fetchContext;
    }()
  }]);
  return ContextResolver;
}();

function _throwInvalidLocalContext(ctx) {
  throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {
    code: 'invalid local context',
    context: ctx
  });
}
/**
 * Resolve all relative `@context` URLs in the given context by inline
 * replacing them with absolute URLs.
 *
 * @param context the context.
 * @param base the base IRI to use to resolve relative IRIs.
 */


function _resolveContextUrls(_ref6) {
  var context = _ref6.context,
      base = _ref6.base;

  if (!context) {
    return;
  }

  var ctx = context['@context'];

  if (_isString(ctx)) {
    context['@context'] = prependBase(base, ctx);
    return;
  }

  if (_isArray(ctx)) {
    for (var i = 0; i < ctx.length; ++i) {
      var element = ctx[i];

      if (_isString(element)) {
        ctx[i] = prependBase(base, element);
        continue;
      }

      if (_isObject(element)) {
        _resolveContextUrls({
          context: {
            '@context': element
          },
          base: base
        });
      }
    }

    return;
  }

  if (!_isObject(ctx)) {
    // no @context URLs can be found in non-object
    return;
  } // ctx is an object, resolve any context URLs in terms


  for (var term in ctx) {
    _resolveContextUrls({
      context: ctx[term],
      base: base
    });
  }
}

},{"./JsonLdError":91,"./ResolvedContext":96,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/toConsumableArray":26,"@babel/runtime/regenerator":30}],91:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

module.exports = /*#__PURE__*/function (_Error) {
  (0, _inherits2["default"])(JsonLdError, _Error);

  var _super = _createSuper(JsonLdError);

  /**
   * Creates a JSON-LD Error.
   *
   * @param msg the error message.
   * @param type the error type.
   * @param details the error details.
   */
  function JsonLdError() {
    var _this;

    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'An unspecified JSON-LD error occurred.';
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'jsonld.Error';
    var details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, JsonLdError);
    _this = _super.call(this, message);
    _this.name = name;
    _this.message = message;
    _this.details = details;
    return _this;
  }

  return JsonLdError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"@babel/runtime/helpers/wrapNativeSuper":29}],92:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

module.exports = function (jsonld) {
  var JsonLdProcessor = /*#__PURE__*/function () {
    function JsonLdProcessor() {
      (0, _classCallCheck2["default"])(this, JsonLdProcessor);
    }

    (0, _createClass2["default"])(JsonLdProcessor, [{
      key: "toString",
      value: function toString() {
        return '[object JsonLdProcessor]';
      }
    }]);
    return JsonLdProcessor;
  }();

  Object.defineProperty(JsonLdProcessor, 'prototype', {
    writable: false,
    enumerable: false
  });
  Object.defineProperty(JsonLdProcessor.prototype, 'constructor', {
    writable: true,
    enumerable: false,
    configurable: true,
    value: JsonLdProcessor
  }); // The Web IDL test harness will check the number of parameters defined in
  // the functions below. The number of parameters must exactly match the
  // required (non-optional) parameters of the JsonLdProcessor interface as
  // defined here:
  // https://www.w3.org/TR/json-ld-api/#the-jsonldprocessor-interface

  JsonLdProcessor.compact = function (input, ctx) {
    if (arguments.length < 2) {
      return Promise.reject(new TypeError('Could not compact, too few arguments.'));
    }

    return jsonld.compact(input, ctx);
  };

  JsonLdProcessor.expand = function (input) {
    if (arguments.length < 1) {
      return Promise.reject(new TypeError('Could not expand, too few arguments.'));
    }

    return jsonld.expand(input);
  };

  JsonLdProcessor.flatten = function (input) {
    if (arguments.length < 1) {
      return Promise.reject(new TypeError('Could not flatten, too few arguments.'));
    }

    return jsonld.flatten(input);
  };

  return JsonLdProcessor;
};

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],93:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict'; // TODO: move `NQuads` to its own package

module.exports = require('rdf-canonize').NQuads;

},{"rdf-canonize":153}],94:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */

/* global Node, XMLSerializer */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _require = require('./constants'),
    RDF_LANGSTRING = _require.RDF_LANGSTRING,
    RDF_PLAIN_LITERAL = _require.RDF_PLAIN_LITERAL,
    RDF_OBJECT = _require.RDF_OBJECT,
    RDF_XML_LITERAL = _require.RDF_XML_LITERAL,
    XSD_STRING = _require.XSD_STRING;

var _Node;

if (typeof Node !== 'undefined') {
  _Node = Node;
} else {
  _Node = {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  };
}

module.exports = /*#__PURE__*/function () {
  function Rdfa() {
    (0, _classCallCheck2["default"])(this, Rdfa);
  }

  (0, _createClass2["default"])(Rdfa, [{
    key: "parse",

    /**
     * Parses the RDF dataset found via the data object from the RDFa API.
     *
     * @param data the RDFa API data object.
     *
     * @return the RDF dataset.
     */
    value: function parse(data) {
      var dataset = {};
      dataset['@default'] = [];
      var subjects = data.getSubjects();

      for (var si = 0; si < subjects.length; ++si) {
        var subject = subjects[si];

        if (subject === null) {
          continue;
        } // get all related triples


        var triples = data.getSubjectTriples(subject);

        if (triples === null) {
          continue;
        }

        var predicates = triples.predicates;

        for (var predicate in predicates) {
          // iterate over objects
          var objects = predicates[predicate].objects;

          for (var oi = 0; oi < objects.length; ++oi) {
            var object = objects[oi]; // create RDF triple

            var triple = {}; // add subject

            if (subject.indexOf('_:') === 0) {
              triple.subject = {
                type: 'blank node',
                value: subject
              };
            } else {
              triple.subject = {
                type: 'IRI',
                value: subject
              };
            } // add predicate


            if (predicate.indexOf('_:') === 0) {
              triple.predicate = {
                type: 'blank node',
                value: predicate
              };
            } else {
              triple.predicate = {
                type: 'IRI',
                value: predicate
              };
            } // serialize XML literal


            var value = object.value;

            if (object.type === RDF_XML_LITERAL) {
              // initialize XMLSerializer
              var _XMLSerializer = getXMLSerializerClass();

              var serializer = new _XMLSerializer();
              value = '';

              for (var x = 0; x < object.value.length; x++) {
                if (object.value[x].nodeType === _Node.ELEMENT_NODE) {
                  value += serializer.serializeToString(object.value[x]);
                } else if (object.value[x].nodeType === _Node.TEXT_NODE) {
                  value += object.value[x].nodeValue;
                }
              }
            } // add object


            triple.object = {}; // object is an IRI

            if (object.type === RDF_OBJECT) {
              if (object.value.indexOf('_:') === 0) {
                triple.object.type = 'blank node';
              } else {
                triple.object.type = 'IRI';
              }
            } else {
              // object is a literal
              triple.object.type = 'literal';

              if (object.type === RDF_PLAIN_LITERAL) {
                if (object.language) {
                  triple.object.datatype = RDF_LANGSTRING;
                  triple.object.language = object.language;
                } else {
                  triple.object.datatype = XSD_STRING;
                }
              } else {
                triple.object.datatype = object.type;
              }
            }

            triple.object.value = value; // add triple to dataset in default graph

            dataset['@default'].push(triple);
          }
        }
      }

      return dataset;
    }
  }]);
  return Rdfa;
}();

function getXMLSerializerClass() {
  if (typeof XMLSerializer === 'undefined') {
    return require('xmldom').XMLSerializer;
  }

  return XMLSerializer;
}

},{"./constants":98,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"xmldom":58}],95:[function(require,module,exports){
/*
 * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a simple queue for requesting documents.
   */
  function RequestQueue() {
    (0, _classCallCheck2["default"])(this, RequestQueue);
    this._requests = {};
  }

  (0, _createClass2["default"])(RequestQueue, [{
    key: "wrapLoader",
    value: function wrapLoader(loader) {
      var self = this;
      self._loader = loader;
      return function ()
      /* url */
      {
        return self.add.apply(self, arguments);
      };
    }
  }, {
    key: "add",
    value: function () {
      var _add = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url) {
        var promise;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                promise = this._requests[url];

                if (!promise) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return", Promise.resolve(promise));

              case 3:
                // queue URL and load it
                promise = this._requests[url] = this._loader(url);
                _context.prev = 4;
                _context.next = 7;
                return promise;

              case 7:
                return _context.abrupt("return", _context.sent);

              case 8:
                _context.prev = 8;
                delete this._requests[url];
                return _context.finish(8);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4,, 8, 11]]);
      }));

      function add(_x) {
        return _add.apply(this, arguments);
      }

      return add;
    }()
  }]);
  return RequestQueue;
}();

},{"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30}],96:[function(require,module,exports){
/*
 * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var LRU = require('lru-cache');

var MAX_ACTIVE_CONTEXTS = 10;

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a ResolvedContext.
   *
   * @param document the context document.
   */
  function ResolvedContext(_ref) {
    var document = _ref.document;
    (0, _classCallCheck2["default"])(this, ResolvedContext);
    this.document = document; // TODO: enable customization of processed context cache
    // TODO: limit based on size of processed contexts vs. number of them

    this.cache = new LRU({
      max: MAX_ACTIVE_CONTEXTS
    });
  }

  (0, _createClass2["default"])(ResolvedContext, [{
    key: "getProcessed",
    value: function getProcessed(activeCtx) {
      return this.cache.get(activeCtx);
    }
  }, {
    key: "setProcessed",
    value: function setProcessed(activeCtx, processedCtx) {
      this.cache.set(activeCtx, processedCtx);
    }
  }]);
  return ResolvedContext;
}();

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"lru-cache":113}],97:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var JsonLdError = require('./JsonLdError');

var _require = require('./types'),
    _isArray = _require.isArray,
    _isObject = _require.isObject,
    _isString = _require.isString,
    _isUndefined = _require.isUndefined;

var _require2 = require('./graphTypes'),
    _isList = _require2.isList,
    _isValue = _require2.isValue,
    _isGraph = _require2.isGraph,
    _isSimpleGraph = _require2.isSimpleGraph,
    _isSubjectReference = _require2.isSubjectReference;

var _require3 = require('./context'),
    _expandIri = _require3.expandIri,
    _getContextValue = _require3.getContextValue,
    _isKeyword = _require3.isKeyword,
    _processContext = _require3.process,
    _processingMode = _require3.processingMode;

var _require4 = require('./url'),
    _removeBase = _require4.removeBase,
    _prependBase = _require4.prependBase;

var _require5 = require('./util'),
    _addValue = _require5.addValue,
    _asArray = _require5.asArray,
    _compareShortestLeast = _require5.compareShortestLeast;

var api = {};
module.exports = api;
/**
 * Recursively compacts an element using the given active context. All values
 * must be in expanded form before this method is called.
 *
 * @param activeCtx the active context to use.
 * @param activeProperty the compacted property associated with the element
 *          to compact, null for none.
 * @param element the element to compact.
 * @param options the compaction options.
 * @param compactionMap the compaction map to use.
 *
 * @return a promise that resolves to the compacted value.
 */

api.compact = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref) {
    var activeCtx, _ref$activeProperty, activeProperty, element, _ref$options, options, _ref$compactionMap, compactionMap, rval, i, compacted, container, ctx, _ret;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            activeCtx = _ref.activeCtx, _ref$activeProperty = _ref.activeProperty, activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty, element = _ref.element, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, _ref$compactionMap = _ref.compactionMap, compactionMap = _ref$compactionMap === void 0 ? function () {
              return undefined;
            } : _ref$compactionMap;

            if (!_isArray(element)) {
              _context2.next = 20;
              break;
            }

            rval = [];
            i = 0;

          case 4:
            if (!(i < element.length)) {
              _context2.next = 18;
              break;
            }

            _context2.next = 7;
            return api.compact({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element[i],
              options: options,
              compactionMap: compactionMap
            });

          case 7:
            compacted = _context2.sent;

            if (!(compacted === null)) {
              _context2.next = 14;
              break;
            }

            _context2.next = 11;
            return compactionMap({
              unmappedValue: element[i],
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              parent: element,
              index: i,
              options: options
            });

          case 11:
            compacted = _context2.sent;

            if (!(compacted === undefined)) {
              _context2.next = 14;
              break;
            }

            return _context2.abrupt("continue", 15);

          case 14:
            rval.push(compacted);

          case 15:
            ++i;
            _context2.next = 4;
            break;

          case 18:
            if (options.compactArrays && rval.length === 1) {
              // use single element if no container is specified
              container = _getContextValue(activeCtx, activeProperty, '@container') || [];

              if (container.length === 0) {
                rval = rval[0];
              }
            }

            return _context2.abrupt("return", rval);

          case 20:
            // use any scoped context on activeProperty
            ctx = _getContextValue(activeCtx, activeProperty, '@context');

            if (_isUndefined(ctx)) {
              _context2.next = 25;
              break;
            }

            _context2.next = 24;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: ctx,
              propagate: true,
              overrideProtected: true,
              options: options
            });

          case 24:
            activeCtx = _context2.sent;

          case 25:
            if (!_isObject(element)) {
              _context2.next = 30;
              break;
            }

            return _context2.delegateYield( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
              var linked, _i, _rval, _container, insideReverse, rval, inputCtx, propertyScopedCtx, types, typeContext, _iterator, _step, type, compactedType, _ctx, keys, _iterator2, _step2, expandedProperty, expandedValue, compactedValue, alias, _compactedValue, _alias, _container2, typeAsSet, isArray, _compactedValue2, compactedProperty, value, _container3, useArray, _alias2, _compactedValue3, _container4, _alias3, _alias4, itemActiveProperty, nestProperty, nestResult, _iterator3, _step3, expandedItem, _itemActiveProperty, _nestProperty, _nestResult, _container5, isGraph, isList, inner, compactedItem, mapObject, key, _mapObject, _key, indexKey, containerKey, others, _asArray2, _asArray3, idKey, typeKey, _types, _asArray4, _asArray5, _isArray2;

              return _regenerator["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!(options.link && '@id' in element && options.link.hasOwnProperty(element['@id']))) {
                        _context.next = 9;
                        break;
                      }

                      // check for a linked element to reuse
                      linked = options.link[element['@id']];
                      _i = 0;

                    case 3:
                      if (!(_i < linked.length)) {
                        _context.next = 9;
                        break;
                      }

                      if (!(linked[_i].expanded === element)) {
                        _context.next = 6;
                        break;
                      }

                      return _context.abrupt("return", {
                        v: linked[_i].compacted
                      });

                    case 6:
                      ++_i;
                      _context.next = 3;
                      break;

                    case 9:
                      if (!(_isValue(element) || _isSubjectReference(element))) {
                        _context.next = 13;
                        break;
                      }

                      _rval = api.compactValue({
                        activeCtx: activeCtx,
                        activeProperty: activeProperty,
                        value: element,
                        options: options
                      });

                      if (options.link && _isSubjectReference(element)) {
                        // store linked element
                        if (!options.link.hasOwnProperty(element['@id'])) {
                          options.link[element['@id']] = [];
                        }

                        options.link[element['@id']].push({
                          expanded: element,
                          compacted: _rval
                        });
                      }

                      return _context.abrupt("return", {
                        v: _rval
                      });

                    case 13:
                      if (!_isList(element)) {
                        _context.next = 17;
                        break;
                      }

                      _container = _getContextValue(activeCtx, activeProperty, '@container') || [];

                      if (!_container.includes('@list')) {
                        _context.next = 17;
                        break;
                      }

                      return _context.abrupt("return", {
                        v: api.compact({
                          activeCtx: activeCtx,
                          activeProperty: activeProperty,
                          element: element['@list'],
                          options: options,
                          compactionMap: compactionMap
                        })
                      });

                    case 17:
                      // FIXME: avoid misuse of active property as an expanded property?
                      insideReverse = activeProperty === '@reverse';
                      rval = {}; // original context before applying property-scoped and local contexts

                      inputCtx = activeCtx; // revert to previous context, if there is one,
                      // and element is not a value object or a node reference

                      if (!_isValue(element) && !_isSubjectReference(element)) {
                        activeCtx = activeCtx.revertToPreviousContext();
                      } // apply property-scoped context after reverting term-scoped context


                      propertyScopedCtx = _getContextValue(inputCtx, activeProperty, '@context');

                      if (_isUndefined(propertyScopedCtx)) {
                        _context.next = 26;
                        break;
                      }

                      _context.next = 25;
                      return _processContext({
                        activeCtx: activeCtx,
                        localCtx: propertyScopedCtx,
                        propagate: true,
                        overrideProtected: true,
                        options: options
                      });

                    case 25:
                      activeCtx = _context.sent;

                    case 26:
                      if (options.link && '@id' in element) {
                        // store linked element
                        if (!options.link.hasOwnProperty(element['@id'])) {
                          options.link[element['@id']] = [];
                        }

                        options.link[element['@id']].push({
                          expanded: element,
                          compacted: rval
                        });
                      } // apply any context defined on an alias of @type
                      // if key is @type and any compacted value is a term having a local
                      // context, overlay that context


                      types = element['@type'] || [];

                      if (types.length > 1) {
                        types = Array.from(types).sort();
                      } // find all type-scoped contexts based on current context, prior to
                      // updating it


                      typeContext = activeCtx;
                      _iterator = _createForOfIteratorHelper(types);
                      _context.prev = 31;

                      _iterator.s();

                    case 33:
                      if ((_step = _iterator.n()).done) {
                        _context.next = 43;
                        break;
                      }

                      type = _step.value;
                      compactedType = api.compactIri({
                        activeCtx: typeContext,
                        iri: type,
                        relativeTo: {
                          vocab: true
                        }
                      }); // Use any type-scoped context defined on this value

                      _ctx = _getContextValue(inputCtx, compactedType, '@context');

                      if (_isUndefined(_ctx)) {
                        _context.next = 41;
                        break;
                      }

                      _context.next = 40;
                      return _processContext({
                        activeCtx: activeCtx,
                        localCtx: _ctx,
                        options: options,
                        propagate: false
                      });

                    case 40:
                      activeCtx = _context.sent;

                    case 41:
                      _context.next = 33;
                      break;

                    case 43:
                      _context.next = 48;
                      break;

                    case 45:
                      _context.prev = 45;
                      _context.t0 = _context["catch"](31);

                      _iterator.e(_context.t0);

                    case 48:
                      _context.prev = 48;

                      _iterator.f();

                      return _context.finish(48);

                    case 51:
                      // process element keys in order
                      keys = Object.keys(element).sort();
                      _iterator2 = _createForOfIteratorHelper(keys);
                      _context.prev = 53;

                      _iterator2.s();

                    case 55:
                      if ((_step2 = _iterator2.n()).done) {
                        _context.next = 211;
                        break;
                      }

                      expandedProperty = _step2.value;
                      expandedValue = element[expandedProperty]; // compact @id

                      if (!(expandedProperty === '@id')) {
                        _context.next = 64;
                        break;
                      }

                      compactedValue = _asArray(expandedValue).map(function (expandedIri) {
                        return api.compactIri({
                          activeCtx: activeCtx,
                          iri: expandedIri,
                          relativeTo: {
                            vocab: false
                          },
                          base: options.base
                        });
                      });

                      if (compactedValue.length === 1) {
                        compactedValue = compactedValue[0];
                      } // use keyword alias and add value


                      alias = api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@id',
                        relativeTo: {
                          vocab: true
                        }
                      });
                      rval[alias] = compactedValue;
                      return _context.abrupt("continue", 209);

                    case 64:
                      if (!(expandedProperty === '@type')) {
                        _context.next = 73;
                        break;
                      }

                      // resolve type values against previous context
                      _compactedValue = _asArray(expandedValue).map(function (expandedIri) {
                        return api.compactIri({
                          activeCtx: inputCtx,
                          iri: expandedIri,
                          relativeTo: {
                            vocab: true
                          }
                        });
                      });

                      if (_compactedValue.length === 1) {
                        _compactedValue = _compactedValue[0];
                      } // use keyword alias and add value


                      _alias = api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@type',
                        relativeTo: {
                          vocab: true
                        }
                      });
                      _container2 = _getContextValue(activeCtx, _alias, '@container') || []; // treat as array for @type if @container includes @set

                      typeAsSet = _container2.includes('@set') && _processingMode(activeCtx, 1.1);
                      isArray = typeAsSet || _isArray(_compactedValue) && expandedValue.length === 0;

                      _addValue(rval, _alias, _compactedValue, {
                        propertyIsArray: isArray
                      });

                      return _context.abrupt("continue", 209);

                    case 73:
                      if (!(expandedProperty === '@reverse')) {
                        _context.next = 80;
                        break;
                      }

                      _context.next = 76;
                      return api.compact({
                        activeCtx: activeCtx,
                        activeProperty: '@reverse',
                        element: expandedValue,
                        options: options,
                        compactionMap: compactionMap
                      });

                    case 76:
                      _compactedValue2 = _context.sent;

                      // handle double-reversed properties
                      for (compactedProperty in _compactedValue2) {
                        if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {
                          value = _compactedValue2[compactedProperty];
                          _container3 = _getContextValue(activeCtx, compactedProperty, '@container') || [];
                          useArray = _container3.includes('@set') || !options.compactArrays;

                          _addValue(rval, compactedProperty, value, {
                            propertyIsArray: useArray
                          });

                          delete _compactedValue2[compactedProperty];
                        }
                      }

                      if (Object.keys(_compactedValue2).length > 0) {
                        // use keyword alias and add value
                        _alias2 = api.compactIri({
                          activeCtx: activeCtx,
                          iri: expandedProperty,
                          relativeTo: {
                            vocab: true
                          }
                        });

                        _addValue(rval, _alias2, _compactedValue2);
                      }

                      return _context.abrupt("continue", 209);

                    case 80:
                      if (!(expandedProperty === '@preserve')) {
                        _context.next = 86;
                        break;
                      }

                      _context.next = 83;
                      return api.compact({
                        activeCtx: activeCtx,
                        activeProperty: activeProperty,
                        element: expandedValue,
                        options: options,
                        compactionMap: compactionMap
                      });

                    case 83:
                      _compactedValue3 = _context.sent;

                      if (!(_isArray(_compactedValue3) && _compactedValue3.length === 0)) {
                        _addValue(rval, expandedProperty, _compactedValue3);
                      }

                      return _context.abrupt("continue", 209);

                    case 86:
                      if (!(expandedProperty === '@index')) {
                        _context.next = 93;
                        break;
                      }

                      // drop @index if inside an @index container
                      _container4 = _getContextValue(activeCtx, activeProperty, '@container') || [];

                      if (!_container4.includes('@index')) {
                        _context.next = 90;
                        break;
                      }

                      return _context.abrupt("continue", 209);

                    case 90:
                      // use keyword alias and add value
                      _alias3 = api.compactIri({
                        activeCtx: activeCtx,
                        iri: expandedProperty,
                        relativeTo: {
                          vocab: true
                        }
                      });

                      _addValue(rval, _alias3, expandedValue);

                      return _context.abrupt("continue", 209);

                    case 93:
                      if (!(expandedProperty !== '@graph' && expandedProperty !== '@list' && expandedProperty !== '@included' && _isKeyword(expandedProperty))) {
                        _context.next = 97;
                        break;
                      }

                      // use keyword alias and add value as is
                      _alias4 = api.compactIri({
                        activeCtx: activeCtx,
                        iri: expandedProperty,
                        relativeTo: {
                          vocab: true
                        }
                      });

                      _addValue(rval, _alias4, expandedValue);

                      return _context.abrupt("continue", 209);

                    case 97:
                      if (_isArray(expandedValue)) {
                        _context.next = 99;
                        break;
                      }

                      throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');

                    case 99:
                      // preserve empty arrays
                      if (expandedValue.length === 0) {
                        itemActiveProperty = api.compactIri({
                          activeCtx: activeCtx,
                          iri: expandedProperty,
                          value: expandedValue,
                          relativeTo: {
                            vocab: true
                          },
                          reverse: insideReverse
                        });
                        nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;
                        nestResult = rval;

                        if (nestProperty) {
                          _checkNestProperty(activeCtx, nestProperty, options);

                          if (!_isObject(rval[nestProperty])) {
                            rval[nestProperty] = {};
                          }

                          nestResult = rval[nestProperty];
                        }

                        _addValue(nestResult, itemActiveProperty, expandedValue, {
                          propertyIsArray: true
                        });
                      } // recusively process array values


                      _iterator3 = _createForOfIteratorHelper(expandedValue);
                      _context.prev = 101;

                      _iterator3.s();

                    case 103:
                      if ((_step3 = _iterator3.n()).done) {
                        _context.next = 201;
                        break;
                      }

                      expandedItem = _step3.value;
                      // compact property and get container type
                      _itemActiveProperty = api.compactIri({
                        activeCtx: activeCtx,
                        iri: expandedProperty,
                        value: expandedItem,
                        relativeTo: {
                          vocab: true
                        },
                        reverse: insideReverse
                      }); // if itemActiveProperty is a @nest property, add values to nestResult,
                      // otherwise rval

                      _nestProperty = activeCtx.mappings.has(_itemActiveProperty) ? activeCtx.mappings.get(_itemActiveProperty)['@nest'] : null;
                      _nestResult = rval;

                      if (_nestProperty) {
                        _checkNestProperty(activeCtx, _nestProperty, options);

                        if (!_isObject(rval[_nestProperty])) {
                          rval[_nestProperty] = {};
                        }

                        _nestResult = rval[_nestProperty];
                      }

                      _container5 = _getContextValue(activeCtx, _itemActiveProperty, '@container') || []; // get simple @graph or @list value if appropriate

                      isGraph = _isGraph(expandedItem);
                      isList = _isList(expandedItem);
                      inner = void 0;

                      if (isList) {
                        inner = expandedItem['@list'];
                      } else if (isGraph) {
                        inner = expandedItem['@graph'];
                      } // recursively compact expanded item


                      _context.next = 116;
                      return api.compact({
                        activeCtx: activeCtx,
                        activeProperty: _itemActiveProperty,
                        element: isList || isGraph ? inner : expandedItem,
                        options: options,
                        compactionMap: compactionMap
                      });

                    case 116:
                      compactedItem = _context.sent;

                      if (!isList) {
                        _context.next = 126;
                        break;
                      }

                      // ensure @list value is an array
                      if (!_isArray(compactedItem)) {
                        compactedItem = [compactedItem];
                      }

                      if (_container5.includes('@list')) {
                        _context.next = 124;
                        break;
                      }

                      // wrap using @list alias
                      compactedItem = (0, _defineProperty2["default"])({}, api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@list',
                        relativeTo: {
                          vocab: true
                        }
                      }), compactedItem); // include @index from expanded @list, if any

                      if ('@index' in expandedItem) {
                        compactedItem[api.compactIri({
                          activeCtx: activeCtx,
                          iri: '@index',
                          relativeTo: {
                            vocab: true
                          }
                        })] = expandedItem['@index'];
                      }

                      _context.next = 126;
                      break;

                    case 124:
                      _addValue(_nestResult, _itemActiveProperty, compactedItem, {
                        valueIsArray: true,
                        allowDuplicate: true
                      });

                      return _context.abrupt("continue", 199);

                    case 126:
                      if (!isGraph) {
                        _context.next = 130;
                        break;
                      }

                      if (_container5.includes('@graph') && (_container5.includes('@id') || _container5.includes('@index') && _isSimpleGraph(expandedItem))) {
                        // get or create the map object
                        mapObject = void 0;

                        if (_nestResult.hasOwnProperty(_itemActiveProperty)) {
                          mapObject = _nestResult[_itemActiveProperty];
                        } else {
                          _nestResult[_itemActiveProperty] = mapObject = {};
                        } // index on @id or @index or alias of @none


                        key = (_container5.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({
                          activeCtx: activeCtx,
                          iri: '@none',
                          relativeTo: {
                            vocab: true
                          }
                        }); // add compactedItem to map, using value of `@id` or a new blank
                        // node identifier

                        _addValue(mapObject, key, compactedItem, {
                          propertyIsArray: !options.compactArrays || _container5.includes('@set')
                        });
                      } else if (_container5.includes('@graph') && _isSimpleGraph(expandedItem)) {
                        // container includes @graph but not @id or @index and value is a
                        // simple graph object add compact value
                        // if compactedItem contains multiple values, it is wrapped in
                        // `@included`
                        if (_isArray(compactedItem) && compactedItem.length > 1) {
                          compactedItem = {
                            '@included': compactedItem
                          };
                        }

                        _addValue(_nestResult, _itemActiveProperty, compactedItem, {
                          propertyIsArray: !options.compactArrays || _container5.includes('@set')
                        });
                      } else {
                        // wrap using @graph alias, remove array if only one item and
                        // compactArrays not set
                        if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {
                          compactedItem = compactedItem[0];
                        }

                        compactedItem = (0, _defineProperty2["default"])({}, api.compactIri({
                          activeCtx: activeCtx,
                          iri: '@graph',
                          relativeTo: {
                            vocab: true
                          }
                        }), compactedItem); // include @id from expanded graph, if any

                        if ('@id' in expandedItem) {
                          compactedItem[api.compactIri({
                            activeCtx: activeCtx,
                            iri: '@id',
                            relativeTo: {
                              vocab: true
                            }
                          })] = expandedItem['@id'];
                        } // include @index from expanded graph, if any


                        if ('@index' in expandedItem) {
                          compactedItem[api.compactIri({
                            activeCtx: activeCtx,
                            iri: '@index',
                            relativeTo: {
                              vocab: true
                            }
                          })] = expandedItem['@index'];
                        }

                        _addValue(_nestResult, _itemActiveProperty, compactedItem, {
                          propertyIsArray: !options.compactArrays || _container5.includes('@set')
                        });
                      }

                      _context.next = 199;
                      break;

                    case 130:
                      if (!(_container5.includes('@language') || _container5.includes('@index') || _container5.includes('@id') || _container5.includes('@type'))) {
                        _context.next = 197;
                        break;
                      }

                      // handle language and index maps
                      // get or create the map object
                      _mapObject = void 0;

                      if (_nestResult.hasOwnProperty(_itemActiveProperty)) {
                        _mapObject = _nestResult[_itemActiveProperty];
                      } else {
                        _nestResult[_itemActiveProperty] = _mapObject = {};
                      }

                      _key = void 0;

                      if (!_container5.includes('@language')) {
                        _context.next = 139;
                        break;
                      }

                      // if container is a language map, simplify compacted value to
                      // a simple string
                      if (_isValue(compactedItem)) {
                        compactedItem = compactedItem['@value'];
                      }

                      _key = expandedItem['@language'];
                      _context.next = 193;
                      break;

                    case 139:
                      if (!_container5.includes('@index')) {
                        _context.next = 167;
                        break;
                      }

                      indexKey = _getContextValue(activeCtx, _itemActiveProperty, '@index') || '@index';
                      containerKey = api.compactIri({
                        activeCtx: activeCtx,
                        iri: indexKey,
                        relativeTo: {
                          vocab: true
                        }
                      });

                      if (!(indexKey === '@index')) {
                        _context.next = 147;
                        break;
                      }

                      _key = expandedItem['@index'];
                      delete compactedItem[containerKey];
                      _context.next = 165;
                      break;

                    case 147:
                      others = void 0;
                      _asArray2 = _asArray(compactedItem[indexKey] || []);
                      _asArray3 = (0, _toArray2["default"])(_asArray2);
                      _key = _asArray3[0];
                      others = _asArray3.slice(1);

                      if (_isString(_key)) {
                        _context.next = 156;
                        break;
                      }

                      // Will use @none if it isn't a string.
                      _key = null;
                      _context.next = 165;
                      break;

                    case 156:
                      _context.t1 = others.length;
                      _context.next = _context.t1 === 0 ? 159 : _context.t1 === 1 ? 161 : 163;
                      break;

                    case 159:
                      delete compactedItem[indexKey];
                      return _context.abrupt("break", 165);

                    case 161:
                      compactedItem[indexKey] = others[0];
                      return _context.abrupt("break", 165);

                    case 163:
                      compactedItem[indexKey] = others;
                      return _context.abrupt("break", 165);

                    case 165:
                      _context.next = 193;
                      break;

                    case 167:
                      if (!_container5.includes('@id')) {
                        _context.next = 173;
                        break;
                      }

                      idKey = api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@id',
                        relativeTo: {
                          vocab: true
                        }
                      });
                      _key = compactedItem[idKey];
                      delete compactedItem[idKey];
                      _context.next = 193;
                      break;

                    case 173:
                      if (!_container5.includes('@type')) {
                        _context.next = 193;
                        break;
                      }

                      typeKey = api.compactIri({
                        activeCtx: activeCtx,
                        iri: '@type',
                        relativeTo: {
                          vocab: true
                        }
                      });
                      _types = void 0;
                      _asArray4 = _asArray(compactedItem[typeKey] || []);
                      _asArray5 = (0, _toArray2["default"])(_asArray4);
                      _key = _asArray5[0];
                      _types = _asArray5.slice(1);
                      _context.t2 = _types.length;
                      _context.next = _context.t2 === 0 ? 183 : _context.t2 === 1 ? 185 : 187;
                      break;

                    case 183:
                      delete compactedItem[typeKey];
                      return _context.abrupt("break", 189);

                    case 185:
                      compactedItem[typeKey] = _types[0];
                      return _context.abrupt("break", 189);

                    case 187:
                      compactedItem[typeKey] = _types;
                      return _context.abrupt("break", 189);

                    case 189:
                      if (!(Object.keys(compactedItem).length === 1 && '@id' in expandedItem)) {
                        _context.next = 193;
                        break;
                      }

                      _context.next = 192;
                      return api.compact({
                        activeCtx: activeCtx,
                        activeProperty: _itemActiveProperty,
                        element: {
                          '@id': expandedItem['@id']
                        },
                        options: options,
                        compactionMap: compactionMap
                      });

                    case 192:
                      compactedItem = _context.sent;

                    case 193:
                      // if compacting this value which has no key, index on @none
                      if (!_key) {
                        _key = api.compactIri({
                          activeCtx: activeCtx,
                          iri: '@none',
                          relativeTo: {
                            vocab: true
                          }
                        });
                      } // add compact value to map object using key from expanded value
                      // based on the container type


                      _addValue(_mapObject, _key, compactedItem, {
                        propertyIsArray: _container5.includes('@set')
                      });

                      _context.next = 199;
                      break;

                    case 197:
                      // use an array if: compactArrays flag is false,
                      // @container is @set or @list , value is an empty
                      // array, or key is @graph
                      _isArray2 = !options.compactArrays || _container5.includes('@set') || _container5.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph'; // add compact value

                      _addValue(_nestResult, _itemActiveProperty, compactedItem, {
                        propertyIsArray: _isArray2
                      });

                    case 199:
                      _context.next = 103;
                      break;

                    case 201:
                      _context.next = 206;
                      break;

                    case 203:
                      _context.prev = 203;
                      _context.t3 = _context["catch"](101);

                      _iterator3.e(_context.t3);

                    case 206:
                      _context.prev = 206;

                      _iterator3.f();

                      return _context.finish(206);

                    case 209:
                      _context.next = 55;
                      break;

                    case 211:
                      _context.next = 216;
                      break;

                    case 213:
                      _context.prev = 213;
                      _context.t4 = _context["catch"](53);

                      _iterator2.e(_context.t4);

                    case 216:
                      _context.prev = 216;

                      _iterator2.f();

                      return _context.finish(216);

                    case 219:
                      return _context.abrupt("return", {
                        v: rval
                      });

                    case 220:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, null, [[31, 45, 48, 51], [53, 213, 216, 219], [101, 203, 206, 209]]);
            })(), "t0", 27);

          case 27:
            _ret = _context2.t0;

            if (!((0, _typeof2["default"])(_ret) === "object")) {
              _context2.next = 30;
              break;
            }

            return _context2.abrupt("return", _ret.v);

          case 30:
            return _context2.abrupt("return", element);

          case 31:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Compacts an IRI or keyword into a term or prefix if it can be. If the
 * IRI has an associated value it may be passed.
 *
 * @param activeCtx the active context to use.
 * @param iri the IRI to compact.
 * @param value the value to check or null.
 * @param relativeTo options for how to compact IRIs:
 *          vocab: true to split after @vocab, false not to.
 * @param reverse true if a reverse property is being compacted, false if not.
 * @param base the absolute URL to use for compacting document-relative IRIs.
 *
 * @return the compacted term, prefix, keyword alias, or the original IRI.
 */


api.compactIri = function (_ref3) {
  var activeCtx = _ref3.activeCtx,
      iri = _ref3.iri,
      _ref3$value = _ref3.value,
      value = _ref3$value === void 0 ? null : _ref3$value,
      _ref3$relativeTo = _ref3.relativeTo,
      relativeTo = _ref3$relativeTo === void 0 ? {
    vocab: false
  } : _ref3$relativeTo,
      _ref3$reverse = _ref3.reverse,
      reverse = _ref3$reverse === void 0 ? false : _ref3$reverse,
      _ref3$base = _ref3.base,
      base = _ref3$base === void 0 ? null : _ref3$base;

  // can't compact null
  if (iri === null) {
    return iri;
  } // if context is from a property term scoped context composed with a
  // type-scoped context, then use the previous context instead


  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {
    activeCtx = activeCtx.previousContext;
  }

  var inverseCtx = activeCtx.getInverse(); // if term is a keyword, it may be compacted to a simple alias

  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {
    return inverseCtx[iri]['@none']['@type']['@none'];
  } // use inverse context to pick a term if iri is relative to vocab


  if (relativeTo.vocab && iri in inverseCtx) {
    var defaultLanguage = activeCtx['@language'] || '@none'; // prefer @index if available in value

    var containers = [];

    if (_isObject(value) && '@index' in value && !('@graph' in value)) {
      containers.push('@index', '@index@set');
    } // if value is a preserve object, use its value


    if (_isObject(value) && '@preserve' in value) {
      value = value['@preserve'][0];
    } // prefer most specific container including @graph, prefering @set
    // variations


    if (_isGraph(value)) {
      // favor indexmap if the graph is indexed
      if ('@index' in value) {
        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');
      } // favor idmap if the graph is has an @id


      if ('@id' in value) {
        containers.push('@graph@id', '@graph@id@set');
      }

      containers.push('@graph', '@graph@set', '@set'); // allow indexmap if the graph is not indexed

      if (!('@index' in value)) {
        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');
      } // allow idmap if the graph does not have an @id


      if (!('@id' in value)) {
        containers.push('@graph@id', '@graph@id@set');
      }
    } else if (_isObject(value) && !_isValue(value)) {
      containers.push('@id', '@id@set', '@type', '@set@type');
    } // defaults for term selection based on type/language


    var typeOrLanguage = '@language';
    var typeOrLanguageValue = '@null';

    if (reverse) {
      typeOrLanguage = '@type';
      typeOrLanguageValue = '@reverse';
      containers.push('@set');
    } else if (_isList(value)) {
      // choose the most specific term that works for all elements in @list
      // only select @list containers if @index is NOT in value
      if (!('@index' in value)) {
        containers.push('@list');
      }

      var list = value['@list'];

      if (list.length === 0) {
        // any empty list can be matched against any term that uses the
        // @list container regardless of @type or @language
        typeOrLanguage = '@any';
        typeOrLanguageValue = '@none';
      } else {
        var commonLanguage = list.length === 0 ? defaultLanguage : null;
        var commonType = null;

        for (var i = 0; i < list.length; ++i) {
          var item = list[i];
          var itemLanguage = '@none';
          var itemType = '@none';

          if (_isValue(item)) {
            if ('@direction' in item) {
              var lang = (item['@language'] || '').toLowerCase();
              var dir = item['@direction'];
              itemLanguage = "".concat(lang, "_").concat(dir);
            } else if ('@language' in item) {
              itemLanguage = item['@language'].toLowerCase();
            } else if ('@type' in item) {
              itemType = item['@type'];
            } else {
              // plain literal
              itemLanguage = '@null';
            }
          } else {
            itemType = '@id';
          }

          if (commonLanguage === null) {
            commonLanguage = itemLanguage;
          } else if (itemLanguage !== commonLanguage && _isValue(item)) {
            commonLanguage = '@none';
          }

          if (commonType === null) {
            commonType = itemType;
          } else if (itemType !== commonType) {
            commonType = '@none';
          } // there are different languages and types in the list, so choose
          // the most generic term, no need to keep iterating the list


          if (commonLanguage === '@none' && commonType === '@none') {
            break;
          }
        }

        commonLanguage = commonLanguage || '@none';
        commonType = commonType || '@none';

        if (commonType !== '@none') {
          typeOrLanguage = '@type';
          typeOrLanguageValue = commonType;
        } else {
          typeOrLanguageValue = commonLanguage;
        }
      }
    } else {
      if (_isValue(value)) {
        if ('@language' in value && !('@index' in value)) {
          containers.push('@language', '@language@set');
          typeOrLanguageValue = value['@language'];
          var _dir = value['@direction'];

          if (_dir) {
            typeOrLanguageValue = "".concat(typeOrLanguageValue, "_").concat(_dir);
          }
        } else if ('@direction' in value && !('@index' in value)) {
          typeOrLanguageValue = "_".concat(value['@direction']);
        } else if ('@type' in value) {
          typeOrLanguage = '@type';
          typeOrLanguageValue = value['@type'];
        }
      } else {
        typeOrLanguage = '@type';
        typeOrLanguageValue = '@id';
      }

      containers.push('@set');
    } // do term selection


    containers.push('@none'); // an index map can be used to index values using @none, so add as a low
    // priority

    if (_isObject(value) && !('@index' in value)) {
      // allow indexing even if no @index present
      containers.push('@index', '@index@set');
    } // values without type or language can use @language map


    if (_isValue(value) && Object.keys(value).length === 1) {
      // allow indexing even if no @index present
      containers.push('@language', '@language@set');
    }

    var term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);

    if (term !== null) {
      return term;
    }
  } // no term match, use @vocab if available


  if (relativeTo.vocab) {
    if ('@vocab' in activeCtx) {
      // determine if vocab is a prefix of the iri
      var vocab = activeCtx['@vocab'];

      if (iri.indexOf(vocab) === 0 && iri !== vocab) {
        // use suffix as relative iri if it is not a term in the active context
        var suffix = iri.substr(vocab.length);

        if (!activeCtx.mappings.has(suffix)) {
          return suffix;
        }
      }
    }
  } // no term or @vocab match, check for possible CURIEs


  var choice = null; // TODO: make FastCurieMap a class with a method to do this lookup

  var partialMatches = [];
  var iriMap = activeCtx.fastCurieMap; // check for partial matches of against `iri`, which means look until
  // iri.length - 1, not full length

  var maxPartialLength = iri.length - 1;

  for (var _i2 = 0; _i2 < maxPartialLength && iri[_i2] in iriMap; ++_i2) {
    iriMap = iriMap[iri[_i2]];

    if ('' in iriMap) {
      partialMatches.push(iriMap[''][0]);
    }
  } // check partial matches in reverse order to prefer longest ones first


  for (var _i3 = partialMatches.length - 1; _i3 >= 0; --_i3) {
    var entry = partialMatches[_i3];
    var terms = entry.terms;

    var _iterator4 = _createForOfIteratorHelper(terms),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _term = _step4.value;
        // a CURIE is usable if:
        // 1. it has no mapping, OR
        // 2. value is null, which means we're not compacting an @value, AND
        //   the mapping matches the IRI
        var curie = _term + ':' + iri.substr(entry.iri.length);
        var isUsableCurie = activeCtx.mappings.get(_term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri); // select curie if it is shorter or the same length but lexicographically
        // less than the current choice

        if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {
          choice = curie;
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  } // return chosen curie


  if (choice !== null) {
    return choice;
  } // If iri could be confused with a compact IRI using a term in this context,
  // signal an error


  var _iterator5 = _createForOfIteratorHelper(activeCtx.mappings),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _step5$value = (0, _slicedToArray2["default"])(_step5.value, 2),
          _term2 = _step5$value[0],
          td = _step5$value[1];

      if (td && td._prefix && iri.startsWith(_term2 + ':')) {
        throw new JsonLdError("Absolute IRI \"".concat(iri, "\" confused with prefix \"").concat(_term2, "\"."), 'jsonld.SyntaxError', {
          code: 'IRI confused with prefix',
          context: activeCtx
        });
      }
    } // compact IRI relative to base

  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  if (!relativeTo.vocab) {
    if ('@base' in activeCtx) {
      if (!activeCtx['@base']) {
        // The None case preserves rval as potentially relative
        return iri;
      } else {
        return _removeBase(_prependBase(base, activeCtx['@base']), iri);
      }
    } else {
      return _removeBase(base, iri);
    }
  } // return IRI as is


  return iri;
};
/**
 * Performs value compaction on an object with '@value' or '@id' as the only
 * property.
 *
 * @param activeCtx the active context.
 * @param activeProperty the active property that points to the value.
 * @param value the value to compact.
 * @param {Object} [options] - processing options.
 *
 * @return the compaction result.
 */


api.compactValue = function (_ref4) {
  var activeCtx = _ref4.activeCtx,
      activeProperty = _ref4.activeProperty,
      value = _ref4.value,
      options = _ref4.options;

  // value is a @value
  if (_isValue(value)) {
    // get context rules
    var _type = _getContextValue(activeCtx, activeProperty, '@type');

    var language = _getContextValue(activeCtx, activeProperty, '@language');

    var direction = _getContextValue(activeCtx, activeProperty, '@direction');

    var container = _getContextValue(activeCtx, activeProperty, '@container') || []; // whether or not the value has an @index that must be preserved

    var preserveIndex = '@index' in value && !container.includes('@index'); // if there's no @index to preserve ...

    if (!preserveIndex && _type !== '@none') {
      // matching @type or @language specified in context, compact value
      if (value['@type'] === _type) {
        return value['@value'];
      }

      if ('@language' in value && value['@language'] === language && '@direction' in value && value['@direction'] === direction) {
        return value['@value'];
      }

      if ('@language' in value && value['@language'] === language) {
        return value['@value'];
      }

      if ('@direction' in value && value['@direction'] === direction) {
        return value['@value'];
      }
    } // return just the value of @value if all are true:
    // 1. @value is the only key or @index isn't being preserved
    // 2. there is no default language or @value is not a string or
    //   the key has a mapping with a null @language


    var keyCount = Object.keys(value).length;
    var isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;
    var hasDefaultLanguage = ('@language' in activeCtx);

    var isValueString = _isString(value['@value']);

    var hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;

    if (isValueOnlyKey && _type !== '@none' && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {
      return value['@value'];
    }

    var rval = {}; // preserve @index

    if (preserveIndex) {
      rval[api.compactIri({
        activeCtx: activeCtx,
        iri: '@index',
        relativeTo: {
          vocab: true
        }
      })] = value['@index'];
    }

    if ('@type' in value) {
      // compact @type IRI
      rval[api.compactIri({
        activeCtx: activeCtx,
        iri: '@type',
        relativeTo: {
          vocab: true
        }
      })] = api.compactIri({
        activeCtx: activeCtx,
        iri: value['@type'],
        relativeTo: {
          vocab: true
        }
      });
    } else if ('@language' in value) {
      // alias @language
      rval[api.compactIri({
        activeCtx: activeCtx,
        iri: '@language',
        relativeTo: {
          vocab: true
        }
      })] = value['@language'];
    }

    if ('@direction' in value) {
      // alias @direction
      rval[api.compactIri({
        activeCtx: activeCtx,
        iri: '@direction',
        relativeTo: {
          vocab: true
        }
      })] = value['@direction'];
    } // alias @value


    rval[api.compactIri({
      activeCtx: activeCtx,
      iri: '@value',
      relativeTo: {
        vocab: true
      }
    })] = value['@value'];
    return rval;
  } // value is a subject reference


  var expandedProperty = _expandIri(activeCtx, activeProperty, {
    vocab: true
  }, options);

  var type = _getContextValue(activeCtx, activeProperty, '@type');

  var compacted = api.compactIri({
    activeCtx: activeCtx,
    iri: value['@id'],
    relativeTo: {
      vocab: type === '@vocab'
    },
    base: options.base
  }); // compact to scalar

  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {
    return compacted;
  }

  return (0, _defineProperty2["default"])({}, api.compactIri({
    activeCtx: activeCtx,
    iri: '@id',
    relativeTo: {
      vocab: true
    }
  }), compacted);
};
/**
 * Picks the preferred compaction term from the given inverse context entry.
 *
 * @param activeCtx the active context.
 * @param iri the IRI to pick the term for.
 * @param value the value to pick the term for.
 * @param containers the preferred containers.
 * @param typeOrLanguage either '@type' or '@language'.
 * @param typeOrLanguageValue the preferred value for '@type' or '@language'.
 *
 * @return the preferred term.
 */


function _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
  if (typeOrLanguageValue === null) {
    typeOrLanguageValue = '@null';
  } // preferences for the value of @type or @language


  var prefs = []; // determine prefs for @id based on whether or not value compacts to a term

  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isObject(value) && '@id' in value) {
    // prefer @reverse first
    if (typeOrLanguageValue === '@reverse') {
      prefs.push('@reverse');
    } // try to compact value to a term


    var term = api.compactIri({
      activeCtx: activeCtx,
      iri: value['@id'],
      relativeTo: {
        vocab: true
      }
    });

    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {
      // prefer @vocab
      prefs.push.apply(prefs, ['@vocab', '@id']);
    } else {
      // prefer @id
      prefs.push.apply(prefs, ['@id', '@vocab']);
    }
  } else {
    prefs.push(typeOrLanguageValue); // consider direction only

    var langDir = prefs.find(function (el) {
      return el.includes('_');
    });

    if (langDir) {
      // consider _dir portion
      prefs.push(langDir.replace(/^[^_]+_/, '_'));
    }
  }

  prefs.push('@none');
  var containerMap = activeCtx.inverse[iri];

  var _iterator6 = _createForOfIteratorHelper(containers),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var container = _step6.value;

      // if container not available in the map, continue
      if (!(container in containerMap)) {
        continue;
      }

      var typeOrLanguageValueMap = containerMap[container][typeOrLanguage];

      var _iterator7 = _createForOfIteratorHelper(prefs),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var pref = _step7.value;

          // if type/language option not available in the map, continue
          if (!(pref in typeOrLanguageValueMap)) {
            continue;
          } // select term


          return typeOrLanguageValueMap[pref];
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return null;
}
/**
 * The value of `@nest` in the term definition must either be `@nest`, or a term
 * which resolves to `@nest`.
 *
 * @param activeCtx the active context.
 * @param nestProperty a term in the active context or `@nest`.
 * @param {Object} [options] - processing options.
 */


function _checkNestProperty(activeCtx, nestProperty, options) {
  if (_expandIri(activeCtx, nestProperty, {
    vocab: true
  }, options) !== '@nest') {
    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {
      code: 'invalid @nest value'
    });
  }
}

},{"./JsonLdError":91,"./context":99,"./graphTypes":106,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/defineProperty":10,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/toArray":25,"@babel/runtime/helpers/typeof":27,"@babel/runtime/regenerator":30}],98:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
var XSD = 'http://www.w3.org/2001/XMLSchema#';
module.exports = {
  // TODO: Deprecated and will be removed later. Use LINK_HEADER_CONTEXT.
  LINK_HEADER_REL: 'http://www.w3.org/ns/json-ld#context',
  LINK_HEADER_CONTEXT: 'http://www.w3.org/ns/json-ld#context',
  RDF: RDF,
  RDF_LIST: RDF + 'List',
  RDF_FIRST: RDF + 'first',
  RDF_REST: RDF + 'rest',
  RDF_NIL: RDF + 'nil',
  RDF_TYPE: RDF + 'type',
  RDF_PLAIN_LITERAL: RDF + 'PlainLiteral',
  RDF_XML_LITERAL: RDF + 'XMLLiteral',
  RDF_JSON_LITERAL: RDF + 'JSON',
  RDF_OBJECT: RDF + 'object',
  RDF_LANGSTRING: RDF + 'langString',
  XSD: XSD,
  XSD_BOOLEAN: XSD + 'boolean',
  XSD_DOUBLE: XSD + 'double',
  XSD_INTEGER: XSD + 'integer',
  XSD_STRING: XSD + 'string'
};

},{}],99:[function(require,module,exports){
/*
 * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var util = require('./util');

var JsonLdError = require('./JsonLdError');

var _require = require('./types'),
    _isArray = _require.isArray,
    _isObject = _require.isObject,
    _isString = _require.isString,
    _isUndefined = _require.isUndefined;

var _require2 = require('./url'),
    _isAbsoluteIri = _require2.isAbsolute,
    _isRelativeIri = _require2.isRelative,
    prependBase = _require2.prependBase,
    parseUrl = _require2.parse;

var _require3 = require('./util'),
    _asArray = _require3.asArray,
    _compareShortestLeast = _require3.compareShortestLeast;

var INITIAL_CONTEXT_CACHE = new Map();
var INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;
var KEYWORD_PATTERN = /^@[a-zA-Z]+$/;
var api = {};
module.exports = api;
/**
 * Processes a local context and returns a new active context.
 *
 * @param activeCtx the current active context.
 * @param localCtx the local context to process.
 * @param options the context processing options.
 * @param propagate `true` if `false`, retains any previously defined term,
 *   which can be rolled back when the descending into a new node object.
 * @param overrideProtected `false` allows protected terms to be modified.
 *
 * @return a Promise that resolves to the new active context.
 */

api.process = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref) {
    var activeCtx, localCtx, options, _ref$propagate, propagate, _ref$overrideProtecte, overrideProtected, _ref$cycles, cycles, ctxs, resolved, rval, _iterator, _step, resolvedContext, ctx, protectedMode, _processed, oldActiveCtx, _i, _Object$entries, _Object$entries$_i, term, _protected, processed, defined, base, value, _value, _value2, _value3, _value4, resolvedImport, processedImport, importCtx, key, _key, keyCtx, process, url;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            activeCtx = _ref.activeCtx, localCtx = _ref.localCtx, options = _ref.options, _ref$propagate = _ref.propagate, propagate = _ref$propagate === void 0 ? true : _ref$propagate, _ref$overrideProtecte = _ref.overrideProtected, overrideProtected = _ref$overrideProtecte === void 0 ? false : _ref$overrideProtecte, _ref$cycles = _ref.cycles, cycles = _ref$cycles === void 0 ? new Set() : _ref$cycles;

            // normalize local context to an array of @context objects
            if (_isObject(localCtx) && '@context' in localCtx && _isArray(localCtx['@context'])) {
              localCtx = localCtx['@context'];
            }

            ctxs = _asArray(localCtx); // no contexts in array, return current active context w/o changes

            if (!(ctxs.length === 0)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", activeCtx);

          case 5:
            _context.next = 7;
            return options.contextResolver.resolve({
              activeCtx: activeCtx,
              context: localCtx,
              documentLoader: options.documentLoader,
              base: options.base
            });

          case 7:
            resolved = _context.sent;

            // override propagate if first resolved context has `@propagate`
            if (_isObject(resolved[0].document) && typeof resolved[0].document['@propagate'] === 'boolean') {
              // retrieve early, error checking done later
              propagate = resolved[0].document['@propagate'];
            } // process each context in order, update active context
            // on each iteration to ensure proper caching


            rval = activeCtx; // track the previous context
            // if not propagating, make sure rval has a previous context

            if (!propagate && !rval.previousContext) {
              // clone `rval` context before updating
              rval = rval.clone();
              rval.previousContext = activeCtx;
            }

            _iterator = _createForOfIteratorHelper(resolved);
            _context.prev = 12;

            _iterator.s();

          case 14:
            if ((_step = _iterator.n()).done) {
              _context.next = 164;
              break;
            }

            resolvedContext = _step.value;
            ctx = resolvedContext.document; // update active context to one computed from last iteration

            activeCtx = rval; // reset to initial context

            if (!(ctx === null)) {
              _context.next = 40;
              break;
            }

            if (!(!overrideProtected && Object.keys(activeCtx["protected"]).length !== 0)) {
              _context.next = 38;
              break;
            }

            protectedMode = options && options.protectedMode || 'error';

            if (!(protectedMode === 'error')) {
              _context.next = 25;
              break;
            }

            throw new JsonLdError('Tried to nullify a context with protected terms outside of ' + 'a term definition.', 'jsonld.SyntaxError', {
              code: 'invalid context nullification'
            });

          case 25:
            if (!(protectedMode === 'warn')) {
              _context.next = 37;
              break;
            }

            // FIXME: remove logging and use a handler
            console.warn('WARNING: invalid context nullification'); // get processed context from cache if available

            _processed = resolvedContext.getProcessed(activeCtx);

            if (!_processed) {
              _context.next = 31;
              break;
            }

            rval = activeCtx = _processed;
            return _context.abrupt("continue", 162);

          case 31:
            oldActiveCtx = activeCtx; // copy all protected term definitions to fresh initial context

            rval = activeCtx = api.getInitialContext(options).clone();

            for (_i = 0, _Object$entries = Object.entries(oldActiveCtx["protected"]); _i < _Object$entries.length; _i++) {
              _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2), term = _Object$entries$_i[0], _protected = _Object$entries$_i[1];

              if (_protected) {
                activeCtx.mappings[term] = util.clone(oldActiveCtx.mappings[term]);
              }
            }

            activeCtx["protected"] = util.clone(oldActiveCtx["protected"]); // cache processed result

            resolvedContext.setProcessed(oldActiveCtx, rval);
            return _context.abrupt("continue", 162);

          case 37:
            throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {
              code: 'invalid protected mode',
              context: localCtx,
              protectedMode: protectedMode
            });

          case 38:
            rval = activeCtx = api.getInitialContext(options).clone();
            return _context.abrupt("continue", 162);

          case 40:
            // get processed context from cache if available
            processed = resolvedContext.getProcessed(activeCtx);

            if (!processed) {
              _context.next = 44;
              break;
            }

            rval = activeCtx = processed;
            return _context.abrupt("continue", 162);

          case 44:
            // dereference @context key if present
            if (_isObject(ctx) && '@context' in ctx) {
              ctx = ctx['@context'];
            } // context must be an object by now, all URLs retrieved before this call


            if (_isObject(ctx)) {
              _context.next = 47;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {
              code: 'invalid local context',
              context: ctx
            });

          case 47:
            // TODO: there is likely a `previousContext` cloning optimization that
            // could be applied here (no need to copy it under certain conditions)
            // clone context before updating it
            rval = rval.clone(); // define context mappings for keys in local context

            defined = new Map(); // handle @version

            if (!('@version' in ctx)) {
              _context.next = 57;
              break;
            }

            if (!(ctx['@version'] !== 1.1)) {
              _context.next = 52;
              break;
            }

            throw new JsonLdError('Unsupported JSON-LD version: ' + ctx['@version'], 'jsonld.UnsupportedVersion', {
              code: 'invalid @version value',
              context: ctx
            });

          case 52:
            if (!(activeCtx.processingMode && activeCtx.processingMode === 'json-ld-1.0')) {
              _context.next = 54;
              break;
            }

            throw new JsonLdError('@version: ' + ctx['@version'] + ' not compatible with ' + activeCtx.processingMode, 'jsonld.ProcessingModeConflict', {
              code: 'processing mode conflict',
              context: ctx
            });

          case 54:
            rval.processingMode = 'json-ld-1.1';
            rval['@version'] = ctx['@version'];
            defined.set('@version', true);

          case 57:
            // if not set explicitly, set processingMode to "json-ld-1.1"
            rval.processingMode = rval.processingMode || activeCtx.processingMode; // handle @base

            if (!('@base' in ctx)) {
              _context.next = 70;
              break;
            }

            base = ctx['@base'];

            if (!(base === null || _isAbsoluteIri(base))) {
              _context.next = 63;
              break;
            }

            _context.next = 68;
            break;

          case 63:
            if (!_isRelativeIri(base)) {
              _context.next = 67;
              break;
            }

            base = prependBase(rval['@base'], base);
            _context.next = 68;
            break;

          case 67:
            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@base" in a ' + '@context must be an absolute IRI, a relative IRI, or null.', 'jsonld.SyntaxError', {
              code: 'invalid base IRI',
              context: ctx
            });

          case 68:
            rval['@base'] = base;
            defined.set('@base', true);

          case 70:
            if (!('@vocab' in ctx)) {
              _context.next = 86;
              break;
            }

            value = ctx['@vocab'];

            if (!(value === null)) {
              _context.next = 76;
              break;
            }

            delete rval['@vocab'];
            _context.next = 85;
            break;

          case 76:
            if (_isString(value)) {
              _context.next = 80;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {
              code: 'invalid vocab mapping',
              context: ctx
            });

          case 80:
            if (!(!_isAbsoluteIri(value) && api.processingMode(rval, 1.0))) {
              _context.next = 84;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a ' + '@context must be an absolute IRI.', 'jsonld.SyntaxError', {
              code: 'invalid vocab mapping',
              context: ctx
            });

          case 84:
            rval['@vocab'] = _expandIri(rval, value, {
              vocab: true,
              base: true
            }, undefined, undefined, options);

          case 85:
            defined.set('@vocab', true);

          case 86:
            if (!('@language' in ctx)) {
              _context.next = 98;
              break;
            }

            _value = ctx['@language'];

            if (!(_value === null)) {
              _context.next = 92;
              break;
            }

            delete rval['@language'];
            _context.next = 97;
            break;

          case 92:
            if (_isString(_value)) {
              _context.next = 96;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@language" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {
              code: 'invalid default language',
              context: ctx
            });

          case 96:
            rval['@language'] = _value.toLowerCase();

          case 97:
            defined.set('@language', true);

          case 98:
            if (!('@direction' in ctx)) {
              _context.next = 112;
              break;
            }

            _value2 = ctx['@direction'];

            if (!(activeCtx.processingMode === 'json-ld-1.0')) {
              _context.next = 102;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @direction not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {
              code: 'invalid context member',
              context: ctx
            });

          case 102:
            if (!(_value2 === null)) {
              _context.next = 106;
              break;
            }

            delete rval['@direction'];
            _context.next = 111;
            break;

          case 106:
            if (!(_value2 !== 'ltr' && _value2 !== 'rtl')) {
              _context.next = 110;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; the value of "@direction" in a ' + '@context must be null, "ltr", or "rtl".', 'jsonld.SyntaxError', {
              code: 'invalid base direction',
              context: ctx
            });

          case 110:
            rval['@direction'] = _value2;

          case 111:
            defined.set('@direction', true);

          case 112:
            if (!('@propagate' in ctx)) {
              _context.next = 119;
              break;
            }

            _value3 = ctx['@propagate'];

            if (!(activeCtx.processingMode === 'json-ld-1.0')) {
              _context.next = 116;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @propagate not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {
              code: 'invalid context entry',
              context: ctx
            });

          case 116:
            if (!(typeof _value3 !== 'boolean')) {
              _context.next = 118;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @propagate value must be a boolean.', 'jsonld.SyntaxError', {
              code: 'invalid @propagate value',
              context: localCtx
            });

          case 118:
            defined.set('@propagate', true);

          case 119:
            if (!('@import' in ctx)) {
              _context.next = 141;
              break;
            }

            _value4 = ctx['@import'];

            if (!(activeCtx.processingMode === 'json-ld-1.0')) {
              _context.next = 123;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @import not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {
              code: 'invalid context entry',
              context: ctx
            });

          case 123:
            if (_isString(_value4)) {
              _context.next = 125;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @import must be a string.', 'jsonld.SyntaxError', {
              code: 'invalid @import value',
              context: localCtx
            });

          case 125:
            _context.next = 127;
            return options.contextResolver.resolve({
              activeCtx: activeCtx,
              context: _value4,
              documentLoader: options.documentLoader,
              base: options.base
            });

          case 127:
            resolvedImport = _context.sent;

            if (!(resolvedImport.length !== 1)) {
              _context.next = 130;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; @import must reference a single context.', 'jsonld.SyntaxError', {
              code: 'invalid remote context',
              context: localCtx
            });

          case 130:
            processedImport = resolvedImport[0].getProcessed(activeCtx);

            if (!processedImport) {
              _context.next = 135;
              break;
            }

            // Note: if the same context were used in this active context
            // as a reference context, then processed_input might not
            // be a dict.
            ctx = processedImport;
            _context.next = 140;
            break;

          case 135:
            importCtx = resolvedImport[0].document;

            if (!('@import' in importCtx)) {
              _context.next = 138;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax: ' + 'imported context must not include @import.', 'jsonld.SyntaxError', {
              code: 'invalid context entry',
              context: localCtx
            });

          case 138:
            // merge ctx into importCtx and replace rval with the result
            for (key in importCtx) {
              if (!ctx.hasOwnProperty(key)) {
                ctx[key] = importCtx[key];
              }
            } // Note: this could potenially conflict if the import
            // were used in the same active context as a referenced
            // context and an import. In this case, we
            // could override the cached result, but seems unlikely.


            resolvedImport[0].setProcessed(activeCtx, ctx);

          case 140:
            defined.set('@import', true);

          case 141:
            // handle @protected; determine whether this sub-context is declaring
            // all its terms to be "protected" (exceptions can be made on a
            // per-definition basis)
            defined.set('@protected', ctx['@protected'] || false); // process all other keys

            _context.t0 = _regenerator["default"].keys(ctx);

          case 143:
            if ((_context.t1 = _context.t0()).done) {
              _context.next = 161;
              break;
            }

            _key = _context.t1.value;
            api.createTermDefinition({
              activeCtx: rval,
              localCtx: ctx,
              term: _key,
              defined: defined,
              options: options,
              overrideProtected: overrideProtected
            });

            if (!(_isObject(ctx[_key]) && '@context' in ctx[_key])) {
              _context.next = 159;
              break;
            }

            keyCtx = ctx[_key]['@context'];
            process = true;

            if (_isString(keyCtx)) {
              url = prependBase(options.base, keyCtx); // track processed contexts to avoid scoped context recursion

              if (cycles.has(url)) {
                process = false;
              } else {
                cycles.add(url);
              }
            } // parse context to validate


            if (!process) {
              _context.next = 159;
              break;
            }

            _context.prev = 151;
            _context.next = 154;
            return api.process({
              activeCtx: rval.clone(),
              localCtx: ctx[_key]['@context'],
              overrideProtected: true,
              options: options,
              cycles: cycles
            });

          case 154:
            _context.next = 159;
            break;

          case 156:
            _context.prev = 156;
            _context.t2 = _context["catch"](151);
            throw new JsonLdError('Invalid JSON-LD syntax; invalid scoped context.', 'jsonld.SyntaxError', {
              code: 'invalid scoped context',
              context: ctx[_key]['@context'],
              term: _key
            });

          case 159:
            _context.next = 143;
            break;

          case 161:
            // cache processed result
            resolvedContext.setProcessed(activeCtx, rval);

          case 162:
            _context.next = 14;
            break;

          case 164:
            _context.next = 169;
            break;

          case 166:
            _context.prev = 166;
            _context.t3 = _context["catch"](12);

            _iterator.e(_context.t3);

          case 169:
            _context.prev = 169;

            _iterator.f();

            return _context.finish(169);

          case 172:
            return _context.abrupt("return", rval);

          case 173:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[12, 166, 169, 172], [151, 156]]);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Creates a term definition during context processing.
 *
 * @param activeCtx the current active context.
 * @param localCtx the local context being processed.
 * @param term the term in the local context to define the mapping for.
 * @param defined a map of defining/defined keys to detect cycles and prevent
 *          double definitions.
 * @param {Object} [options] - creation options.
 * @param {string} [options.protectedMode="error"] - "error" to throw error
 *   on `@protected` constraint violation, "warn" to allow violations and
 *   signal a warning.
 * @param overrideProtected `false` allows protected terms to be modified.
 */


api.createTermDefinition = function (_ref3) {
  var activeCtx = _ref3.activeCtx,
      localCtx = _ref3.localCtx,
      term = _ref3.term,
      defined = _ref3.defined,
      options = _ref3.options,
      _ref3$overrideProtect = _ref3.overrideProtected,
      overrideProtected = _ref3$overrideProtect === void 0 ? false : _ref3$overrideProtect;

  if (defined.has(term)) {
    // term already defined
    if (defined.get(term)) {
      return;
    } // cycle detected


    throw new JsonLdError('Cyclical context definition detected.', 'jsonld.CyclicalContext', {
      code: 'cyclic IRI mapping',
      context: localCtx,
      term: term
    });
  } // now defining term


  defined.set(term, false); // get context term value

  var value;

  if (localCtx.hasOwnProperty(term)) {
    value = localCtx[term];
  }

  if (term === '@type' && _isObject(value) && (value['@container'] || '@set') === '@set' && api.processingMode(activeCtx, 1.1)) {
    var _validKeys = ['@container', '@id', '@protected'];
    var keys = Object.keys(value);

    if (keys.length === 0 || keys.some(function (k) {
      return !_validKeys.includes(k);
    })) {
      throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {
        code: 'keyword redefinition',
        context: localCtx,
        term: term
      });
    }
  } else if (api.isKeyword(term)) {
    throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {
      code: 'keyword redefinition',
      context: localCtx,
      term: term
    });
  } else if (term.match(KEYWORD_PATTERN)) {
    // FIXME: remove logging and use a handler
    console.warn('WARNING: terms beginning with "@" are reserved' + ' for future use and ignored', {
      term: term
    });
    return;
  } else if (term === '') {
    throw new JsonLdError('Invalid JSON-LD syntax; a term cannot be an empty string.', 'jsonld.SyntaxError', {
      code: 'invalid term definition',
      context: localCtx
    });
  } // keep reference to previous mapping for potential `@protected` check


  var previousMapping = activeCtx.mappings.get(term); // remove old mapping

  if (activeCtx.mappings.has(term)) {
    activeCtx.mappings["delete"](term);
  } // convert short-hand value to object w/@id


  var simpleTerm = false;

  if (_isString(value) || value === null) {
    simpleTerm = true;
    value = {
      '@id': value
    };
  }

  if (!_isObject(value)) {
    throw new JsonLdError('Invalid JSON-LD syntax; @context term values must be ' + 'strings or objects.', 'jsonld.SyntaxError', {
      code: 'invalid term definition',
      context: localCtx
    });
  } // create new mapping


  var mapping = {};
  activeCtx.mappings.set(term, mapping);
  mapping.reverse = false; // make sure term definition only has expected keywords

  var validKeys = ['@container', '@id', '@language', '@reverse', '@type']; // JSON-LD 1.1 support

  if (api.processingMode(activeCtx, 1.1)) {
    validKeys.push('@context', '@direction', '@index', '@nest', '@prefix', '@protected');
  }

  for (var kw in value) {
    if (!validKeys.includes(kw)) {
      throw new JsonLdError('Invalid JSON-LD syntax; a term definition must not contain ' + kw, 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }
  } // always compute whether term has a colon as an optimization for
  // _compactIri


  var colon = term.indexOf(':');
  mapping._termHasColon = colon > 0;

  if ('@reverse' in value) {
    if ('@id' in value) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @id.', 'jsonld.SyntaxError', {
        code: 'invalid reverse property',
        context: localCtx
      });
    }

    if ('@nest' in value) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @nest.', 'jsonld.SyntaxError', {
        code: 'invalid reverse property',
        context: localCtx
      });
    }

    var reverse = value['@reverse'];

    if (!_isString(reverse)) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be a string.', 'jsonld.SyntaxError', {
        code: 'invalid IRI mapping',
        context: localCtx
      });
    }

    if (!api.isKeyword(reverse) && reverse.match(KEYWORD_PATTERN)) {
      // FIXME: remove logging and use a handler
      console.warn('WARNING: values beginning with "@" are reserved' + ' for future use and ignored', {
        reverse: reverse
      });

      if (previousMapping) {
        activeCtx.mappings.set(term, previousMapping);
      } else {
        activeCtx.mappings["delete"](term);
      }

      return;
    } // expand and add @id mapping


    var _id = _expandIri(activeCtx, reverse, {
      vocab: true,
      base: false
    }, localCtx, defined, options);

    if (!_isAbsoluteIri(_id)) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be an ' + 'absolute IRI or a blank node identifier.', 'jsonld.SyntaxError', {
        code: 'invalid IRI mapping',
        context: localCtx
      });
    }

    mapping['@id'] = _id;
    mapping.reverse = true;
  } else if ('@id' in value) {
    var _id2 = value['@id'];

    if (_id2 && !_isString(_id2)) {
      throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an array ' + 'of strings or a string.', 'jsonld.SyntaxError', {
        code: 'invalid IRI mapping',
        context: localCtx
      });
    }

    if (_id2 === null) {
      // reserve a null term, which may be protected
      mapping['@id'] = null;
    } else if (!api.isKeyword(_id2) && _id2.match(KEYWORD_PATTERN)) {
      // FIXME: remove logging and use a handler
      console.warn('WARNING: values beginning with "@" are reserved' + ' for future use and ignored', {
        id: _id2
      });

      if (previousMapping) {
        activeCtx.mappings.set(term, previousMapping);
      } else {
        activeCtx.mappings["delete"](term);
      }

      return;
    } else if (_id2 !== term) {
      // expand and add @id mapping
      _id2 = _expandIri(activeCtx, _id2, {
        vocab: true,
        base: false
      }, localCtx, defined, options);

      if (!_isAbsoluteIri(_id2) && !api.isKeyword(_id2)) {
        throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an ' + 'absolute IRI, a blank node identifier, or a keyword.', 'jsonld.SyntaxError', {
          code: 'invalid IRI mapping',
          context: localCtx
        });
      } // if term has the form of an IRI it must map the same


      if (term.match(/(?::[^:])|\//)) {
        var termDefined = new Map(defined).set(term, true);

        var termIri = _expandIri(activeCtx, term, {
          vocab: true,
          base: false
        }, localCtx, termDefined, options);

        if (termIri !== _id2) {
          throw new JsonLdError('Invalid JSON-LD syntax; term in form of IRI must ' + 'expand to definition.', 'jsonld.SyntaxError', {
            code: 'invalid IRI mapping',
            context: localCtx
          });
        }
      }

      mapping['@id'] = _id2; // indicate if this term may be used as a compact IRI prefix

      mapping._prefix = simpleTerm && !mapping._termHasColon && _id2.match(/[:\/\?#\[\]@]$/);
    }
  }

  if (!('@id' in mapping)) {
    // see if the term has a prefix
    if (mapping._termHasColon) {
      var prefix = term.substr(0, colon);

      if (localCtx.hasOwnProperty(prefix)) {
        // define parent prefix
        api.createTermDefinition({
          activeCtx: activeCtx,
          localCtx: localCtx,
          term: prefix,
          defined: defined,
          options: options
        });
      }

      if (activeCtx.mappings.has(prefix)) {
        // set @id based on prefix parent
        var suffix = term.substr(colon + 1);
        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;
      } else {
        // term is an absolute IRI
        mapping['@id'] = term;
      }
    } else if (term === '@type') {
      // Special case, were we've previously determined that container is @set
      mapping['@id'] = term;
    } else {
      // non-IRIs *must* define @ids if @vocab is not available
      if (!('@vocab' in activeCtx)) {
        throw new JsonLdError('Invalid JSON-LD syntax; @context terms must define an @id.', 'jsonld.SyntaxError', {
          code: 'invalid IRI mapping',
          context: localCtx,
          term: term
        });
      } // prepend vocab to term


      mapping['@id'] = activeCtx['@vocab'] + term;
    }
  } // Handle term protection


  if (value['@protected'] === true || defined.get('@protected') === true && value['@protected'] !== false) {
    activeCtx["protected"][term] = true;
    mapping["protected"] = true;
  } // IRI mapping now defined


  defined.set(term, true);

  if ('@type' in value) {
    var type = value['@type'];

    if (!_isString(type)) {
      throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be a string.', 'jsonld.SyntaxError', {
        code: 'invalid type mapping',
        context: localCtx
      });
    }

    if (type === '@json' || type === '@none') {
      if (api.processingMode(activeCtx, 1.0)) {
        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must not be ' + "\"".concat(type, "\" in JSON-LD 1.0 mode."), 'jsonld.SyntaxError', {
          code: 'invalid type mapping',
          context: localCtx
        });
      }
    } else if (type !== '@id' && type !== '@vocab') {
      // expand @type to full IRI
      type = _expandIri(activeCtx, type, {
        vocab: true,
        base: false
      }, localCtx, defined, options);

      if (!_isAbsoluteIri(type)) {
        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an ' + 'absolute IRI.', 'jsonld.SyntaxError', {
          code: 'invalid type mapping',
          context: localCtx
        });
      }

      if (type.indexOf('_:') === 0) {
        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an IRI, ' + 'not a blank node identifier.', 'jsonld.SyntaxError', {
          code: 'invalid type mapping',
          context: localCtx
        });
      }
    } // add @type to mapping


    mapping['@type'] = type;
  }

  if ('@container' in value) {
    // normalize container to an array form
    var container = _isString(value['@container']) ? [value['@container']] : value['@container'] || [];
    var validContainers = ['@list', '@set', '@index', '@language'];
    var isValid = true;
    var hasSet = container.includes('@set'); // JSON-LD 1.1 support

    if (api.processingMode(activeCtx, 1.1)) {
      validContainers.push('@graph', '@id', '@type'); // check container length

      if (container.includes('@list')) {
        if (container.length !== 1) {
          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @list must ' + 'have no other values', 'jsonld.SyntaxError', {
            code: 'invalid container mapping',
            context: localCtx
          });
        }
      } else if (container.includes('@graph')) {
        if (container.some(function (key) {
          return key !== '@graph' && key !== '@id' && key !== '@index' && key !== '@set';
        })) {
          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @graph must ' + 'have no other values other than @id, @index, and @set', 'jsonld.SyntaxError', {
            code: 'invalid container mapping',
            context: localCtx
          });
        }
      } else {
        // otherwise, container may also include @set
        isValid &= container.length <= (hasSet ? 2 : 1);
      }

      if (container.includes('@type')) {
        // If mapping does not have an @type,
        // set it to @id
        mapping['@type'] = mapping['@type'] || '@id'; // type mapping must be either @id or @vocab

        if (!['@id', '@vocab'].includes(mapping['@type'])) {
          throw new JsonLdError('Invalid JSON-LD syntax; container: @type requires @type to be ' + '@id or @vocab.', 'jsonld.SyntaxError', {
            code: 'invalid type mapping',
            context: localCtx
          });
        }
      }
    } else {
      // in JSON-LD 1.0, container must not be an array (it must be a string,
      // which is one of the validContainers)
      isValid &= !_isArray(value['@container']); // check container length

      isValid &= container.length <= 1;
    } // check against valid containers


    isValid &= container.every(function (c) {
      return validContainers.includes(c);
    }); // @set not allowed with @list

    isValid &= !(hasSet && container.includes('@list'));

    if (!isValid) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value must be ' + 'one of the following: ' + validContainers.join(', '), 'jsonld.SyntaxError', {
        code: 'invalid container mapping',
        context: localCtx
      });
    }

    if (mapping.reverse && !container.every(function (c) {
      return ['@index', '@set'].includes(c);
    })) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value for a @reverse ' + 'type definition must be @index or @set.', 'jsonld.SyntaxError', {
        code: 'invalid reverse property',
        context: localCtx
      });
    } // add @container to mapping


    mapping['@container'] = container;
  } // property indexing


  if ('@index' in value) {
    if (!('@container' in value) || !mapping['@container'].includes('@index')) {
      throw new JsonLdError('Invalid JSON-LD syntax; @index without @index in @container: ' + "\"".concat(value['@index'], "\" on term \"").concat(term, "\"."), 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }

    if (!_isString(value['@index']) || value['@index'].indexOf('@') === 0) {
      throw new JsonLdError('Invalid JSON-LD syntax; @index must expand to an IRI: ' + "\"".concat(value['@index'], "\" on term \"").concat(term, "\"."), 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }

    mapping['@index'] = value['@index'];
  } // scoped contexts


  if ('@context' in value) {
    mapping['@context'] = value['@context'];
  }

  if ('@language' in value && !('@type' in value)) {
    var language = value['@language'];

    if (language !== null && !_isString(language)) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @language value must be ' + 'a string or null.', 'jsonld.SyntaxError', {
        code: 'invalid language mapping',
        context: localCtx
      });
    } // add @language to mapping


    if (language !== null) {
      language = language.toLowerCase();
    }

    mapping['@language'] = language;
  } // term may be used as a prefix


  if ('@prefix' in value) {
    if (term.match(/:|\//)) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @prefix used on a compact IRI term', 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }

    if (api.isKeyword(mapping['@id'])) {
      throw new JsonLdError('Invalid JSON-LD syntax; keywords may not be used as prefixes', 'jsonld.SyntaxError', {
        code: 'invalid term definition',
        context: localCtx
      });
    }

    if (typeof value['@prefix'] === 'boolean') {
      mapping._prefix = value['@prefix'] === true;
    } else {
      throw new JsonLdError('Invalid JSON-LD syntax; @context value for @prefix must be boolean', 'jsonld.SyntaxError', {
        code: 'invalid @prefix value',
        context: localCtx
      });
    }
  }

  if ('@direction' in value) {
    var direction = value['@direction'];

    if (direction !== null && direction !== 'ltr' && direction !== 'rtl') {
      throw new JsonLdError('Invalid JSON-LD syntax; @direction value must be ' + 'null, "ltr", or "rtl".', 'jsonld.SyntaxError', {
        code: 'invalid base direction',
        context: localCtx
      });
    }

    mapping['@direction'] = direction;
  }

  if ('@nest' in value) {
    var nest = value['@nest'];

    if (!_isString(nest) || nest !== '@nest' && nest.indexOf('@') === 0) {
      throw new JsonLdError('Invalid JSON-LD syntax; @context @nest value must be ' + 'a string which is not a keyword other than @nest.', 'jsonld.SyntaxError', {
        code: 'invalid @nest value',
        context: localCtx
      });
    }

    mapping['@nest'] = nest;
  } // disallow aliasing @context and @preserve


  var id = mapping['@id'];

  if (id === '@context' || id === '@preserve') {
    throw new JsonLdError('Invalid JSON-LD syntax; @context and @preserve cannot be aliased.', 'jsonld.SyntaxError', {
      code: 'invalid keyword alias',
      context: localCtx
    });
  } // Check for overriding protected terms


  if (previousMapping && previousMapping["protected"] && !overrideProtected) {
    // force new term to continue to be protected and see if the mappings would
    // be equal
    activeCtx["protected"][term] = true;
    mapping["protected"] = true;

    if (!_deepCompare(previousMapping, mapping)) {
      var protectedMode = options && options.protectedMode || 'error';

      if (protectedMode === 'error') {
        throw new JsonLdError('Invalid JSON-LD syntax; tried to redefine a protected term.', 'jsonld.SyntaxError', {
          code: 'protected term redefinition',
          context: localCtx,
          term: term
        });
      } else if (protectedMode === 'warn') {
        // FIXME: remove logging and use a handler
        console.warn('WARNING: protected term redefinition', {
          term: term
        });
        return;
      }

      throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {
        code: 'invalid protected mode',
        context: localCtx,
        term: term,
        protectedMode: protectedMode
      });
    }
  }
};
/**
 * Expands a string to a full IRI. The string may be a term, a prefix, a
 * relative IRI, or an absolute IRI. The associated absolute IRI will be
 * returned.
 *
 * @param activeCtx the current active context.
 * @param value the string to expand.
 * @param relativeTo options for how to resolve relative IRIs:
 *          base: true to resolve against the base IRI, false not to.
 *          vocab: true to concatenate after @vocab, false not to.
 * @param {Object} [options] - processing options.
 *
 * @return the expanded value.
 */


api.expandIri = function (activeCtx, value, relativeTo, options) {
  return _expandIri(activeCtx, value, relativeTo, undefined, undefined, options);
};
/**
 * Expands a string to a full IRI. The string may be a term, a prefix, a
 * relative IRI, or an absolute IRI. The associated absolute IRI will be
 * returned.
 *
 * @param activeCtx the current active context.
 * @param value the string to expand.
 * @param relativeTo options for how to resolve relative IRIs:
 *          base: true to resolve against the base IRI, false not to.
 *          vocab: true to concatenate after @vocab, false not to.
 * @param localCtx the local context being processed (only given if called
 *          during context processing).
 * @param defined a map for tracking cycles in context definitions (only given
 *          if called during context processing).
 * @param {Object} [options] - processing options.
 *
 * @return the expanded value.
 */


function _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {
  // already expanded
  if (value === null || !_isString(value) || api.isKeyword(value)) {
    return value;
  } // ignore non-keyword things that look like a keyword


  if (value.match(KEYWORD_PATTERN)) {
    return null;
  } // define term dependency if not defined


  if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {
    api.createTermDefinition({
      activeCtx: activeCtx,
      localCtx: localCtx,
      term: value,
      defined: defined,
      options: options
    });
  }

  relativeTo = relativeTo || {};

  if (relativeTo.vocab) {
    var mapping = activeCtx.mappings.get(value); // value is explicitly ignored with a null mapping

    if (mapping === null) {
      return null;
    }

    if (_isObject(mapping) && '@id' in mapping) {
      // value is a term
      return mapping['@id'];
    }
  } // split value into prefix:suffix


  var colon = value.indexOf(':');

  if (colon > 0) {
    var prefix = value.substr(0, colon);
    var suffix = value.substr(colon + 1); // do not expand blank nodes (prefix of '_') or already-absolute
    // IRIs (suffix of '//')

    if (prefix === '_' || suffix.indexOf('//') === 0) {
      return value;
    } // prefix dependency not defined, define it


    if (localCtx && localCtx.hasOwnProperty(prefix)) {
      api.createTermDefinition({
        activeCtx: activeCtx,
        localCtx: localCtx,
        term: prefix,
        defined: defined,
        options: options
      });
    } // use mapping if prefix is defined


    var _mapping = activeCtx.mappings.get(prefix);

    if (_mapping && _mapping._prefix) {
      return _mapping['@id'] + suffix;
    } // already absolute IRI


    if (_isAbsoluteIri(value)) {
      return value;
    }
  } // prepend vocab


  if (relativeTo.vocab && '@vocab' in activeCtx) {
    return activeCtx['@vocab'] + value;
  } // prepend base


  if (relativeTo.base && '@base' in activeCtx) {
    if (activeCtx['@base']) {
      // The null case preserves value as potentially relative
      return prependBase(prependBase(options.base, activeCtx['@base']), value);
    }
  } else if (relativeTo.base) {
    return prependBase(options.base, value);
  }

  return value;
}
/**
 * Gets the initial context.
 *
 * @param options the options to use:
 *          [base] the document base IRI.
 *
 * @return the initial context.
 */


api.getInitialContext = function (options) {
  var key = JSON.stringify({
    processingMode: options.processingMode
  });
  var cached = INITIAL_CONTEXT_CACHE.get(key);

  if (cached) {
    return cached;
  }

  var initialContext = {
    processingMode: options.processingMode,
    mappings: new Map(),
    inverse: null,
    getInverse: _createInverseContext,
    clone: _cloneActiveContext,
    revertToPreviousContext: _revertToPreviousContext,
    "protected": {}
  }; // TODO: consider using LRU cache instead

  if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {
    // clear whole cache -- assumes scenario where the cache fills means
    // the cache isn't being used very efficiently anyway
    INITIAL_CONTEXT_CACHE.clear();
  }

  INITIAL_CONTEXT_CACHE.set(key, initialContext);
  return initialContext;
  /**
   * Generates an inverse context for use in the compaction algorithm, if
   * not already generated for the given active context.
   *
   * @return the inverse context.
   */

  function _createInverseContext() {
    var activeCtx = this; // lazily create inverse

    if (activeCtx.inverse) {
      return activeCtx.inverse;
    }

    var inverse = activeCtx.inverse = {}; // variables for building fast CURIE map

    var fastCurieMap = activeCtx.fastCurieMap = {};
    var irisToTerms = {}; // handle default language

    var defaultLanguage = (activeCtx['@language'] || '@none').toLowerCase(); // handle default direction

    var defaultDirection = activeCtx['@direction']; // create term selections for each mapping in the context, ordered by
    // shortest and then lexicographically least

    var mappings = activeCtx.mappings;
    var terms = (0, _toConsumableArray2["default"])(mappings.keys()).sort(_compareShortestLeast);

    var _iterator2 = _createForOfIteratorHelper(terms),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var term = _step2.value;
        var mapping = mappings.get(term);

        if (mapping === null) {
          continue;
        }

        var container = mapping['@container'] || '@none';
        container = [].concat(container).sort().join('');

        if (mapping['@id'] === null) {
          continue;
        } // iterate over every IRI in the mapping


        var ids = _asArray(mapping['@id']);

        var _iterator3 = _createForOfIteratorHelper(ids),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var iri = _step3.value;
            var entry = inverse[iri];
            var isKeyword = api.isKeyword(iri);

            if (!entry) {
              // initialize entry
              inverse[iri] = entry = {};

              if (!isKeyword && !mapping._termHasColon) {
                // init IRI to term map and fast CURIE prefixes
                irisToTerms[iri] = [term];
                var fastCurieEntry = {
                  iri: iri,
                  terms: irisToTerms[iri]
                };

                if (iri[0] in fastCurieMap) {
                  fastCurieMap[iri[0]].push(fastCurieEntry);
                } else {
                  fastCurieMap[iri[0]] = [fastCurieEntry];
                }
              }
            } else if (!isKeyword && !mapping._termHasColon) {
              // add IRI to term match
              irisToTerms[iri].push(term);
            } // add new entry


            if (!entry[container]) {
              entry[container] = {
                '@language': {},
                '@type': {},
                '@any': {}
              };
            }

            entry = entry[container];

            _addPreferredTerm(term, entry['@any'], '@none');

            if (mapping.reverse) {
              // term is preferred for values using @reverse
              _addPreferredTerm(term, entry['@type'], '@reverse');
            } else if (mapping['@type'] === '@none') {
              _addPreferredTerm(term, entry['@any'], '@none');

              _addPreferredTerm(term, entry['@language'], '@none');

              _addPreferredTerm(term, entry['@type'], '@none');
            } else if ('@type' in mapping) {
              // term is preferred for values using specific type
              _addPreferredTerm(term, entry['@type'], mapping['@type']);
            } else if ('@language' in mapping && '@direction' in mapping) {
              // term is preferred for values using specific language and direction
              var language = mapping['@language'];
              var direction = mapping['@direction'];

              if (language && direction) {
                _addPreferredTerm(term, entry['@language'], "".concat(language, "_").concat(direction).toLowerCase());
              } else if (language) {
                _addPreferredTerm(term, entry['@language'], language.toLowerCase());
              } else if (direction) {
                _addPreferredTerm(term, entry['@language'], "_".concat(direction));
              } else {
                _addPreferredTerm(term, entry['@language'], '@null');
              }
            } else if ('@language' in mapping) {
              _addPreferredTerm(term, entry['@language'], (mapping['@language'] || '@null').toLowerCase());
            } else if ('@direction' in mapping) {
              if (mapping['@direction']) {
                _addPreferredTerm(term, entry['@language'], "_".concat(mapping['@direction']));
              } else {
                _addPreferredTerm(term, entry['@language'], '@none');
              }
            } else if (defaultDirection) {
              _addPreferredTerm(term, entry['@language'], "_".concat(defaultDirection));

              _addPreferredTerm(term, entry['@language'], '@none');

              _addPreferredTerm(term, entry['@type'], '@none');
            } else {
              // add entries for no type and no language
              _addPreferredTerm(term, entry['@language'], defaultLanguage);

              _addPreferredTerm(term, entry['@language'], '@none');

              _addPreferredTerm(term, entry['@type'], '@none');
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } // build fast CURIE map

    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    for (var _key2 in fastCurieMap) {
      _buildIriMap(fastCurieMap, _key2, 1);
    }

    return inverse;
  }
  /**
   * Runs a recursive algorithm to build a lookup map for quickly finding
   * potential CURIEs.
   *
   * @param iriMap the map to build.
   * @param key the current key in the map to work on.
   * @param idx the index into the IRI to compare.
   */


  function _buildIriMap(iriMap, key, idx) {
    var entries = iriMap[key];
    var next = iriMap[key] = {};
    var iri;
    var letter;

    var _iterator4 = _createForOfIteratorHelper(entries),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var entry = _step4.value;
        iri = entry.iri;

        if (idx >= iri.length) {
          letter = '';
        } else {
          letter = iri[idx];
        }

        if (letter in next) {
          next[letter].push(entry);
        } else {
          next[letter] = [entry];
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    for (var _key3 in next) {
      if (_key3 === '') {
        continue;
      }

      _buildIriMap(next, _key3, idx + 1);
    }
  }
  /**
   * Adds the term for the given entry if not already added.
   *
   * @param term the term to add.
   * @param entry the inverse context typeOrLanguage entry to add to.
   * @param typeOrLanguageValue the key in the entry to add to.
   */


  function _addPreferredTerm(term, entry, typeOrLanguageValue) {
    if (!entry.hasOwnProperty(typeOrLanguageValue)) {
      entry[typeOrLanguageValue] = term;
    }
  }
  /**
   * Clones an active context, creating a child active context.
   *
   * @return a clone (child) of the active context.
   */


  function _cloneActiveContext() {
    var child = {};
    child.mappings = util.clone(this.mappings);
    child.clone = this.clone;
    child.inverse = null;
    child.getInverse = this.getInverse;
    child["protected"] = util.clone(this["protected"]);

    if (this.previousContext) {
      child.previousContext = this.previousContext.clone();
    }

    child.revertToPreviousContext = this.revertToPreviousContext;

    if ('@base' in this) {
      child['@base'] = this['@base'];
    }

    if ('@language' in this) {
      child['@language'] = this['@language'];
    }

    if ('@vocab' in this) {
      child['@vocab'] = this['@vocab'];
    }

    return child;
  }
  /**
   * Reverts any type-scoped context in this active context to the previous
   * context.
   */


  function _revertToPreviousContext() {
    if (!this.previousContext) {
      return this;
    }

    return this.previousContext.clone();
  }
};
/**
 * Gets the value for the given active context key and type, null if none is
 * set or undefined if none is set and type is '@context'.
 *
 * @param ctx the active context.
 * @param key the context key.
 * @param [type] the type of value to get (eg: '@id', '@type'), if not
 *          specified gets the entire entry for a key, null if not found.
 *
 * @return the value, null, or undefined.
 */


api.getContextValue = function (ctx, key, type) {
  // invalid key
  if (key === null) {
    if (type === '@context') {
      return undefined;
    }

    return null;
  } // get specific entry information


  if (ctx.mappings.has(key)) {
    var entry = ctx.mappings.get(key);

    if (_isUndefined(type)) {
      // return whole entry
      return entry;
    }

    if (entry.hasOwnProperty(type)) {
      // return entry value for type
      return entry[type];
    }
  } // get default language


  if (type === '@language' && type in ctx) {
    return ctx[type];
  } // get default direction


  if (type === '@direction' && type in ctx) {
    return ctx[type];
  }

  if (type === '@context') {
    return undefined;
  }

  return null;
};
/**
 * Processing Mode check.
 *
 * @param activeCtx the current active context.
 * @param version the string or numeric version to check.
 *
 * @return boolean.
 */


api.processingMode = function (activeCtx, version) {
  if (version.toString() >= '1.1') {
    return !activeCtx.processingMode || activeCtx.processingMode >= 'json-ld-' + version.toString();
  } else {
    return activeCtx.processingMode === 'json-ld-1.0';
  }
};
/**
 * Returns whether or not the given value is a keyword.
 *
 * @param v the value to check.
 *
 * @return true if the value is a keyword, false if not.
 */


api.isKeyword = function (v) {
  if (!_isString(v) || v[0] !== '@') {
    return false;
  }

  switch (v) {
    case '@base':
    case '@container':
    case '@context':
    case '@default':
    case '@direction':
    case '@embed':
    case '@explicit':
    case '@graph':
    case '@id':
    case '@included':
    case '@index':
    case '@json':
    case '@language':
    case '@list':
    case '@nest':
    case '@none':
    case '@omitDefault':
    case '@prefix':
    case '@preserve':
    case '@protected':
    case '@requireAll':
    case '@reverse':
    case '@set':
    case '@type':
    case '@value':
    case '@version':
    case '@vocab':
      return true;
  }

  return false;
};

function _deepCompare(x1, x2) {
  // compare `null` or primitive types directly
  if (!(x1 && (0, _typeof2["default"])(x1) === 'object') || !(x2 && (0, _typeof2["default"])(x2) === 'object')) {
    return x1 === x2;
  } // x1 and x2 are objects (also potentially arrays)


  var x1Array = Array.isArray(x1);

  if (x1Array !== Array.isArray(x2)) {
    return false;
  }

  if (x1Array) {
    if (x1.length !== x2.length) {
      return false;
    }

    for (var i = 0; i < x1.length; ++i) {
      if (!_deepCompare(x1[i], x2[i])) {
        return false;
      }
    }

    return true;
  } // x1 and x2 are non-array objects


  var k1s = Object.keys(x1);
  var k2s = Object.keys(x2);

  if (k1s.length !== k2s.length) {
    return false;
  }

  for (var k1 in x1) {
    var v1 = x1[k1];
    var v2 = x2[k1]; // special case: `@container` can be in any order

    if (k1 === '@container') {
      if (Array.isArray(v1) && Array.isArray(v2)) {
        v1 = v1.slice().sort();
        v2 = v2.slice().sort();
      }
    }

    if (!_deepCompare(v1, v2)) {
      return false;
    }
  }

  return true;
}

},{"./JsonLdError":91,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/toConsumableArray":26,"@babel/runtime/helpers/typeof":27,"@babel/runtime/regenerator":30}],100:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _require = require('../util'),
    parseLinkHeader = _require.parseLinkHeader,
    buildHeaders = _require.buildHeaders;

var _require2 = require('../constants'),
    LINK_HEADER_CONTEXT = _require2.LINK_HEADER_CONTEXT;

var JsonLdError = require('../JsonLdError');

var RequestQueue = require('../RequestQueue');

var _require3 = require('../url'),
    prependBase = _require3.prependBase;
/**
 * Creates a built-in node document loader.
 *
 * @param options the options to use:
 *          secure: require all URLs to use HTTPS.
 *          strictSSL: true to require SSL certificates to be valid,
 *            false not to (default: true).
 *          maxRedirects: the maximum number of redirects to permit, none by
 *            default.
 *          request: the object which will make the request, default is
 *            provided by `https://www.npmjs.com/package/request`.
 *          headers: an object (map) of headers which will be passed as request
 *            headers for the requested document. Accept is not allowed.
 *
 * @return the node document loader.
 */


module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    strictSSL: true,
    maxRedirects: -1,
    headers: {}
  },
      secure = _ref.secure,
      _ref$strictSSL = _ref.strictSSL,
      strictSSL = _ref$strictSSL === void 0 ? true : _ref$strictSSL,
      _ref$maxRedirects = _ref.maxRedirects,
      maxRedirects = _ref$maxRedirects === void 0 ? -1 : _ref$maxRedirects,
      request = _ref.request,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers;

  headers = buildHeaders(headers); // TODO: use `axios`

  request = request || require('request');

  var http = require('http');

  var queue = new RequestQueue();
  return queue.wrapLoader(function (url) {
    return loadDocument(url, []);
  });

  function loadDocument(_x, _x2) {
    return _loadDocument.apply(this, arguments);
  }

  function _loadDocument() {
    _loadDocument = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url, redirects) {
      var doc, result, alternate, _result, res, body, statusText, linkHeaders, linkedContext;

      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0)) {
                _context.next = 2;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              });

            case 2:
              if (!(secure && url.indexOf('https') !== 0)) {
                _context.next = 4;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\'s scheme is not "https".', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              });

            case 4:
              // TODO: disable cache until HTTP caching implemented
              doc = null; //cache.get(url);

              if (!(doc !== null)) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", doc);

            case 7:
              alternate = null;
              _context.prev = 8;
              _context.next = 11;
              return _request(request, {
                url: url,
                headers: headers,
                strictSSL: strictSSL,
                followRedirect: false
              });

            case 11:
              result = _context.sent;
              _context.next = 17;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](8);
              throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                url: url,
                cause: _context.t0
              });

            case 17:
              _result = result, res = _result.res, body = _result.body;
              doc = {
                contextUrl: null,
                documentUrl: url,
                document: body || null
              }; // handle error

              statusText = http.STATUS_CODES[res.statusCode];

              if (!(res.statusCode >= 400)) {
                _context.next = 22;
                break;
              }

              throw new JsonLdError("URL \"".concat(url, "\" could not be dereferenced: ").concat(statusText), 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url,
                httpStatusCode: res.statusCode
              });

            case 22:
              if (!(res.headers.link && res.headers['content-type'] !== 'application/ld+json')) {
                _context.next = 30;
                break;
              }

              // only 1 related link header permitted
              linkHeaders = parseLinkHeader(res.headers.link);
              linkedContext = linkHeaders[LINK_HEADER_CONTEXT];

              if (!Array.isArray(linkedContext)) {
                _context.next = 27;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', {
                code: 'multiple context link headers',
                url: url
              });

            case 27:
              if (linkedContext) {
                doc.contextUrl = linkedContext.target;
              } // "alternate" link header is a redirect


              alternate = linkHeaders['alternate'];

              if (alternate && alternate.type == 'application/ld+json' && !(res.headers['content-type'] || '').match(/^application\/(\w*\+)?json$/)) {
                res.headers.location = prependBase(url, alternate.target);
              }

            case 30:
              if (!((alternate || res.statusCode >= 300 && res.statusCode < 400) && res.headers.location)) {
                _context.next = 37;
                break;
              }

              if (!(redirects.length === maxRedirects)) {
                _context.next = 33;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {
                code: 'loading document failed',
                url: url,
                httpStatusCode: res.statusCode,
                redirects: redirects
              });

            case 33:
              if (!(redirects.indexOf(url) !== -1)) {
                _context.next = 35;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {
                code: 'recursive context inclusion',
                url: url,
                httpStatusCode: res.statusCode,
                redirects: redirects
              });

            case 35:
              redirects.push(url);
              return _context.abrupt("return", loadDocument(res.headers.location, redirects));

            case 37:
              // cache for each redirected URL
              redirects.push(url); // TODO: disable cache until HTTP caching implemented

              /*
              for(let i = 0; i < redirects.length; ++i) {
                cache.set(
                  redirects[i],
                  {contextUrl: null, documentUrl: redirects[i], document: body});
              }
              */

              return _context.abrupt("return", doc);

            case 39:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[8, 14]]);
    }));
    return _loadDocument.apply(this, arguments);
  }
};

function _request(request, options) {
  return new Promise(function (resolve, reject) {
    request(options, function (err, res, body) {
      if (err) {
        reject(err);
      } else {
        resolve({
          res: res,
          body: body
        });
      }
    });
  });
}

},{"../JsonLdError":91,"../RequestQueue":95,"../constants":98,"../url":111,"../util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30,"http":58,"request":58}],101:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _require = require('../util'),
    parseLinkHeader = _require.parseLinkHeader,
    buildHeaders = _require.buildHeaders;

var _require2 = require('../constants'),
    LINK_HEADER_CONTEXT = _require2.LINK_HEADER_CONTEXT;

var JsonLdError = require('../JsonLdError');

var RequestQueue = require('../RequestQueue');

var _require3 = require('../url'),
    prependBase = _require3.prependBase;

var REGEX_LINK_HEADER = /(^|(\r\n))link:/i;
/**
 * Creates a built-in XMLHttpRequest document loader.
 *
 * @param options the options to use:
 *          secure: require all URLs to use HTTPS.
 *          headers: an object (map) of headers which will be passed as request
 *            headers for the requested document. Accept is not allowed.
 *          [xhr]: the XMLHttpRequest API to use.
 *
 * @return the XMLHttpRequest document loader.
 */

module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    headers: {}
  },
      secure = _ref.secure,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      xhr = _ref.xhr;

  headers = buildHeaders(headers);
  var queue = new RequestQueue();
  return queue.wrapLoader(loader);

  function loader(_x) {
    return _loader.apply(this, arguments);
  }

  function _loader() {
    _loader = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url) {
      var req, doc, alternate, contentType, linkHeader, linkHeaders, linkedContext;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0)) {
                _context.next = 2;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              });

            case 2:
              if (!(secure && url.indexOf('https') !== 0)) {
                _context.next = 4;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\'s scheme is not "https".', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              });

            case 4:
              _context.prev = 4;
              _context.next = 7;
              return _get(xhr, url, headers);

            case 7:
              req = _context.sent;
              _context.next = 13;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](4);
              throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                url: url,
                cause: _context.t0
              });

            case 13:
              if (!(req.status >= 400)) {
                _context.next = 15;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced: ' + req.statusText, 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                url: url,
                httpStatusCode: req.status
              });

            case 15:
              doc = {
                contextUrl: null,
                documentUrl: url,
                document: req.response
              };
              alternate = null; // handle Link Header (avoid unsafe header warning by existence testing)

              contentType = req.getResponseHeader('Content-Type');

              if (REGEX_LINK_HEADER.test(req.getAllResponseHeaders())) {
                linkHeader = req.getResponseHeader('Link');
              }

              if (!(linkHeader && contentType !== 'application/ld+json')) {
                _context.next = 30;
                break;
              }

              // only 1 related link header permitted
              linkHeaders = parseLinkHeader(linkHeader);
              linkedContext = linkHeaders[LINK_HEADER_CONTEXT];

              if (!Array.isArray(linkedContext)) {
                _context.next = 24;
                break;
              }

              throw new JsonLdError('URL could not be dereferenced, it has more than one ' + 'associated HTTP Link Header.', 'jsonld.InvalidUrl', {
                code: 'multiple context link headers',
                url: url
              });

            case 24:
              if (linkedContext) {
                doc.contextUrl = linkedContext.target;
              } // "alternate" link header is a redirect


              alternate = linkHeaders['alternate'];

              if (!(alternate && alternate.type == 'application/ld+json' && !(contentType || '').match(/^application\/(\w*\+)?json$/))) {
                _context.next = 30;
                break;
              }

              _context.next = 29;
              return loader(prependBase(url, alternate.target));

            case 29:
              doc = _context.sent;

            case 30:
              return _context.abrupt("return", doc);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[4, 10]]);
    }));
    return _loader.apply(this, arguments);
  }
};

function _get(xhr, url, headers) {
  xhr = xhr || XMLHttpRequest;
  var req = new xhr();
  return new Promise(function (resolve, reject) {
    req.onload = function () {
      return resolve(req);
    };

    req.onerror = function (err) {
      return reject(err);
    };

    req.open('GET', url, true);

    for (var k in headers) {
      req.setRequestHeader(k, headers[k]);
    }

    req.send();
  });
}

},{"../JsonLdError":91,"../RequestQueue":95,"../constants":98,"../url":111,"../util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30}],102:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var JsonLdError = require('./JsonLdError');

var _require = require('./types'),
    _isArray = _require.isArray,
    _isObject = _require.isObject,
    _isEmptyObject = _require.isEmptyObject,
    _isString = _require.isString,
    _isUndefined = _require.isUndefined;

var _require2 = require('./graphTypes'),
    _isList = _require2.isList,
    _isValue = _require2.isValue,
    _isGraph = _require2.isGraph,
    _isSubject = _require2.isSubject;

var _require3 = require('./context'),
    _expandIri = _require3.expandIri,
    _getContextValue = _require3.getContextValue,
    _isKeyword = _require3.isKeyword,
    _processContext = _require3.process,
    _processingMode = _require3.processingMode;

var _require4 = require('./url'),
    _isAbsoluteIri = _require4.isAbsolute;

var _require5 = require('./util'),
    _addValue = _require5.addValue,
    _asArray = _require5.asArray,
    _getValues = _require5.getValues,
    _validateTypeValue = _require5.validateTypeValue;

var api = {};
module.exports = api;
var REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
/**
 * Recursively expands an element using the given context. Any context in
 * the element will be removed. All context URLs must have been retrieved
 * before calling this method.
 *
 * @param activeCtx the context to use.
 * @param activeProperty the property for the element, null for none.
 * @param element the element to expand.
 * @param options the expansion options.
 * @param insideList true if the element is a list, false if not.
 * @param insideIndex true if the element is inside an index container,
 *          false if not.
 * @param typeScopedContext an optional type-scoped active context for
 *          expanding values of nodes that were expressed according to
 *          a type-scoped context.
 * @param expansionMap(info) a function that can be used to custom map
 *          unmappable values (or to throw an error when they are detected);
 *          if this function returns `undefined` then the default behavior
 *          will be used.
 *
 * @return a Promise that resolves to the expanded value.
 */

api.expand = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref) {
    var activeCtx, _ref$activeProperty, activeProperty, element, _ref$options, options, _ref$insideList, insideList, _ref$insideIndex, insideIndex, _ref$typeScopedContex, typeScopedContext, _ref$expansionMap, expansionMap, mapped, _rval, container, i, e, expandedActiveProperty, propertyScopedCtx, keys, mustRevert, _iterator, _step, key, expandedProperty, typeKey, _iterator2, _step2, _key, _expandedProperty, value, _types, _iterator3, _step3, type, ctx, rval, count, validCount, values, types, _mapped, _mapped2, _mapped3;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            activeCtx = _ref.activeCtx, _ref$activeProperty = _ref.activeProperty, activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty, element = _ref.element, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, _ref$insideList = _ref.insideList, insideList = _ref$insideList === void 0 ? false : _ref$insideList, _ref$insideIndex = _ref.insideIndex, insideIndex = _ref$insideIndex === void 0 ? false : _ref$insideIndex, _ref$typeScopedContex = _ref.typeScopedContext, typeScopedContext = _ref$typeScopedContex === void 0 ? null : _ref$typeScopedContex, _ref$expansionMap = _ref.expansionMap, expansionMap = _ref$expansionMap === void 0 ? function () {
              return undefined;
            } : _ref$expansionMap;

            if (!(element === null || element === undefined)) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return", null);

          case 3:
            // disable framing if activeProperty is @default
            if (activeProperty === '@default') {
              options = Object.assign({}, options, {
                isFrame: false
              });
            }

            if (!(!_isArray(element) && !_isObject(element))) {
              _context.next = 13;
              break;
            }

            if (!(!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, {
              vocab: true
            }, options) === '@graph'))) {
              _context.next = 12;
              break;
            }

            _context.next = 8;
            return expansionMap({
              unmappedValue: element,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              options: options,
              insideList: insideList
            });

          case 8:
            mapped = _context.sent;

            if (!(mapped === undefined)) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("return", null);

          case 11:
            return _context.abrupt("return", mapped);

          case 12:
            return _context.abrupt("return", _expandValue({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              value: element,
              options: options
            }));

          case 13:
            if (!_isArray(element)) {
              _context.next = 34;
              break;
            }

            _rval = [];
            container = _getContextValue(activeCtx, activeProperty, '@container') || [];
            insideList = insideList || container.includes('@list');
            i = 0;

          case 18:
            if (!(i < element.length)) {
              _context.next = 33;
              break;
            }

            _context.next = 21;
            return api.expand({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element[i],
              options: options,
              expansionMap: expansionMap,
              insideIndex: insideIndex,
              typeScopedContext: typeScopedContext
            });

          case 21:
            e = _context.sent;

            if (insideList && _isArray(e)) {
              e = {
                '@list': e
              };
            }

            if (!(e === null)) {
              _context.next = 29;
              break;
            }

            _context.next = 26;
            return expansionMap({
              unmappedValue: element[i],
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              parent: element,
              index: i,
              options: options,
              expandedParent: _rval,
              insideList: insideList
            });

          case 26:
            e = _context.sent;

            if (!(e === undefined)) {
              _context.next = 29;
              break;
            }

            return _context.abrupt("continue", 30);

          case 29:
            if (_isArray(e)) {
              _rval = _rval.concat(e);
            } else {
              _rval.push(e);
            }

          case 30:
            ++i;
            _context.next = 18;
            break;

          case 33:
            return _context.abrupt("return", _rval);

          case 34:
            // recursively expand object:
            // first, expand the active property
            expandedActiveProperty = _expandIri(activeCtx, activeProperty, {
              vocab: true
            }, options); // Get any property-scoped context for activeProperty

            propertyScopedCtx = _getContextValue(activeCtx, activeProperty, '@context'); // second, determine if any type-scoped context should be reverted; it
            // should only be reverted when the following are all true:
            // 1. `element` is not a value or subject reference
            // 2. `insideIndex` is false

            typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);
            keys = Object.keys(element).sort();
            mustRevert = !insideIndex;

            if (!(mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes('@context'))) {
              _context.next = 63;
              break;
            }

            _iterator = _createForOfIteratorHelper(keys);
            _context.prev = 41;

            _iterator.s();

          case 43:
            if ((_step = _iterator.n()).done) {
              _context.next = 55;
              break;
            }

            key = _step.value;
            expandedProperty = _expandIri(typeScopedContext, key, {
              vocab: true
            }, options);

            if (!(expandedProperty === '@value')) {
              _context.next = 50;
              break;
            }

            // value found, ensure type-scoped context is used to expand it
            mustRevert = false;
            activeCtx = typeScopedContext;
            return _context.abrupt("break", 55);

          case 50:
            if (!(expandedProperty === '@id' && keys.length === 1)) {
              _context.next = 53;
              break;
            }

            // subject reference found, do not revert
            mustRevert = false;
            return _context.abrupt("break", 55);

          case 53:
            _context.next = 43;
            break;

          case 55:
            _context.next = 60;
            break;

          case 57:
            _context.prev = 57;
            _context.t0 = _context["catch"](41);

            _iterator.e(_context.t0);

          case 60:
            _context.prev = 60;

            _iterator.f();

            return _context.finish(60);

          case 63:
            if (mustRevert) {
              // revert type scoped context
              activeCtx = activeCtx.revertToPreviousContext();
            } // apply property-scoped context after reverting term-scoped context


            if (_isUndefined(propertyScopedCtx)) {
              _context.next = 68;
              break;
            }

            _context.next = 67;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: propertyScopedCtx,
              propagate: true,
              overrideProtected: true,
              options: options
            });

          case 67:
            activeCtx = _context.sent;

          case 68:
            if (!('@context' in element)) {
              _context.next = 72;
              break;
            }

            _context.next = 71;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: element['@context'],
              options: options
            });

          case 71:
            activeCtx = _context.sent;

          case 72:
            // set the type-scoped context to the context on input, for use later
            typeScopedContext = activeCtx; // Remember the first key found expanding to @type

            typeKey = null; // look for scoped contexts on `@type`

            _iterator2 = _createForOfIteratorHelper(keys);
            _context.prev = 75;

            _iterator2.s();

          case 77:
            if ((_step2 = _iterator2.n()).done) {
              _context.next = 106;
              break;
            }

            _key = _step2.value;
            _expandedProperty = _expandIri(activeCtx, _key, {
              vocab: true
            }, options);

            if (!(_expandedProperty === '@type')) {
              _context.next = 104;
              break;
            }

            // set scoped contexts from @type
            // avoid sorting if possible
            typeKey = typeKey || _key;
            value = element[_key];
            _types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];
            _iterator3 = _createForOfIteratorHelper(_types);
            _context.prev = 85;

            _iterator3.s();

          case 87:
            if ((_step3 = _iterator3.n()).done) {
              _context.next = 96;
              break;
            }

            type = _step3.value;
            ctx = _getContextValue(typeScopedContext, type, '@context');

            if (_isUndefined(ctx)) {
              _context.next = 94;
              break;
            }

            _context.next = 93;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: ctx,
              options: options,
              propagate: false
            });

          case 93:
            activeCtx = _context.sent;

          case 94:
            _context.next = 87;
            break;

          case 96:
            _context.next = 101;
            break;

          case 98:
            _context.prev = 98;
            _context.t1 = _context["catch"](85);

            _iterator3.e(_context.t1);

          case 101:
            _context.prev = 101;

            _iterator3.f();

            return _context.finish(101);

          case 104:
            _context.next = 77;
            break;

          case 106:
            _context.next = 111;
            break;

          case 108:
            _context.prev = 108;
            _context.t2 = _context["catch"](75);

            _iterator2.e(_context.t2);

          case 111:
            _context.prev = 111;

            _iterator2.f();

            return _context.finish(111);

          case 114:
            // process each key and value in element, ignoring @nest content
            rval = {};
            _context.next = 117;
            return _expandObject({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              expandedActiveProperty: expandedActiveProperty,
              element: element,
              expandedParent: rval,
              options: options,
              insideList: insideList,
              typeKey: typeKey,
              typeScopedContext: typeScopedContext,
              expansionMap: expansionMap
            });

          case 117:
            // get property count on expanded output
            keys = Object.keys(rval);
            count = keys.length;

            if (!('@value' in rval)) {
              _context.next = 149;
              break;
            }

            if (!('@type' in rval && ('@language' in rval || '@direction' in rval))) {
              _context.next = 122;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may not ' + 'contain both "@type" and either "@language" or "@direction".', 'jsonld.SyntaxError', {
              code: 'invalid value object',
              element: rval
            });

          case 122:
            validCount = count - 1;

            if ('@type' in rval) {
              validCount -= 1;
            }

            if ('@index' in rval) {
              validCount -= 1;
            }

            if ('@language' in rval) {
              validCount -= 1;
            }

            if ('@direction' in rval) {
              validCount -= 1;
            }

            if (!(validCount !== 0)) {
              _context.next = 129;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may only ' + 'have an "@index" property and either "@type" ' + 'or either or both "@language" or "@direction".', 'jsonld.SyntaxError', {
              code: 'invalid value object',
              element: rval
            });

          case 129:
            values = rval['@value'] === null ? [] : _asArray(rval['@value']);
            types = _getValues(rval, '@type'); // drop null @values unless custom mapped

            if (!(_processingMode(activeCtx, 1.1) && types.includes('@json') && types.length === 1)) {
              _context.next = 134;
              break;
            }

            _context.next = 147;
            break;

          case 134:
            if (!(values.length === 0)) {
              _context.next = 141;
              break;
            }

            _context.next = 137;
            return expansionMap({
              unmappedValue: rval,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element,
              options: options,
              insideList: insideList
            });

          case 137:
            _mapped = _context.sent;

            if (_mapped !== undefined) {
              rval = _mapped;
            } else {
              rval = null;
            }

            _context.next = 147;
            break;

          case 141:
            if (!(!values.every(function (v) {
              return _isString(v) || _isEmptyObject(v);
            }) && '@language' in rval)) {
              _context.next = 145;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; only strings may be language-tagged.', 'jsonld.SyntaxError', {
              code: 'invalid language-tagged value',
              element: rval
            });

          case 145:
            if (types.every(function (t) {
              return _isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) || _isEmptyObject(t);
            })) {
              _context.next = 147;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" and "@type" ' + 'must have an absolute IRI for the value of "@type".', 'jsonld.SyntaxError', {
              code: 'invalid typed value',
              element: rval
            });

          case 147:
            _context.next = 164;
            break;

          case 149:
            if (!('@type' in rval && !_isArray(rval['@type']))) {
              _context.next = 153;
              break;
            }

            // convert @type to an array
            rval['@type'] = [rval['@type']];
            _context.next = 164;
            break;

          case 153:
            if (!('@set' in rval || '@list' in rval)) {
              _context.next = 159;
              break;
            }

            if (!(count > 1 && !(count === 2 && '@index' in rval))) {
              _context.next = 156;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property "@set" ' + 'or "@list", then it can have at most one other property that is ' + '"@index".', 'jsonld.SyntaxError', {
              code: 'invalid set or list object',
              element: rval
            });

          case 156:
            // optimize away @set
            if ('@set' in rval) {
              rval = rval['@set'];
              keys = Object.keys(rval);
              count = keys.length;
            }

            _context.next = 164;
            break;

          case 159:
            if (!(count === 1 && '@language' in rval)) {
              _context.next = 164;
              break;
            }

            _context.next = 162;
            return expansionMap(rval, {
              unmappedValue: rval,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element,
              options: options,
              insideList: insideList
            });

          case 162:
            _mapped2 = _context.sent;

            if (_mapped2 !== undefined) {
              rval = _mapped2;
            } else {
              rval = null;
            }

          case 164:
            if (!(_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === '@graph'))) {
              _context.next = 170;
              break;
            }

            if (!(count === 0 || '@value' in rval || '@list' in rval || count === 1 && '@id' in rval)) {
              _context.next = 170;
              break;
            }

            _context.next = 168;
            return expansionMap({
              unmappedValue: rval,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: element,
              options: options,
              insideList: insideList
            });

          case 168:
            _mapped3 = _context.sent;

            if (_mapped3 !== undefined) {
              rval = _mapped3;
            } else {
              rval = null;
            }

          case 170:
            return _context.abrupt("return", rval);

          case 171:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[41, 57, 60, 63], [75, 108, 111, 114], [85, 98, 101, 104]]);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Expand each key and value of element adding to result
 *
 * @param activeCtx the context to use.
 * @param activeProperty the property for the element.
 * @param expandedActiveProperty the expansion of activeProperty
 * @param element the element to expand.
 * @param expandedParent the expanded result into which to add values.
 * @param options the expansion options.
 * @param insideList true if the element is a list, false if not.
 * @param typeKey first key found expanding to @type.
 * @param typeScopedContext the context before reverting.
 * @param expansionMap(info) a function that can be used to custom map
 *          unmappable values (or to throw an error when they are detected);
 *          if this function returns `undefined` then the default behavior
 *          will be used.
 */


function _expandObject(_x2) {
  return _expandObject2.apply(this, arguments);
}
/**
 * Expands the given value by using the coercion and keyword rules in the
 * given context.
 *
 * @param activeCtx the active context to use.
 * @param activeProperty the active property the value is associated with.
 * @param value the value to expand.
 * @param {Object} [options] - processing options.
 *
 * @return the expanded value.
 */


function _expandObject2() {
  _expandObject2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref3) {
    var activeCtx, activeProperty, expandedActiveProperty, element, expandedParent, _ref3$options, options, insideList, typeKey, typeScopedContext, expansionMap, keys, nests, unexpandedValue, isJsonType, _iterator6, _step6, _key2, value, expandedValue, expandedProperty, includedResult, _iterator8, _step8, lang, _iterator9, _step9, dir, property, reverseMap, _property, items, ii, item, termCtx, ctx, container, direction, asGraph, indexKey, propertyIndex, _asGraph, isList, nextActiveProperty, _reverseMap, _ii, _item, _i, _nests, key, nestedValues, _iterator7, _step7, nv;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            activeCtx = _ref3.activeCtx, activeProperty = _ref3.activeProperty, expandedActiveProperty = _ref3.expandedActiveProperty, element = _ref3.element, expandedParent = _ref3.expandedParent, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, insideList = _ref3.insideList, typeKey = _ref3.typeKey, typeScopedContext = _ref3.typeScopedContext, expansionMap = _ref3.expansionMap;
            keys = Object.keys(element).sort();
            nests = [];
            // Figure out if this is the type for a JSON literal
            isJsonType = element[typeKey] && _expandIri(activeCtx, _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey], {
              vocab: true
            }, options) === '@json';
            _iterator6 = _createForOfIteratorHelper(keys);
            _context2.prev = 5;

            _iterator6.s();

          case 7:
            if ((_step6 = _iterator6.n()).done) {
              _context2.next = 202;
              break;
            }

            _key2 = _step6.value;
            value = element[_key2];
            expandedValue = void 0; // skip @context

            if (!(_key2 === '@context')) {
              _context2.next = 13;
              break;
            }

            return _context2.abrupt("continue", 200);

          case 13:
            // expand property
            expandedProperty = _expandIri(activeCtx, _key2, {
              vocab: true
            }, options); // drop non-absolute IRI keys that aren't keywords unless custom mapped

            if (!(expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty)))) {
              _context2.next = 18;
              break;
            }

            // TODO: use `await` to support async
            expandedProperty = expansionMap({
              unmappedProperty: _key2,
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              parent: element,
              options: options,
              insideList: insideList,
              value: value,
              expandedParent: expandedParent
            });

            if (!(expandedProperty === undefined)) {
              _context2.next = 18;
              break;
            }

            return _context2.abrupt("continue", 200);

          case 18:
            if (!_isKeyword(expandedProperty)) {
              _context2.next = 23;
              break;
            }

            if (!(expandedActiveProperty === '@reverse')) {
              _context2.next = 21;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' + 'property.', 'jsonld.SyntaxError', {
              code: 'invalid reverse property map',
              value: value
            });

          case 21:
            if (!(expandedProperty in expandedParent && expandedProperty !== '@included' && expandedProperty !== '@type')) {
              _context2.next = 23;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; colliding keywords detected.', 'jsonld.SyntaxError', {
              code: 'colliding keywords',
              keyword: expandedProperty
            });

          case 23:
            if (!(expandedProperty === '@id')) {
              _context2.next = 40;
              break;
            }

            if (_isString(value)) {
              _context2.next = 38;
              break;
            }

            if (options.isFrame) {
              _context2.next = 27;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value must a string.', 'jsonld.SyntaxError', {
              code: 'invalid @id value',
              value: value
            });

          case 27:
            if (!_isObject(value)) {
              _context2.next = 32;
              break;
            }

            if (_isEmptyObject(value)) {
              _context2.next = 30;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {
              code: 'invalid @id value',
              value: value
            });

          case 30:
            _context2.next = 38;
            break;

          case 32:
            if (!_isArray(value)) {
              _context2.next = 37;
              break;
            }

            if (value.every(function (v) {
              return _isString(v);
            })) {
              _context2.next = 35;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {
              code: 'invalid @id value',
              value: value
            });

          case 35:
            _context2.next = 38;
            break;

          case 37:
            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {
              code: 'invalid @id value',
              value: value
            });

          case 38:
            _addValue(expandedParent, '@id', _asArray(value).map(function (v) {
              return _isString(v) ? _expandIri(activeCtx, v, {
                base: true
              }, options) : v;
            }), {
              propertyIsArray: options.isFrame
            });

            return _context2.abrupt("continue", 200);

          case 40:
            if (!(expandedProperty === '@type')) {
              _context2.next = 45;
              break;
            }

            // if framing, can be a default object, but need to expand
            // key to determine that
            if (_isObject(value)) {
              value = Object.fromEntries(Object.entries(value).map(function (_ref6) {
                var _ref7 = (0, _slicedToArray2["default"])(_ref6, 2),
                    k = _ref7[0],
                    v = _ref7[1];

                return [_expandIri(typeScopedContext, k, {
                  vocab: true
                }), _asArray(v).map(function (vv) {
                  return _expandIri(typeScopedContext, vv, {
                    base: true,
                    vocab: true
                  });
                })];
              }));
            }

            _validateTypeValue(value, options.isFrame);

            _addValue(expandedParent, '@type', _asArray(value).map(function (v) {
              return _isString(v) ? _expandIri(typeScopedContext, v, {
                base: true,
                vocab: true
              }, options) : v;
            }), {
              propertyIsArray: options.isFrame
            });

            return _context2.abrupt("continue", 200);

          case 45:
            if (!(expandedProperty === '@included' && _processingMode(activeCtx, 1.1))) {
              _context2.next = 55;
              break;
            }

            _context2.t0 = _asArray;
            _context2.next = 49;
            return api.expand({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: value,
              options: options,
              expansionMap: expansionMap
            });

          case 49:
            _context2.t1 = _context2.sent;
            includedResult = (0, _context2.t0)(_context2.t1);

            if (includedResult.every(function (v) {
              return _isSubject(v);
            })) {
              _context2.next = 53;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; ' + 'values of @included must expand to node objects.', 'jsonld.SyntaxError', {
              code: 'invalid @included value',
              value: value
            });

          case 53:
            _addValue(expandedParent, '@included', includedResult, {
              propertyIsArray: true
            });

            return _context2.abrupt("continue", 200);

          case 55:
            if (!(expandedProperty === '@graph' && !(_isObject(value) || _isArray(value)))) {
              _context2.next = 57;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@graph" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {
              code: 'invalid @graph value',
              value: value
            });

          case 57:
            if (!(expandedProperty === '@value')) {
              _context2.next = 61;
              break;
            }

            // capture value for later
            // "colliding keywords" check prevents this from being set twice
            unexpandedValue = value;

            if (isJsonType && _processingMode(activeCtx, 1.1)) {
              // no coercion to array, and retain all values
              expandedParent['@value'] = value;
            } else {
              _addValue(expandedParent, '@value', value, {
                propertyIsArray: options.isFrame
              });
            }

            return _context2.abrupt("continue", 200);

          case 61:
            if (!(expandedProperty === '@language')) {
              _context2.next = 71;
              break;
            }

            if (!(value === null)) {
              _context2.next = 64;
              break;
            }

            return _context2.abrupt("continue", 200);

          case 64:
            if (!(!_isString(value) && !options.isFrame)) {
              _context2.next = 66;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@language" value must be a string.', 'jsonld.SyntaxError', {
              code: 'invalid language-tagged string',
              value: value
            });

          case 66:
            // ensure language value is lowercase
            value = _asArray(value).map(function (v) {
              return _isString(v) ? v.toLowerCase() : v;
            }); // ensure language tag matches BCP47

            _iterator8 = _createForOfIteratorHelper(value);

            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                lang = _step8.value;

                if (_isString(lang) && !lang.match(REGEX_BCP47)) {
                  console.warn("@language must be valid BCP47: ".concat(lang));
                }
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }

            _addValue(expandedParent, '@language', value, {
              propertyIsArray: options.isFrame
            });

            return _context2.abrupt("continue", 200);

          case 71:
            if (!(expandedProperty === '@direction')) {
              _context2.next = 94;
              break;
            }

            if (!(!_isString(value) && !options.isFrame)) {
              _context2.next = 74;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@direction" value must be a string.', 'jsonld.SyntaxError', {
              code: 'invalid base direction',
              value: value
            });

          case 74:
            value = _asArray(value); // ensure direction is "ltr" or "rtl"

            _iterator9 = _createForOfIteratorHelper(value);
            _context2.prev = 76;

            _iterator9.s();

          case 78:
            if ((_step9 = _iterator9.n()).done) {
              _context2.next = 84;
              break;
            }

            dir = _step9.value;

            if (!(_isString(dir) && dir !== 'ltr' && dir !== 'rtl')) {
              _context2.next = 82;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".', 'jsonld.SyntaxError', {
              code: 'invalid base direction',
              value: value
            });

          case 82:
            _context2.next = 78;
            break;

          case 84:
            _context2.next = 89;
            break;

          case 86:
            _context2.prev = 86;
            _context2.t2 = _context2["catch"](76);

            _iterator9.e(_context2.t2);

          case 89:
            _context2.prev = 89;

            _iterator9.f();

            return _context2.finish(89);

          case 92:
            _addValue(expandedParent, '@direction', value, {
              propertyIsArray: options.isFrame
            });

            return _context2.abrupt("continue", 200);

          case 94:
            if (!(expandedProperty === '@index')) {
              _context2.next = 99;
              break;
            }

            if (_isString(value)) {
              _context2.next = 97;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@index" value must be a string.', 'jsonld.SyntaxError', {
              code: 'invalid @index value',
              value: value
            });

          case 97:
            _addValue(expandedParent, '@index', value);

            return _context2.abrupt("continue", 200);

          case 99:
            if (!(expandedProperty === '@reverse')) {
              _context2.next = 127;
              break;
            }

            if (_isObject(value)) {
              _context2.next = 102;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must be an object.', 'jsonld.SyntaxError', {
              code: 'invalid @reverse value',
              value: value
            });

          case 102:
            _context2.next = 104;
            return api.expand({
              activeCtx: activeCtx,
              activeProperty: '@reverse',
              element: value,
              options: options,
              expansionMap: expansionMap
            });

          case 104:
            expandedValue = _context2.sent;

            // properties double-reversed
            if ('@reverse' in expandedValue) {
              for (property in expandedValue['@reverse']) {
                _addValue(expandedParent, property, expandedValue['@reverse'][property], {
                  propertyIsArray: true
                });
              }
            } // FIXME: can this be merged with code below to simplify?
            // merge in all reversed properties


            reverseMap = expandedParent['@reverse'] || null;
            _context2.t3 = _regenerator["default"].keys(expandedValue);

          case 108:
            if ((_context2.t4 = _context2.t3()).done) {
              _context2.next = 126;
              break;
            }

            _property = _context2.t4.value;

            if (!(_property === '@reverse')) {
              _context2.next = 112;
              break;
            }

            return _context2.abrupt("continue", 108);

          case 112:
            if (reverseMap === null) {
              reverseMap = expandedParent['@reverse'] = {};
            }

            _addValue(reverseMap, _property, [], {
              propertyIsArray: true
            });

            items = expandedValue[_property];
            ii = 0;

          case 116:
            if (!(ii < items.length)) {
              _context2.next = 124;
              break;
            }

            item = items[ii];

            if (!(_isValue(item) || _isList(item))) {
              _context2.next = 120;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {
              code: 'invalid reverse property value',
              value: expandedValue
            });

          case 120:
            _addValue(reverseMap, _property, item, {
              propertyIsArray: true
            });

          case 121:
            ++ii;
            _context2.next = 116;
            break;

          case 124:
            _context2.next = 108;
            break;

          case 126:
            return _context2.abrupt("continue", 200);

          case 127:
            if (!(expandedProperty === '@nest')) {
              _context2.next = 130;
              break;
            }

            nests.push(_key2);
            return _context2.abrupt("continue", 200);

          case 130:
            // use potential scoped context for key
            termCtx = activeCtx;
            ctx = _getContextValue(activeCtx, _key2, '@context');

            if (_isUndefined(ctx)) {
              _context2.next = 136;
              break;
            }

            _context2.next = 135;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: ctx,
              propagate: true,
              overrideProtected: true,
              options: options
            });

          case 135:
            termCtx = _context2.sent;

          case 136:
            container = _getContextValue(termCtx, _key2, '@container') || [];

            if (!(container.includes('@language') && _isObject(value))) {
              _context2.next = 142;
              break;
            }

            direction = _getContextValue(termCtx, _key2, '@direction'); // handle language map container (skip if value is not an object)

            expandedValue = _expandLanguageMap(termCtx, value, direction, options);
            _context2.next = 180;
            break;

          case 142:
            if (!(container.includes('@index') && _isObject(value))) {
              _context2.next = 151;
              break;
            }

            // handle index container (skip if value is not an object)
            asGraph = container.includes('@graph');
            indexKey = _getContextValue(termCtx, _key2, '@index') || '@index';
            propertyIndex = indexKey !== '@index' && _expandIri(activeCtx, indexKey, {
              vocab: true
            }, options);
            _context2.next = 148;
            return _expandIndexMap({
              activeCtx: termCtx,
              options: options,
              activeProperty: _key2,
              value: value,
              expansionMap: expansionMap,
              asGraph: asGraph,
              indexKey: indexKey,
              propertyIndex: propertyIndex
            });

          case 148:
            expandedValue = _context2.sent;
            _context2.next = 180;
            break;

          case 151:
            if (!(container.includes('@id') && _isObject(value))) {
              _context2.next = 158;
              break;
            }

            // handle id container (skip if value is not an object)
            _asGraph = container.includes('@graph');
            _context2.next = 155;
            return _expandIndexMap({
              activeCtx: termCtx,
              options: options,
              activeProperty: _key2,
              value: value,
              expansionMap: expansionMap,
              asGraph: _asGraph,
              indexKey: '@id'
            });

          case 155:
            expandedValue = _context2.sent;
            _context2.next = 180;
            break;

          case 158:
            if (!(container.includes('@type') && _isObject(value))) {
              _context2.next = 164;
              break;
            }

            _context2.next = 161;
            return _expandIndexMap({
              // since container is `@type`, revert type scoped context when expanding
              activeCtx: termCtx.revertToPreviousContext(),
              options: options,
              activeProperty: _key2,
              value: value,
              expansionMap: expansionMap,
              asGraph: false,
              indexKey: '@type'
            });

          case 161:
            expandedValue = _context2.sent;
            _context2.next = 180;
            break;

          case 164:
            // recurse into @list or @set
            isList = expandedProperty === '@list';

            if (!(isList || expandedProperty === '@set')) {
              _context2.next = 173;
              break;
            }

            nextActiveProperty = activeProperty;

            if (isList && expandedActiveProperty === '@graph') {
              nextActiveProperty = null;
            }

            _context2.next = 170;
            return api.expand({
              activeCtx: termCtx,
              activeProperty: nextActiveProperty,
              element: value,
              options: options,
              insideList: isList,
              expansionMap: expansionMap
            });

          case 170:
            expandedValue = _context2.sent;
            _context2.next = 180;
            break;

          case 173:
            if (!(_getContextValue(activeCtx, _key2, '@type') === '@json')) {
              _context2.next = 177;
              break;
            }

            expandedValue = {
              '@type': '@json',
              '@value': value
            };
            _context2.next = 180;
            break;

          case 177:
            _context2.next = 179;
            return api.expand({
              activeCtx: termCtx,
              activeProperty: _key2,
              element: value,
              options: options,
              insideList: false,
              expansionMap: expansionMap
            });

          case 179:
            expandedValue = _context2.sent;

          case 180:
            if (!(expandedValue === null && expandedProperty !== '@value')) {
              _context2.next = 184;
              break;
            }

            // TODO: use `await` to support async
            expandedValue = expansionMap({
              unmappedValue: value,
              expandedProperty: expandedProperty,
              activeCtx: termCtx,
              activeProperty: activeProperty,
              parent: element,
              options: options,
              insideList: insideList,
              key: _key2,
              expandedParent: expandedParent
            });

            if (!(expandedValue === undefined)) {
              _context2.next = 184;
              break;
            }

            return _context2.abrupt("continue", 200);

          case 184:
            // convert expanded value to @list if container specifies it
            if (expandedProperty !== '@list' && !_isList(expandedValue) && container.includes('@list')) {
              // ensure expanded value in @list is an array
              expandedValue = {
                '@list': _asArray(expandedValue)
              };
            } // convert expanded value to @graph if container specifies it
            // and value is not, itself, a graph
            // index cases handled above


            if (container.includes('@graph') && !container.some(function (key) {
              return key === '@id' || key === '@index';
            })) {
              // ensure expanded values are arrays
              expandedValue = _asArray(expandedValue).map(function (v) {
                return {
                  '@graph': _asArray(v)
                };
              });
            } // FIXME: can this be merged with code above to simplify?
            // merge in reverse properties


            if (!(termCtx.mappings.has(_key2) && termCtx.mappings.get(_key2).reverse)) {
              _context2.next = 199;
              break;
            }

            _reverseMap = expandedParent['@reverse'] = expandedParent['@reverse'] || {};
            expandedValue = _asArray(expandedValue);
            _ii = 0;

          case 190:
            if (!(_ii < expandedValue.length)) {
              _context2.next = 198;
              break;
            }

            _item = expandedValue[_ii];

            if (!(_isValue(_item) || _isList(_item))) {
              _context2.next = 194;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {
              code: 'invalid reverse property value',
              value: expandedValue
            });

          case 194:
            _addValue(_reverseMap, expandedProperty, _item, {
              propertyIsArray: true
            });

          case 195:
            ++_ii;
            _context2.next = 190;
            break;

          case 198:
            return _context2.abrupt("continue", 200);

          case 199:
            // add value for property
            // special keywords handled above
            _addValue(expandedParent, expandedProperty, expandedValue, {
              propertyIsArray: true
            });

          case 200:
            _context2.next = 7;
            break;

          case 202:
            _context2.next = 207;
            break;

          case 204:
            _context2.prev = 204;
            _context2.t5 = _context2["catch"](5);

            _iterator6.e(_context2.t5);

          case 207:
            _context2.prev = 207;

            _iterator6.f();

            return _context2.finish(207);

          case 210:
            if (!('@value' in expandedParent)) {
              _context2.next = 216;
              break;
            }

            if (!(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1))) {
              _context2.next = 214;
              break;
            }

            _context2.next = 216;
            break;

          case 214:
            if (!((_isObject(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame)) {
              _context2.next = 216;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; "@value" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {
              code: 'invalid value object value',
              value: unexpandedValue
            });

          case 216:
            _i = 0, _nests = nests;

          case 217:
            if (!(_i < _nests.length)) {
              _context2.next = 242;
              break;
            }

            key = _nests[_i];
            nestedValues = _isArray(element[key]) ? element[key] : [element[key]];
            _iterator7 = _createForOfIteratorHelper(nestedValues);
            _context2.prev = 221;

            _iterator7.s();

          case 223:
            if ((_step7 = _iterator7.n()).done) {
              _context2.next = 231;
              break;
            }

            nv = _step7.value;

            if (!(!_isObject(nv) || Object.keys(nv).some(function (k) {
              return _expandIri(activeCtx, k, {
                vocab: true
              }, options) === '@value';
            }))) {
              _context2.next = 227;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; nested value must be a node object.', 'jsonld.SyntaxError', {
              code: 'invalid @nest value',
              value: nv
            });

          case 227:
            _context2.next = 229;
            return _expandObject({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              expandedActiveProperty: expandedActiveProperty,
              element: nv,
              expandedParent: expandedParent,
              options: options,
              insideList: insideList,
              typeScopedContext: typeScopedContext,
              typeKey: typeKey,
              expansionMap: expansionMap
            });

          case 229:
            _context2.next = 223;
            break;

          case 231:
            _context2.next = 236;
            break;

          case 233:
            _context2.prev = 233;
            _context2.t6 = _context2["catch"](221);

            _iterator7.e(_context2.t6);

          case 236:
            _context2.prev = 236;

            _iterator7.f();

            return _context2.finish(236);

          case 239:
            _i++;
            _context2.next = 217;
            break;

          case 242:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[5, 204, 207, 210], [76, 86, 89, 92], [221, 233, 236, 239]]);
  }));
  return _expandObject2.apply(this, arguments);
}

function _expandValue(_ref4) {
  var activeCtx = _ref4.activeCtx,
      activeProperty = _ref4.activeProperty,
      value = _ref4.value,
      options = _ref4.options;

  // nothing to expand
  if (value === null || value === undefined) {
    return null;
  } // special-case expand @id and @type (skips '@id' expansion)


  var expandedProperty = _expandIri(activeCtx, activeProperty, {
    vocab: true
  }, options);

  if (expandedProperty === '@id') {
    return _expandIri(activeCtx, value, {
      base: true
    }, options);
  } else if (expandedProperty === '@type') {
    return _expandIri(activeCtx, value, {
      vocab: true,
      base: true
    }, options);
  } // get type definition from context


  var type = _getContextValue(activeCtx, activeProperty, '@type'); // do @id expansion (automatic for @graph)


  if ((type === '@id' || expandedProperty === '@graph') && _isString(value)) {
    return {
      '@id': _expandIri(activeCtx, value, {
        base: true
      }, options)
    };
  } // do @id expansion w/vocab


  if (type === '@vocab' && _isString(value)) {
    return {
      '@id': _expandIri(activeCtx, value, {
        vocab: true,
        base: true
      }, options)
    };
  } // do not expand keyword values


  if (_isKeyword(expandedProperty)) {
    return value;
  }

  var rval = {};

  if (type && !['@id', '@vocab', '@none'].includes(type)) {
    // other type
    rval['@type'] = type;
  } else if (_isString(value)) {
    // check for language tagging for strings
    var language = _getContextValue(activeCtx, activeProperty, '@language');

    if (language !== null) {
      rval['@language'] = language;
    }

    var direction = _getContextValue(activeCtx, activeProperty, '@direction');

    if (direction !== null) {
      rval['@direction'] = direction;
    }
  } // do conversion of values that aren't basic JSON types to strings


  if (!['boolean', 'number', 'string'].includes((0, _typeof2["default"])(value))) {
    value = value.toString();
  }

  rval['@value'] = value;
  return rval;
}
/**
 * Expands a language map.
 *
 * @param activeCtx the active context to use.
 * @param languageMap the language map to expand.
 * @param direction the direction to apply to values.
 * @param {Object} [options] - processing options.
 *
 * @return the expanded language map.
 */


function _expandLanguageMap(activeCtx, languageMap, direction, options) {
  var rval = [];
  var keys = Object.keys(languageMap).sort();

  var _iterator4 = _createForOfIteratorHelper(keys),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var key = _step4.value;

      var expandedKey = _expandIri(activeCtx, key, {
        vocab: true
      }, options);

      var val = languageMap[key];

      if (!_isArray(val)) {
        val = [val];
      }

      var _iterator5 = _createForOfIteratorHelper(val),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var item = _step5.value;

          if (item === null) {
            // null values are allowed (8.5) but ignored (3.1)
            continue;
          }

          if (!_isString(item)) {
            throw new JsonLdError('Invalid JSON-LD syntax; language map values must be strings.', 'jsonld.SyntaxError', {
              code: 'invalid language map value',
              languageMap: languageMap
            });
          }

          var _val = {
            '@value': item
          };

          if (expandedKey !== '@none') {
            _val['@language'] = key.toLowerCase();
          }

          if (direction) {
            _val['@direction'] = direction;
          }

          rval.push(_val);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return rval;
}

function _expandIndexMap(_x3) {
  return _expandIndexMap2.apply(this, arguments);
}

function _expandIndexMap2() {
  _expandIndexMap2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(_ref5) {
    var activeCtx, options, activeProperty, value, expansionMap, asGraph, indexKey, propertyIndex, rval, keys, isTypeIndex, _iterator10, _step10, key, ctx, val, expandedKey, _iterator11, _step11, item;

    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            activeCtx = _ref5.activeCtx, options = _ref5.options, activeProperty = _ref5.activeProperty, value = _ref5.value, expansionMap = _ref5.expansionMap, asGraph = _ref5.asGraph, indexKey = _ref5.indexKey, propertyIndex = _ref5.propertyIndex;
            rval = [];
            keys = Object.keys(value).sort();
            isTypeIndex = indexKey === '@type';
            _iterator10 = _createForOfIteratorHelper(keys);
            _context3.prev = 5;

            _iterator10.s();

          case 7:
            if ((_step10 = _iterator10.n()).done) {
              _context3.next = 51;
              break;
            }

            key = _step10.value;

            if (!isTypeIndex) {
              _context3.next = 15;
              break;
            }

            ctx = _getContextValue(activeCtx, key, '@context');

            if (_isUndefined(ctx)) {
              _context3.next = 15;
              break;
            }

            _context3.next = 14;
            return _processContext({
              activeCtx: activeCtx,
              localCtx: ctx,
              propagate: false,
              options: options
            });

          case 14:
            activeCtx = _context3.sent;

          case 15:
            val = value[key];

            if (!_isArray(val)) {
              val = [val];
            }

            _context3.next = 19;
            return api.expand({
              activeCtx: activeCtx,
              activeProperty: activeProperty,
              element: val,
              options: options,
              insideList: false,
              insideIndex: true,
              expansionMap: expansionMap
            });

          case 19:
            val = _context3.sent;
            // expand for @type, but also for @none
            expandedKey = void 0;

            if (propertyIndex) {
              if (key === '@none') {
                expandedKey = '@none';
              } else {
                expandedKey = _expandValue({
                  activeCtx: activeCtx,
                  activeProperty: indexKey,
                  value: key,
                  options: options
                });
              }
            } else {
              expandedKey = _expandIri(activeCtx, key, {
                vocab: true
              }, options);
            }

            if (indexKey === '@id') {
              // expand document relative
              key = _expandIri(activeCtx, key, {
                base: true
              }, options);
            } else if (isTypeIndex) {
              key = expandedKey;
            }

            _iterator11 = _createForOfIteratorHelper(val);
            _context3.prev = 24;

            _iterator11.s();

          case 26:
            if ((_step11 = _iterator11.n()).done) {
              _context3.next = 41;
              break;
            }

            item = _step11.value;

            // If this is also a @graph container, turn items into graphs
            if (asGraph && !_isGraph(item)) {
              item = {
                '@graph': [item]
              };
            }

            if (!(indexKey === '@type')) {
              _context3.next = 33;
              break;
            }

            if (expandedKey === '@none') {// ignore @none
            } else if (item['@type']) {
              item['@type'] = [key].concat(item['@type']);
            } else {
              item['@type'] = [key];
            }

            _context3.next = 38;
            break;

          case 33:
            if (!(_isValue(item) && !['@language', '@type', '@index'].includes(indexKey))) {
              _context3.next = 37;
              break;
            }

            throw new JsonLdError('Invalid JSON-LD syntax; Attempt to add illegal key to value ' + "object: \"".concat(indexKey, "\"."), 'jsonld.SyntaxError', {
              code: 'invalid value object',
              value: item
            });

          case 37:
            if (propertyIndex) {
              // index is a property to be expanded, and values interpreted for that
              // property
              if (expandedKey !== '@none') {
                // expand key as a value
                _addValue(item, propertyIndex, expandedKey, {
                  propertyIsArray: true,
                  prependValue: true
                });
              }
            } else if (expandedKey !== '@none' && !(indexKey in item)) {
              item[indexKey] = key;
            }

          case 38:
            rval.push(item);

          case 39:
            _context3.next = 26;
            break;

          case 41:
            _context3.next = 46;
            break;

          case 43:
            _context3.prev = 43;
            _context3.t0 = _context3["catch"](24);

            _iterator11.e(_context3.t0);

          case 46:
            _context3.prev = 46;

            _iterator11.f();

            return _context3.finish(46);

          case 49:
            _context3.next = 7;
            break;

          case 51:
            _context3.next = 56;
            break;

          case 53:
            _context3.prev = 53;
            _context3.t1 = _context3["catch"](5);

            _iterator10.e(_context3.t1);

          case 56:
            _context3.prev = 56;

            _iterator10.f();

            return _context3.finish(56);

          case 59:
            return _context3.abrupt("return", rval);

          case 60:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[5, 53, 56, 59], [24, 43, 46, 49]]);
  }));
  return _expandIndexMap2.apply(this, arguments);
}

},{"./JsonLdError":91,"./context":99,"./graphTypes":106,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/typeof":27,"@babel/runtime/regenerator":30}],103:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _require = require('./graphTypes'),
    _isSubjectReference = _require.isSubjectReference;

var _require2 = require('./nodeMap'),
    _createMergedNodeMap = _require2.createMergedNodeMap;

var api = {};
module.exports = api;
/**
 * Performs JSON-LD flattening.
 *
 * @param input the expanded JSON-LD to flatten.
 *
 * @return the flattened output.
 */

api.flatten = function (input) {
  var defaultGraph = _createMergedNodeMap(input); // produce flattened output


  var flattened = [];
  var keys = Object.keys(defaultGraph).sort();

  for (var ki = 0; ki < keys.length; ++ki) {
    var node = defaultGraph[keys[ki]]; // only add full subjects to top-level

    if (!_isSubjectReference(node)) {
      flattened.push(node);
    }
  }

  return flattened;
};

},{"./graphTypes":106,"./nodeMap":108}],104:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('./context'),
    isKeyword = _require.isKeyword;

var graphTypes = require('./graphTypes');

var types = require('./types');

var util = require('./util');

var url = require('./url');

var JsonLdError = require('./JsonLdError');

var _require2 = require('./nodeMap'),
    _createNodeMap = _require2.createNodeMap,
    _mergeNodeMapGraphs = _require2.mergeNodeMapGraphs;

var api = {};
module.exports = api;
/**
 * Performs JSON-LD `merged` framing.
 *
 * @param input the expanded JSON-LD to frame.
 * @param frame the expanded JSON-LD frame to use.
 * @param options the framing options.
 *
 * @return the framed output.
 */

api.frameMergedOrDefault = function (input, frame, options) {
  // create framing state
  var state = {
    options: options,
    embedded: false,
    graph: '@default',
    graphMap: {
      '@default': {}
    },
    subjectStack: [],
    link: {},
    bnodeMap: {}
  }; // produce a map of all graphs and name each bnode
  // FIXME: currently uses subjects from @merged graph only

  var issuer = new util.IdentifierIssuer('_:b');

  _createNodeMap(input, state.graphMap, '@default', issuer);

  if (options.merged) {
    state.graphMap['@merged'] = _mergeNodeMapGraphs(state.graphMap);
    state.graph = '@merged';
  }

  state.subjects = state.graphMap[state.graph]; // frame the subjects

  var framed = [];
  api.frame(state, Object.keys(state.subjects).sort(), frame, framed); // If pruning blank nodes, find those to prune

  if (options.pruneBlankNodeIdentifiers) {
    // remove all blank nodes appearing only once, done in compaction
    options.bnodesToClear = Object.keys(state.bnodeMap).filter(function (id) {
      return state.bnodeMap[id].length === 1;
    });
  } // remove @preserve from results


  options.link = {};
  return _cleanupPreserve(framed, options);
};
/**
 * Frames subjects according to the given frame.
 *
 * @param state the current framing state.
 * @param subjects the subjects to filter.
 * @param frame the frame.
 * @param parent the parent subject or top-level array.
 * @param property the parent property, initialized to null.
 */


api.frame = function (state, subjects, frame, parent) {
  var property = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

  // validate the frame
  _validateFrame(frame);

  frame = frame[0]; // get flags for current frame

  var options = state.options;
  var flags = {
    embed: _getFrameFlag(frame, options, 'embed'),
    explicit: _getFrameFlag(frame, options, 'explicit'),
    requireAll: _getFrameFlag(frame, options, 'requireAll')
  }; // get link for current graph

  if (!state.link.hasOwnProperty(state.graph)) {
    state.link[state.graph] = {};
  }

  var link = state.link[state.graph]; // filter out subjects that match the frame

  var matches = _filterSubjects(state, subjects, frame, flags); // add matches to output


  var ids = Object.keys(matches).sort();

  var _iterator = _createForOfIteratorHelper(ids),
      _step;

  try {
    var _loop = function _loop() {
      var id = _step.value;
      var subject = matches[id];
      /* Note: In order to treat each top-level match as a compartmentalized
      result, clear the unique embedded subjects map when the property is null,
      which only occurs at the top-level. */

      if (property === null) {
        state.uniqueEmbeds = (0, _defineProperty2["default"])({}, state.graph, {});
      } else {
        state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};
      }

      if (flags.embed === '@link' && id in link) {
        // TODO: may want to also match an existing linked subject against
        // the current frame ... so different frames could produce different
        // subjects that are only shared in-memory when the frames are the same
        // add existing linked subject
        _addFrameOutput(parent, property, link[id]);

        return "continue";
      } // start output for subject


      var output = {
        '@id': id
      };

      if (id.indexOf('_:') === 0) {
        util.addValue(state.bnodeMap, id, output, {
          propertyIsArray: true
        });
      }

      link[id] = output; // validate @embed

      if ((flags.embed === '@first' || flags.embed === '@last') && state.is11) {
        throw new JsonLdError('Invalid JSON-LD syntax; invalid value of @embed.', 'jsonld.SyntaxError', {
          code: 'invalid @embed value',
          frame: frame
        });
      }

      if (!state.embedded && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
        // skip adding this node object to the top level, as it was
        // already included in another node object
        return "continue";
      } // if embed is @never or if a circular reference would be created by an
      // embed, the subject cannot be embedded, just add the reference;
      // note that a circular reference won't occur when the embed flag is
      // `@link` as the above check will short-circuit before reaching this point


      if (state.embedded && (flags.embed === '@never' || _createsCircularReference(subject, state.graph, state.subjectStack))) {
        _addFrameOutput(parent, property, output);

        return "continue";
      } // if only the first (or once) should be embedded


      if (state.embedded && (flags.embed == '@first' || flags.embed == '@once') && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
        _addFrameOutput(parent, property, output);

        return "continue";
      } // if only the last match should be embedded


      if (flags.embed === '@last') {
        // remove any existing embed
        if (id in state.uniqueEmbeds[state.graph]) {
          _removeEmbed(state, id);
        }
      }

      state.uniqueEmbeds[state.graph][id] = {
        parent: parent,
        property: property
      }; // push matching subject onto stack to enable circular embed checks

      state.subjectStack.push({
        subject: subject,
        graph: state.graph
      }); // subject is also the name of a graph

      if (id in state.graphMap) {
        var recurse = false;
        var subframe = null;

        if (!('@graph' in frame)) {
          recurse = state.graph !== '@merged';
          subframe = {};
        } else {
          subframe = frame['@graph'][0];
          recurse = !(id === '@merged' || id === '@default');

          if (!types.isObject(subframe)) {
            subframe = {};
          }
        }

        if (recurse) {
          // recurse into graph
          api.frame(_objectSpread(_objectSpread({}, state), {}, {
            graph: id,
            embedded: false
          }), Object.keys(state.graphMap[id]).sort(), [subframe], output, '@graph');
        }
      } // if frame has @included, recurse over its sub-frame


      if ('@included' in frame) {
        api.frame(_objectSpread(_objectSpread({}, state), {}, {
          embedded: false
        }), subjects, frame['@included'], output, '@included');
      } // iterate over subject properties


      var _iterator2 = _createForOfIteratorHelper(Object.keys(subject).sort()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var prop = _step2.value;

          // copy keywords to output
          if (isKeyword(prop)) {
            output[prop] = util.clone(subject[prop]);

            if (prop === '@type') {
              // count bnode values of @type
              var _iterator5 = _createForOfIteratorHelper(subject['@type']),
                  _step5;

              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  var type = _step5.value;

                  if (type.indexOf('_:') === 0) {
                    util.addValue(state.bnodeMap, type, output, {
                      propertyIsArray: true
                    });
                  }
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
            }

            continue;
          } // explicit is on and property isn't in the frame, skip processing


          if (flags.explicit && !(prop in frame)) {
            continue;
          } // add objects


          var _iterator6 = _createForOfIteratorHelper(subject[prop]),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var o = _step6.value;

              var _subframe = prop in frame ? frame[prop] : _createImplicitFrame(flags); // recurse into list


              if (graphTypes.isList(o)) {
                var _subframe2 = frame[prop] && frame[prop][0] && frame[prop][0]['@list'] ? frame[prop][0]['@list'] : _createImplicitFrame(flags); // add empty list


                var list = {
                  '@list': []
                };

                _addFrameOutput(output, prop, list); // add list objects


                var src = o['@list'];

                var _iterator7 = _createForOfIteratorHelper(src),
                    _step7;

                try {
                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                    var oo = _step7.value;

                    if (graphTypes.isSubjectReference(oo)) {
                      // recurse into subject reference
                      api.frame(_objectSpread(_objectSpread({}, state), {}, {
                        embedded: true
                      }), [oo['@id']], _subframe2, list, '@list');
                    } else {
                      // include other values automatically
                      _addFrameOutput(list, '@list', util.clone(oo));
                    }
                  }
                } catch (err) {
                  _iterator7.e(err);
                } finally {
                  _iterator7.f();
                }
              } else if (graphTypes.isSubjectReference(o)) {
                // recurse into subject reference
                api.frame(_objectSpread(_objectSpread({}, state), {}, {
                  embedded: true
                }), [o['@id']], _subframe, output, prop);
              } else if (_valueMatch(_subframe[0], o)) {
                // include other values, if they match
                _addFrameOutput(output, prop, util.clone(o));
              }
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        } // handle defaults

      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper(Object.keys(frame).sort()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _prop = _step3.value;

          // skip keywords
          if (_prop === '@type') {
            if (!types.isObject(frame[_prop][0]) || !('@default' in frame[_prop][0])) {
              continue;
            } // allow through default types

          } else if (isKeyword(_prop)) {
            continue;
          } // if omit default is off, then include default values for properties
          // that appear in the next frame but are not in the matching subject


          var next = frame[_prop][0] || {};

          var omitDefaultOn = _getFrameFlag(next, options, 'omitDefault');

          if (!omitDefaultOn && !(_prop in output)) {
            var preserve = '@null';

            if ('@default' in next) {
              preserve = util.clone(next['@default']);
            }

            if (!types.isArray(preserve)) {
              preserve = [preserve];
            }

            output[_prop] = [{
              '@preserve': preserve
            }];
          }
        } // if embed reverse values by finding nodes having this subject as a value
        // of the associated property

      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      var _iterator4 = _createForOfIteratorHelper(Object.keys(frame['@reverse'] || {}).sort()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var reverseProp = _step4.value;
          var _subframe3 = frame['@reverse'][reverseProp];

          for (var _i = 0, _Object$keys = Object.keys(state.subjects); _i < _Object$keys.length; _i++) {
            var _subject = _Object$keys[_i];
            var nodeValues = util.getValues(state.subjects[_subject], reverseProp);

            if (nodeValues.some(function (v) {
              return v['@id'] === id;
            })) {
              // node has property referencing this subject, recurse
              output['@reverse'] = output['@reverse'] || {};
              util.addValue(output['@reverse'], reverseProp, [], {
                propertyIsArray: true
              });
              api.frame(_objectSpread(_objectSpread({}, state), {}, {
                embedded: true
              }), [_subject], _subframe3, output['@reverse'][reverseProp], property);
            }
          }
        } // add output to parent

      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      _addFrameOutput(parent, property, output); // pop matching subject from circular ref-checking stack


      state.subjectStack.pop();
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};
/**
 * Replace `@null` with `null`, removing it from arrays.
 *
 * @param input the framed, compacted output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */


api.cleanupNull = function (input, options) {
  // recurse through arrays
  if (types.isArray(input)) {
    var noNulls = input.map(function (v) {
      return api.cleanupNull(v, options);
    });
    return noNulls.filter(function (v) {
      return v;
    }); // removes nulls from array
  }

  if (input === '@null') {
    return null;
  }

  if (types.isObject(input)) {
    // handle in-memory linked nodes
    if ('@id' in input) {
      var id = input['@id'];

      if (options.link.hasOwnProperty(id)) {
        var idx = options.link[id].indexOf(input);

        if (idx !== -1) {
          // already visited
          return options.link[id][idx];
        } // prevent circular visitation


        options.link[id].push(input);
      } else {
        // prevent circular visitation
        options.link[id] = [input];
      }
    }

    for (var key in input) {
      input[key] = api.cleanupNull(input[key], options);
    }
  }

  return input;
};
/**
 * Creates an implicit frame when recursing through subject matches. If
 * a frame doesn't have an explicit frame for a particular property, then
 * a wildcard child frame will be created that uses the same flags that the
 * parent frame used.
 *
 * @param flags the current framing flags.
 *
 * @return the implicit frame.
 */


function _createImplicitFrame(flags) {
  var frame = {};

  for (var key in flags) {
    if (flags[key] !== undefined) {
      frame['@' + key] = [flags[key]];
    }
  }

  return [frame];
}
/**
 * Checks the current subject stack to see if embedding the given subject
 * would cause a circular reference.
 *
 * @param subjectToEmbed the subject to embed.
 * @param graph the graph the subject to embed is in.
 * @param subjectStack the current stack of subjects.
 *
 * @return true if a circular reference would be created, false if not.
 */


function _createsCircularReference(subjectToEmbed, graph, subjectStack) {
  for (var i = subjectStack.length - 1; i >= 0; --i) {
    var subject = subjectStack[i];

    if (subject.graph === graph && subject.subject['@id'] === subjectToEmbed['@id']) {
      return true;
    }
  }

  return false;
}
/**
 * Gets the frame flag value for the given flag name.
 *
 * @param frame the frame.
 * @param options the framing options.
 * @param name the flag name.
 *
 * @return the flag value.
 */


function _getFrameFlag(frame, options, name) {
  var flag = '@' + name;
  var rval = flag in frame ? frame[flag][0] : options[name];

  if (name === 'embed') {
    // default is "@last"
    // backwards-compatibility support for "embed" maps:
    // true => "@last"
    // false => "@never"
    if (rval === true) {
      rval = '@once';
    } else if (rval === false) {
      rval = '@never';
    } else if (rval !== '@always' && rval !== '@never' && rval !== '@link' && rval !== '@first' && rval !== '@last' && rval !== '@once') {
      throw new JsonLdError('Invalid JSON-LD syntax; invalid value of @embed.', 'jsonld.SyntaxError', {
        code: 'invalid @embed value',
        frame: frame
      });
    }
  }

  return rval;
}
/**
 * Validates a JSON-LD frame, throwing an exception if the frame is invalid.
 *
 * @param frame the frame to validate.
 */


function _validateFrame(frame) {
  if (!types.isArray(frame) || frame.length !== 1 || !types.isObject(frame[0])) {
    throw new JsonLdError('Invalid JSON-LD syntax; a JSON-LD frame must be a single object.', 'jsonld.SyntaxError', {
      frame: frame
    });
  }

  if ('@id' in frame[0]) {
    var _iterator8 = _createForOfIteratorHelper(util.asArray(frame[0]['@id'])),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var id = _step8.value;

        // @id must be wildcard or an IRI
        if (!(types.isObject(id) || url.isAbsolute(id)) || types.isString(id) && id.indexOf('_:') === 0) {
          throw new JsonLdError('Invalid JSON-LD syntax; invalid @id in frame.', 'jsonld.SyntaxError', {
            code: 'invalid frame',
            frame: frame
          });
        }
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
  }

  if ('@type' in frame[0]) {
    var _iterator9 = _createForOfIteratorHelper(util.asArray(frame[0]['@type'])),
        _step9;

    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var type = _step9.value;

        // @id must be wildcard or an IRI
        if (!(types.isObject(type) || url.isAbsolute(type)) || types.isString(type) && type.indexOf('_:') === 0) {
          throw new JsonLdError('Invalid JSON-LD syntax; invalid @type in frame.', 'jsonld.SyntaxError', {
            code: 'invalid frame',
            frame: frame
          });
        }
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
  }
}
/**
 * Returns a map of all of the subjects that match a parsed frame.
 *
 * @param state the current framing state.
 * @param subjects the set of subjects to filter.
 * @param frame the parsed frame.
 * @param flags the frame flags.
 *
 * @return all of the matched subjects.
 */


function _filterSubjects(state, subjects, frame, flags) {
  // filter subjects in @id order
  var rval = {};

  var _iterator10 = _createForOfIteratorHelper(subjects),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var id = _step10.value;
      var subject = state.graphMap[state.graph][id];

      if (_filterSubject(state, subject, frame, flags)) {
        rval[id] = subject;
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  return rval;
}
/**
 * Returns true if the given subject matches the given frame.
 *
 * Matches either based on explicit type inclusion where the node has any
 * type listed in the frame. If the frame has empty types defined matches
 * nodes not having a @type. If the frame has a type of {} defined matches
 * nodes having any type defined.
 *
 * Otherwise, does duck typing, where the node must have all of the
 * properties defined in the frame.
 *
 * @param state the current framing state.
 * @param subject the subject to check.
 * @param frame the frame to check.
 * @param flags the frame flags.
 *
 * @return true if the subject matches, false if not.
 */


function _filterSubject(state, subject, frame, flags) {
  // check ducktype
  var wildcard = true;
  var matchesSome = false;

  for (var key in frame) {
    var matchThis = false;
    var nodeValues = util.getValues(subject, key);
    var isEmpty = util.getValues(frame, key).length === 0;

    if (key === '@id') {
      // match on no @id or any matching @id, including wildcard
      if (types.isEmptyObject(frame['@id'][0] || {})) {
        matchThis = true;
      } else if (frame['@id'].length >= 0) {
        matchThis = frame['@id'].includes(nodeValues[0]);
      }

      if (!flags.requireAll) {
        return matchThis;
      }
    } else if (key === '@type') {
      // check @type (object value means 'any' type,
      // fall through to ducktyping)
      wildcard = false;

      if (isEmpty) {
        if (nodeValues.length > 0) {
          // don't match on no @type
          return false;
        }

        matchThis = true;
      } else if (frame['@type'].length === 1 && types.isEmptyObject(frame['@type'][0])) {
        // match on wildcard @type if there is a type
        matchThis = nodeValues.length > 0;
      } else {
        // match on a specific @type
        var _iterator11 = _createForOfIteratorHelper(frame['@type']),
            _step11;

        try {
          var _loop2 = function _loop2() {
            var type = _step11.value;

            if (types.isObject(type) && '@default' in type) {
              // match on default object
              matchThis = true;
            } else {
              matchThis = matchThis || nodeValues.some(function (tt) {
                return tt === type;
              });
            }
          };

          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            _loop2();
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
      }

      if (!flags.requireAll) {
        return matchThis;
      }
    } else if (isKeyword(key)) {
      continue;
    } else {
      var _ret2 = function () {
        // Force a copy of this frame entry so it can be manipulated
        var thisFrame = util.getValues(frame, key)[0];
        var hasDefault = false;

        if (thisFrame) {
          _validateFrame([thisFrame]);

          hasDefault = '@default' in thisFrame;
        } // no longer a wildcard pattern if frame has any non-keyword properties


        wildcard = false; // skip, but allow match if node has no value for property, and frame has
        // a default value

        if (nodeValues.length === 0 && hasDefault) {
          return "continue";
        } // if frame value is empty, don't match if subject has any value


        if (nodeValues.length > 0 && isEmpty) {
          return {
            v: false
          };
        }

        if (thisFrame === undefined) {
          // node does not match if values is not empty and the value of property
          // in frame is match none.
          if (nodeValues.length > 0) {
            return {
              v: false
            };
          }

          matchThis = true;
        } else {
          if (graphTypes.isList(thisFrame)) {
            var listValue = thisFrame['@list'][0];

            if (graphTypes.isList(nodeValues[0])) {
              var nodeListValues = nodeValues[0]['@list'];

              if (graphTypes.isValue(listValue)) {
                // match on any matching value
                matchThis = nodeListValues.some(function (lv) {
                  return _valueMatch(listValue, lv);
                });
              } else if (graphTypes.isSubject(listValue) || graphTypes.isSubjectReference(listValue)) {
                matchThis = nodeListValues.some(function (lv) {
                  return _nodeMatch(state, listValue, lv, flags);
                });
              }
            }
          } else if (graphTypes.isValue(thisFrame)) {
            matchThis = nodeValues.some(function (nv) {
              return _valueMatch(thisFrame, nv);
            });
          } else if (graphTypes.isSubjectReference(thisFrame)) {
            matchThis = nodeValues.some(function (nv) {
              return _nodeMatch(state, thisFrame, nv, flags);
            });
          } else if (types.isObject(thisFrame)) {
            matchThis = nodeValues.length > 0;
          } else {
            matchThis = false;
          }
        }
      }();

      if (_ret2 === "continue") continue;
      if ((0, _typeof2["default"])(_ret2) === "object") return _ret2.v;
    } // all non-defaulted values must match if requireAll is set


    if (!matchThis && flags.requireAll) {
      return false;
    }

    matchesSome = matchesSome || matchThis;
  } // return true if wildcard or subject matches some properties


  return wildcard || matchesSome;
}
/**
 * Removes an existing embed.
 *
 * @param state the current framing state.
 * @param id the @id of the embed to remove.
 */


function _removeEmbed(state, id) {
  // get existing embed
  var embeds = state.uniqueEmbeds[state.graph];
  var embed = embeds[id];
  var parent = embed.parent;
  var property = embed.property; // create reference to replace embed

  var subject = {
    '@id': id
  }; // remove existing embed

  if (types.isArray(parent)) {
    // replace subject with reference
    for (var i = 0; i < parent.length; ++i) {
      if (util.compareValues(parent[i], subject)) {
        parent[i] = subject;
        break;
      }
    }
  } else {
    // replace subject with reference
    var useArray = types.isArray(parent[property]);
    util.removeValue(parent, property, subject, {
      propertyIsArray: useArray
    });
    util.addValue(parent, property, subject, {
      propertyIsArray: useArray
    });
  } // recursively remove dependent dangling embeds


  var removeDependents = function removeDependents(id) {
    // get embed keys as a separate array to enable deleting keys in map
    var ids = Object.keys(embeds);

    for (var _i2 = 0, _ids = ids; _i2 < _ids.length; _i2++) {
      var next = _ids[_i2];

      if (next in embeds && types.isObject(embeds[next].parent) && embeds[next].parent['@id'] === id) {
        delete embeds[next];
        removeDependents(next);
      }
    }
  };

  removeDependents(id);
}
/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */


function _cleanupPreserve(input, options) {
  // recurse through arrays
  if (types.isArray(input)) {
    return input.map(function (value) {
      return _cleanupPreserve(value, options);
    });
  }

  if (types.isObject(input)) {
    // remove @preserve
    if ('@preserve' in input) {
      return input['@preserve'][0];
    } // skip @values


    if (graphTypes.isValue(input)) {
      return input;
    } // recurse through @lists


    if (graphTypes.isList(input)) {
      input['@list'] = _cleanupPreserve(input['@list'], options);
      return input;
    } // handle in-memory linked nodes


    if ('@id' in input) {
      var id = input['@id'];

      if (options.link.hasOwnProperty(id)) {
        var idx = options.link[id].indexOf(input);

        if (idx !== -1) {
          // already visited
          return options.link[id][idx];
        } // prevent circular visitation


        options.link[id].push(input);
      } else {
        // prevent circular visitation
        options.link[id] = [input];
      }
    } // recurse through properties


    for (var prop in input) {
      // potentially remove the id, if it is an unreference bnode
      if (prop === '@id' && options.bnodesToClear.includes(input[prop])) {
        delete input['@id'];
        continue;
      }

      input[prop] = _cleanupPreserve(input[prop], options);
    }
  }

  return input;
}
/**
 * Adds framing output to the given parent.
 *
 * @param parent the parent to add to.
 * @param property the parent property.
 * @param output the output to add.
 */


function _addFrameOutput(parent, property, output) {
  if (types.isObject(parent)) {
    util.addValue(parent, property, output, {
      propertyIsArray: true
    });
  } else {
    parent.push(output);
  }
}
/**
 * Node matches if it is a node, and matches the pattern as a frame.
 *
 * @param state the current framing state.
 * @param pattern used to match value
 * @param value to check
 * @param flags the frame flags.
 */


function _nodeMatch(state, pattern, value, flags) {
  if (!('@id' in value)) {
    return false;
  }

  var nodeObject = state.subjects[value['@id']];
  return nodeObject && _filterSubject(state, nodeObject, pattern, flags);
}
/**
 * Value matches if it is a value and matches the value pattern
 *
 * * `pattern` is empty
 * * @values are the same, or `pattern[@value]` is a wildcard, and
 * * @types are the same or `value[@type]` is not null
 *   and `pattern[@type]` is `{}`, or `value[@type]` is null
 *   and `pattern[@type]` is null or `[]`, and
 * * @languages are the same or `value[@language]` is not null
 *   and `pattern[@language]` is `{}`, or `value[@language]` is null
 *   and `pattern[@language]` is null or `[]`.
 *
 * @param pattern used to match value
 * @param value to check
 */


function _valueMatch(pattern, value) {
  var v1 = value['@value'];
  var t1 = value['@type'];
  var l1 = value['@language'];
  var v2 = pattern['@value'] ? types.isArray(pattern['@value']) ? pattern['@value'] : [pattern['@value']] : [];
  var t2 = pattern['@type'] ? types.isArray(pattern['@type']) ? pattern['@type'] : [pattern['@type']] : [];
  var l2 = pattern['@language'] ? types.isArray(pattern['@language']) ? pattern['@language'] : [pattern['@language']] : [];

  if (v2.length === 0 && t2.length === 0 && l2.length === 0) {
    return true;
  }

  if (!(v2.includes(v1) || types.isEmptyObject(v2[0]))) {
    return false;
  }

  if (!(!t1 && t2.length === 0 || t2.includes(t1) || t1 && types.isEmptyObject(t2[0]))) {
    return false;
  }

  if (!(!l1 && l2.length === 0 || l2.includes(l1) || l1 && types.isEmptyObject(l2[0]))) {
    return false;
  }

  return true;
}

},{"./JsonLdError":91,"./context":99,"./graphTypes":106,"./nodeMap":108,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/defineProperty":10,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],105:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var JsonLdError = require('./JsonLdError');

var graphTypes = require('./graphTypes');

var types = require('./types');

var util = require('./util'); // constants


var _require = require('./constants'),
    RDF_LIST = _require.RDF_LIST,
    RDF_FIRST = _require.RDF_FIRST,
    RDF_REST = _require.RDF_REST,
    RDF_NIL = _require.RDF_NIL,
    RDF_TYPE = _require.RDF_TYPE,
    RDF_JSON_LITERAL = _require.RDF_JSON_LITERAL,
    XSD_BOOLEAN = _require.XSD_BOOLEAN,
    XSD_DOUBLE = _require.XSD_DOUBLE,
    XSD_INTEGER = _require.XSD_INTEGER,
    XSD_STRING = _require.XSD_STRING;

var REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
var api = {};
module.exports = api;
/**
 * Converts an RDF dataset to JSON-LD.
 *
 * @param dataset the RDF dataset.
 * @param options the RDF serialization options.
 *
 * @return a Promise that resolves to the JSON-LD output.
 */

api.fromRDF = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(dataset, _ref) {
    var _ref$useRdfType, useRdfType, _ref$useNativeTypes, useNativeTypes, _ref$rdfDirection, rdfDirection, defaultGraph, graphMap, referencedOnce, _iterator, _step, quad, _name, nodeMap, s, p, o, _node, objectIsNode, value, object, name, graphObject, nil, _iterator2, _step2, usage, node, property, head, list, listNodes, nodeKeyCount, _i, _listNodes, listNode, result, subjects, _iterator3, _step3, subject, _node2, graph, _graphObject, graphSubjects, _iterator4, _step4, graphSubject, _node3;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref$useRdfType = _ref.useRdfType, useRdfType = _ref$useRdfType === void 0 ? false : _ref$useRdfType, _ref$useNativeTypes = _ref.useNativeTypes, useNativeTypes = _ref$useNativeTypes === void 0 ? false : _ref$useNativeTypes, _ref$rdfDirection = _ref.rdfDirection, rdfDirection = _ref$rdfDirection === void 0 ? null : _ref$rdfDirection;
            defaultGraph = {};
            graphMap = {
              '@default': defaultGraph
            };
            referencedOnce = {};
            _iterator = _createForOfIteratorHelper(dataset);
            _context.prev = 5;

            _iterator.s();

          case 7:
            if ((_step = _iterator.n()).done) {
              _context.next = 28;
              break;
            }

            quad = _step.value;
            // TODO: change 'name' to 'graph'
            _name = quad.graph.termType === 'DefaultGraph' ? '@default' : quad.graph.value;

            if (!(_name in graphMap)) {
              graphMap[_name] = {};
            }

            if (_name !== '@default' && !(_name in defaultGraph)) {
              defaultGraph[_name] = {
                '@id': _name
              };
            }

            nodeMap = graphMap[_name]; // get subject, predicate, object

            s = quad.subject.value;
            p = quad.predicate.value;
            o = quad.object;

            if (!(s in nodeMap)) {
              nodeMap[s] = {
                '@id': s
              };
            }

            _node = nodeMap[s];
            objectIsNode = o.termType.endsWith('Node');

            if (objectIsNode && !(o.value in nodeMap)) {
              nodeMap[o.value] = {
                '@id': o.value
              };
            }

            if (!(p === RDF_TYPE && !useRdfType && objectIsNode)) {
              _context.next = 23;
              break;
            }

            util.addValue(_node, '@type', o.value, {
              propertyIsArray: true
            });
            return _context.abrupt("continue", 26);

          case 23:
            value = _RDFToObject(o, useNativeTypes, rdfDirection);
            util.addValue(_node, p, value, {
              propertyIsArray: true
            }); // object may be an RDF list/partial list node but we can't know easily
            // until all triples are read

            if (objectIsNode) {
              if (o.value === RDF_NIL) {
                // track rdf:nil uniquely per graph
                object = nodeMap[o.value];

                if (!('usages' in object)) {
                  object.usages = [];
                }

                object.usages.push({
                  node: _node,
                  property: p,
                  value: value
                });
              } else if (o.value in referencedOnce) {
                // object referenced more than once
                referencedOnce[o.value] = false;
              } else {
                // keep track of single reference
                referencedOnce[o.value] = {
                  node: _node,
                  property: p,
                  value: value
                };
              }
            }

          case 26:
            _context.next = 7;
            break;

          case 28:
            _context.next = 33;
            break;

          case 30:
            _context.prev = 30;
            _context.t0 = _context["catch"](5);

            _iterator.e(_context.t0);

          case 33:
            _context.prev = 33;

            _iterator.f();

            return _context.finish(33);

          case 36:
            _context.t1 = _regenerator["default"].keys(graphMap);

          case 37:
            if ((_context.t2 = _context.t1()).done) {
              _context.next = 84;
              break;
            }

            name = _context.t2.value;
            graphObject = graphMap[name]; // no @lists to be converted, continue

            if (RDF_NIL in graphObject) {
              _context.next = 42;
              break;
            }

            return _context.abrupt("continue", 37);

          case 42:
            // iterate backwards through each RDF list
            nil = graphObject[RDF_NIL];

            if (nil.usages) {
              _context.next = 45;
              break;
            }

            return _context.abrupt("continue", 37);

          case 45:
            _iterator2 = _createForOfIteratorHelper(nil.usages);
            _context.prev = 46;

            _iterator2.s();

          case 48:
            if ((_step2 = _iterator2.n()).done) {
              _context.next = 73;
              break;
            }

            usage = _step2.value;
            node = usage.node;
            property = usage.property;
            head = usage.value;
            list = [];
            listNodes = []; // ensure node is a well-formed list node; it must:
            // 1. Be referenced only once.
            // 2. Have an array for rdf:first that has 1 item.
            // 3. Have an array for rdf:rest that has 1 item.
            // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,
            //   optionally, @type where the value is rdf:List.

            nodeKeyCount = Object.keys(node).length;

          case 56:
            if (!(property === RDF_REST && types.isObject(referencedOnce[node['@id']]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node['@type']) && node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {
              _context.next = 68;
              break;
            }

            list.push(node[RDF_FIRST][0]);
            listNodes.push(node['@id']); // get next node, moving backwards through list

            usage = referencedOnce[node['@id']];
            node = usage.node;
            property = usage.property;
            head = usage.value;
            nodeKeyCount = Object.keys(node).length; // if node is not a blank node, then list head found

            if (graphTypes.isBlankNode(node)) {
              _context.next = 66;
              break;
            }

            return _context.abrupt("break", 68);

          case 66:
            _context.next = 56;
            break;

          case 68:
            // transform list into @list object
            delete head['@id'];
            head['@list'] = list.reverse();

            for (_i = 0, _listNodes = listNodes; _i < _listNodes.length; _i++) {
              listNode = _listNodes[_i];
              delete graphObject[listNode];
            }

          case 71:
            _context.next = 48;
            break;

          case 73:
            _context.next = 78;
            break;

          case 75:
            _context.prev = 75;
            _context.t3 = _context["catch"](46);

            _iterator2.e(_context.t3);

          case 78:
            _context.prev = 78;

            _iterator2.f();

            return _context.finish(78);

          case 81:
            delete nil.usages;
            _context.next = 37;
            break;

          case 84:
            result = [];
            subjects = Object.keys(defaultGraph).sort();
            _iterator3 = _createForOfIteratorHelper(subjects);

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                subject = _step3.value;
                _node2 = defaultGraph[subject];

                if (subject in graphMap) {
                  graph = _node2['@graph'] = [];
                  _graphObject = graphMap[subject];
                  graphSubjects = Object.keys(_graphObject).sort();
                  _iterator4 = _createForOfIteratorHelper(graphSubjects);

                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                      graphSubject = _step4.value;
                      _node3 = _graphObject[graphSubject]; // only add full subjects to top-level

                      if (!graphTypes.isSubjectReference(_node3)) {
                        graph.push(_node3);
                      }
                    }
                  } catch (err) {
                    _iterator4.e(err);
                  } finally {
                    _iterator4.f();
                  }
                } // only add full subjects to top-level


                if (!graphTypes.isSubjectReference(_node2)) {
                  result.push(_node2);
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }

            return _context.abrupt("return", result);

          case 89:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[5, 30, 33, 36], [46, 75, 78, 81]]);
  }));

  return function (_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Converts an RDF triple object to a JSON-LD object.
 *
 * @param o the RDF triple object to convert.
 * @param useNativeTypes true to output native types, false not to.
 *
 * @return the JSON-LD object.
 */


function _RDFToObject(o, useNativeTypes, rdfDirection) {
  // convert NamedNode/BlankNode object to JSON-LD
  if (o.termType.endsWith('Node')) {
    return {
      '@id': o.value
    };
  } // convert literal to JSON-LD


  var rval = {
    '@value': o.value
  }; // add language

  if (o.language) {
    rval['@language'] = o.language;
  } else {
    var type = o.datatype.value;

    if (!type) {
      type = XSD_STRING;
    }

    if (type === RDF_JSON_LITERAL) {
      type = '@json';

      try {
        rval['@value'] = JSON.parse(rval['@value']);
      } catch (e) {
        throw new JsonLdError('JSON literal could not be parsed.', 'jsonld.InvalidJsonLiteral', {
          code: 'invalid JSON literal',
          value: rval['@value'],
          cause: e
        });
      }
    } // use native types for certain xsd types


    if (useNativeTypes) {
      if (type === XSD_BOOLEAN) {
        if (rval['@value'] === 'true') {
          rval['@value'] = true;
        } else if (rval['@value'] === 'false') {
          rval['@value'] = false;
        }
      } else if (types.isNumeric(rval['@value'])) {
        if (type === XSD_INTEGER) {
          var i = parseInt(rval['@value'], 10);

          if (i.toFixed(0) === rval['@value']) {
            rval['@value'] = i;
          }
        } else if (type === XSD_DOUBLE) {
          rval['@value'] = parseFloat(rval['@value']);
        }
      } // do not add native type


      if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {
        rval['@type'] = type;
      }
    } else if (rdfDirection === 'i18n-datatype' && type.startsWith('https://www.w3.org/ns/i18n#')) {
      var _type$split = type.split(/[#_]/),
          _type$split2 = (0, _slicedToArray2["default"])(_type$split, 3),
          language = _type$split2[1],
          direction = _type$split2[2];

      if (language.length > 0) {
        rval['@language'] = language;

        if (!language.match(REGEX_BCP47)) {
          console.warn("@language must be valid BCP47: ".concat(language));
        }
      }

      rval['@direction'] = direction;
    } else if (type !== XSD_STRING) {
      rval['@type'] = type;
    }
  }

  return rval;
}

},{"./JsonLdError":91,"./constants":98,"./graphTypes":106,"./types":110,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/regenerator":30}],106:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var types = require('./types');

var api = {};
module.exports = api;
/**
 * Returns true if the given value is a subject with properties.
 *
 * @param v the value to check.
 *
 * @return true if the value is a subject with properties, false if not.
 */

api.isSubject = function (v) {
  // Note: A value is a subject if all of these hold true:
  // 1. It is an Object.
  // 2. It is not a @value, @set, or @list.
  // 3. It has more than 1 key OR any existing key is not @id.
  if (types.isObject(v) && !('@value' in v || '@set' in v || '@list' in v)) {
    var keyCount = Object.keys(v).length;
    return keyCount > 1 || !('@id' in v);
  }

  return false;
};
/**
 * Returns true if the given value is a subject reference.
 *
 * @param v the value to check.
 *
 * @return true if the value is a subject reference, false if not.
 */


api.isSubjectReference = function (v) {
  return (// Note: A value is a subject reference if all of these hold true:
    // 1. It is an Object.
    // 2. It has a single key: @id.
    types.isObject(v) && Object.keys(v).length === 1 && '@id' in v
  );
};
/**
 * Returns true if the given value is a @value.
 *
 * @param v the value to check.
 *
 * @return true if the value is a @value, false if not.
 */


api.isValue = function (v) {
  return (// Note: A value is a @value if all of these hold true:
    // 1. It is an Object.
    // 2. It has the @value property.
    types.isObject(v) && '@value' in v
  );
};
/**
 * Returns true if the given value is a @list.
 *
 * @param v the value to check.
 *
 * @return true if the value is a @list, false if not.
 */


api.isList = function (v) {
  return (// Note: A value is a @list if all of these hold true:
    // 1. It is an Object.
    // 2. It has the @list property.
    types.isObject(v) && '@list' in v
  );
};
/**
 * Returns true if the given value is a @graph.
 *
 * @return true if the value is a @graph, false if not.
 */


api.isGraph = function (v) {
  // Note: A value is a graph if all of these hold true:
  // 1. It is an object.
  // 2. It has an `@graph` key.
  // 3. It may have '@id' or '@index'
  return types.isObject(v) && '@graph' in v && Object.keys(v).filter(function (key) {
    return key !== '@id' && key !== '@index';
  }).length === 1;
};
/**
 * Returns true if the given value is a simple @graph.
 *
 * @return true if the value is a simple @graph, false if not.
 */


api.isSimpleGraph = function (v) {
  // Note: A value is a simple graph if all of these hold true:
  // 1. It is an object.
  // 2. It has an `@graph` key.
  // 3. It has only 1 key or 2 keys where one of them is `@index`.
  return api.isGraph(v) && !('@id' in v);
};
/**
 * Returns true if the given value is a blank node.
 *
 * @param v the value to check.
 *
 * @return true if the value is a blank node, false if not.
 */


api.isBlankNode = function (v) {
  // Note: A value is a blank node if all of these hold true:
  // 1. It is an Object.
  // 2. If it has an @id key its value begins with '_:'.
  // 3. It has no keys OR is not a @value, @set, or @list.
  if (types.isObject(v)) {
    if ('@id' in v) {
      return v['@id'].indexOf('_:') === 0;
    }

    return Object.keys(v).length === 0 || !('@value' in v || '@set' in v || '@list' in v);
  }

  return false;
};

},{"./types":110}],107:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2019 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var canonize = require('rdf-canonize');

var util = require('./util');

var ContextResolver = require('./ContextResolver');

var IdentifierIssuer = util.IdentifierIssuer;

var JsonLdError = require('./JsonLdError');

var LRU = require('lru-cache');

var NQuads = require('./NQuads');

var Rdfa = require('./Rdfa');

var _require = require('./expand'),
    _expand = _require.expand;

var _require2 = require('./flatten'),
    _flatten = _require2.flatten;

var _require3 = require('./fromRdf'),
    _fromRDF = _require3.fromRDF;

var _require4 = require('./toRdf'),
    _toRDF = _require4.toRDF;

var _require5 = require('./frame'),
    _frameMergedOrDefault = _require5.frameMergedOrDefault,
    _cleanupNull = _require5.cleanupNull;

var _require6 = require('./types'),
    _isArray = _require6.isArray,
    _isObject = _require6.isObject,
    _isString = _require6.isString;

var _require7 = require('./graphTypes'),
    _isSubjectReference = _require7.isSubjectReference;

var _require8 = require('./context'),
    _expandIri = _require8.expandIri,
    _getInitialContext = _require8.getInitialContext,
    _processContext = _require8.process,
    _processingMode = _require8.processingMode;

var _require9 = require('./compact'),
    _compact = _require9.compact,
    _compactIri = _require9.compactIri;

var _require10 = require('./nodeMap'),
    _createNodeMap = _require10.createNodeMap,
    _createMergedNodeMap = _require10.createMergedNodeMap,
    _mergeNodeMaps = _require10.mergeNodeMaps; // determine if in-browser or using Node.js


var _nodejs = typeof process !== 'undefined' && process.versions && process.versions.node;

var _browser = !_nodejs && (typeof window !== 'undefined' || typeof self !== 'undefined');
/* eslint-disable indent */
// attaches jsonld API to the given object


var wrapper = function wrapper(jsonld) {
  /** Registered RDF dataset parsers hashed by content-type. */
  var _rdfParsers = {}; // resolved context cache
  // TODO: consider basing max on context size rather than number

  var RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;

  var _resolvedContextCache = new LRU({
    max: RESOLVED_CONTEXT_CACHE_MAX_SIZE
  });
  /* Core API */

  /**
   * Performs JSON-LD compaction.
   *
   * @param input the JSON-LD input to compact.
   * @param ctx the context to compact with.
   * @param [options] options to use:
   *          [base] the base IRI to use.
   *          [compactArrays] true to compact arrays to single values when
   *            appropriate, false not to (default: true).
   *          [compactToRelative] true to compact IRIs to be relative to document
   *            base, false to keep absolute (default: true)
   *          [graph] true to always output a top-level graph (default: false).
   *          [expandContext] a context to expand with.
   *          [skipExpansion] true to assume the input is expanded and skip
   *            expansion, false not to, defaults to false.
   *          [documentLoader(url, options)] the document loader.
   *          [expansionMap(info)] a function that can be used to custom map
   *            unmappable values (or to throw an error when they are detected);
   *            if this function returns `undefined` then the default behavior
   *            will be used.
   *          [framing] true if compaction is occuring during a framing operation.
   *          [compactionMap(info)] a function that can be used to custom map
   *            unmappable values (or to throw an error when they are detected);
   *            if this function returns `undefined` then the default behavior
   *            will be used.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the compacted output.
   */


  jsonld.compact = /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(input, ctx, options) {
      var expanded,
          activeCtx,
          compacted,
          tmp,
          i,
          hasContext,
          graphAlias,
          graph,
          _graph,
          key,
          _args = arguments;

      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(_args.length < 2)) {
                _context.next = 2;
                break;
              }

              throw new TypeError('Could not compact, too few arguments.');

            case 2:
              if (!(ctx === null)) {
                _context.next = 4;
                break;
              }

              throw new JsonLdError('The compaction context must not be null.', 'jsonld.CompactError', {
                code: 'invalid local context'
              });

            case 4:
              if (!(input === null)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", null);

            case 6:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                compactArrays: true,
                compactToRelative: true,
                graph: false,
                skipExpansion: false,
                link: false,
                issuer: new IdentifierIssuer('_:b'),
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              });

              if (options.link) {
                // force skip expansion when linking, "link" is not part of the public
                // API, it should only be called from framing
                options.skipExpansion = true;
              }

              if (!options.compactToRelative) {
                delete options.base;
              } // expand input


              if (!options.skipExpansion) {
                _context.next = 13;
                break;
              }

              expanded = input;
              _context.next = 16;
              break;

            case 13:
              _context.next = 15;
              return jsonld.expand(input, options);

            case 15:
              expanded = _context.sent;

            case 16:
              _context.next = 18;
              return jsonld.processContext(_getInitialContext(options), ctx, options);

            case 18:
              activeCtx = _context.sent;
              _context.next = 21;
              return _compact({
                activeCtx: activeCtx,
                element: expanded,
                options: options,
                compactionMap: options.compactionMap
              });

            case 21:
              compacted = _context.sent;

              // perform clean up
              if (options.compactArrays && !options.graph && _isArray(compacted)) {
                if (compacted.length === 1) {
                  // simplify to a single item
                  compacted = compacted[0];
                } else if (compacted.length === 0) {
                  // simplify to an empty object
                  compacted = {};
                }
              } else if (options.graph && _isObject(compacted)) {
                // always use array if graph option is on
                compacted = [compacted];
              } // follow @context key


              if (_isObject(ctx) && '@context' in ctx) {
                ctx = ctx['@context'];
              } // build output context


              ctx = util.clone(ctx);

              if (!_isArray(ctx)) {
                ctx = [ctx];
              } // remove empty contexts


              tmp = ctx;
              ctx = [];

              for (i = 0; i < tmp.length; ++i) {
                if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {
                  ctx.push(tmp[i]);
                }
              } // remove array if only one context


              hasContext = ctx.length > 0;

              if (ctx.length === 1) {
                ctx = ctx[0];
              } // add context and/or @graph


              if (_isArray(compacted)) {
                // use '@graph' keyword
                graphAlias = _compactIri({
                  activeCtx: activeCtx,
                  iri: '@graph',
                  relativeTo: {
                    vocab: true
                  }
                });
                graph = compacted;
                compacted = {};

                if (hasContext) {
                  compacted['@context'] = ctx;
                }

                compacted[graphAlias] = graph;
              } else if (_isObject(compacted) && hasContext) {
                // reorder keys so @context is first
                _graph = compacted;
                compacted = {
                  '@context': ctx
                };

                for (key in _graph) {
                  compacted[key] = _graph[key];
                }
              }

              return _context.abrupt("return", compacted);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * Performs JSON-LD expansion.
   *
   * @param input the JSON-LD input to expand.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [keepFreeFloatingNodes] true to keep free-floating nodes,
   *            false not to, defaults to false.
   *          [documentLoader(url, options)] the document loader.
   *          [expansionMap(info)] a function that can be used to custom map
   *            unmappable values (or to throw an error when they are detected);
   *            if this function returns `undefined` then the default behavior
   *            will be used.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the expanded output.
   */


  jsonld.expand = /*#__PURE__*/function () {
    var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(input, options) {
      var toResolve,
          contextsToProcess,
          expandContext,
          defaultBase,
          remoteDoc,
          activeCtx,
          _i,
          _contextsToProcess,
          localCtx,
          expanded,
          _args2 = arguments;

      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(_args2.length < 1)) {
                _context2.next = 2;
                break;
              }

              throw new TypeError('Could not expand, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                keepFreeFloatingNodes: false,
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              });

              if (options.expansionMap === false) {
                options.expansionMap = undefined;
              } // build set of objects that may have @contexts to resolve


              toResolve = {}; // build set of contexts to process prior to expansion

              contextsToProcess = []; // if an `expandContext` has been given ensure it gets resolved

              if ('expandContext' in options) {
                expandContext = util.clone(options.expandContext);

                if (_isObject(expandContext) && '@context' in expandContext) {
                  toResolve.expandContext = expandContext;
                } else {
                  toResolve.expandContext = {
                    '@context': expandContext
                  };
                }

                contextsToProcess.push(toResolve.expandContext);
              } // if input is a string, attempt to dereference remote document


              if (_isString(input)) {
                _context2.next = 11;
                break;
              }

              // input is not a URL, do not need to retrieve it first
              toResolve.input = util.clone(input);
              _context2.next = 17;
              break;

            case 11:
              _context2.next = 13;
              return jsonld.get(input, options);

            case 13:
              remoteDoc = _context2.sent;
              defaultBase = remoteDoc.documentUrl;
              toResolve.input = remoteDoc.document;

              if (remoteDoc.contextUrl) {
                // context included in HTTP link header and must be resolved
                toResolve.remoteContext = {
                  '@context': remoteDoc.contextUrl
                };
                contextsToProcess.push(toResolve.remoteContext);
              }

            case 17:
              // set default base
              if (!('base' in options)) {
                options.base = defaultBase || '';
              } // process any additional contexts


              activeCtx = _getInitialContext(options);
              _i = 0, _contextsToProcess = contextsToProcess;

            case 20:
              if (!(_i < _contextsToProcess.length)) {
                _context2.next = 28;
                break;
              }

              localCtx = _contextsToProcess[_i];
              _context2.next = 24;
              return _processContext({
                activeCtx: activeCtx,
                localCtx: localCtx,
                options: options
              });

            case 24:
              activeCtx = _context2.sent;

            case 25:
              _i++;
              _context2.next = 20;
              break;

            case 28:
              _context2.next = 30;
              return _expand({
                activeCtx: activeCtx,
                element: toResolve.input,
                options: options,
                expansionMap: options.expansionMap
              });

            case 30:
              expanded = _context2.sent;

              // optimize away @graph with no other properties
              if (_isObject(expanded) && '@graph' in expanded && Object.keys(expanded).length === 1) {
                expanded = expanded['@graph'];
              } else if (expanded === null) {
                expanded = [];
              } // normalize to an array


              if (!_isArray(expanded)) {
                expanded = [expanded];
              }

              return _context2.abrupt("return", expanded);

            case 34:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x4, _x5) {
      return _ref2.apply(this, arguments);
    };
  }();
  /**
   * Performs JSON-LD flattening.
   *
   * @param input the JSON-LD to flatten.
   * @param ctx the context to use to compact the flattened output, or null.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the flattened output.
   */


  jsonld.flatten = /*#__PURE__*/function () {
    var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(input, ctx, options) {
      var expanded,
          flattened,
          compacted,
          _args3 = arguments;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(_args3.length < 1)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", new TypeError('Could not flatten, too few arguments.'));

            case 2:
              if (typeof ctx === 'function') {
                ctx = null;
              } else {
                ctx = ctx || null;
              } // set default options


              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // expand input

              _context3.next = 6;
              return jsonld.expand(input, options);

            case 6:
              expanded = _context3.sent;
              // do flattening
              flattened = _flatten(expanded);

              if (!(ctx === null)) {
                _context3.next = 10;
                break;
              }

              return _context3.abrupt("return", flattened);

            case 10:
              // compact result (force @graph option to true, skip expansion)
              options.graph = true;
              options.skipExpansion = true;
              _context3.next = 14;
              return jsonld.compact(flattened, ctx, options);

            case 14:
              compacted = _context3.sent;
              return _context3.abrupt("return", compacted);

            case 16:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x6, _x7, _x8) {
      return _ref3.apply(this, arguments);
    };
  }();
  /**
   * Performs JSON-LD framing.
   *
   * @param input the JSON-LD input to frame.
   * @param frame the JSON-LD frame to use.
   * @param [options] the framing options.
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [embed] default @embed flag: '@last', '@always', '@never', '@link'
   *            (default: '@last').
   *          [explicit] default @explicit flag (default: false).
   *          [requireAll] default @requireAll flag (default: true).
   *          [omitDefault] default @omitDefault flag (default: false).
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the framed output.
   */


  jsonld.frame = /*#__PURE__*/function () {
    var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(input, frame, options) {
      var remoteDoc,
          ctx,
          frameContext,
          activeCtx,
          expanded,
          opts,
          expandedFrame,
          frameKeys,
          framed,
          compacted,
          _args4 = arguments;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(_args4.length < 2)) {
                _context4.next = 2;
                break;
              }

              throw new TypeError('Could not frame, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                embed: '@once',
                explicit: false,
                requireAll: false,
                omitDefault: false,
                bnodesToClear: [],
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // if frame is a string, attempt to dereference remote document

              if (!_isString(frame)) {
                _context4.next = 9;
                break;
              }

              _context4.next = 6;
              return jsonld.get(frame, options);

            case 6:
              remoteDoc = _context4.sent;
              frame = remoteDoc.document;

              if (remoteDoc.contextUrl) {
                // inject link header @context into frame
                ctx = frame['@context'];

                if (!ctx) {
                  ctx = remoteDoc.contextUrl;
                } else if (_isArray(ctx)) {
                  ctx.push(remoteDoc.contextUrl);
                } else {
                  ctx = [ctx, remoteDoc.contextUrl];
                }

                frame['@context'] = ctx;
              }

            case 9:
              frameContext = frame ? frame['@context'] || {} : {}; // process context

              _context4.next = 12;
              return jsonld.processContext(_getInitialContext(options), frameContext, options);

            case 12:
              activeCtx = _context4.sent;

              // mode specific defaults
              if (!options.hasOwnProperty('omitGraph')) {
                options.omitGraph = _processingMode(activeCtx, 1.1);
              }

              if (!options.hasOwnProperty('pruneBlankNodeIdentifiers')) {
                options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);
              } // expand input


              _context4.next = 17;
              return jsonld.expand(input, options);

            case 17:
              expanded = _context4.sent;
              // expand frame
              opts = _objectSpread({}, options);
              opts.isFrame = true;
              opts.keepFreeFloatingNodes = true;
              _context4.next = 23;
              return jsonld.expand(frame, opts);

            case 23:
              expandedFrame = _context4.sent;
              // if the unexpanded frame includes a key expanding to @graph, frame the
              // default graph, otherwise, the merged graph
              frameKeys = Object.keys(frame).map(function (key) {
                return _expandIri(activeCtx, key, {
                  vocab: true
                });
              });
              opts.merged = !frameKeys.includes('@graph');
              opts.is11 = _processingMode(activeCtx, 1.1); // do framing

              framed = _frameMergedOrDefault(expanded, expandedFrame, opts);
              opts.graph = !options.omitGraph;
              opts.skipExpansion = true;
              opts.link = {};
              opts.framing = true;
              _context4.next = 34;
              return jsonld.compact(framed, frameContext, opts);

            case 34:
              compacted = _context4.sent;
              // replace @null with null, compacting arrays
              opts.link = {};
              compacted = _cleanupNull(compacted, opts);
              return _context4.abrupt("return", compacted);

            case 38:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x9, _x10, _x11) {
      return _ref4.apply(this, arguments);
    };
  }();
  /**
   * **Experimental**
   *
   * Links a JSON-LD document's nodes in memory.
   *
   * @param input the JSON-LD document to link.
   * @param [ctx] the JSON-LD context to apply.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the linked output.
   */


  jsonld.link = /*#__PURE__*/function () {
    var _ref5 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(input, ctx, options) {
      var frame;
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              // API matches running frame with a wildcard frame and embed: '@link'
              // get arguments
              frame = {};

              if (ctx) {
                frame['@context'] = ctx;
              }

              frame['@embed'] = '@link';
              return _context5.abrupt("return", jsonld.frame(input, frame, options));

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function (_x12, _x13, _x14) {
      return _ref5.apply(this, arguments);
    };
  }();
  /**
   * Performs RDF dataset normalization on the given input. The input is JSON-LD
   * unless the 'inputFormat' option is used. The output is an RDF dataset
   * unless the 'format' option is used.
   *
   * @param input the input to normalize as JSON-LD or as a format specified by
   *          the 'inputFormat' option.
   * @param [options] the options to use:
   *          [algorithm] the normalization algorithm to use, `URDNA2015` or
   *            `URGNA2012` (default: `URDNA2015`).
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [skipExpansion] true to assume the input is expanded and skip
   *            expansion, false not to, defaults to false.
   *          [inputFormat] the format if input is not JSON-LD:
   *            'application/n-quads' for N-Quads.
   *          [format] the format if output is a string:
   *            'application/n-quads' for N-Quads.
   *          [documentLoader(url, options)] the document loader.
   *          [useNative] true to use a native canonize algorithm
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the normalized output.
   */


  jsonld.normalize = jsonld.canonize = /*#__PURE__*/function () {
    var _ref6 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(input, options) {
      var parsedInput,
          opts,
          dataset,
          _args6 = arguments;
      return _regenerator["default"].wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!(_args6.length < 1)) {
                _context6.next = 2;
                break;
              }

              throw new TypeError('Could not canonize, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                algorithm: 'URDNA2015',
                skipExpansion: false,
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              });

              if (!('inputFormat' in options)) {
                _context6.next = 8;
                break;
              }

              if (!(options.inputFormat !== 'application/n-quads' && options.inputFormat !== 'application/nquads')) {
                _context6.next = 6;
                break;
              }

              throw new JsonLdError('Unknown canonicalization input format.', 'jsonld.CanonizeError');

            case 6:
              // TODO: `await` for async parsers
              parsedInput = NQuads.parse(input); // do canonicalization

              return _context6.abrupt("return", canonize.canonize(parsedInput, options));

            case 8:
              // convert to RDF dataset then do normalization
              opts = _objectSpread({}, options);
              delete opts.format;
              opts.produceGeneralizedRdf = false;
              _context6.next = 13;
              return jsonld.toRDF(input, opts);

            case 13:
              dataset = _context6.sent;
              return _context6.abrupt("return", canonize.canonize(dataset, options));

            case 15:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function (_x15, _x16) {
      return _ref6.apply(this, arguments);
    };
  }();
  /**
   * Converts an RDF dataset to JSON-LD.
   *
   * @param dataset a serialized string of RDF in a format specified by the
   *          format option or an RDF dataset to convert.
   * @param [options] the options to use:
   *          [format] the format if dataset param must first be parsed:
   *            'application/n-quads' for N-Quads (default).
   *          [rdfParser] a custom RDF-parser to use to parse the dataset.
   *          [useRdfType] true to use rdf:type, false to use @type
   *            (default: false).
   *          [useNativeTypes] true to convert XSD types into native types
   *            (boolean, integer, double), false not to (default: false).
   *
   * @return a Promise that resolves to the JSON-LD document.
   */


  jsonld.fromRDF = /*#__PURE__*/function () {
    var _ref7 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(dataset, options) {
      var _options,
          format,
          _options2,
          rdfParser,
          parsedDataset,
          _args7 = arguments;

      return _regenerator["default"].wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!(_args7.length < 1)) {
                _context7.next = 2;
                break;
              }

              throw new TypeError('Could not convert from RDF, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                format: _isString(dataset) ? 'application/n-quads' : undefined
              });
              _options = options, format = _options.format;
              _options2 = options, rdfParser = _options2.rdfParser; // handle special format

              if (!format) {
                _context7.next = 11;
                break;
              }

              // check supported formats
              rdfParser = rdfParser || _rdfParsers[format];

              if (rdfParser) {
                _context7.next = 9;
                break;
              }

              throw new JsonLdError('Unknown input format.', 'jsonld.UnknownFormat', {
                format: format
              });

            case 9:
              _context7.next = 12;
              break;

            case 11:
              // no-op parser, assume dataset already parsed
              rdfParser = function rdfParser() {
                return dataset;
              };

            case 12:
              _context7.next = 14;
              return rdfParser(dataset);

            case 14:
              parsedDataset = _context7.sent;
              return _context7.abrupt("return", _fromRDF(parsedDataset, options));

            case 16:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function (_x17, _x18) {
      return _ref7.apply(this, arguments);
    };
  }();
  /**
   * Outputs the RDF dataset found in the given JSON-LD object.
   *
   * @param input the JSON-LD input.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [skipExpansion] true to assume the input is expanded and skip
   *            expansion, false not to, defaults to false.
   *          [format] the format to use to output a string:
   *            'application/n-quads' for N-Quads.
   *          [produceGeneralizedRdf] true to output generalized RDF, false
   *            to produce only standard RDF (default: false).
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the RDF dataset.
   */


  jsonld.toRDF = /*#__PURE__*/function () {
    var _ref8 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(input, options) {
      var expanded,
          dataset,
          _args8 = arguments;
      return _regenerator["default"].wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (!(_args8.length < 1)) {
                _context8.next = 2;
                break;
              }

              throw new TypeError('Could not convert to RDF, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                skipExpansion: false,
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // TODO: support toRDF custom map?

              if (!options.skipExpansion) {
                _context8.next = 7;
                break;
              }

              expanded = input;
              _context8.next = 10;
              break;

            case 7:
              _context8.next = 9;
              return jsonld.expand(input, options);

            case 9:
              expanded = _context8.sent;

            case 10:
              // output RDF dataset
              dataset = _toRDF(expanded, options);

              if (!options.format) {
                _context8.next = 17;
                break;
              }

              if (!(options.format === 'application/n-quads' || options.format === 'application/nquads')) {
                _context8.next = 16;
                break;
              }

              _context8.next = 15;
              return NQuads.serialize(dataset);

            case 15:
              return _context8.abrupt("return", _context8.sent);

            case 16:
              throw new JsonLdError('Unknown output format.', 'jsonld.UnknownFormat', {
                format: options.format
              });

            case 17:
              return _context8.abrupt("return", dataset);

            case 18:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    return function (_x19, _x20) {
      return _ref8.apply(this, arguments);
    };
  }();
  /**
   * **Experimental**
   *
   * Recursively flattens the nodes in the given JSON-LD input into a merged
   * map of node ID => node. All graphs will be merged into the default graph.
   *
   * @param input the JSON-LD input.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the merged node map.
   */


  jsonld.createNodeMap = /*#__PURE__*/function () {
    var _ref9 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(input, options) {
      var expanded,
          _args9 = arguments;
      return _regenerator["default"].wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (!(_args9.length < 1)) {
                _context9.next = 2;
                break;
              }

              throw new TypeError('Could not create node map, too few arguments.');

            case 2:
              // set default options
              options = _setDefaults(options, {
                base: _isString(input) ? input : '',
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // expand input

              _context9.next = 5;
              return jsonld.expand(input, options);

            case 5:
              expanded = _context9.sent;
              return _context9.abrupt("return", _createMergedNodeMap(expanded, options));

            case 7:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));

    return function (_x21, _x22) {
      return _ref9.apply(this, arguments);
    };
  }();
  /**
   * **Experimental**
   *
   * Merges two or more JSON-LD documents into a single flattened document.
   *
   * @param docs the JSON-LD documents to merge together.
   * @param ctx the context to use to compact the merged result, or null.
   * @param [options] the options to use:
   *          [base] the base IRI to use.
   *          [expandContext] a context to expand with.
   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.
   *          [mergeNodes] true to merge properties for nodes with the same ID,
   *            false to ignore new properties for nodes with the same ID once
   *            the ID has been defined; note that this may not prevent merging
   *            new properties where a node is in the `object` position
   *            (default: true).
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the merged output.
   */


  jsonld.merge = /*#__PURE__*/function () {
    var _ref10 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(docs, ctx, options) {
      var expanded,
          mergeNodes,
          issuer,
          graphs,
          i,
          doc,
          _graphs,
          graphName,
          _nodeMap,
          nodeMap,
          key,
          defaultGraph,
          flattened,
          keys,
          ki,
          node,
          compacted,
          _args10 = arguments;

      return _regenerator["default"].wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (!(_args10.length < 1)) {
                _context10.next = 2;
                break;
              }

              throw new TypeError('Could not merge, too few arguments.');

            case 2:
              if (_isArray(docs)) {
                _context10.next = 4;
                break;
              }

              throw new TypeError('Could not merge, "docs" must be an array.');

            case 4:
              if (typeof ctx === 'function') {
                ctx = null;
              } else {
                ctx = ctx || null;
              } // set default options


              options = _setDefaults(options, {
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // expand all documents

              _context10.next = 8;
              return Promise.all(docs.map(function (doc) {
                var opts = _objectSpread({}, options);

                return jsonld.expand(doc, opts);
              }));

            case 8:
              expanded = _context10.sent;
              mergeNodes = true;

              if ('mergeNodes' in options) {
                mergeNodes = options.mergeNodes;
              }

              issuer = options.issuer || new IdentifierIssuer('_:b');
              graphs = {
                '@default': {}
              };
              i = 0;

            case 14:
              if (!(i < expanded.length)) {
                _context10.next = 33;
                break;
              }

              // uniquely relabel blank nodes
              doc = util.relabelBlankNodes(expanded[i], {
                issuer: new IdentifierIssuer('_:b' + i + '-')
              }); // add nodes to the shared node map graphs if merging nodes, to a
              // separate graph set if not

              _graphs = mergeNodes || i === 0 ? graphs : {
                '@default': {}
              };

              _createNodeMap(doc, _graphs, '@default', issuer);

              if (!(_graphs !== graphs)) {
                _context10.next = 30;
                break;
              }

              _context10.t0 = _regenerator["default"].keys(_graphs);

            case 20:
              if ((_context10.t1 = _context10.t0()).done) {
                _context10.next = 30;
                break;
              }

              graphName = _context10.t1.value;
              _nodeMap = _graphs[graphName];

              if (graphName in graphs) {
                _context10.next = 26;
                break;
              }

              graphs[graphName] = _nodeMap;
              return _context10.abrupt("continue", 20);

            case 26:
              nodeMap = graphs[graphName];

              for (key in _nodeMap) {
                if (!(key in nodeMap)) {
                  nodeMap[key] = _nodeMap[key];
                }
              }

              _context10.next = 20;
              break;

            case 30:
              ++i;
              _context10.next = 14;
              break;

            case 33:
              // add all non-default graphs to default graph
              defaultGraph = _mergeNodeMaps(graphs); // produce flattened output

              flattened = [];
              keys = Object.keys(defaultGraph).sort();

              for (ki = 0; ki < keys.length; ++ki) {
                node = defaultGraph[keys[ki]]; // only add full subjects to top-level

                if (!_isSubjectReference(node)) {
                  flattened.push(node);
                }
              }

              if (!(ctx === null)) {
                _context10.next = 39;
                break;
              }

              return _context10.abrupt("return", flattened);

            case 39:
              // compact result (force @graph option to true, skip expansion)
              options.graph = true;
              options.skipExpansion = true;
              _context10.next = 43;
              return jsonld.compact(flattened, ctx, options);

            case 43:
              compacted = _context10.sent;
              return _context10.abrupt("return", compacted);

            case 45:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));

    return function (_x23, _x24, _x25) {
      return _ref10.apply(this, arguments);
    };
  }();
  /**
   * The default document loader for external documents.
   *
   * @param url the URL to load.
   *
   * @return a promise that resolves to the remote document.
   */


  Object.defineProperty(jsonld, 'documentLoader', {
    get: function get() {
      return jsonld._documentLoader;
    },
    set: function set(v) {
      return jsonld._documentLoader = v;
    }
  }); // default document loader not implemented

  jsonld.documentLoader = /*#__PURE__*/function () {
    var _ref11 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(url) {
      return _regenerator["default"].wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              throw new JsonLdError('Could not retrieve a JSON-LD document from the URL. URL ' + 'dereferencing not implemented.', 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                url: url
              });

            case 1:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));

    return function (_x26) {
      return _ref11.apply(this, arguments);
    };
  }();
  /**
   * Gets a remote JSON-LD document using the default document loader or
   * one given in the passed options.
   *
   * @param url the URL to fetch.
   * @param [options] the options to use:
   *          [documentLoader] the document loader to use.
   *
   * @return a Promise that resolves to the retrieved remote document.
   */


  jsonld.get = /*#__PURE__*/function () {
    var _ref12 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(url, options) {
      var load, remoteDoc;
      return _regenerator["default"].wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (typeof options.documentLoader === 'function') {
                load = options.documentLoader;
              } else {
                load = jsonld.documentLoader;
              }

              _context12.next = 3;
              return load(url);

            case 3:
              remoteDoc = _context12.sent;
              _context12.prev = 4;

              if (remoteDoc.document) {
                _context12.next = 7;
                break;
              }

              throw new JsonLdError('No remote document found at the given URL.', 'jsonld.NullRemoteDocument');

            case 7:
              if (_isString(remoteDoc.document)) {
                remoteDoc.document = JSON.parse(remoteDoc.document);
              }

              _context12.next = 13;
              break;

            case 10:
              _context12.prev = 10;
              _context12.t0 = _context12["catch"](4);
              throw new JsonLdError('Could not retrieve a JSON-LD document from the URL.', 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                cause: _context12.t0,
                remoteDoc: remoteDoc
              });

            case 13:
              return _context12.abrupt("return", remoteDoc);

            case 14:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, null, [[4, 10]]);
    }));

    return function (_x27, _x28) {
      return _ref12.apply(this, arguments);
    };
  }();
  /**
   * Processes a local context, resolving any URLs as necessary, and returns a
   * new active context.
   *
   * @param activeCtx the current active context.
   * @param localCtx the local context to process.
   * @param [options] the options to use:
   *          [documentLoader(url, options)] the document loader.
   *          [contextResolver] internal use only.
   *
   * @return a Promise that resolves to the new active context.
   */


  jsonld.processContext = /*#__PURE__*/function () {
    var _ref13 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(activeCtx, localCtx, options) {
      return _regenerator["default"].wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              // set default options
              options = _setDefaults(options, {
                base: '',
                contextResolver: new ContextResolver({
                  sharedCache: _resolvedContextCache
                })
              }); // return initial context early for null context

              if (!(localCtx === null)) {
                _context13.next = 3;
                break;
              }

              return _context13.abrupt("return", _getInitialContext(options));

            case 3:
              // get URLs in localCtx
              localCtx = util.clone(localCtx);

              if (!(_isObject(localCtx) && '@context' in localCtx)) {
                localCtx = {
                  '@context': localCtx
                };
              }

              return _context13.abrupt("return", _processContext({
                activeCtx: activeCtx,
                localCtx: localCtx,
                options: options
              }));

            case 6:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    }));

    return function (_x29, _x30, _x31) {
      return _ref13.apply(this, arguments);
    };
  }(); // backwards compatibility


  jsonld.getContextValue = require('./context').getContextValue;
  /**
   * Document loaders.
   */

  jsonld.documentLoaders = {};
  jsonld.documentLoaders.node = require('./documentLoaders/node');
  jsonld.documentLoaders.xhr = require('./documentLoaders/xhr');
  /**
   * Assigns the default document loader for external document URLs to a built-in
   * default. Supported types currently include: 'xhr' and 'node'.
   *
   * @param type the type to set.
   * @param [params] the parameters required to use the document loader.
   */

  jsonld.useDocumentLoader = function (type) {
    if (!(type in jsonld.documentLoaders)) {
      throw new JsonLdError('Unknown document loader type: "' + type + '"', 'jsonld.UnknownDocumentLoader', {
        type: type
      });
    } // set document loader


    jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));
  };
  /**
   * Registers an RDF dataset parser by content-type, for use with
   * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,
   * a string of input. An RDF dataset parser can be synchronous or
   * asynchronous (by returning a promise).
   *
   * @param contentType the content-type for the parser.
   * @param parser(input) the parser function (takes a string as a parameter
   *          and either returns an RDF dataset or a Promise that resolves to one.
   */


  jsonld.registerRDFParser = function (contentType, parser) {
    _rdfParsers[contentType] = parser;
  };
  /**
   * Unregisters an RDF dataset parser by content-type.
   *
   * @param contentType the content-type for the parser.
   */


  jsonld.unregisterRDFParser = function (contentType) {
    delete _rdfParsers[contentType];
  }; // register the N-Quads RDF parser


  jsonld.registerRDFParser('application/n-quads', NQuads.parse);
  jsonld.registerRDFParser('application/nquads', NQuads.parse); // register the RDFa API RDF parser

  jsonld.registerRDFParser('rdfa-api', Rdfa.parse);
  /* URL API */

  jsonld.url = require('./url');
  /* Utility API */

  jsonld.util = util; // backwards compatibility

  Object.assign(jsonld, util); // reexpose API as jsonld.promises for backwards compatability

  jsonld.promises = jsonld; // backwards compatibility

  jsonld.RequestQueue = require('./RequestQueue');
  /* WebIDL API */

  jsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld); // setup browser global JsonLdProcessor

  if (_browser && typeof global.JsonLdProcessor === 'undefined') {
    Object.defineProperty(global, 'JsonLdProcessor', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: jsonld.JsonLdProcessor
    });
  } // set platform-specific defaults/APIs


  if (_nodejs) {
    // use node document loader by default
    jsonld.useDocumentLoader('node');
  } else if (typeof XMLHttpRequest !== 'undefined') {
    // use xhr document loader by default
    jsonld.useDocumentLoader('xhr');
  }

  function _setDefaults(options, _ref14) {
    var _ref14$documentLoader = _ref14.documentLoader,
        documentLoader = _ref14$documentLoader === void 0 ? jsonld.documentLoader : _ref14$documentLoader,
        defaults = (0, _objectWithoutProperties2["default"])(_ref14, ["documentLoader"]);
    return Object.assign({}, {
      documentLoader: documentLoader
    }, defaults, options);
  } // end of jsonld API `wrapper` factory


  return jsonld;
}; // external APIs:
// used to generate a new jsonld API instance


var factory = function factory() {
  return wrapper(function () {
    return factory();
  });
}; // wrap the main jsonld API instance


wrapper(factory); // export API

module.exports = factory;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ContextResolver":90,"./JsonLdError":91,"./JsonLdProcessor":92,"./NQuads":93,"./Rdfa":94,"./RequestQueue":95,"./compact":97,"./context":99,"./documentLoaders/node":100,"./documentLoaders/xhr":101,"./expand":102,"./flatten":103,"./frame":104,"./fromRdf":105,"./graphTypes":106,"./nodeMap":108,"./toRdf":109,"./types":110,"./url":111,"./util":112,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/defineProperty":10,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/objectWithoutProperties":20,"@babel/runtime/regenerator":30,"_process":142,"lru-cache":113,"rdf-canonize":153}],108:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('./context'),
    isKeyword = _require.isKeyword;

var graphTypes = require('./graphTypes');

var types = require('./types');

var util = require('./util');

var JsonLdError = require('./JsonLdError');

var api = {};
module.exports = api;
/**
 * Creates a merged JSON-LD node map (node ID => node).
 *
 * @param input the expanded JSON-LD to create a node map of.
 * @param [options] the options to use:
 *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.
 *
 * @return the node map.
 */

api.createMergedNodeMap = function (input, options) {
  options = options || {}; // produce a map of all subjects and name each bnode

  var issuer = options.issuer || new util.IdentifierIssuer('_:b');
  var graphs = {
    '@default': {}
  };
  api.createNodeMap(input, graphs, '@default', issuer); // add all non-default graphs to default graph

  return api.mergeNodeMaps(graphs);
};
/**
 * Recursively flattens the subjects in the given JSON-LD expanded input
 * into a node map.
 *
 * @param input the JSON-LD expanded input.
 * @param graphs a map of graph name to subject map.
 * @param graph the name of the current graph.
 * @param issuer the blank node identifier issuer.
 * @param name the name assigned to the current input if it is a bnode.
 * @param list the list to append to, null for none.
 */


api.createNodeMap = function (input, graphs, graph, issuer, name, list) {
  // recurse through array
  if (types.isArray(input)) {
    var _iterator = _createForOfIteratorHelper(input),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;
        api.createNodeMap(node, graphs, graph, issuer, undefined, list);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return;
  } // add non-object to list


  if (!types.isObject(input)) {
    if (list) {
      list.push(input);
    }

    return;
  } // add values to list


  if (graphTypes.isValue(input)) {
    if ('@type' in input) {
      var type = input['@type']; // rename @type blank node

      if (type.indexOf('_:') === 0) {
        input['@type'] = type = issuer.getId(type);
      }
    }

    if (list) {
      list.push(input);
    }

    return;
  } else if (list && graphTypes.isList(input)) {
    var _list = [];
    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);
    list.push({
      '@list': _list
    });
    return;
  } // Note: At this point, input must be a subject.
  // spec requires @type to be named first, so assign names early


  if ('@type' in input) {
    var _types = input['@type'];

    var _iterator2 = _createForOfIteratorHelper(_types),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _type = _step2.value;

        if (_type.indexOf('_:') === 0) {
          issuer.getId(_type);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  } // get name for subject


  if (types.isUndefined(name)) {
    name = graphTypes.isBlankNode(input) ? issuer.getId(input['@id']) : input['@id'];
  } // add subject reference to list


  if (list) {
    list.push({
      '@id': name
    });
  } // create new subject or merge into existing one


  var subjects = graphs[graph];
  var subject = subjects[name] = subjects[name] || {};
  subject['@id'] = name;
  var properties = Object.keys(input).sort();

  var _iterator3 = _createForOfIteratorHelper(properties),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var property = _step3.value;

      // skip @id
      if (property === '@id') {
        continue;
      } // handle reverse properties


      if (property === '@reverse') {
        var referencedNode = {
          '@id': name
        };
        var reverseMap = input['@reverse'];

        for (var reverseProperty in reverseMap) {
          var items = reverseMap[reverseProperty];

          var _iterator4 = _createForOfIteratorHelper(items),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var item = _step4.value;
              var itemName = item['@id'];

              if (graphTypes.isBlankNode(item)) {
                itemName = issuer.getId(itemName);
              }

              api.createNodeMap(item, graphs, graph, issuer, itemName);
              util.addValue(subjects[itemName], reverseProperty, referencedNode, {
                propertyIsArray: true,
                allowDuplicate: false
              });
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }

        continue;
      } // recurse into graph


      if (property === '@graph') {
        // add graph subjects map entry
        if (!(name in graphs)) {
          graphs[name] = {};
        }

        api.createNodeMap(input[property], graphs, name, issuer);
        continue;
      } // recurse into included


      if (property === '@included') {
        api.createNodeMap(input[property], graphs, graph, issuer);
        continue;
      } // copy non-@type keywords


      if (property !== '@type' && isKeyword(property)) {
        if (property === '@index' && property in subject && (input[property] !== subject[property] || input[property]['@id'] !== subject[property]['@id'])) {
          throw new JsonLdError('Invalid JSON-LD syntax; conflicting @index property detected.', 'jsonld.SyntaxError', {
            code: 'conflicting indexes',
            subject: subject
          });
        }

        subject[property] = input[property];
        continue;
      } // iterate over objects


      var objects = input[property]; // if property is a bnode, assign it a new id

      if (property.indexOf('_:') === 0) {
        property = issuer.getId(property);
      } // ensure property is added for empty arrays


      if (objects.length === 0) {
        util.addValue(subject, property, [], {
          propertyIsArray: true
        });
        continue;
      }

      var _iterator5 = _createForOfIteratorHelper(objects),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var o = _step5.value;

          if (property === '@type') {
            // rename @type blank nodes
            o = o.indexOf('_:') === 0 ? issuer.getId(o) : o;
          } // handle embedded subject or subject reference


          if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {
            // skip null @id
            if ('@id' in o && !o['@id']) {
              continue;
            } // relabel blank node @id


            var id = graphTypes.isBlankNode(o) ? issuer.getId(o['@id']) : o['@id']; // add reference and recurse

            util.addValue(subject, property, {
              '@id': id
            }, {
              propertyIsArray: true,
              allowDuplicate: false
            });
            api.createNodeMap(o, graphs, graph, issuer, id);
          } else if (graphTypes.isValue(o)) {
            util.addValue(subject, property, o, {
              propertyIsArray: true,
              allowDuplicate: false
            });
          } else if (graphTypes.isList(o)) {
            // handle @list
            var _list2 = [];
            api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list2);
            o = {
              '@list': _list2
            };
            util.addValue(subject, property, o, {
              propertyIsArray: true,
              allowDuplicate: false
            });
          } else {
            // handle @value
            api.createNodeMap(o, graphs, graph, issuer, name);
            util.addValue(subject, property, o, {
              propertyIsArray: true,
              allowDuplicate: false
            });
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
};
/**
 * Merge separate named graphs into a single merged graph including
 * all nodes from the default graph and named graphs.
 *
 * @param graphs a map of graph name to subject map.
 *
 * @return the merged graph map.
 */


api.mergeNodeMapGraphs = function (graphs) {
  var merged = {};

  var _iterator6 = _createForOfIteratorHelper(Object.keys(graphs).sort()),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var name = _step6.value;

      var _iterator7 = _createForOfIteratorHelper(Object.keys(graphs[name]).sort()),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var id = _step7.value;
          var node = graphs[name][id];

          if (!(id in merged)) {
            merged[id] = {
              '@id': id
            };
          }

          var mergedNode = merged[id];

          var _iterator8 = _createForOfIteratorHelper(Object.keys(node).sort()),
              _step8;

          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var property = _step8.value;

              if (isKeyword(property) && property !== '@type') {
                // copy keywords
                mergedNode[property] = util.clone(node[property]);
              } else {
                // merge objects
                var _iterator9 = _createForOfIteratorHelper(node[property]),
                    _step9;

                try {
                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                    var value = _step9.value;
                    util.addValue(mergedNode, property, util.clone(value), {
                      propertyIsArray: true,
                      allowDuplicate: false
                    });
                  }
                } catch (err) {
                  _iterator9.e(err);
                } finally {
                  _iterator9.f();
                }
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return merged;
};

api.mergeNodeMaps = function (graphs) {
  // add all non-default graphs to default graph
  var defaultGraph = graphs['@default'];
  var graphNames = Object.keys(graphs).sort();

  var _iterator10 = _createForOfIteratorHelper(graphNames),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var graphName = _step10.value;

      if (graphName === '@default') {
        continue;
      }

      var nodeMap = graphs[graphName];
      var subject = defaultGraph[graphName];

      if (!subject) {
        defaultGraph[graphName] = subject = {
          '@id': graphName,
          '@graph': []
        };
      } else if (!('@graph' in subject)) {
        subject['@graph'] = [];
      }

      var graph = subject['@graph'];

      var _iterator11 = _createForOfIteratorHelper(Object.keys(nodeMap).sort()),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var id = _step11.value;
          var node = nodeMap[id]; // only add full subjects

          if (!graphTypes.isSubjectReference(node)) {
            graph.push(node);
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  return defaultGraph;
};

},{"./JsonLdError":91,"./context":99,"./graphTypes":106,"./types":110,"./util":112}],109:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('./nodeMap'),
    createNodeMap = _require.createNodeMap;

var _require2 = require('./context'),
    isKeyword = _require2.isKeyword;

var graphTypes = require('./graphTypes');

var jsonCanonicalize = require('canonicalize');

var types = require('./types');

var util = require('./util');

var _require3 = require('./constants'),
    RDF_FIRST = _require3.RDF_FIRST,
    RDF_REST = _require3.RDF_REST,
    RDF_NIL = _require3.RDF_NIL,
    RDF_TYPE = _require3.RDF_TYPE,
    RDF_JSON_LITERAL = _require3.RDF_JSON_LITERAL,
    RDF_LANGSTRING = _require3.RDF_LANGSTRING,
    XSD_BOOLEAN = _require3.XSD_BOOLEAN,
    XSD_DOUBLE = _require3.XSD_DOUBLE,
    XSD_INTEGER = _require3.XSD_INTEGER,
    XSD_STRING = _require3.XSD_STRING;

var _require4 = require('./url'),
    _isAbsoluteIri = _require4.isAbsolute;

var api = {};
module.exports = api;
/**
 * Outputs an RDF dataset for the expanded JSON-LD input.
 *
 * @param input the expanded JSON-LD input.
 * @param options the RDF serialization options.
 *
 * @return the RDF dataset.
 */

api.toRDF = function (input, options) {
  // create node map for default graph (and any named graphs)
  var issuer = new util.IdentifierIssuer('_:b');
  var nodeMap = {
    '@default': {}
  };
  createNodeMap(input, nodeMap, '@default', issuer);
  var dataset = [];
  var graphNames = Object.keys(nodeMap).sort();

  var _iterator = _createForOfIteratorHelper(graphNames),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var graphName = _step.value;
      var graphTerm = void 0;

      if (graphName === '@default') {
        graphTerm = {
          termType: 'DefaultGraph',
          value: ''
        };
      } else if (_isAbsoluteIri(graphName)) {
        if (graphName.startsWith('_:')) {
          graphTerm = {
            termType: 'BlankNode'
          };
        } else {
          graphTerm = {
            termType: 'NamedNode'
          };
        }

        graphTerm.value = graphName;
      } else {
        // skip relative IRIs (not valid RDF)
        continue;
      }

      _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return dataset;
};
/**
 * Adds RDF quads for a particular graph to the given dataset.
 *
 * @param dataset the dataset to append RDF quads to.
 * @param graph the graph to create RDF quads for.
 * @param graphTerm the graph term for each quad.
 * @param issuer a IdentifierIssuer for assigning blank node names.
 * @param options the RDF serialization options.
 *
 * @return the array of RDF triples for the given graph.
 */


function _graphToRDF(dataset, graph, graphTerm, issuer, options) {
  var ids = Object.keys(graph).sort();

  var _iterator2 = _createForOfIteratorHelper(ids),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var id = _step2.value;
      var node = graph[id];
      var properties = Object.keys(node).sort();

      var _iterator3 = _createForOfIteratorHelper(properties),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var property = _step3.value;
          var items = node[property];

          if (property === '@type') {
            property = RDF_TYPE;
          } else if (isKeyword(property)) {
            continue;
          }

          var _iterator4 = _createForOfIteratorHelper(items),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var item = _step4.value;
              // RDF subject
              var subject = {
                termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',
                value: id
              }; // skip relative IRI subjects (not valid RDF)

              if (!_isAbsoluteIri(id)) {
                continue;
              } // RDF predicate


              var predicate = {
                termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',
                value: property
              }; // skip relative IRI predicates (not valid RDF)

              if (!_isAbsoluteIri(property)) {
                continue;
              } // skip blank node predicates unless producing generalized RDF


              if (predicate.termType === 'BlankNode' && !options.produceGeneralizedRdf) {
                continue;
              } // convert list, value or node object to triple


              var object = _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection); // skip null objects (they are relative IRIs)


              if (object) {
                dataset.push({
                  subject: subject,
                  predicate: predicate,
                  object: object,
                  graph: graphTerm
                });
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
/**
 * Converts a @list value into linked list of blank node RDF quads
 * (an RDF collection).
 *
 * @param list the @list value.
 * @param issuer a IdentifierIssuer for assigning blank node names.
 * @param dataset the array of quads to append to.
 * @param graphTerm the graph term for each quad.
 *
 * @return the head of the list.
 */


function _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {
  var first = {
    termType: 'NamedNode',
    value: RDF_FIRST
  };
  var rest = {
    termType: 'NamedNode',
    value: RDF_REST
  };
  var nil = {
    termType: 'NamedNode',
    value: RDF_NIL
  };
  var last = list.pop(); // Result is the head of the list

  var result = last ? {
    termType: 'BlankNode',
    value: issuer.getId()
  } : nil;
  var subject = result;

  var _iterator5 = _createForOfIteratorHelper(list),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var item = _step5.value;

      var _object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);

      var next = {
        termType: 'BlankNode',
        value: issuer.getId()
      };
      dataset.push({
        subject: subject,
        predicate: first,
        object: _object,
        graph: graphTerm
      });
      dataset.push({
        subject: subject,
        predicate: rest,
        object: next,
        graph: graphTerm
      });
      subject = next;
    } // Tail of list

  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  if (last) {
    var object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);

    dataset.push({
      subject: subject,
      predicate: first,
      object: object,
      graph: graphTerm
    });
    dataset.push({
      subject: subject,
      predicate: rest,
      object: nil,
      graph: graphTerm
    });
  }

  return result;
}
/**
 * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,
 * node object to an RDF resource, or adds a list.
 *
 * @param item the JSON-LD value or node object.
 * @param issuer a IdentifierIssuer for assigning blank node names.
 * @param dataset the dataset to append RDF quads to.
 * @param graphTerm the graph term for each quad.
 *
 * @return the RDF literal or RDF resource.
 */


function _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {
  var object = {}; // convert value object to RDF

  if (graphTypes.isValue(item)) {
    object.termType = 'Literal';
    object.value = undefined;
    object.datatype = {
      termType: 'NamedNode'
    };
    var value = item['@value'];
    var datatype = item['@type'] || null; // convert to XSD/JSON datatypes as appropriate

    if (datatype === '@json') {
      object.value = jsonCanonicalize(value);
      object.datatype.value = RDF_JSON_LITERAL;
    } else if (types.isBoolean(value)) {
      object.value = value.toString();
      object.datatype.value = datatype || XSD_BOOLEAN;
    } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {
      if (!types.isDouble(value)) {
        value = parseFloat(value);
      } // canonical double representation


      object.value = value.toExponential(15).replace(/(\d)0*e\+?/, '$1E');
      object.datatype.value = datatype || XSD_DOUBLE;
    } else if (types.isNumber(value)) {
      object.value = value.toFixed(0);
      object.datatype.value = datatype || XSD_INTEGER;
    } else if (rdfDirection === 'i18n-datatype' && '@direction' in item) {
      var _datatype = 'https://www.w3.org/ns/i18n#' + (item['@language'] || '') + "_".concat(item['@direction']);

      object.datatype.value = _datatype;
      object.value = value;
    } else if ('@language' in item) {
      object.value = value;
      object.datatype.value = datatype || RDF_LANGSTRING;
      object.language = item['@language'];
    } else {
      object.value = value;
      object.datatype.value = datatype || XSD_STRING;
    }
  } else if (graphTypes.isList(item)) {
    var _list = _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection);

    object.termType = _list.termType;
    object.value = _list.value;
  } else {
    // convert string/node object to RDF
    var id = types.isObject(item) ? item['@id'] : item;
    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';
    object.value = id;
  } // skip relative IRIs, not valid RDF


  if (object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {
    return null;
  }

  return object;
}

},{"./constants":98,"./context":99,"./graphTypes":106,"./nodeMap":108,"./types":110,"./url":111,"./util":112,"canonicalize":61}],110:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var api = {};
module.exports = api;
/**
 * Returns true if the given value is an Array.
 *
 * @param v the value to check.
 *
 * @return true if the value is an Array, false if not.
 */

api.isArray = Array.isArray;
/**
 * Returns true if the given value is a Boolean.
 *
 * @param v the value to check.
 *
 * @return true if the value is a Boolean, false if not.
 */

api.isBoolean = function (v) {
  return typeof v === 'boolean' || Object.prototype.toString.call(v) === '[object Boolean]';
};
/**
 * Returns true if the given value is a double.
 *
 * @param v the value to check.
 *
 * @return true if the value is a double, false if not.
 */


api.isDouble = function (v) {
  return api.isNumber(v) && (String(v).indexOf('.') !== -1 || Math.abs(v) >= 1e21);
};
/**
 * Returns true if the given value is an empty Object.
 *
 * @param v the value to check.
 *
 * @return true if the value is an empty Object, false if not.
 */


api.isEmptyObject = function (v) {
  return api.isObject(v) && Object.keys(v).length === 0;
};
/**
 * Returns true if the given value is a Number.
 *
 * @param v the value to check.
 *
 * @return true if the value is a Number, false if not.
 */


api.isNumber = function (v) {
  return typeof v === 'number' || Object.prototype.toString.call(v) === '[object Number]';
};
/**
 * Returns true if the given value is numeric.
 *
 * @param v the value to check.
 *
 * @return true if the value is numeric, false if not.
 */


api.isNumeric = function (v) {
  return !isNaN(parseFloat(v)) && isFinite(v);
};
/**
 * Returns true if the given value is an Object.
 *
 * @param v the value to check.
 *
 * @return true if the value is an Object, false if not.
 */


api.isObject = function (v) {
  return Object.prototype.toString.call(v) === '[object Object]';
};
/**
 * Returns true if the given value is a String.
 *
 * @param v the value to check.
 *
 * @return true if the value is a String, false if not.
 */


api.isString = function (v) {
  return typeof v === 'string' || Object.prototype.toString.call(v) === '[object String]';
};
/**
 * Returns true if the given value is undefined.
 *
 * @param v the value to check.
 *
 * @return true if the value is undefined, false if not.
 */


api.isUndefined = function (v) {
  return typeof v === 'undefined';
};

},{}],111:[function(require,module,exports){
/*
 * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var types = require('./types');

var api = {};
module.exports = api; // define URL parser
// parseUri 1.2.2
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
// with local jsonld.js modifications

api.parsers = {
  simple: {
    // RFC 3986 basic parts
    keys: ['href', 'scheme', 'authority', 'path', 'query', 'fragment'],

    /* eslint-disable-next-line max-len */
    regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
  },
  full: {
    keys: ['href', 'protocol', 'scheme', 'authority', 'auth', 'user', 'password', 'hostname', 'port', 'path', 'directory', 'file', 'query', 'fragment'],

    /* eslint-disable-next-line max-len */
    regex: /^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};

api.parse = function (str, parser) {
  var parsed = {};
  var o = api.parsers[parser || 'full'];
  var m = o.regex.exec(str);
  var i = o.keys.length;

  while (i--) {
    parsed[o.keys[i]] = m[i] === undefined ? null : m[i];
  } // remove default ports in found in URLs


  if (parsed.scheme === 'https' && parsed.port === '443' || parsed.scheme === 'http' && parsed.port === '80') {
    parsed.href = parsed.href.replace(':' + parsed.port, '');
    parsed.authority = parsed.authority.replace(':' + parsed.port, '');
    parsed.port = null;
  }

  parsed.normalizedPath = api.removeDotSegments(parsed.path);
  return parsed;
};
/**
 * Prepends a base IRI to the given relative IRI.
 *
 * @param base the base IRI.
 * @param iri the relative IRI.
 *
 * @return the absolute IRI.
 */


api.prependBase = function (base, iri) {
  // skip IRI processing
  if (base === null) {
    return iri;
  } // already an absolute IRI


  if (api.isAbsolute(iri)) {
    return iri;
  } // parse base if it is a string


  if (!base || types.isString(base)) {
    base = api.parse(base || '');
  } // parse given IRI


  var rel = api.parse(iri); // per RFC3986 5.2.2

  var transform = {
    protocol: base.protocol || ''
  };

  if (rel.authority !== null) {
    transform.authority = rel.authority;
    transform.path = rel.path;
    transform.query = rel.query;
  } else {
    transform.authority = base.authority;

    if (rel.path === '') {
      transform.path = base.path;

      if (rel.query !== null) {
        transform.query = rel.query;
      } else {
        transform.query = base.query;
      }
    } else {
      if (rel.path.indexOf('/') === 0) {
        // IRI represents an absolute path
        transform.path = rel.path;
      } else {
        // merge paths
        var path = base.path; // append relative path to the end of the last directory from base

        path = path.substr(0, path.lastIndexOf('/') + 1);

        if ((path.length > 0 || base.authority) && path.substr(-1) !== '/') {
          path += '/';
        }

        path += rel.path;
        transform.path = path;
      }

      transform.query = rel.query;
    }
  }

  if (rel.path !== '') {
    // remove slashes and dots in path
    transform.path = api.removeDotSegments(transform.path);
  } // construct URL


  var rval = transform.protocol;

  if (transform.authority !== null) {
    rval += '//' + transform.authority;
  }

  rval += transform.path;

  if (transform.query !== null) {
    rval += '?' + transform.query;
  }

  if (rel.fragment !== null) {
    rval += '#' + rel.fragment;
  } // handle empty base


  if (rval === '') {
    rval = './';
  }

  return rval;
};
/**
 * Removes a base IRI from the given absolute IRI.
 *
 * @param base the base IRI.
 * @param iri the absolute IRI.
 *
 * @return the relative IRI if relative to base, otherwise the absolute IRI.
 */


api.removeBase = function (base, iri) {
  // skip IRI processing
  if (base === null) {
    return iri;
  }

  if (!base || types.isString(base)) {
    base = api.parse(base || '');
  } // establish base root


  var root = '';

  if (base.href !== '') {
    root += (base.protocol || '') + '//' + (base.authority || '');
  } else if (iri.indexOf('//')) {
    // support network-path reference with empty base
    root += '//';
  } // IRI not relative to base


  if (iri.indexOf(root) !== 0) {
    return iri;
  } // remove root from IRI and parse remainder


  var rel = api.parse(iri.substr(root.length)); // remove path segments that match (do not remove last segment unless there
  // is a hash or query)

  var baseSegments = base.normalizedPath.split('/');
  var iriSegments = rel.normalizedPath.split('/');
  var last = rel.fragment || rel.query ? 0 : 1;

  while (baseSegments.length > 0 && iriSegments.length > last) {
    if (baseSegments[0] !== iriSegments[0]) {
      break;
    }

    baseSegments.shift();
    iriSegments.shift();
  } // use '../' for each non-matching base segment


  var rval = '';

  if (baseSegments.length > 0) {
    // don't count the last segment (if it ends with '/' last path doesn't
    // count and if it doesn't end with '/' it isn't a path)
    baseSegments.pop();

    for (var i = 0; i < baseSegments.length; ++i) {
      rval += '../';
    }
  } // prepend remaining segments


  rval += iriSegments.join('/'); // add query and hash

  if (rel.query !== null) {
    rval += '?' + rel.query;
  }

  if (rel.fragment !== null) {
    rval += '#' + rel.fragment;
  } // handle empty base


  if (rval === '') {
    rval = './';
  }

  return rval;
};
/**
 * Removes dot segments from a URL path.
 *
 * @param path the path to remove dot segments from.
 */


api.removeDotSegments = function (path) {
  // RFC 3986 5.2.4 (reworked)
  // empty path shortcut
  if (path.length === 0) {
    return '';
  }

  var input = path.split('/');
  var output = [];

  while (input.length > 0) {
    var next = input.shift();
    var done = input.length === 0;

    if (next === '.') {
      if (done) {
        // ensure output has trailing /
        output.push('');
      }

      continue;
    }

    if (next === '..') {
      output.pop();

      if (done) {
        // ensure output has trailing /
        output.push('');
      }

      continue;
    }

    output.push(next);
  } // if path was absolute, ensure output has leading /


  if (path[0] === '/' && output.length > 0 && output[0] !== '') {
    output.unshift('');
  }

  if (output.length === 1 && output[0] === '') {
    return '/';
  }

  return output.join('/');
}; // TODO: time better isAbsolute/isRelative checks using full regexes:
// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html
// regex to check for absolute IRI (starting scheme and ':') or blank node IRI


var isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
/**
 * Returns true if the given value is an absolute IRI or blank node IRI, false
 * if not.
 * Note: This weak check only checks for a correct starting scheme.
 *
 * @param v the value to check.
 *
 * @return true if the value is an absolute IRI, false if not.
 */

api.isAbsolute = function (v) {
  return types.isString(v) && isAbsoluteRegex.test(v);
};
/**
 * Returns true if the given value is a relative IRI, false if not.
 * Note: this is a weak check.
 *
 * @param v the value to check.
 *
 * @return true if the value is a relative IRI, false if not.
 */


api.isRelative = function (v) {
  return types.isString(v);
};

},{"./types":110}],112:[function(require,module,exports){
/*
 * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var graphTypes = require('./graphTypes');

var types = require('./types'); // TODO: move `IdentifierIssuer` to its own package


var IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;

var JsonLdError = require('./JsonLdError'); // constants


var REGEX_LINK_HEADERS = /(?:<[^>]*?>|"[^"]*?"|[^,])+/g;
var REGEX_LINK_HEADER = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
var REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
var DEFAULTS = {
  headers: {
    accept: 'application/ld+json, application/json'
  }
};
var api = {};
module.exports = api;
api.IdentifierIssuer = IdentifierIssuer;
/**
 * Clones an object, array, Map, Set, or string/number. If a typed JavaScript
 * object is given, such as a Date, it will be converted to a string.
 *
 * @param value the value to clone.
 *
 * @return the cloned value.
 */

api.clone = function (value) {
  if (value && (0, _typeof2["default"])(value) === 'object') {
    var rval;

    if (types.isArray(value)) {
      rval = [];

      for (var i = 0; i < value.length; ++i) {
        rval[i] = api.clone(value[i]);
      }
    } else if (value instanceof Map) {
      rval = new Map();

      var _iterator = _createForOfIteratorHelper(value),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
              k = _step$value[0],
              v = _step$value[1];

          rval.set(k, api.clone(v));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else if (value instanceof Set) {
      rval = new Set();

      var _iterator2 = _createForOfIteratorHelper(value),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _v = _step2.value;
          rval.add(api.clone(_v));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } else if (types.isObject(value)) {
      rval = {};

      for (var key in value) {
        rval[key] = api.clone(value[key]);
      }
    } else {
      rval = value.toString();
    }

    return rval;
  }

  return value;
};
/**
 * Ensure a value is an array. If the value is an array, it is returned.
 * Otherwise, it is wrapped in an array.
 *
 * @param value the value to return as an array.
 *
 * @return the value as an array.
 */


api.asArray = function (value) {
  return Array.isArray(value) ? value : [value];
};
/**
 * Builds an HTTP headers object for making a JSON-LD request from custom
 * headers and asserts the `accept` header isn't overridden.
 *
 * @param headers an object of headers with keys as header names and values
 *          as header values.
 *
 * @return an object of headers with a valid `accept` header.
 */


api.buildHeaders = function () {
  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var hasAccept = Object.keys(headers).some(function (h) {
    return h.toLowerCase() === 'accept';
  });

  if (hasAccept) {
    throw new RangeError('Accept header may not be specified; only "' + DEFAULTS.headers.accept + '" is supported.');
  }

  return Object.assign({
    Accept: DEFAULTS.headers.accept
  }, headers);
};
/**
 * Parses a link header. The results will be key'd by the value of "rel".
 *
 * Link: <http://json-ld.org/contexts/person.jsonld>;
 * rel="http://www.w3.org/ns/json-ld#context"; type="application/ld+json"
 *
 * Parses as: {
 *   'http://www.w3.org/ns/json-ld#context': {
 *     target: http://json-ld.org/contexts/person.jsonld,
 *     type: 'application/ld+json'
 *   }
 * }
 *
 * If there is more than one "rel" with the same IRI, then entries in the
 * resulting map for that "rel" will be arrays.
 *
 * @param header the link header to parse.
 */


api.parseLinkHeader = function (header) {
  var rval = {}; // split on unbracketed/unquoted commas

  var entries = header.match(REGEX_LINK_HEADERS);

  for (var i = 0; i < entries.length; ++i) {
    var match = entries[i].match(REGEX_LINK_HEADER);

    if (!match) {
      continue;
    }

    var result = {
      target: match[1]
    };
    var params = match[2];

    while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {
      result[match[1]] = match[2] === undefined ? match[3] : match[2];
    }

    var rel = result['rel'] || '';

    if (Array.isArray(rval[rel])) {
      rval[rel].push(result);
    } else if (rval.hasOwnProperty(rel)) {
      rval[rel] = [rval[rel], result];
    } else {
      rval[rel] = result;
    }
  }

  return rval;
};
/**
 * Throws an exception if the given value is not a valid @type value.
 *
 * @param v the value to check.
 */


api.validateTypeValue = function (v, isFrame) {
  if (types.isString(v)) {
    return;
  }

  if (types.isArray(v) && v.every(function (vv) {
    return types.isString(vv);
  })) {
    return;
  }

  if (isFrame && types.isObject(v)) {
    switch (Object.keys(v).length) {
      case 0:
        // empty object is wildcard
        return;

      case 1:
        // default entry is all strings
        if ('@default' in v && api.asArray(v['@default']).every(function (vv) {
          return types.isString(vv);
        })) {
          return;
        }

    }
  }

  throw new JsonLdError('Invalid JSON-LD syntax; "@type" value must a string, an array of ' + 'strings, an empty object, ' + 'or a default object.', 'jsonld.SyntaxError', {
    code: 'invalid type value',
    value: v
  });
};
/**
 * Returns true if the given subject has the given property.
 *
 * @param subject the subject to check.
 * @param property the property to look for.
 *
 * @return true if the subject has the given property, false if not.
 */


api.hasProperty = function (subject, property) {
  if (subject.hasOwnProperty(property)) {
    var value = subject[property];
    return !types.isArray(value) || value.length > 0;
  }

  return false;
};
/**
 * Determines if the given value is a property of the given subject.
 *
 * @param subject the subject to check.
 * @param property the property to check.
 * @param value the value to check.
 *
 * @return true if the value exists, false if not.
 */


api.hasValue = function (subject, property, value) {
  if (api.hasProperty(subject, property)) {
    var val = subject[property];
    var isList = graphTypes.isList(val);

    if (types.isArray(val) || isList) {
      if (isList) {
        val = val['@list'];
      }

      for (var i = 0; i < val.length; ++i) {
        if (api.compareValues(value, val[i])) {
          return true;
        }
      }
    } else if (!types.isArray(value)) {
      // avoid matching the set of values with an array value parameter
      return api.compareValues(value, val);
    }
  }

  return false;
};
/**
 * Adds a value to a subject. If the value is an array, all values in the
 * array will be added.
 *
 * @param subject the subject to add the value to.
 * @param property the property that relates the value to the subject.
 * @param value the value to add.
 * @param [options] the options to use:
 *        [propertyIsArray] true if the property is always an array, false
 *          if not (default: false).
 *        [valueIsArray] true if the value to be added should be preserved as
 *          an array (lists) (default: false).
 *        [allowDuplicate] true to allow duplicates, false not to (uses a
 *          simple shallow comparison of subject ID or value) (default: true).
 *        [prependValue] false to prepend value to any existing values.
 *          (default: false)
 */


api.addValue = function (subject, property, value, options) {
  options = options || {};

  if (!('propertyIsArray' in options)) {
    options.propertyIsArray = false;
  }

  if (!('valueIsArray' in options)) {
    options.valueIsArray = false;
  }

  if (!('allowDuplicate' in options)) {
    options.allowDuplicate = true;
  }

  if (!('prependValue' in options)) {
    options.prependValue = false;
  }

  if (options.valueIsArray) {
    subject[property] = value;
  } else if (types.isArray(value)) {
    if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {
      subject[property] = [];
    }

    if (options.prependValue) {
      value = value.concat(subject[property]);
      subject[property] = [];
    }

    for (var i = 0; i < value.length; ++i) {
      api.addValue(subject, property, value[i], options);
    }
  } else if (subject.hasOwnProperty(property)) {
    // check if subject already has value if duplicates not allowed
    var hasValue = !options.allowDuplicate && api.hasValue(subject, property, value); // make property an array if value not present or always an array

    if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {
      subject[property] = [subject[property]];
    } // add new value


    if (!hasValue) {
      if (options.prependValue) {
        subject[property].unshift(value);
      } else {
        subject[property].push(value);
      }
    }
  } else {
    // add new value as set or single value
    subject[property] = options.propertyIsArray ? [value] : value;
  }
};
/**
 * Gets all of the values for a subject's property as an array.
 *
 * @param subject the subject.
 * @param property the property.
 *
 * @return all of the values for a subject's property as an array.
 */


api.getValues = function (subject, property) {
  return [].concat(subject[property] || []);
};
/**
 * Removes a property from a subject.
 *
 * @param subject the subject.
 * @param property the property.
 */


api.removeProperty = function (subject, property) {
  delete subject[property];
};
/**
 * Removes a value from a subject.
 *
 * @param subject the subject.
 * @param property the property that relates the value to the subject.
 * @param value the value to remove.
 * @param [options] the options to use:
 *          [propertyIsArray] true if the property is always an array, false
 *            if not (default: false).
 */


api.removeValue = function (subject, property, value, options) {
  options = options || {};

  if (!('propertyIsArray' in options)) {
    options.propertyIsArray = false;
  } // filter out value


  var values = api.getValues(subject, property).filter(function (e) {
    return !api.compareValues(e, value);
  });

  if (values.length === 0) {
    api.removeProperty(subject, property);
  } else if (values.length === 1 && !options.propertyIsArray) {
    subject[property] = values[0];
  } else {
    subject[property] = values;
  }
};
/**
 * Relabels all blank nodes in the given JSON-LD input.
 *
 * @param input the JSON-LD input.
 * @param [options] the options to use:
 *          [issuer] an IdentifierIssuer to use to label blank nodes.
 */


api.relabelBlankNodes = function (input, options) {
  options = options || {};
  var issuer = options.issuer || new IdentifierIssuer('_:b');
  return _labelBlankNodes(issuer, input);
};
/**
 * Compares two JSON-LD values for equality. Two JSON-LD values will be
 * considered equal if:
 *
 * 1. They are both primitives of the same type and value.
 * 2. They are both @values with the same @value, @type, @language,
 *   and @index, OR
 * 3. They both have @ids they are the same.
 *
 * @param v1 the first value.
 * @param v2 the second value.
 *
 * @return true if v1 and v2 are considered equal, false if not.
 */


api.compareValues = function (v1, v2) {
  // 1. equal primitives
  if (v1 === v2) {
    return true;
  } // 2. equal @values


  if (graphTypes.isValue(v1) && graphTypes.isValue(v2) && v1['@value'] === v2['@value'] && v1['@type'] === v2['@type'] && v1['@language'] === v2['@language'] && v1['@index'] === v2['@index']) {
    return true;
  } // 3. equal @ids


  if (types.isObject(v1) && '@id' in v1 && types.isObject(v2) && '@id' in v2) {
    return v1['@id'] === v2['@id'];
  }

  return false;
};
/**
 * Compares two strings first based on length and then lexicographically.
 *
 * @param a the first string.
 * @param b the second string.
 *
 * @return -1 if a < b, 1 if a > b, 0 if a === b.
 */


api.compareShortestLeast = function (a, b) {
  if (a.length < b.length) {
    return -1;
  }

  if (b.length < a.length) {
    return 1;
  }

  if (a === b) {
    return 0;
  }

  return a < b ? -1 : 1;
};
/**
 * Labels the blank nodes in the given value using the given IdentifierIssuer.
 *
 * @param issuer the IdentifierIssuer to use.
 * @param element the element with blank nodes to rename.
 *
 * @return the element.
 */


function _labelBlankNodes(issuer, element) {
  if (types.isArray(element)) {
    for (var i = 0; i < element.length; ++i) {
      element[i] = _labelBlankNodes(issuer, element[i]);
    }
  } else if (graphTypes.isList(element)) {
    element['@list'] = _labelBlankNodes(issuer, element['@list']);
  } else if (types.isObject(element)) {
    // relabel blank node
    if (graphTypes.isBlankNode(element)) {
      element['@id'] = issuer.getId(element['@id']);
    } // recursively apply to all keys


    var keys = Object.keys(element).sort();

    for (var ki = 0; ki < keys.length; ++ki) {
      var key = keys[ki];

      if (key !== '@id') {
        element[key] = _labelBlankNodes(issuer, element[key]);
      }
    }
  }

  return element;
}

},{"./JsonLdError":91,"./graphTypes":106,"./types":110,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/typeof":27,"rdf-canonize":153}],113:[function(require,module,exports){
'use strict'; // A linked list to keep track of recently-used-ness

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var Yallist = require('yallist');

var MAX = Symbol('max');
var LENGTH = Symbol('length');
var LENGTH_CALCULATOR = Symbol('lengthCalculator');
var ALLOW_STALE = Symbol('allowStale');
var MAX_AGE = Symbol('maxAge');
var DISPOSE = Symbol('dispose');
var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
var LRU_LIST = Symbol('lruList');
var CACHE = Symbol('cache');
var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

var naiveLength = function naiveLength() {
  return 1;
}; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


var LRUCache = /*#__PURE__*/function () {
  function LRUCache(options) {
    (0, _classCallCheck2["default"])(this, LRUCache);
    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    var max = this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  (0, _createClass2["default"])(LRUCache, [{
    key: "rforEach",
    value: function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
  }, {
    key: "forEach",
    value: function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].head; walker !== null;) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
  }, {
    key: "keys",
    value: function keys() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.key;
      });
    }
  }, {
    key: "values",
    value: function values() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.value;
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this = this;

      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function (hit) {
          return _this[DISPOSE](hit.key, hit.value);
        });
      }

      this[CACHE] = new Map(); // hash of items by key

      this[LRU_LIST] = new Yallist(); // list of items in order of use recency

      this[LENGTH] = 0; // length of items in the list
    }
  }, {
    key: "dump",
    value: function dump() {
      var _this2 = this;

      return this[LRU_LIST].map(function (hit) {
        return isStale(_this2, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    }
  }, {
    key: "dumpLru",
    value: function dumpLru() {
      return this[LRU_LIST];
    }
  }, {
    key: "set",
    value: function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);

      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          _del(this, this[CACHE].get(key));

          return false;
        }

        var node = this[CACHE].get(key);
        var item = node.value; // dispose of the old one before overwriting
        // split out into 2 ifs for better coverage tracking

        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }

      var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }

      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (!this[CACHE].has(key)) return false;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
  }, {
    key: "get",
    value: function get(key) {
      return _get(this, key, true);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      return _get(this, key, false);
    }
  }, {
    key: "pop",
    value: function pop() {
      var node = this[LRU_LIST].tail;
      if (!node) return null;

      _del(this, node);

      return node.value;
    }
  }, {
    key: "del",
    value: function del(key) {
      _del(this, this[CACHE].get(key));
    }
  }, {
    key: "load",
    value: function load(arr) {
      // reset the cache
      this.reset();
      var now = Date.now(); // A previous serialized cache has the most recent items first

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) // the item was created without expiration in a non aged cache
          this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now; // dont add already expired items

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
  }, {
    key: "prune",
    value: function prune() {
      var _this3 = this;

      this[CACHE].forEach(function (value, key) {
        return _get(_this3, key, false);
      });
    }
  }, {
    key: "max",
    set: function set(mL) {
      if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
      this[MAX] = mL || Infinity;
      trim(this);
    },
    get: function get() {
      return this[MAX];
    }
  }, {
    key: "allowStale",
    set: function set(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    },
    get: function get() {
      return this[ALLOW_STALE];
    }
  }, {
    key: "maxAge",
    set: function set(mA) {
      if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
      this[MAX_AGE] = mA;
      trim(this);
    },
    get: function get() {
      return this[MAX_AGE];
    } // resize the cache when the lengthCalculator changes.

  }, {
    key: "lengthCalculator",
    set: function set(lC) {
      var _this4 = this;

      if (typeof lC !== 'function') lC = naiveLength;

      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(function (hit) {
          hit.length = _this4[LENGTH_CALCULATOR](hit.value, hit.key);
          _this4[LENGTH] += hit.length;
        });
      }

      trim(this);
    },
    get: function get() {
      return this[LENGTH_CALCULATOR];
    }
  }, {
    key: "length",
    get: function get() {
      return this[LENGTH];
    }
  }, {
    key: "itemCount",
    get: function get() {
      return this[LRU_LIST].length;
    }
  }]);
  return LRUCache;
}();

var _get = function _get(self, key, doUse) {
  var node = self[CACHE].get(key);

  if (node) {
    var hit = node.value;

    if (isStale(self, hit)) {
      _del(self, node);

      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

var isStale = function isStale(self, hit) {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};

var trim = function trim(self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev;

      _del(self, walker);

      walker = prev;
    }
  }
};

var _del = function _del(self, node) {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE]["delete"](hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

var Entry = function Entry(key, value, length, now, maxAge) {
  (0, _classCallCheck2["default"])(this, Entry);
  this.key = key;
  this.value = value;
  this.length = length;
  this.now = now;
  this.maxAge = maxAge || 0;
};

var forEachStep = function forEachStep(self, fn, node, thisp) {
  var hit = node.value;

  if (isStale(self, hit)) {
    _del(self, node);

    if (!self[ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

module.exports = LRUCache;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"yallist":196}],114:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./lib/propertyhandler/IItemPropertyHandler"), exports);

__exportStar(require("./lib/propertyhandler/ItemPropertyHandlerContent"), exports);

__exportStar(require("./lib/propertyhandler/ItemPropertyHandlerNumber"), exports);

__exportStar(require("./lib/propertyhandler/ItemPropertyHandlerTime"), exports);

__exportStar(require("./lib/propertyhandler/ItemPropertyHandlerUrl"), exports);

__exportStar(require("./lib/IHtmlParseListener"), exports);

__exportStar(require("./lib/IItemScope"), exports);

__exportStar(require("./lib/IVocabRegistry"), exports);

__exportStar(require("./lib/MicrodataRdfParser"), exports);

__exportStar(require("./lib/Util"), exports);

},{"./lib/IHtmlParseListener":115,"./lib/IItemScope":116,"./lib/IVocabRegistry":117,"./lib/MicrodataRdfParser":118,"./lib/Util":119,"./lib/propertyhandler/IItemPropertyHandler":120,"./lib/propertyhandler/ItemPropertyHandlerContent":121,"./lib/propertyhandler/ItemPropertyHandlerNumber":122,"./lib/propertyhandler/ItemPropertyHandlerTime":123,"./lib/propertyhandler/ItemPropertyHandlerUrl":124}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],118:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MicrodataRdfParser = void 0;

var stream_1 = require("stream");

var htmlparser2_1 = require("htmlparser2");

var ItemPropertyHandlerContent_1 = require("./propertyhandler/ItemPropertyHandlerContent");

var ItemPropertyHandlerNumber_1 = require("./propertyhandler/ItemPropertyHandlerNumber");

var ItemPropertyHandlerTime_1 = require("./propertyhandler/ItemPropertyHandlerTime");

var ItemPropertyHandlerUrl_1 = require("./propertyhandler/ItemPropertyHandlerUrl");

var Util_1 = require("./Util");

var VOCAB_REGISTRY_DEFAULT = require("./vocab-registry-default.json");
/**
 * A stream transformer that parses Microdata (text) streams to an {@link RDF.Stream}.
 */


var MicrodataRdfParser = /*#__PURE__*/function (_stream_1$Transform) {
  (0, _inherits2["default"])(MicrodataRdfParser, _stream_1$Transform);

  var _super = _createSuper(MicrodataRdfParser);

  function MicrodataRdfParser(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, MicrodataRdfParser);
    _this = _super.call(this, {
      readableObjectMode: true
    }); // Stacks, where the key is the current depth.

    _this.itemScopeStack = [];
    _this.textBufferStack = []; // Variables for managing itemrefs.

    _this.isEmittingReferences = false;
    _this.pendingItemRefsDomain = {};
    _this.pendingItemRefsRangeFinalized = {}; // eslint-disable-next-line lines-between-class-members

    _this.pendingItemRefsRangeCollecting = {};
    options = options || {};
    _this.options = options;
    _this.util = new Util_1.Util(options.dataFactory, options.baseIRI);
    _this.defaultGraph = options.defaultGraph || _this.util.dataFactory.defaultGraph();
    _this.htmlParseListener = options.htmlParseListener;
    _this.vocabRegistry = options.vocabRegistry || VOCAB_REGISTRY_DEFAULT;
    _this.parser = _this.initializeParser(!!options.xmlMode);
    return _this;
  }
  /**
   * Parses the given text stream into a quad stream.
   * @param {NodeJS.EventEmitter} stream A text stream.
   * @return {RDF.Stream} A quad stream.
   */


  (0, _createClass2["default"])(MicrodataRdfParser, [{
    key: "import",
    value: function _import(stream) {
      var output = new stream_1.PassThrough({
        readableObjectMode: true
      });
      stream.on('error', function (error) {
        return parsed.emit('error', error);
      });
      stream.on('data', function (data) {
        return output.push(data);
      });
      stream.on('end', function () {
        return output.push(null);
      });
      var parsed = output.pipe(new MicrodataRdfParser(this.options));
      return parsed;
    }
  }, {
    key: "_transform",
    value: function _transform(chunk, encoding, callback) {
      this.parser.write(chunk);
      callback();
    }
  }, {
    key: "_flush",
    value: function _flush(callback) {
      this.parser.end();
      callback();
    }
    /**
     * Get the current item scope for the current depth.
     * This will skip all undefined item scopes.
     * @param parent If we should start looking one level higher in the stack.
     */

  }, {
    key: "getItemScope",
    value: function getItemScope(parent) {
      var parentTagI = this.itemScopeStack.length - (parent ? 2 : 1);

      while (parentTagI > 0 && !this.itemScopeStack[parentTagI]) {
        parentTagI--;
      }

      return this.itemScopeStack[parentTagI];
    }
    /**
     * Get the current stack depth.
     */

  }, {
    key: "getDepth",
    value: function getDepth() {
      return this.itemScopeStack.length;
    }
  }, {
    key: "onTagOpen",
    value: function onTagOpen(name, attributes) {
      if (!this.isEmittingReferences) {
        // If the tag has an 'id', start collecting the whole stack in the item reference buffer
        if ('id' in attributes) {
          var id = attributes.id;
          this.pendingItemRefsRangeCollecting[id] = {
            events: [],
            counter: 0,
            ids: []
          };
        } // Store this event in all collecting item reference buffers


        for (var _i = 0, _Object$values = Object.values(this.pendingItemRefsRangeCollecting); _i < _Object$values.length; _i++) {
          var buffer = _Object$values[_i];
          buffer.counter++;
          buffer.events.push({
            type: 'open',
            name: name,
            attributes: attributes
          });
        }
      } // Ensure the text buffer stack is in line with the stack depth
      // eslint-disable-next-line unicorn/no-useless-undefined


      this.textBufferStack.push(undefined); // Processing steps based on https://w3c.github.io/microdata-rdf/#rdf-conversion-algorithm
      // 1. Determine the current item scope

      var itemScope;

      if ('itemscope' in attributes) {
        // Create a new item scope
        var subject;

        if (this.emittingReferencesItemScopeIdGenerator) {
          subject = this.emittingReferencesItemScopeIdGenerator();
        } else {
          subject = 'itemid' in attributes && this.util.createSubject(attributes.itemid) || this.util.dataFactory.blankNode(); // Store the genererated id in all collecting item reference buffers

          for (var _i2 = 0, _Object$values2 = Object.values(this.pendingItemRefsRangeCollecting); _i2 < _Object$values2.length; _i2++) {
            var _buffer = _Object$values2[_i2];

            _buffer.ids.push(subject);
          }
        }

        itemScope = {
          subject: subject
        }; // If the id was reused from a reference, block any new triples to be generated from it

        if (this.isEmittingReferences) {
          itemScope.blockEmission = true;
        } // Inherit vocab from parent item scope


        var parentItemScope = this.getItemScope();

        if (parentItemScope && parentItemScope.vocab) {
          itemScope.vocab = parentItemScope.vocab;
        } // 2. Push any changes to the item scope to the stack


        this.itemScopeStack.push(itemScope);
      } else {
        // Determine the parent item scope
        itemScope = this.getItemScope(); // 2. Push any changes to the item scope to the stack
        // eslint-disable-next-line unicorn/no-useless-undefined

        this.itemScopeStack.push(undefined);
      } // If we have a valid item scope, process the current node


      if (itemScope) {
        // 3. Handle item types
        if ('itemtype' in attributes) {
          var _iterator = _createForOfIteratorHelper(this.util.createVocabIris(attributes.itemtype, itemScope, false)),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var type = _step.value;

              // 4. Vocab identifier is the first valid item
              if (!itemScope.vocab) {
                // 5. Modify vocab based on registry
                itemScope.vocab = this.util.deriveVocab(type.value, this.vocabRegistry);
              } // Emit item type


              if (!itemScope.blockEmission) {
                this.emitTriple(itemScope.subject, this.util.dataFactory.namedNode("".concat(Util_1.Util.RDF, "type")), type);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } // Save language in item scope


        if ('lang' in attributes) {
          itemScope.language = attributes.lang;
        }

        if ('xml:lang' in attributes) {
          itemScope.language = attributes['xml:lang'];
        } // Handle itemrefs (only if we also had an itemscope)


        if ('itemscope' in attributes) {
          // If we have an itemref, store it in our domain buffer.
          if (!this.isEmittingReferences && 'itemref' in attributes) {
            var _iterator2 = _createForOfIteratorHelper(attributes.itemref.split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/)),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var reference = _step2.value;

                if (!(reference in this.pendingItemRefsDomain)) {
                  this.pendingItemRefsDomain[reference] = [];
                }

                this.pendingItemRefsDomain[reference].push(itemScope);
                this.tryToEmitReferences(reference, itemScope);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        }
      } // 6. Handle item properties


      if ('itemprop' in attributes) {
        this.handleItemProperties(attributes.itemprop, false, itemScope, name, attributes);
      } // Handle reverse item properties
      // https://w3c.github.io/microdata-rdf/#reverse-itemprop


      if ('itemprop-reverse' in attributes) {
        this.handleItemProperties(attributes['itemprop-reverse'], true, itemScope, name, attributes);
      }
    }
  }, {
    key: "onText",
    value: function onText(data) {
      // Store this event in all collecting item reference buffers
      if (!this.isEmittingReferences) {
        for (var _i3 = 0, _Object$values3 = Object.values(this.pendingItemRefsRangeCollecting); _i3 < _Object$values3.length; _i3++) {
          var buffer = _Object$values3[_i3];
          buffer.events.push({
            type: 'text',
            data: data
          });
        }
      } // Save the text inside all item scopes that need to collect text


      var _iterator3 = _createForOfIteratorHelper(this.textBufferStack),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var textBuffer = _step3.value;

          if (textBuffer) {
            textBuffer.push(data);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "onTagClose",
    value: function onTagClose() {
      // Store this event in all collecting item reference buffers
      if (!this.isEmittingReferences) {
        for (var _i4 = 0, _Object$entries = Object.entries(this.pendingItemRefsRangeCollecting); _i4 < _Object$entries.length; _i4++) {
          var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i4], 2),
              reference = _Object$entries$_i[0],
              buffer = _Object$entries$_i[1];

          buffer.counter--;
          buffer.events.push({
            type: 'close'
          }); // Once the counter becomes zero, the tag is fully buffered, so we finalize it.

          if (buffer.counter === 0) {
            this.pendingItemRefsRangeFinalized[reference] = buffer;
            delete this.pendingItemRefsRangeCollecting[reference]; // Try to emit this reference with buffered domain items

            this.tryToEmitReferences(reference);
          }
        }
      } // Emit all triples that were determined in the active tag


      var itemScope = this.getItemScope(true);

      if (itemScope) {
        var depth = this.getDepth();

        if (itemScope.predicates && depth in itemScope.predicates) {
          for (var _i5 = 0, _Object$entries2 = Object.entries(itemScope.predicates[depth]); _i5 < _Object$entries2.length; _i5++) {
            var _Object$entries2$_i = (0, _slicedToArray2["default"])(_Object$entries2[_i5], 2),
                predicateKey = _Object$entries2$_i[0],
                predicates = _Object$entries2$_i[1];

            // First check if we have a child item scope, otherwise get the text content
            // Safely cast textBufferStack, as it is always defined when itemScope.predicates is defined.
            var object = this.util.createLiteral(this.textBufferStack[depth].join(''), itemScope);
            this.emitPredicateTriples(itemScope, predicates, object, predicateKey === 'reverse');
            delete itemScope.predicates[depth][predicateKey];
          }
        }
      } // Remove the active tag from the stack


      this.itemScopeStack.pop();
      this.textBufferStack.pop();
    }
  }, {
    key: "onEnd",
    value: function onEnd() {// Nothing important should happen here.
    }
    /**
     * Initialize a new HtmlParser.
     * @param xmlMode If the parser should be setup in strict mode.
     */

  }, {
    key: "initializeParser",
    value: function initializeParser(xmlMode) {
      var _this2 = this;

      return new htmlparser2_1.Parser({
        onclosetag: function onclosetag() {
          try {
            _this2.onTagClose();

            if (_this2.htmlParseListener) {
              _this2.htmlParseListener.onTagClose();
            }
          } catch (error) {
            _this2.emit('error', error);
          }
        },
        onend: function onend() {
          try {
            _this2.onEnd();

            if (_this2.htmlParseListener) {
              _this2.htmlParseListener.onEnd();
            }
          } catch (error) {
            _this2.emit('error', error);
          }
        },
        onopentag: function onopentag(name, attributes) {
          try {
            _this2.onTagOpen(name, attributes);

            if (_this2.htmlParseListener) {
              _this2.htmlParseListener.onTagOpen(name, attributes);
            }
          } catch (error) {
            _this2.emit('error', error);
          }
        },
        ontext: function ontext(data) {
          try {
            _this2.onText(data);

            if (_this2.htmlParseListener) {
              _this2.htmlParseListener.onText(data);
            }
          } catch (error) {
            _this2.emit('error', error);
          }
        }
      }, {
        decodeEntities: true,
        recognizeSelfClosing: true,
        xmlMode: xmlMode
      });
    }
    /**
     * Handle the given item properties.
     * @param itempropValue The value of itemprop or itemprop-reverse.
     * @param reverse If the item properties are reversed (itemprop-reverse).
     * @param itemScope The current item scope.
     * @param tagName The current tag name.
     * @param tagAttributes The current tag attributes.
     */

  }, {
    key: "handleItemProperties",
    value: function handleItemProperties(itempropValue, reverse, itemScope, tagName, tagAttributes) {
      var parentItemScope = this.getItemScope(true);

      if (parentItemScope) {
        // Set predicates in the scope, and handle them on tag close.
        var depth = this.getDepth();
        var predicates = this.util.createVocabIris(itempropValue, parentItemScope, true);

        if (!parentItemScope.predicates) {
          parentItemScope.predicates = {};
        }

        if (!parentItemScope.predicates[depth]) {
          parentItemScope.predicates[depth] = {};
        }

        var predicatesKey = reverse ? 'reverse' : 'forward';
        parentItemScope.predicates[depth][predicatesKey] = predicates; // Append rdf:type predicate if vocabulary expansion applies

        var _iterator4 = _createForOfIteratorHelper(this.util.getVocabularyExpansionType(itempropValue, parentItemScope, this.vocabRegistry)),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var vocabularyExpansionType = _step4.value;
            predicates.push(vocabularyExpansionType);
          } // Check if a property handler that applies, forcefully use that as predicate value.
          // But DON'T call handlers in this prop is a direct (nested) itemscope.

        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        if (itemScope && 'itemscope' in tagAttributes) {
          this.emitPredicateTriples(parentItemScope, predicates, itemScope.subject, reverse); // Finalize the predicates, so text values do not apply to them.

          delete parentItemScope.predicates[depth][predicatesKey];
        } else {
          var _iterator5 = _createForOfIteratorHelper(MicrodataRdfParser.ITEM_PROPERTY_HANDLERS),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var handler = _step5.value;

              if (handler.canHandle(tagName, tagAttributes)) {
                var object = handler.getObject(tagAttributes, this.util, parentItemScope);
                this.emitPredicateTriples(parentItemScope, predicates, object, reverse); // Finalize the predicates, so text values do not apply to them.

                delete parentItemScope.predicates[depth][predicatesKey];
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        } // If no valid handler was found, indicate that we should collect text at this depth.


        if (parentItemScope.predicates[depth][predicatesKey]) {
          this.textBufferStack[depth] = [];
        }
      }
    }
    /**
     * Emit the given object for the given predicates.
     * @param itemScope The current item scope.
     * @param predicates An array of predicates.
     * @param object An object.
     * @param reverse If the triples should be reversed.
     */

  }, {
    key: "emitPredicateTriples",
    value: function emitPredicateTriples(itemScope, predicates, object, reverse) {
      if (!itemScope.blockEmission) {
        var _iterator6 = _createForOfIteratorHelper(predicates),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var predicate = _step6.value;

            if (reverse) {
              // Literals can not exist in subject position, so they must be ignored.
              if (object.termType !== 'Literal') {
                this.emitTriple(object, predicate, itemScope.subject);
              }
            } else {
              this.emitTriple(itemScope.subject, predicate, object);
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }
    }
    /**
     * Emit the given triple to the stream.
     * @param {Quad_Subject} subject A subject term.
     * @param {Quad_Predicate} predicate A predicate term.
     * @param {Quad_Object} object An object term.
     */

  }, {
    key: "emitTriple",
    value: function emitTriple(subject, predicate, object) {
      this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));
    }
    /**
     * Attempt to emit all pending itemrefs for the given reference.
     * @param reference An item reference id.
     * @param itemScopeDomain An optional item scope. If defined, only refs from this scope will be emitted.
     */

  }, {
    key: "tryToEmitReferences",
    value: function tryToEmitReferences(reference, itemScopeDomain) {
      var _this3 = this;

      var range = this.pendingItemRefsRangeFinalized[reference];

      if (range) {
        // Determine the item scope domains to emit
        var applicableItemScopes;

        if (itemScopeDomain) {
          applicableItemScopes = [itemScopeDomain]; // Remove the item from the pending array
          // Element is guaranteed to exist in buffer

          var itemScopeDomainIndex = this.pendingItemRefsDomain[reference].indexOf(itemScopeDomain);
          this.pendingItemRefsDomain[reference].splice(itemScopeDomainIndex, 1);
        } else {
          applicableItemScopes = this.pendingItemRefsDomain[reference]; // Remove all items from the pending array

          delete this.pendingItemRefsDomain[reference];
        }

        if (applicableItemScopes) {
          // Save the stack state
          var itemScopeStackOld = this.itemScopeStack;
          var textBufferStackOld = this.textBufferStack;
          this.isEmittingReferences = true; // For all applicable item scopes, emit the buffered events.

          var _iterator7 = _createForOfIteratorHelper(applicableItemScopes),
              _step7;

          try {
            var _loop = function _loop() {
              var itemScope = _step7.value;
              _this3.itemScopeStack = [itemScope];
              _this3.textBufferStack = [undefined];
              var pendingIds = range.ids.slice();

              _this3.emittingReferencesItemScopeIdGenerator = function () {
                return pendingIds.shift();
              };

              var _iterator8 = _createForOfIteratorHelper(range.events),
                  _step8;

              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  var event = _step8.value;

                  switch (event.type) {
                    case 'open':
                      _this3.onTagOpen(event.name, event.attributes);

                      break;

                    case 'text':
                      _this3.onText(event.data);

                      break;

                    case 'close':
                      _this3.onTagClose();

                      break;
                  }
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            };

            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              _loop();
            } // Restore the stack state

          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }

          this.emittingReferencesItemScopeIdGenerator = undefined;
          this.itemScopeStack = itemScopeStackOld;
          this.textBufferStack = textBufferStackOld;
          this.isEmittingReferences = false;
        }
      }
    }
  }]);
  return MicrodataRdfParser;
}(stream_1.Transform);

exports.MicrodataRdfParser = MicrodataRdfParser;
MicrodataRdfParser.ITEM_PROPERTY_HANDLERS = [new ItemPropertyHandlerContent_1.ItemPropertyHandlerContent(), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('a', 'href'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('area', 'href'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('audio', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('embed', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('iframe', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('img', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('link', 'href'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('object', 'data'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('source', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('track', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('video', 'src'), new ItemPropertyHandlerNumber_1.ItemPropertyHandlerNumber('data', 'value'), new ItemPropertyHandlerNumber_1.ItemPropertyHandlerNumber('meter', 'value'), new ItemPropertyHandlerTime_1.ItemPropertyHandlerTime()];

},{"./Util":119,"./propertyhandler/ItemPropertyHandlerContent":121,"./propertyhandler/ItemPropertyHandlerNumber":122,"./propertyhandler/ItemPropertyHandlerTime":123,"./propertyhandler/ItemPropertyHandlerUrl":124,"./vocab-registry-default.json":125,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"@babel/runtime/helpers/slicedToArray":24,"htmlparser2":87,"stream":191}],119:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Util = void 0;

var rdf_data_factory_1 = require("rdf-data-factory");

var relative_to_absolute_iri_1 = require("relative-to-absolute-iri");
/**
 * A collection of utility functions.
 */


var Util = /*#__PURE__*/function () {
  function Util(dataFactory, baseIRI) {
    (0, _classCallCheck2["default"])(this, Util);
    this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();
    this.baseIRI = baseIRI || '';
  }
  /**
   * Check if the given IRI is valid.
   * @param {string} iri A potential IRI.
   * @return {boolean} If the given IRI is valid.
   */


  (0, _createClass2["default"])(Util, [{
    key: "createVocabIris",

    /**
     * Create vocab terms for the given terms attribute.
     *
     * Relative IRIs will be based on the active vocab or baseIRI if `allowRelativeIris` is true.
     *
     * @param {string} terms An attribute value.
     * @param {IItemScope} itemScope The active item scope.
     * @param {boolean} allowRelativeIris If relative IRIs are allowed.
     * @return {Term[]} The IRI terms.
     */
    value: function createVocabIris(terms, itemScope, allowRelativeIris) {
      var _this = this;

      return terms.split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/).filter(function (term) {
        return !!term;
      }).map(function (property) {
        if (!Util.isValidIri(property)) {
          if (!allowRelativeIris) {
            return;
          }

          property = "".concat(itemScope.vocab || "".concat(_this.baseIRI, "#")).concat(property);
        }

        return _this.dataFactory.namedNode(property);
      }).filter(function (term) {
        return !!term;
      });
    }
    /**
     * Get the predicates for which the given itemprop value should cause vocabulary expansion.
     * @param terms An attribute value.
     * @param itemScope The active item scope.
     * @param vocabRegistry The active vocabulary registry.
     */

  }, {
    key: "getVocabularyExpansionType",
    value: function getVocabularyExpansionType(terms, itemScope, vocabRegistry) {
      var _this2 = this;

      // Check the presence of subPropertyOf or equivalentProperty
      var parts = terms.split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/);

      if (parts.includes('subPropertyOf') || parts.includes('equivalentProperty')) {
        return [this.dataFactory.namedNode("".concat(Util.RDF, "type"))];
      } // Check in the item scope's vocab


      if (itemScope.vocab && itemScope.vocab in vocabRegistry && vocabRegistry[itemScope.vocab].properties) {
        var predicates = [];

        for (var _i = 0, _Object$entries = Object.entries(vocabRegistry[itemScope.vocab].properties); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2),
              property = _Object$entries$_i[0],
              expansions = _Object$entries$_i[1];

          if (parts.includes(property)) {
            predicates = predicates.concat(Object.values(expansions).map(function (iri) {
              return _this2.dataFactory.namedNode(iri);
            }));
          }
        }

        return predicates;
      }

      return [];
    }
    /**
     * Create a named node for the given term, which can be relative to the document base.
     * @param {string} iri A term string.
     * @return {Term} An RDF term, or undefined if invalid.
     */

  }, {
    key: "createSubject",
    value: function createSubject(iri) {
      if (!Util.isValidIri(iri)) {
        try {
          iri = relative_to_absolute_iri_1.resolve(iri, this.baseIRI);
        } catch (_a) {
          return;
        }
      }

      return this.dataFactory.namedNode(iri);
    }
    /**
     * Create a new literal node.
     * @param {string} literal The literal value.
     * @param {IActiveTag} activeTag The current active tag.
     * @return {Literal} A new literal node.
     */

  }, {
    key: "createLiteral",
    value: function createLiteral(literal, activeTag) {
      return this.dataFactory.literal(literal, activeTag.language);
    }
    /**
     * Determine the vocab IRI from a given type IRI.
     * @link https://w3c.github.io/microdata-rdf/#property-uri-generation
     * @param typeIri A type IRI.
     * @param vocabRegistry The active vocabulary registry.
     */

  }, {
    key: "deriveVocab",
    value: function deriveVocab(typeIri, vocabRegistry) {
      var vocab; // First check if we find a prefix in the vocab registry

      for (var uriPrefix in vocabRegistry) {
        if (typeIri.startsWith(uriPrefix)) {
          vocab = uriPrefix; // Append fragment if prefix does not end with a slash

          if (!vocab.endsWith('/')) {
            vocab += '#';
          }

          break;
        }
      } // If no match was found, remove the last path segment from the URI


      if (!vocab) {
        var hashPos = typeIri.indexOf('#');

        if (hashPos > 0) {
          vocab = typeIri.slice(0, hashPos + 1);
        } else {
          vocab = relative_to_absolute_iri_1.resolve('.', typeIri);
        }
      }

      return vocab;
    }
  }], [{
    key: "isValidIri",
    value: function isValidIri(iri) {
      return Util.IRI_REGEX.test(iri);
    }
  }]);
  return Util;
}();

exports.Util = Util;
Util.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
Util.XSD = 'http://www.w3.org/2001/XMLSchema#';
Util.RDFA = 'http://www.w3.org/ns/rdfa#';
Util.IRI_REGEX = /^([A-Za-z][\+-\.0-9A-Za-z]*|_):(?:(?![ "<>\[-\]`\{-\}])[\s\S])*$/;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"rdf-data-factory":155,"relative-to-absolute-iri":188}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],121:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ItemPropertyHandlerContent = void 0;
/**
 * Handler for an item property with the 'content' attribute.
 */

var ItemPropertyHandlerContent = /*#__PURE__*/function () {
  function ItemPropertyHandlerContent() {
    (0, _classCallCheck2["default"])(this, ItemPropertyHandlerContent);
  }

  (0, _createClass2["default"])(ItemPropertyHandlerContent, [{
    key: "canHandle",
    value: function canHandle(tagName, attributes) {
      return 'content' in attributes;
    }
  }, {
    key: "getObject",
    value: function getObject(attributes, util, itemScope) {
      return util.createLiteral(attributes.content, itemScope);
    }
  }]);
  return ItemPropertyHandlerContent;
}();

exports.ItemPropertyHandlerContent = ItemPropertyHandlerContent;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],122:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ItemPropertyHandlerNumber = void 0;

var Util_1 = require("../Util");
/**
 * Handler for an item property with a number attribute.
 */


var ItemPropertyHandlerNumber = /*#__PURE__*/function () {
  function ItemPropertyHandlerNumber(tagName, attributeName) {
    (0, _classCallCheck2["default"])(this, ItemPropertyHandlerNumber);
    this.tagName = tagName;
    this.attributeName = attributeName;
  }

  (0, _createClass2["default"])(ItemPropertyHandlerNumber, [{
    key: "canHandle",
    value: function canHandle(tagName, attributes) {
      return this.tagName === tagName && this.attributeName in attributes;
    }
  }, {
    key: "getObject",
    value: function getObject(attributes, util, itemScope) {
      var value = attributes[this.attributeName];
      var datatype;

      if (!Number.isNaN(Number.parseInt(value, 10)) && !value.includes('.')) {
        datatype = "".concat(Util_1.Util.XSD, "integer");
      } else if (!Number.isNaN(Number.parseFloat(value))) {
        datatype = "".concat(Util_1.Util.XSD, "double");
      }

      return util.dataFactory.literal(value, datatype && util.dataFactory.namedNode(datatype));
    }
  }]);
  return ItemPropertyHandlerNumber;
}();

exports.ItemPropertyHandlerNumber = ItemPropertyHandlerNumber;

},{"../Util":119,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],123:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ItemPropertyHandlerTime = void 0;

var Util_1 = require("../Util");
/**
 * Handler for an item property for time tags.
 */


var ItemPropertyHandlerTime = /*#__PURE__*/function () {
  function ItemPropertyHandlerTime() {
    (0, _classCallCheck2["default"])(this, ItemPropertyHandlerTime);
  }

  (0, _createClass2["default"])(ItemPropertyHandlerTime, [{
    key: "canHandle",
    value: function canHandle(tagName, attributes) {
      return tagName === 'time' && 'datetime' in attributes;
    }
  }, {
    key: "getObject",
    value: function getObject(attributes, util, itemScope) {
      var value = attributes.datetime;
      var datatype;

      var _iterator = _createForOfIteratorHelper(ItemPropertyHandlerTime.TIME_REGEXES),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var entry = _step.value;

          if (entry.regex.exec(value)) {
            datatype = util.dataFactory.namedNode(Util_1.Util.XSD + entry.type);
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return util.dataFactory.literal(value, datatype);
    }
  }]);
  return ItemPropertyHandlerTime;
}();

exports.ItemPropertyHandlerTime = ItemPropertyHandlerTime;
ItemPropertyHandlerTime.TIME_REGEXES = [{
  regex: /^\x2D?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9])?S)?)?$/,
  type: 'duration'
}, {
  regex: /^[0-9]+\x2D[0-9][0-9]\x2D[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+\x2D][0-9][0-9]:[0-9][0-9]))$/,
  type: 'dateTime'
}, {
  regex: /^[0-9]+\x2D[0-9][0-9]\x2D[0-9][0-9]Z?$/,
  type: 'date'
}, {
  regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+\x2D][0-9][0-9]:[0-9][0-9]))$/,
  type: 'time'
}, {
  regex: /^[0-9]+\x2D[0-9][0-9]$/,
  type: 'gYearMonth'
}, {
  regex: /^[0-9]+$/,
  type: 'gYear'
}];

},{"../Util":119,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],124:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ItemPropertyHandlerUrl = void 0;

var relative_to_absolute_iri_1 = require("relative-to-absolute-iri");
/**
 * Handler for an item property with a URL attribute.
 */


var ItemPropertyHandlerUrl = /*#__PURE__*/function () {
  function ItemPropertyHandlerUrl(tagName, attributeName) {
    (0, _classCallCheck2["default"])(this, ItemPropertyHandlerUrl);
    this.tagName = tagName;
    this.attributeName = attributeName;
  }

  (0, _createClass2["default"])(ItemPropertyHandlerUrl, [{
    key: "canHandle",
    value: function canHandle(tagName, attributes) {
      return this.tagName === tagName && this.attributeName in attributes;
    }
  }, {
    key: "getObject",
    value: function getObject(attributes, util, itemScope) {
      return util.dataFactory.namedNode(relative_to_absolute_iri_1.resolve(attributes[this.attributeName], util.baseIRI));
    }
  }]);
  return ItemPropertyHandlerUrl;
}();

exports.ItemPropertyHandlerUrl = ItemPropertyHandlerUrl;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"relative-to-absolute-iri":188}],125:[function(require,module,exports){
module.exports={
  "http://schema.org/": {
    "properties": {
      "additionalType": {"subPropertyOf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"}
    }
  },
  "http://microformats.org/profile/hcard": {}
}

},{}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    XSD = 'http://www.w3.org/2001/XMLSchema#',
    SWAP = 'http://www.w3.org/2000/10/swap/';
var _default = {
  xsd: {
    decimal: XSD + 'decimal',
    "boolean": XSD + 'boolean',
    "double": XSD + 'double',
    integer: XSD + 'integer',
    string: XSD + 'string'
  },
  rdf: {
    type: RDF + 'type',
    nil: RDF + 'nil',
    first: RDF + 'first',
    rest: RDF + 'rest',
    langString: RDF + 'langString'
  },
  owl: {
    sameAs: 'http://www.w3.org/2002/07/owl#sameAs'
  },
  r: {
    forSome: SWAP + 'reify#forSome',
    forAll: SWAP + 'reify#forAll'
  },
  log: {
    implies: SWAP + 'log#implies'
  }
};
exports["default"] = _default;

},{}],127:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _assertThisInitialized2 = _interopRequireDefault2(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.termFromId = termFromId;
exports.termToId = termToId;
exports.escapeQuotes = escapeQuotes;
exports.unescapeQuotes = unescapeQuotes;
exports.Triple = exports.Quad = exports.DefaultGraph = exports.Variable = exports.BlankNode = exports.Literal = exports.NamedNode = exports.Term = exports["default"] = void 0;

var _IRIs = _interopRequireDefault(require("./IRIs"));

var _N3Util = require("./N3Util");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // N3.js implementations of the RDF/JS core data types
// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md


var _IRIs$default = _IRIs["default"],
    rdf = _IRIs$default.rdf,
    xsd = _IRIs$default.xsd;
var DEFAULTGRAPH;
var _blankNodeCounter = 0;
var escapedLiteral = /^"(.*".*)(?="[^"]*$)/;
var quadId = /^<<("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ?("(?:""|[^"])*"[^ ]*|[^ ]+)?>>$/; // ## DataFactory singleton

var DataFactory = {
  namedNode: namedNode,
  blankNode: blankNode,
  variable: variable,
  literal: literal,
  defaultGraph: defaultGraph,
  quad: quad,
  triple: quad
};
var _default = DataFactory; // ## Term constructor

exports["default"] = _default;

var Term = /*#__PURE__*/function () {
  function Term(id) {
    (0, _classCallCheck2["default"])(this, Term);
    this.id = id;
  } // ### The value of this term


  (0, _createClass2["default"])(Term, [{
    key: "equals",
    // ### Returns whether this object represents the same term as the other
    value: function equals(other) {
      // If both terms were created by this library,
      // equality can be computed through ids
      if (other instanceof Term) return this.id === other.id; // Otherwise, compare term type and value

      return !!other && this.termType === other.termType && this.value === other.value;
    } // ### Returns a plain object representation of this term

  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        termType: this.termType,
        value: this.value
      };
    }
  }, {
    key: "value",
    get: function get() {
      return this.id;
    }
  }]);
  return Term;
}(); // ## NamedNode constructor


exports.Term = Term;

var NamedNode = /*#__PURE__*/function (_Term) {
  (0, _inherits2["default"])(NamedNode, _Term);

  var _super = _createSuper(NamedNode);

  function NamedNode() {
    (0, _classCallCheck2["default"])(this, NamedNode);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(NamedNode, [{
    key: "termType",
    // ### The term type of this term
    get: function get() {
      return 'NamedNode';
    }
  }]);
  return NamedNode;
}(Term); // ## Literal constructor


exports.NamedNode = NamedNode;

var Literal = /*#__PURE__*/function (_Term2) {
  (0, _inherits2["default"])(Literal, _Term2);

  var _super2 = _createSuper(Literal);

  function Literal() {
    (0, _classCallCheck2["default"])(this, Literal);
    return _super2.apply(this, arguments);
  }

  (0, _createClass2["default"])(Literal, [{
    key: "equals",
    // ### Returns whether this object represents the same term as the other
    value: function equals(other) {
      // If both literals were created by this library,
      // equality can be computed through ids
      if (other instanceof Literal) return this.id === other.id; // Otherwise, compare term type, value, language, and datatype

      return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        termType: this.termType,
        value: this.value,
        language: this.language,
        datatype: {
          termType: 'NamedNode',
          value: this.datatypeString
        }
      };
    }
  }, {
    key: "termType",
    // ### The term type of this term
    get: function get() {
      return 'Literal';
    } // ### The text value of this literal

  }, {
    key: "value",
    get: function get() {
      return this.id.substring(1, this.id.lastIndexOf('"'));
    } // ### The language of this literal

  }, {
    key: "language",
    get: function get() {
      // Find the last quotation mark (e.g., '"abc"@en-us')
      var id = this.id,
          atPos = id.lastIndexOf('"') + 1; // If "@" it follows, return the remaining substring; empty otherwise

      return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';
    } // ### The datatype IRI of this literal

  }, {
    key: "datatype",
    get: function get() {
      return new NamedNode(this.datatypeString);
    } // ### The datatype string of this literal

  }, {
    key: "datatypeString",
    get: function get() {
      // Find the last quotation mark (e.g., '"abc"^^http://ex.org/types#t')
      var id = this.id,
          dtPos = id.lastIndexOf('"') + 1,
          ch; // If "^" it follows, return the remaining substring

      return dtPos < id.length && (ch = id[dtPos]) === '^' ? id.substr(dtPos + 2) : // If "@" follows, return rdf:langString; xsd:string otherwise
      ch !== '@' ? xsd.string : rdf.langString;
    }
  }]);
  return Literal;
}(Term); // ## BlankNode constructor


exports.Literal = Literal;

var BlankNode = /*#__PURE__*/function (_Term3) {
  (0, _inherits2["default"])(BlankNode, _Term3);

  var _super3 = _createSuper(BlankNode);

  function BlankNode(name) {
    (0, _classCallCheck2["default"])(this, BlankNode);
    return _super3.call(this, '_:' + name);
  } // ### The term type of this term


  (0, _createClass2["default"])(BlankNode, [{
    key: "termType",
    get: function get() {
      return 'BlankNode';
    } // ### The name of this blank node

  }, {
    key: "value",
    get: function get() {
      return this.id.substr(2);
    }
  }]);
  return BlankNode;
}(Term);

exports.BlankNode = BlankNode;

var Variable = /*#__PURE__*/function (_Term4) {
  (0, _inherits2["default"])(Variable, _Term4);

  var _super4 = _createSuper(Variable);

  function Variable(name) {
    (0, _classCallCheck2["default"])(this, Variable);
    return _super4.call(this, '?' + name);
  } // ### The term type of this term


  (0, _createClass2["default"])(Variable, [{
    key: "termType",
    get: function get() {
      return 'Variable';
    } // ### The name of this variable

  }, {
    key: "value",
    get: function get() {
      return this.id.substr(1);
    }
  }]);
  return Variable;
}(Term); // ## DefaultGraph constructor


exports.Variable = Variable;

var DefaultGraph = /*#__PURE__*/function (_Term5) {
  (0, _inherits2["default"])(DefaultGraph, _Term5);

  var _super5 = _createSuper(DefaultGraph);

  function DefaultGraph() {
    var _this;

    (0, _classCallCheck2["default"])(this, DefaultGraph);
    _this = _super5.call(this, '');
    return (0, _possibleConstructorReturn2["default"])(_this, DEFAULTGRAPH || (0, _assertThisInitialized2["default"])(_this));
  } // ### The term type of this term


  (0, _createClass2["default"])(DefaultGraph, [{
    key: "equals",
    // ### Returns whether this object represents the same term as the other
    value: function equals(other) {
      // If both terms were created by this library,
      // equality can be computed through strict equality;
      // otherwise, compare term types.
      return this === other || !!other && this.termType === other.termType;
    }
  }, {
    key: "termType",
    get: function get() {
      return 'DefaultGraph';
    }
  }]);
  return DefaultGraph;
}(Term); // ## DefaultGraph singleton


exports.DefaultGraph = DefaultGraph;
DEFAULTGRAPH = new DefaultGraph(); // ### Constructs a term from the given internal string ID

function termFromId(id, factory) {
  factory = factory || DataFactory; // Falsy value or empty string indicate the default graph

  if (!id) return factory.defaultGraph(); // Identify the term type based on the first character

  switch (id[0]) {
    case '?':
      return factory.variable(id.substr(1));

    case '_':
      return factory.blankNode(id.substr(2));

    case '"':
      // Shortcut for internal literals
      if (factory === DataFactory) return new Literal(id); // Literal without datatype or language

      if (id[id.length - 1] === '"') return factory.literal(id.substr(1, id.length - 2)); // Literal with datatype or language

      var endPos = id.lastIndexOf('"', id.length - 1);
      return factory.literal(id.substr(1, endPos - 1), id[endPos + 1] === '@' ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3)));

    case '<':
      var components = quadId.exec(id);
      return factory.quad(termFromId(unescapeQuotes(components[1]), factory), termFromId(unescapeQuotes(components[2]), factory), termFromId(unescapeQuotes(components[3]), factory), components[4] && termFromId(unescapeQuotes(components[4]), factory));

    default:
      return factory.namedNode(id);
  }
} // ### Constructs an internal string ID from the given term or ID string


function termToId(term) {
  if (typeof term === 'string') return term;
  if (term instanceof Term && term.termType !== 'Quad') return term.id;
  if (!term) return DEFAULTGRAPH.id; // Term instantiated with another library

  switch (term.termType) {
    case 'NamedNode':
      return term.value;

    case 'BlankNode':
      return '_:' + term.value;

    case 'Variable':
      return '?' + term.value;

    case 'DefaultGraph':
      return '';

    case 'Literal':
      return '"' + term.value + '"' + (term.language ? '@' + term.language : term.datatype && term.datatype.value !== xsd.string ? '^^' + term.datatype.value : '');

    case 'Quad':
      // To identify RDF* quad components, we escape quotes by doubling them.
      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.
      return "<<".concat(escapeQuotes(termToId(term.subject)), " ").concat(escapeQuotes(termToId(term.predicate)), " ").concat(escapeQuotes(termToId(term.object))).concat((0, _N3Util.isDefaultGraph)(term.graph) ? '' : " ".concat(termToId(term.graph)), ">>");

    default:
      throw new Error('Unexpected termType: ' + term.termType);
  }
} // ## Quad constructor


var Quad = /*#__PURE__*/function (_Term6) {
  (0, _inherits2["default"])(Quad, _Term6);

  var _super6 = _createSuper(Quad);

  function Quad(subject, predicate, object, graph) {
    var _this2;

    (0, _classCallCheck2["default"])(this, Quad);
    _this2 = _super6.call(this, '');
    _this2.subject = subject;
    _this2.predicate = predicate;
    _this2.object = object;
    _this2.graph = graph || DEFAULTGRAPH;
    return _this2;
  } // ### The term type of this term


  (0, _createClass2["default"])(Quad, [{
    key: "toJSON",
    // ### Returns a plain object representation of this quad
    value: function toJSON() {
      return {
        termType: this.termType,
        subject: this.subject.toJSON(),
        predicate: this.predicate.toJSON(),
        object: this.object.toJSON(),
        graph: this.graph.toJSON()
      };
    } // ### Returns whether this object represents the same quad as the other

  }, {
    key: "equals",
    value: function equals(other) {
      return !!other && this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph);
    }
  }, {
    key: "termType",
    get: function get() {
      return 'Quad';
    }
  }]);
  return Quad;
}(Term);

exports.Triple = exports.Quad = Quad; // ### Escapes the quotes within the given literal

function escapeQuotes(id) {
  return id.replace(escapedLiteral, function (_, quoted) {
    return "\"".concat(quoted.replace(/"/g, '""'));
  });
} // ### Unescapes the quotes within the given literal


function unescapeQuotes(id) {
  return id.replace(escapedLiteral, function (_, quoted) {
    return "\"".concat(quoted.replace(/""/g, '"'));
  });
} // ### Creates an IRI


function namedNode(iri) {
  return new NamedNode(iri);
} // ### Creates a blank node


function blankNode(name) {
  return new BlankNode(name || "n3-".concat(_blankNodeCounter++));
} // ### Creates a literal


function literal(value, languageOrDataType) {
  // Create a language-tagged string
  if (typeof languageOrDataType === 'string') return new Literal('"' + value + '"@' + languageOrDataType.toLowerCase()); // Automatically determine datatype for booleans and numbers

  var datatype = languageOrDataType ? languageOrDataType.value : '';

  if (datatype === '') {
    // Convert a boolean
    if (typeof value === 'boolean') datatype = xsd["boolean"]; // Convert an integer or double
    else if (typeof value === 'number') {
        if (Number.isFinite(value)) datatype = Number.isInteger(value) ? xsd.integer : xsd["double"];else {
          datatype = xsd["double"];
          if (!Number.isNaN(value)) value = value > 0 ? 'INF' : '-INF';
        }
      }
  } // Create a datatyped literal


  return datatype === '' || datatype === xsd.string ? new Literal('"' + value + '"') : new Literal('"' + value + '"^^' + datatype);
} // ### Creates a variable


function variable(name) {
  return new Variable(name);
} // ### Returns the default graph


function defaultGraph() {
  return DEFAULTGRAPH;
} // ### Creates a quad


function quad(subject, predicate, object, graph) {
  return new Quad(subject, predicate, object, graph);
}

},{"./IRIs":126,"./N3Util":133,"@babel/runtime/helpers/assertThisInitialized":5,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22}],128:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _IRIs = _interopRequireDefault(require("./IRIs"));

var _queueMicrotask = _interopRequireDefault(require("queue-microtask"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3Lexer** tokenizes N3 documents.


var xsd = _IRIs["default"].xsd; // Regular expression and replacement string to escape N3 strings

var escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g;
var escapeReplacements = {
  '\\': '\\',
  "'": "'",
  '"': '"',
  'n': '\n',
  'r': '\r',
  't': '\t',
  'f': '\f',
  'b': '\b',
  '_': '_',
  '~': '~',
  '.': '.',
  '-': '-',
  '!': '!',
  '$': '$',
  '&': '&',
  '(': '(',
  ')': ')',
  '*': '*',
  '+': '+',
  ',': ',',
  ';': ';',
  '=': '=',
  '/': '/',
  '?': '?',
  '#': '#',
  '@': '@',
  '%': '%'
};
var illegalIriChars = /[\x00-\x20<>\\"\{\}\|\^\`]/;
var lineModeRegExps = {
  _iri: true,
  _unescapedIri: true,
  _simpleQuotedString: true,
  _langcode: true,
  _blank: true,
  _newline: true,
  _comment: true,
  _whitespace: true,
  _endOfFile: true
};
var invalidRegExp = /$0^/; // ## Constructor

var N3Lexer = /*#__PURE__*/function () {
  function N3Lexer(options) {
    (0, _classCallCheck2["default"])(this, N3Lexer);
    // ## Regular expressions
    // It's slightly faster to have these as properties than as in-scope variables
    this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/; // IRI with escape sequences; needs sanity check after unescaping

    this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/; // IRI without escape sequences; no unescaping

    this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/; // string without escape sequences

    this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/;
    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i;
    this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/;
    this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/;
    this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/;
    this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/;
    this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/;
    this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/;
    this._keyword = /^@[a-z]+(?=[\s#<:])/i;
    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i;
    this._shortPredicates = /^a(?=[\s()\[\]\{\}"'<>])/;
    this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/;
    this._comment = /#([^\n\r]*)/;
    this._whitespace = /^[ \t]+/;
    this._endOfFile = /^(?:#[^\n\r]*)?$/;
    options = options || {}; // In line mode (N-Triples or N-Quads), only simple features may be parsed

    if (this._lineMode = !!options.lineMode) {
      this._n3Mode = false; // Don't tokenize special literals

      for (var key in this) {
        if (!(key in lineModeRegExps) && this[key] instanceof RegExp) this[key] = invalidRegExp;
      }
    } // When not in line mode, enable N3 functionality by default
    else {
        this._n3Mode = options.n3 !== false;
      } // Don't output comment tokens by default


    this._comments = !!options.comments; // Cache the last tested closing position of long literals

    this._literalClosingPos = 0;
  } // ## Private methods
  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback


  (0, _createClass2["default"])(N3Lexer, [{
    key: "_tokenizeToEnd",
    value: function _tokenizeToEnd(callback, inputFinished) {
      // Continue parsing as far as possible; the loop will return eventually
      var input = this._input,
          outputComments = this._comments;

      while (true) {
        // Count and skip whitespace lines
        var whiteSpaceMatch, comment;

        while (whiteSpaceMatch = this._newline.exec(input)) {
          // Try to find a comment
          if (outputComments && (comment = this._comment.exec(whiteSpaceMatch[0]))) callback(null, {
            line: this._line,
            type: 'comment',
            value: comment[1],
            prefix: ''
          }); // Advance the input

          input = input.substr(whiteSpaceMatch[0].length, input.length);
          this._line++;
        } // Skip whitespace on current line


        if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input))) input = input.substr(whiteSpaceMatch[0].length, input.length); // Stop for now if we're at the end

        if (this._endOfFile.test(input)) {
          // If the input is finished, emit EOF
          if (inputFinished) {
            // Try to find a final comment
            if (outputComments && (comment = this._comment.exec(input))) callback(null, {
              line: this._line,
              type: 'comment',
              value: comment[1],
              prefix: ''
            });
            callback(input = null, {
              line: this._line,
              type: 'eof',
              value: '',
              prefix: ''
            });
          }

          return this._input = input;
        } // Look for specific token types based on the first character


        var line = this._line,
            type = '',
            value = '',
            prefix = '',
            firstChar = input[0],
            match = null,
            matchLength = 0,
            inconclusive = false;

        switch (firstChar) {
          case '^':
            // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed
            if (input.length < 3) break; // Try to match a type
            else if (input[1] === '^') {
                this._previousMarker = '^^'; // Move to type IRI or prefixed name

                input = input.substr(2);

                if (input[0] !== '<') {
                  inconclusive = true;
                  break;
                }
              } // If no type, it must be a path expression
              else {
                  if (this._n3Mode) {
                    matchLength = 1;
                    type = '^';
                  }

                  break;
                }
          // Fall through in case the type is an IRI

          case '<':
            // Try to find a full IRI without escape sequences
            if (match = this._unescapedIri.exec(input)) type = 'IRI', value = match[1]; // Try to find a full IRI with escape sequences
            else if (match = this._iri.exec(input)) {
                value = this._unescape(match[1]);
                if (value === null || illegalIriChars.test(value)) return reportSyntaxError(this);
                type = 'IRI';
              } // Try to find a nested triple
              else if (input.length > 1 && input[1] === '<') type = '<<', matchLength = 2; // Try to find a backwards implication arrow
                else if (this._n3Mode && input.length > 1 && input[1] === '=') type = 'inverse', matchLength = 2, value = '>';
            break;

          case '>':
            if (input.length > 1 && input[1] === '>') type = '>>', matchLength = 2;
            break;

          case '_':
            // Try to find a blank node. Since it can contain (but not end with) a dot,
            // we always need a non-dot character before deciding it is a blank node.
            // Therefore, try inserting a space if we're at the end of the input.
            if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(input + ' '))) type = 'blank', prefix = '_', value = match[1];
            break;

          case '"':
            // Try to find a literal without escape sequences
            if (match = this._simpleQuotedString.exec(input)) value = match[1]; // Try to find a literal wrapped in three pairs of quotes
            else {
                var _this$_parseLiteral = this._parseLiteral(input);

                value = _this$_parseLiteral.value;
                matchLength = _this$_parseLiteral.matchLength;
                if (value === null) return reportSyntaxError(this);
              }

            if (match !== null || matchLength !== 0) {
              type = 'literal';
              this._literalClosingPos = 0;
            }

            break;

          case "'":
            if (!this._lineMode) {
              // Try to find a literal without escape sequences
              if (match = this._simpleApostropheString.exec(input)) value = match[1]; // Try to find a literal wrapped in three pairs of quotes
              else {
                  var _this$_parseLiteral2 = this._parseLiteral(input);

                  value = _this$_parseLiteral2.value;
                  matchLength = _this$_parseLiteral2.matchLength;
                  if (value === null) return reportSyntaxError(this);
                }

              if (match !== null || matchLength !== 0) {
                type = 'literal';
                this._literalClosingPos = 0;
              }
            }

            break;

          case '?':
            // Try to find a variable
            if (this._n3Mode && (match = this._variable.exec(input))) type = 'var', value = match[0];
            break;

          case '@':
            // Try to find a language code
            if (this._previousMarker === 'literal' && (match = this._langcode.exec(input))) type = 'langcode', value = match[1]; // Try to find a keyword
            else if (match = this._keyword.exec(input)) type = match[0];
            break;

          case '.':
            // Try to find a dot as punctuation
            if (input.length === 1 ? inputFinished : input[1] < '0' || input[1] > '9') {
              type = '.';
              matchLength = 1;
              break;
            }

          // Fall through to numerical case (could be a decimal dot)

          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
          case '+':
          case '-':
            // Try to find a number. Since it can contain (but not end with) a dot,
            // we always need a non-dot character before deciding it is a number.
            // Therefore, try inserting a space if we're at the end of the input.
            if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(input + ' '))) {
              type = 'literal', value = match[0];
              prefix = typeof match[1] === 'string' ? xsd["double"] : typeof match[2] === 'string' ? xsd.decimal : xsd.integer;
            }

            break;

          case 'B':
          case 'b':
          case 'p':
          case 'P':
          case 'G':
          case 'g':
            // Try to find a SPARQL-style keyword
            if (match = this._sparqlKeyword.exec(input)) type = match[0].toUpperCase();else inconclusive = true;
            break;

          case 'f':
          case 't':
            // Try to match a boolean
            if (match = this._boolean.exec(input)) type = 'literal', value = match[0], prefix = xsd["boolean"];else inconclusive = true;
            break;

          case 'a':
            // Try to find an abbreviated predicate
            if (match = this._shortPredicates.exec(input)) type = 'abbreviation', value = 'a';else inconclusive = true;
            break;

          case '=':
            // Try to find an implication arrow or equals sign
            if (this._n3Mode && input.length > 1) {
              type = 'abbreviation';
              if (input[1] !== '>') matchLength = 1, value = '=';else matchLength = 2, value = '>';
            }

            break;

          case '!':
            if (!this._n3Mode) break;

          case ',':
          case ';':
          case '[':
          case ']':
          case '(':
          case ')':
          case '{':
          case '}':
            if (!this._lineMode) {
              matchLength = 1;
              type = firstChar;
            }

            break;

          default:
            inconclusive = true;
        } // Some first characters do not allow an immediate decision, so inspect more


        if (inconclusive) {
          // Try to find a prefix
          if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') && (match = this._prefix.exec(input))) type = 'prefix', value = match[1] || ''; // Try to find a prefixed name. Since it can contain (but not end with) a dot,
          // we always need a non-dot character before deciding it is a prefixed name.
          // Therefore, try inserting a space if we're at the end of the input.
          else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(input + ' '))) type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);
        } // A type token is special: it can only be emitted after an IRI or prefixed name is read


        if (this._previousMarker === '^^') {
          switch (type) {
            case 'prefixed':
              type = 'type';
              break;

            case 'IRI':
              type = 'typeIRI';
              break;

            default:
              type = '';
          }
        } // What if nothing of the above was found?


        if (!type) {
          // We could be in streaming mode, and then we just wait for more input to arrive.
          // Otherwise, a syntax error has occurred in the input.
          // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).
          if (inputFinished || !/^'''|^"""/.test(input) && /\n|\r/.test(input)) return reportSyntaxError(this);else return this._input = input;
        } // Emit the parsed token


        var token = {
          line: line,
          type: type,
          value: value,
          prefix: prefix
        };
        callback(null, token);
        this.previousToken = token;
        this._previousMarker = type; // Advance to next part to tokenize

        input = input.substr(matchLength || match[0].length, input.length);
      } // Signals the syntax error through the callback


      function reportSyntaxError(self) {
        callback(self._syntaxError(/^\S*/.exec(input)[0]));
      }
    } // ### `_unescape` replaces N3 escape codes by their corresponding characters

  }, {
    key: "_unescape",
    value: function _unescape(item) {
      var invalid = false;
      var replaced = item.replace(escapeSequence, function (sequence, unicode4, unicode8, escapedChar) {
        // 4-digit unicode character
        if (typeof unicode4 === 'string') return String.fromCharCode(Number.parseInt(unicode4, 16)); // 8-digit unicode character

        if (typeof unicode8 === 'string') {
          var charCode = Number.parseInt(unicode8, 16);
          return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));
        } // fixed escape sequence


        if (escapedChar in escapeReplacements) return escapeReplacements[escapedChar]; // invalid escape sequence

        invalid = true;
        return '';
      });
      return invalid ? null : replaced;
    } // ### `_parseLiteral` parses a literal into an unescaped value

  }, {
    key: "_parseLiteral",
    value: function _parseLiteral(input) {
      // Ensure we have enough lookahead to identify triple-quoted strings
      if (input.length >= 3) {
        // Identify the opening quote(s)
        var opening = input.match(/^(?:"""|"|'''|'|)/)[0];
        var openingLength = opening.length; // Find the next candidate closing quotes

        var closingPos = Math.max(this._literalClosingPos, openingLength);

        while ((closingPos = input.indexOf(opening, closingPos)) > 0) {
          // Count backslashes right before the closing quotes
          var backslashCount = 0;

          while (input[closingPos - backslashCount - 1] === '\\') {
            backslashCount++;
          } // An even number of backslashes (in particular 0)
          // means these are actual, non-escaped closing quotes


          if (backslashCount % 2 === 0) {
            // Extract and unescape the value
            var raw = input.substring(openingLength, closingPos);
            var lines = raw.split(/\r\n|\r|\n/).length - 1;
            var matchLength = closingPos + openingLength; // Only triple-quoted strings can be multi-line

            if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode) break;
            this._line += lines;
            return {
              value: this._unescape(raw),
              matchLength: matchLength
            };
          }

          closingPos++;
        }

        this._literalClosingPos = input.length - openingLength + 1;
      }

      return {
        value: '',
        matchLength: 0
      };
    } // ### `_syntaxError` creates a syntax error for the given issue

  }, {
    key: "_syntaxError",
    value: function _syntaxError(issue) {
      this._input = null;
      var err = new Error('Unexpected "' + issue + '" on line ' + this._line + '.');
      err.context = {
        token: undefined,
        line: this._line,
        previousToken: this.previousToken
      };
      return err;
    } // ## Public methods
    // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
    // The input can be a string or a stream.

  }, {
    key: "tokenize",
    value: function tokenize(input, callback) {
      var self = this;
      this._line = 1; // If the input is a string, continuously emit tokens through the callback until the end

      if (typeof input === 'string') {
        this._input = input; // If a callback was passed, asynchronously call it

        if (typeof callback === 'function') (0, _queueMicrotask["default"])(function () {
          return self._tokenizeToEnd(callback, true);
        }); // If no callback was passed, tokenize synchronously and return
        else {
            var tokens = [],
                error;

            this._tokenizeToEnd(function (e, t) {
              e ? error = e : tokens.push(t);
            }, true);

            if (error) throw error;
            return tokens;
          }
      } // Otherwise, the input must be a stream
      else {
          this._input = '';
          this._pendingBuffer = null;
          if (typeof input.setEncoding === 'function') input.setEncoding('utf8'); // Adds the data chunk to the buffer and parses as far as possible

          input.on('data', function (data) {
            if (self._input !== null && data.length !== 0) {
              // Prepend any previous pending writes
              if (self._pendingBuffer) {
                data = Buffer.concat([self._pendingBuffer, data]);
                self._pendingBuffer = null;
              } // Hold if the buffer ends in an incomplete unicode sequence


              if (data[data.length - 1] & 0x80) {
                self._pendingBuffer = data;
              } // Otherwise, tokenize as far as possible
              else {
                  self._input += data;

                  self._tokenizeToEnd(callback, false);
                }
            }
          }); // Parses until the end

          input.on('end', function () {
            if (self._input !== null) self._tokenizeToEnd(callback, true);
          });
          input.on('error', callback);
        }
    }
  }]);
  return N3Lexer;
}();

exports["default"] = N3Lexer;

}).call(this)}).call(this,require("buffer").Buffer)

},{"./IRIs":126,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"buffer":60,"queue-microtask":143}],129:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _N3Lexer = _interopRequireDefault(require("./N3Lexer"));

var _N3DataFactory = _interopRequireDefault(require("./N3DataFactory"));

var _IRIs = _interopRequireDefault(require("./IRIs"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3Parser** parses N3 documents.


var blankNodePrefix = 0; // ## Constructor

var N3Parser = /*#__PURE__*/function () {
  function N3Parser(options) {
    (0, _classCallCheck2["default"])(this, N3Parser);
    this._contextStack = [];
    this._graph = null; // Set the document IRI

    options = options || {};

    this._setBase(options.baseIRI);

    options.factory && initDataFactory(this, options.factory); // Set supported features depending on the format

    var format = typeof options.format === 'string' ? options.format.match(/\w*$/)[0].toLowerCase() : '',
        isTurtle = /turtle/.test(format),
        isTriG = /trig/.test(format),
        isNTriples = /triple/.test(format),
        isNQuads = /quad/.test(format),
        isN3 = this._n3Mode = /n3/.test(format),
        isLineMode = isNTriples || isNQuads;
    if (!(this._supportsNamedGraphs = !(isTurtle || isN3))) this._readPredicateOrNamedGraph = this._readPredicate; // Support triples in other graphs

    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3); // Support nesting of triples

    this._supportsRDFStar = format === '' || /star|\*$/.test(format); // Disable relative IRIs in N-Triples or N-Quads mode

    if (isLineMode) this._resolveRelativeIRI = function (iri) {
      return null;
    };
    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' : options.blankNodePrefix.replace(/^(?!_:)/, '_:');
    this._lexer = options.lexer || new _N3Lexer["default"]({
      lineMode: isLineMode,
      n3: isN3
    }); // Disable explicit quantifiers by default

    this._explicitQuantifiers = !!options.explicitQuantifiers;
  } // ## Static class methods
  // ### `_resetBlankNodePrefix` restarts blank node prefix identification


  (0, _createClass2["default"])(N3Parser, [{
    key: "_setBase",
    // ## Private methods
    // ### `_setBase` sets the base IRI to resolve relative IRIs
    value: function _setBase(baseIRI) {
      if (!baseIRI) {
        this._base = '';
        this._basePath = '';
      } else {
        // Remove fragment if present
        var fragmentPos = baseIRI.indexOf('#');
        if (fragmentPos >= 0) baseIRI = baseIRI.substr(0, fragmentPos); // Set base IRI and its components

        this._base = baseIRI;
        this._basePath = baseIRI.indexOf('/') < 0 ? baseIRI : baseIRI.replace(/[^\/?]*(?:\?.*)?$/, '');
        baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i);
        this._baseRoot = baseIRI[0];
        this._baseScheme = baseIRI[1];
      }
    } // ### `_saveContext` stores the current parsing context
    // when entering a new scope (list, blank node, formula)

  }, {
    key: "_saveContext",
    value: function _saveContext(type, graph, subject, predicate, object) {
      var n3Mode = this._n3Mode;

      this._contextStack.push({
        subject: subject,
        predicate: predicate,
        object: object,
        graph: graph,
        type: type,
        inverse: n3Mode ? this._inversePredicate : false,
        blankPrefix: n3Mode ? this._prefixes._ : '',
        quantified: n3Mode ? this._quantified : null
      }); // The settings below only apply to N3 streams


      if (n3Mode) {
        // Every new scope resets the predicate direction
        this._inversePredicate = false; // In N3, blank nodes are scoped to a formula
        // (using a dot as separator, as a blank node label cannot start with it)

        this._prefixes._ = this._graph ? this._graph.id.substr(2) + '.' : '.'; // Quantifiers are scoped to a formula

        this._quantified = Object.create(this._quantified);
      }
    } // ### `_restoreContext` restores the parent context
    // when leaving a scope (list, blank node, formula)

  }, {
    key: "_restoreContext",
    value: function _restoreContext() {
      var context = this._contextStack.pop(),
          n3Mode = this._n3Mode;

      this._subject = context.subject;
      this._predicate = context.predicate;
      this._object = context.object;
      this._graph = context.graph; // The settings below only apply to N3 streams

      if (n3Mode) {
        this._inversePredicate = context.inverse;
        this._prefixes._ = context.blankPrefix;
        this._quantified = context.quantified;
      }
    } // ### `_readInTopContext` reads a token when in the top context

  }, {
    key: "_readInTopContext",
    value: function _readInTopContext(token) {
      switch (token.type) {
        // If an EOF token arrives in the top context, signal that we're done
        case 'eof':
          if (this._graph !== null) return this._error('Unclosed graph', token);
          delete this._prefixes._;
          return this._callback(null, null, this._prefixes);
        // It could be a prefix declaration

        case 'PREFIX':
          this._sparqlStyle = true;

        case '@prefix':
          return this._readPrefix;
        // It could be a base declaration

        case 'BASE':
          this._sparqlStyle = true;

        case '@base':
          return this._readBaseIRI;
        // It could be a graph

        case '{':
          if (this._supportsNamedGraphs) {
            this._graph = '';
            this._subject = null;
            return this._readSubject;
          }

        case 'GRAPH':
          if (this._supportsNamedGraphs) return this._readNamedGraphLabel;
        // Otherwise, the next token must be a subject

        default:
          return this._readSubject(token);
      }
    } // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable

  }, {
    key: "_readEntity",
    value: function _readEntity(token, quantifier) {
      var value;

      switch (token.type) {
        // Read a relative or absolute IRI
        case 'IRI':
        case 'typeIRI':
          var iri = this._resolveIRI(token.value);

          if (iri === null) return this._error('Invalid IRI', token);
          value = this._namedNode(iri);
          break;
        // Read a prefixed name

        case 'type':
        case 'prefixed':
          var prefix = this._prefixes[token.prefix];
          if (prefix === undefined) return this._error('Undefined prefix "' + token.prefix + ':"', token);
          value = this._namedNode(prefix + token.value);
          break;
        // Read a blank node

        case 'blank':
          value = this._blankNode(this._prefixes[token.prefix] + token.value);
          break;
        // Read a variable

        case 'var':
          value = this._variable(token.value.substr(1));
          break;
        // Everything else is not an entity

        default:
          return this._error('Expected entity but got ' + token.type, token);
      } // In N3 mode, replace the entity if it is quantified


      if (!quantifier && this._n3Mode && value.id in this._quantified) value = this._quantified[value.id];
      return value;
    } // ### `_readSubject` reads a quad's subject

  }, {
    key: "_readSubject",
    value: function _readSubject(token) {
      this._predicate = null;

      switch (token.type) {
        case '[':
          // Start a new quad with a new blank node as subject
          this._saveContext('blank', this._graph, this._subject = this._blankNode(), null, null);

          return this._readBlankNodeHead;

        case '(':
          // Start a new list
          this._saveContext('list', this._graph, this.RDF_NIL, null, null);

          this._subject = null;
          return this._readListItem;

        case '{':
          // Start a new formula
          if (!this._n3Mode) return this._error('Unexpected graph', token);

          this._saveContext('formula', this._graph, this._graph = this._blankNode(), null, null);

          return this._readSubject;

        case '}':
          // No subject; the graph in which we are reading is closed instead
          return this._readPunctuation(token);

        case '@forSome':
          if (!this._n3Mode) return this._error('Unexpected "@forSome"', token);
          this._subject = null;
          this._predicate = this.N3_FORSOME;
          this._quantifier = this._blankNode;
          return this._readQuantifierList;

        case '@forAll':
          if (!this._n3Mode) return this._error('Unexpected "@forAll"', token);
          this._subject = null;
          this._predicate = this.N3_FORALL;
          this._quantifier = this._variable;
          return this._readQuantifierList;

        case 'literal':
          if (!this._n3Mode) return this._error('Unexpected literal', token);

          if (token.prefix.length === 0) {
            this._literalValue = token.value;
            return this._completeSubjectLiteral;
          } else this._subject = this._literal(token.value, this._namedNode(token.prefix));

          break;

        case '<<':
          if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);

          this._saveContext('<<', this._graph, null, null, null);

          this._graph = null;
          return this._readSubject;

        default:
          // Read the subject entity
          if ((this._subject = this._readEntity(token)) === undefined) return; // In N3 mode, the subject might be a path

          if (this._n3Mode) return this._getPathReader(this._readPredicateOrNamedGraph);
      } // The next token must be a predicate,
      // or, if the subject was actually a graph IRI, a named graph


      return this._readPredicateOrNamedGraph;
    } // ### `_readPredicate` reads a quad's predicate

  }, {
    key: "_readPredicate",
    value: function _readPredicate(token) {
      var type = token.type;

      switch (type) {
        case 'inverse':
          this._inversePredicate = true;

        case 'abbreviation':
          this._predicate = this.ABBREVIATIONS[token.value];
          break;

        case '.':
        case ']':
        case '}':
          // Expected predicate didn't come, must have been trailing semicolon
          if (this._predicate === null) return this._error('Unexpected ' + type, token);
          this._subject = null;
          return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);

        case ';':
          // Additional semicolons can be safely ignored
          return this._predicate !== null ? this._readPredicate : this._error('Expected predicate but got ;', token);

        case 'blank':
          if (!this._n3Mode) return this._error('Disallowed blank node as predicate', token);

        default:
          if ((this._predicate = this._readEntity(token)) === undefined) return;
      } // The next token must be an object


      return this._readObject;
    } // ### `_readObject` reads a quad's object

  }, {
    key: "_readObject",
    value: function _readObject(token) {
      switch (token.type) {
        case 'literal':
          // Regular literal, can still get a datatype or language
          if (token.prefix.length === 0) {
            this._literalValue = token.value;
            return this._readDataTypeOrLang;
          } // Pre-datatyped string literal (prefix stores the datatype)
          else this._object = this._literal(token.value, this._namedNode(token.prefix));

          break;

        case '[':
          // Start a new quad with a new blank node as subject
          this._saveContext('blank', this._graph, this._subject, this._predicate, this._subject = this._blankNode());

          return this._readBlankNodeHead;

        case '(':
          // Start a new list
          this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);

          this._subject = null;
          return this._readListItem;

        case '{':
          // Start a new formula
          if (!this._n3Mode) return this._error('Unexpected graph', token);

          this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());

          return this._readSubject;

        case '<<':
          if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);

          this._saveContext('<<', this._graph, this._subject, this._predicate, null);

          this._graph = null;
          return this._readSubject;

        default:
          // Read the object entity
          if ((this._object = this._readEntity(token)) === undefined) return; // In N3 mode, the object might be a path

          if (this._n3Mode) return this._getPathReader(this._getContextEndReader());
      }

      return this._getContextEndReader();
    } // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph

  }, {
    key: "_readPredicateOrNamedGraph",
    value: function _readPredicateOrNamedGraph(token) {
      return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);
    } // ### `_readGraph` reads a graph

  }, {
    key: "_readGraph",
    value: function _readGraph(token) {
      if (token.type !== '{') return this._error('Expected graph but got ' + token.type, token); // The "subject" we read is actually the GRAPH's label

      this._graph = this._subject, this._subject = null;
      return this._readSubject;
    } // ### `_readBlankNodeHead` reads the head of a blank node

  }, {
    key: "_readBlankNodeHead",
    value: function _readBlankNodeHead(token) {
      if (token.type === ']') {
        this._subject = null;
        return this._readBlankNodeTail(token);
      } else {
        this._predicate = null;
        return this._readPredicate(token);
      }
    } // ### `_readBlankNodeTail` reads the end of a blank node

  }, {
    key: "_readBlankNodeTail",
    value: function _readBlankNodeTail(token) {
      if (token.type !== ']') return this._readBlankNodePunctuation(token); // Store blank node quad

      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this blank node

      var empty = this._predicate === null;

      this._restoreContext(); // If the blank node was the subject, continue reading the predicate


      if (this._object === null) // If the blank node was empty, it could be a named graph label
        return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank; // If the blank node was the object, restore previous context and read punctuation
      else return this._getContextEndReader();
    } // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node

  }, {
    key: "_readPredicateAfterBlank",
    value: function _readPredicateAfterBlank(token) {
      switch (token.type) {
        case '.':
        case '}':
          // No predicate is coming if the triple is terminated here
          this._subject = null;
          return this._readPunctuation(token);

        default:
          return this._readPredicate(token);
      }
    } // ### `_readListItem` reads items from a list

  }, {
    key: "_readListItem",
    value: function _readListItem(token) {
      var item = null,
          // The item of the list
      list = null,
          // The list itself
      previousList = this._subject,
          // The previous list that contains this list
      stack = this._contextStack,
          // The stack of parent contexts
      parent = stack[stack.length - 1],
          // The parent containing the current list
      next = this._readListItem; // The next function to execute

      switch (token.type) {
        case '[':
          // Stack the current list quad and start a new quad with a blank node as subject
          this._saveContext('blank', this._graph, list = this._blankNode(), this.RDF_FIRST, this._subject = item = this._blankNode());

          next = this._readBlankNodeHead;
          break;

        case '(':
          // Stack the current list quad and start a new list
          this._saveContext('list', this._graph, list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);

          this._subject = null;
          break;

        case ')':
          // Closing the list; restore the parent context
          this._restoreContext(); // If this list is contained within a parent list, return the membership quad here.
          // This will be `<parent list element> rdf:first <this list>.`.


          if (stack.length !== 0 && stack[stack.length - 1].type === 'list') this._emit(this._subject, this._predicate, this._object, this._graph); // Was this list the parent's subject?

          if (this._predicate === null) {
            // The next token is the predicate
            next = this._readPredicate; // No list tail if this was an empty list

            if (this._subject === this.RDF_NIL) return next;
          } // The list was in the parent context's object
          else {
              next = this._getContextEndReader(); // No list tail if this was an empty list

              if (this._object === this.RDF_NIL) return next;
            } // Close the list by making the head nil


          list = this.RDF_NIL;
          break;

        case 'literal':
          // Regular literal, can still get a datatype or language
          if (token.prefix.length === 0) {
            this._literalValue = token.value;
            next = this._readListItemDataTypeOrLang;
          } // Pre-datatyped string literal (prefix stores the datatype)
          else {
              item = this._literal(token.value, this._namedNode(token.prefix));
              next = this._getContextEndReader();
            }

          break;

        case '{':
          // Start a new formula
          if (!this._n3Mode) return this._error('Unexpected graph', token);

          this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());

          return this._readSubject;

        default:
          if ((item = this._readEntity(token)) === undefined) return;
      } // Create a new blank node if no item head was assigned yet


      if (list === null) this._subject = list = this._blankNode(); // Is this the first element of the list?

      if (previousList === null) {
        // This list is either the subject or the object of its parent
        if (parent.predicate === null) parent.subject = list;else parent.object = list;
      } else {
        // Continue the previous list with the current list
        this._emit(previousList, this.RDF_REST, list, this._graph);
      } // If an item was read, add it to the list


      if (item !== null) {
        // In N3 mode, the item might be a path
        if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {
          // Create a new context to add the item's path
          this._saveContext('item', this._graph, list, this.RDF_FIRST, item);

          this._subject = item, this._predicate = null; // _readPath will restore the context and output the item

          return this._getPathReader(this._readListItem);
        } // Output the item


        this._emit(list, this.RDF_FIRST, item, this._graph);
      }

      return next;
    } // ### `_readDataTypeOrLang` reads an _optional_ datatype or language

  }, {
    key: "_readDataTypeOrLang",
    value: function _readDataTypeOrLang(token) {
      return this._completeObjectLiteral(token, false);
    } // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list

  }, {
    key: "_readListItemDataTypeOrLang",
    value: function _readListItemDataTypeOrLang(token) {
      return this._completeObjectLiteral(token, true);
    } // ### `_completeLiteral` completes a literal with an optional datatype or language

  }, {
    key: "_completeLiteral",
    value: function _completeLiteral(token) {
      // Create a simple string literal by default
      var literal = this._literal(this._literalValue);

      switch (token.type) {
        // Create a datatyped literal
        case 'type':
        case 'typeIRI':
          var datatype = this._readEntity(token);

          if (datatype === undefined) return; // No datatype means an error occurred

          literal = this._literal(this._literalValue, datatype);
          token = null;
          break;
        // Create a language-tagged string

        case 'langcode':
          literal = this._literal(this._literalValue, token.value);
          token = null;
          break;
      }

      return {
        token: token,
        literal: literal
      };
    } // Completes a literal in subject position

  }, {
    key: "_completeSubjectLiteral",
    value: function _completeSubjectLiteral(token) {
      this._subject = this._completeLiteral(token).literal;
      return this._readPredicateOrNamedGraph;
    } // Completes a literal in object position

  }, {
    key: "_completeObjectLiteral",
    value: function _completeObjectLiteral(token, listItem) {
      var completed = this._completeLiteral(token);

      if (!completed) return;
      this._object = completed.literal; // If this literal was part of a list, write the item
      // (we could also check the context stack, but passing in a flag is faster)

      if (listItem) this._emit(this._subject, this.RDF_FIRST, this._object, this._graph); // If the token was consumed, continue with the rest of the input

      if (completed.token === null) return this._getContextEndReader(); // Otherwise, consume the token now
      else {
          this._readCallback = this._getContextEndReader();
          return this._readCallback(completed.token);
        }
    } // ### `_readFormulaTail` reads the end of a formula

  }, {
    key: "_readFormulaTail",
    value: function _readFormulaTail(token) {
      if (token.type !== '}') return this._readPunctuation(token); // Store the last quad of the formula

      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this formula

      this._restoreContext(); // If the formula was the subject, continue reading the predicate.
      // If the formula was the object, read punctuation.


      return this._object === null ? this._readPredicate : this._getContextEndReader();
    } // ### `_readPunctuation` reads punctuation between quads or quad parts

  }, {
    key: "_readPunctuation",
    value: function _readPunctuation(token) {
      var next,
          subject = this._subject,
          graph = this._graph,
          inversePredicate = this._inversePredicate;

      switch (token.type) {
        // A closing brace ends a graph
        case '}':
          if (this._graph === null) return this._error('Unexpected graph closing', token);
          if (this._n3Mode) return this._readFormulaTail(token);
          this._graph = null;
        // A dot just ends the statement, without sharing anything with the next

        case '.':
          this._subject = null;
          next = this._contextStack.length ? this._readSubject : this._readInTopContext;
          if (inversePredicate) this._inversePredicate = false;
          break;
        // Semicolon means the subject is shared; predicate and object are different

        case ';':
          next = this._readPredicate;
          break;
        // Comma means both the subject and predicate are shared; the object is different

        case ',':
          next = this._readObject;
          break;

        default:
          // An entity means this is a quad (only allowed if not already inside a graph)
          if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {
            next = this._readQuadPunctuation;
            break;
          }

          return this._error('Expected punctuation to follow "' + this._object.id + '"', token);
      } // A quad has been completed now, so return it


      if (subject !== null) {
        var predicate = this._predicate,
            object = this._object;
        if (!inversePredicate) this._emit(subject, predicate, object, graph);else this._emit(object, predicate, subject, graph);
      }

      return next;
    } // ### `_readBlankNodePunctuation` reads punctuation in a blank node

  }, {
    key: "_readBlankNodePunctuation",
    value: function _readBlankNodePunctuation(token) {
      var next;

      switch (token.type) {
        // Semicolon means the subject is shared; predicate and object are different
        case ';':
          next = this._readPredicate;
          break;
        // Comma means both the subject and predicate are shared; the object is different

        case ',':
          next = this._readObject;
          break;

        default:
          return this._error('Expected punctuation to follow "' + this._object.id + '"', token);
      } // A quad has been completed now, so return it


      this._emit(this._subject, this._predicate, this._object, this._graph);

      return next;
    } // ### `_readQuadPunctuation` reads punctuation after a quad

  }, {
    key: "_readQuadPunctuation",
    value: function _readQuadPunctuation(token) {
      if (token.type !== '.') return this._error('Expected dot to follow quad', token);
      return this._readInTopContext;
    } // ### `_readPrefix` reads the prefix of a prefix declaration

  }, {
    key: "_readPrefix",
    value: function _readPrefix(token) {
      if (token.type !== 'prefix') return this._error('Expected prefix to follow @prefix', token);
      this._prefix = token.value;
      return this._readPrefixIRI;
    } // ### `_readPrefixIRI` reads the IRI of a prefix declaration

  }, {
    key: "_readPrefixIRI",
    value: function _readPrefixIRI(token) {
      if (token.type !== 'IRI') return this._error('Expected IRI to follow prefix "' + this._prefix + ':"', token);

      var prefixNode = this._readEntity(token);

      this._prefixes[this._prefix] = prefixNode.value;

      this._prefixCallback(this._prefix, prefixNode);

      return this._readDeclarationPunctuation;
    } // ### `_readBaseIRI` reads the IRI of a base declaration

  }, {
    key: "_readBaseIRI",
    value: function _readBaseIRI(token) {
      var iri = token.type === 'IRI' && this._resolveIRI(token.value);

      if (!iri) return this._error('Expected valid IRI to follow base declaration', token);

      this._setBase(iri);

      return this._readDeclarationPunctuation;
    } // ### `_readNamedGraphLabel` reads the label of a named graph

  }, {
    key: "_readNamedGraphLabel",
    value: function _readNamedGraphLabel(token) {
      switch (token.type) {
        case 'IRI':
        case 'blank':
        case 'prefixed':
          return this._readSubject(token), this._readGraph;

        case '[':
          return this._readNamedGraphBlankLabel;

        default:
          return this._error('Invalid graph label', token);
      }
    } // ### `_readNamedGraphLabel` reads a blank node label of a named graph

  }, {
    key: "_readNamedGraphBlankLabel",
    value: function _readNamedGraphBlankLabel(token) {
      if (token.type !== ']') return this._error('Invalid graph label', token);
      this._subject = this._blankNode();
      return this._readGraph;
    } // ### `_readDeclarationPunctuation` reads the punctuation of a declaration

  }, {
    key: "_readDeclarationPunctuation",
    value: function _readDeclarationPunctuation(token) {
      // SPARQL-style declarations don't have punctuation
      if (this._sparqlStyle) {
        this._sparqlStyle = false;
        return this._readInTopContext(token);
      }

      if (token.type !== '.') return this._error('Expected declaration to end with a dot', token);
      return this._readInTopContext;
    } // Reads a list of quantified symbols from a @forSome or @forAll statement

  }, {
    key: "_readQuantifierList",
    value: function _readQuantifierList(token) {
      var entity;

      switch (token.type) {
        case 'IRI':
        case 'prefixed':
          if ((entity = this._readEntity(token, true)) !== undefined) break;

        default:
          return this._error('Unexpected ' + token.type, token);
      } // Without explicit quantifiers, map entities to a quantified entity


      if (!this._explicitQuantifiers) this._quantified[entity.id] = this._quantifier(this._blankNode().value); // With explicit quantifiers, output the reified quantifier
      else {
          // If this is the first item, start a new quantifier list
          if (this._subject === null) this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH); // Otherwise, continue the previous list
          else this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH); // Output the list item

          this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);
        }
      return this._readQuantifierPunctuation;
    } // Reads punctuation from a @forSome or @forAll statement

  }, {
    key: "_readQuantifierPunctuation",
    value: function _readQuantifierPunctuation(token) {
      // Read more quantifiers
      if (token.type === ',') return this._readQuantifierList; // End of the quantifier list
      else {
          // With explicit quantifiers, close the quantifier list
          if (this._explicitQuantifiers) {
            this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);

            this._subject = null;
          } // Read a dot


          this._readCallback = this._getContextEndReader();
          return this._readCallback(token);
        }
    } // ### `_getPathReader` reads a potential path and then resumes with the given function

  }, {
    key: "_getPathReader",
    value: function _getPathReader(afterPath) {
      this._afterPath = afterPath;
      return this._readPath;
    } // ### `_readPath` reads a potential path

  }, {
    key: "_readPath",
    value: function _readPath(token) {
      switch (token.type) {
        // Forward path
        case '!':
          return this._readForwardPath;
        // Backward path

        case '^':
          return this._readBackwardPath;
        // Not a path; resume reading where we left off

        default:
          var stack = this._contextStack,
              parent = stack.length && stack[stack.length - 1]; // If we were reading a list item, we still need to output it

          if (parent && parent.type === 'item') {
            // The list item is the remaining subejct after reading the path
            var item = this._subject; // Switch back to the context of the list

            this._restoreContext(); // Output the list item


            this._emit(this._subject, this.RDF_FIRST, item, this._graph);
          }

          return this._afterPath(token);
      }
    } // ### `_readForwardPath` reads a '!' path

  }, {
    key: "_readForwardPath",
    value: function _readForwardPath(token) {
      var subject,
          predicate,
          object = this._blankNode(); // The next token is the predicate


      if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's object

      if (this._predicate === null) subject = this._subject, this._subject = object; // If we were reading an object, replace the subject by the path's object
      else subject = this._object, this._object = object; // Emit the path's current quad and read its next section

      this._emit(subject, predicate, object, this._graph);

      return this._readPath;
    } // ### `_readBackwardPath` reads a '^' path

  }, {
    key: "_readBackwardPath",
    value: function _readBackwardPath(token) {
      var subject = this._blankNode(),
          predicate,
          object; // The next token is the predicate


      if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's subject

      if (this._predicate === null) object = this._subject, this._subject = subject; // If we were reading an object, replace the subject by the path's subject
      else object = this._object, this._object = subject; // Emit the path's current quad and read its next section

      this._emit(subject, predicate, object, this._graph);

      return this._readPath;
    } // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple

  }, {
    key: "_readRDFStarTailOrGraph",
    value: function _readRDFStarTailOrGraph(token) {
      if (token.type !== '>>') {
        // An entity means this is a quad (only allowed if not already inside a graph)
        if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined) return this._readRDFStarTail;
        return this._error('Expected >> to follow "' + this._object.id + '"', token);
      }

      return this._readRDFStarTail(token);
    } // ### `_readRDFStarTail` reads the end of a nested RDF* triple

  }, {
    key: "_readRDFStarTail",
    value: function _readRDFStarTail(token) {
      if (token.type !== '>>') return this._error("Expected >> but got ".concat(token.type), token); // Read the quad and restore the previous context

      var quad = this._quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);

      this._restoreContext(); // If the triple was the subject, continue by reading the predicate.


      if (this._subject === null) {
        this._subject = quad;
        return this._readPredicate;
      } // If the triple was the object, read context end.
      else {
          this._object = quad;
          return this._getContextEndReader();
        }
    } // ### `_getContextEndReader` gets the next reader function at the end of a context

  }, {
    key: "_getContextEndReader",
    value: function _getContextEndReader() {
      var contextStack = this._contextStack;
      if (!contextStack.length) return this._readPunctuation;

      switch (contextStack[contextStack.length - 1].type) {
        case 'blank':
          return this._readBlankNodeTail;

        case 'list':
          return this._readListItem;

        case 'formula':
          return this._readFormulaTail;

        case '<<':
          return this._readRDFStarTailOrGraph;
      }
    } // ### `_emit` sends a quad through the callback

  }, {
    key: "_emit",
    value: function _emit(subject, predicate, object, graph) {
      this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));
    } // ### `_error` emits an error message through the callback

  }, {
    key: "_error",
    value: function _error(message, token) {
      var err = new Error(message + ' on line ' + token.line + '.');
      err.context = {
        token: token,
        line: token.line,
        previousToken: this._lexer.previousToken
      };

      this._callback(err);

      this._callback = noop;
    } // ### `_resolveIRI` resolves an IRI against the base path

  }, {
    key: "_resolveIRI",
    value: function _resolveIRI(iri) {
      return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);
    } // ### `_resolveRelativeIRI` resolves an IRI against the base path,
    // assuming that a base path has been set and that the IRI is indeed relative

  }, {
    key: "_resolveRelativeIRI",
    value: function _resolveRelativeIRI(iri) {
      // An empty relative IRI indicates the base IRI
      if (!iri.length) return this._base; // Decide resolving strategy based in the first character

      switch (iri[0]) {
        // Resolve relative fragment IRIs against the base IRI
        case '#':
          return this._base + iri;
        // Resolve relative query string IRIs by replacing the query string

        case '?':
          return this._base.replace(/(?:\?.*)?$/, iri);
        // Resolve root-relative IRIs at the root of the base IRI

        case '/':
          // Resolve scheme-relative IRIs to the scheme
          return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);
        // Resolve all other IRIs at the base IRI's path

        default:
          // Relative IRIs cannot contain a colon in the first path segment
          return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);
      }
    } // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986

  }, {
    key: "_removeDotSegments",
    value: function _removeDotSegments(iri) {
      // Don't modify the IRI if it does not contain any dot segments
      if (!/(^|\/)\.\.?($|[/#?])/.test(iri)) return iri; // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'

      var result = '',
          length = iri.length,
          i = -1,
          pathStart = -1,
          segmentStart = 0,
          next = '/';

      while (i < length) {
        switch (next) {
          // The path starts with the first slash after the authority
          case ':':
            if (pathStart < 0) {
              // Skip two slashes before the authority
              if (iri[++i] === '/' && iri[++i] === '/') // Skip to slash after the authority
                while ((pathStart = i + 1) < length && iri[pathStart] !== '/') {
                  i = pathStart;
                }
            }

            break;
          // Don't modify a query string or fragment

          case '?':
          case '#':
            i = length;
            break;
          // Handle '/.' or '/..' path segments

          case '/':
            if (iri[i + 1] === '.') {
              next = iri[++i + 1];

              switch (next) {
                // Remove a '/.' segment
                case '/':
                  result += iri.substring(segmentStart, i - 1);
                  segmentStart = i + 1;
                  break;
                // Remove a trailing '/.' segment

                case undefined:
                case '?':
                case '#':
                  return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
                // Remove a '/..' segment

                case '.':
                  next = iri[++i + 1];

                  if (next === undefined || next === '/' || next === '?' || next === '#') {
                    result += iri.substring(segmentStart, i - 2); // Try to remove the parent path from result

                    if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart); // Remove a trailing '/..' segment

                    if (next !== '/') return result + '/' + iri.substr(i + 1);
                    segmentStart = i + 1;
                  }

              }
            }

        }

        next = iri[++i];
      }

      return result + iri.substring(segmentStart);
    } // ## Public methods
    // ### `parse` parses the N3 input and emits each parsed quad through the callback

  }, {
    key: "parse",
    value: function parse(input, quadCallback, prefixCallback) {
      var self = this; // The read callback is the next function to be executed when a token arrives.
      // We start reading in the top context.

      this._readCallback = this._readInTopContext;
      this._sparqlStyle = false;
      this._prefixes = Object.create(null);
      this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : 'b' + blankNodePrefix++ + '_';
      this._prefixCallback = prefixCallback || noop;
      this._inversePredicate = false;
      this._quantified = Object.create(null); // Parse synchronously if no quad callback is given

      if (!quadCallback) {
        var quads = [],
            error;

        this._callback = function (e, t) {
          e ? error = e : t && quads.push(t);
        };

        this._lexer.tokenize(input).every(function (token) {
          return self._readCallback = self._readCallback(token);
        });

        if (error) throw error;
        return quads;
      } // Parse asynchronously otherwise, executing the read callback when a token arrives


      this._callback = quadCallback;

      this._lexer.tokenize(input, function (error, token) {
        if (error !== null) self._callback(error), self._callback = noop;else if (self._readCallback) self._readCallback = self._readCallback(token);
      });
    }
  }], [{
    key: "_resetBlankNodePrefix",
    value: function _resetBlankNodePrefix() {
      blankNodePrefix = 0;
    }
  }]);
  return N3Parser;
}(); // The empty function


exports["default"] = N3Parser;

function noop() {} // Initializes the parser with the given data factory


function initDataFactory(parser, factory) {
  // Set factory methods
  var namedNode = factory.namedNode;
  parser._namedNode = namedNode;
  parser._blankNode = factory.blankNode;
  parser._literal = factory.literal;
  parser._variable = factory.variable;
  parser._quad = factory.quad;
  parser.DEFAULTGRAPH = factory.defaultGraph(); // Set common named nodes

  parser.RDF_FIRST = namedNode(_IRIs["default"].rdf.first);
  parser.RDF_REST = namedNode(_IRIs["default"].rdf.rest);
  parser.RDF_NIL = namedNode(_IRIs["default"].rdf.nil);
  parser.N3_FORALL = namedNode(_IRIs["default"].r.forAll);
  parser.N3_FORSOME = namedNode(_IRIs["default"].r.forSome);
  parser.ABBREVIATIONS = {
    'a': namedNode(_IRIs["default"].rdf.type),
    '=': namedNode(_IRIs["default"].owl.sameAs),
    '>': namedNode(_IRIs["default"].log.implies)
  };
  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');
}

initDataFactory(N3Parser.prototype, _N3DataFactory["default"]);

},{"./IRIs":126,"./N3DataFactory":127,"./N3Lexer":128,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],130:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault2(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

var _typeof2 = _interopRequireDefault2(require("@babel/runtime/helpers/typeof"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _N3DataFactory = _interopRequireWildcard(require("./N3DataFactory"));

var _readableStream = require("readable-stream");

var _IRIs = _interopRequireDefault(require("./IRIs"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || (0, _typeof2["default"])(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // **N3Store** objects store N3 quads by graph in memory.
// ## Constructor


var N3Store = /*#__PURE__*/function () {
  function N3Store(quads, options) {
    (0, _classCallCheck2["default"])(this, N3Store);
    // The number of quads is initially zero
    this._size = 0; // `_graphs` contains subject, predicate, and object indexes per graph

    this._graphs = Object.create(null); // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,
    // saving memory by using only numbers as keys in `_graphs`

    this._id = 0;
    this._ids = Object.create(null);
    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero

    this._entities = Object.create(null); // inverse of `_ids`
    // `_blankNodeIndex` is the index of the last automatically named blank node

    this._blankNodeIndex = 0; // Shift parameters if `quads` is not given

    if (!options && quads && !quads[0]) options = quads, quads = null;
    options = options || {};
    this._factory = options.factory || _N3DataFactory["default"]; // Add quads if passed

    if (quads) this.addQuads(quads);
  } // ## Public properties
  // ### `size` returns the number of quads in the store


  (0, _createClass2["default"])(N3Store, [{
    key: "_addToIndex",
    // ## Private methods
    // ### `_addToIndex` adds a quad to a three-layered index.
    // Returns if the index has changed, if the entry did not already exist.
    value: function _addToIndex(index0, key0, key1, key2) {
      // Create layers as necessary
      var index1 = index0[key0] || (index0[key0] = {});
      var index2 = index1[key1] || (index1[key1] = {}); // Setting the key to _any_ value signals the presence of the quad

      var existed = (key2 in index2);
      if (!existed) index2[key2] = null;
      return !existed;
    } // ### `_removeFromIndex` removes a quad from a three-layered index

  }, {
    key: "_removeFromIndex",
    value: function _removeFromIndex(index0, key0, key1, key2) {
      // Remove the quad from the index
      var index1 = index0[key0],
          index2 = index1[key1],
          key;
      delete index2[key2]; // Remove intermediary index layers if they are empty

      for (key in index2) {
        return;
      }

      delete index1[key1];

      for (key in index1) {
        return;
      }

      delete index0[key0];
    } // ### `_findInIndex` finds a set of quads in a three-layered index.
    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
    // Any of these keys can be undefined, which is interpreted as a wildcard.
    // `name0`, `name1`, and `name2` are the names of the keys at each level,
    // used when reconstructing the resulting quad
    // (for instance: _subject_, _predicate_, and _object_).
    // Finally, `graph` will be the graph of the created quads.
    // If `callback` is given, each result is passed through it
    // and iteration halts when it returns truthy for any quad.
    // If instead `array` is given, each result is added to the array.

  }, {
    key: "_findInIndex",
    value: function _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {
      var tmp,
          index1,
          index2,
          varCount = !key0 + !key1 + !key2,
          // depending on the number of variables, keys or reverse index are faster
      entityKeys = varCount > 1 ? Object.keys(this._ids) : this._entities; // If a key is specified, use only that part of index 0.

      if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];

      for (var value0 in index0) {
        var entity0 = entityKeys[value0];

        if (index1 = index0[value0]) {
          // If a key is specified, use only that part of index 1.
          if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];

          for (var value1 in index1) {
            var entity1 = entityKeys[value1];

            if (index2 = index1[value1]) {
              // If a key is specified, use only that part of index 2, if it exists.
              var values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2); // Create quads for all items found in index 2.

              for (var l = 0; l < values.length; l++) {
                var parts = {
                  subject: null,
                  predicate: null,
                  object: null
                };
                parts[name0] = (0, _N3DataFactory.termFromId)(entity0, this._factory);
                parts[name1] = (0, _N3DataFactory.termFromId)(entity1, this._factory);
                parts[name2] = (0, _N3DataFactory.termFromId)(entityKeys[values[l]], this._factory);

                var quad = this._factory.quad(parts.subject, parts.predicate, parts.object, (0, _N3DataFactory.termFromId)(graph, this._factory));

                if (array) array.push(quad);else if (callback(quad)) return true;
              }
            }
          }
        }
      }

      return array;
    } // ### `_loop` executes the callback on all keys of index 0

  }, {
    key: "_loop",
    value: function _loop(index0, callback) {
      for (var key0 in index0) {
        callback(key0);
      }
    } // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0

  }, {
    key: "_loopByKey0",
    value: function _loopByKey0(index0, key0, callback) {
      var index1, key1;

      if (index1 = index0[key0]) {
        for (key1 in index1) {
          callback(key1);
        }
      }
    } // ### `_loopByKey1` executes the callback on given keys of all entries in index 0

  }, {
    key: "_loopByKey1",
    value: function _loopByKey1(index0, key1, callback) {
      var key0, index1;

      for (key0 in index0) {
        index1 = index0[key0];
        if (index1[key1]) callback(key0);
      }
    } // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2

  }, {
    key: "_loopBy2Keys",
    value: function _loopBy2Keys(index0, key0, key1, callback) {
      var index1, index2, key2;

      if ((index1 = index0[key0]) && (index2 = index1[key1])) {
        for (key2 in index2) {
          callback(key2);
        }
      }
    } // ### `_countInIndex` counts matching quads in a three-layered index.
    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
    // Any of these keys can be undefined, which is interpreted as a wildcard.

  }, {
    key: "_countInIndex",
    value: function _countInIndex(index0, key0, key1, key2) {
      var count = 0,
          tmp,
          index1,
          index2; // If a key is specified, count only that part of index 0

      if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];

      for (var value0 in index0) {
        if (index1 = index0[value0]) {
          // If a key is specified, count only that part of index 1
          if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];

          for (var value1 in index1) {
            if (index2 = index1[value1]) {
              // If a key is specified, count the quad if it exists
              if (key2) key2 in index2 && count++; // Otherwise, count all quads
              else count += Object.keys(index2).length;
            }
          }
        }
      }

      return count;
    } // ### `_getGraphs` returns an array with the given graph,
    // or all graphs if the argument is null or undefined.

  }, {
    key: "_getGraphs",
    value: function _getGraphs(graph) {
      if (!isString(graph)) return this._graphs;
      var graphs = {};
      graphs[graph] = this._graphs[graph];
      return graphs;
    } // ### `_uniqueEntities` returns a function that accepts an entity ID
    // and passes the corresponding entity to callback if it hasn't occurred before.

  }, {
    key: "_uniqueEntities",
    value: function _uniqueEntities(callback) {
      var uniqueIds = Object.create(null),
          entities = this._entities;
      return function (id) {
        if (!(id in uniqueIds)) {
          uniqueIds[id] = true;
          callback((0, _N3DataFactory.termFromId)(entities[id]));
        }
      };
    } // ## Public methods
    // ### `addQuad` adds a new quad to the store.
    // Returns if the quad index has changed, if the quad did not already exist.

  }, {
    key: "addQuad",
    value: function addQuad(subject, predicate, object, graph) {
      // Shift arguments if a quad object is given instead of components
      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation

      subject = (0, _N3DataFactory.termToId)(subject);
      predicate = (0, _N3DataFactory.termToId)(predicate);
      object = (0, _N3DataFactory.termToId)(object);
      graph = (0, _N3DataFactory.termToId)(graph); // Find the graph that will contain the triple

      var graphItem = this._graphs[graph]; // Create the graph if it doesn't exist yet

      if (!graphItem) {
        graphItem = this._graphs[graph] = {
          subjects: {},
          predicates: {},
          objects: {}
        }; // Freezing a graph helps subsequent `add` performance,
        // and properties will never be modified anyway

        Object.freeze(graphItem);
      } // Since entities can often be long IRIs, we avoid storing them in every index.
      // Instead, we have a separate index that maps entities to numbers,
      // which are then used as keys in the other indexes.


      var ids = this._ids;
      var entities = this._entities;
      subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);
      predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);
      object = ids[object] || (ids[entities[++this._id] = object] = this._id);

      var changed = this._addToIndex(graphItem.subjects, subject, predicate, object);

      this._addToIndex(graphItem.predicates, predicate, object, subject);

      this._addToIndex(graphItem.objects, object, subject, predicate); // The cached quad count is now invalid


      this._size = null;
      return changed;
    } // ### `addQuads` adds multiple quads to the store

  }, {
    key: "addQuads",
    value: function addQuads(quads) {
      for (var i = 0; i < quads.length; i++) {
        this.addQuad(quads[i]);
      }
    } // ### `import` adds a stream of quads to the store

  }, {
    key: "import",
    value: function _import(stream) {
      var self = this;
      stream.on('data', function (quad) {
        self.addQuad(quad);
      });
      return stream;
    } // ### `removeQuad` removes a quad from the store if it exists

  }, {
    key: "removeQuad",
    value: function removeQuad(subject, predicate, object, graph) {
      // Shift arguments if a quad object is given instead of components
      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation

      subject = (0, _N3DataFactory.termToId)(subject);
      predicate = (0, _N3DataFactory.termToId)(predicate);
      object = (0, _N3DataFactory.termToId)(object);
      graph = (0, _N3DataFactory.termToId)(graph); // Find internal identifiers for all components
      // and verify the quad exists.

      var graphItem,
          ids = this._ids,
          graphs = this._graphs,
          subjects,
          predicates;
      if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) return false; // Remove it from all indexes

      this._removeFromIndex(graphItem.subjects, subject, predicate, object);

      this._removeFromIndex(graphItem.predicates, predicate, object, subject);

      this._removeFromIndex(graphItem.objects, object, subject, predicate);

      if (this._size !== null) this._size--; // Remove the graph if it is empty

      for (subject in graphItem.subjects) {
        return true;
      }

      delete graphs[graph];
      return true;
    } // ### `removeQuads` removes multiple quads from the store

  }, {
    key: "removeQuads",
    value: function removeQuads(quads) {
      for (var i = 0; i < quads.length; i++) {
        this.removeQuad(quads[i]);
      }
    } // ### `remove` removes a stream of quads from the store

  }, {
    key: "remove",
    value: function remove(stream) {
      var self = this;
      stream.on('data', function (quad) {
        self.removeQuad(quad);
      });
      return stream;
    } // ### `removeMatches` removes all matching quads from the store
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "removeMatches",
    value: function removeMatches(subject, predicate, object, graph) {
      return this.remove(this.match(subject, predicate, object, graph));
    } // ### `deleteGraph` removes all triples with the given graph from the store

  }, {
    key: "deleteGraph",
    value: function deleteGraph(graph) {
      return this.removeMatches(null, null, null, graph);
    } // ### `getQuads` returns an array of quads matching a pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getQuads",
    value: function getQuads(subject, predicate, object, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var quads = [],
          graphs = this._getGraphs(graph),
          content,
          ids = this._ids,
          subjectId,
          predicateId,
          objectId; // Translate IRIs to internal index keys.


      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return quads;

      for (var graphId in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graphId]) {
          // Choose the optimal index, based on what fields are present
          if (subjectId) {
            if (objectId) // If subject and object are given, the object index will be the fastest
              this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads);else // If only subject and possibly predicate are given, the subject index will be the fastest
              this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads);
          } else if (predicateId) // If only predicate and possibly object are given, the predicate index will be the fastest
            this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads);else if (objectId) // If only object is given, the object index will be the fastest
            this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads);else // If nothing is given, iterate subjects and predicates first
            this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads);
        }
      }

      return quads;
    } // ### `match` returns a stream of quads matching a pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "match",
    value: function match(subject, predicate, object, graph) {
      var _this = this;

      var stream = new _readableStream.Readable({
        objectMode: true
      }); // Initialize stream once it is being read

      stream._read = function () {
        var _iterator = _createForOfIteratorHelper(_this.getQuads(subject, predicate, object, graph)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var quad = _step.value;
            stream.push(quad);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        stream.push(null);
      };

      return stream;
    } // ### `countQuads` returns the number of quads matching a pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "countQuads",
    value: function countQuads(subject, predicate, object, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var count = 0,
          graphs = this._getGraphs(graph),
          content,
          ids = this._ids,
          subjectId,
          predicateId,
          objectId; // Translate IRIs to internal index keys.


      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return 0;

      for (var graphId in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graphId]) {
          // Choose the optimal index, based on what fields are present
          if (subject) {
            if (object) // If subject and object are given, the object index will be the fastest
              count += this._countInIndex(content.objects, objectId, subjectId, predicateId);else // If only subject and possibly predicate are given, the subject index will be the fastest
              count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);
          } else if (predicate) {
            // If only predicate and possibly object are given, the predicate index will be the fastest
            count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);
          } else {
            // If only object is possibly given, the object index will be the fastest
            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
          }
        }
      }

      return count;
    } // ### `forEach` executes the callback on all quads.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forEach",
    value: function forEach(callback, subject, predicate, object, graph) {
      this.some(function (quad) {
        callback(quad);
        return false;
      }, subject, predicate, object, graph);
    } // ### `every` executes the callback on all quads,
    // and returns `true` if it returns truthy for all them.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "every",
    value: function every(callback, subject, predicate, object, graph) {
      var some = false;
      var every = !this.some(function (quad) {
        some = true;
        return !callback(quad);
      }, subject, predicate, object, graph);
      return some && every;
    } // ### `some` executes the callback on all quads,
    // and returns `true` if it returns truthy for any of them.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "some",
    value: function some(callback, subject, predicate, object, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var graphs = this._getGraphs(graph),
          content,
          ids = this._ids,
          subjectId,
          predicateId,
          objectId; // Translate IRIs to internal index keys.


      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return false;

      for (var graphId in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graphId]) {
          // Choose the optimal index, based on what fields are present
          if (subjectId) {
            if (objectId) {
              // If subject and object are given, the object index will be the fastest
              if (this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, callback, null)) return true;
            } else // If only subject and possibly predicate are given, the subject index will be the fastest
              if (this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, callback, null)) return true;
          } else if (predicateId) {
            // If only predicate and possibly object are given, the predicate index will be the fastest
            if (this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, callback, null)) {
              return true;
            }
          } else if (objectId) {
            // If only object is given, the object index will be the fastest
            if (this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, callback, null)) {
              return true;
            }
          } else // If nothing is given, iterate subjects and predicates first
            if (this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, callback, null)) {
              return true;
            }
        }
      }

      return false;
    } // ### `getSubjects` returns all subjects that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getSubjects",
    value: function getSubjects(predicate, object, graph) {
      var results = [];
      this.forSubjects(function (s) {
        results.push(s);
      }, predicate, object, graph);
      return results;
    } // ### `forSubjects` executes the callback on all subjects that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forSubjects",
    value: function forSubjects(callback, predicate, object, graph) {
      // Convert terms to internal string representation
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var ids = this._ids,
          graphs = this._getGraphs(graph),
          content,
          predicateId,
          objectId;

      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.

      if (isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;

      for (graph in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graph]) {
          // Choose optimal index based on which fields are wildcards
          if (predicateId) {
            if (objectId) // If predicate and object are given, the POS index is best.
              this._loopBy2Keys(content.predicates, predicateId, objectId, callback);else // If only predicate is given, the SPO index is best.
              this._loopByKey1(content.subjects, predicateId, callback);
          } else if (objectId) // If only object is given, the OSP index is best.
            this._loopByKey0(content.objects, objectId, callback);else // If no params given, iterate all the subjects
            this._loop(content.subjects, callback);
        }
      }
    } // ### `getPredicates` returns all predicates that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getPredicates",
    value: function getPredicates(subject, object, graph) {
      var results = [];
      this.forPredicates(function (p) {
        results.push(p);
      }, subject, object, graph);
      return results;
    } // ### `forPredicates` executes the callback on all predicates that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forPredicates",
    value: function forPredicates(callback, subject, object, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      object = object && (0, _N3DataFactory.termToId)(object);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var ids = this._ids,
          graphs = this._getGraphs(graph),
          content,
          subjectId,
          objectId;

      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.

      if (isString(subject) && !(subjectId = ids[subject]) || isString(object) && !(objectId = ids[object])) return;

      for (graph in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graph]) {
          // Choose optimal index based on which fields are wildcards
          if (subjectId) {
            if (objectId) // If subject and object are given, the OSP index is best.
              this._loopBy2Keys(content.objects, objectId, subjectId, callback);else // If only subject is given, the SPO index is best.
              this._loopByKey0(content.subjects, subjectId, callback);
          } else if (objectId) // If only object is given, the POS index is best.
            this._loopByKey1(content.predicates, objectId, callback);else // If no params given, iterate all the predicates.
            this._loop(content.predicates, callback);
        }
      }
    } // ### `getObjects` returns all objects that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getObjects",
    value: function getObjects(subject, predicate, graph) {
      var results = [];
      this.forObjects(function (o) {
        results.push(o);
      }, subject, predicate, graph);
      return results;
    } // ### `forObjects` executes the callback on all objects that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forObjects",
    value: function forObjects(callback, subject, predicate, graph) {
      // Convert terms to internal string representation
      subject = subject && (0, _N3DataFactory.termToId)(subject);
      predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
      graph = graph && (0, _N3DataFactory.termToId)(graph);

      var ids = this._ids,
          graphs = this._getGraphs(graph),
          content,
          subjectId,
          predicateId;

      callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.

      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate])) return;

      for (graph in graphs) {
        // Only if the specified graph contains triples, there can be results
        if (content = graphs[graph]) {
          // Choose optimal index based on which fields are wildcards
          if (subjectId) {
            if (predicateId) // If subject and predicate are given, the SPO index is best.
              this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);else // If only subject is given, the OSP index is best.
              this._loopByKey1(content.objects, subjectId, callback);
          } else if (predicateId) // If only predicate is given, the POS index is best.
            this._loopByKey0(content.predicates, predicateId, callback);else // If no params given, iterate all the objects.
            this._loop(content.objects, callback);
        }
      }
    } // ### `getGraphs` returns all graphs that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "getGraphs",
    value: function getGraphs(subject, predicate, object) {
      var results = [];
      this.forGraphs(function (g) {
        results.push(g);
      }, subject, predicate, object);
      return results;
    } // ### `forGraphs` executes the callback on all graphs that match the pattern.
    // Setting any field to `undefined` or `null` indicates a wildcard.

  }, {
    key: "forGraphs",
    value: function forGraphs(callback, subject, predicate, object) {
      for (var graph in this._graphs) {
        this.some(function (quad) {
          callback(quad.graph);
          return true; // Halt iteration of some()
        }, subject, predicate, object, graph);
      }
    } // ### `createBlankNode` creates a new blank node, returning its name

  }, {
    key: "createBlankNode",
    value: function createBlankNode(suggestedName) {
      var name, index; // Generate a name based on the suggested name

      if (suggestedName) {
        name = suggestedName = '_:' + suggestedName, index = 1;

        while (this._ids[name]) {
          name = suggestedName + index++;
        }
      } // Generate a generic blank node name
      else {
          do {
            name = '_:b' + this._blankNodeIndex++;
          } while (this._ids[name]);
        } // Add the blank node to the entities, avoiding the generation of duplicates


      this._ids[name] = ++this._id;
      this._entities[this._id] = name;
      return this._factory.blankNode(name.substr(2));
    } // ### `extractLists` finds and removes all list triples
    // and returns the items per list.

  }, {
    key: "extractLists",
    value: function extractLists() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$remove = _ref.remove,
          remove = _ref$remove === void 0 ? false : _ref$remove,
          _ref$ignoreErrors = _ref.ignoreErrors,
          ignoreErrors = _ref$ignoreErrors === void 0 ? false : _ref$ignoreErrors;

      var lists = {}; // has scalar keys so could be a simple Object

      var onError = ignoreErrors ? function () {
        return true;
      } : function (node, message) {
        throw new Error("".concat(node.value, " ").concat(message));
      }; // Traverse each list from its tail

      var tails = this.getQuads(null, _IRIs["default"].rdf.rest, _IRIs["default"].rdf.nil, null);
      var toRemove = remove ? (0, _toConsumableArray2["default"])(tails) : [];
      tails.forEach(function (tailQuad) {
        var items = []; // the members found as objects of rdf:first quads

        var malformed = false; // signals whether the current list is malformed

        var head; // the head of the list (_:b1 in above example)

        var headPos; // set to subject or object when head is set

        var graph = tailQuad.graph; // make sure list is in exactly one graph
        // Traverse the list from tail to end

        var current = tailQuad.subject;

        while (current && !malformed) {
          var objectQuads = _this2.getQuads(null, null, current, null);

          var subjectQuads = _this2.getQuads(current, null, null, null);

          var i,
              quad,
              first = null,
              rest = null,
              parent = null; // Find the first and rest of this list node

          for (i = 0; i < subjectQuads.length && !malformed; i++) {
            quad = subjectQuads[i];
            if (!quad.graph.equals(graph)) malformed = onError(current, 'not confined to single graph');else if (head) malformed = onError(current, 'has non-list arcs out'); // one rdf:first
            else if (quad.predicate.value === _IRIs["default"].rdf.first) {
                if (first) malformed = onError(current, 'has multiple rdf:first arcs');else toRemove.push(first = quad);
              } // one rdf:rest
              else if (quad.predicate.value === _IRIs["default"].rdf.rest) {
                  if (rest) malformed = onError(current, 'has multiple rdf:rest arcs');else toRemove.push(rest = quad);
                } // alien triple
                else if (objectQuads.length) malformed = onError(current, 'can\'t be subject and object');else {
                    head = quad; // e.g. { (1 2 3) :p :o }

                    headPos = 'subject';
                  }
          } // { :s :p (1 2) } arrives here with no head
          // { (1 2) :p :o } arrives here with head set to the list.


          for (i = 0; i < objectQuads.length && !malformed; ++i) {
            quad = objectQuads[i];
            if (head) malformed = onError(current, 'can\'t have coreferences'); // one rdf:rest
            else if (quad.predicate.value === _IRIs["default"].rdf.rest) {
                if (parent) malformed = onError(current, 'has incoming rdf:rest arcs');else parent = quad;
              } else {
                head = quad; // e.g. { :s :p (1 2) }

                headPos = 'object';
              }
          } // Store the list item and continue with parent


          if (!first) malformed = onError(current, 'has no list head');else items.unshift(first.object);
          current = parent && parent.subject;
        } // Don't remove any quads if the list is malformed


        if (malformed) remove = false; // Store the list under the value of its head
        else if (head) lists[head[headPos].value] = items;
      }); // Remove list quads if requested

      if (remove) this.removeQuads(toRemove);
      return lists;
    }
  }, {
    key: "size",
    get: function get() {
      // Return the quad count if if was cached
      var size = this._size;
      if (size !== null) return size; // Calculate the number of quads by counting to the deepest level

      size = 0;
      var graphs = this._graphs,
          subjects,
          subject;

      for (var graphKey in graphs) {
        for (var subjectKey in subjects = graphs[graphKey].subjects) {
          for (var predicateKey in subject = subjects[subjectKey]) {
            size += Object.keys(subject[predicateKey]).length;
          }
        }
      }

      return this._size = size;
    }
  }]);
  return N3Store;
}(); // Determines whether the argument is a string


exports["default"] = N3Store;

function isString(s) {
  return typeof s === 'string' || s instanceof String;
}

},{"./IRIs":126,"./N3DataFactory":127,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/toConsumableArray":26,"@babel/runtime/helpers/typeof":27,"readable-stream":186}],131:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault2(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _N3Parser = _interopRequireDefault(require("./N3Parser"));

var _readableStream = require("readable-stream");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3StreamParser** parses a text stream into a quad stream.
// ## Constructor


var N3StreamParser = /*#__PURE__*/function (_readableStream$Trans) {
  (0, _inherits2["default"])(N3StreamParser, _readableStream$Trans);

  var _super = _createSuper(N3StreamParser);

  function N3StreamParser(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, N3StreamParser);
    _this = _super.call(this, {
      decodeStrings: true
    });
    _this._readableState.objectMode = true; // Set up parser with dummy stream to obtain `data` and `end` callbacks

    var self = (0, _assertThisInitialized2["default"])(_this),
        parser = new _N3Parser["default"](options),
        onData,
        onEnd;
    parser.parse({
      on: function on(event, callback) {
        switch (event) {
          case 'data':
            onData = callback;
            break;

          case 'end':
            onEnd = callback;
            break;
        }
      }
    }, // Handle quads by pushing them down the pipeline
    function (error, quad) {
      error && self.emit('error', error) || quad && self.push(quad);
    }, // Emit prefixes through the `prefix` event
    function (prefix, uri) {
      self.emit('prefix', prefix, uri);
    }); // Implement Transform methods through parser callbacks

    _this._transform = function (chunk, encoding, done) {
      onData(chunk);
      done();
    };

    _this._flush = function (done) {
      onEnd();
      done();
    };

    return _this;
  } // ### Parses a stream of strings


  (0, _createClass2["default"])(N3StreamParser, [{
    key: "import",
    value: function _import(stream) {
      var self = this;
      stream.on('data', function (chunk) {
        self.write(chunk);
      });
      stream.on('end', function () {
        self.end();
      });
      stream.on('error', function (error) {
        self.emit('error', error);
      });
      return this;
    }
  }]);
  return N3StreamParser;
}(_readableStream.Transform);

exports["default"] = N3StreamParser;

},{"./N3Parser":129,"@babel/runtime/helpers/assertThisInitialized":5,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"readable-stream":186}],132:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault2(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _readableStream = require("readable-stream");

var _N3Writer = _interopRequireDefault(require("./N3Writer"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3StreamWriter** serializes a quad stream into a text stream.
// ## Constructor


var N3StreamWriter = /*#__PURE__*/function (_readableStream$Trans) {
  (0, _inherits2["default"])(N3StreamWriter, _readableStream$Trans);

  var _super = _createSuper(N3StreamWriter);

  function N3StreamWriter(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, N3StreamWriter);
    _this = _super.call(this, {
      encoding: 'utf8'
    });
    _this._writableState.objectMode = true; // Set up writer with a dummy stream object

    var self = (0, _assertThisInitialized2["default"])(_this);
    var writer = _this._writer = new _N3Writer["default"]({
      write: function write(quad, encoding, callback) {
        self.push(quad);
        callback && callback();
      },
      end: function end(callback) {
        self.push(null);
        callback && callback();
      }
    }, options); // Implement Transform methods on top of writer

    _this._transform = function (quad, encoding, done) {
      writer.addQuad(quad, done);
    };

    _this._flush = function (done) {
      writer.end(done);
    };

    return _this;
  } // ### Serializes a stream of quads


  (0, _createClass2["default"])(N3StreamWriter, [{
    key: "import",
    value: function _import(stream) {
      var self = this;
      stream.on('data', function (quad) {
        self.write(quad);
      });
      stream.on('end', function () {
        self.end();
      });
      stream.on('error', function (error) {
        self.emit('error', error);
      });
      stream.on('prefix', function (prefix, iri) {
        self._writer.addPrefix(prefix, iri);
      });
      return this;
    }
  }]);
  return N3StreamWriter;
}(_readableStream.Transform);

exports["default"] = N3StreamWriter;

},{"./N3Writer":134,"@babel/runtime/helpers/assertThisInitialized":5,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"readable-stream":186}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNamedNode = isNamedNode;
exports.isBlankNode = isBlankNode;
exports.isLiteral = isLiteral;
exports.isVariable = isVariable;
exports.isDefaultGraph = isDefaultGraph;
exports.inDefaultGraph = inDefaultGraph;
exports.prefix = prefix;
exports.prefixes = prefixes;

var _N3DataFactory = _interopRequireDefault(require("./N3DataFactory"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3Util** provides N3 utility functions.
// Tests whether the given term represents an IRI


function isNamedNode(term) {
  return !!term && term.termType === 'NamedNode';
} // Tests whether the given term represents a blank node


function isBlankNode(term) {
  return !!term && term.termType === 'BlankNode';
} // Tests whether the given term represents a literal


function isLiteral(term) {
  return !!term && term.termType === 'Literal';
} // Tests whether the given term represents a variable


function isVariable(term) {
  return !!term && term.termType === 'Variable';
} // Tests whether the given term represents the default graph


function isDefaultGraph(term) {
  return !!term && term.termType === 'DefaultGraph';
} // Tests whether the given quad is in the default graph


function inDefaultGraph(quad) {
  return isDefaultGraph(quad.graph);
} // Creates a function that prepends the given IRI to a local name


function prefix(iri, factory) {
  return prefixes({
    '': iri
  }, factory)('');
} // Creates a function that allows registering and expanding prefixes


function prefixes(defaultPrefixes, factory) {
  // Add all of the default prefixes
  var prefixes = Object.create(null);

  for (var prefix in defaultPrefixes) {
    processPrefix(prefix, defaultPrefixes[prefix]);
  } // Set the default factory if none was specified


  factory = factory || _N3DataFactory["default"]; // Registers a new prefix (if an IRI was specified)
  // or retrieves a function that expands an existing prefix (if no IRI was specified)

  function processPrefix(prefix, iri) {
    // Create a new prefix if an IRI is specified or the prefix doesn't exist
    if (typeof iri === 'string') {
      // Create a function that expands the prefix
      var cache = Object.create(null);

      prefixes[prefix] = function (local) {
        return cache[local] || (cache[local] = factory.namedNode(iri + local));
      };
    } else if (!(prefix in prefixes)) {
      throw new Error('Unknown prefix: ' + prefix);
    }

    return prefixes[prefix];
  }

  return processPrefix;
}

},{"./N3DataFactory":127}],134:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

var _typeof2 = _interopRequireDefault2(require("@babel/runtime/helpers/typeof"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _IRIs = _interopRequireDefault(require("./IRIs"));

var _N3DataFactory = _interopRequireWildcard(require("./N3DataFactory"));

var _N3Util = require("./N3Util");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || (0, _typeof2["default"])(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // **N3Writer** writes N3 documents.


var DEFAULTGRAPH = _N3DataFactory["default"].defaultGraph();

var _IRIs$default = _IRIs["default"],
    rdf = _IRIs$default.rdf,
    xsd = _IRIs$default.xsd; // Characters in literals that require escaping

var escape = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/,
    escapeAll = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g,
    escapedCharacters = {
  '\\': '\\\\',
  '"': '\\"',
  '\t': '\\t',
  '\n': '\\n',
  '\r': '\\r',
  '\b': '\\b',
  '\f': '\\f'
}; // ## Placeholder class to represent already pretty-printed terms

var SerializedTerm = /*#__PURE__*/function (_N3DataFactory$Term) {
  (0, _inherits2["default"])(SerializedTerm, _N3DataFactory$Term);

  var _super = _createSuper(SerializedTerm);

  function SerializedTerm() {
    (0, _classCallCheck2["default"])(this, SerializedTerm);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(SerializedTerm, [{
    key: "equals",
    // Pretty-printed nodes are not equal to any other node
    // (e.g., [] does not equal [])
    value: function equals() {
      return false;
    }
  }]);
  return SerializedTerm;
}(_N3DataFactory.Term); // ## Constructor


var N3Writer = /*#__PURE__*/function () {
  function N3Writer(outputStream, options) {
    (0, _classCallCheck2["default"])(this, N3Writer);
    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes
    this._prefixRegex = /$0^/; // Shift arguments if the first argument is not a stream

    if (outputStream && typeof outputStream.write !== 'function') options = outputStream, outputStream = null;
    options = options || {};
    this._lists = options.lists; // If no output stream given, send the output as string through the end callback

    if (!outputStream) {
      var output = '';
      this._outputStream = {
        write: function write(chunk, encoding, done) {
          output += chunk;
          done && done();
        },
        end: function end(done) {
          done && done(null, output);
        }
      };
      this._endStream = true;
    } else {
      this._outputStream = outputStream;
      this._endStream = options.end === undefined ? true : !!options.end;
    } // Initialize writer, depending on the format


    this._subject = null;

    if (!/triple|quad/i.test(options.format)) {
      this._graph = DEFAULTGRAPH;
      this._prefixIRIs = Object.create(null);
      options.prefixes && this.addPrefixes(options.prefixes);
    } else {
      this._writeQuad = this._writeQuadLine;
    }
  } // ## Private methods
  // ### Whether the current graph is the default graph


  (0, _createClass2["default"])(N3Writer, [{
    key: "_write",
    // ### `_write` writes the argument to the output stream
    value: function _write(string, callback) {
      this._outputStream.write(string, 'utf8', callback);
    } // ### `_writeQuad` writes the quad to the output stream

  }, {
    key: "_writeQuad",
    value: function _writeQuad(subject, predicate, object, graph, done) {
      try {
        // Write the graph's label if it has changed
        if (!graph.equals(this._graph)) {
          // Close the previous graph and start the new one
          this._write((this._subject === null ? '' : this._inDefaultGraph ? '.\n' : '\n}\n') + (DEFAULTGRAPH.equals(graph) ? '' : this._encodeIriOrBlank(graph) + ' {\n'));

          this._graph = graph;
          this._subject = null;
        } // Don't repeat the subject if it's the same


        if (subject.equals(this._subject)) {
          // Don't repeat the predicate if it's the same
          if (predicate.equals(this._predicate)) this._write(', ' + this._encodeObject(object), done); // Same subject, different predicate
          else this._write(';\n    ' + this._encodePredicate(this._predicate = predicate) + ' ' + this._encodeObject(object), done);
        } // Different subject; write the whole quad
        else this._write((this._subject === null ? '' : '.\n') + this._encodeSubject(this._subject = subject) + ' ' + this._encodePredicate(this._predicate = predicate) + ' ' + this._encodeObject(object), done);
      } catch (error) {
        done && done(error);
      }
    } // ### `_writeQuadLine` writes the quad to the output stream as a single line

  }, {
    key: "_writeQuadLine",
    value: function _writeQuadLine(subject, predicate, object, graph, done) {
      // Write the quad without prefixes
      delete this._prefixMatch;

      this._write(this.quadToString(subject, predicate, object, graph), done);
    } // ### `quadToString` serializes a quad as a string

  }, {
    key: "quadToString",
    value: function quadToString(subject, predicate, object, graph) {
      return this._encodeSubject(subject) + ' ' + this._encodeIriOrBlank(predicate) + ' ' + this._encodeObject(object) + (graph && graph.value ? ' ' + this._encodeIriOrBlank(graph) + ' .\n' : ' .\n');
    } // ### `quadsToString` serializes an array of quads as a string

  }, {
    key: "quadsToString",
    value: function quadsToString(quads) {
      return quads.map(function (t) {
        return this.quadToString(t.subject, t.predicate, t.object, t.graph);
      }, this).join('');
    } // ### `_encodeSubject` represents a subject

  }, {
    key: "_encodeSubject",
    value: function _encodeSubject(entity) {
      return entity.termType === 'Quad' ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);
    } // ### `_encodeIriOrBlank` represents an IRI or blank node

  }, {
    key: "_encodeIriOrBlank",
    value: function _encodeIriOrBlank(entity) {
      // A blank node or list is represented as-is
      if (entity.termType !== 'NamedNode') {
        // If it is a list head, pretty-print it
        if (this._lists && entity.value in this._lists) entity = this.list(this._lists[entity.value]);
        return 'id' in entity ? entity.id : '_:' + entity.value;
      } // Escape special characters


      var iri = entity.value;
      if (escape.test(iri)) iri = iri.replace(escapeAll, characterReplacer); // Try to represent the IRI as prefixed name

      var prefixMatch = this._prefixRegex.exec(iri);

      return !prefixMatch ? '<' + iri + '>' : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];
    } // ### `_encodeLiteral` represents a literal

  }, {
    key: "_encodeLiteral",
    value: function _encodeLiteral(literal) {
      // Escape special characters
      var value = literal.value;
      if (escape.test(value)) value = value.replace(escapeAll, characterReplacer); // Write the literal, possibly with type or language

      if (literal.language) return '"' + value + '"@' + literal.language;else if (literal.datatype.value !== xsd.string) return '"' + value + '"^^' + this._encodeIriOrBlank(literal.datatype);else return '"' + value + '"';
    } // ### `_encodePredicate` represents a predicate

  }, {
    key: "_encodePredicate",
    value: function _encodePredicate(predicate) {
      return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);
    } // ### `_encodeObject` represents an object

  }, {
    key: "_encodeObject",
    value: function _encodeObject(object) {
      switch (object.termType) {
        case 'Quad':
          return this._encodeQuad(object);

        case 'Literal':
          return this._encodeLiteral(object);

        default:
          return this._encodeIriOrBlank(object);
      }
    } // ### `_encodeQuad` encodes an RDF* quad

  }, {
    key: "_encodeQuad",
    value: function _encodeQuad(_ref) {
      var subject = _ref.subject,
          predicate = _ref.predicate,
          object = _ref.object,
          graph = _ref.graph;
      return "<<".concat(this._encodeSubject(subject), " ").concat(this._encodePredicate(predicate), " ").concat(this._encodeObject(object)).concat((0, _N3Util.isDefaultGraph)(graph) ? '' : " ".concat(this._encodeIriOrBlank(graph)), ">>");
    } // ### `_blockedWrite` replaces `_write` after the writer has been closed

  }, {
    key: "_blockedWrite",
    value: function _blockedWrite() {
      throw new Error('Cannot write because the writer has been closed.');
    } // ### `addQuad` adds the quad to the output stream

  }, {
    key: "addQuad",
    value: function addQuad(subject, predicate, object, graph, done) {
      // The quad was given as an object, so shift parameters
      if (object === undefined) this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate); // The optional `graph` parameter was not provided
      else if (typeof graph === 'function') this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph); // The `graph` parameter was provided
        else this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);
    } // ### `addQuads` adds the quads to the output stream

  }, {
    key: "addQuads",
    value: function addQuads(quads) {
      for (var i = 0; i < quads.length; i++) {
        this.addQuad(quads[i]);
      }
    } // ### `addPrefix` adds the prefix to the output stream

  }, {
    key: "addPrefix",
    value: function addPrefix(prefix, iri, done) {
      var prefixes = {};
      prefixes[prefix] = iri;
      this.addPrefixes(prefixes, done);
    } // ### `addPrefixes` adds the prefixes to the output stream

  }, {
    key: "addPrefixes",
    value: function addPrefixes(prefixes, done) {
      var prefixIRIs = this._prefixIRIs,
          hasPrefixes = false;

      for (var prefix in prefixes) {
        var iri = prefixes[prefix];
        if (typeof iri !== 'string') iri = iri.value;
        hasPrefixes = true; // Finish a possible pending quad

        if (this._subject !== null) {
          this._write(this._inDefaultGraph ? '.\n' : '\n}\n');

          this._subject = null, this._graph = '';
        } // Store and write the prefix


        prefixIRIs[iri] = prefix += ':';

        this._write('@prefix ' + prefix + ' <' + iri + '>.\n');
      } // Recreate the prefix matcher


      if (hasPrefixes) {
        var IRIlist = '',
            prefixList = '';

        for (var prefixIRI in prefixIRIs) {
          IRIlist += IRIlist ? '|' + prefixIRI : prefixIRI;
          prefixList += (prefixList ? '|' : '') + prefixIRIs[prefixIRI];
        }

        IRIlist = IRIlist.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, '\\$&');
        this._prefixRegex = new RegExp('^(?:' + prefixList + ')[^\/]*$|' + '^(' + IRIlist + ')([a-zA-Z][\\-_a-zA-Z0-9]*)$');
      } // End a prefix block with a newline


      this._write(hasPrefixes ? '\n' : '', done);
    } // ### `blank` creates a blank node with the given content

  }, {
    key: "blank",
    value: function blank(predicate, object) {
      var children = predicate,
          child,
          length; // Empty blank node

      if (predicate === undefined) children = []; // Blank node passed as blank(Term("predicate"), Term("object"))
      else if (predicate.termType) children = [{
          predicate: predicate,
          object: object
        }]; // Blank node passed as blank({ predicate: predicate, object: object })
        else if (!('length' in predicate)) children = [predicate];

      switch (length = children.length) {
        // Generate an empty blank node
        case 0:
          return new SerializedTerm('[]');
        // Generate a non-nested one-triple blank node

        case 1:
          child = children[0];
          if (!(child.object instanceof SerializedTerm)) return new SerializedTerm('[ ' + this._encodePredicate(child.predicate) + ' ' + this._encodeObject(child.object) + ' ]');
        // Generate a multi-triple or nested blank node

        default:
          var contents = '['; // Write all triples in order

          for (var i = 0; i < length; i++) {
            child = children[i]; // Write only the object is the predicate is the same as the previous

            if (child.predicate.equals(predicate)) contents += ', ' + this._encodeObject(child.object); // Otherwise, write the predicate and the object
            else {
                contents += (i ? ';\n  ' : '\n  ') + this._encodePredicate(child.predicate) + ' ' + this._encodeObject(child.object);
                predicate = child.predicate;
              }
          }

          return new SerializedTerm(contents + '\n]');
      }
    } // ### `list` creates a list node with the given content

  }, {
    key: "list",
    value: function list(elements) {
      var length = elements && elements.length || 0,
          contents = new Array(length);

      for (var i = 0; i < length; i++) {
        contents[i] = this._encodeObject(elements[i]);
      }

      return new SerializedTerm('(' + contents.join(' ') + ')');
    } // ### `end` signals the end of the output stream

  }, {
    key: "end",
    value: function end(done) {
      // Finish a possible pending quad
      if (this._subject !== null) {
        this._write(this._inDefaultGraph ? '.\n' : '\n}\n');

        this._subject = null;
      } // Disallow further writing


      this._write = this._blockedWrite; // Try to end the underlying stream, ensuring done is called exactly one time

      var singleDone = done && function (error, result) {
        singleDone = null, done(error, result);
      };

      if (this._endStream) {
        try {
          return this._outputStream.end(singleDone);
        } catch (error) {
          /* error closing stream */
        }
      }

      singleDone && singleDone();
    }
  }, {
    key: "_inDefaultGraph",
    get: function get() {
      return DEFAULTGRAPH.equals(this._graph);
    }
  }]);
  return N3Writer;
}(); // Replaces a character by its escaped version


exports["default"] = N3Writer;

function characterReplacer(character) {
  // Replace a single character by its escaped version
  var result = escapedCharacters[character];

  if (result === undefined) {
    // Replace a single character with its 4-bit unicode escape sequence
    if (character.length === 1) {
      result = character.charCodeAt(0).toString(16);
      result = "\\u0000".substr(0, 6 - result.length) + result;
    } // Replace a surrogate pair with its 8-bit unicode escape sequence
    else {
        result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);
        result = "\\U00000000".substr(0, 10 - result.length) + result;
      }
  }

  return result;
}

},{"./IRIs":126,"./N3DataFactory":127,"./N3Util":133,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"@babel/runtime/helpers/typeof":27}],135:[function(require,module,exports){
"use strict";

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault2(require("@babel/runtime/helpers/typeof"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Lexer", {
  enumerable: true,
  get: function get() {
    return _N3Lexer["default"];
  }
});
Object.defineProperty(exports, "Parser", {
  enumerable: true,
  get: function get() {
    return _N3Parser["default"];
  }
});
Object.defineProperty(exports, "Writer", {
  enumerable: true,
  get: function get() {
    return _N3Writer["default"];
  }
});
Object.defineProperty(exports, "Store", {
  enumerable: true,
  get: function get() {
    return _N3Store["default"];
  }
});
Object.defineProperty(exports, "StreamParser", {
  enumerable: true,
  get: function get() {
    return _N3StreamParser["default"];
  }
});
Object.defineProperty(exports, "StreamWriter", {
  enumerable: true,
  get: function get() {
    return _N3StreamWriter["default"];
  }
});
Object.defineProperty(exports, "DataFactory", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory["default"];
  }
});
Object.defineProperty(exports, "Term", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Term;
  }
});
Object.defineProperty(exports, "NamedNode", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.NamedNode;
  }
});
Object.defineProperty(exports, "Literal", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Literal;
  }
});
Object.defineProperty(exports, "BlankNode", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.BlankNode;
  }
});
Object.defineProperty(exports, "Variable", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Variable;
  }
});
Object.defineProperty(exports, "DefaultGraph", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.DefaultGraph;
  }
});
Object.defineProperty(exports, "Quad", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Quad;
  }
});
Object.defineProperty(exports, "Triple", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.Triple;
  }
});
Object.defineProperty(exports, "termFromId", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.termFromId;
  }
});
Object.defineProperty(exports, "termToId", {
  enumerable: true,
  get: function get() {
    return _N3DataFactory.termToId;
  }
});
exports.Util = void 0;

var _N3Lexer = _interopRequireDefault(require("./N3Lexer"));

var _N3Parser = _interopRequireDefault(require("./N3Parser"));

var _N3Writer = _interopRequireDefault(require("./N3Writer"));

var _N3Store = _interopRequireDefault(require("./N3Store"));

var _N3StreamParser = _interopRequireDefault(require("./N3StreamParser"));

var _N3StreamWriter = _interopRequireDefault(require("./N3StreamWriter"));

var Util = _interopRequireWildcard(require("./N3Util"));

exports.Util = Util;

var _N3DataFactory = _interopRequireWildcard(require("./N3DataFactory"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || (0, _typeof2["default"])(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

},{"./N3DataFactory":127,"./N3Lexer":128,"./N3Parser":129,"./N3Store":130,"./N3StreamParser":131,"./N3StreamWriter":132,"./N3Util":133,"./N3Writer":134,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],136:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
var api = {};
module.exports = api; // baseN alphabet indexes

var _reverseAlphabets = {};
/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */

api.encode = function (input, alphabet, maxline) {
  if (typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }

  if (maxline !== undefined && typeof maxline !== 'number') {
    throw new TypeError('"maxline" must be a number.');
  }

  var output = '';

  if (!(input instanceof Uint8Array)) {
    // assume forge byte buffer
    output = _encodeWithByteBuffer(input, alphabet);
  } else {
    var i = 0;
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var digits = [0];

    for (i = 0; i < input.length; ++i) {
      for (var j = 0, carry = input[i]; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base;
        carry = carry / base | 0;
      }

      while (carry > 0) {
        digits.push(carry % base);
        carry = carry / base | 0;
      }
    } // deal with leading zeros


    for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
      output += first;
    } // convert digits to a string


    for (i = digits.length - 1; i >= 0; --i) {
      output += alphabet[digits[i]];
    }
  }

  if (maxline) {
    var regex = new RegExp('.{1,' + maxline + '}', 'g');
    output = output.match(regex).join('\r\n');
  }

  return output;
};
/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */


api.decode = function (input, alphabet) {
  if (typeof input !== 'string') {
    throw new TypeError('"input" must be a string.');
  }

  if (typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }

  var table = _reverseAlphabets[alphabet];

  if (!table) {
    // compute reverse alphabet
    table = _reverseAlphabets[alphabet] = [];

    for (var i = 0; i < alphabet.length; ++i) {
      table[alphabet.charCodeAt(i)] = i;
    }
  } // remove whitespace characters


  input = input.replace(/\s/g, '');
  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var bytes = [0];

  for (var i = 0; i < input.length; i++) {
    var value = table[input.charCodeAt(i)];

    if (value === undefined) {
      return;
    }

    for (var j = 0, carry = value; j < bytes.length; ++j) {
      carry += bytes[j] * base;
      bytes[j] = carry & 0xff;
      carry >>= 8;
    }

    while (carry > 0) {
      bytes.push(carry & 0xff);
      carry >>= 8;
    }
  } // deal with leading zeros


  for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
    bytes.push(0);
  }

  if (typeof Buffer !== 'undefined') {
    return Buffer.from(bytes.reverse());
  }

  return new Uint8Array(bytes.reverse());
};

function _encodeWithByteBuffer(input, alphabet) {
  var i = 0;
  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var digits = [0];

  for (i = 0; i < input.length(); ++i) {
    for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
      carry += digits[j] << 8;
      digits[j] = carry % base;
      carry = carry / base | 0;
    }

    while (carry > 0) {
      digits.push(carry % base);
      carry = carry / base | 0;
    }
  }

  var output = ''; // deal with leading zeros

  for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
    output += first;
  } // convert digits to a string


  for (i = digits.length - 1; i >= 0; --i) {
    output += alphabet[digits[i]];
  }

  return output;
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":58}],137:[function(require,module,exports){
"use strict";

/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */
module.exports = {
  // default options
  options: {
    usePureJavaScript: false
  }
};

},{}],138:[function(require,module,exports){
"use strict";

/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */
var forge = require('./forge');

module.exports = forge.md = forge.md || {};
forge.md.algorithms = forge.md.algorithms || {};

},{"./forge":137}],139:[function(require,module,exports){
"use strict";

/**
 * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./md');

require('./util');

var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
/**
 * Creates a SHA-1 message digest object.
 *
 * @return a message digest object.
 */

sha1.create = function () {
  // do initialization as necessary
  if (!_initialized) {
    _init();
  } // SHA-1 state contains five 32-bit integers


  var _state = null; // input buffer

  var _input = forge.util.createBuffer(); // used for word storage


  var _w = new Array(80); // message digest object


  var md = {
    algorithm: 'sha1',
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  /**
   * Starts the digest.
   *
   * @return this digest object.
   */

  md.start = function () {
    // up to 56-bit message length for convenience
    md.messageLength = 0; // full message length (set md.messageLength64 for backwards-compatibility)

    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;

    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }

    _input = forge.util.createBuffer();
    _state = {
      h0: 0x67452301,
      h1: 0xEFCDAB89,
      h2: 0x98BADCFE,
      h3: 0x10325476,
      h4: 0xC3D2E1F0
    };
    return md;
  }; // start digest automatically for first time


  md.start();
  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */

  md.update = function (msg, encoding) {
    if (encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    } // update message length


    var len = msg.length;
    md.messageLength += len;
    len = [len / 0x100000000 >>> 0, len >>> 0];

    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 0x100000000 >>> 0;
    } // add bytes to input buffer


    _input.putBytes(msg); // process bytes


    _update(_state, _w, _input); // compact input buffer every 2K or if empty


    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };
  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */


  md.digest = function () {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.
     In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */
    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes()); // compute remaining size to be digested (include message length size)

    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes

    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int

    var next, carry;
    var bits = md.fullMessageLength[0] * 8;

    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 0x100000000 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }

    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4
    };

    _update(s2, _w, finalBlock);

    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };

  return md;
}; // sha-1 padding bytes not initialized yet


var _padding = null;
var _initialized = false;
/**
 * Initializes the constant tables.
 */

function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64); // now initialized

  _initialized = true;
}
/**
 * Updates a SHA-1 state with the given byte buffer.
 *
 * @param s the SHA-1 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */


function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t, a, b, c, d, e, f, i;
  var len = bytes.length();

  while (len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 80 32-bit words according to SHA-1 algorithm
    // and for 32-79 using Max Locktyukhin's optimization
    // initialize hash value for this chunk
    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4; // round 1

    for (i = 0; i < 16; ++i) {
      t = bytes.getInt32();
      w[i] = t;
      f = d ^ b & (c ^ d);
      t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    }

    for (; i < 20; ++i) {
      t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      t = t << 1 | t >>> 31;
      w[i] = t;
      f = d ^ b & (c ^ d);
      t = (a << 5 | a >>> 27) + f + e + 0x5A827999 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // round 2


    for (; i < 32; ++i) {
      t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      t = t << 1 | t >>> 31;
      w[i] = t;
      f = b ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    }

    for (; i < 40; ++i) {
      t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
      t = t << 2 | t >>> 30;
      w[i] = t;
      f = b ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // round 3


    for (; i < 60; ++i) {
      t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
      t = t << 2 | t >>> 30;
      w[i] = t;
      f = b & c | d & (b ^ c);
      t = (a << 5 | a >>> 27) + f + e + 0x8F1BBCDC + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // round 4


    for (; i < 80; ++i) {
      t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
      t = t << 2 | t >>> 30;
      w[i] = t;
      f = b ^ c ^ d;
      t = (a << 5 | a >>> 27) + f + e + 0xCA62C1D6 + t;
      e = d;
      d = c; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug

      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t;
    } // update hash state


    s.h0 = s.h0 + a | 0;
    s.h1 = s.h1 + b | 0;
    s.h2 = s.h2 + c | 0;
    s.h3 = s.h3 + d | 0;
    s.h4 = s.h4 + e | 0;
    len -= 64;
  }
}

},{"./forge":137,"./md":138,"./util":141}],140:[function(require,module,exports){
"use strict";

/**
 * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
 *
 * See FIPS 180-2 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = require('./forge');

require('./md');

require('./util');

var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
/**
 * Creates a SHA-256 message digest object.
 *
 * @return a message digest object.
 */

sha256.create = function () {
  // do initialization as necessary
  if (!_initialized) {
    _init();
  } // SHA-256 state contains eight 32-bit integers


  var _state = null; // input buffer

  var _input = forge.util.createBuffer(); // used for word storage


  var _w = new Array(64); // message digest object


  var md = {
    algorithm: 'sha256',
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  /**
   * Starts the digest.
   *
   * @return this digest object.
   */

  md.start = function () {
    // up to 56-bit message length for convenience
    md.messageLength = 0; // full message length (set md.messageLength64 for backwards-compatibility)

    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;

    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }

    _input = forge.util.createBuffer();
    _state = {
      h0: 0x6A09E667,
      h1: 0xBB67AE85,
      h2: 0x3C6EF372,
      h3: 0xA54FF53A,
      h4: 0x510E527F,
      h5: 0x9B05688C,
      h6: 0x1F83D9AB,
      h7: 0x5BE0CD19
    };
    return md;
  }; // start digest automatically for first time


  md.start();
  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */

  md.update = function (msg, encoding) {
    if (encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    } // update message length


    var len = msg.length;
    md.messageLength += len;
    len = [len / 0x100000000 >>> 0, len >>> 0];

    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 0x100000000 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 0x100000000 >>> 0;
    } // add bytes to input buffer


    _input.putBytes(msg); // process bytes


    _update(_state, _w, _input); // compact input buffer every 2K or if empty


    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };
  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */


  md.digest = function () {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.
     In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */
    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes()); // compute remaining size to be digested (include message length size)

    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes

    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int

    var next, carry;
    var bits = md.fullMessageLength[0] * 8;

    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 0x100000000 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }

    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4,
      h5: _state.h5,
      h6: _state.h6,
      h7: _state.h7
    };

    _update(s2, _w, finalBlock);

    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };

  return md;
}; // sha-256 padding bytes not initialized yet


var _padding = null;
var _initialized = false; // table of constants

var _k = null;
/**
 * Initializes the constant tables.
 */

function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64); // create K table for SHA-256

  _k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; // now initialized

  _initialized = true;
}
/**
 * Updates a SHA-256 state with the given byte buffer.
 *
 * @param s the SHA-256 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */


function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
  var len = bytes.length();

  while (len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 64 32-bit words according to SHA-256
    for (i = 0; i < 16; ++i) {
      w[i] = bytes.getInt32();
    }

    for (; i < 64; ++i) {
      // XOR word 2 words ago rot right 17, rot right 19, shft right 10
      t1 = w[i - 2];
      t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10; // XOR word 15 words ago rot right 7, rot right 18, shft right 3

      t2 = w[i - 15];
      t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3; // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32

      w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
    } // initialize hash value for this chunk


    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4;
    f = s.h5;
    g = s.h6;
    h = s.h7; // round function

    for (i = 0; i < 64; ++i) {
      // Sum1(e)
      s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7); // Ch(e, f, g) (optimized the same way as SHA-1)

      ch = g ^ e & (f ^ g); // Sum0(a)

      s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10); // Maj(a, b, c) (optimized the same way as SHA-1)

      maj = a & b | c & (a ^ b); // main algorithm

      t1 = h + s1 + ch + _k[i] + w[i];
      t2 = s0 + maj;
      h = g;
      g = f;
      f = e; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`

      e = d + t1 >>> 0;
      d = c;
      c = b;
      b = a; // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`

      a = t1 + t2 >>> 0;
    } // update hash state


    s.h0 = s.h0 + a | 0;
    s.h1 = s.h1 + b | 0;
    s.h2 = s.h2 + c | 0;
    s.h3 = s.h3 + d | 0;
    s.h4 = s.h4 + e | 0;
    s.h5 = s.h5 + f | 0;
    s.h6 = s.h6 + g | 0;
    s.h7 = s.h7 + h | 0;
    len -= 64;
  }
}

},{"./forge":137,"./md":138,"./util":141}],141:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */
var forge = require('./forge');

var baseN = require('./baseN');
/* Utilities API */


var util = module.exports = forge.util = forge.util || {}; // define setImmediate and nextTick

(function () {
  // use native nextTick (unless we're in webpack)
  // webpack (or better node-libs-browser polyfill) sets process.browser.
  // this way we can detect webpack properly
  if (typeof process !== 'undefined' && process.nextTick && !process.browser) {
    util.nextTick = process.nextTick;

    if (typeof setImmediate === 'function') {
      util.setImmediate = setImmediate;
    } else {
      // polyfill setImmediate with nextTick, older versions of node
      // (those w/o setImmediate) won't totally starve IO
      util.setImmediate = util.nextTick;
    }

    return;
  } // polyfill nextTick with native setImmediate


  if (typeof setImmediate === 'function') {
    util.setImmediate = function () {
      return setImmediate.apply(undefined, arguments);
    };

    util.nextTick = function (callback) {
      return setImmediate(callback);
    };

    return;
  }
  /* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */
  // polyfill with setTimeout


  util.setImmediate = function (callback) {
    setTimeout(callback, 0);
  }; // upgrade polyfill to use postMessage


  if (typeof window !== 'undefined' && typeof window.postMessage === 'function') {
    var handler = function handler(event) {
      if (event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function (callback) {
          callback();
        });
      }
    };

    var msg = 'forge.setImmediate';
    var callbacks = [];

    util.setImmediate = function (callback) {
      callbacks.push(callback); // only send message when one hasn't been sent in
      // the current turn of the event loop

      if (callbacks.length === 1) {
        window.postMessage(msg, '*');
      }
    };

    window.addEventListener('message', handler, true);
  } // upgrade polyfill to use MutationObserver


  if (typeof MutationObserver !== 'undefined') {
    // polyfill with MutationObserver
    var now = Date.now();
    var attr = true;
    var div = document.createElement('div');
    var callbacks = [];
    new MutationObserver(function () {
      var copy = callbacks.slice();
      callbacks.length = 0;
      copy.forEach(function (callback) {
        callback();
      });
    }).observe(div, {
      attributes: true
    });
    var oldSetImmediate = util.setImmediate;

    util.setImmediate = function (callback) {
      if (Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback); // only trigger observer when it hasn't been triggered in
        // the current turn of the event loop

        if (callbacks.length === 1) {
          div.setAttribute('a', attr = !attr);
        }
      }
    };
  }

  util.nextTick = util.setImmediate;
})(); // check if running under Node.js


util.isNodejs = typeof process !== 'undefined' && process.versions && process.versions.node; // 'self' will also work in Web Workers (instance of WorkerGlobalScope) while
// it will point to `window` in the main thread.
// To remain compatible with older browsers, we fall back to 'window' if 'self'
// is not available.

util.globalScope = function () {
  if (util.isNodejs) {
    return global;
  }

  return typeof self === 'undefined' ? window : self;
}(); // define isArray


util.isArray = Array.isArray || function (x) {
  return Object.prototype.toString.call(x) === '[object Array]';
}; // define isArrayBuffer


util.isArrayBuffer = function (x) {
  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;
}; // define isArrayBufferView


util.isArrayBufferView = function (x) {
  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
};
/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */


function _checkBitsParam(n) {
  if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);
  }
} // TODO: set ByteBuffer to best available backing


util.ByteBuffer = ByteStringBuffer;
/** Buffer w/BinaryString backing */

/**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */

function ByteStringBuffer(b) {
  // TODO: update to match DataBuffer API
  // the data in this buffer
  this.data = ''; // the pointer for reading from this buffer

  this.read = 0;

  if (typeof b === 'string') {
    this.data = b;
  } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
    if (typeof Buffer !== 'undefined' && b instanceof Buffer) {
      this.data = b.toString('binary');
    } else {
      // convert native buffer to forge buffer
      // FIXME: support native buffers internally instead
      var arr = new Uint8Array(b);

      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch (e) {
        for (var i = 0; i < arr.length; ++i) {
          this.putByte(arr[i]);
        }
      }
    }
  } else if (b instanceof ByteStringBuffer || (0, _typeof2["default"])(b) === 'object' && typeof b.data === 'string' && typeof b.read === 'number') {
    // copy existing buffer
    this.data = b.data;
    this.read = b.read;
  } // used for v8 optimization


  this._constructedStringLength = 0;
}

util.ByteStringBuffer = ByteStringBuffer;
/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */

var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;

util.ByteStringBuffer.prototype._optimizeConstructedString = function (x) {
  this._constructedStringLength += x;

  if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
    // this substr() should cause the constructed string to join
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};
/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */


util.ByteStringBuffer.prototype.length = function () {
  return this.data.length - this.read;
};
/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */


util.ByteStringBuffer.prototype.isEmpty = function () {
  return this.length() <= 0;
};
/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putByte = function (b) {
  return this.putBytes(String.fromCharCode(b));
};
/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.fillWithByte = function (b, n) {
  b = String.fromCharCode(b);
  var d = this.data;

  while (n > 0) {
    if (n & 1) {
      d += b;
    }

    n >>>= 1;

    if (n > 0) {
      b += b;
    }
  }

  this.data = d;

  this._optimizeConstructedString(n);

  return this;
};
/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a binary encoded string) to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putBytes = function (bytes) {
  this.data += bytes;

  this._optimizeConstructedString(bytes.length);

  return this;
};
/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putString = function (str) {
  return this.putBytes(util.encodeUtf8(str));
};
/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt16 = function (i) {
  return this.putBytes(String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt24 = function (i) {
  return this.putBytes(String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt32 = function (i) {
  return this.putBytes(String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
};
/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt16Le = function (i) {
  return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF));
};
/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt24Le = function (i) {
  return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF));
};
/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt32Le = function (i) {
  return this.putBytes(String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 24 & 0xFF));
};
/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putInt = function (i, n) {
  _checkBitsParam(n);

  var bytes = '';

  do {
    n -= 8;
    bytes += String.fromCharCode(i >> n & 0xFF);
  } while (n > 0);

  return this.putBytes(bytes);
};
/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putSignedInt = function (i, n) {
  // putInt checks n
  if (i < 0) {
    i += 2 << n - 1;
  }

  return this.putInt(i, n);
};
/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.putBuffer = function (buffer) {
  return this.putBytes(buffer.getBytes());
};
/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */


util.ByteStringBuffer.prototype.getByte = function () {
  return this.data.charCodeAt(this.read++);
};
/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.ByteStringBuffer.prototype.getInt16 = function () {
  var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.ByteStringBuffer.prototype.getInt24 = function () {
  var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.ByteStringBuffer.prototype.getInt32 = function () {
  var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  this.read += 4;
  return rval;
};
/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.ByteStringBuffer.prototype.getInt16Le = function () {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.ByteStringBuffer.prototype.getInt24Le = function () {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.ByteStringBuffer.prototype.getInt32Le = function () {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  this.read += 4;
  return rval;
};
/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.ByteStringBuffer.prototype.getInt = function (n) {
  _checkBitsParam(n);

  var rval = 0;

  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n -= 8;
  } while (n > 0);

  return rval;
};
/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.ByteStringBuffer.prototype.getSignedInt = function (n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << n - 2;

  if (x >= max) {
    x -= max << 1;
  }

  return x;
};
/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer. Note that the resulting string is binary encoded (in node.js this
 * encoding is referred to as `binary`, it is *not* `utf8`).
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */


util.ByteStringBuffer.prototype.getBytes = function (count) {
  var rval;

  if (count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }

  return rval;
};
/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */


util.ByteStringBuffer.prototype.bytes = function (count) {
  return typeof count === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */


util.ByteStringBuffer.prototype.at = function (i) {
  return this.data.charCodeAt(this.read + i);
};
/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.setAt = function (i, b) {
  this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
  return this;
};
/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */


util.ByteStringBuffer.prototype.last = function () {
  return this.data.charCodeAt(this.data.length - 1);
};
/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */


util.ByteStringBuffer.prototype.copy = function () {
  var c = util.createBuffer(this.data);
  c.read = this.read;
  return c;
};
/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.compact = function () {
  if (this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }

  return this;
};
/**
 * Clears this buffer.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.clear = function () {
  this.data = '';
  this.read = 0;
  return this;
};
/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */


util.ByteStringBuffer.prototype.truncate = function (count) {
  var len = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len);
  this.read = 0;
  return this;
};
/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */


util.ByteStringBuffer.prototype.toHex = function () {
  var rval = '';

  for (var i = this.read; i < this.data.length; ++i) {
    var b = this.data.charCodeAt(i);

    if (b < 16) {
      rval += '0';
    }

    rval += b.toString(16);
  }

  return rval;
};
/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */


util.ByteStringBuffer.prototype.toString = function () {
  return util.decodeUtf8(this.bytes());
};
/** End Buffer w/BinaryString backing */

/** Buffer w/UInt8Array backing */

/**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */


function DataBuffer(b, options) {
  // default options
  options = options || {}; // pointers for read from/write to buffer

  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;
  var isArrayBuffer = util.isArrayBuffer(b);
  var isArrayBufferView = util.isArrayBufferView(b);

  if (isArrayBuffer || isArrayBufferView) {
    // use ArrayBuffer directly
    if (isArrayBuffer) {
      this.data = new DataView(b);
    } else {
      // TODO: adjust read/write offset based on the type of view
      // or specify that this must be done in the options ... that the
      // offsets are byte-based
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }

    this.write = 'writeOffset' in options ? options.writeOffset : this.data.byteLength;
    return;
  } // initialize to empty array buffer and add any given bytes using putBytes


  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;

  if (b !== null && b !== undefined) {
    this.putBytes(b);
  }

  if ('writeOffset' in options) {
    this.write = options.writeOffset;
  }
}

util.DataBuffer = DataBuffer;
/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */

util.DataBuffer.prototype.length = function () {
  return this.write - this.read;
};
/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */


util.DataBuffer.prototype.isEmpty = function () {
  return this.length() <= 0;
};
/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */


util.DataBuffer.prototype.accommodate = function (amount, growSize) {
  if (this.length() >= amount) {
    return this;
  }

  growSize = Math.max(growSize || this.growSize, amount); // grow buffer

  var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src);
  this.data = new DataView(dst.buffer);
  return this;
};
/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putByte = function (b) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b);
  return this;
};
/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.fillWithByte = function (b, n) {
  this.accommodate(n);

  for (var i = 0; i < n; ++i) {
    this.data.setUint8(b);
  }

  return this;
};
/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putBytes = function (bytes, encoding) {
  if (util.isArrayBufferView(bytes)) {
    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var len = src.byteLength - src.byteOffset;
    this.accommodate(len);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src);
    this.write += len;
    return this;
  }

  if (util.isArrayBuffer(bytes)) {
    var src = new Uint8Array(bytes);
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src, this.write);
    this.write += src.byteLength;
    return this;
  } // bytes is a util.DataBuffer or equivalent


  if (bytes instanceof util.DataBuffer || (0, _typeof2["default"])(bytes) === 'object' && typeof bytes.read === 'number' && typeof bytes.write === 'number' && util.isArrayBufferView(bytes.data)) {
    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(bytes.data.byteLength, this.write);
    dst.set(src);
    this.write += src.byteLength;
    return this;
  }

  if (bytes instanceof util.ByteStringBuffer) {
    // copy binary string and process as the same as a string parameter below
    bytes = bytes.data;
    encoding = 'binary';
  } // string conversion


  encoding = encoding || 'binary';

  if (typeof bytes === 'string') {
    var view; // decode from string

    if (encoding === 'hex') {
      this.accommodate(Math.ceil(bytes.length / 2));
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.hex.decode(bytes, view, this.write);
      return this;
    }

    if (encoding === 'base64') {
      this.accommodate(Math.ceil(bytes.length / 4) * 3);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.base64.decode(bytes, view, this.write);
      return this;
    } // encode text as UTF-8 bytes


    if (encoding === 'utf8') {
      // encode as UTF-8 then decode string as raw binary
      bytes = util.encodeUtf8(bytes);
      encoding = 'binary';
    } // decode string as raw binary


    if (encoding === 'binary' || encoding === 'raw') {
      // one byte per character
      this.accommodate(bytes.length);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.raw.decode(view);
      return this;
    } // encode text as UTF-16 bytes


    if (encoding === 'utf16') {
      // two bytes per character
      this.accommodate(bytes.length * 2);
      view = new Uint16Array(this.data.buffer, this.write);
      this.write += util.text.utf16.encode(view);
      return this;
    }

    throw new Error('Invalid encoding: ' + encoding);
  }

  throw Error('Invalid parameter: ' + bytes);
};
/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putBuffer = function (buffer) {
  this.putBytes(buffer);
  buffer.clear();
  return this;
};
/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putString = function (str) {
  return this.putBytes(str, 'utf16');
};
/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt16 = function (i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i);
  this.write += 2;
  return this;
};
/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt24 = function (i) {
  this.accommodate(3);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.write += 3;
  return this;
};
/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt32 = function (i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i);
  this.write += 4;
  return this;
};
/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt16Le = function (i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i, true);
  this.write += 2;
  return this;
};
/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt24Le = function (i) {
  this.accommodate(3);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
  this.write += 3;
  return this;
};
/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt32Le = function (i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i, true);
  this.write += 4;
  return this;
};
/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putInt = function (i, n) {
  _checkBitsParam(n);

  this.accommodate(n / 8);

  do {
    n -= 8;
    this.data.setInt8(this.write++, i >> n & 0xFF);
  } while (n > 0);

  return this;
};
/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.putSignedInt = function (i, n) {
  _checkBitsParam(n);

  this.accommodate(n / 8);

  if (i < 0) {
    i += 2 << n - 1;
  }

  return this.putInt(i, n);
};
/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */


util.DataBuffer.prototype.getByte = function () {
  return this.data.getInt8(this.read++);
};
/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.DataBuffer.prototype.getInt16 = function () {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.DataBuffer.prototype.getInt24 = function () {
  var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.DataBuffer.prototype.getInt32 = function () {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};
/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */


util.DataBuffer.prototype.getInt16Le = function () {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};
/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */


util.DataBuffer.prototype.getInt24Le = function () {
  var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
  this.read += 3;
  return rval;
};
/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */


util.DataBuffer.prototype.getInt32Le = function () {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};
/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.DataBuffer.prototype.getInt = function (n) {
  _checkBitsParam(n);

  var rval = 0;

  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n -= 8;
  } while (n > 0);

  return rval;
};
/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */


util.DataBuffer.prototype.getSignedInt = function (n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << n - 2;

  if (x >= max) {
    x -= max << 1;
  }

  return x;
};
/**
 * Reads bytes out as a binary encoded string and clears them from the
 * buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a binary encoded string of bytes.
 */


util.DataBuffer.prototype.getBytes = function (count) {
  // TODO: deprecate this method, it is poorly named and
  // this.toString('binary') replaces it
  // add a toTypedArray()/toArrayBuffer() function
  var rval;

  if (count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }

  return rval;
};
/**
 * Gets a binary encoded string of the bytes from this buffer without
 * modifying the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of binary encoded characters.
 */


util.DataBuffer.prototype.bytes = function (count) {
  // TODO: deprecate this method, it is poorly named, add "getString()"
  return typeof count === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */


util.DataBuffer.prototype.at = function (i) {
  return this.data.getUint8(this.read + i);
};
/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.setAt = function (i, b) {
  this.data.setUint8(i, b);
  return this;
};
/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */


util.DataBuffer.prototype.last = function () {
  return this.data.getUint8(this.write - 1);
};
/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */


util.DataBuffer.prototype.copy = function () {
  return new util.DataBuffer(this);
};
/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.compact = function () {
  if (this.read > 0) {
    var src = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src.byteLength);
    dst.set(src);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }

  return this;
};
/**
 * Clears this buffer.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.clear = function () {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};
/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */


util.DataBuffer.prototype.truncate = function (count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};
/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */


util.DataBuffer.prototype.toHex = function () {
  var rval = '';

  for (var i = this.read; i < this.data.byteLength; ++i) {
    var b = this.data.getUint8(i);

    if (b < 16) {
      rval += '0';
    }

    rval += b.toString(16);
  }

  return rval;
};
/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */


util.DataBuffer.prototype.toString = function (encoding) {
  var view = new Uint8Array(this.data, this.read, this.length());
  encoding = encoding || 'utf8'; // encode to string

  if (encoding === 'binary' || encoding === 'raw') {
    return util.binary.raw.encode(view);
  }

  if (encoding === 'hex') {
    return util.binary.hex.encode(view);
  }

  if (encoding === 'base64') {
    return util.binary.base64.encode(view);
  } // decode to text


  if (encoding === 'utf8') {
    return util.text.utf8.decode(view);
  }

  if (encoding === 'utf16') {
    return util.text.utf16.decode(view);
  }

  throw new Error('Invalid encoding: ' + encoding);
};
/** End Buffer w/UInt8Array backing */

/**
 * Creates a buffer that stores bytes. A value may be given to populate the
 * buffer with data. This value can either be string of encoded bytes or a
 * regular string of characters. When passing a string of binary encoded
 * bytes, the encoding `raw` should be given. This is also the default. When
 * passing a string of characters, the encoding `utf8` should be given.
 *
 * @param [input] a string with encoded bytes to store in the buffer.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */


util.createBuffer = function (input, encoding) {
  // TODO: deprecate, use new ByteBuffer() instead
  encoding = encoding || 'raw';

  if (input !== undefined && encoding === 'utf8') {
    input = util.encodeUtf8(input);
  }

  return new util.ByteBuffer(input);
};
/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */


util.fillString = function (c, n) {
  var s = '';

  while (n > 0) {
    if (n & 1) {
      s += c;
    }

    n >>>= 1;

    if (n > 0) {
      c += c;
    }
  }

  return s;
};
/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */


util.xorBytes = function (s1, s2, n) {
  var s3 = '';
  var b = '';
  var t = '';
  var i = 0;
  var c = 0;

  for (; n > 0; --n, ++i) {
    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);

    if (c >= 10) {
      s3 += t;
      t = '';
      c = 0;
    }

    t += String.fromCharCode(b);
    ++c;
  }

  s3 += t;
  return s3;
};
/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */


util.hexToBytes = function (hex) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
  var rval = '';
  var i = 0;

  if (hex.length & 1 == 1) {
    // odd number of characters, convert first character alone
    i = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  } // convert 2 characters (1 byte) at a time


  for (; i < hex.length; i += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }

  return rval;
};
/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */


util.bytesToHex = function (bytes) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
  return util.createBuffer(bytes).toHex();
};
/**
 * Converts an 32-bit integer to 4-big-endian byte string.
 *
 * @param i the integer.
 *
 * @return the byte string.
 */


util.int32ToBytes = function (i) {
  return String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF);
}; // base64 characters, reverse mapping


var _base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var _base64Idx = [
/*43 -43 = 0*/

/*'+',  1,  2,  3,'/' */
62, -1, -1, -1, 63,
/*'0','1','2','3','4','5','6','7','8','9' */
52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
/*15, 16, 17,'=', 19, 20, 21 */
-1, -1, -1, 64, -1, -1, -1,
/*65 - 43 = 22*/

/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
/*91 - 43 = 48 */

/*48, 49, 50, 51, 52, 53 */
-1, -1, -1, -1, -1, -1,
/*97 - 43 = 54*/

/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51]; // base58 characters (Bitcoin alphabet)

var _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
/**
 * Base64 encodes a 'binary' encoded string of bytes.
 *
 * @param input the binary encoded string of bytes to base64-encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output.
 */

util.encode64 = function (input, maxline) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;

  while (i < input.length) {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++); // encode 4 character group

    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);

    if (isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }

  output += line;
  return output;
};
/**
 * Base64 decodes a string into a 'binary' encoded string of bytes.
 *
 * @param input the base64-encoded input.
 *
 * @return the binary encoded string.
 */


util.decode64 = function (input) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."
  // remove all non-base64 characters
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  var output = '';
  var enc1, enc2, enc3, enc4;
  var i = 0;

  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    output += String.fromCharCode(enc1 << 2 | enc2 >> 4);

    if (enc3 !== 64) {
      // decoded at least 2 bytes
      output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);

      if (enc4 !== 64) {
        // decoded 3 bytes
        output += String.fromCharCode((enc3 & 3) << 6 | enc4);
      }
    }
  }

  return output;
};
/**
 * Encodes the given string of characters (a standard JavaScript
 * string) as a binary encoded string where the bytes represent
 * a UTF-8 encoded string of characters. Non-ASCII characters will be
 * encoded as multiple bytes according to UTF-8.
 *
 * @param str a standard string of characters to encode.
 *
 * @return the binary encoded string.
 */


util.encodeUtf8 = function (str) {
  return unescape(encodeURIComponent(str));
};
/**
 * Decodes a binary encoded string that contains bytes that
 * represent a UTF-8 encoded string of characters -- into a
 * string of characters (a standard JavaScript string).
 *
 * @param str the binary encoded string to decode.
 *
 * @return the resulting standard string of characters.
 */


util.decodeUtf8 = function (str) {
  return decodeURIComponent(escape(str));
}; // binary encoding/decoding tools
// FIXME: Experimental. Do not use yet.


util.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: baseN.encode,
    decode: baseN.decode
  }
};
/**
 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param bytes the Uint8Array to encode.
 *
 * @return the binary-encoded string.
 */

util.binary.raw.encode = function (bytes) {
  return String.fromCharCode.apply(null, bytes);
};
/**
 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param str the binary-encoded string to decode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */


util.binary.raw.decode = function (str, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(str.length);
  }

  offset = offset || 0;
  var j = offset;

  for (var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }

  return output ? j - offset : out;
};
/**
 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
 * ByteBuffer as a string of hexadecimal characters.
 *
 * @param bytes the bytes to convert.
 *
 * @return the string of hexadecimal characters.
 */


util.binary.hex.encode = util.bytesToHex;
/**
 * Decodes a hex-encoded string to a Uint8Array.
 *
 * @param hex the hexadecimal string to convert.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */

util.binary.hex.decode = function (hex, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }

  offset = offset || 0;
  var i = 0,
      j = offset;

  if (hex.length & 1) {
    // odd number of characters, convert first character alone
    i = 1;
    out[j++] = parseInt(hex[0], 16);
  } // convert 2 characters (1 byte) at a time


  for (; i < hex.length; i += 2) {
    out[j++] = parseInt(hex.substr(i, 2), 16);
  }

  return output ? j - offset : out;
};
/**
 * Base64-encodes a Uint8Array.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output string.
 */


util.binary.base64.encode = function (input, maxline) {
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;

  while (i < input.byteLength) {
    chr1 = input[i++];
    chr2 = input[i++];
    chr3 = input[i++]; // encode 4 character group

    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);

    if (isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }

  output += line;
  return output;
};
/**
 * Decodes a base64-encoded string to a Uint8Array.
 *
 * @param input the base64-encoded input string.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */


util.binary.base64.decode = function (input, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  } // remove all non-base64 characters


  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i = 0,
      j = offset;

  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    out[j++] = enc1 << 2 | enc2 >> 4;

    if (enc3 !== 64) {
      // decoded at least 2 bytes
      out[j++] = (enc2 & 15) << 4 | enc3 >> 2;

      if (enc4 !== 64) {
        // decoded 3 bytes
        out[j++] = (enc3 & 3) << 6 | enc4;
      }
    }
  } // make sure result is the exact decoded length


  return output ? j - offset : out.subarray(0, j);
}; // add support for base58 encoding/decoding with Bitcoin alphabet


util.binary.base58.encode = function (input, maxline) {
  return util.binary.baseN.encode(input, _base58, maxline);
};

util.binary.base58.decode = function (input, maxline) {
  return util.binary.baseN.decode(input, _base58, maxline);
}; // text encoding/decoding tools
// FIXME: Experimental. Do not use yet.


util.text = {
  utf8: {},
  utf16: {}
};
/**
 * Encodes the given string as UTF-8 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */

util.text.utf8.encode = function (str, output, offset) {
  str = util.encodeUtf8(str);
  var out = output;

  if (!out) {
    out = new Uint8Array(str.length);
  }

  offset = offset || 0;
  var j = offset;

  for (var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }

  return output ? j - offset : out;
};
/**
 * Decodes the UTF-8 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */


util.text.utf8.decode = function (bytes) {
  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
};
/**
 * Encodes the given string as UTF-16 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */


util.text.utf16.encode = function (str, output, offset) {
  var out = output;

  if (!out) {
    out = new Uint8Array(str.length * 2);
  }

  var view = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j = offset;
  var k = offset;

  for (var i = 0; i < str.length; ++i) {
    view[k++] = str.charCodeAt(i);
    j += 2;
  }

  return output ? j - offset : out;
};
/**
 * Decodes the UTF-16 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */


util.text.utf16.decode = function (bytes) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
};
/**
 * Deflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true to return only raw deflate data, false to include zlib
 *          header and trailer.
 *
 * @return the deflated data as a string.
 */


util.deflate = function (api, bytes, raw) {
  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval); // strip zlib header and trailer if necessary

  if (raw) {
    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that
    // there is a 4-byte DICT (alder-32) block before the data if
    // its 5th bit is set
    var start = 2;
    var flg = bytes.charCodeAt(1);

    if (flg & 0x20) {
      start = 6;
    } // zlib trailer is 4 bytes of adler-32


    bytes = bytes.substring(start, bytes.length - 4);
  }

  return bytes;
};
/**
 * Inflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true if the incoming data has no zlib header or trailer and is
 *          raw DEFLATE data.
 *
 * @return the inflated data as a string, null on error.
 */


util.inflate = function (api, bytes, raw) {
  // TODO: add zlib header and trailer if necessary/possible
  var rval = api.inflate(util.encode64(bytes)).rval;
  return rval === null ? null : util.decode64(rval);
};
/**
 * Sets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param obj the storage object, null to remove.
 */


var _setStorageObject = function _setStorageObject(api, id, obj) {
  if (!api) {
    throw new Error('WebStorage not available.');
  }

  var rval;

  if (obj === null) {
    rval = api.removeItem(id);
  } else {
    // json-encode and base64-encode object
    obj = util.encode64(JSON.stringify(obj));
    rval = api.setItem(id, obj);
  } // handle potential flash error


  if (typeof rval !== 'undefined' && rval.rval !== true) {
    var error = new Error(rval.error.message);
    error.id = rval.error.id;
    error.name = rval.error.name;
    throw error;
  }
};
/**
 * Gets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 *
 * @return the storage object entry or null if none exists.
 */


var _getStorageObject = function _getStorageObject(api, id) {
  if (!api) {
    throw new Error('WebStorage not available.');
  } // get the existing entry


  var rval = api.getItem(id);
  /* Note: We check api.init because we can't do (api == localStorage)
    on IE because of "Class doesn't support Automation" exception. Only
    the flash api has an init method so this works too, but we need a
    better solution in the future. */
  // flash returns item wrapped in an object, handle special case

  if (api.init) {
    if (rval.rval === null) {
      if (rval.error) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      } // no error, but also no item


      rval = null;
    } else {
      rval = rval.rval;
    }
  } // handle decoding


  if (rval !== null) {
    // base64-decode and json-decode data
    rval = JSON.parse(util.decode64(rval));
  }

  return rval;
};
/**
 * Stores an item in local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 */


var _setItem = function _setItem(api, id, key, data) {
  // get storage object
  var obj = _getStorageObject(api, id);

  if (obj === null) {
    // create a new storage object
    obj = {};
  } // update key


  obj[key] = data; // set storage object

  _setStorageObject(api, id, obj);
};
/**
 * Gets an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 *
 * @return the item.
 */


var _getItem = function _getItem(api, id, key) {
  // get storage object
  var rval = _getStorageObject(api, id);

  if (rval !== null) {
    // return data at key
    rval = key in rval ? rval[key] : null;
  }

  return rval;
};
/**
 * Removes an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 */


var _removeItem = function _removeItem(api, id, key) {
  // get storage object
  var obj = _getStorageObject(api, id);

  if (obj !== null && key in obj) {
    // remove key
    delete obj[key]; // see if entry has no keys remaining

    var empty = true;

    for (var prop in obj) {
      empty = false;
      break;
    }

    if (empty) {
      // remove entry entirely if no keys are left
      obj = null;
    } // set storage object


    _setStorageObject(api, id, obj);
  }
};
/**
 * Clears the local disk storage identified by the given ID.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 */


var _clearItems = function _clearItems(api, id) {
  _setStorageObject(api, id, null);
};
/**
 * Calls a storage function.
 *
 * @param func the function to call.
 * @param args the arguments for the function.
 * @param location the location argument.
 *
 * @return the return value from the function.
 */


var _callStorageFunction = function _callStorageFunction(func, args, location) {
  var rval = null; // default storage types

  if (typeof location === 'undefined') {
    location = ['web', 'flash'];
  } // apply storage types in order of preference


  var type;
  var done = false;
  var exception = null;

  for (var idx in location) {
    type = location[idx];

    try {
      if (type === 'flash' || type === 'both') {
        if (args[0] === null) {
          throw new Error('Flash local storage not available.');
        }

        rval = func.apply(this, args);
        done = type === 'flash';
      }

      if (type === 'web' || type === 'both') {
        args[0] = localStorage;
        rval = func.apply(this, args);
        done = true;
      }
    } catch (ex) {
      exception = ex;
    }

    if (done) {
      break;
    }
  }

  if (!done) {
    throw exception;
  }

  return rval;
};
/**
 * Stores an item on local disk.
 *
 * The available types of local storage include 'flash', 'web', and 'both'.
 *
 * The type 'flash' refers to flash local storage (SharedObject). In order
 * to use flash local storage, the 'api' parameter must be valid. The type
 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
 * refers to storing using both 'flash' and 'web', not just one or the
 * other.
 *
 * The location array should list the storage types to use in order of
 * preference:
 *
 * ['flash']: flash only storage
 * ['web']: web only storage
 * ['both']: try to store in both
 * ['flash','web']: store in flash first, but if not available, 'web'
 * ['web','flash']: store in web first, but if not available, 'flash'
 *
 * The location array defaults to: ['web', 'flash']
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 * @param location an array with the preferred types of storage to use.
 */


util.setItem = function (api, id, key, data, location) {
  _callStorageFunction(_setItem, arguments, location);
};
/**
 * Gets an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 *
 * @return the item.
 */


util.getItem = function (api, id, key, location) {
  return _callStorageFunction(_getItem, arguments, location);
};
/**
 * Removes an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 */


util.removeItem = function (api, id, key, location) {
  _callStorageFunction(_removeItem, arguments, location);
};
/**
 * Clears the local disk storage identified by the given ID.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface if flash is available.
 * @param id the storage ID to use.
 * @param location an array with the preferred types of storage to use.
 */


util.clearItems = function (api, id, location) {
  _callStorageFunction(_clearItems, arguments, location);
};
/**
 * Parses the scheme, host, and port from an http(s) url.
 *
 * @param str the url string.
 *
 * @return the parsed url object or null if the url is invalid.
 */


util.parseUrl = function (str) {
  // FIXME: this regex looks a bit broken
  var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
  regex.lastIndex = 0;
  var m = regex.exec(str);
  var url = m === null ? null : {
    full: str,
    scheme: m[1],
    host: m[2],
    port: m[3],
    path: m[4]
  };

  if (url) {
    url.fullHost = url.host;

    if (url.port) {
      if (url.port !== 80 && url.scheme === 'http') {
        url.fullHost += ':' + url.port;
      } else if (url.port !== 443 && url.scheme === 'https') {
        url.fullHost += ':' + url.port;
      }
    } else if (url.scheme === 'http') {
      url.port = 80;
    } else if (url.scheme === 'https') {
      url.port = 443;
    }

    url.full = url.scheme + '://' + url.fullHost;
  }

  return url;
};
/* Storage for query variables */


var _queryVariables = null;
/**
 * Returns the window location query variables. Query is parsed on the first
 * call and the same object is returned on subsequent calls. The mapping
 * is from keys to an array of values. Parameters without values will have
 * an object key set but no value added to the value array. Values are
 * unescaped.
 *
 * ...?k1=v1&k2=v2:
 * {
 *   "k1": ["v1"],
 *   "k2": ["v2"]
 * }
 *
 * ...?k1=v1&k1=v2:
 * {
 *   "k1": ["v1", "v2"]
 * }
 *
 * ...?k1=v1&k2:
 * {
 *   "k1": ["v1"],
 *   "k2": []
 * }
 *
 * ...?k1=v1&k1:
 * {
 *   "k1": ["v1"]
 * }
 *
 * ...?k1&k1:
 * {
 *   "k1": []
 * }
 *
 * @param query the query string to parse (optional, default to cached
 *          results from parsing window location search query).
 *
 * @return object mapping keys to variables.
 */

util.getQueryVariables = function (query) {
  var parse = function parse(q) {
    var rval = {};
    var kvpairs = q.split('&');

    for (var i = 0; i < kvpairs.length; i++) {
      var pos = kvpairs[i].indexOf('=');
      var key;
      var val;

      if (pos > 0) {
        key = kvpairs[i].substring(0, pos);
        val = kvpairs[i].substring(pos + 1);
      } else {
        key = kvpairs[i];
        val = null;
      }

      if (!(key in rval)) {
        rval[key] = [];
      } // disallow overriding object prototype keys


      if (!(key in Object.prototype) && val !== null) {
        rval[key].push(unescape(val));
      }
    }

    return rval;
  };

  var rval;

  if (typeof query === 'undefined') {
    // set cached variables if needed
    if (_queryVariables === null) {
      if (typeof window !== 'undefined' && window.location && window.location.search) {
        // parse window search query
        _queryVariables = parse(window.location.search.substring(1));
      } else {
        // no query variables available
        _queryVariables = {};
      }
    }

    rval = _queryVariables;
  } else {
    // parse given query
    rval = parse(query);
  }

  return rval;
};
/**
 * Parses a fragment into a path and query. This method will take a URI
 * fragment and break it up as if it were the main URI. For example:
 *    /bar/baz?a=1&b=2
 * results in:
 *    {
 *       path: ["bar", "baz"],
 *       query: {"k1": ["v1"], "k2": ["v2"]}
 *    }
 *
 * @return object with a path array and query object.
 */


util.parseFragment = function (fragment) {
  // default to whole fragment
  var fp = fragment;
  var fq = ''; // split into path and query if possible at the first '?'

  var pos = fragment.indexOf('?');

  if (pos > 0) {
    fp = fragment.substring(0, pos);
    fq = fragment.substring(pos + 1);
  } // split path based on '/' and ignore first element if empty


  var path = fp.split('/');

  if (path.length > 0 && path[0] === '') {
    path.shift();
  } // convert query into object


  var query = fq === '' ? {} : util.getQueryVariables(fq);
  return {
    pathString: fp,
    queryString: fq,
    path: path,
    query: query
  };
};
/**
 * Makes a request out of a URI-like request string. This is intended to
 * be used where a fragment id (after a URI '#') is parsed as a URI with
 * path and query parts. The string should have a path beginning and
 * delimited by '/' and optional query parameters following a '?'. The
 * query should be a standard URL set of key value pairs delimited by
 * '&'. For backwards compatibility the initial '/' on the path is not
 * required. The request object has the following API, (fully described
 * in the method code):
 *    {
 *       path: <the path string part>.
 *       query: <the query string part>,
 *       getPath(i): get part or all of the split path array,
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */


util.makeRequest = function (reqString) {
  var frag = util.parseFragment(reqString);
  var req = {
    // full path string
    path: frag.pathString,
    // full query string
    query: frag.queryString,

    /**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */
    getPath: function getPath(i) {
      return typeof i === 'undefined' ? frag.path : frag.path[i];
    },

    /**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */
    getQuery: function getQuery(k, i) {
      var rval;

      if (typeof k === 'undefined') {
        rval = frag.query;
      } else {
        rval = frag.query[k];

        if (rval && typeof i !== 'undefined') {
          rval = rval[i];
        }
      }

      return rval;
    },
    getQueryLast: function getQueryLast(k, _default) {
      var rval;
      var vals = req.getQuery(k);

      if (vals) {
        rval = vals[vals.length - 1];
      } else {
        rval = _default;
      }

      return rval;
    }
  };
  return req;
};
/**
 * Makes a URI out of a path, an object with query parameters, and a
 * fragment. Uses jQuery.param() internally for query string creation.
 * If the path is an array, it will be joined with '/'.
 *
 * @param path string path or array of strings.
 * @param query object with query parameters. (optional)
 * @param fragment fragment string. (optional)
 *
 * @return string object with request parameters.
 */


util.makeLink = function (path, query, fragment) {
  // join path parts if needed
  path = jQuery.isArray(path) ? path.join('/') : path;
  var qstr = jQuery.param(query || {});
  fragment = fragment || '';
  return path + (qstr.length > 0 ? '?' + qstr : '') + (fragment.length > 0 ? '#' + fragment : '');
};
/**
 * Check if an object is empty.
 *
 * Taken from:
 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
 *
 * @param object the object to check.
 */


util.isEmpty = function (obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }

  return true;
};
/**
 * Format with simple printf-style interpolation.
 *
 * %%: literal '%'
 * %s,%o: convert next argument into a string.
 *
 * @param format the string to format.
 * @param ... arguments to interpolate into the format string.
 */


util.format = function (format) {
  var re = /%./g; // current match

  var match; // current part

  var part; // current arg index

  var argi = 0; // collected parts to recombine later

  var parts = []; // last index found

  var last = 0; // loop while matches remain

  while (match = re.exec(format)) {
    part = format.substring(last, re.lastIndex - 2); // don't add empty strings (ie, parts between %s%s)

    if (part.length > 0) {
      parts.push(part);
    }

    last = re.lastIndex; // switch on % code

    var code = match[0][1];

    switch (code) {
      case 's':
      case 'o':
        // check if enough arguments were given
        if (argi < arguments.length) {
          parts.push(arguments[argi++ + 1]);
        } else {
          parts.push('<?>');
        }

        break;
      // FIXME: do proper formating for numbers, etc
      //case 'f':
      //case 'd':

      case '%':
        parts.push('%');
        break;

      default:
        parts.push('<%' + code + '?>');
    }
  } // add trailing part of format string


  parts.push(format.substring(last));
  return parts.join('');
};
/**
 * Formats a number.
 *
 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
 */


util.formatNumber = function (number, decimals, dec_point, thousands_sep) {
  // http://kevin.vanzonneveld.net
  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +     bugfix by: Michael White (http://crestidg.com)
  // +     bugfix by: Benjamin Lupton
  // +     bugfix by: Allan Jensen (http://www.winternet.no)
  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // *     example 1: number_format(1234.5678, 2, '.', '');
  // *     returns 1: 1234.57
  var n = number,
      c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d = dec_point === undefined ? ',' : dec_point;
  var t = thousands_sep === undefined ? '.' : thousands_sep,
      s = n < 0 ? '-' : '';
  var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + '';
  var j = i.length > 3 ? i.length % 3 : 0;
  return s + (j ? i.substr(0, j) + t : '') + i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
};
/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */


util.formatSize = function (size) {
  if (size >= 1073741824) {
    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';
  } else if (size >= 1048576) {
    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
  } else if (size >= 1024) {
    size = util.formatNumber(size / 1024, 0) + ' KiB';
  } else {
    size = util.formatNumber(size, 0) + ' bytes';
  }

  return size;
};
/**
 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */


util.bytesFromIP = function (ip) {
  if (ip.indexOf('.') !== -1) {
    return util.bytesFromIPv4(ip);
  }

  if (ip.indexOf(':') !== -1) {
    return util.bytesFromIPv6(ip);
  }

  return null;
};
/**
 * Converts an IPv4 string representation into bytes (in network order).
 *
 * @param ip the IPv4 address to convert.
 *
 * @return the 4-byte address or null if the address can't be parsed.
 */


util.bytesFromIPv4 = function (ip) {
  ip = ip.split('.');

  if (ip.length !== 4) {
    return null;
  }

  var b = util.createBuffer();

  for (var i = 0; i < ip.length; ++i) {
    var num = parseInt(ip[i], 10);

    if (isNaN(num)) {
      return null;
    }

    b.putByte(num);
  }

  return b.getBytes();
};
/**
 * Converts an IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv6 address to convert.
 *
 * @return the 16-byte address or null if the address can't be parsed.
 */


util.bytesFromIPv6 = function (ip) {
  var blanks = 0;
  ip = ip.split(':').filter(function (e) {
    if (e.length === 0) ++blanks;
    return true;
  });
  var zeros = (8 - ip.length + blanks) * 2;
  var b = util.createBuffer();

  for (var i = 0; i < 8; ++i) {
    if (!ip[i] || ip[i].length === 0) {
      b.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }

    var bytes = util.hexToBytes(ip[i]);

    if (bytes.length < 2) {
      b.putByte(0);
    }

    b.putBytes(bytes);
  }

  return b.getBytes();
};
/**
 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
 * an IPv6 string representation. The bytes must be in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */


util.bytesToIP = function (bytes) {
  if (bytes.length === 4) {
    return util.bytesToIPv4(bytes);
  }

  if (bytes.length === 16) {
    return util.bytesToIPv6(bytes);
  }

  return null;
};
/**
 * Converts 4-bytes into an IPv4 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 string representation or null for an invalid # of bytes.
 */


util.bytesToIPv4 = function (bytes) {
  if (bytes.length !== 4) {
    return null;
  }

  var ip = [];

  for (var i = 0; i < bytes.length; ++i) {
    ip.push(bytes.charCodeAt(i));
  }

  return ip.join('.');
};
/**
 * Converts 16-bytes into an IPv16 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv16 string representation or null for an invalid # of bytes.
 */


util.bytesToIPv6 = function (bytes) {
  if (bytes.length !== 16) {
    return null;
  }

  var ip = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;

  for (var i = 0; i < bytes.length; i += 2) {
    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]); // canonicalize zero representation

    while (hex[0] === '0' && hex !== '0') {
      hex = hex.substr(1);
    }

    if (hex === '0') {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip.length;

      if (!last || idx !== last.end + 1) {
        zeroGroups.push({
          start: idx,
          end: idx
        });
      } else {
        last.end = idx;

        if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }

    ip.push(hex);
  }

  if (zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup]; // only shorten group of length > 0

    if (group.end - group.start > 0) {
      ip.splice(group.start, group.end - group.start + 1, '');

      if (group.start === 0) {
        ip.unshift('');
      }

      if (group.end === 7) {
        ip.push('');
      }
    }
  }

  return ip.join(':');
};
/**
 * Estimates the number of processes that can be run concurrently. If
 * creating Web Workers, keep in mind that the main JavaScript process needs
 * its own core.
 *
 * @param options the options to use:
 *          update true to force an update (not use the cached value).
 * @param callback(err, max) called once the operation completes.
 */


util.estimateCores = function (options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = options || {};

  if ('cores' in util && !options.update) {
    return callback(null, util.cores);
  }

  if (typeof navigator !== 'undefined' && 'hardwareConcurrency' in navigator && navigator.hardwareConcurrency > 0) {
    util.cores = navigator.hardwareConcurrency;
    return callback(null, util.cores);
  }

  if (typeof Worker === 'undefined') {
    // workers not available
    util.cores = 1;
    return callback(null, util.cores);
  }

  if (typeof Blob === 'undefined') {
    // can't estimate, default to 2
    util.cores = 2;
    return callback(null, util.cores);
  } // create worker concurrency estimation code as blob


  var blobUrl = URL.createObjectURL(new Blob(['(', function () {
    self.addEventListener('message', function (e) {
      // run worker for 4 ms
      var st = Date.now();
      var et = st + 4;

      while (Date.now() < et) {
        ;
      }

      self.postMessage({
        st: st,
        et: et
      });
    });
  }.toString(), ')()'], {
    type: 'application/javascript'
  })); // take 5 samples using 16 workers

  sample([], 5, 16);

  function sample(max, samples, numWorkers) {
    if (samples === 0) {
      // get overlap average
      var avg = Math.floor(max.reduce(function (avg, x) {
        return avg + x;
      }, 0) / max.length);
      util.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util.cores);
    }

    map(numWorkers, function (err, results) {
      max.push(reduce(numWorkers, results));
      sample(max, samples - 1, numWorkers);
    });
  }

  function map(numWorkers, callback) {
    var workers = [];
    var results = [];

    for (var i = 0; i < numWorkers; ++i) {
      var worker = new Worker(blobUrl);
      worker.addEventListener('message', function (e) {
        results.push(e.data);

        if (results.length === numWorkers) {
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].terminate();
          }

          callback(null, results);
        }
      });
      workers.push(worker);
    }

    for (var i = 0; i < numWorkers; ++i) {
      workers[i].postMessage(i);
    }
  }

  function reduce(numWorkers, results) {
    // find overlapping time windows
    var overlaps = [];

    for (var n = 0; n < numWorkers; ++n) {
      var r1 = results[n];
      var overlap = overlaps[n] = [];

      for (var i = 0; i < numWorkers; ++i) {
        if (n === i) {
          continue;
        }

        var r2 = results[i];

        if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
          overlap.push(i);
        }
      }
    } // get maximum overlaps ... don't include overlapping worker itself
    // as the main JS process was also being scheduled during the work and
    // would have to be subtracted from the estimate anyway


    return overlaps.reduce(function (max, overlap) {
      return Math.max(max, overlap.length);
    }, 0);
  }
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate)

},{"./baseN":136,"./forge":137,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27,"_process":142,"buffer":58,"timers":193}],142:[function(require,module,exports){
"use strict";

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

},{}],143:[function(require,module,exports){
"use strict";

/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var promise;
module.exports = typeof queueMicrotask === 'function' ? queueMicrotask.bind(globalThis) // reuse resolved promise, and allocate it lazily
: function (cb) {
  return (promise || (promise = Promise.resolve())).then(cb)["catch"](function (err) {
    return setTimeout(function () {
      throw err;
    }, 0);
  });
};

},{}],144:[function(require,module,exports){
/**
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var util = require('./util');

module.exports = /*#__PURE__*/function () {
  function AsyncAlgorithm() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$maxCallStackDept = _ref.maxCallStackDepth,
        maxCallStackDepth = _ref$maxCallStackDept === void 0 ? 500 : _ref$maxCallStackDept,
        _ref$maxTotalCallStac = _ref.maxTotalCallStackDepth,
        maxTotalCallStackDepth = _ref$maxTotalCallStac === void 0 ? 0xFFFFFFFF : _ref$maxTotalCallStac,
        _ref$timeSlice = _ref.timeSlice,
        timeSlice = _ref$timeSlice === void 0 ? 10 : _ref$timeSlice;

    (0, _classCallCheck2["default"])(this, AsyncAlgorithm);
    this.schedule = {};
    this.schedule.MAX_DEPTH = maxCallStackDepth;
    this.schedule.MAX_TOTAL_DEPTH = maxTotalCallStackDepth;
    this.schedule.depth = 0;
    this.schedule.totalDepth = 0;
    this.schedule.timeSlice = timeSlice;
  } // do some work in a time slice, but in serial


  (0, _createClass2["default"])(AsyncAlgorithm, [{
    key: "doWork",
    value: function doWork(fn, callback) {
      var schedule = this.schedule;

      if (schedule.totalDepth >= schedule.MAX_TOTAL_DEPTH) {
        return callback(new Error('Maximum total call stack depth exceeded; canonicalization aborting.'));
      }

      (function work() {
        if (schedule.depth === schedule.MAX_DEPTH) {
          // stack too deep, run on next tick
          schedule.depth = 0;
          schedule.running = false;
          return util.nextTick(work);
        } // if not yet running, force run


        var now = Date.now();

        if (!schedule.running) {
          schedule.start = Date.now();
          schedule.deadline = schedule.start + schedule.timeSlice;
        } // TODO: should also include an estimate of expectedWorkTime


        if (now < schedule.deadline) {
          schedule.running = true;
          schedule.depth++;
          schedule.totalDepth++;
          return fn(function (err, result) {
            schedule.depth--;
            schedule.totalDepth--;
            callback(err, result);
          });
        } // not enough time left in this slice, run after letting browser
        // do some other things


        schedule.depth = 0;
        schedule.running = false;
        util.setImmediate(work);
      })();
    } // asynchronously loop

  }, {
    key: "forEach",
    value: function forEach(iterable, fn, callback) {
      var self = this;

      var _iterator2;

      var idx = 0;
      var length;

      if (Array.isArray(iterable)) {
        length = iterable.length;

        _iterator2 = function iterator() {
          if (idx === length) {
            return false;
          }

          _iterator2.value = iterable[idx++];
          _iterator2.key = idx;
          return true;
        };
      } else {
        var keys = Object.keys(iterable);
        length = keys.length;

        _iterator2 = function _iterator() {
          if (idx === length) {
            return false;
          }

          _iterator2.key = keys[idx++];
          _iterator2.value = iterable[_iterator2.key];
          return true;
        };
      }

      (function iterate(err) {
        if (err) {
          return callback(err);
        }

        if (_iterator2()) {
          return self.doWork(function () {
            return fn(_iterator2.value, _iterator2.key, iterate);
          });
        }

        callback();
      })();
    } // asynchronous waterfall

  }, {
    key: "waterfall",
    value: function waterfall(fns, callback) {
      var self = this;
      self.forEach(fns, function (fn, idx, callback) {
        return self.doWork(fn, callback);
      }, callback);
    } // asynchronous while

  }, {
    key: "whilst",
    value: function whilst(condition, fn, callback) {
      var self = this;

      (function loop(err) {
        if (err) {
          return callback(err);
        }

        if (!condition()) {
          return callback();
        }

        self.doWork(fn, loop);
      })();
    }
  }]);
  return AsyncAlgorithm;
}();

},{"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],145:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var util = require('./util');

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a new IdentifierIssuer. A IdentifierIssuer issues unique
   * identifiers, keeping track of any previously issued identifiers.
   *
   * @param prefix the prefix to use ('<prefix><counter>').
   */
  function IdentifierIssuer(prefix) {
    (0, _classCallCheck2["default"])(this, IdentifierIssuer);
    this.prefix = prefix;
    this.counter = 0;
    this.existing = {};
  }
  /**
   * Copies this IdentifierIssuer.
   *
   * @return a copy of this IdentifierIssuer.
   */


  (0, _createClass2["default"])(IdentifierIssuer, [{
    key: "clone",
    value: function clone() {
      var copy = new IdentifierIssuer(this.prefix);
      copy.counter = this.counter;
      copy.existing = util.clone(this.existing);
      return copy;
    }
    /**
     * Gets the new identifier for the given old identifier, where if no old
     * identifier is given a new identifier will be generated.
     *
     * @param [old] the old identifier to get the new identifier for.
     *
     * @return the new identifier.
     */

  }, {
    key: "getId",
    value: function getId(old) {
      // return existing old identifier
      if (old && old in this.existing) {
        return this.existing[old];
      } // get next identifier


      var identifier = this.prefix + this.counter;
      this.counter += 1; // save mapping

      if (old) {
        this.existing[old] = identifier;
      }

      return identifier;
    }
    /**
     * Returns true if the given old identifer has already been assigned a new
     * identifier.
     *
     * @param old the old identifier to check.
     *
     * @return true if the old identifier has been assigned a new identifier,
     *   false if not.
     */

  }, {
    key: "hasId",
    value: function hasId(old) {
      return old in this.existing;
    }
  }]);
  return IdentifierIssuer;
}();

},{"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],146:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var forge = require('node-forge/lib/forge');

require('node-forge/lib/md');

require('node-forge/lib/sha1');

require('node-forge/lib/sha256');

module.exports = /*#__PURE__*/function () {
  /**
   * Creates a new MessageDigest.
   *
   * @param algorithm the algorithm to use.
   */
  function MessageDigest(algorithm) {
    (0, _classCallCheck2["default"])(this, MessageDigest);
    this.md = forge.md[algorithm].create();
  }

  (0, _createClass2["default"])(MessageDigest, [{
    key: "update",
    value: function update(msg) {
      this.md.update(msg, 'utf8');
    }
  }, {
    key: "digest",
    value: function digest() {
      return this.md.digest().toHex();
    }
  }]);
  return MessageDigest;
}();

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"node-forge/lib/forge":137,"node-forge/lib/md":138,"node-forge/lib/sha1":139,"node-forge/lib/sha256":140}],147:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict'; // eslint-disable-next-line no-unused-vars

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var TERMS = ['subject', 'predicate', 'object', 'graph'];
var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
var RDF_LANGSTRING = RDF + 'langString';
var XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string'; // build regexes

var REGEX = {};

(function () {
  var iri = '(?:<([^:]+:[^>]*)>)'; // https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL

  var PN_CHARS_BASE = 'A-Z' + 'a-z' + "\xC0-\xD6" + "\xD8-\xF6" + "\xF8-\u02FF" + "\u0370-\u037D" + "\u037F-\u1FFF" + "\u200C-\u200D" + "\u2070-\u218F" + "\u2C00-\u2FEF" + "\u3001-\uD7FF" + "\uF900-\uFDCF" + "\uFDF0-\uFFFD"; // TODO:
  //'\u10000-\uEFFFF';

  var PN_CHARS_U = PN_CHARS_BASE + '_';
  var PN_CHARS = PN_CHARS_U + '0-9' + '-' + "\xB7" + "\u0300-\u036F" + "\u203F-\u2040";
  var BLANK_NODE_LABEL = '(_:' + '(?:[' + PN_CHARS_U + '0-9])' + '(?:(?:[' + PN_CHARS + '.])*(?:[' + PN_CHARS + ']))?' + ')';
  var bnode = BLANK_NODE_LABEL;
  var plain = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"';
  var datatype = '(?:\\^\\^' + iri + ')';
  var language = '(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))';
  var literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';
  var ws = '[ \\t]+';
  var wso = '[ \\t]*'; // define quad part regexes

  var subject = '(?:' + iri + '|' + bnode + ')' + ws;
  var property = iri + ws;
  var object = '(?:' + iri + '|' + bnode + '|' + literal + ')' + wso;
  var graphName = '(?:\\.|(?:(?:' + iri + '|' + bnode + ')' + wso + '\\.))'; // end of line and empty regexes

  REGEX.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g;
  REGEX.empty = new RegExp('^' + wso + '$'); // full quad regex

  REGEX.quad = new RegExp('^' + wso + subject + property + object + graphName + wso + '$');
})();

module.exports = /*#__PURE__*/function () {
  function NQuads() {
    (0, _classCallCheck2["default"])(this, NQuads);
  }

  (0, _createClass2["default"])(NQuads, null, [{
    key: "parse",

    /**
     * Parses RDF in the form of N-Quads.
     *
     * @param input the N-Quads input to parse.
     *
     * @return an RDF dataset (an array of quads per http://rdf.js.org/).
     */
    value: function parse(input) {
      // build RDF dataset
      var dataset = [];
      var graphs = {}; // split N-Quad input into lines

      var lines = input.split(REGEX.eoln);
      var lineNumber = 0;

      var _iterator = _createForOfIteratorHelper(lines),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var line = _step.value;
          lineNumber++; // skip empty lines

          if (REGEX.empty.test(line)) {
            continue;
          } // parse quad


          var match = line.match(REGEX.quad);

          if (match === null) {
            throw new Error('N-Quads parse error on line ' + lineNumber + '.');
          } // create RDF quad


          var quad = {}; // get subject

          if (match[1] !== undefined) {
            quad.subject = {
              termType: 'NamedNode',
              value: match[1]
            };
          } else {
            quad.subject = {
              termType: 'BlankNode',
              value: match[2]
            };
          } // get predicate


          quad.predicate = {
            termType: 'NamedNode',
            value: match[3]
          }; // get object

          if (match[4] !== undefined) {
            quad.object = {
              termType: 'NamedNode',
              value: match[4]
            };
          } else if (match[5] !== undefined) {
            quad.object = {
              termType: 'BlankNode',
              value: match[5]
            };
          } else {
            quad.object = {
              termType: 'Literal',
              value: undefined,
              datatype: {
                termType: 'NamedNode'
              }
            };

            if (match[7] !== undefined) {
              quad.object.datatype.value = match[7];
            } else if (match[8] !== undefined) {
              quad.object.datatype.value = RDF_LANGSTRING;
              quad.object.language = match[8];
            } else {
              quad.object.datatype.value = XSD_STRING;
            }

            quad.object.value = _unescape(match[6]);
          } // get graph


          if (match[9] !== undefined) {
            quad.graph = {
              termType: 'NamedNode',
              value: match[9]
            };
          } else if (match[10] !== undefined) {
            quad.graph = {
              termType: 'BlankNode',
              value: match[10]
            };
          } else {
            quad.graph = {
              termType: 'DefaultGraph',
              value: ''
            };
          } // only add quad if it is unique in its graph


          if (!(quad.graph.value in graphs)) {
            graphs[quad.graph.value] = [quad];
            dataset.push(quad);
          } else {
            var unique = true;
            var quads = graphs[quad.graph.value];

            var _iterator2 = _createForOfIteratorHelper(quads),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var q = _step2.value;

                if (_compareTriples(q, quad)) {
                  unique = false;
                  break;
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            if (unique) {
              quads.push(quad);
              dataset.push(quad);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return dataset;
    }
    /**
     * Converts an RDF dataset to N-Quads.
     *
     * @param dataset (array of quads) the RDF dataset to convert.
     *
     * @return the N-Quads string.
     */

  }, {
    key: "serialize",
    value: function serialize(dataset) {
      if (!Array.isArray(dataset)) {
        dataset = NQuads.legacyDatasetToQuads(dataset);
      }

      var quads = [];

      var _iterator3 = _createForOfIteratorHelper(dataset),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var quad = _step3.value;
          quads.push(NQuads.serializeQuad(quad));
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return quads.sort().join('');
    }
    /**
     * Converts an RDF quad to an N-Quad string (a single quad).
     *
     * @param quad the RDF quad convert.
     *
     * @return the N-Quad string.
     */

  }, {
    key: "serializeQuad",
    value: function serializeQuad(quad) {
      var s = quad.subject;
      var p = quad.predicate;
      var o = quad.object;
      var g = quad.graph;
      var nquad = ''; // subject and predicate can only be NamedNode or BlankNode

      [s, p].forEach(function (term) {
        if (term.termType === 'NamedNode') {
          nquad += '<' + term.value + '>';
        } else {
          nquad += term.value;
        }

        nquad += ' ';
      }); // object is NamedNode, BlankNode, or Literal

      if (o.termType === 'NamedNode') {
        nquad += '<' + o.value + '>';
      } else if (o.termType === 'BlankNode') {
        nquad += o.value;
      } else {
        nquad += '"' + _escape(o.value) + '"';

        if (o.datatype.value === RDF_LANGSTRING) {
          if (o.language) {
            nquad += '@' + o.language;
          }
        } else if (o.datatype.value !== XSD_STRING) {
          nquad += '^^<' + o.datatype.value + '>';
        }
      } // graph can only be NamedNode or BlankNode (or DefaultGraph, but that
      // does not add to `nquad`)


      if (g.termType === 'NamedNode') {
        nquad += ' <' + g.value + '>';
      } else if (g.termType === 'BlankNode') {
        nquad += ' ' + g.value;
      }

      nquad += ' .\n';
      return nquad;
    }
    /**
     * Converts a legacy-formatted dataset to an array of quads dataset per
     * http://rdf.js.org/.
     *
     * @param dataset the legacy dataset to convert.
     *
     * @return the array of quads dataset.
     */

  }, {
    key: "legacyDatasetToQuads",
    value: function legacyDatasetToQuads(dataset) {
      var quads = [];
      var termTypeMap = {
        'blank node': 'BlankNode',
        IRI: 'NamedNode',
        literal: 'Literal'
      };

      var _loop = function _loop(graphName) {
        var triples = dataset[graphName];
        triples.forEach(function (triple) {
          var quad = {};

          for (var componentName in triple) {
            var oldComponent = triple[componentName];
            var newComponent = {
              termType: termTypeMap[oldComponent.type],
              value: oldComponent.value
            };

            if (newComponent.termType === 'Literal') {
              newComponent.datatype = {
                termType: 'NamedNode'
              };

              if ('datatype' in oldComponent) {
                newComponent.datatype.value = oldComponent.datatype;
              }

              if ('language' in oldComponent) {
                if (!('datatype' in oldComponent)) {
                  newComponent.datatype.value = RDF_LANGSTRING;
                }

                newComponent.language = oldComponent.language;
              } else if (!('datatype' in oldComponent)) {
                newComponent.datatype.value = XSD_STRING;
              }
            }

            quad[componentName] = newComponent;
          }

          if (graphName === '@default') {
            quad.graph = {
              termType: 'DefaultGraph',
              value: ''
            };
          } else {
            quad.graph = {
              termType: graphName.startsWith('_:') ? 'BlankNode' : 'NamedNode',
              value: graphName
            };
          }

          quads.push(quad);
        });
      };

      for (var graphName in dataset) {
        _loop(graphName);
      }

      return quads;
    }
  }]);
  return NQuads;
}();
/**
 * Compares two RDF triples for equality.
 *
 * @param t1 the first triple.
 * @param t2 the second triple.
 *
 * @return true if the triples are the same, false if not.
 */


function _compareTriples(t1, t2) {
  for (var k in t1) {
    if (t1[k].termType !== t2[k].termType || t1[k].value !== t2[k].value) {
      return false;
    }
  }

  if (t1.object.termType !== 'Literal') {
    return true;
  }

  return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.datatype.value === t2.object.datatype.value && t1.object.language === t2.object.language;
}

var _escapeRegex = /["\\\n\r]/g;
/**
 * Escape string to N-Quads literal
 */

function _escape(s) {
  return s.replace(_escapeRegex, function (match) {
    switch (match) {
      case '"':
        return '\\"';

      case '\\':
        return '\\\\';

      case '\n':
        return '\\n';

      case '\r':
        return '\\r';
    }
  });
}

var _unescapeRegex = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
/**
 * Unescape N-Quads literal to string
 */

function _unescape(s) {
  return s.replace(_unescapeRegex, function (match, code, u, U) {
    if (code) {
      switch (code) {
        case 't':
          return '\t';

        case 'b':
          return '\b';

        case 'n':
          return '\n';

        case 'r':
          return '\r';

        case 'f':
          return '\f';

        case '"':
          return '"';

        case '\'':
          return '\'';

        case '\\':
          return '\\';
      }
    }

    if (u) {
      return String.fromCharCode(parseInt(u, 16));
    }

    if (U) {
      // FIXME: support larger values
      throw new Error('Unsupported U escape');
    }
  });
}

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],148:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict'; // TODO: convert to ES6 iterable

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

module.exports = /*#__PURE__*/function () {
  /**
   * A Permutator iterates over all possible permutations of the given array
   * of elements.
   *
   * @param list the array of elements to iterate over.
   */
  function Permutator(list) {
    (0, _classCallCheck2["default"])(this, Permutator);
    // original array
    this.list = list.sort(); // indicates whether there are more permutations

    this.done = false; // directional info for permutation algorithm

    this.left = {};

    for (var i = 0; i < list.length; ++i) {
      this.left[list[i]] = true;
    }
  }
  /**
   * Returns true if there is another permutation.
   *
   * @return true if there is another permutation, false if not.
   */


  (0, _createClass2["default"])(Permutator, [{
    key: "hasNext",
    value: function hasNext() {
      return !this.done;
    }
    /**
     * Gets the next permutation. Call hasNext() to ensure there is another one
     * first.
     *
     * @return the next permutation.
     */

  }, {
    key: "next",
    value: function next() {
      // copy current permutation
      var rval = this.list.slice();
      /* Calculate the next permutation using the Steinhaus-Johnson-Trotter
       permutation algorithm. */
      // get largest mobile element k
      // (mobile: element is greater than the one it is looking at)

      var k = null;
      var pos = 0;
      var length = this.list.length;

      for (var i = 0; i < length; ++i) {
        var element = this.list[i];
        var left = this.left[element];

        if ((k === null || element > k) && (left && i > 0 && element > this.list[i - 1] || !left && i < length - 1 && element > this.list[i + 1])) {
          k = element;
          pos = i;
        }
      } // no more permutations


      if (k === null) {
        this.done = true;
      } else {
        // swap k and the element it is looking at
        var swap = this.left[k] ? pos - 1 : pos + 1;
        this.list[pos] = this.list[swap];
        this.list[swap] = k; // reverse the direction of all elements larger than k

        for (var _i = 0; _i < length; ++_i) {
          if (this.list[_i] > k) {
            this.left[this.list[_i]] = !this.left[this.list[_i]];
          }
        }
      }

      return rval;
    }
  }]);
  return Permutator;
}();

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],149:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var AsyncAlgorithm = require('./AsyncAlgorithm');

var IdentifierIssuer = require('./IdentifierIssuer');

var MessageDigest = require('./MessageDigest');

var Permutator = require('./Permutator');

var NQuads = require('./NQuads');

var util = require('./util');

var POSITIONS = {
  subject: 's',
  object: 'o',
  graph: 'g'
};

module.exports = /*#__PURE__*/function (_AsyncAlgorithm) {
  (0, _inherits2["default"])(URDNA2015, _AsyncAlgorithm);

  var _super = _createSuper(URDNA2015);

  function URDNA2015(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, URDNA2015);
    options = options || {};
    _this = _super.call(this, options);
    _this.name = 'URDNA2015';
    _this.options = Object.assign({}, options);
    _this.blankNodeInfo = {};
    _this.hashToBlankNodes = {};
    _this.canonicalIssuer = new IdentifierIssuer('_:c14n');
    _this.hashAlgorithm = 'sha256';
    _this.quads;
    return _this;
  } // 4.4) Normalization Algorithm


  (0, _createClass2["default"])(URDNA2015, [{
    key: "main",
    value: function main(dataset, callback) {
      var self = this;
      self.schedule.start = Date.now();
      var result;
      self.quads = dataset; // 1) Create the normalization state.
      // Note: Optimize by generating non-normalized blank node map concurrently.

      var nonNormalized = {};
      self.waterfall([function (callback) {
        // 2) For every quad in input dataset:
        self.forEach(dataset, function (quad, idx, callback) {
          // 2.1) For each blank node that occurs in the quad, add a reference
          // to the quad using the blank node identifier in the blank node to
          // quads map, creating a new entry if necessary.
          self.forEachComponent(quad, function (component) {
            if (component.termType !== 'BlankNode') {
              return;
            }

            var id = component.value;

            if (id in self.blankNodeInfo) {
              self.blankNodeInfo[id].quads.push(quad);
            } else {
              nonNormalized[id] = true;
              self.blankNodeInfo[id] = {
                quads: [quad]
              };
            }
          });
          callback();
        }, callback);
      }, function (callback) {
        // 3) Create a list of non-normalized blank node identifiers
        // non-normalized identifiers and populate it using the keys from the
        // blank node to quads map.
        // Note: We use a map here and it was generated during step 2.
        // 4) Initialize simple, a boolean flag, to true.
        var simple = true; // 5) While simple is true, issue canonical identifiers for blank nodes:

        self.whilst(function () {
          return simple;
        }, function (callback) {
          // 5.1) Set simple to false.
          simple = false; // 5.2) Clear hash to blank nodes map.

          self.hashToBlankNodes = {};
          self.waterfall([function (callback) {
            // 5.3) For each blank node identifier identifier in
            // non-normalized identifiers:
            self.forEach(nonNormalized, function (value, id, callback) {
              // 5.3.1) Create a hash, hash, according to the Hash First
              // Degree Quads algorithm.
              self.hashFirstDegreeQuads(id, function (err, hash) {
                if (err) {
                  return callback(err);
                } // 5.3.2) Add hash and identifier to hash to blank nodes map,
                // creating a new entry if necessary.


                if (hash in self.hashToBlankNodes) {
                  self.hashToBlankNodes[hash].push(id);
                } else {
                  self.hashToBlankNodes[hash] = [id];
                }

                callback();
              });
            }, callback);
          }, function (callback) {
            // 5.4) For each hash to identifier list mapping in hash to blank
            // nodes map, lexicographically-sorted by hash:
            var hashes = Object.keys(self.hashToBlankNodes).sort();
            self.forEach(hashes, function (hash, i, callback) {
              // 5.4.1) If the length of identifier list is greater than 1,
              // continue to the next mapping.
              var idList = self.hashToBlankNodes[hash];

              if (idList.length > 1) {
                return callback();
              } // 5.4.2) Use the Issue Identifier algorithm, passing canonical
              // issuer and the single blank node identifier in identifier
              // list, identifier, to issue a canonical replacement identifier
              // for identifier.
              // TODO: consider changing `getId` to `issue`


              var id = idList[0];
              self.canonicalIssuer.getId(id); // 5.4.3) Remove identifier from non-normalized identifiers.

              delete nonNormalized[id]; // 5.4.4) Remove hash from the hash to blank nodes map.

              delete self.hashToBlankNodes[hash]; // 5.4.5) Set simple to true.

              simple = true;
              callback();
            }, callback);
          }], callback);
        }, callback);
      }, function (callback) {
        // 6) For each hash to identifier list mapping in hash to blank nodes
        // map, lexicographically-sorted by hash:
        var hashes = Object.keys(self.hashToBlankNodes).sort();
        self.forEach(hashes, function (hash, idx, callback) {
          // 6.1) Create hash path list where each item will be a result of
          // running the Hash N-Degree Quads algorithm.
          var hashPathList = []; // 6.2) For each blank node identifier identifier in identifier list:

          var idList = self.hashToBlankNodes[hash];
          self.waterfall([function (callback) {
            self.forEach(idList, function (id, idx, callback) {
              // 6.2.1) If a canonical identifier has already been issued for
              // identifier, continue to the next identifier.
              if (self.canonicalIssuer.hasId(id)) {
                return callback();
              } // 6.2.2) Create temporary issuer, an identifier issuer
              // initialized with the prefix _:b.


              var issuer = new IdentifierIssuer('_:b'); // 6.2.3) Use the Issue Identifier algorithm, passing temporary
              // issuer and identifier, to issue a new temporary blank node
              // identifier for identifier.

              issuer.getId(id); // 6.2.4) Run the Hash N-Degree Quads algorithm, passing
              // temporary issuer, and append the result to the hash path
              // list.

              self.hashNDegreeQuads(id, issuer, function (err, result) {
                if (err) {
                  return callback(err);
                }

                hashPathList.push(result);
                callback();
              });
            }, callback);
          }, function (callback) {
            // 6.3) For each result in the hash path list,
            // lexicographically-sorted by the hash in result:
            // TODO: use `String.localeCompare`?
            hashPathList.sort(function (a, b) {
              return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
            });
            self.forEach(hashPathList, function (result, idx, callback) {
              // 6.3.1) For each blank node identifier, existing identifier,
              // that was issued a temporary identifier by identifier issuer
              // in result, issue a canonical identifier, in the same order,
              // using the Issue Identifier algorithm, passing canonical
              // issuer and existing identifier.
              for (var existing in result.issuer.existing) {
                self.canonicalIssuer.getId(existing);
              }

              callback();
            }, callback);
          }], callback);
        }, callback);
      }, function (callback) {
        /* Note: At this point all blank nodes in the set of RDF quads have been
        assigned canonical identifiers, which have been stored in the canonical
        issuer. Here each quad is updated by assigning each of its blank nodes
        its new identifier. */
        // 7) For each quad, quad, in input dataset:
        var normalized = [];
        self.waterfall([function (callback) {
          self.forEach(self.quads, function (quad, idx, callback) {
            // 7.1) Create a copy, quad copy, of quad and replace any existing
            // blank node identifiers using the canonical identifiers
            // previously issued by canonical issuer.
            // Note: We optimize away the copy here.
            self.forEachComponent(quad, function (component) {
              if (component.termType === 'BlankNode' && !component.value.startsWith(self.canonicalIssuer.prefix)) {
                component.value = self.canonicalIssuer.getId(component.value);
              }
            }); // 7.2) Add quad copy to the normalized dataset.

            normalized.push(NQuads.serializeQuad(quad));
            callback();
          }, callback);
        }, function (callback) {
          // sort normalized output
          normalized.sort(); // 8) Return the normalized dataset.

          result = normalized.join('');
          return callback();
        }], callback);
      }], function (err) {
        return callback(err, result);
      });
    } // 4.6) Hash First Degree Quads

  }, {
    key: "hashFirstDegreeQuads",
    value: function hashFirstDegreeQuads(id, callback) {
      var self = this; // return cached hash

      var info = self.blankNodeInfo[id];

      if ('hash' in info) {
        return callback(null, info.hash);
      } // 1) Initialize nquads to an empty list. It will be used to store quads in
      // N-Quads format.


      var nquads = []; // 2) Get the list of quads quads associated with the reference blank node
      // identifier in the blank node to quads map.

      var quads = info.quads; // 3) For each quad quad in quads:

      self.forEach(quads, function (quad, idx, callback) {
        // 3.1) Serialize the quad in N-Quads format with the following special
        // rule:
        // 3.1.1) If any component in quad is an blank node, then serialize it
        // using a special identifier as follows:
        var copy = {
          predicate: quad.predicate
        };
        self.forEachComponent(quad, function (component, key) {
          // 3.1.2) If the blank node's existing blank node identifier matches the
          // reference blank node identifier then use the blank node identifier
          // _:a, otherwise, use the blank node identifier _:z.
          copy[key] = self.modifyFirstDegreeComponent(id, component, key);
        });
        nquads.push(NQuads.serializeQuad(copy));
        callback();
      }, function (err) {
        if (err) {
          return callback(err);
        } // 4) Sort nquads in lexicographical order.


        nquads.sort(); // 5) Return the hash that results from passing the sorted, joined nquads
        // through the hash algorithm.

        var md = new MessageDigest(self.hashAlgorithm);

        for (var i = 0; i < nquads.length; ++i) {
          md.update(nquads[i]);
        } // TODO: represent as byte buffer instead to cut memory usage in half


        info.hash = md.digest();
        callback(null, info.hash);
      });
    } // 4.7) Hash Related Blank Node

  }, {
    key: "hashRelatedBlankNode",
    value: function hashRelatedBlankNode(related, quad, issuer, position, callback) {
      var self = this; // 1) Set the identifier to use for related, preferring first the canonical
      // identifier for related if issued, second the identifier issued by issuer
      // if issued, and last, if necessary, the result of the Hash First Degree
      // Quads algorithm, passing related.

      var id;
      self.waterfall([function (callback) {
        if (self.canonicalIssuer.hasId(related)) {
          id = self.canonicalIssuer.getId(related);
          return callback();
        }

        if (issuer.hasId(related)) {
          id = issuer.getId(related);
          return callback();
        }

        self.hashFirstDegreeQuads(related, function (err, hash) {
          if (err) {
            return callback(err);
          }

          id = hash;
          callback();
        });
      }], function (err) {
        if (err) {
          return callback(err);
        } // 2) Initialize a string input to the value of position.
        // Note: We use a hash object instead.


        var md = new MessageDigest(self.hashAlgorithm);
        md.update(position); // 3) If position is not g, append <, the value of the predicate in quad,
        // and > to input.

        if (position !== 'g') {
          md.update(self.getRelatedPredicate(quad));
        } // 4) Append identifier to input.


        md.update(id); // 5) Return the hash that results from passing input through the hash
        // algorithm.
        // TODO: represent as byte buffer instead to cut memory usage in half

        return callback(null, md.digest());
      });
    } // 4.8) Hash N-Degree Quads

  }, {
    key: "hashNDegreeQuads",
    value: function hashNDegreeQuads(id, issuer, callback) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.
      // Note: 2) and 3) handled within `createHashToRelated`

      var hashToRelated;
      var md = new MessageDigest(self.hashAlgorithm);
      self.waterfall([function (callback) {
        return self.createHashToRelated(id, issuer, function (err, result) {
          if (err) {
            return callback(err);
          }

          hashToRelated = result;
          callback();
        });
      }, function (callback) {
        // 4) Create an empty string, data to hash.
        // Note: We created a hash object `md` above instead.
        // 5) For each related hash to blank node list mapping in hash to
        // related blank nodes map, sorted lexicographically by related hash:
        var hashes = Object.keys(hashToRelated).sort();
        self.forEach(hashes, function (hash, idx, callback) {
          // 5.1) Append the related hash to the data to hash.
          md.update(hash); // 5.2) Create a string chosen path.

          var chosenPath = ''; // 5.3) Create an unset chosen issuer variable.

          var chosenIssuer; // 5.4) For each permutation of blank node list:

          var permutator = new Permutator(hashToRelated[hash]);
          self.whilst(function () {
            return permutator.hasNext();
          }, function (nextPermutation) {
            var permutation = permutator.next(); // 5.4.1) Create a copy of issuer, issuer copy.

            var issuerCopy = issuer.clone(); // 5.4.2) Create a string path.

            var path = ''; // 5.4.3) Create a recursion list, to store blank node identifiers
            // that must be recursively processed by this algorithm.

            var recursionList = [];
            self.waterfall([function (callback) {
              // 5.4.4) For each related in permutation:
              self.forEach(permutation, function (related, idx, callback) {
                // 5.4.4.1) If a canonical identifier has been issued for
                // related, append it to path.
                if (self.canonicalIssuer.hasId(related)) {
                  path += self.canonicalIssuer.getId(related);
                } else {
                  // 5.4.4.2) Otherwise:
                  // 5.4.4.2.1) If issuer copy has not issued an identifier
                  // for related, append related to recursion list.
                  if (!issuerCopy.hasId(related)) {
                    recursionList.push(related);
                  } // 5.4.4.2.2) Use the Issue Identifier algorithm, passing
                  // issuer copy and related and append the result to path.


                  path += issuerCopy.getId(related);
                } // 5.4.4.3) If chosen path is not empty and the length of path
                // is greater than or equal to the length of chosen path and
                // path is lexicographically greater than chosen path, then
                // skip to the next permutation.
                // Note: Comparing path length to chosen path length can be
                // optimized away; only compare lexicographically.


                if (chosenPath.length !== 0 && path > chosenPath) {
                  // FIXME: may cause inaccurate total depth calculation
                  return nextPermutation();
                }

                callback();
              }, callback);
            }, function (callback) {
              // 5.4.5) For each related in recursion list:
              self.forEach(recursionList, function (related, idx, callback) {
                // 5.4.5.1) Set result to the result of recursively executing
                // the Hash N-Degree Quads algorithm, passing related for
                // identifier and issuer copy for path identifier issuer.
                self.hashNDegreeQuads(related, issuerCopy, function (err, result) {
                  if (err) {
                    return callback(err);
                  } // 5.4.5.2) Use the Issue Identifier algorithm, passing
                  // issuer copy and related and append the result to path.


                  path += issuerCopy.getId(related); // 5.4.5.3) Append <, the hash in result, and > to path.

                  path += '<' + result.hash + '>'; // 5.4.5.4) Set issuer copy to the identifier issuer in
                  // result.

                  issuerCopy = result.issuer; // 5.4.5.5) If chosen path is not empty and the length of
                  // path is greater than or equal to the length of chosen
                  // path and path is lexicographically greater than chosen
                  // path, then skip to the next permutation.
                  // Note: Comparing path length to chosen path length can be
                  // optimized away; only compare lexicographically.

                  if (chosenPath.length !== 0 && path > chosenPath) {
                    // FIXME: may cause inaccurate total depth calculation
                    return nextPermutation();
                  }

                  callback();
                });
              }, callback);
            }, function (callback) {
              // 5.4.6) If chosen path is empty or path is lexicographically
              // less than chosen path, set chosen path to path and chosen
              // issuer to issuer copy.
              if (chosenPath.length === 0 || path < chosenPath) {
                chosenPath = path;
                chosenIssuer = issuerCopy;
              }

              callback();
            }], nextPermutation);
          }, function (err) {
            if (err) {
              return callback(err);
            } // 5.5) Append chosen path to data to hash.


            md.update(chosenPath); // 5.6) Replace issuer, by reference, with chosen issuer.

            issuer = chosenIssuer;
            callback();
          });
        }, callback);
      }], function (err) {
        // 6) Return issuer and the hash that results from passing data to hash
        // through the hash algorithm.
        callback(err, {
          hash: md.digest(),
          issuer: issuer
        });
      });
    } // helper for modifying component during Hash First Degree Quads

  }, {
    key: "modifyFirstDegreeComponent",
    value: function modifyFirstDegreeComponent(id, component) {
      if (component.termType !== 'BlankNode') {
        return component;
      }

      component = util.clone(component);
      component.value = component.value === id ? '_:a' : '_:z';
      return component;
    } // helper for getting a related predicate

  }, {
    key: "getRelatedPredicate",
    value: function getRelatedPredicate(quad) {
      return '<' + quad.predicate.value + '>';
    } // helper for creating hash to related blank nodes map

  }, {
    key: "createHashToRelated",
    value: function createHashToRelated(id, issuer, callback) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.

      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to
      // quads map for the key identifier.

      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:

      self.forEach(quads, function (quad, idx, callback) {
        // 3.1) For each component in quad, if component is the subject, object,
        // and graph name and it is a blank node that is not identified by
        // identifier:
        self.forEach(quad, function (component, key, callback) {
          if (key === 'predicate' || !(component.termType === 'BlankNode' && component.value !== id)) {
            return callback();
          } // 3.1.1) Set hash to the result of the Hash Related Blank Node
          // algorithm, passing the blank node identifier for component as
          // related, quad, path identifier issuer as issuer, and position as
          // either s, o, or g based on whether component is a subject, object,
          // graph name, respectively.


          var related = component.value;
          var position = POSITIONS[key];
          self.hashRelatedBlankNode(related, quad, issuer, position, function (err, hash) {
            if (err) {
              return callback(err);
            } // 3.1.2) Add a mapping of hash to the blank node identifier for
            // component to hash to related blank nodes map, adding an entry as
            // necessary.


            if (hash in hashToRelated) {
              hashToRelated[hash].push(related);
            } else {
              hashToRelated[hash] = [related];
            }

            callback();
          });
        }, callback);
      }, function (err) {
        return callback(err, hashToRelated);
      });
    } // helper that iterates over quad components (skips predicate)

  }, {
    key: "forEachComponent",
    value: function forEachComponent(quad, op) {
      for (var key in quad) {
        // skip `predicate`
        if (key === 'predicate') {
          continue;
        }

        op(quad[key], key, quad);
      }
    }
  }]);
  return URDNA2015;
}(AsyncAlgorithm);

},{"./AsyncAlgorithm":144,"./IdentifierIssuer":145,"./MessageDigest":146,"./NQuads":147,"./Permutator":148,"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22}],150:[function(require,module,exports){
/*
 * Copyright (c) 2016 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var IdentifierIssuer = require('./IdentifierIssuer');

var MessageDigest = require('./MessageDigest');

var Permutator = require('./Permutator');

var NQuads = require('./NQuads');

var util = require('./util');

var POSITIONS = {
  subject: 's',
  object: 'o',
  graph: 'g'
};

module.exports = /*#__PURE__*/function () {
  function URDNA2015Sync() {
    (0, _classCallCheck2["default"])(this, URDNA2015Sync);
    this.name = 'URDNA2015';
    this.blankNodeInfo = {};
    this.hashToBlankNodes = {};
    this.canonicalIssuer = new IdentifierIssuer('_:c14n');
    this.hashAlgorithm = 'sha256';
    this.quads;
  } // 4.4) Normalization Algorithm


  (0, _createClass2["default"])(URDNA2015Sync, [{
    key: "main",
    value: function main(dataset) {
      var self = this;
      self.quads = dataset; // 1) Create the normalization state.
      // Note: Optimize by generating non-normalized blank node map concurrently.

      var nonNormalized = {}; // 2) For every quad in input dataset:

      var _iterator = _createForOfIteratorHelper(dataset),
          _step;

      try {
        var _loop = function _loop() {
          var quad = _step.value;
          // 2.1) For each blank node that occurs in the quad, add a reference
          // to the quad using the blank node identifier in the blank node to
          // quads map, creating a new entry if necessary.
          self.forEachComponent(quad, function (component) {
            if (component.termType !== 'BlankNode') {
              return;
            }

            var id = component.value;

            if (id in self.blankNodeInfo) {
              self.blankNodeInfo[id].quads.push(quad);
            } else {
              nonNormalized[id] = true;
              self.blankNodeInfo[id] = {
                quads: [quad]
              };
            }
          });
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        } // 3) Create a list of non-normalized blank node identifiers
        // non-normalized identifiers and populate it using the keys from the
        // blank node to quads map.
        // Note: We use a map here and it was generated during step 2.
        // 4) Initialize simple, a boolean flag, to true.

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var simple = true; // 5) While simple is true, issue canonical identifiers for blank nodes:

      while (simple) {
        // 5.1) Set simple to false.
        simple = false; // 5.2) Clear hash to blank nodes map.

        self.hashToBlankNodes = {}; // 5.3) For each blank node identifier identifier in non-normalized
        // identifiers:

        for (var id in nonNormalized) {
          // 5.3.1) Create a hash, hash, according to the Hash First Degree
          // Quads algorithm.
          var hash = self.hashFirstDegreeQuads(id); // 5.3.2) Add hash and identifier to hash to blank nodes map,
          // creating a new entry if necessary.

          if (hash in self.hashToBlankNodes) {
            self.hashToBlankNodes[hash].push(id);
          } else {
            self.hashToBlankNodes[hash] = [id];
          }
        } // 5.4) For each hash to identifier list mapping in hash to blank
        // nodes map, lexicographically-sorted by hash:


        var _hashes = Object.keys(self.hashToBlankNodes).sort();

        for (var i = 0; i < _hashes.length; ++i) {
          // 5.4.1) If the length of identifier list is greater than 1,
          // continue to the next mapping.
          var _hash = _hashes[i];
          var idList = self.hashToBlankNodes[_hash];

          if (idList.length > 1) {
            continue;
          } // 5.4.2) Use the Issue Identifier algorithm, passing canonical
          // issuer and the single blank node identifier in identifier
          // list, identifier, to issue a canonical replacement identifier
          // for identifier.
          // TODO: consider changing `getId` to `issue`


          var _id = idList[0];
          self.canonicalIssuer.getId(_id); // 5.4.3) Remove identifier from non-normalized identifiers.

          delete nonNormalized[_id]; // 5.4.4) Remove hash from the hash to blank nodes map.

          delete self.hashToBlankNodes[_hash]; // 5.4.5) Set simple to true.

          simple = true;
        }
      } // 6) For each hash to identifier list mapping in hash to blank nodes map,
      // lexicographically-sorted by hash:


      var hashes = Object.keys(self.hashToBlankNodes).sort();

      for (var _i = 0; _i < hashes.length; ++_i) {
        // 6.1) Create hash path list where each item will be a result of
        // running the Hash N-Degree Quads algorithm.
        var hashPathList = []; // 6.2) For each blank node identifier identifier in identifier list:

        var _hash2 = hashes[_i];
        var _idList = self.hashToBlankNodes[_hash2];

        for (var j = 0; j < _idList.length; ++j) {
          // 6.2.1) If a canonical identifier has already been issued for
          // identifier, continue to the next identifier.
          var _id2 = _idList[j];

          if (self.canonicalIssuer.hasId(_id2)) {
            continue;
          } // 6.2.2) Create temporary issuer, an identifier issuer
          // initialized with the prefix _:b.


          var issuer = new IdentifierIssuer('_:b'); // 6.2.3) Use the Issue Identifier algorithm, passing temporary
          // issuer and identifier, to issue a new temporary blank node
          // identifier for identifier.

          issuer.getId(_id2); // 6.2.4) Run the Hash N-Degree Quads algorithm, passing
          // temporary issuer, and append the result to the hash path list.

          var result = self.hashNDegreeQuads(_id2, issuer);
          hashPathList.push(result);
        } // 6.3) For each result in the hash path list,
        // lexicographically-sorted by the hash in result:
        // TODO: use `String.localeCompare`?


        hashPathList.sort(function (a, b) {
          return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
        });

        for (var _j = 0; _j < hashPathList.length; ++_j) {
          // 6.3.1) For each blank node identifier, existing identifier,
          // that was issued a temporary identifier by identifier issuer
          // in result, issue a canonical identifier, in the same order,
          // using the Issue Identifier algorithm, passing canonical
          // issuer and existing identifier.
          var _result = hashPathList[_j];

          for (var existing in _result.issuer.existing) {
            self.canonicalIssuer.getId(existing);
          }
        }
      }
      /* Note: At this point all blank nodes in the set of RDF quads have been
      assigned canonical identifiers, which have been stored in the canonical
      issuer. Here each quad is updated by assigning each of its blank nodes
      its new identifier. */
      // 7) For each quad, quad, in input dataset:


      var normalized = [];

      for (var _i2 = 0; _i2 < self.quads.length; ++_i2) {
        // 7.1) Create a copy, quad copy, of quad and replace any existing
        // blank node identifiers using the canonical identifiers
        // previously issued by canonical issuer.
        // Note: We optimize away the copy here.
        var quad = self.quads[_i2];
        self.forEachComponent(quad, function (component) {
          if (component.termType === 'BlankNode' && !component.value.startsWith(self.canonicalIssuer.prefix)) {
            component.value = self.canonicalIssuer.getId(component.value);
          }
        }); // 7.2) Add quad copy to the normalized dataset.

        normalized.push(NQuads.serializeQuad(quad));
      } // sort normalized output


      normalized.sort(); // 8) Return the normalized dataset.

      return normalized.join('');
    } // 4.6) Hash First Degree Quads

  }, {
    key: "hashFirstDegreeQuads",
    value: function hashFirstDegreeQuads(id) {
      var self = this; // return cached hash

      var info = self.blankNodeInfo[id];

      if ('hash' in info) {
        return info.hash;
      } // 1) Initialize nquads to an empty list. It will be used to store quads in
      // N-Quads format.


      var nquads = []; // 2) Get the list of quads `quads` associated with the reference blank node
      // identifier in the blank node to quads map.

      var quads = info.quads; // 3) For each quad `quad` in `quads`:

      var _loop2 = function _loop2(i) {
        var quad = quads[i]; // 3.1) Serialize the quad in N-Quads format with the following special
        // rule:
        // 3.1.1) If any component in quad is an blank node, then serialize it
        // using a special identifier as follows:

        var copy = {
          predicate: quad.predicate
        };
        self.forEachComponent(quad, function (component, key) {
          // 3.1.2) If the blank node's existing blank node identifier matches
          // the reference blank node identifier then use the blank node
          // identifier _:a, otherwise, use the blank node identifier _:z.
          copy[key] = self.modifyFirstDegreeComponent(id, component, key);
        });
        nquads.push(NQuads.serializeQuad(copy));
      };

      for (var i = 0; i < quads.length; ++i) {
        _loop2(i);
      } // 4) Sort nquads in lexicographical order.


      nquads.sort(); // 5) Return the hash that results from passing the sorted, joined nquads
      // through the hash algorithm.

      var md = new MessageDigest(self.hashAlgorithm);

      for (var _i3 = 0; _i3 < nquads.length; ++_i3) {
        md.update(nquads[_i3]);
      } // TODO: represent as byte buffer instead to cut memory usage in half


      info.hash = md.digest();
      return info.hash;
    } // 4.7) Hash Related Blank Node

  }, {
    key: "hashRelatedBlankNode",
    value: function hashRelatedBlankNode(related, quad, issuer, position) {
      var self = this; // 1) Set the identifier to use for related, preferring first the canonical
      // identifier for related if issued, second the identifier issued by issuer
      // if issued, and last, if necessary, the result of the Hash First Degree
      // Quads algorithm, passing related.

      var id;

      if (self.canonicalIssuer.hasId(related)) {
        id = self.canonicalIssuer.getId(related);
      } else if (issuer.hasId(related)) {
        id = issuer.getId(related);
      } else {
        id = self.hashFirstDegreeQuads(related);
      } // 2) Initialize a string input to the value of position.
      // Note: We use a hash object instead.


      var md = new MessageDigest(self.hashAlgorithm);
      md.update(position); // 3) If position is not g, append <, the value of the predicate in quad,
      // and > to input.

      if (position !== 'g') {
        md.update(self.getRelatedPredicate(quad));
      } // 4) Append identifier to input.


      md.update(id); // 5) Return the hash that results from passing input through the hash
      // algorithm.
      // TODO: represent as byte buffer instead to cut memory usage in half

      return md.digest();
    } // 4.8) Hash N-Degree Quads

  }, {
    key: "hashNDegreeQuads",
    value: function hashNDegreeQuads(id, issuer) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.
      // Note: 2) and 3) handled within `createHashToRelated`

      var md = new MessageDigest(self.hashAlgorithm);
      var hashToRelated = self.createHashToRelated(id, issuer); // 4) Create an empty string, data to hash.
      // Note: We created a hash object `md` above instead.
      // 5) For each related hash to blank node list mapping in hash to related
      // blank nodes map, sorted lexicographically by related hash:

      var hashes = Object.keys(hashToRelated).sort();

      for (var i = 0; i < hashes.length; ++i) {
        // 5.1) Append the related hash to the data to hash.
        var hash = hashes[i];
        md.update(hash); // 5.2) Create a string chosen path.

        var chosenPath = ''; // 5.3) Create an unset chosen issuer variable.

        var chosenIssuer = void 0; // 5.4) For each permutation of blank node list:

        var permutator = new Permutator(hashToRelated[hash]);

        while (permutator.hasNext()) {
          var permutation = permutator.next(); // 5.4.1) Create a copy of issuer, issuer copy.

          var issuerCopy = issuer.clone(); // 5.4.2) Create a string path.

          var path = ''; // 5.4.3) Create a recursion list, to store blank node identifiers
          // that must be recursively processed by this algorithm.

          var recursionList = []; // 5.4.4) For each related in permutation:

          var nextPermutation = false;

          for (var j = 0; j < permutation.length; ++j) {
            // 5.4.4.1) If a canonical identifier has been issued for
            // related, append it to path.
            var related = permutation[j];

            if (self.canonicalIssuer.hasId(related)) {
              path += self.canonicalIssuer.getId(related);
            } else {
              // 5.4.4.2) Otherwise:
              // 5.4.4.2.1) If issuer copy has not issued an identifier for
              // related, append related to recursion list.
              if (!issuerCopy.hasId(related)) {
                recursionList.push(related);
              } // 5.4.4.2.2) Use the Issue Identifier algorithm, passing
              // issuer copy and related and append the result to path.


              path += issuerCopy.getId(related);
            } // 5.4.4.3) If chosen path is not empty and the length of path
            // is greater than or equal to the length of chosen path and
            // path is lexicographically greater than chosen path, then
            // skip to the next permutation.
            // Note: Comparing path length to chosen path length can be optimized
            // away; only compare lexicographically.


            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }

          if (nextPermutation) {
            continue;
          } // 5.4.5) For each related in recursion list:


          for (var _j2 = 0; _j2 < recursionList.length; ++_j2) {
            // 5.4.5.1) Set result to the result of recursively executing
            // the Hash N-Degree Quads algorithm, passing related for
            // identifier and issuer copy for path identifier issuer.
            var _related = recursionList[_j2];
            var result = self.hashNDegreeQuads(_related, issuerCopy); // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer
            // copy and related and append the result to path.

            path += issuerCopy.getId(_related); // 5.4.5.3) Append <, the hash in result, and > to path.

            path += '<' + result.hash + '>'; // 5.4.5.4) Set issuer copy to the identifier issuer in
            // result.

            issuerCopy = result.issuer; // 5.4.5.5) If chosen path is not empty and the length of path
            // is greater than or equal to the length of chosen path and
            // path is lexicographically greater than chosen path, then
            // skip to the next permutation.
            // Note: Comparing path length to chosen path length can be optimized
            // away; only compare lexicographically.

            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }

          if (nextPermutation) {
            continue;
          } // 5.4.6) If chosen path is empty or path is lexicographically
          // less than chosen path, set chosen path to path and chosen
          // issuer to issuer copy.


          if (chosenPath.length === 0 || path < chosenPath) {
            chosenPath = path;
            chosenIssuer = issuerCopy;
          }
        } // 5.5) Append chosen path to data to hash.


        md.update(chosenPath); // 5.6) Replace issuer, by reference, with chosen issuer.

        issuer = chosenIssuer;
      } // 6) Return issuer and the hash that results from passing data to hash
      // through the hash algorithm.


      return {
        hash: md.digest(),
        issuer: issuer
      };
    } // helper for modifying component during Hash First Degree Quads

  }, {
    key: "modifyFirstDegreeComponent",
    value: function modifyFirstDegreeComponent(id, component) {
      if (component.termType !== 'BlankNode') {
        return component;
      }

      component = util.clone(component);
      component.value = component.value === id ? '_:a' : '_:z';
      return component;
    } // helper for getting a related predicate

  }, {
    key: "getRelatedPredicate",
    value: function getRelatedPredicate(quad) {
      return '<' + quad.predicate.value + '>';
    } // helper for creating hash to related blank nodes map

  }, {
    key: "createHashToRelated",
    value: function createHashToRelated(id, issuer) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.

      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to
      // quads map for the key identifier.

      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:

      for (var i = 0; i < quads.length; ++i) {
        // 3.1) For each component in quad, if component is the subject, object,
        // and graph name and it is a blank node that is not identified by
        // identifier:
        var quad = quads[i];

        for (var key in quad) {
          var component = quad[key];

          if (key === 'predicate' || !(component.termType === 'BlankNode' && component.value !== id)) {
            continue;
          } // 3.1.1) Set hash to the result of the Hash Related Blank Node
          // algorithm, passing the blank node identifier for component as
          // related, quad, path identifier issuer as issuer, and position as
          // either s, o, or g based on whether component is a subject, object,
          // graph name, respectively.


          var related = component.value;
          var position = POSITIONS[key];
          var hash = self.hashRelatedBlankNode(related, quad, issuer, position); // 3.1.2) Add a mapping of hash to the blank node identifier for
          // component to hash to related blank nodes map, adding an entry as
          // necessary.

          if (hash in hashToRelated) {
            hashToRelated[hash].push(related);
          } else {
            hashToRelated[hash] = [related];
          }
        }
      }

      return hashToRelated;
    } // helper that iterates over quad components (skips predicate)

  }, {
    key: "forEachComponent",
    value: function forEachComponent(quad, op) {
      for (var key in quad) {
        // skip `predicate`
        if (key === 'predicate') {
          continue;
        }

        op(quad[key], key, quad);
      }
    }
  }]);
  return URDNA2015Sync;
}();

},{"./IdentifierIssuer":145,"./MessageDigest":146,"./NQuads":147,"./Permutator":148,"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],151:[function(require,module,exports){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var URDNA2015 = require('./URDNA2015');

var util = require('./util');

module.exports = /*#__PURE__*/function (_URDNA) {
  (0, _inherits2["default"])(URDNA2012, _URDNA);

  var _super = _createSuper(URDNA2012);

  function URDNA2012(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, URDNA2012);
    _this = _super.call(this, options);
    _this.name = 'URGNA2012';
    _this.hashAlgorithm = 'sha1';
    return _this;
  } // helper for modifying component during Hash First Degree Quads


  (0, _createClass2["default"])(URDNA2012, [{
    key: "modifyFirstDegreeComponent",
    value: function modifyFirstDegreeComponent(id, component, key) {
      if (component.termType !== 'BlankNode') {
        return component;
      }

      component = util.clone(component);

      if (key === 'name') {
        component.value = '_:g';
      } else {
        component.value = component.value === id ? '_:a' : '_:z';
      }

      return component;
    } // helper for getting a related predicate

  }, {
    key: "getRelatedPredicate",
    value: function getRelatedPredicate(quad) {
      return quad.predicate.value;
    } // helper for creating hash to related blank nodes map

  }, {
    key: "createHashToRelated",
    value: function createHashToRelated(id, issuer, callback) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.

      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to
      // quads map for the key identifier.

      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:

      self.forEach(quads, function (quad, idx, callback) {
        // 3.1) If the quad's subject is a blank node that does not match
        // identifier, set hash to the result of the Hash Related Blank Node
        // algorithm, passing the blank node identifier for subject as related,
        // quad, path identifier issuer as issuer, and p as position.
        var position;
        var related;

        if (quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {
          related = quad.subject.value;
          position = 'p';
        } else if (quad.object.termType === 'BlankNode' && quad.object.value !== id) {
          // 3.2) Otherwise, if quad's object is a blank node that does not match
          // identifier, to the result of the Hash Related Blank Node algorithm,
          // passing the blank node identifier for object as related, quad, path
          // identifier issuer as issuer, and r as position.
          related = quad.object.value;
          position = 'r';
        } else {
          // 3.3) Otherwise, continue to the next quad.
          return callback();
        } // 3.4) Add a mapping of hash to the blank node identifier for the
        // component that matched (subject or object) to hash to related blank
        // nodes map, adding an entry as necessary.


        self.hashRelatedBlankNode(related, quad, issuer, position, function (err, hash) {
          if (err) {
            return callback(err);
          }

          if (hash in hashToRelated) {
            hashToRelated[hash].push(related);
          } else {
            hashToRelated[hash] = [related];
          }

          callback();
        });
      }, function (err) {
        return callback(err, hashToRelated);
      });
    }
  }]);
  return URDNA2012;
}(URDNA2015);

},{"./URDNA2015":149,"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22}],152:[function(require,module,exports){
/*
 * Copyright (c) 2016 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var URDNA2015Sync = require('./URDNA2015Sync');

var util = require('./util');

module.exports = /*#__PURE__*/function (_URDNA2015Sync) {
  (0, _inherits2["default"])(URDNA2012Sync, _URDNA2015Sync);

  var _super = _createSuper(URDNA2012Sync);

  function URDNA2012Sync() {
    var _this;

    (0, _classCallCheck2["default"])(this, URDNA2012Sync);
    _this = _super.call(this);
    _this.name = 'URGNA2012';
    _this.hashAlgorithm = 'sha1';
    return _this;
  } // helper for modifying component during Hash First Degree Quads


  (0, _createClass2["default"])(URDNA2012Sync, [{
    key: "modifyFirstDegreeComponent",
    value: function modifyFirstDegreeComponent(id, component, key) {
      if (component.termType !== 'BlankNode') {
        return component;
      }

      component = util.clone(component);

      if (key === 'name') {
        component.value = '_:g';
      } else {
        component.value = component.value === id ? '_:a' : '_:z';
      }

      return component;
    } // helper for getting a related predicate

  }, {
    key: "getRelatedPredicate",
    value: function getRelatedPredicate(quad) {
      return quad.predicate.value;
    } // helper for creating hash to related blank nodes map

  }, {
    key: "createHashToRelated",
    value: function createHashToRelated(id, issuer) {
      var self = this; // 1) Create a hash to related blank nodes map for storing hashes that
      // identify related blank nodes.

      var hashToRelated = {}; // 2) Get a reference, quads, to the list of quads in the blank node to
      // quads map for the key identifier.

      var quads = self.blankNodeInfo[id].quads; // 3) For each quad in quads:

      for (var i = 0; i < quads.length; ++i) {
        // 3.1) If the quad's subject is a blank node that does not match
        // identifier, set hash to the result of the Hash Related Blank Node
        // algorithm, passing the blank node identifier for subject as related,
        // quad, path identifier issuer as issuer, and p as position.
        var quad = quads[i];
        var position = void 0;
        var related = void 0;

        if (quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {
          related = quad.subject.value;
          position = 'p';
        } else if (quad.object.termType === 'BlankNode' && quad.object.value !== id) {
          // 3.2) Otherwise, if quad's object is a blank node that does not match
          // identifier, to the result of the Hash Related Blank Node algorithm,
          // passing the blank node identifier for object as related, quad, path
          // identifier issuer as issuer, and r as position.
          related = quad.object.value;
          position = 'r';
        } else {
          // 3.3) Otherwise, continue to the next quad.
          continue;
        } // 3.4) Add a mapping of hash to the blank node identifier for the
        // component that matched (subject or object) to hash to related blank
        // nodes map, adding an entry as necessary.


        var hash = self.hashRelatedBlankNode(related, quad, issuer, position);

        if (hash in hashToRelated) {
          hashToRelated[hash].push(related);
        } else {
          hashToRelated[hash] = [related];
        }
      }

      return hashToRelated;
    }
  }]);
  return URDNA2012Sync;
}(URDNA2015Sync);

},{"./URDNA2015Sync":150,"./util":154,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22}],153:[function(require,module,exports){
/**
 * An implementation of the RDF Dataset Normalization specification.
 * This library works in the browser and node.js.
 *
 * BSD 3-Clause License
 * Copyright (c) 2016-2017 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var util = require('./util');

var URDNA2015 = require('./URDNA2015');

var URGNA2012 = require('./URGNA2012');

var URDNA2015Sync = require('./URDNA2015Sync');

var URGNA2012Sync = require('./URGNA2012Sync'); // optional native support


var rdfCanonizeNative;

try {
  rdfCanonizeNative = require('rdf-canonize-native');
} catch (e) {}

var api = {};
module.exports = api; // expose helpers

api.NQuads = require('./NQuads');
api.IdentifierIssuer = require('./IdentifierIssuer');
/**
 * Get or set native API.
 *
 * @param api the native API.
 *
 * @return the currently set native API.
 */

api._rdfCanonizeNative = function (api) {
  if (api) {
    rdfCanonizeNative = api;
  }

  return rdfCanonizeNative;
};
/**
 * Asynchronously canonizes an RDF dataset.
 *
 * @param dataset the dataset to canonize.
 * @param options the options to use:
 *          algorithm the canonicalization algorithm to use, `URDNA2015` or
 *            `URGNA2012`.
 *          [useNative] use native implementation (default: false).
 * @param [callback(err, canonical)] called once the operation completes.
 *
 * @return a Promise that resolves to the canonicalized RDF Dataset.
 */


api.canonize = util.callbackify( /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(dataset, options) {
    var callback, promise;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            promise = new Promise(function (resolve, reject) {
              callback = function callback(err, canonical) {
                if (err) {
                  return reject(err);
                }
                /*if(options.format === 'application/n-quads') {
                  canonical = canonical.join('');
                }
                canonical = _parseNQuads(canonical.join(''));*/


                resolve(canonical);
              };
            }); // back-compat with legacy dataset

            if (!Array.isArray(dataset)) {
              dataset = api.NQuads.legacyDatasetToQuads(dataset);
            } // TODO: convert algorithms to Promise-based async


            if (!options.useNative) {
              _context.next = 10;
              break;
            }

            if (!rdfCanonizeNative) {
              _context.next = 7;
              break;
            }

            rdfCanonizeNative.canonize(dataset, options, callback);
            _context.next = 8;
            break;

          case 7:
            throw new Error('rdf-canonize-native not available');

          case 8:
            _context.next = 23;
            break;

          case 10:
            if (!(options.algorithm === 'URDNA2015')) {
              _context.next = 14;
              break;
            }

            new URDNA2015(options).main(dataset, callback);
            _context.next = 23;
            break;

          case 14:
            if (!(options.algorithm === 'URGNA2012')) {
              _context.next = 18;
              break;
            }

            new URGNA2012(options).main(dataset, callback);
            _context.next = 23;
            break;

          case 18:
            if ('algorithm' in options) {
              _context.next = 22;
              break;
            }

            throw new Error('No RDF Dataset Canonicalization algorithm specified.');

          case 22:
            throw new Error('Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);

          case 23:
            return _context.abrupt("return", promise);

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}());
/**
 * Synchronously canonizes an RDF dataset.
 *
 * @param dataset the dataset to canonize.
 * @param options the options to use:
 *          algorithm the canonicalization algorithm to use, `URDNA2015` or
 *            `URGNA2012`.
 *          [useNative] use native implementation (default: false).
 *
 * @return the RDF dataset in canonical form.
 */

api.canonizeSync = function (dataset, options) {
  // back-compat with legacy dataset
  if (!Array.isArray(dataset)) {
    dataset = api.NQuads.legacyDatasetToQuads(dataset);
  }

  if (options.useNative) {
    if (rdfCanonizeNative) {
      return rdfCanonizeNative.canonizeSync(dataset, options);
    }

    throw new Error('rdf-canonize-native not available');
  }

  if (options.algorithm === 'URDNA2015') {
    return new URDNA2015Sync(options).main(dataset);
  } else if (options.algorithm === 'URGNA2012') {
    return new URGNA2012Sync(options).main(dataset);
  }

  if (!('algorithm' in options)) {
    throw new Error('No RDF Dataset Canonicalization algorithm specified.');
  }

  throw new Error('Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);
};

},{"./IdentifierIssuer":145,"./NQuads":147,"./URDNA2015":149,"./URDNA2015Sync":150,"./URGNA2012":151,"./URGNA2012Sync":152,"./util":154,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30,"rdf-canonize-native":58}],154:[function(require,module,exports){
(function (process,setImmediate){(function (){
/*
 * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var api = {};
module.exports = api; // define setImmediate and nextTick
//// nextTick implementation with browser-compatible fallback ////
// from https://github.com/caolan/async/blob/master/lib/async.js
// capture the global reference to guard against fakeTimer mocks

var _setImmediate = typeof setImmediate === 'function' && setImmediate;

var _delay = _setImmediate ? // not a direct alias (for IE10 compatibility)
function (fn) {
  return _setImmediate(fn);
} : function (fn) {
  return setTimeout(fn, 0);
};

if ((typeof process === "undefined" ? "undefined" : (0, _typeof2["default"])(process)) === 'object' && typeof process.nextTick === 'function') {
  api.nextTick = process.nextTick;
} else {
  api.nextTick = _delay;
}

api.setImmediate = _setImmediate ? _delay : api.nextTick;
/**
 * Clones an object, array, or string/number. If a typed JavaScript object
 * is given, such as a Date, it will be converted to a string.
 *
 * @param value the value to clone.
 *
 * @return the cloned value.
 */

api.clone = function (value) {
  if (value && (0, _typeof2["default"])(value) === 'object') {
    var rval;

    if (Array.isArray(value)) {
      rval = [];

      for (var i = 0; i < value.length; ++i) {
        rval[i] = api.clone(value[i]);
      }
    } else if (api.isObject(value)) {
      rval = {};

      for (var key in value) {
        rval[key] = api.clone(value[key]);
      }
    } else {
      rval = value.toString();
    }

    return rval;
  }

  return value;
};
/**
 * Returns true if the given value is an Object.
 *
 * @param v the value to check.
 *
 * @return true if the value is an Object, false if not.
 */


api.isObject = function (v) {
  return Object.prototype.toString.call(v) === '[object Object]';
};
/**
 * Returns true if the given value is undefined.
 *
 * @param v the value to check.
 *
 * @return true if the value is undefined, false if not.
 */


api.isUndefined = function (v) {
  return typeof v === 'undefined';
};

api.callbackify = function (fn) {
  return /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
    var _len,
        args,
        _key,
        callback,
        result,
        _args = arguments;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = _args[_key];
            }

            callback = args[args.length - 1];

            if (typeof callback === 'function') {
              args.pop();
            }

            _context.prev = 3;
            _context.next = 6;
            return fn.apply(null, args);

          case 6:
            result = _context.sent;
            _context.next = 14;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](3);

            if (!(typeof callback === 'function')) {
              _context.next = 13;
              break;
            }

            return _context.abrupt("return", _invokeCallback(callback, _context.t0));

          case 13:
            throw _context.t0;

          case 14:
            if (!(typeof callback === 'function')) {
              _context.next = 16;
              break;
            }

            return _context.abrupt("return", _invokeCallback(callback, null, result));

          case 16:
            return _context.abrupt("return", result);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 9]]);
  }));
};

function _invokeCallback(callback, err, result) {
  try {
    return callback(err, result);
  } catch (unhandledError) {
    // throw unhandled errors to prevent "unhandled rejected promise"
    // and simulate what would have happened in a promiseless API
    process.nextTick(function () {
      throw unhandledError;
    });
  }
}

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

},{"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27,"@babel/runtime/regenerator":30,"_process":142,"timers":193}],155:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./lib/BlankNode"), exports);

__exportStar(require("./lib/DataFactory"), exports);

__exportStar(require("./lib/DefaultGraph"), exports);

__exportStar(require("./lib/Literal"), exports);

__exportStar(require("./lib/NamedNode"), exports);

__exportStar(require("./lib/Quad"), exports);

__exportStar(require("./lib/Variable"), exports);

},{"./lib/BlankNode":156,"./lib/DataFactory":157,"./lib/DefaultGraph":158,"./lib/Literal":159,"./lib/NamedNode":160,"./lib/Quad":161,"./lib/Variable":162}],156:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BlankNode = void 0;
/**
 * A term that represents an RDF blank node with a label.
 */

var BlankNode = /*#__PURE__*/function () {
  function BlankNode(value) {
    (0, _classCallCheck2["default"])(this, BlankNode);
    this.termType = 'BlankNode';
    this.value = value;
  }

  (0, _createClass2["default"])(BlankNode, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'BlankNode' && other.value === this.value;
    }
  }]);
  return BlankNode;
}();

exports.BlankNode = BlankNode;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],157:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataFactory = void 0;

var BlankNode_1 = require("./BlankNode");

var DefaultGraph_1 = require("./DefaultGraph");

var Literal_1 = require("./Literal");

var NamedNode_1 = require("./NamedNode");

var Quad_1 = require("./Quad");

var Variable_1 = require("./Variable");

var dataFactoryCounter = 0;
/**
 * A factory for instantiating RDF terms and quads.
 */

var DataFactory = /*#__PURE__*/function () {
  function DataFactory(options) {
    (0, _classCallCheck2["default"])(this, DataFactory);
    this.blankNodeCounter = 0;
    options = options || {};
    this.blankNodePrefix = options.blankNodePrefix || "df_".concat(dataFactoryCounter++, "_");
  }
  /**
   * @param value The IRI for the named node.
   * @return A new instance of NamedNode.
   * @see NamedNode
   */


  (0, _createClass2["default"])(DataFactory, [{
    key: "namedNode",
    value: function namedNode(value) {
      return new NamedNode_1.NamedNode(value);
    }
    /**
     * @param value The optional blank node identifier.
     * @return A new instance of BlankNode.
     *         If the `value` parameter is undefined a new identifier
     *         for the blank node is generated for each call.
     * @see BlankNode
     */

  }, {
    key: "blankNode",
    value: function blankNode(value) {
      return new BlankNode_1.BlankNode(value || "".concat(this.blankNodePrefix).concat(this.blankNodeCounter++));
    }
    /**
     * @param value              The literal value.
     * @param languageOrDatatype The optional language or datatype.
     *                           If `languageOrDatatype` is a NamedNode,
     *                           then it is used for the value of `NamedNode.datatype`.
     *                           Otherwise `languageOrDatatype` is used for the value
     *                           of `NamedNode.language`.
     * @return A new instance of Literal.
     * @see Literal
     */

  }, {
    key: "literal",
    value: function literal(value, languageOrDatatype) {
      return new Literal_1.Literal(value, languageOrDatatype);
    }
    /**
     * This method is optional.
     * @param value The variable name
     * @return A new instance of Variable.
     * @see Variable
     */

  }, {
    key: "variable",
    value: function variable(value) {
      return new Variable_1.Variable(value);
    }
    /**
     * @return An instance of DefaultGraph.
     */

  }, {
    key: "defaultGraph",
    value: function defaultGraph() {
      return DefaultGraph_1.DefaultGraph.INSTANCE;
    }
    /**
     * @param subject   The quad subject term.
     * @param predicate The quad predicate term.
     * @param object    The quad object term.
     * @param graph     The quad graph term.
     * @return A new instance of Quad.
     * @see Quad
     */

  }, {
    key: "quad",
    value: function quad(subject, predicate, object, graph) {
      return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());
    }
    /**
     * Create a deep copy of the given term using this data factory.
     * @param original An RDF term.
     * @return A deep copy of the given term.
     */

  }, {
    key: "fromTerm",
    value: function fromTerm(original) {
      // TODO: remove nasty any casts when this TS bug has been fixed:
      //  https://github.com/microsoft/TypeScript/issues/26933
      switch (original.termType) {
        case 'NamedNode':
          return this.namedNode(original.value);

        case 'BlankNode':
          return this.blankNode(original.value);

        case 'Literal':
          if (original.language) {
            return this.literal(original.value, original.language);
          }

          if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {
            return this.literal(original.value, this.fromTerm(original.datatype));
          }

          return this.literal(original.value);

        case 'Variable':
          return this.variable(original.value);

        case 'DefaultGraph':
          return this.defaultGraph();

        case 'Quad':
          return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));
      }
    }
    /**
     * Create a deep copy of the given quad using this data factory.
     * @param original An RDF quad.
     * @return A deep copy of the given quad.
     */

  }, {
    key: "fromQuad",
    value: function fromQuad(original) {
      return this.fromTerm(original);
    }
    /**
     * Reset the internal blank node counter.
     */

  }, {
    key: "resetBlankNodeCounter",
    value: function resetBlankNodeCounter() {
      this.blankNodeCounter = 0;
    }
  }]);
  return DataFactory;
}();

exports.DataFactory = DataFactory;

},{"./BlankNode":156,"./DefaultGraph":158,"./Literal":159,"./NamedNode":160,"./Quad":161,"./Variable":162,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],158:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultGraph = void 0;
/**
 * A singleton term instance that represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */

var DefaultGraph = /*#__PURE__*/function () {
  function DefaultGraph() {
    (0, _classCallCheck2["default"])(this, DefaultGraph);
    this.termType = 'DefaultGraph';
    this.value = ''; // Private constructor
  }

  (0, _createClass2["default"])(DefaultGraph, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'DefaultGraph';
    }
  }]);
  return DefaultGraph;
}();

exports.DefaultGraph = DefaultGraph;
DefaultGraph.INSTANCE = new DefaultGraph();

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],159:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Literal = void 0;

var NamedNode_1 = require("./NamedNode");
/**
 * A term that represents an RDF literal, containing a string with an optional language tag or datatype.
 */


var Literal = /*#__PURE__*/function () {
  function Literal(value, languageOrDatatype) {
    (0, _classCallCheck2["default"])(this, Literal);
    this.termType = 'Literal';
    this.value = value;

    if (typeof languageOrDatatype === 'string') {
      this.language = languageOrDatatype;
      this.datatype = Literal.RDF_LANGUAGE_STRING;
    } else if (languageOrDatatype) {
      this.language = '';
      this.datatype = languageOrDatatype;
    } else {
      this.language = '';
      this.datatype = Literal.XSD_STRING;
    }
  }

  (0, _createClass2["default"])(Literal, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'Literal' && other.value === this.value && other.language === this.language && other.datatype.equals(this.datatype);
    }
  }]);
  return Literal;
}();

exports.Literal = Literal;
Literal.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
Literal.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');

},{"./NamedNode":160,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],160:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NamedNode = void 0;
/**
 * A term that contains an IRI.
 */

var NamedNode = /*#__PURE__*/function () {
  function NamedNode(value) {
    (0, _classCallCheck2["default"])(this, NamedNode);
    this.termType = 'NamedNode';
    this.value = value;
  }

  (0, _createClass2["default"])(NamedNode, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'NamedNode' && other.value === this.value;
    }
  }]);
  return NamedNode;
}();

exports.NamedNode = NamedNode;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],161:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Quad = void 0;
/**
 * An instance of DefaultGraph represents the default graph.
 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
 */

var Quad = /*#__PURE__*/function () {
  function Quad(subject, predicate, object, graph) {
    (0, _classCallCheck2["default"])(this, Quad);
    this.termType = 'Quad';
    this.value = '';
    this.subject = subject;
    this.predicate = predicate;
    this.object = object;
    this.graph = graph;
  }

  (0, _createClass2["default"])(Quad, [{
    key: "equals",
    value: function equals(other) {
      // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.
      return !!other && (other.termType === 'Quad' || !other.termType) && this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph);
    }
  }]);
  return Quad;
}();

exports.Quad = Quad;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],162:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Variable = void 0;
/**
 * A term that represents a variable.
 */

var Variable = /*#__PURE__*/function () {
  function Variable(value) {
    (0, _classCallCheck2["default"])(this, Variable);
    this.termType = 'Variable';
    this.value = value;
  }

  (0, _createClass2["default"])(Variable, [{
    key: "equals",
    value: function equals(other) {
      return !!other && other.termType === 'Variable' && other.value === this.value;
    }
  }]);
  return Variable;
}();

exports.Variable = Variable;

},{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13}],163:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

__exportStar(require("./lib/IActiveTag"), exports);

__exportStar(require("./lib/IHtmlParseListener"), exports);

__exportStar(require("./lib/IRdfaPattern"), exports);

__exportStar(require("./lib/RdfaParser"), exports);

__exportStar(require("./lib/RdfaProfile"), exports);

__exportStar(require("./lib/Util"), exports);

},{"./lib/IActiveTag":164,"./lib/IHtmlParseListener":165,"./lib/IRdfaPattern":166,"./lib/RdfaParser":167,"./lib/RdfaProfile":168,"./lib/Util":169}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],165:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],167:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RdfaParser = void 0;

var htmlparser2_1 = require("htmlparser2");

var stream_1 = require("stream");

var INITIAL_CONTEXT_XHTML = require("./initial-context-xhtml.json");

var INITIAL_CONTEXT = require("./initial-context.json");

var RdfaProfile_1 = require("./RdfaProfile");

var Util_1 = require("./Util");
/**
 * A stream transformer that parses RDFa (text) streams to an {@link RDF.Stream}.
 */


var RdfaParser = /*#__PURE__*/function (_stream_1$Transform) {
  (0, _inherits2["default"])(RdfaParser, _stream_1$Transform);

  var _super = _createSuper(RdfaParser);

  function RdfaParser(options) {
    var _this;

    (0, _classCallCheck2["default"])(this, RdfaParser);
    _this = _super.call(this, {
      readableObjectMode: true
    });
    _this.activeTagStack = [];
    options = options || {};
    _this.options = options;
    _this.util = new Util_1.Util(options.dataFactory, options.baseIRI);
    _this.defaultGraph = options.defaultGraph || _this.util.dataFactory.defaultGraph();
    var profile = options.contentType ? Util_1.Util.contentTypeToProfile(options.contentType) : options.profile || '';
    _this.features = options.features || RdfaProfile_1.RDFA_FEATURES[profile];
    _this.htmlParseListener = options.htmlParseListener;
    _this.rdfaPatterns = _this.features.copyRdfaPatterns ? {} : null;
    _this.pendingRdfaPatternCopies = _this.features.copyRdfaPatterns ? {} : null;
    _this.parser = _this.initializeParser(profile === 'xml');

    _this.activeTagStack.push({
      incompleteTriples: [],
      inlist: false,
      language: options.language,
      listMapping: {},
      listMappingLocal: {},
      name: '',
      prefixesAll: Object.assign(Object.assign({}, INITIAL_CONTEXT['@context']), _this.features.xhtmlInitialContext ? INITIAL_CONTEXT_XHTML['@context'] : {}),
      prefixesCustom: {},
      skipElement: false,
      vocab: options.vocab
    });

    return _this;
  }
  /**
   * Parses the given text stream into a quad stream.
   * @param {NodeJS.EventEmitter} stream A text stream.
   * @return {RDF.Stream} A quad stream.
   */


  (0, _createClass2["default"])(RdfaParser, [{
    key: "import",
    value: function _import(stream) {
      var output = new stream_1.PassThrough({
        readableObjectMode: true
      });
      stream.on('error', function (error) {
        return parsed.emit('error', error);
      });
      stream.on('data', function (data) {
        return output.push(data);
      });
      stream.on('end', function () {
        return output.push(null);
      });
      var parsed = output.pipe(new RdfaParser(this.options));
      return parsed;
    }
  }, {
    key: "_transform",
    value: function _transform(chunk, encoding, callback) {
      this.parser.write(chunk);
      callback();
    }
  }, {
    key: "_flush",
    value: function _flush(callback) {
      this.parser.end();
      callback();
    }
  }, {
    key: "onTagOpen",
    value: function onTagOpen(name, attributes) {
      // Determine the parent tag (ignore skipped tags)
      var parentTagI = this.activeTagStack.length - 1;

      while (parentTagI > 0 && this.activeTagStack[parentTagI].skipElement) {
        parentTagI--;
      }

      var parentTag = this.activeTagStack[parentTagI]; // If we skipped a tag, make sure we DO use the lang, prefixes and vocab of the skipped tag

      if (parentTagI !== this.activeTagStack.length - 1) {
        parentTag = Object.assign(Object.assign({}, parentTag), {
          language: this.activeTagStack[this.activeTagStack.length - 1].language,
          prefixesAll: this.activeTagStack[this.activeTagStack.length - 1].prefixesAll,
          prefixesCustom: this.activeTagStack[this.activeTagStack.length - 1].prefixesCustom,
          vocab: this.activeTagStack[this.activeTagStack.length - 1].vocab
        });
      } // Create a new active tag and inherit language scope and baseIRI from parent


      var activeTag = {
        collectChildTags: parentTag.collectChildTags,
        incompleteTriples: [],
        inlist: 'inlist' in attributes,
        listMapping: [],
        listMappingLocal: parentTag.listMapping,
        localBaseIRI: parentTag.localBaseIRI,
        name: name,
        prefixesAll: null,
        prefixesCustom: null,
        skipElement: false
      };
      this.activeTagStack.push(activeTag); // Save the tag contents if needed

      if (activeTag.collectChildTags) {
        // Add explicitly defined xmlns, xmlns:* and prefixes to attributes, as required by the spec (Step 11, note)
        // Sort prefixes alphabetically for deterministic namespace declaration order
        var _iterator = _createForOfIteratorHelper(Object.keys(parentTag.prefixesCustom).sort()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var prefix = _step.value;
            var suffix = parentTag.prefixesCustom[prefix];
            var attributeKey = prefix === '' ? 'xmlns' : 'xmlns:' + prefix;

            if (!(attributeKey in attributes)) {
              attributes[attributeKey] = suffix;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var attributesSerialized = Object.keys(attributes).map(function (key) {
          return "".concat(key, "=\"").concat(attributes[key], "\"");
        }).join(' ');
        activeTag.text = ["<".concat(name).concat(attributesSerialized ? ' ' + attributesSerialized : '', ">")];

        if (this.features.skipHandlingXmlLiteralChildren) {
          return;
        }
      }

      var allowTermsInRelPredicates = true;
      var allowTermsInRevPredicates = true;

      if (this.features.onlyAllowUriRelRevIfProperty) {
        // Ignore illegal rel/rev values when property is present
        if ('property' in attributes && 'rel' in attributes) {
          allowTermsInRelPredicates = false;

          if (attributes.rel.indexOf(':') < 0) {
            delete attributes.rel;
          }
        }

        if ('property' in attributes && 'rev' in attributes) {
          allowTermsInRevPredicates = false;

          if (attributes.rev.indexOf(':') < 0) {
            delete attributes.rev;
          }
        }
      }

      if (this.features.copyRdfaPatterns) {
        // Save the tag if needed
        if (parentTag.collectedPatternTag) {
          var patternTag = {
            attributes: attributes,
            children: [],
            name: name,
            referenced: false,
            rootPattern: false,
            text: []
          };
          parentTag.collectedPatternTag.children.push(patternTag);
          activeTag.collectedPatternTag = patternTag;
          return;
        } // Store tags with type rdfa:Pattern as patterns


        if (attributes["typeof"] === 'rdfa:Pattern') {
          activeTag.collectedPatternTag = {
            attributes: attributes,
            children: [],
            name: name,
            parentTag: parentTag,
            referenced: false,
            rootPattern: true,
            text: []
          };
          return;
        } // Instantiate patterns on rdfa:copy


        if (attributes.property === 'rdfa:copy') {
          var copyTargetPatternId = attributes.resource || attributes.href || attributes.src;

          if (this.rdfaPatterns[copyTargetPatternId]) {
            this.emitPatternCopy(parentTag, this.rdfaPatterns[copyTargetPatternId], copyTargetPatternId);
          } else {
            if (!this.pendingRdfaPatternCopies[copyTargetPatternId]) {
              this.pendingRdfaPatternCopies[copyTargetPatternId] = [];
            }

            this.pendingRdfaPatternCopies[copyTargetPatternId].push(parentTag);
          }

          return;
        }
      } // <base> tags override the baseIRI of the whole document


      if (this.features.baseTag && name === 'base' && attributes.href) {
        this.util.baseIRI = this.util.getBaseIRI(attributes.href);
      } // xml:base attributes override the baseIRI of the current tag and children


      if (this.features.xmlBase && attributes['xml:base']) {
        activeTag.localBaseIRI = this.util.getBaseIRI(attributes['xml:base']);
      } // <time> tags set an initial datatype


      if (this.features.timeTag && name === 'time' && !attributes.datatype) {
        activeTag.interpretObjectAsTime = true;
      } // Processing based on https://www.w3.org/TR/rdfa-core/#s_rdfaindetail
      // 1: initialize values


      var newSubject;
      var currentObjectResource;
      var typedResource; // 2: handle vocab attribute to set active vocabulary
      // Vocab sets the active vocabulary

      if ('vocab' in attributes) {
        if (attributes.vocab) {
          activeTag.vocab = attributes.vocab;
          this.emitTriple(this.util.getBaseIriTerm(activeTag), this.util.dataFactory.namedNode(Util_1.Util.RDFA + 'usesVocabulary'), this.util.dataFactory.namedNode(activeTag.vocab));
        } else {
          // If vocab is set to '', then we fallback to the root vocab as defined via the parser constructor
          activeTag.vocab = this.activeTagStack[0].vocab;
        }
      } else {
        activeTag.vocab = parentTag.vocab;
      } // 3: handle prefixes


      activeTag.prefixesCustom = Util_1.Util.parsePrefixes(attributes, parentTag.prefixesCustom, this.features.xmlnsPrefixMappings);
      activeTag.prefixesAll = Object.keys(activeTag.prefixesCustom).length > 0 ? Object.assign(Object.assign({}, parentTag.prefixesAll), activeTag.prefixesCustom) : parentTag.prefixesAll; // Handle role attribute

      if (this.features.roleAttribute && attributes.role) {
        var roleSubject = attributes.id ? this.util.createIri('#' + attributes.id, activeTag, false, false, false) : this.util.createBlankNode(); // Temporarily override vocab

        var vocabOld = activeTag.vocab;
        activeTag.vocab = 'http://www.w3.org/1999/xhtml/vocab#';

        var _iterator2 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.role, activeTag, true, false)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var role = _step2.value;
            this.emitTriple(roleSubject, this.util.dataFactory.namedNode('http://www.w3.org/1999/xhtml/vocab#role'), role);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        activeTag.vocab = vocabOld;
      } // 4: handle language
      // Save language attribute value in active tag


      if ('xml:lang' in attributes || this.features.langAttribute && 'lang' in attributes) {
        activeTag.language = attributes['xml:lang'] || attributes.lang;
      } else {
        activeTag.language = parentTag.language;
      }

      var isRootTag = this.activeTagStack.length === 2;

      if (!('rel' in attributes) && !('rev' in attributes)) {
        // 5: Determine the new subject when rel and rev are not present
        if ('property' in attributes && !('content' in attributes) && !('datatype' in attributes)) {
          // 5.1: property is present, but not content and datatype
          // Determine new subject
          if ('about' in attributes) {
            newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);
            activeTag.explicitNewSubject = !!newSubject;
          } else if (isRootTag) {
            newSubject = true;
          } else if (parentTag.object) {
            newSubject = parentTag.object;
          } // Determine type


          if ('typeof' in attributes) {
            if ('about' in attributes) {
              typedResource = this.util.createIri(attributes.about, activeTag, false, true, true);
            }

            if (!typedResource && isRootTag) {
              typedResource = true;
            }

            if (!typedResource && 'resource' in attributes) {
              typedResource = this.util.createIri(attributes.resource, activeTag, false, true, true);
            }

            if (!typedResource && ('href' in attributes || 'src' in attributes)) {
              typedResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);
            }

            if (!typedResource && this.isInheritSubjectInHeadBody(name)) {
              typedResource = newSubject;
            }

            if (!typedResource) {
              typedResource = this.util.createBlankNode();
            }

            currentObjectResource = typedResource;
          }
        } else {
          // 5.2
          if ('about' in attributes || 'resource' in attributes) {
            newSubject = this.util.createIri(attributes.about || attributes.resource, activeTag, false, true, true);
            activeTag.explicitNewSubject = !!newSubject;
          }

          if (!newSubject && ('href' in attributes || 'src' in attributes)) {
            newSubject = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);
            activeTag.explicitNewSubject = !!newSubject;
          }

          if (!newSubject) {
            if (isRootTag) {
              newSubject = true;
            } else if (this.isInheritSubjectInHeadBody(name)) {
              newSubject = parentTag.object;
            } else if ('typeof' in attributes) {
              newSubject = this.util.createBlankNode();
              activeTag.explicitNewSubject = true;
            } else if (parentTag.object) {
              newSubject = parentTag.object;

              if (!('property' in attributes)) {
                activeTag.skipElement = true;
              }
            }
          } // Determine type


          if ('typeof' in attributes) {
            typedResource = newSubject;
          }
        }
      } else {
        // either rel or rev is present
        // 6: Determine the new subject when rel or rev are present
        // Define new subject
        if ('about' in attributes) {
          newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);
          activeTag.explicitNewSubject = !!newSubject;

          if ('typeof' in attributes) {
            typedResource = newSubject;
          }
        } else if (isRootTag) {
          newSubject = true;
        } else if (parentTag.object) {
          newSubject = parentTag.object;
        } // Define object


        if ('resource' in attributes) {
          currentObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);
        }

        if (!currentObjectResource) {
          if ('href' in attributes || 'src' in attributes) {
            currentObjectResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);
          } else if ('typeof' in attributes && !('about' in attributes) && !this.isInheritSubjectInHeadBody(name)) {
            currentObjectResource = this.util.createBlankNode();
          }
        } // Set typed resource


        if ('typeof' in attributes && !('about' in attributes)) {
          if (this.isInheritSubjectInHeadBody(name)) {
            typedResource = newSubject;
          } else {
            typedResource = currentObjectResource;
          }
        }
      } // 7: If a typed resource was defined, emit it as a triple


      if (typedResource) {
        var _iterator3 = _createForOfIteratorHelper(this.util.createVocabIris(attributes["typeof"], activeTag, true, true)),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var type = _step3.value;
            this.emitTriple(this.util.getResourceOrBaseIri(typedResource, activeTag), this.util.dataFactory.namedNode(Util_1.Util.RDF + 'type'), type);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } // 8: Reset list mapping if we have a new subject


      if (newSubject) {
        activeTag.listMapping = {};
      } // 9: If an object was defined, emit triples for it


      if (currentObjectResource) {
        // Handle list mapping
        if ('rel' in attributes && 'inlist' in attributes) {
          var _iterator4 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var predicate = _step4.value;
              this.addListMapping(activeTag, newSubject, predicate, currentObjectResource);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        } // Determine predicates using rel or rev (unless rel and inlist are present)


        if (!('rel' in attributes && 'inlist' in attributes)) {
          if ('rel' in attributes) {
            var _iterator5 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var _predicate = _step5.value;
                this.emitTriple(this.util.getResourceOrBaseIri(newSubject, activeTag), _predicate, this.util.getResourceOrBaseIri(currentObjectResource, activeTag));
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }

          if ('rev' in attributes) {
            var _iterator6 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates, false)),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _predicate2 = _step6.value;
                this.emitTriple(this.util.getResourceOrBaseIri(currentObjectResource, activeTag), _predicate2, this.util.getResourceOrBaseIri(newSubject, activeTag));
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
        }
      } // 10: Store incomplete triples if we don't have an object, but we do have predicates


      if (!currentObjectResource) {
        if ('rel' in attributes) {
          if ('inlist' in attributes) {
            var _iterator7 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)),
                _step7;

            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var _predicate3 = _step7.value;
                this.addListMapping(activeTag, newSubject, _predicate3, null);
                activeTag.incompleteTriples.push({
                  predicate: _predicate3,
                  reverse: false,
                  list: true
                });
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          } else {
            var _iterator8 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)),
                _step8;

            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                var _predicate4 = _step8.value;
                activeTag.incompleteTriples.push({
                  predicate: _predicate4,
                  reverse: false
                });
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
          }
        }

        if ('rev' in attributes) {
          var _iterator9 = _createForOfIteratorHelper(this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates, false)),
              _step9;

          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var _predicate5 = _step9.value;
              activeTag.incompleteTriples.push({
                predicate: _predicate5,
                reverse: true
              });
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        } // Set a blank node object, so the children can make use of this when completing the triples


        if (activeTag.incompleteTriples.length > 0) {
          currentObjectResource = this.util.createBlankNode();
        }
      } // 11: Determine current property value


      if ('property' in attributes) {
        // Create predicates
        activeTag.predicates = this.util.createVocabIris(attributes.property, activeTag, true, false); // Save datatype attribute value in active tag

        var localObjectResource;

        if ('datatype' in attributes) {
          activeTag.datatype = this.util.createIri(attributes.datatype, activeTag, true, true, false);

          if (activeTag.datatype && (activeTag.datatype.value === Util_1.Util.RDF + 'XMLLiteral' || this.features.htmlDatatype && activeTag.datatype.value === Util_1.Util.RDF + 'HTML')) {
            activeTag.collectChildTags = true;
          }
        } else {
          // Try to determine resource
          if (!('rev' in attributes) && !('rel' in attributes) && !('content' in attributes)) {
            if ('resource' in attributes) {
              localObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);
            }

            if (!localObjectResource && 'href' in attributes) {
              localObjectResource = this.util.createIri(attributes.href, activeTag, false, false, true);
            }

            if (!localObjectResource && 'src' in attributes) {
              localObjectResource = this.util.createIri(attributes.src, activeTag, false, false, true);
            }
          }

          if ('typeof' in attributes && !('about' in attributes)) {
            localObjectResource = typedResource;
          }
        }

        if ('content' in attributes) {
          // Emit triples based on content attribute has preference over text content
          var object = this.util.createLiteral(attributes.content, activeTag);

          if ('inlist' in attributes) {
            var _iterator10 = _createForOfIteratorHelper(activeTag.predicates),
                _step10;

            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var _predicate6 = _step10.value;
                this.addListMapping(activeTag, newSubject, _predicate6, object);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
          } else {
            var subject = this.util.getResourceOrBaseIri(newSubject, activeTag);

            var _iterator11 = _createForOfIteratorHelper(activeTag.predicates),
                _step11;

            try {
              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                var _predicate7 = _step11.value;
                this.emitTriple(subject, _predicate7, object);
              }
            } catch (err) {
              _iterator11.e(err);
            } finally {
              _iterator11.f();
            }
          } // Unset predicate to avoid text contents to produce new triples


          activeTag.predicates = null;
        } else if (this.features.datetimeAttribute && 'datetime' in attributes) {
          activeTag.interpretObjectAsTime = true; // Datetime attribute on time tag has preference over text content

          var _object = this.util.createLiteral(attributes.datetime, activeTag);

          if ('inlist' in attributes) {
            var _iterator12 = _createForOfIteratorHelper(activeTag.predicates),
                _step12;

            try {
              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                var _predicate8 = _step12.value;
                this.addListMapping(activeTag, newSubject, _predicate8, _object);
              }
            } catch (err) {
              _iterator12.e(err);
            } finally {
              _iterator12.f();
            }
          } else {
            var _subject = this.util.getResourceOrBaseIri(newSubject, activeTag);

            var _iterator13 = _createForOfIteratorHelper(activeTag.predicates),
                _step13;

            try {
              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                var _predicate9 = _step13.value;
                this.emitTriple(_subject, _predicate9, _object);
              }
            } catch (err) {
              _iterator13.e(err);
            } finally {
              _iterator13.f();
            }
          } // Unset predicate to avoid text contents to produce new triples


          activeTag.predicates = null;
        } else if (localObjectResource) {
          // Emit triples for all resource objects
          var _object2 = this.util.getResourceOrBaseIri(localObjectResource, activeTag);

          if ('inlist' in attributes) {
            var _iterator14 = _createForOfIteratorHelper(activeTag.predicates),
                _step14;

            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var _predicate10 = _step14.value;
                this.addListMapping(activeTag, newSubject, _predicate10, _object2);
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
          } else {
            var _subject2 = this.util.getResourceOrBaseIri(newSubject, activeTag);

            var _iterator15 = _createForOfIteratorHelper(activeTag.predicates),
                _step15;

            try {
              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                var _predicate11 = _step15.value;
                this.emitTriple(_subject2, _predicate11, _object2);
              }
            } catch (err) {
              _iterator15.e(err);
            } finally {
              _iterator15.f();
            }
          } // Unset predicate to avoid text contents to produce new triples


          activeTag.predicates = null;
        }
      } // 12: Complete incomplete triples


      var incompleteTriplesCompleted = false;

      if (!activeTag.skipElement && newSubject && parentTag.incompleteTriples.length > 0) {
        incompleteTriplesCompleted = true;

        var _subject3 = this.util.getResourceOrBaseIri(parentTag.subject, activeTag);

        var _object3 = this.util.getResourceOrBaseIri(newSubject, activeTag);

        var _iterator16 = _createForOfIteratorHelper(parentTag.incompleteTriples),
            _step16;

        try {
          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
            var incompleteTriple = _step16.value;

            if (!incompleteTriple.reverse) {
              if (incompleteTriple.list) {
                // Find the active tag that defined the list by going up the stack
                var firstInListTag = null;

                for (var i = this.activeTagStack.length - 1; i >= 0; i--) {
                  if (this.activeTagStack[i].inlist) {
                    firstInListTag = this.activeTagStack[i];
                    break;
                  }
                } // firstInListTag is guaranteed to be non-null


                this.addListMapping(firstInListTag, newSubject, incompleteTriple.predicate, _object3);
              } else {
                this.emitTriple(_subject3, incompleteTriple.predicate, _object3);
              }
            } else {
              this.emitTriple(_object3, incompleteTriple.predicate, _subject3);
            }
          }
        } catch (err) {
          _iterator16.e(err);
        } finally {
          _iterator16.f();
        }
      }

      if (!incompleteTriplesCompleted && parentTag.incompleteTriples.length > 0) {
        activeTag.incompleteTriples = activeTag.incompleteTriples.concat(parentTag.incompleteTriples);
      } // 13: Save evaluation context into active tag


      activeTag.subject = newSubject || parentTag.subject;
      activeTag.object = currentObjectResource || newSubject;
    }
  }, {
    key: "onText",
    value: function onText(data) {
      var activeTag = this.activeTagStack[this.activeTagStack.length - 1]; // Collect text in pattern tag if needed

      if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag) {
        activeTag.collectedPatternTag.text.push(data);
        return;
      } // Save the text inside the active tag


      if (!activeTag.text) {
        activeTag.text = [];
      }

      activeTag.text.push(data);
    }
  }, {
    key: "onTagClose",
    value: function onTagClose() {
      var _this2 = this;

      // Get the active tag
      var activeTag = this.activeTagStack[this.activeTagStack.length - 1];
      var parentTag = this.activeTagStack[this.activeTagStack.length - 2];

      if (!(activeTag.collectChildTags && parentTag.collectChildTags && this.features.skipHandlingXmlLiteralChildren)) {
        // If we detect a finalized rdfa:Pattern tag, store it
        if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag && activeTag.collectedPatternTag.rootPattern) {
          var patternId = activeTag.collectedPatternTag.attributes.resource; // Remove resource and typeof attributes to avoid it being seen as a new pattern

          delete activeTag.collectedPatternTag.attributes.resource;
          delete activeTag.collectedPatternTag.attributes["typeof"]; // Store the pattern

          this.rdfaPatterns[patternId] = activeTag.collectedPatternTag; // Apply all pending copies for this pattern

          if (this.pendingRdfaPatternCopies[patternId]) {
            var _iterator17 = _createForOfIteratorHelper(this.pendingRdfaPatternCopies[patternId]),
                _step17;

            try {
              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                var tag = _step17.value;
                this.emitPatternCopy(tag, activeTag.collectedPatternTag, patternId);
              }
            } catch (err) {
              _iterator17.e(err);
            } finally {
              _iterator17.f();
            }

            delete this.pendingRdfaPatternCopies[patternId];
          } // Remove the active tag from the stack


          this.activeTagStack.pop();
          return;
        } // Emit all triples that were determined in the active tag


        if (activeTag.predicates) {
          var subject = this.util.getResourceOrBaseIri(activeTag.subject, activeTag);
          var textSegments = activeTag.text || [];

          if (activeTag.collectChildTags && parentTag.collectChildTags) {
            // If we are inside an XMLLiteral child that also has RDFa content, ignore the tag name that was collected.
            textSegments = textSegments.slice(1);
          }

          var object = this.util.createLiteral(textSegments.join(''), activeTag);

          if (activeTag.inlist) {
            var _iterator18 = _createForOfIteratorHelper(activeTag.predicates),
                _step18;

            try {
              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                var predicate = _step18.value;
                this.addListMapping(activeTag, subject, predicate, object);
              }
            } catch (err) {
              _iterator18.e(err);
            } finally {
              _iterator18.f();
            }
          } else {
            var _iterator19 = _createForOfIteratorHelper(activeTag.predicates),
                _step19;

            try {
              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                var _predicate12 = _step19.value;
                this.emitTriple(subject, _predicate12, object);
              }
            } catch (err) {
              _iterator19.e(err);
            } finally {
              _iterator19.f();
            }
          } // Reset text, unless the parent is also collecting text


          if (!parentTag.predicates) {
            activeTag.text = null;
          }
        } // 14: Handle local list mapping


        if (activeTag.object && Object.keys(activeTag.listMapping).length > 0) {
          var _subject4 = this.util.getResourceOrBaseIri(activeTag.object, activeTag);

          for (var predicateValue in activeTag.listMapping) {
            var _predicate13 = this.util.dataFactory.namedNode(predicateValue);

            var values = activeTag.listMapping[predicateValue];

            if (values.length > 0) {
              // Non-empty list, emit linked list of rdf:first and rdf:rest chains
              var bnodes = values.map(function () {
                return _this2.util.createBlankNode();
              });

              for (var i = 0; i < values.length; i++) {
                var _object4 = this.util.getResourceOrBaseIri(values[i], activeTag);

                this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util_1.Util.RDF + 'first'), _object4);
                this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util_1.Util.RDF + 'rest'), i < values.length - 1 ? bnodes[i + 1] : this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));
              } // Emit triple for the first linked list chain


              this.emitTriple(_subject4, _predicate13, bnodes[0]);
            } else {
              // Empty list, just emit rdf:nil
              this.emitTriple(_subject4, _predicate13, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));
            }
          }
        }
      } // Remove the active tag from the stack


      this.activeTagStack.pop(); // Save the tag contents if needed

      if (activeTag.collectChildTags && activeTag.text) {
        activeTag.text.push("</".concat(activeTag.name, ">"));
      } // If we still have text contents, try to append it to the parent tag


      if (activeTag.text && parentTag) {
        if (!parentTag.text) {
          parentTag.text = activeTag.text;
        } else {
          parentTag.text = parentTag.text.concat(activeTag.text);
        }
      }
    }
  }, {
    key: "onEnd",
    value: function onEnd() {
      if (this.features.copyRdfaPatterns) {
        this.features.copyRdfaPatterns = false; // Emit all unreferenced patterns

        for (var patternId in this.rdfaPatterns) {
          var pattern = this.rdfaPatterns[patternId];

          if (!pattern.referenced) {
            pattern.attributes["typeof"] = 'rdfa:Pattern';
            pattern.attributes.resource = patternId;
            this.emitPatternCopy(pattern.parentTag, pattern, patternId);
            pattern.referenced = false;
            delete pattern.attributes["typeof"];
            delete pattern.attributes.resource;
          }
        } // Emit all unreferenced copy links


        for (var _patternId in this.pendingRdfaPatternCopies) {
          var _iterator20 = _createForOfIteratorHelper(this.pendingRdfaPatternCopies[_patternId]),
              _step20;

          try {
            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
              var parentTag = _step20.value;
              this.activeTagStack.push(parentTag);
              this.onTagOpen('link', {
                property: 'rdfa:copy',
                href: _patternId
              });
              this.onTagClose();
              this.activeTagStack.pop();
            }
          } catch (err) {
            _iterator20.e(err);
          } finally {
            _iterator20.f();
          }
        }

        this.features.copyRdfaPatterns = true;
      }
    }
    /**
     * If the new subject can be inherited from the parent object
     * if the resource defines no new subject.
     * @param {string} name The current tag name.
     * @returns {boolean} If the subject can be inherited.
     */

  }, {
    key: "isInheritSubjectInHeadBody",
    value: function isInheritSubjectInHeadBody(name) {
      return this.features.inheritSubjectInHeadBody && (name === 'head' || name === 'body');
    }
    /**
     * Add a list mapping for the given predicate and object in the active tag.
     * @param {IActiveTag} activeTag The active tag.
     * @param {Term | boolean} subject A subject term, this will only be used to create a separate list
     *                                 if activeTag.explicitNewSubject is true.
     * @param {Term} predicate A predicate term.
     * @param {Term | boolean} currentObjectResource The current object resource.
     */

  }, {
    key: "addListMapping",
    value: function addListMapping(activeTag, subject, predicate, currentObjectResource) {
      if (activeTag.explicitNewSubject) {
        var bNode = this.util.createBlankNode();
        this.emitTriple(this.util.getResourceOrBaseIri(subject, activeTag), predicate, bNode);
        this.emitTriple(bNode, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'first'), this.util.getResourceOrBaseIri(currentObjectResource, activeTag));
        this.emitTriple(bNode, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'rest'), this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));
      } else {
        var predicateList = activeTag.listMappingLocal[predicate.value];

        if (!predicateList) {
          activeTag.listMappingLocal[predicate.value] = predicateList = [];
        }

        if (currentObjectResource) {
          predicateList.push(currentObjectResource);
        }
      }
    }
    /**
     * Emit the given triple to the stream.
     * @param {Term} subject A subject term.
     * @param {Term} predicate A predicate term.
     * @param {Term} object An object term.
     */

  }, {
    key: "emitTriple",
    value: function emitTriple(subject, predicate, object) {
      // Validate IRIs
      if (subject.termType === 'NamedNode' && subject.value.indexOf(':') < 0 || predicate.termType === 'NamedNode' && predicate.value.indexOf(':') < 0 || object.termType === 'NamedNode' && object.value.indexOf(':') < 0) {
        return;
      }

      this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));
    }
    /**
     * Emit an instantiation of the given pattern with the given parent tag.
     * @param {IActiveTag} parentTag The parent tag to instantiate in.
     * @param {IRdfaPattern} pattern The pattern to instantiate.
     * @param {string} rootPatternId The pattern id.
     */

  }, {
    key: "emitPatternCopy",
    value: function emitPatternCopy(parentTag, pattern, rootPatternId) {
      var _this3 = this;

      this.activeTagStack.push(parentTag);
      pattern.referenced = true; // Ensure that blank nodes within patterns are instantiated only once.
      // All next pattern copies will reuse the instantiated blank nodes from the first pattern.

      if (!pattern.constructedBlankNodes) {
        pattern.constructedBlankNodes = [];

        this.util.blankNodeFactory = function () {
          var bNode = _this3.util.dataFactory.blankNode();

          pattern.constructedBlankNodes.push(bNode);
          return bNode;
        };
      } else {
        var blankNodeIndex = 0;

        this.util.blankNodeFactory = function () {
          return pattern.constructedBlankNodes[blankNodeIndex++];
        };
      } // Apply everything within the pattern


      this.emitPatternCopyAbsolute(pattern, true, rootPatternId);
      this.util.blankNodeFactory = null;
      this.activeTagStack.pop();
    }
    /**
     * Emit an instantiation of the given pattern with the given parent tag.
     *
     * This should probably not be called directly,
     * call {@link emitPatternCopy} instead.
     *
     * @param {IRdfaPattern} pattern The pattern to instantiate.
     * @param {boolean} root If this is the root call for the given pattern.
     * @param {string} rootPatternId The pattern id.
     */

  }, {
    key: "emitPatternCopyAbsolute",
    value: function emitPatternCopyAbsolute(pattern, root, rootPatternId) {
      // Stop on detection of cyclic patterns
      if (!root && pattern.attributes.property === 'rdfa:copy' && pattern.attributes.href === rootPatternId) {
        return;
      }

      this.onTagOpen(pattern.name, pattern.attributes);

      var _iterator21 = _createForOfIteratorHelper(pattern.text),
          _step21;

      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var text = _step21.value;
          this.onText(text);
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }

      var _iterator22 = _createForOfIteratorHelper(pattern.children),
          _step22;

      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var child = _step22.value;
          this.emitPatternCopyAbsolute(child, false, rootPatternId);
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }

      this.onTagClose();
    }
  }, {
    key: "initializeParser",
    value: function initializeParser(xmlMode) {
      var _this4 = this;

      return new htmlparser2_1.Parser({
        onclosetag: function onclosetag() {
          try {
            _this4.onTagClose();

            if (_this4.htmlParseListener) {
              _this4.htmlParseListener.onTagClose();
            }
          } catch (e) {
            _this4.emit('error', e);
          }
        },
        onend: function onend() {
          try {
            _this4.onEnd();

            if (_this4.htmlParseListener) {
              _this4.htmlParseListener.onEnd();
            }
          } catch (e) {
            _this4.emit('error', e);
          }
        },
        onopentag: function onopentag(name, attributes) {
          try {
            _this4.onTagOpen(name, attributes);

            if (_this4.htmlParseListener) {
              _this4.htmlParseListener.onTagOpen(name, attributes);
            }
          } catch (e) {
            _this4.emit('error', e);
          }
        },
        ontext: function ontext(data) {
          try {
            _this4.onText(data);

            if (_this4.htmlParseListener) {
              _this4.htmlParseListener.onText(data);
            }
          } catch (e) {
            _this4.emit('error', e);
          }
        }
      }, {
        decodeEntities: true,
        recognizeSelfClosing: true,
        xmlMode: xmlMode
      });
    }
  }]);
  return RdfaParser;
}(stream_1.Transform);

exports.RdfaParser = RdfaParser;

},{"./RdfaProfile":168,"./Util":169,"./initial-context-xhtml.json":170,"./initial-context.json":171,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/getPrototypeOf":11,"@babel/runtime/helpers/inherits":12,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/possibleConstructorReturn":22,"htmlparser2":87,"stream":191}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RDFA_CONTENTTYPES = exports.RDFA_FEATURES = void 0;
/**
 * A mapping of RDFa profile to a features object.
 */
// tslint:disable:object-literal-sort-keys

exports.RDFA_FEATURES = {
  '': {
    baseTag: true,
    xmlBase: true,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: true,
    inheritSubjectInHeadBody: true,
    datetimeAttribute: true,
    timeTag: true,
    htmlDatatype: true,
    copyRdfaPatterns: true,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: true,
    roleAttribute: true
  },
  'core': {
    baseTag: false,
    xmlBase: false,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: true,
    inheritSubjectInHeadBody: false,
    datetimeAttribute: false,
    timeTag: false,
    htmlDatatype: false,
    copyRdfaPatterns: true,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: false,
    roleAttribute: false
  },
  'html': {
    baseTag: true,
    xmlBase: false,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: true,
    inheritSubjectInHeadBody: true,
    datetimeAttribute: true,
    timeTag: true,
    htmlDatatype: true,
    copyRdfaPatterns: true,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: false,
    roleAttribute: true
  },
  'xhtml': {
    baseTag: true,
    xmlBase: false,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: true,
    inheritSubjectInHeadBody: true,
    datetimeAttribute: true,
    timeTag: true,
    htmlDatatype: true,
    copyRdfaPatterns: true,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: true,
    roleAttribute: true
  },
  'xml': {
    baseTag: false,
    xmlBase: true,
    langAttribute: true,
    onlyAllowUriRelRevIfProperty: false,
    inheritSubjectInHeadBody: false,
    datetimeAttribute: true,
    timeTag: true,
    htmlDatatype: false,
    copyRdfaPatterns: false,
    xmlnsPrefixMappings: true,
    xhtmlInitialContext: false,
    roleAttribute: true
  }
}; // tslint:enable:object-literal-sort-keys
// tslint:disable:object-literal-sort-keys

exports.RDFA_CONTENTTYPES = {
  // HTML
  'text/html': 'html',
  // XHTML
  'application/xhtml+xml': 'xhtml',
  // XML
  'application/xml': 'xml',
  'text/xml': 'xml',
  'image/svg+xml': 'xml'
}; // tslint:enable:object-literal-sort-keys

},{}],169:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Util = void 0;

var relative_to_absolute_iri_1 = require("relative-to-absolute-iri");

var RdfaProfile_1 = require("./RdfaProfile");

var rdf_data_factory_1 = require("rdf-data-factory");
/**
 * A collection of utility functions.
 */


var Util = /*#__PURE__*/function () {
  function Util(dataFactory, baseIRI) {
    (0, _classCallCheck2["default"])(this, Util);
    this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();
    this.baseIRI = this.dataFactory.namedNode(baseIRI || '');
    this.baseIRIDocument = this.baseIRI;
  }
  /**
   * Retrieve the prefixes of the current tag's attributes.
   * @param {{[p: string]: string}} attributes A tag's attributes.
   * @param {{[p: string]: string}} parentPrefixes The prefixes from the parent tag.
   * @param {boolean} xmlnsPrefixMappings If prefixes should be extracted from xmlnsPrefixMappings.
   * @return {{[p: string]: string}} The new prefixes.
   */


  (0, _createClass2["default"])(Util, [{
    key: "getBaseIRI",

    /**
     * Get the base IRI.
     * @param {string} baseIriValue A base IRI value.
     * @return A base IRI named node.
     */
    value: function getBaseIRI(baseIriValue) {
      var href = baseIriValue;
      var fragmentIndex = href.indexOf('#');

      if (fragmentIndex >= 0) {
        href = href.substr(0, fragmentIndex);
      }

      return this.dataFactory.namedNode(relative_to_absolute_iri_1.resolve(href, this.baseIRI.value));
    }
    /**
     * If the term is a boolean, return the baseIRI, otherwise return the term as-is.
     * @param {Term | boolean} term A term or boolean, where the boolean indicates the baseIRI.
     * @param {IActiveTag} activeTag An active tag.
     * @returns {Term} A term.
     */

  }, {
    key: "getResourceOrBaseIri",
    value: function getResourceOrBaseIri(term, activeTag) {
      return term === true ? this.getBaseIriTerm(activeTag) : term;
    }
    /**
     * Get the active base IRI as an RDF term.
     * @param {IActiveTag} activeTag The active tag.
     * @return {NamedNode} The base IRI term.
     */

  }, {
    key: "getBaseIriTerm",
    value: function getBaseIriTerm(activeTag) {
      return activeTag.localBaseIRI || this.baseIRI;
    }
  }, {
    key: "createVocabIris",
    value: function createVocabIris(terms, activeTag, allowTerms, allowBlankNode) {
      var _this = this;

      return terms.split(/\s+/).filter(function (term) {
        return term && (allowTerms || term.indexOf(':') >= 0);
      }).map(function (property) {
        return _this.createIri(property, activeTag, true, true, allowBlankNode);
      }).filter(function (term) {
        return term != null;
      });
    }
    /**
     * Create a new literal node.
     * @param {string} literal The literal value.
     * @param {IActiveTag} activeTag The current active tag.
     * @return {Literal} A new literal node.
     */

  }, {
    key: "createLiteral",
    value: function createLiteral(literal, activeTag) {
      if (activeTag.interpretObjectAsTime && !activeTag.datatype) {
        var _iterator = _createForOfIteratorHelper(Util.TIME_REGEXES),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var entry = _step.value;

            if (literal.match(entry.regex)) {
              activeTag.datatype = this.dataFactory.namedNode(Util.XSD + entry.type);
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return this.dataFactory.literal(literal, activeTag.datatype || activeTag.language);
    }
    /**
     * Create a blank node.
     * @returns {BlankNode} A new blank node.
     */

  }, {
    key: "createBlankNode",
    value: function createBlankNode() {
      if (this.blankNodeFactory) {
        return this.blankNodeFactory();
      }

      return this.dataFactory.blankNode();
    }
  }, {
    key: "createIri",
    value: function createIri(term, activeTag, vocab, allowSafeCurie, allowBlankNode) {
      term = term || '';

      if (!allowSafeCurie) {
        if (!vocab) {
          term = relative_to_absolute_iri_1.resolve(term, this.getBaseIriTerm(activeTag).value);
        }

        if (!Util.isValidIri(term)) {
          return null;
        }

        return this.dataFactory.namedNode(term);
      } // Handle strict CURIEs


      if (term.length > 0 && term[0] === '[' && term[term.length - 1] === ']') {
        term = term.substr(1, term.length - 2); // Strict CURIEs MUST have a prefix separator

        if (term.indexOf(':') < 0) {
          return null;
        }
      } // Handle blank nodes


      if (term.startsWith('_:')) {
        return allowBlankNode ? this.dataFactory.blankNode(term.substr(2) || 'b_identity') : null;
      } // Handle vocab IRIs


      if (vocab) {
        if (activeTag.vocab && term.indexOf(':') < 0) {
          return this.dataFactory.namedNode(activeTag.vocab + term);
        }
      } // Handle prefixed IRIs


      var iri = Util.expandPrefixedTerm(term, activeTag); // Resolve against baseIRI if in base-mode, or if the term was a prefixed relative IRI

      if (!vocab) {
        iri = relative_to_absolute_iri_1.resolve(iri, this.getBaseIriTerm(activeTag).value);
      } else if (term !== iri) {
        iri = relative_to_absolute_iri_1.resolve(iri, this.baseIRIDocument.value);
      }

      if (!Util.isValidIri(iri)) {
        return null;
      }

      return this.dataFactory.namedNode(iri);
    }
  }], [{
    key: "parsePrefixes",
    value: function parsePrefixes(attributes, parentPrefixes, xmlnsPrefixMappings) {
      var additionalPrefixes = {};

      if (xmlnsPrefixMappings) {
        for (var attribute in attributes) {
          if (attribute.startsWith('xmlns')) {
            additionalPrefixes[attribute.substr(6)] = attributes[attribute];
          }
        }
      }

      if (attributes.prefix || Object.keys(additionalPrefixes).length > 0) {
        var prefixes = Object.assign(Object.assign({}, parentPrefixes), additionalPrefixes);

        if (attributes.prefix) {
          var prefixMatch; // tslint:disable-next-line:no-conditional-assignment

          while (prefixMatch = Util.PREFIX_REGEX.exec(attributes.prefix)) {
            prefixes[prefixMatch[1]] = prefixMatch[2];
          }
        }

        return prefixes;
      } else {
        return parentPrefixes;
      }
    }
    /**
     * Expand the given term value based on the given prefixes.
     * @param {string} term A term value.
     * @param {{[p: string]: string}[]} prefixes The available prefixes.
     * @return {string} An expanded URL, or the term as-is.
     */

  }, {
    key: "expandPrefixedTerm",
    value: function expandPrefixedTerm(term, activeTag) {
      // Check if the term is prefixed
      var colonIndex = term.indexOf(':');
      var prefix;
      var local;

      if (colonIndex >= 0) {
        prefix = term.substr(0, colonIndex);
        local = term.substr(colonIndex + 1);
      } // Expand default namespace


      if (prefix === '') {
        return 'http://www.w3.org/1999/xhtml/vocab#' + local;
      } // Try to expand the prefix


      if (prefix) {
        var prefixElement = activeTag.prefixesAll[prefix];

        if (prefixElement) {
          return prefixElement + local;
        }
      } // Try to expand the term


      if (term) {
        var expandedTerm = activeTag.prefixesAll[term.toLocaleLowerCase()];

        if (expandedTerm) {
          return expandedTerm;
        }
      }

      return term;
    }
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */

  }, {
    key: "isValidIri",
    value: function isValidIri(iri) {
      return Util.IRI_REGEX.test(iri);
    }
    /**
     * Determine the RDFa profile from the given content type.
     * Defaults to the default RDFa profile (all features enabled) for unknown content types.
     * @param {string} contentType A content type.
     * @returns {RdfaProfile} An RDFa profile.
     */

  }, {
    key: "contentTypeToProfile",
    value: function contentTypeToProfile(contentType) {
      return RdfaProfile_1.RDFA_CONTENTTYPES[contentType] || '';
    }
  }]);
  return Util;
}();

exports.Util = Util;
Util.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
Util.XSD = 'http://www.w3.org/2001/XMLSchema#';
Util.RDFA = 'http://www.w3.org/ns/rdfa#';
Util.PREFIX_REGEX = /\s*([^:\s]*)*:\s*([^\s]*)*\s*/g;
Util.TIME_REGEXES = [{
  regex: /^-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9])?S)?)?$/,
  type: 'duration'
}, {
  regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
  type: 'dateTime'
}, {
  regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/,
  type: 'date'
}, {
  regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
  type: 'time'
}, {
  regex: /^[0-9]+-[0-9][0-9]$/,
  type: 'gYearMonth'
}, {
  regex: /^[0-9]+$/,
  type: 'gYear'
}];
Util.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`]*$/;

},{"./RdfaProfile":168,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":9,"@babel/runtime/helpers/interopRequireDefault":13,"rdf-data-factory":155,"relative-to-absolute-iri":188}],170:[function(require,module,exports){
module.exports={
  "@context": {
    "alternate": "http://www.w3.org/1999/xhtml/vocab#alternate",
    "appendix": "http://www.w3.org/1999/xhtml/vocab#appendix",
    "cite": "http://www.w3.org/1999/xhtml/vocab#cite",
    "bookmark": "http://www.w3.org/1999/xhtml/vocab#bookmark",
    "contents": "http://www.w3.org/1999/xhtml/vocab#contents",
    "chapter": "http://www.w3.org/1999/xhtml/vocab#chapter",
    "copyright": "http://www.w3.org/1999/xhtml/vocab#copyright",
    "first": "http://www.w3.org/1999/xhtml/vocab#first",
    "glossary": "http://www.w3.org/1999/xhtml/vocab#glossary",
    "help": "http://www.w3.org/1999/xhtml/vocab#help",
    "icon": "http://www.w3.org/1999/xhtml/vocab#icon",
    "index": "http://www.w3.org/1999/xhtml/vocab#index",
    "last": "http://www.w3.org/1999/xhtml/vocab#last",
    "license": "http://www.w3.org/1999/xhtml/vocab#license",
    "meta": "http://www.w3.org/1999/xhtml/vocab#meta",
    "next": "http://www.w3.org/1999/xhtml/vocab#next",
    "prev": "http://www.w3.org/1999/xhtml/vocab#prev",
    "previous": "http://www.w3.org/1999/xhtml/vocab#previous",
    "section": "http://www.w3.org/1999/xhtml/vocab#section",
    "start": "http://www.w3.org/1999/xhtml/vocab#start",
    "stylesheet": "http://www.w3.org/1999/xhtml/vocab#stylesheet",
    "subsection": "http://www.w3.org/1999/xhtml/vocab#subsection",
    "top": "http://www.w3.org/1999/xhtml/vocab#top",
    "up": "http://www.w3.org/1999/xhtml/vocab#up",
    "p3pv1": "http://www.w3.org/1999/xhtml/vocab#p3pv1"
  }
}

},{}],171:[function(require,module,exports){
module.exports={
  "@context": {
    "as": "https://www.w3.org/ns/activitystreams#",
    "cat": "http://www.w3.org/ns/dcat#",
    "cc": "http://creativecommons.org/ns#",
    "cnt": "http://www.w3.org/2008/content#",
    "csvw": "http://www.w3.org/ns/csvw#",
    "ctag": "http://commontag.org/ns#",
    "dc": "http://purl.org/dc/terms/",
    "dc11": "http://purl.org/dc/elements/1.1/",
    "dcat": "http://www.w3.org/ns/dcat#",
    "dcterms": "http://purl.org/dc/terms/",
    "dqv": "http://www.w3.org/ns/dqv#",
    "duv": "https://www.w3.org/TR/vocab-duv#",
    "earl": "http://www.w3.org/ns/earl#",
    "foaf": "http://xmlns.com/foaf/0.1/",
    "gldp": "http://www.w3.org/ns/people#",
    "gr": "http://purl.org/goodrelations/v1#",
    "grddl": "http://www.w3.org/2003/g/data-view#",
    "ht": "http://www.w3.org/2006/http#",
    "ical": "http://www.w3.org/2002/12/cal/icaltzd#",
    "ldp": "http://www.w3.org/ns/ldp#",
    "ma": "http://www.w3.org/ns/ma-ont#",
    "oa": "http://www.w3.org/ns/oa#",
    "odrl": "http://www.w3.org/ns/odrl/2/",
    "og": "http://ogp.me/ns#",
    "org": "http://www.w3.org/ns/org#",
    "owl": "http://www.w3.org/2002/07/owl#",
    "prov": "http://www.w3.org/ns/prov#",
    "ptr": "http://www.w3.org/2009/pointers#",
    "qb": "http://purl.org/linked-data/cube#",
    "rev": "http://purl.org/stuff/rev#",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfa": "http://www.w3.org/ns/rdfa#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "rif": "http://www.w3.org/2007/rif#",
    "rr": "http://www.w3.org/ns/r2rml#",
    "schema": "http://schema.org/",
    "sd": "http://www.w3.org/ns/sparql-service-description#",
    "sioc": "http://rdfs.org/sioc/ns#",
    "skos": "http://www.w3.org/2004/02/skos/core#",
    "skosxl": "http://www.w3.org/2008/05/skos-xl#",
    "ssn": "http://www.w3.org/ns/ssn/",
    "sosa": "http://www.w3.org/ns/sosa/",
    "time": "http://www.w3.org/2006/time#",
    "v": "http://rdf.data-vocabulary.org/#",
    "vcard": "http://www.w3.org/2006/vcard/ns#",
    "void": "http://rdfs.org/ns/void#",
    "wdr": "http://www.w3.org/2007/05/powder#",
    "wdrs": "http://www.w3.org/2007/05/powder-s#",
    "xhv": "http://www.w3.org/1999/xhtml/vocab#",
    "xml": "http://www.w3.org/XML/1998/namespace",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "describedby": "http://www.w3.org/2007/05/powder-s#describedby",
    "license": "http://www.w3.org/1999/xhtml/vocab#license",
    "role": "http://www.w3.org/1999/xhtml/vocab#role"
  }
}

},{}],172:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError = /*#__PURE__*/function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat((0, _typeof2["default"])(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],173:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":175,"./_stream_writable":177,"_process":142,"inherits":89}],174:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":176,"inherits":89}],175:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":172,"./_stream_duplex":173,"./internal/streams/async_iterator":178,"./internal/streams/buffer_list":179,"./internal/streams/destroy":180,"./internal/streams/from":182,"./internal/streams/state":184,"./internal/streams/stream":185,"_process":142,"buffer":60,"events":83,"inherits":89,"string_decoder/":192,"util":58}],176:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

},{"../errors":172,"./_stream_duplex":173,"inherits":89}],177:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options["final"] === 'function') this._final = options["final"];
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":172,"./_stream_duplex":173,"./internal/streams/destroy":180,"./internal/streams/state":184,"./internal/streams/stream":185,"_process":142,"buffer":60,"inherits":89,"util-deprecate":194}],178:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this; // if we have detected an error in the meanwhile
    // reject straight away


    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this; // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to


  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":181,"_process":142}],179:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

},{"buffer":60,"util":58}],180:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

}).call(this)}).call(this,require('_process'))

},{"_process":142}],181:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

},{"../../../errors":172}],182:[function(require,module,exports){
"use strict";

module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};

},{}],183:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

},{"../../../errors":172,"./end-of-stream":181}],184:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

},{"../../../errors":172}],185:[function(require,module,exports){
"use strict";

module.exports = require('events').EventEmitter;

},{"events":83}],186:[function(require,module,exports){
"use strict";

exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":173,"./lib/_stream_passthrough.js":174,"./lib/_stream_readable.js":175,"./lib/_stream_transform.js":176,"./lib/_stream_writable.js":177,"./lib/internal/streams/end-of-stream.js":181,"./lib/internal/streams/pipeline.js":183}],187:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }

  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && (0, _typeof2["default"])(value) === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
(typeof module === "undefined" ? "undefined" : (0, _typeof2["default"])(module)) === "object" ? module.exports : {});

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":27}],188:[function(require,module,exports){
"use strict";

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

__export(require("./lib/Resolve"));

},{"./lib/Resolve":189}],189:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Convert the given relative IRI to an absolute IRI
 * by taking into account the given optional baseIRI.
 *
 * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.
 * @param {string} baseIRI The optional base IRI.
 * @return {string} an absolute IRI.
 */

function resolve(relativeIRI, baseIRI) {
  baseIRI = baseIRI || '';
  var baseFragmentPos = baseIRI.indexOf('#'); // Ignore any fragments in the base IRI

  if (baseFragmentPos > 0) {
    baseIRI = baseIRI.substr(0, baseFragmentPos);
  } // Convert empty value directly to base IRI


  if (!relativeIRI.length) {
    // At this point, the baseIRI MUST be absolute, otherwise we error
    if (baseIRI.indexOf(':') < 0) {
      throw new Error("Found invalid baseIRI '".concat(baseIRI, "' for value '").concat(relativeIRI, "'"));
    }

    return baseIRI;
  } // If the value starts with a query character, concat directly (but strip the existing query)


  if (relativeIRI.startsWith('?')) {
    var baseQueryPos = baseIRI.indexOf('?');

    if (baseQueryPos > 0) {
      baseIRI = baseIRI.substr(0, baseQueryPos);
    }

    return baseIRI + relativeIRI;
  } // If the value starts with a fragment character, concat directly


  if (relativeIRI.startsWith('#')) {
    return baseIRI + relativeIRI;
  } // Ignore baseIRI if it is empty


  if (!baseIRI.length) {
    var relativeColonPos = relativeIRI.indexOf(':');

    if (relativeColonPos < 0) {
      throw new Error("Found invalid relative IRI '".concat(relativeIRI, "' for a missing baseIRI"));
    }

    return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);
  } // Ignore baseIRI if the value is absolute


  var valueColonPos = relativeIRI.indexOf(':');

  if (valueColonPos >= 0) {
    return removeDotSegmentsOfPath(relativeIRI, valueColonPos);
  } // At this point, the baseIRI MUST be absolute, otherwise we error


  var baseColonPos = baseIRI.indexOf(':');

  if (baseColonPos < 0) {
    throw new Error("Found invalid baseIRI '".concat(baseIRI, "' for value '").concat(relativeIRI, "'"));
  }

  var baseIRIScheme = baseIRI.substr(0, baseColonPos + 1); // Inherit the baseIRI scheme if the value starts with '//'

  if (relativeIRI.indexOf('//') === 0) {
    return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
  } // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.


  var baseSlashAfterColonPos;

  if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {
    // If there is no additional '/' after the '//'.
    baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);

    if (baseSlashAfterColonPos < 0) {
      // If something other than a '/' follows the '://', append the value after a '/',
      // otherwise, prefix the value with only the baseIRI scheme.
      if (baseIRI.length > baseColonPos + 3) {
        return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
      } else {
        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
      }
    }
  } else {
    // If there is not even a single '/' after the ':'
    baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);

    if (baseSlashAfterColonPos < 0) {
      // If we don't have a '/' after the ':',
      // prefix the value with only the baseIRI scheme.
      return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
    }
  } // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.


  if (relativeIRI.indexOf('/') === 0) {
    return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);
  }

  var baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);
  var baseIRILastSlashPos = baseIRIPath.lastIndexOf('/'); // Ignore everything after the last '/' in the baseIRI path

  if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {
    baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1); // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')
    // This change is only allowed if there is something else following the path

    if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {
      relativeIRI = relativeIRI.substr(1);
    }
  } // Prefix the value with the baseIRI path where


  relativeIRI = baseIRIPath + relativeIRI; // Remove dot segment from the IRI

  relativeIRI = removeDotSegments(relativeIRI); // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.

  return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;
}

exports.resolve = resolve;
/**
 * Remove dot segments from the given path,
 * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).
 * @param {string} path An IRI path.
 * @return {string} A path, will always start with a '/'.
 */

function removeDotSegments(path) {
  // Prepare a buffer with segments between each '/.
  // Each segment represents an array of characters.
  var segmentBuffers = [];
  var i = 0;

  while (i < path.length) {
    // Remove '/.' or '/..'
    switch (path[i]) {
      case '/':
        if (path[i + 1] === '.') {
          if (path[i + 2] === '.') {
            // Start a new segment if we find an invalid character after the '.'
            if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {
              segmentBuffers.push([]);
              i++;
              break;
            } // Go to parent directory,
            // so we remove a parent segment


            segmentBuffers.pop(); // Ensure that we end with a slash if there is a trailing '/..'

            if (!path[i + 3]) {
              segmentBuffers.push([]);
            }

            i += 3;
          } else {
            // Start a new segment if we find an invalid character after the '.'
            if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {
              segmentBuffers.push([]);
              i++;
              break;
            } // Ensure that we end with a slash if there is a trailing '/.'


            if (!path[i + 2]) {
              segmentBuffers.push([]);
            } // Go to the current directory,
            // so we do nothing


            i += 2;
          }
        } else {
          // Start a new segment
          segmentBuffers.push([]);
          i++;
        }

        break;

      case '#':
      case '?':
        // Query and fragment string should be appended unchanged
        if (!segmentBuffers.length) {
          segmentBuffers.push([]);
        }

        segmentBuffers[segmentBuffers.length - 1].push(path.substr(i)); // Break the while loop

        i = path.length;
        break;

      default:
        // Not a special character, just append it to our buffer
        if (!segmentBuffers.length) {
          segmentBuffers.push([]);
        }

        segmentBuffers[segmentBuffers.length - 1].push(path[i]);
        i++;
        break;
    }
  }

  return '/' + segmentBuffers.map(function (buffer) {
    return buffer.join('');
  }).join('/');
}

exports.removeDotSegments = removeDotSegments;
/**
 * Removes dot segments of the given IRI.
 * @param {string} iri An IRI (or part of IRI).
 * @param {number} colonPosition The position of the first ':' in the IRI.
 * @return {string} The IRI where dot segments were removed.
 */

function removeDotSegmentsOfPath(iri, colonPosition) {
  // Determine where we should start looking for the first '/' that indicates the start of the path
  var searchOffset = colonPosition + 1;

  if (colonPosition >= 0) {
    if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {
      searchOffset = colonPosition + 3;
    }
  } else {
    if (iri[0] === '/' && iri[1] === '/') {
      searchOffset = 2;
    }
  } // Determine the path


  var pathSeparator = iri.indexOf('/', searchOffset);

  if (pathSeparator < 0) {
    return iri;
  }

  var base = iri.substr(0, pathSeparator);
  var path = iri.substr(pathSeparator); // Remove dot segments from the path

  return base + removeDotSegments(path);
}

exports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;

function isCharacterAllowedAfterRelativePathSegment(character) {
  return !character || character === '#' || character === '?' || character === '/';
}

},{}],190:[function(require,module,exports){
"use strict";

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

},{"buffer":60}],191:[function(require,module,exports){
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = require('events').EventEmitter;

var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js');
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js'); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

},{"events":83,"inherits":89,"readable-stream/lib/_stream_duplex.js":173,"readable-stream/lib/_stream_passthrough.js":174,"readable-stream/lib/_stream_readable.js":175,"readable-stream/lib/_stream_transform.js":176,"readable-stream/lib/_stream_writable.js":177,"readable-stream/lib/internal/streams/end-of-stream.js":181,"readable-stream/lib/internal/streams/pipeline.js":183}],192:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(_byte) {
  if (_byte <= 0x7F) return 0;else if (_byte >> 5 === 0x06) return 2;else if (_byte >> 4 === 0x0E) return 3;else if (_byte >> 3 === 0x1E) return 4;
  return _byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD";
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD";
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD";
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":190}],193:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
"use strict";

var nextTick = require('process/browser.js').nextTick;

var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  timeout.close();
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // That's not how node.js implements it but the exposed api is the same.


exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
  immediateIds[id] = true;
  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      } // Prevent ids from leaking


      exports.clearImmediate(id);
    }
  });
  return id;
};
exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
  delete immediateIds[id];
};

}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":142,"timers":193}],194:[function(require,module,exports){
(function (global){(function (){
"use strict";

/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],195:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/_regenerator["default"].mark(function _callee() {
    var walker;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;

          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }

            _context.next = 4;
            return walker.value;

          case 4:
            walker = walker.next;
            _context.next = 1;
            break;

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  });
};

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30}],196:[function(require,module,exports){
'use strict';

module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;

function Yallist(list) {
  var self = this;

  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.splice = function (start, deleteCount
/*, ...nodes */
) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i]);
  }

  return ret;
};

Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  require('./iterator.js')(Yallist);
} catch (er) {}

},{"./iterator.js":195}],197:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Store = require('n3').Store;

var Parser = require('n3').Parser;

var jsonld = require('jsonld');

var Readable = require('stream').Readable;

var RdfaParser = require('rdfa-streaming-parser').RdfaParser;

var MicrodataParser = require('microdata-rdf-streaming-parser').MicrodataRdfParser;

var errors = require('./errors.js');
/**
 * Parses json-ld to quads into the n3.Store
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Promise<Store>}
 */


function parseJsonLd(_x, _x2) {
  return _parseJsonLd.apply(this, arguments);
}
/**
 * Parse RDFa to quads into the n3.Store
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Promise<Store>}
 */


function _parseJsonLd() {
  _parseJsonLd = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(text, baseUrl) {
    var data, nquads;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            data = JSON.parse(text);
            data['@id'] = baseUrl;
            _context.next = 4;
            return jsonld.toRDF(data, {
              format: 'application/n-quads',
              base: baseUrl
            });

          case 4:
            nquads = _context.sent;
            return _context.abrupt("return", parseNQuads(nquads, baseUrl));

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseJsonLd.apply(this, arguments);
}

function parseRdfa(_x3, _x4) {
  return _parseRdfa.apply(this, arguments);
}
/**
 * Parses microdata to quads into the n3.Store
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Promise<Store>}
 */


function _parseRdfa() {
  _parseRdfa = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(text, baseUrl) {
    var textStream;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            textStream = new Readable();
            textStream.push(text);
            textStream.push(null);
            return _context2.abrupt("return", new Promise(function (res, rej) {
              var store = new Store();
              var rdfaParser = new RdfaParser({
                baseIRI: baseUrl,
                contentType: 'text/html'
              });
              textStream.pipe(rdfaParser).on('data', function (quad) {
                store.addQuad(quad);
              }).on('error', function (err) {
                return rej(err);
              }).on('end', function () {
                if (store.getQuads().length === 0) res(undefined);
                res(store);
              });
            }));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseRdfa.apply(this, arguments);
}

function parseMicrodata(_x5, _x6) {
  return _parseMicrodata.apply(this, arguments);
}
/**
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Store}
 */


function _parseMicrodata() {
  _parseMicrodata = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(text, baseUrl) {
    var textStream;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            textStream = new Readable();
            textStream.push(text);
            textStream.push(null);
            return _context3.abrupt("return", new Promise(function (res, rej) {
              var store = new Store();
              var rdfaParser = new MicrodataParser({
                baseIRI: baseUrl
              });
              textStream.pipe(rdfaParser).on('data', function (quad) {
                store.addQuad(quad);
              }).on('error', function (err) {
                return rej(err);
              }).on('end', function () {
                if (store.getQuads().length === 0) res(undefined);
                res(store);
              });
            }));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _parseMicrodata.apply(this, arguments);
}

function parseNQuads(text, baseUrl) {
  var turtleParser = new Parser({
    format: 'application/n-quads',
    baseIRI: baseUrl
  });
  var store = new Store();
  turtleParser.parse(text).forEach(function (quad) {
    store.addQuad(quad);
  });
  return store;
}
/**
 * @param {string} text - input data
 * @param {string} baseUrl - main shape URL
 * @return {Store}
 */


function parseTurtle(text, baseUrl) {
  var turtleParser = new Parser({
    format: 'text/turtle',
    baseIRI: baseUrl
  });
  var store = new Store();
  turtleParser.parse(text).forEach(function (quad) {
    store.addQuad(quad);
  });
  return store;
}
/**
 * Helper for trying to parse input text into a certain format
 * @param {*} parser parser function
 * @returns {Promise<undefined|Store>}
 */


function tryParse(_x7) {
  return _tryParse.apply(this, arguments);
}
/**
 * Transforms input to quads
 * @param {string} text - input data
 * @param {string} url - main shape URL
 * @returns {Promise<Store>}
 */


function _tryParse() {
  _tryParse = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(parser) {
    var quads;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return parser();

          case 3:
            quads = _context4.sent;
            _context4.next = 8;
            break;

          case 6:
            _context4.prev = 6;
            _context4.t0 = _context4["catch"](0);

          case 8:
            return _context4.abrupt("return", quads);

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 6]]);
  }));
  return _tryParse.apply(this, arguments);
}

function stringToQuads(_x8, _x9) {
  return _stringToQuads.apply(this, arguments);
}

function _stringToQuads() {
  _stringToQuads = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(text, url) {
    var jsonParser, microdataParser, rdfaParser, res;
    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            jsonParser = /*#__PURE__*/function () {
              var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
                return _regenerator["default"].wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        _context5.next = 2;
                        return parseJsonLd(text, url);

                      case 2:
                        return _context5.abrupt("return", _context5.sent);

                      case 3:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));

              return function jsonParser() {
                return _ref.apply(this, arguments);
              };
            }();

            microdataParser = /*#__PURE__*/function () {
              var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
                return _regenerator["default"].wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return parseMicrodata(text, url);

                      case 2:
                        return _context6.abrupt("return", _context6.sent);

                      case 3:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));

              return function microdataParser() {
                return _ref2.apply(this, arguments);
              };
            }();

            rdfaParser = /*#__PURE__*/function () {
              var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
                return _regenerator["default"].wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        _context7.next = 2;
                        return parseRdfa(text, url);

                      case 2:
                        return _context7.abrupt("return", _context7.sent);

                      case 3:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7);
              }));

              return function rdfaParser() {
                return _ref3.apply(this, arguments);
              };
            }();

            _context8.next = 5;
            return tryParse(jsonParser);

          case 5:
            _context8.t1 = _context8.sent;

            if (_context8.t1) {
              _context8.next = 10;
              break;
            }

            _context8.next = 9;
            return tryParse(microdataParser);

          case 9:
            _context8.t1 = _context8.sent;

          case 10:
            _context8.t0 = _context8.t1;

            if (_context8.t0) {
              _context8.next = 15;
              break;
            }

            _context8.next = 14;
            return tryParse(rdfaParser);

          case 14:
            _context8.t0 = _context8.sent;

          case 15:
            res = _context8.t0;

            if (!(res === undefined || res.getQuads().length === 0)) {
              _context8.next = 18;
              break;
            }

            throw new errors.InvalidDataError('Error while parsing the data. ' + 'This could be caused by incorrect data or incorrect data format. ' + 'Possible formats: json-ld, microdata, rdfa');

          case 18:
            return _context8.abrupt("return", res);

          case 19:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _stringToQuads.apply(this, arguments);
}

module.exports = {
  parseJsonLd: parseJsonLd,
  parseMicrodata: parseMicrodata,
  parseRdfa: parseRdfa,
  parseNQuads: parseNQuads,
  parseTurtle: parseTurtle,
  stringToQuads: stringToQuads
};

},{"./errors.js":1,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/regenerator":30,"jsonld":107,"microdata-rdf-streaming-parser":114,"n3":135,"rdfa-streaming-parser":163,"stream":191}],198:[function(require,module,exports){
"use strict";

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
module.exports = {
  stringToQuads: require('./parser').stringToQuads,
  parseJsonLd: require('./parser').parseJsonLd,
  parseMicrodata: require('./parser').parseMicrodata,
  parseRdfa: require('./parser').parseRdfa,
  parseNQuads: require('./parser').parseNQuads,
  randomUrl: require('./util').randomUrl,
  quadsToShapes: require('./util').quadsToShapes
};

},{"./parser":197,"./util":199}],199:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var fs = require('fs');

var axios = require('axios');

var jsonld = require('jsonld');

var n3 = require('n3');

var Store = n3.Store;

var RdfaParser = require('rdfa-streaming-parser').RdfaParser;

var errors = require('./errors');
/**
 * Loads related data (shapes, context, etc.) from remote or local source
 * @param {string} link url to the remote source or local path
 * @return {*}
 */


function loadData(_x) {
  return _loadData.apply(this, arguments);
}
/**
 * Removes duplicates from objects array
 * @param {[object]} items
 * @param {[string]} keys
 * @returns {[object]}
 */


function _loadData() {
  _loadData = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(link) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!link.match("^https?://")) {
              _context.next = 4;
              break;
            }

            _context.next = 3;
            return axios.get(link);

          case 3:
            return _context.abrupt("return", _context.sent.data);

          case 4:
            return _context.abrupt("return", fs.readFileSync(link).toString());

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadData.apply(this, arguments);
}

function uniqueBy(items, keys) {
  var seen = {};
  return items.filter(function (item) {
    var val = '';
    keys.forEach(function (key) {
      return val += item[key];
    });
    return seen.hasOwnProperty(val) ? false : seen[val] = true;
  });
}
/**
 *  Generates random URL as base
 *  @param {number} length
 *  @return {string}
 */


function randomUrl() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  var result = 'https://example.org/';
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }

  return result;
}
/**
 * Finds strongly connected components in the data graph
 * @param {Store} store
 * @return {Map<string, number>} - map from subject uris to
 * component ids
 */


function stronglyConnectedComponents(store) {
  var nodes = (0, _toConsumableArray2["default"])(new Set(store.getSubjects().map(function (x) {
    return x.id;
  })));
  var order = [];
  var component = [];
  var componentIdx = 0;
  var components = new Map();
  var used = new Map();

  var forwardDfs = function forwardDfs(v) {
    used.set(v, true);

    var _iterator = _createForOfIteratorHelper(store.getQuads(v, undefined, undefined)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var quad = _step.value;
        if (nodes.includes(quad.object.id) && !used.get(quad.object.id)) forwardDfs(quad.object.id);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    order.push(v);
  };

  var backwardDfs = function backwardDfs(v) {
    used.set(v, true);
    component.push(v);

    var _iterator2 = _createForOfIteratorHelper(store.getQuads(undefined, undefined, v)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var quad = _step2.value;
        if (!used.get(quad.subject.id)) backwardDfs(quad.subject.id);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  };

  var _iterator3 = _createForOfIteratorHelper(nodes),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _node = _step3.value;
      used.set(_node, false);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  var _iterator4 = _createForOfIteratorHelper(nodes),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _node2 = _step4.value;
      if (!used.get(_node2)) forwardDfs(_node2);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  var _iterator5 = _createForOfIteratorHelper(nodes),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _node3 = _step5.value;
      used.set(_node3, false);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  for (var i = 0; i < nodes.length; i++) {
    var node = order[nodes.length - 1 - i];

    if (!used.get(node)) {
      backwardDfs(node);
      component.forEach(function (x) {
        return components.set(x, componentIdx);
      });
      componentIdx++;
      component = [];
    }
  }

  return components;
}
/**
 * Parses quads to multiple stores which represent root nodes
 * in the data graph
 * @param {Store} store
 */


function quadsToShapes(store) {
  var components = stronglyConnectedComponents(store);
  var notRoot = new Set();

  var _iterator6 = _createForOfIteratorHelper(store.getQuads()),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var quad = _step6.value;

      if (components.has(quad.subject.id) && components.has(quad.object.id) && components.get(quad.subject.id) !== components.get(quad.object.id)) {
        notRoot.add(components.get(quad.object.id));
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  var shapes = new Map();

  var _iterator7 = _createForOfIteratorHelper(components.entries()),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _step7$value = (0, _slicedToArray2["default"])(_step7.value, 2),
          node = _step7$value[0],
          component = _step7$value[1];

      if (!notRoot.has(component)) {
        shapes.set(node, getShape(node, store, shapes, []));
        notRoot.add(component);
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return shapes;
}
/**
 * Recursively gets all triples, related to the shape
 * @param {any} id - id of the constructed shape
 * @param {Store} store - store, containing all the triples
 * @param {Map<any, Store>} shapes - map [id -> shape Store]
 * @param {Array<any>} parsed - array for tracking recursive loops
 */


function getShape(id, store, shapes, parsed) {
  var shapeQuads = store.getQuads(id, undefined, undefined);
  if (shapeQuads.length === 0) return;
  parsed.push(id);

  var _iterator8 = _createForOfIteratorHelper(store.getQuads(id, undefined, undefined)),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var quad = _step8.value;

      if (parsed.includes(quad.object.id)) {
        shapeQuads.push(quad);
        continue;
      }

      var nestedStore = void 0;

      if (shapes.get(quad.object)) {
        nestedStore = shapes.get(quad.object.id);
      } else {
        nestedStore = getShape(quad.object.id, store, shapes, parsed);
      }

      if (nestedStore && nestedStore.getQuads().length > 0) {
        shapeQuads.push.apply(shapeQuads, (0, _toConsumableArray2["default"])(nestedStore.getQuads()));
      }
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  var shapeStore = new Store();

  var _iterator9 = _createForOfIteratorHelper(shapeQuads),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var _quad = _step9.value;
      shapeStore.addQuad(_quad);
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  return shapeStore;
}

module.exports = {
  randomUrl: randomUrl,
  loadData: loadData,
  uniqueBy: uniqueBy,
  quadsToShapes: quadsToShapes
};

},{"./errors":1,"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":24,"@babel/runtime/helpers/toConsumableArray":26,"@babel/runtime/regenerator":30,"axios":31,"fs":59,"jsonld":107,"n3":135,"rdfa-streaming-parser":163}]},{},[198])(198)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJlcnJvcnMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm9uaWNhbGl6ZS9saWIvY2Fub25pY2FsaXplLmpzIiwibm9kZV9tb2R1bGVzL2RvbS1zZXJpYWxpemVyL2xpYi9mb3JlaWduTmFtZXMuanMiLCJub2RlX21vZHVsZXMvZG9tLXNlcmlhbGl6ZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbWVsZW1lbnR0eXBlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb21oYW5kbGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb21oYW5kbGVyL2xpYi9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb211dGlscy9saWIvbGVnYWN5LmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9tYW5pcHVsYXRpb24uanMiLCJub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL3F1ZXJ5aW5nLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL3RhZ3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi90cmF2ZXJzYWwuanMiLCJub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZGVjb2RlX2NvZGVwb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvbWFwcy9kZWNvZGUuanNvbiIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9tYXBzL2xlZ2FjeS5qc29uIiwibm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9tYXBzL3htbC5qc29uIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL0ZlZWRIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9QYXJzZXIuanMiLCJub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL1Rva2VuaXplci5qcyIsIm5vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvQ29udGV4dFJlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvSnNvbkxkRXJyb3IuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9Kc29uTGRQcm9jZXNzb3IuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9OUXVhZHMuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9SZGZhLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvUmVxdWVzdFF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvUmVzb2x2ZWRDb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvY29tcGFjdC5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL2NvbnRleHQuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9kb2N1bWVudExvYWRlcnMvbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL2RvY3VtZW50TG9hZGVycy94aHIuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9leHBhbmQuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvZnJhbWUuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi9mcm9tUmRmLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvZ3JhcGhUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL2pzb25sZC5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL25vZGVNYXAuanMiLCJub2RlX21vZHVsZXMvanNvbmxkL2xpYi90b1JkZi5qcyIsIm5vZGVfbW9kdWxlcy9qc29ubGQvbGliL3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvdXJsLmpzIiwibm9kZV9tb2R1bGVzL2pzb25sZC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9kYXRhLXJkZi1zdHJlYW1pbmctcGFyc2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvSUh0bWxQYXJzZUxpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvSUl0ZW1TY29wZS5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb2RhdGEtcmRmLXN0cmVhbWluZy1wYXJzZXIvbGliL0lWb2NhYlJlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvTWljcm9kYXRhUmRmUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb2RhdGEtcmRmLXN0cmVhbWluZy1wYXJzZXIvbGliL3Byb3BlcnR5aGFuZGxlci9JSXRlbVByb3BlcnR5SGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb2RhdGEtcmRmLXN0cmVhbWluZy1wYXJzZXIvbGliL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyQ29udGVudC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb2RhdGEtcmRmLXN0cmVhbWluZy1wYXJzZXIvbGliL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lLmpzIiwibm9kZV9tb2R1bGVzL21pY3JvZGF0YS1yZGYtc3RyZWFtaW5nLXBhcnNlci9saWIvcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwuanMiLCJub2RlX21vZHVsZXMvbWljcm9kYXRhLXJkZi1zdHJlYW1pbmctcGFyc2VyL2xpYi92b2NhYi1yZWdpc3RyeS1kZWZhdWx0Lmpzb24iLCJub2RlX21vZHVsZXMvbjMvbGliL0lSSXMuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL04zRGF0YUZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL04zTGV4ZXIuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL04zUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL24zL2xpYi9OM1N0b3JlLmpzIiwibm9kZV9tb2R1bGVzL24zL2xpYi9OM1N0cmVhbVBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9uMy9saWIvTjNTdHJlYW1Xcml0ZXIuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL04zVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9uMy9saWIvTjNXcml0ZXIuanMiLCJub2RlX21vZHVsZXMvbjMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Jhc2VOLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2ZvcmdlLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21kLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3NoYTEuanMiLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvc2hhMjU2LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXVlLW1pY3JvdGFzay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL0FzeW5jQWxnb3JpdGhtLmpzIiwibm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvSWRlbnRpZmllcklzc3Vlci5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL01lc3NhZ2VEaWdlc3QtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL05RdWFkcy5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL1Blcm11dGF0b3IuanMiLCJub2RlX21vZHVsZXMvcmRmLWNhbm9uaXplL2xpYi9VUkROQTIwMTUuanMiLCJub2RlX21vZHVsZXMvcmRmLWNhbm9uaXplL2xpYi9VUkROQTIwMTVTeW5jLmpzIiwibm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvVVJHTkEyMDEyLmpzIiwibm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvVVJHTkEyMDEyU3luYy5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JkZi1kYXRhLWZhY3RvcnkvbGliL0JsYW5rTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2xpYi9EYXRhRmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2xpYi9EZWZhdWx0R3JhcGguanMiLCJub2RlX21vZHVsZXMvcmRmLWRhdGEtZmFjdG9yeS9saWIvTGl0ZXJhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2xpYi9OYW1lZE5vZGUuanMiLCJub2RlX21vZHVsZXMvcmRmLWRhdGEtZmFjdG9yeS9saWIvUXVhZC5qcyIsIm5vZGVfbW9kdWxlcy9yZGYtZGF0YS1mYWN0b3J5L2xpYi9WYXJpYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZGZhLXN0cmVhbWluZy1wYXJzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmRmYS1zdHJlYW1pbmctcGFyc2VyL2xpYi9JQWN0aXZlVGFnLmpzIiwibm9kZV9tb2R1bGVzL3JkZmEtc3RyZWFtaW5nLXBhcnNlci9saWIvSVJkZmFQYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL3JkZmEtc3RyZWFtaW5nLXBhcnNlci9saWIvUmRmYVBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9yZGZhLXN0cmVhbWluZy1wYXJzZXIvbGliL1JkZmFQcm9maWxlLmpzIiwibm9kZV9tb2R1bGVzL3JkZmEtc3RyZWFtaW5nLXBhcnNlci9saWIvVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9yZGZhLXN0cmVhbWluZy1wYXJzZXIvbGliL2luaXRpYWwtY29udGV4dC14aHRtbC5qc29uIiwibm9kZV9tb2R1bGVzL3JkZmEtc3RyZWFtaW5nLXBhcnNlci9saWIvaW5pdGlhbC1jb250ZXh0Lmpzb24iLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL3JlbGF0aXZlLXRvLWFic29sdXRlLWlyaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWxhdGl2ZS10by1hYnNvbHV0ZS1pcmkvbGliL1Jlc29sdmUuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy95YWxsaXN0L2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsInBhcnNlci5qcyIsInBhcnNpbmctaW5kZXguanMiLCJ1dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ00sZ0I7Ozs7O0FBQ0YsNEJBQVksT0FBWixFQUFxQjtBQUFBOztBQUFBO0FBQ2pCLDhCQUFNLE9BQU47QUFDQSxVQUFLLElBQUwsR0FBWSxrQkFBWjtBQUZpQjtBQUdwQjs7O2tEQUowQixLOztJQU96QixtQjs7Ozs7QUFDRiwrQkFBWSxPQUFaLEVBQXFCO0FBQUE7O0FBQUE7QUFDakIsZ0NBQU0sT0FBTjtBQUNBLFdBQUssSUFBTCxHQUFZLHFCQUFaO0FBRmlCO0FBR3BCOzs7a0RBSjZCLEs7O0FBT2xDLE1BQU0sQ0FBQyxPQUFQLEdBQWlCO0FBQ2IsRUFBQSxnQkFBZ0IsRUFBRSxnQkFETDtBQUViLEVBQUEsbUJBQW1CLEVBQUU7QUFGUixDQUFqQjs7Ozs7QUM3QkEsU0FBUyxp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QUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRztBQUFoQyxDQUFuQztBQUNBLElBQUksa0JBQWtCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUEvQztBQUNBLElBQUksa0JBQWtCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUEvQztBQUNBLElBQUksa0JBQWtCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUEvQztBQUNBLElBQUksa0JBQWtCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUEvQztBQUNBLElBQUksaUJBQWlCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRTtBQUEvQixDQUFuQztBQUNBLElBQUksaUJBQWlCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRTtBQUEvQixDQUFuQztBQUNBLElBQUksaUJBQWlCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRTtBQUEvQixDQUFuQztBQUNBLElBQUksaUJBQWlCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNkI7QUFBRTtBQUEvQixDQUFuQztBQUNBLElBQUksaUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUE5QztBQUNBLElBQUksaUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUE5QztBQUNBLElBQUksaUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUE5QztBQUNBLElBQUksZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7QUFBRTtBQUE5QixDQUFsQztBQUNBLElBQUksZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7QUFBRTtBQUE5QixDQUFsQztBQUNBLElBQUksZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7QUFBRTtBQUE5QixDQUFsQztBQUNBLElBQUksbUJBQW1CLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUFoRDtBQUNBLElBQUksaUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUE5QztBQUNBLElBQUksaUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUE5QztBQUNBLElBQUksaUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRCxFQUFNO0FBQUc7QUFBVCxDQUE5QztBQUNBLElBQUkscUJBQXFCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7QUFBRTtBQUE5QixDQUF2QztBQUNBLElBQUksZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7QUFBRTtBQUE5QixDQUFsQztBQUNBLElBQUksZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7QUFBRTtBQUE5QixDQUFsQztBQUNBLElBQUksZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7QUFBRTtBQUE5QixDQUFsQztBQUNBLElBQUksaUJBQWlCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBb0M7QUFBRztBQUF2QyxDQUFuQztBQUNBLElBQUksd0JBQXdCLEdBQUcsV0FBVyxDQUFDLEdBQUQsRUFBTTtBQUFHO0FBQVQsRUFBNEI7QUFBRztBQUEvQixDQUExQzs7QUFDQSxJQUFJLFNBQVM7QUFBRztBQUFlLFlBQVk7QUFDdkMsV0FBUyxTQUFULENBQW1CLE9BQW5CLEVBQTRCLEdBQTVCLEVBQWlDO0FBQzdCLFFBQUksRUFBSjtBQUNBOzs7QUFDQSxTQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0E7O0FBQ0EsU0FBSyxNQUFMLEdBQWMsRUFBZDtBQUNBOztBQUNBLFNBQUssWUFBTCxHQUFvQixDQUFwQjtBQUNBOztBQUNBLFNBQUssTUFBTCxHQUFjLENBQWQ7QUFDQTtBQUNSO0FBQ0E7QUFDQTs7QUFDUSxTQUFLLFlBQUwsR0FBb0IsQ0FBcEI7QUFDQTs7QUFDQSxTQUFLLFNBQUwsR0FBaUI7QUFBRTtBQUFuQjtBQUNBOztBQUNBLFNBQUssT0FBTCxHQUFlO0FBQUU7QUFBakI7QUFDQTs7QUFDQSxTQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0E7O0FBQ0EsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLFNBQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxTQUFLLE9BQUwsR0FBZSxDQUFDLEVBQUUsT0FBTyxLQUFLLElBQVosSUFBb0IsT0FBTyxLQUFLLEtBQUssQ0FBckMsR0FBeUMsS0FBSyxDQUE5QyxHQUFrRCxPQUFPLENBQUMsT0FBNUQsQ0FBaEI7QUFDQSxTQUFLLGNBQUwsR0FBc0IsQ0FBQyxFQUFFLEdBQUcsT0FBTyxLQUFLLElBQVosSUFBb0IsT0FBTyxLQUFLLEtBQUssQ0FBckMsR0FBeUMsS0FBSyxDQUE5QyxHQUFrRCxPQUFPLENBQUMsY0FBaEUsTUFBb0YsSUFBcEYsSUFBNEYsRUFBRSxLQUFLLEtBQUssQ0FBeEcsR0FBNEcsRUFBNUcsR0FBaUgsSUFBdkk7QUFDSDs7QUFDRCxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLEtBQXBCLEdBQTRCLFlBQVk7QUFDcEMsU0FBSyxNQUFMLEdBQWM7QUFBRTtBQUFoQjtBQUNBLFNBQUssTUFBTCxHQUFjLEVBQWQ7QUFDQSxTQUFLLFlBQUwsR0FBb0IsQ0FBcEI7QUFDQSxTQUFLLE1BQUwsR0FBYyxDQUFkO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLENBQXBCO0FBQ0EsU0FBSyxTQUFMLEdBQWlCO0FBQUU7QUFBbkI7QUFDQSxTQUFLLE9BQUwsR0FBZTtBQUFFO0FBQWpCO0FBQ0EsU0FBSyxPQUFMLEdBQWUsSUFBZjtBQUNBLFNBQUssS0FBTCxHQUFhLEtBQWI7QUFDSCxHQVZEOztBQVdBLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsS0FBcEIsR0FBNEIsVUFBVSxLQUFWLEVBQWlCO0FBQ3pDLFFBQUksS0FBSyxLQUFULEVBQ0ksS0FBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixLQUFLLENBQUMsc0JBQUQsQ0FBdEI7QUFDSixTQUFLLE1BQUwsSUFBZSxLQUFmO0FBQ0EsU0FBSyxLQUFMO0FBQ0gsR0FMRDs7QUFNQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLEdBQXBCLEdBQTBCLFVBQVUsS0FBVixFQUFpQjtBQUN2QyxRQUFJLEtBQUssS0FBVCxFQUNJLEtBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsS0FBSyxDQUFDLG9CQUFELENBQXRCO0FBQ0osUUFBSSxLQUFKLEVBQ0ksS0FBSyxLQUFMLENBQVcsS0FBWDtBQUNKLFNBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxRQUFJLEtBQUssT0FBVCxFQUNJLEtBQUssTUFBTDtBQUNQLEdBUkQ7O0FBU0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixLQUFwQixHQUE0QixZQUFZO0FBQ3BDLFNBQUssT0FBTCxHQUFlLEtBQWY7QUFDSCxHQUZEOztBQUdBLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsTUFBcEIsR0FBNkIsWUFBWTtBQUNyQyxTQUFLLE9BQUwsR0FBZSxJQUFmOztBQUNBLFFBQUksS0FBSyxNQUFMLEdBQWMsS0FBSyxNQUFMLENBQVksTUFBOUIsRUFBc0M7QUFDbEMsV0FBSyxLQUFMO0FBQ0g7O0FBQ0QsUUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDWixXQUFLLE1BQUw7QUFDSDtBQUNKLEdBUkQ7QUFTQTtBQUNKO0FBQ0E7OztBQUNJLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsZ0JBQXBCLEdBQXVDLFlBQVk7QUFDL0MsV0FBTyxLQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUFoQztBQUNILEdBRkQ7O0FBR0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixTQUFwQixHQUFnQyxVQUFVLENBQVYsRUFBYTtBQUN6QyxRQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDWCxVQUFJLEtBQUssTUFBTCxHQUFjLEtBQUssWUFBdkIsRUFBcUM7QUFDakMsYUFBSyxHQUFMLENBQVMsTUFBVCxDQUFnQixLQUFLLFVBQUwsRUFBaEI7QUFDSDs7QUFDRCxXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBekI7QUFDSCxLQU5ELE1BT0ssSUFBSSxLQUFLLGNBQUwsSUFDTCxDQUFDLEtBQUssR0FERCxLQUVKLEtBQUssT0FBTCxLQUFpQjtBQUFFO0FBQW5CLE9BQWlDLEtBQUssT0FBTCxLQUFpQjtBQUFFO0FBRmhELEtBQUosRUFFa0U7QUFDbkUsVUFBSSxLQUFLLE1BQUwsR0FBYyxLQUFLLFlBQXZCLEVBQXFDO0FBQ2pDLGFBQUssR0FBTCxDQUFTLE1BQVQsQ0FBZ0IsS0FBSyxVQUFMLEVBQWhCO0FBQ0g7O0FBQ0QsV0FBSyxTQUFMLEdBQWlCO0FBQUU7QUFBbkI7QUFDQSxXQUFLLE1BQUwsR0FBYztBQUFHO0FBQWpCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBekI7QUFDSDtBQUNKLEdBbEJEOztBQW1CQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLGtCQUFwQixHQUF5QyxVQUFVLENBQVYsRUFBYTtBQUNsRCxRQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDWCxXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0gsS0FGRCxNQUdLLElBQUksQ0FBQyxLQUFLLEdBQVYsRUFBZTtBQUNoQixXQUFLLEdBQUwsQ0FBUyxNQUFULENBQWdCLEtBQUssVUFBTCxFQUFoQjtBQUNBLFdBQUssWUFBTCxHQUFvQixLQUFLLE1BQXpCO0FBQ0gsS0FISSxNQUlBLElBQUksQ0FBQyxLQUFLLEdBQU4sSUFDTCxLQUFLLE9BQUwsS0FBaUI7QUFBRTtBQURkLE9BRUwsVUFBVSxDQUFDLENBQUQsQ0FGVCxFQUVjO0FBQ2YsV0FBSyxNQUFMLEdBQWM7QUFBRTtBQUFoQjtBQUNILEtBSkksTUFLQSxJQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDaEIsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNBLFdBQUssWUFBTCxHQUFvQixLQUFLLE1BQUwsR0FBYyxDQUFsQztBQUNILEtBSEksTUFJQSxJQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDaEIsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNBLFdBQUssWUFBTCxHQUFvQixLQUFLLE1BQUwsR0FBYyxDQUFsQztBQUNILEtBSEksTUFJQSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUQsQ0FBakIsRUFBc0I7QUFDdkIsV0FBSyxNQUFMLEdBQWM7QUFBRTtBQUFoQjtBQUNILEtBRkksTUFHQTtBQUNELFdBQUssTUFBTCxHQUNJLENBQUMsS0FBSyxPQUFOLEtBQWtCLENBQUMsS0FBSyxHQUFOLElBQWEsQ0FBQyxLQUFLLEdBQXJDLElBQ007QUFBRztBQURULFFBRU0sQ0FBQyxLQUFLLE9BQU4sS0FBa0IsQ0FBQyxLQUFLLEdBQU4sSUFBYSxDQUFDLEtBQUssR0FBckMsSUFDSTtBQUFHO0FBRFAsUUFFSTtBQUFFO0FBTGhCO0FBTUEsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBekI7QUFDSDtBQUNKLEdBakNEOztBQWtDQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLGNBQXBCLEdBQXFDLFVBQVUsQ0FBVixFQUFhO0FBQzlDLFFBQUksQ0FBQyxLQUFLLEdBQU4sSUFBYSxDQUFDLEtBQUssR0FBbkIsSUFBMEIsVUFBVSxDQUFDLENBQUQsQ0FBeEMsRUFBNkM7QUFDekMsV0FBSyxTQUFMLENBQWUsZUFBZjtBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLE1BQUw7QUFDSDtBQUNKLEdBTkQ7O0FBT0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQix5QkFBcEIsR0FBZ0QsVUFBVSxDQUFWLEVBQWE7QUFDekQsUUFBSSxVQUFVLENBQUMsQ0FBRCxDQUFkLEVBQW1CLENBQ2Y7QUFDSCxLQUZELE1BR0ssSUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ2hCLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDSCxLQUZJLE1BR0EsSUFBSSxLQUFLLE9BQUwsS0FBaUI7QUFBRTtBQUF2QixNQUFtQztBQUNwQyxZQUFJLENBQUMsS0FBSyxHQUFOLElBQWEsQ0FBQyxLQUFLLEdBQXZCLEVBQTRCO0FBQ3hCLGVBQUssTUFBTCxHQUFjO0FBQUc7QUFBakI7QUFDSCxTQUZELE1BR0ssSUFBSSxDQUFDLEtBQUssR0FBTixJQUFhLENBQUMsS0FBSyxHQUF2QixFQUE0QjtBQUM3QixlQUFLLE1BQUwsR0FBYztBQUFHO0FBQWpCO0FBQ0gsU0FGSSxNQUdBO0FBQ0QsZUFBSyxNQUFMLEdBQWM7QUFBRTtBQUFoQjtBQUNBLGVBQUssTUFBTDtBQUNIO0FBQ0osT0FYSSxNQVlBLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBRCxDQUFqQixFQUFzQjtBQUN2QixXQUFLLE1BQUwsR0FBYztBQUFHO0FBQWpCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBekI7QUFDSCxLQUhJLE1BSUE7QUFDRCxXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBekI7QUFDSDtBQUNKLEdBM0JEOztBQTRCQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLHFCQUFwQixHQUE0QyxVQUFVLENBQVYsRUFBYTtBQUNyRCxRQUFJLENBQUMsS0FBSyxHQUFOLElBQWEsVUFBVSxDQUFDLENBQUQsQ0FBM0IsRUFBZ0M7QUFDNUIsV0FBSyxTQUFMLENBQWUsWUFBZjtBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLE1BQUw7QUFDSDtBQUNKLEdBTkQ7O0FBT0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQix3QkFBcEIsR0FBK0MsVUFBVSxDQUFWLEVBQWE7QUFDeEQ7QUFDQSxRQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDWCxXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBTCxHQUFjLENBQWxDO0FBQ0g7QUFDSixHQU5EOztBQU9BLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0Isd0JBQXBCLEdBQStDLFVBQVUsQ0FBVixFQUFhO0FBQ3hELFFBQUksQ0FBQyxLQUFLLEdBQVYsRUFBZTtBQUNYLFdBQUssR0FBTCxDQUFTLFlBQVQ7QUFDQSxXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBTCxHQUFjLENBQWxDO0FBQ0gsS0FKRCxNQUtLLElBQUksQ0FBQyxLQUFLLEdBQVYsRUFBZTtBQUNoQixXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0gsS0FGSSxNQUdBLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBRCxDQUFmLEVBQW9CO0FBQ3JCLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUF6QjtBQUNIO0FBQ0osR0FiRDs7QUFjQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLHFCQUFwQixHQUE0QyxVQUFVLENBQVYsRUFBYTtBQUNyRCxRQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDWCxXQUFLLEdBQUwsQ0FBUyxnQkFBVDtBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUFMLEdBQWMsQ0FBbEM7QUFDQSxXQUFLLE9BQUwsR0FBZTtBQUFFO0FBQWpCLE9BSlcsQ0FJa0I7QUFDaEMsS0FMRCxNQU1LLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBRCxDQUFmLEVBQW9CO0FBQ3JCLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLE1BQUw7QUFDSDtBQUNKLEdBWEQ7O0FBWUEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixvQkFBcEIsR0FBMkMsVUFBVSxDQUFWLEVBQWE7QUFDcEQsUUFBSSxDQUFDLEtBQUssR0FBTixJQUFhLENBQUMsS0FBSyxHQUFuQixJQUEwQixDQUFDLEtBQUssR0FBaEMsSUFBdUMsVUFBVSxDQUFDLENBQUQsQ0FBckQsRUFBMEQ7QUFDdEQsV0FBSyxHQUFMLENBQVMsWUFBVCxDQUFzQixLQUFLLFVBQUwsRUFBdEI7QUFDQSxXQUFLLFlBQUwsR0FBb0IsQ0FBQyxDQUFyQjtBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUc7QUFBakI7QUFDQSxXQUFLLE1BQUw7QUFDSDtBQUNKLEdBUEQ7O0FBUUEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQix1QkFBcEIsR0FBOEMsVUFBVSxDQUFWLEVBQWE7QUFDdkQsUUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ1gsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNILEtBRkQsTUFHSyxJQUFJLENBQUMsS0FBSyxHQUFOLElBQWEsQ0FBQyxLQUFLLEdBQXZCLEVBQTRCO0FBQzdCLFdBQUssR0FBTCxDQUFTLFdBQVQsQ0FBcUIsU0FBckI7QUFDQSxXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0EsV0FBSyxNQUFMO0FBQ0gsS0FKSSxNQUtBLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBRCxDQUFmLEVBQW9CO0FBQ3JCLFdBQUssR0FBTCxDQUFTLFdBQVQsQ0FBcUIsU0FBckI7QUFDQSxXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBekI7QUFDSDtBQUNKLEdBZEQ7O0FBZUEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQix5QkFBcEIsR0FBZ0QsVUFBVSxDQUFWLEVBQWE7QUFDekQsUUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ1gsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNBLFdBQUssWUFBTCxHQUFvQixLQUFLLE1BQUwsR0FBYyxDQUFsQztBQUNILEtBSEQsTUFJSyxJQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDaEIsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNBLFdBQUssWUFBTCxHQUFvQixLQUFLLE1BQUwsR0FBYyxDQUFsQztBQUNILEtBSEksTUFJQSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUQsQ0FBZixFQUFvQjtBQUNyQixXQUFLLE1BQUwsR0FBYztBQUFHO0FBQWpCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBekI7QUFDQSxXQUFLLE1BQUwsR0FIcUIsQ0FHTjtBQUNsQjtBQUNKLEdBZEQ7O0FBZUEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixzQkFBcEIsR0FBNkMsVUFBVSxDQUFWLEVBQWEsS0FBYixFQUFvQjtBQUM3RCxRQUFJLENBQUMsS0FBSyxLQUFWLEVBQWlCO0FBQ2IsV0FBSyxTQUFMLENBQWUsY0FBZjtBQUNBLFdBQUssR0FBTCxDQUFTLFdBQVQsQ0FBcUIsS0FBckI7QUFDQSxXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0gsS0FKRCxNQUtLLElBQUksS0FBSyxjQUFMLElBQXVCLENBQUMsS0FBSyxHQUFqQyxFQUFzQztBQUN2QyxXQUFLLFNBQUwsQ0FBZSxjQUFmO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLEtBQUssTUFBdEI7QUFDQSxXQUFLLE1BQUwsR0FBYztBQUFHO0FBQWpCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBekI7QUFDSDtBQUNKLEdBWkQ7O0FBYUEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixpQ0FBcEIsR0FBd0QsVUFBVSxDQUFWLEVBQWE7QUFDakUsU0FBSyxzQkFBTCxDQUE0QixDQUE1QixFQUErQixHQUEvQjtBQUNILEdBRkQ7O0FBR0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixpQ0FBcEIsR0FBd0QsVUFBVSxDQUFWLEVBQWE7QUFDakUsU0FBSyxzQkFBTCxDQUE0QixDQUE1QixFQUErQixHQUEvQjtBQUNILEdBRkQ7O0FBR0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQiw2QkFBcEIsR0FBb0QsVUFBVSxDQUFWLEVBQWE7QUFDN0QsUUFBSSxVQUFVLENBQUMsQ0FBRCxDQUFWLElBQWlCLENBQUMsS0FBSyxHQUEzQixFQUFnQztBQUM1QixXQUFLLFNBQUwsQ0FBZSxjQUFmO0FBQ0EsV0FBSyxHQUFMLENBQVMsV0FBVCxDQUFxQixJQUFyQjtBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLE1BQUw7QUFDSCxLQUxELE1BTUssSUFBSSxLQUFLLGNBQUwsSUFBdUIsQ0FBQyxLQUFLLEdBQWpDLEVBQXNDO0FBQ3ZDLFdBQUssU0FBTCxDQUFlLGNBQWY7QUFDQSxXQUFLLFNBQUwsR0FBaUIsS0FBSyxNQUF0QjtBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUc7QUFBakI7QUFDQSxXQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUF6QjtBQUNIO0FBQ0osR0FiRDs7QUFjQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLHNCQUFwQixHQUE2QyxVQUFVLENBQVYsRUFBYTtBQUN0RCxTQUFLLE1BQUwsR0FDSSxDQUFDLEtBQUssR0FBTixHQUNNO0FBQUc7QUFEVCxNQUVNLENBQUMsS0FBSyxHQUFOLEdBQ0k7QUFBRztBQURQLE1BRUk7QUFBRztBQUxqQjtBQU1ILEdBUEQ7O0FBUUEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixrQkFBcEIsR0FBeUMsVUFBVSxDQUFWLEVBQWE7QUFDbEQsUUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ1gsV0FBSyxHQUFMLENBQVMsYUFBVCxDQUF1QixLQUFLLFVBQUwsRUFBdkI7QUFDQSxXQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBTCxHQUFjLENBQWxDO0FBQ0g7QUFDSixHQU5EOztBQU9BLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsNEJBQXBCLEdBQW1ELFVBQVUsQ0FBVixFQUFhO0FBQzVELFFBQUksQ0FBQyxLQUFLLEdBQVYsRUFBZTtBQUNYLFdBQUssR0FBTCxDQUFTLHVCQUFULENBQWlDLEtBQUssVUFBTCxFQUFqQztBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUFMLEdBQWMsQ0FBbEM7QUFDSDtBQUNKLEdBTkQ7O0FBT0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixrQkFBcEIsR0FBeUMsVUFBVSxDQUFWLEVBQWE7QUFDbEQsUUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ1gsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNBLFdBQUssWUFBTCxHQUFvQixLQUFLLE1BQUwsR0FBYyxDQUFsQztBQUNILEtBSEQsTUFJSztBQUNELFdBQUssTUFBTCxHQUFjO0FBQUc7QUFBakI7QUFDSDtBQUNKLEdBUkQ7O0FBU0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixjQUFwQixHQUFxQyxVQUFVLENBQVYsRUFBYTtBQUM5QyxRQUFJLENBQUMsS0FBSyxHQUFWLEVBQ0ksS0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNQLEdBSEQ7O0FBSUEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixxQkFBcEIsR0FBNEMsVUFBVSxDQUFWLEVBQWE7QUFDckQsUUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ1gsV0FBSyxHQUFMLENBQVMsU0FBVCxDQUFtQixLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLEtBQUssWUFBM0IsRUFBeUMsS0FBSyxNQUE5QyxDQUFuQjtBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUFMLEdBQWMsQ0FBbEM7QUFDSDtBQUNKLEdBTkQ7O0FBT0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixrQkFBcEIsR0FBeUMsVUFBVSxDQUFWLEVBQWE7QUFDbEQsUUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ1gsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNILEtBRkQsTUFHSztBQUNELFdBQUssTUFBTCxHQUFjO0FBQUc7QUFBakI7QUFDSDtBQUNKLEdBUEQ7O0FBUUEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixrQkFBcEIsR0FBeUMsVUFBVSxDQUFWLEVBQWE7QUFDbEQsUUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ1g7QUFDQSxXQUFLLEdBQUwsQ0FBUyxTQUFULENBQW1CLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsS0FBSyxZQUEzQixFQUF5QyxLQUFLLE1BQUwsR0FBYyxDQUF2RCxDQUFuQjtBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUFMLEdBQWMsQ0FBbEM7QUFDSCxLQUxELE1BTUssSUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ2hCLFdBQUssTUFBTCxHQUFjO0FBQUc7QUFBakI7QUFDSCxLQVRpRCxDQVVsRDs7QUFDSCxHQVhEOztBQVlBLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsaUJBQXBCLEdBQXdDLFVBQVUsQ0FBVixFQUFhO0FBQ2pELFFBQUksQ0FBQyxLQUFLLEdBQVYsRUFBZTtBQUNYLFdBQUssTUFBTCxHQUFjO0FBQUc7QUFBakI7QUFDQSxXQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUFMLEdBQWMsQ0FBbEM7QUFDSCxLQUhELE1BSUs7QUFDRCxXQUFLLE1BQUwsR0FBYztBQUFHO0FBQWpCO0FBQ0EsV0FBSyxNQUFMO0FBQ0g7QUFDSixHQVREOztBQVVBLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsWUFBcEIsR0FBbUMsVUFBVSxDQUFWLEVBQWE7QUFDNUMsUUFBSSxDQUFDLEtBQUssR0FBVixFQUNJLEtBQUssTUFBTCxHQUFjO0FBQUc7QUFBakI7QUFDUCxHQUhEOztBQUlBLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsZ0JBQXBCLEdBQXVDLFVBQVUsQ0FBVixFQUFhO0FBQ2hELFFBQUksQ0FBQyxLQUFLLEdBQVYsRUFDSSxLQUFLLE1BQUwsR0FBYztBQUFHO0FBQWpCLEtBREosS0FHSSxLQUFLLE1BQUwsR0FBYztBQUFHO0FBQWpCO0FBQ1AsR0FMRDs7QUFNQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLGdCQUFwQixHQUF1QyxVQUFVLENBQVYsRUFBYTtBQUNoRCxRQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDWDtBQUNBLFdBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixLQUFLLFlBQTNCLEVBQXlDLEtBQUssTUFBTCxHQUFjLENBQXZELENBQWpCO0FBQ0EsV0FBSyxNQUFMLEdBQWM7QUFBRTtBQUFoQjtBQUNBLFdBQUssWUFBTCxHQUFvQixLQUFLLE1BQUwsR0FBYyxDQUFsQztBQUNILEtBTEQsTUFNSyxJQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDaEIsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNILEtBVCtDLENBVWhEOztBQUNILEdBWEQ7O0FBWUEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixtQkFBcEIsR0FBMEMsVUFBVSxDQUFWLEVBQWE7QUFDbkQsUUFBSSxDQUFDLEtBQUssR0FBTixJQUFhLENBQUMsS0FBSyxHQUF2QixFQUE0QjtBQUN4QixXQUFLLE1BQUwsR0FBYztBQUFHO0FBQWpCO0FBQ0gsS0FGRCxNQUdLLElBQUksQ0FBQyxLQUFLLEdBQU4sSUFBYSxDQUFDLEtBQUssR0FBdkIsRUFBNEI7QUFDN0IsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNILEtBRkksTUFHQTtBQUNELFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLE1BQUwsR0FGQyxDQUVjO0FBQ2xCO0FBQ0osR0FYRDs7QUFZQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLHNCQUFwQixHQUE2QyxVQUFVLENBQVYsRUFBYTtBQUN0RCxRQUFJLEtBQUssT0FBTCxLQUFpQjtBQUFFO0FBQW5CLFFBQW9DLENBQUMsS0FBSyxHQUFOLElBQWEsQ0FBQyxLQUFLLEdBQXZELENBQUosRUFBaUU7QUFDN0QsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNILEtBRkQsTUFHSyxJQUFJLEtBQUssT0FBTCxLQUFpQjtBQUFFO0FBQW5CLFFBQW1DLENBQUMsS0FBSyxHQUFOLElBQWEsQ0FBQyxLQUFLLEdBQXRELENBQUosRUFBZ0U7QUFDakUsV0FBSyxNQUFMLEdBQWM7QUFBRztBQUFqQjtBQUNILEtBRkksTUFJRCxLQUFLLE1BQUwsR0FBYztBQUFFO0FBQWhCO0FBQ1AsR0FURDs7QUFVQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLHNCQUFwQixHQUE2QyxVQUFVLENBQVYsRUFBYSxPQUFiLEVBQXNCO0FBQy9ELFFBQUksQ0FBQyxLQUFLLEdBQU4sSUFBYSxDQUFDLEtBQUssR0FBbkIsSUFBMEIsVUFBVSxDQUFDLENBQUQsQ0FBeEMsRUFBNkM7QUFDekMsV0FBSyxPQUFMLEdBQWUsT0FBZjtBQUNIOztBQUNELFNBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxTQUFLLE1BQUwsR0FMK0QsQ0FLaEQ7QUFDbEIsR0FORDs7QUFPQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLHFCQUFwQixHQUE0QyxVQUFVLENBQVYsRUFBYSxrQkFBYixFQUFpQztBQUN6RSxRQUFJLENBQUMsS0FBSyxHQUFOLElBQWEsVUFBVSxDQUFDLENBQUQsQ0FBM0IsRUFBZ0M7QUFDNUIsV0FBSyxPQUFMLEdBQWU7QUFBRTtBQUFqQjtBQUNBLFdBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDQSxXQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUFMLEdBQWMsa0JBQWxDO0FBQ0EsV0FBSyxNQUFMLEdBSjRCLENBSWI7QUFDbEIsS0FMRCxNQU9JLEtBQUssTUFBTCxHQUFjO0FBQUU7QUFBaEI7QUFDUCxHQVRELENBMVl1QyxDQW9adkM7OztBQUNBLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsZ0JBQXBCLEdBQXVDLFVBQVUsR0FBVixFQUFlO0FBQ2xELFFBQUksR0FBRyxLQUFLLEtBQUssQ0FBakIsRUFBb0I7QUFBRSxNQUFBLEdBQUcsR0FBRyxLQUFLLE9BQUwsR0FBZSxVQUFVLFdBQXpCLEdBQW9DLGVBQWUsV0FBekQ7QUFBb0UsS0FEeEMsQ0FFbEQ7OztBQUNBLFFBQUksS0FBSyxZQUFMLEdBQW9CLENBQXBCLEdBQXdCLEtBQUssTUFBakMsRUFBeUM7QUFDckMsVUFBSSxNQUFNLEdBQUcsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixLQUFLLFlBQUwsR0FBb0IsQ0FBMUMsRUFBNkMsS0FBSyxNQUFsRCxDQUFiOztBQUNBLFVBQUksTUFBTSxDQUFDLFNBQVAsQ0FBaUIsY0FBakIsQ0FBZ0MsSUFBaEMsQ0FBcUMsR0FBckMsRUFBMEMsTUFBMUMsQ0FBSixFQUF1RDtBQUNuRCxhQUFLLFdBQUwsQ0FBaUIsR0FBRyxDQUFDLE1BQUQsQ0FBcEI7QUFDQSxhQUFLLFlBQUwsR0FBb0IsS0FBSyxNQUFMLEdBQWMsQ0FBbEM7QUFDSDtBQUNKO0FBQ0osR0FWRCxDQXJadUMsQ0FnYXZDOzs7QUFDQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLGlCQUFwQixHQUF3QyxZQUFZO0FBQ2hELFFBQUksS0FBSyxHQUFHLEtBQUssWUFBTCxHQUFvQixDQUFoQyxDQURnRCxDQUVoRDs7QUFDQSxRQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBTCxDQUFTLEtBQUssTUFBTCxHQUFjLEtBQXZCLEVBQThCLENBQTlCLENBQVo7O0FBQ0EsV0FBTyxLQUFLLElBQUksQ0FBaEIsRUFBbUI7QUFDZjtBQUNBLFVBQUksTUFBTSxHQUFHLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsS0FBbkIsRUFBMEIsS0FBMUIsQ0FBYjs7QUFDQSxVQUFJLE1BQU0sQ0FBQyxTQUFQLENBQWlCLGNBQWpCLENBQWdDLElBQWhDLENBQXFDLGFBQWEsV0FBbEQsRUFBNEQsTUFBNUQsQ0FBSixFQUF5RTtBQUNyRSxhQUFLLFdBQUwsQ0FBaUIsYUFBYSxXQUFiLENBQXNCLE1BQXRCLENBQWpCO0FBQ0EsYUFBSyxZQUFMLElBQXFCLEtBQUssR0FBRyxDQUE3QjtBQUNBO0FBQ0g7O0FBQ0QsTUFBQSxLQUFLO0FBQ1I7QUFDSixHQWREOztBQWVBLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0Isa0JBQXBCLEdBQXlDLFVBQVUsQ0FBVixFQUFhO0FBQ2xELFFBQUksQ0FBQyxLQUFLLEdBQVYsRUFBZTtBQUNYLFdBQUssZ0JBQUwsR0FEVyxDQUVYOztBQUNBLFVBQUksS0FBSyxTQUFMLEtBQW1CO0FBQUU7QUFBckIsU0FDQSxLQUFLLFlBQUwsR0FBb0IsQ0FBcEIsR0FBd0IsS0FBSyxNQUQ3QixJQUVBLENBQUMsS0FBSyxPQUZWLEVBRW1CO0FBQ2YsYUFBSyxpQkFBTDtBQUNIOztBQUNELFdBQUssTUFBTCxHQUFjLEtBQUssU0FBbkI7QUFDSCxLQVRELE1BVUssSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFKLElBQVcsQ0FBQyxHQUFHLEdBQWhCLEtBQXdCLENBQUMsWUFBWSxDQUFDLENBQUQsQ0FBekMsRUFBOEM7QUFDL0MsVUFBSSxLQUFLLE9BQUwsSUFBZ0IsS0FBSyxZQUFMLEdBQW9CLENBQXBCLEtBQTBCLEtBQUssTUFBbkQsRUFBMkQsQ0FDdkQ7QUFDSCxPQUZELE1BR0ssSUFBSSxLQUFLLFNBQUwsS0FBbUI7QUFBRTtBQUF6QixRQUFxQztBQUN0QyxjQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDWDtBQUNBLGlCQUFLLGdCQUFMLENBQXNCLGFBQWEsV0FBbkM7QUFDSDtBQUNKLFNBTEksTUFNQTtBQUNELGFBQUssaUJBQUw7QUFDSDs7QUFDRCxXQUFLLE1BQUwsR0FBYyxLQUFLLFNBQW5CO0FBQ0EsV0FBSyxNQUFMO0FBQ0g7QUFDSixHQTNCRDs7QUE0QkEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixtQkFBcEIsR0FBMEMsVUFBVSxNQUFWLEVBQWtCLElBQWxCLEVBQXdCLE1BQXhCLEVBQWdDO0FBQ3RFLFFBQUksWUFBWSxHQUFHLEtBQUssWUFBTCxHQUFvQixNQUF2Qzs7QUFDQSxRQUFJLFlBQVksS0FBSyxLQUFLLE1BQTFCLEVBQWtDO0FBQzlCO0FBQ0EsVUFBSSxNQUFNLEdBQUcsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixZQUF0QixFQUFvQyxLQUFLLE1BQXpDLENBQWI7QUFDQSxVQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBRCxFQUFTLElBQVQsQ0FBckI7QUFDQSxXQUFLLFdBQUwsQ0FBaUIsa0JBQWtCLFdBQWxCLENBQTJCLE1BQTNCLENBQWpCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLE1BQU0sR0FBRyxLQUFLLE1BQUwsR0FBYyxDQUFqQixHQUFxQixLQUFLLE1BQXBEO0FBQ0g7O0FBQ0QsU0FBSyxNQUFMLEdBQWMsS0FBSyxTQUFuQjtBQUNILEdBVkQ7O0FBV0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixvQkFBcEIsR0FBMkMsVUFBVSxDQUFWLEVBQWE7QUFDcEQsUUFBSSxDQUFDLEtBQUssR0FBVixFQUFlO0FBQ1gsV0FBSyxtQkFBTCxDQUF5QixDQUF6QixFQUE0QixFQUE1QixFQUFnQyxJQUFoQztBQUNILEtBRkQsTUFHSyxJQUFJLENBQUMsR0FBRyxHQUFKLElBQVcsQ0FBQyxHQUFHLEdBQW5CLEVBQXdCO0FBQ3pCLFVBQUksQ0FBQyxLQUFLLE9BQVYsRUFBbUI7QUFDZixhQUFLLG1CQUFMLENBQXlCLENBQXpCLEVBQTRCLEVBQTVCLEVBQWdDLEtBQWhDO0FBQ0gsT0FGRCxNQUdLO0FBQ0QsYUFBSyxNQUFMLEdBQWMsS0FBSyxTQUFuQjtBQUNIOztBQUNELFdBQUssTUFBTDtBQUNIO0FBQ0osR0FiRDs7QUFjQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLGdCQUFwQixHQUF1QyxVQUFVLENBQVYsRUFBYTtBQUNoRCxRQUFJLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFDWCxXQUFLLG1CQUFMLENBQXlCLENBQXpCLEVBQTRCLEVBQTVCLEVBQWdDLElBQWhDO0FBQ0gsS0FGRCxNQUdLLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBSixJQUFXLENBQUMsR0FBRyxHQUFoQixNQUNKLENBQUMsR0FBRyxHQUFKLElBQVcsQ0FBQyxHQUFHLEdBRFgsTUFFSixDQUFDLEdBQUcsR0FBSixJQUFXLENBQUMsR0FBRyxHQUZYLENBQUosRUFFcUI7QUFDdEIsVUFBSSxDQUFDLEtBQUssT0FBVixFQUFtQjtBQUNmLGFBQUssbUJBQUwsQ0FBeUIsQ0FBekIsRUFBNEIsRUFBNUIsRUFBZ0MsS0FBaEM7QUFDSCxPQUZELE1BR0s7QUFDRCxhQUFLLE1BQUwsR0FBYyxLQUFLLFNBQW5CO0FBQ0g7O0FBQ0QsV0FBSyxNQUFMO0FBQ0g7QUFDSixHQWZEOztBQWdCQSxFQUFBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLE9BQXBCLEdBQThCLFlBQVk7QUFDdEMsUUFBSSxLQUFLLFlBQUwsR0FBb0IsQ0FBeEIsRUFBMkI7QUFDdkIsV0FBSyxNQUFMLEdBQWMsRUFBZDtBQUNBLFdBQUssWUFBTCxJQUFxQixLQUFLLE1BQTFCO0FBQ0EsV0FBSyxNQUFMLEdBQWMsQ0FBZDtBQUNILEtBSkQsTUFLSyxJQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNuQixVQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFFO0FBQXRCLFFBQWtDO0FBQzlCLGNBQUksS0FBSyxZQUFMLEtBQXNCLEtBQUssTUFBL0IsRUFBdUM7QUFDbkMsaUJBQUssR0FBTCxDQUFTLE1BQVQsQ0FBZ0IsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQUFLLFlBQXhCLENBQWhCO0FBQ0g7O0FBQ0QsZUFBSyxNQUFMLEdBQWMsRUFBZDtBQUNBLGVBQUssWUFBTCxJQUFxQixLQUFLLE1BQTFCO0FBQ0EsZUFBSyxNQUFMLEdBQWMsQ0FBZDtBQUNILFNBUEQsTUFRSyxJQUFJLEtBQUssWUFBTCxLQUFzQixLQUFLLE1BQS9CLEVBQXVDO0FBQ3hDO0FBQ0EsYUFBSyxNQUFMLEdBQWMsRUFBZDtBQUNBLGFBQUssWUFBTCxJQUFxQixLQUFLLE1BQTFCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsQ0FBZDtBQUNILE9BTEksTUFNQTtBQUNEO0FBQ0EsYUFBSyxNQUFMLEdBQWMsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQUFLLFlBQXhCLENBQWQ7QUFDQSxhQUFLLE1BQUwsSUFBZSxLQUFLLFlBQXBCO0FBQ0EsYUFBSyxZQUFMLElBQXFCLEtBQUssWUFBMUI7QUFDSDs7QUFDRCxXQUFLLFlBQUwsR0FBb0IsQ0FBcEI7QUFDSDtBQUNKLEdBN0JEO0FBOEJBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsS0FBcEIsR0FBNEIsWUFBWTtBQUNwQyxXQUFPLEtBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxDQUFZLE1BQTFCLElBQW9DLEtBQUssT0FBaEQsRUFBeUQ7QUFDckQsVUFBSSxDQUFDLEdBQUcsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQUFLLE1BQXhCLENBQVI7O0FBQ0EsVUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRTtBQUF0QixRQUFrQztBQUM5QixlQUFLLFNBQUwsQ0FBZSxDQUFmO0FBQ0gsU0FGRCxNQUdLLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBaUQ7QUFDbEQsZUFBSyxpQ0FBTCxDQUF1QyxDQUF2QztBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFFO0FBQXRCLFFBQTZDO0FBQzlDLGVBQUssb0JBQUwsQ0FBMEIsQ0FBMUI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUF3QztBQUN6QyxlQUFLLGNBQUwsQ0FBb0IsQ0FBcEI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUErQztBQUNoRCxlQUFLLHFCQUFMLENBQTJCLENBQTNCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUU7QUFBdEIsUUFBaUQ7QUFDbEQsZUFBSyx3QkFBTCxDQUE4QixDQUE5QjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFFO0FBQXRCLFFBQXVDO0FBQ3hDLGVBQUssY0FBTCxDQUFvQixDQUFwQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFFO0FBQXRCLFFBQThDO0FBQy9DLGVBQUsscUJBQUwsQ0FBMkIsQ0FBM0I7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRTtBQUF0QixRQUEyQztBQUM1QyxlQUFLLGtCQUFMLENBQXdCLENBQXhCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBaUQ7QUFDbEQsZUFBSyx1QkFBTCxDQUE2QixDQUE3QjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQWlEO0FBQ2xELGVBQUssaUNBQUwsQ0FBdUMsQ0FBdkM7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUFtRDtBQUNwRCxlQUFLLHlCQUFMLENBQStCLENBQS9CO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUU7QUFBdEIsUUFBa0Q7QUFDbkQsZUFBSyx5QkFBTCxDQUErQixDQUEvQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFFO0FBQXRCLFFBQWlEO0FBQ2xELGVBQUssd0JBQUwsQ0FBOEIsQ0FBOUI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUE2QztBQUM5QyxlQUFLLG1CQUFMLENBQXlCLENBQXpCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBNEM7QUFDN0MsZUFBSyxrQkFBTCxDQUF3QixDQUF4QjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQWlEO0FBQ2xELGVBQUssNkJBQUwsQ0FBbUMsQ0FBbkM7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRTtBQUF0QixRQUE4QztBQUMvQyxlQUFLLHFCQUFMLENBQTJCLENBQTNCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBNEM7QUFDN0MsZUFBSyxrQkFBTCxDQUF3QixDQUF4QjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQWdEO0FBQ2pELGVBQUssc0JBQUwsQ0FBNEIsQ0FBNUI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUE0QztBQUM3QyxlQUFLLGtCQUFMLENBQXdCLENBQXhCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBNEM7QUFDN0MsZUFBSyxrQkFBTCxDQUF3QixDQUF4QjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQWdEO0FBQ2pELGVBQUssc0JBQUwsQ0FBNEIsQ0FBNUI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUFnRDtBQUNqRCxVQUFBLHFCQUFxQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQXJCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMkM7QUFDNUMsVUFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFqQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTJDO0FBQzVDLFVBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBakI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEyQztBQUM1QyxVQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQWpCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBNEM7QUFDN0MsVUFBQSxrQkFBa0IsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFsQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTRDO0FBQzdDLFVBQUEsa0JBQWtCLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBbEI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUE0QztBQUM3QyxVQUFBLGtCQUFrQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQWxCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBNEM7QUFDN0MsVUFBQSxrQkFBa0IsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFsQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTRDO0FBQzdDLGVBQUssc0JBQUwsQ0FBNEIsQ0FBNUIsRUFBK0I7QUFBRTtBQUFqQztBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTJDO0FBQzVDLFVBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBakI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEyQztBQUM1QyxlQUFLLHFCQUFMLENBQTJCLENBQTNCLEVBQThCLENBQTlCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMkM7QUFDNUMsVUFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFqQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQXNDO0FBQ3ZDLGVBQUssWUFBTCxDQUFrQixDQUFsQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTJDO0FBQzVDLFVBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBakI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEyQztBQUM1QyxVQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQWpCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMkM7QUFDNUMsZUFBSyxzQkFBTCxDQUE0QixDQUE1QixFQUErQjtBQUFFO0FBQWpDO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMEM7QUFDM0MsVUFBQSxnQkFBZ0IsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFoQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTBDO0FBQzNDLFVBQUEsZ0JBQWdCLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBaEI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEwQztBQUMzQyxVQUFBLGdCQUFnQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQWhCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMEM7QUFDM0MsZUFBSyxxQkFBTCxDQUEyQixDQUEzQixFQUE4QixDQUE5QjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTZDO0FBQzlDLFVBQUEsbUJBQW1CLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBbkI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEyQztBQUM1QyxVQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQWpCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMkM7QUFDNUMsVUFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFqQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTJDO0FBQzVDLFVBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBakI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEyQztBQUM1QyxlQUFLLHNCQUFMLENBQTRCLENBQTVCLEVBQStCO0FBQUU7QUFBakM7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEwQztBQUMzQyxVQUFBLGdCQUFnQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQWhCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMEM7QUFDM0MsVUFBQSxnQkFBZ0IsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFoQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTBDO0FBQzNDLFVBQUEsZ0JBQWdCLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBaEI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEwQztBQUMzQyxlQUFLLHFCQUFMLENBQTJCLENBQTNCLEVBQThCLENBQTlCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBc0Q7QUFDdkQsZUFBSyw0QkFBTCxDQUFrQyxDQUFsQztBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTRDO0FBQzdDLGVBQUssa0JBQUwsQ0FBd0IsQ0FBeEI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEyQztBQUM1QyxVQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQWpCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMkM7QUFDNUMsVUFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFqQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTJDO0FBQzVDLFVBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBakI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEyQztBQUM1QyxVQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQWpCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMEM7QUFDM0MsZUFBSyxnQkFBTCxDQUFzQixDQUF0QjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTBDO0FBQzNDLGVBQUssZ0JBQUwsQ0FBc0IsQ0FBdEI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEyQztBQUM1QyxVQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQWpCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBMkM7QUFDNUMsVUFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUFqQjtBQUNILFNBRkksTUFHQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQTJDO0FBQzVDLGVBQUssaUJBQUwsQ0FBdUIsQ0FBdkI7QUFDSCxTQUZJLE1BR0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUF2QixRQUEwQztBQUMzQyxlQUFLLGdCQUFMLENBQXNCLENBQXRCO0FBQ0gsU0FGSSxNQUdBLElBQUksS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFBdkIsUUFBOEM7QUFDL0MsZUFBSyxvQkFBTCxDQUEwQixDQUExQixFQUQrQyxDQUUvQztBQUNILFNBSEksTUFJQSxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQXZCLFFBQWtEO0FBQ25ELFVBQUEsd0JBQXdCLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBeEI7QUFDSCxTQUZJLE1BR0E7QUFDRCxhQUFLLEdBQUwsQ0FBUyxPQUFULENBQWlCLEtBQUssQ0FBQyxnQkFBRCxDQUF0QixFQUEwQyxLQUFLLE1BQS9DO0FBQ0g7O0FBQ0QsV0FBSyxNQUFMO0FBQ0g7O0FBQ0QsU0FBSyxPQUFMO0FBQ0gsR0FoTkQ7O0FBaU5BLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsTUFBcEIsR0FBNkIsWUFBWTtBQUNyQztBQUNBLFFBQUksS0FBSyxZQUFMLEdBQW9CLEtBQUssTUFBN0IsRUFBcUM7QUFDakMsV0FBSyxrQkFBTDtBQUNIOztBQUNELFNBQUssR0FBTCxDQUFTLEtBQVQ7QUFDSCxHQU5EOztBQU9BLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0Isa0JBQXBCLEdBQXlDLFlBQVk7QUFDakQsUUFBSSxJQUFJLEdBQUcsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQUFLLFlBQXhCLENBQVg7O0FBQ0EsUUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUFuQixPQUNBLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBRG5CLE9BRUEsS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFGdkIsTUFFMEM7QUFDdEMsYUFBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixJQUFqQjtBQUNILE9BSkQsTUFLSyxJQUFJLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBQW5CLE9BQ0wsS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFEZCxPQUVMLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBRmxCLE1BRXVDO0FBQ3hDLGFBQUssR0FBTCxDQUFTLFNBQVQsQ0FBbUIsSUFBbkI7QUFDSCxPQUpJLE1BS0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUFuQixPQUEwQyxDQUFDLEtBQUssT0FBcEQsRUFBNkQ7QUFDOUQsV0FBSyxpQkFBTDs7QUFDQSxVQUFJLEtBQUssWUFBTCxHQUFvQixLQUFLLE1BQTdCLEVBQXFDO0FBQ2pDLGFBQUssTUFBTCxHQUFjLEtBQUssU0FBbkI7QUFDQSxhQUFLLGtCQUFMO0FBQ0g7QUFDSixLQU5JLE1BT0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUFuQixPQUE0QyxDQUFDLEtBQUssT0FBdEQsRUFBK0Q7QUFDaEUsV0FBSyxtQkFBTCxDQUF5QixDQUF6QixFQUE0QixFQUE1QixFQUFnQyxLQUFoQzs7QUFDQSxVQUFJLEtBQUssWUFBTCxHQUFvQixLQUFLLE1BQTdCLEVBQXFDO0FBQ2pDLGFBQUssTUFBTCxHQUFjLEtBQUssU0FBbkI7QUFDQSxhQUFLLGtCQUFMO0FBQ0g7QUFDSixLQU5JLE1BT0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUFuQixPQUF3QyxDQUFDLEtBQUssT0FBbEQsRUFBMkQ7QUFDNUQsV0FBSyxtQkFBTCxDQUF5QixDQUF6QixFQUE0QixFQUE1QixFQUFnQyxLQUFoQzs7QUFDQSxVQUFJLEtBQUssWUFBTCxHQUFvQixLQUFLLE1BQTdCLEVBQXFDO0FBQ2pDLGFBQUssTUFBTCxHQUFjLEtBQUssU0FBbkI7QUFDQSxhQUFLLGtCQUFMO0FBQ0g7QUFDSixLQU5JLE1BT0EsSUFBSSxLQUFLLE1BQUwsS0FBZ0I7QUFBRTtBQUFsQixPQUNMLEtBQUssTUFBTCxLQUFnQjtBQUFFO0FBRGIsT0FFTCxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUZkLE9BR0wsS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFIZCxPQUlMLEtBQUssTUFBTCxLQUFnQjtBQUFFO0FBSmIsT0FLTCxLQUFLLE1BQUwsS0FBZ0I7QUFBRztBQUxkLE9BTUwsS0FBSyxNQUFMLEtBQWdCO0FBQUc7QUFOZCxPQU9MLEtBQUssTUFBTCxLQUFnQjtBQUFHO0FBUGQsT0FRTCxLQUFLLE1BQUwsS0FBZ0I7QUFBRTtBQVJqQixNQVF5QztBQUMxQyxhQUFLLEdBQUwsQ0FBUyxNQUFULENBQWdCLElBQWhCO0FBQ0g7QUFDRDtBQUNSO0FBQ0E7QUFDQTs7QUFDSyxHQWhERDs7QUFpREEsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixVQUFwQixHQUFpQyxZQUFZO0FBQ3pDLFdBQU8sS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixLQUFLLFlBQTNCLEVBQXlDLEtBQUssTUFBOUMsQ0FBUDtBQUNILEdBRkQ7O0FBR0EsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixTQUFwQixHQUFnQyxVQUFVLElBQVYsRUFBZ0I7QUFDNUMsU0FBSyxHQUFMLENBQVMsSUFBVCxFQUFlLEtBQUssVUFBTCxFQUFmO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLENBQUMsQ0FBckI7QUFDSCxHQUhEOztBQUlBLEVBQUEsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsV0FBcEIsR0FBa0MsVUFBVSxLQUFWLEVBQWlCO0FBQy9DLFFBQUksS0FBSyxTQUFMLEtBQW1CO0FBQUU7QUFBekIsTUFBcUM7QUFDakMsYUFBSyxHQUFMLENBQVMsWUFBVCxDQUFzQixLQUF0QixFQURpQyxDQUNIO0FBQ2pDLE9BRkQsTUFHSztBQUNELFdBQUssR0FBTCxDQUFTLE1BQVQsQ0FBZ0IsS0FBaEI7QUFDSDtBQUNKLEdBUEQ7O0FBUUEsU0FBTyxTQUFQO0FBQ0gsQ0FqekI4QixFQUEvQjs7QUFrekJBLE9BQU8sV0FBUCxHQUFrQixTQUFsQjs7O0FDajRCQTs7QUFDQSxJQUFJLGVBQWUsR0FBSSxVQUFRLFNBQUssZUFBZCxLQUFtQyxNQUFNLENBQUMsTUFBUCxHQUFpQixVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixFQUFsQixFQUFzQjtBQUM1RixNQUFJLEVBQUUsS0FBSyxTQUFYLEVBQXNCLEVBQUUsR0FBRyxDQUFMO0FBQ3RCLEVBQUEsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsQ0FBdEIsRUFBeUIsRUFBekIsRUFBNkI7QUFBRSxJQUFBLFVBQVUsRUFBRSxJQUFkO0FBQW9CLElBQUEsR0FBRyxFQUFFLGVBQVc7QUFBRSxhQUFPLENBQUMsQ0FBQyxDQUFELENBQVI7QUFBYztBQUFwRCxHQUE3QjtBQUNILENBSHdELEdBR25ELFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLEVBQWxCLEVBQXNCO0FBQ3hCLE1BQUksRUFBRSxLQUFLLFNBQVgsRUFBc0IsRUFBRSxHQUFHLENBQUw7QUFDdEIsRUFBQSxDQUFDLENBQUMsRUFBRCxDQUFELEdBQVEsQ0FBQyxDQUFDLENBQUQsQ0FBVDtBQUNILENBTnFCLENBQXRCOztBQU9BLElBQUksa0JBQWtCLEdBQUksVUFBUSxTQUFLLGtCQUFkLEtBQXNDLE1BQU0sQ0FBQyxNQUFQLEdBQWlCLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUMzRixFQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLENBQXRCLEVBQXlCLFNBQXpCLEVBQW9DO0FBQUUsSUFBQSxVQUFVLEVBQUUsSUFBZDtBQUFvQixJQUFBLEtBQUssRUFBRTtBQUEzQixHQUFwQztBQUNILENBRjhELEdBRTFELFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUNoQixFQUFBLENBQUMsQ0FBQyxTQUFELENBQUQsR0FBZSxDQUFmO0FBQ0gsQ0FKd0IsQ0FBekI7O0FBS0EsSUFBSSxZQUFZLEdBQUksVUFBUSxTQUFLLFlBQWQsSUFBK0IsVUFBVSxHQUFWLEVBQWU7QUFDN0QsTUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLFVBQWYsRUFBMkIsT0FBTyxHQUFQO0FBQzNCLE1BQUksTUFBTSxHQUFHLEVBQWI7QUFDQSxNQUFJLEdBQUcsSUFBSSxJQUFYLEVBQWlCLEtBQUssSUFBSSxDQUFULElBQWMsR0FBZDtBQUFtQixRQUFJLENBQUMsS0FBSyxTQUFOLElBQW1CLE1BQU0sQ0FBQyxTQUFQLENBQWlCLGNBQWpCLENBQWdDLElBQWhDLENBQXFDLEdBQXJDLEVBQTBDLENBQTFDLENBQXZCLEVBQXFFLGVBQWUsQ0FBQyxNQUFELEVBQVMsR0FBVCxFQUFjLENBQWQsQ0FBZjtBQUF4Rjs7QUFDakIsRUFBQSxrQkFBa0IsQ0FBQyxNQUFELEVBQVMsR0FBVCxDQUFsQjs7QUFDQSxTQUFPLE1BQVA7QUFDSCxDQU5EOztBQU9BLElBQUksWUFBWSxHQUFJLFVBQVEsU0FBSyxZQUFkLElBQStCLFVBQVMsQ0FBVCxFQUFZLE9BQVosRUFBcUI7QUFDbkUsT0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFFBQUksQ0FBQyxLQUFLLFNBQU4sSUFBbUIsQ0FBQyxNQUFNLENBQUMsU0FBUCxDQUFpQixjQUFqQixDQUFnQyxJQUFoQyxDQUFxQyxPQUFyQyxFQUE4QyxDQUE5QyxDQUF4QixFQUEwRSxlQUFlLENBQUMsT0FBRCxFQUFVLENBQVYsRUFBYSxDQUFiLENBQWY7QUFBM0Y7QUFDSCxDQUZEOztBQUdBLElBQUksZUFBZSxHQUFJLFVBQVEsU0FBSyxlQUFkLElBQWtDLFVBQVUsR0FBVixFQUFlO0FBQ25FLFNBQVEsR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFaLEdBQTBCLEdBQTFCLEdBQWdDO0FBQUUsZUFBVztBQUFiLEdBQXZDO0FBQ0gsQ0FGRDs7QUFHQSxNQUFNLENBQUMsY0FBUCxDQUFzQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFLEVBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7QUFDQSxPQUFPLENBQUMsVUFBUixHQUFxQixPQUFPLENBQUMsY0FBUixHQUF5QixPQUFPLENBQUMsUUFBUixHQUFtQixPQUFPLENBQUMsV0FBUixHQUFzQixPQUFPLENBQUMsU0FBUixHQUFvQixPQUFPLENBQUMsZUFBUixHQUEwQixPQUFPLENBQUMsUUFBUixHQUFtQixPQUFPLENBQUMsVUFBUixHQUFxQixPQUFPLENBQUMsTUFBUixHQUFpQixLQUFLLENBQW5NOztBQUNBLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFELENBQXRCOztBQUNBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFFBQS9CLEVBQXlDO0FBQUUsRUFBQSxVQUFVLEVBQUUsSUFBZDtBQUFvQixFQUFBLEdBQUcsRUFBRSxlQUFZO0FBQUUsV0FBTyxRQUFRLENBQUMsTUFBaEI7QUFBeUI7QUFBaEUsQ0FBekM7O0FBQ0EsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLFlBQUQsQ0FBMUI7O0FBQ0EsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRSxFQUFBLFVBQVUsRUFBRSxJQUFkO0FBQW9CLEVBQUEsR0FBRyxFQUFFLGVBQVk7QUFBRSxXQUFPLFlBQVksQ0FBQyxVQUFwQjtBQUFpQztBQUF4RSxDQUE3QztBQUNBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLGdCQUEvQixFQUFpRDtBQUFFLEVBQUEsVUFBVSxFQUFFLElBQWQ7QUFBb0IsRUFBQSxHQUFHLEVBQUUsZUFBWTtBQUFFLFdBQU8sWUFBWSxDQUFDLFVBQXBCO0FBQWlDO0FBQXhFLENBQWpELEUsQ0FDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCLE9BQXhCLEVBQWlDO0FBQzdCLE1BQUksT0FBTyxHQUFHLElBQUksWUFBWSxDQUFDLFVBQWpCLENBQTRCLEtBQUssQ0FBakMsRUFBb0MsT0FBcEMsQ0FBZDtBQUNBLE1BQUksUUFBUSxDQUFDLE1BQWIsQ0FBb0IsT0FBcEIsRUFBNkIsT0FBN0IsRUFBc0MsR0FBdEMsQ0FBMEMsSUFBMUM7QUFDQSxTQUFPLE9BQU8sQ0FBQyxHQUFmO0FBQ0g7O0FBQ0QsT0FBTyxDQUFDLFFBQVIsR0FBbUIsUUFBbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTLGVBQVQsQ0FBeUIsRUFBekIsRUFBNkIsT0FBN0IsRUFBc0MsU0FBdEMsRUFBaUQ7QUFDN0MsTUFBSSxPQUFPLEdBQUcsSUFBSSxZQUFZLENBQUMsVUFBakIsQ0FBNEIsRUFBNUIsRUFBZ0MsT0FBaEMsRUFBeUMsU0FBekMsQ0FBZDtBQUNBLFNBQU8sSUFBSSxRQUFRLENBQUMsTUFBYixDQUFvQixPQUFwQixFQUE2QixPQUE3QixDQUFQO0FBQ0g7O0FBQ0QsT0FBTyxDQUFDLGVBQVIsR0FBMEIsZUFBMUI7O0FBQ0EsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLGFBQUQsQ0FBekI7O0FBQ0EsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0IsV0FBL0IsRUFBNEM7QUFBRSxFQUFBLFVBQVUsRUFBRSxJQUFkO0FBQW9CLEVBQUEsR0FBRyxFQUFFLGVBQVk7QUFBRSxXQUFPLGVBQWUsQ0FBQyxXQUFELENBQWYsV0FBUDtBQUE4QztBQUFyRixDQUE1Qzs7QUFDQSxJQUFJLFdBQVcsR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLGdCQUFELENBQVIsQ0FBOUI7O0FBQ0EsT0FBTyxDQUFDLFdBQVIsR0FBc0IsV0FBdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxZQUFZLENBQUMsT0FBTyxDQUFDLGVBQUQsQ0FBUixFQUEyQixPQUEzQixDQUFaOztBQUNBLE9BQU8sQ0FBQyxRQUFSLEdBQW1CLFlBQVksQ0FBQyxPQUFPLENBQUMsVUFBRCxDQUFSLENBQS9COztBQUNBLElBQUksYUFBYSxHQUFHLE9BQU8sQ0FBQyxlQUFELENBQTNCOztBQUNBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUUsRUFBQSxVQUFVLEVBQUUsSUFBZDtBQUFvQixFQUFBLEdBQUcsRUFBRSxlQUFZO0FBQUUsV0FBTyxhQUFhLENBQUMsV0FBckI7QUFBbUM7QUFBMUUsQ0FBN0M7Ozs7O0FDckVBO0FBQ0EsT0FBTyxDQUFDLElBQVIsR0FBZSxVQUFVLE1BQVYsRUFBa0IsTUFBbEIsRUFBMEIsSUFBMUIsRUFBZ0MsSUFBaEMsRUFBc0MsTUFBdEMsRUFBOEM7QUFDM0QsTUFBSSxDQUFKLEVBQU8sQ0FBUDtBQUNBLE1BQUksSUFBSSxHQUFJLE1BQU0sR0FBRyxDQUFWLEdBQWUsSUFBZixHQUFzQixDQUFqQztBQUNBLE1BQUksSUFBSSxHQUFHLENBQUMsS0FBSyxJQUFOLElBQWMsQ0FBekI7QUFDQSxNQUFJLEtBQUssR0FBRyxJQUFJLElBQUksQ0FBcEI7QUFDQSxNQUFJLEtBQUssR0FBRyxDQUFDLENBQWI7QUFDQSxNQUFJLENBQUMsR0FBRyxJQUFJLEdBQUksTUFBTSxHQUFHLENBQWIsR0FBa0IsQ0FBOUI7QUFDQSxNQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFKLEdBQVEsQ0FBcEI7QUFDQSxNQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQVYsQ0FBZDtBQUVBLEVBQUEsQ0FBQyxJQUFJLENBQUw7QUFFQSxFQUFBLENBQUMsR0FBRyxDQUFDLEdBQUksQ0FBQyxLQUFNLENBQUMsS0FBUixJQUFrQixDQUEzQjtBQUNBLEVBQUEsQ0FBQyxLQUFNLENBQUMsS0FBUjtBQUNBLEVBQUEsS0FBSyxJQUFJLElBQVQ7O0FBQ0EsU0FBTyxLQUFLLEdBQUcsQ0FBZixFQUFrQixDQUFDLEdBQUksQ0FBQyxHQUFHLEdBQUwsR0FBWSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQVYsQ0FBdEIsRUFBb0MsQ0FBQyxJQUFJLENBQXpDLEVBQTRDLEtBQUssSUFBSSxDQUF2RSxFQUEwRSxDQUFFOztBQUU1RSxFQUFBLENBQUMsR0FBRyxDQUFDLEdBQUksQ0FBQyxLQUFNLENBQUMsS0FBUixJQUFrQixDQUEzQjtBQUNBLEVBQUEsQ0FBQyxLQUFNLENBQUMsS0FBUjtBQUNBLEVBQUEsS0FBSyxJQUFJLElBQVQ7O0FBQ0EsU0FBTyxLQUFLLEdBQUcsQ0FBZixFQUFrQixDQUFDLEdBQUksQ0FBQyxHQUFHLEdBQUwsR0FBWSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQVYsQ0FBdEIsRUFBb0MsQ0FBQyxJQUFJLENBQXpDLEVBQTRDLEtBQUssSUFBSSxDQUF2RSxFQUEwRSxDQUFFOztBQUU1RSxNQUFJLENBQUMsS0FBSyxDQUFWLEVBQWE7QUFDWCxJQUFBLENBQUMsR0FBRyxJQUFJLEtBQVI7QUFDRCxHQUZELE1BRU8sSUFBSSxDQUFDLEtBQUssSUFBVixFQUFnQjtBQUNyQixXQUFPLENBQUMsR0FBRyxHQUFILEdBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFKLEdBQVEsQ0FBVixJQUFlLFFBQWpDO0FBQ0QsR0FGTSxNQUVBO0FBQ0wsSUFBQSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQVosQ0FBUjtBQUNBLElBQUEsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFSO0FBQ0Q7O0FBQ0QsU0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUosR0FBUSxDQUFWLElBQWUsQ0FBZixHQUFtQixJQUFJLENBQUMsR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDLEdBQUcsSUFBaEIsQ0FBMUI7QUFDRCxDQS9CRDs7QUFpQ0EsT0FBTyxDQUFDLEtBQVIsR0FBZ0IsVUFBVSxNQUFWLEVBQWtCLEtBQWxCLEVBQXlCLE1BQXpCLEVBQWlDLElBQWpDLEVBQXVDLElBQXZDLEVBQTZDLE1BQTdDLEVBQXFEO0FBQ25FLE1BQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWO0FBQ0EsTUFBSSxJQUFJLEdBQUksTUFBTSxHQUFHLENBQVYsR0FBZSxJQUFmLEdBQXNCLENBQWpDO0FBQ0EsTUFBSSxJQUFJLEdBQUcsQ0FBQyxLQUFLLElBQU4sSUFBYyxDQUF6QjtBQUNBLE1BQUksS0FBSyxHQUFHLElBQUksSUFBSSxDQUFwQjtBQUNBLE1BQUksRUFBRSxHQUFJLElBQUksS0FBSyxFQUFULEdBQWMsSUFBSSxDQUFDLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQyxFQUFiLElBQW1CLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYixDQUFqQyxHQUFvRCxDQUE5RDtBQUNBLE1BQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFILEdBQVEsTUFBTSxHQUFHLENBQTdCO0FBQ0EsTUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUgsR0FBTyxDQUFDLENBQXBCO0FBQ0EsTUFBSSxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQVIsSUFBYyxLQUFLLEtBQUssQ0FBVixJQUFlLElBQUksS0FBSixHQUFZLENBQXpDLEdBQThDLENBQTlDLEdBQWtELENBQTFEO0FBRUEsRUFBQSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBUyxLQUFULENBQVI7O0FBRUEsTUFBSSxLQUFLLENBQUMsS0FBRCxDQUFMLElBQWdCLEtBQUssS0FBSyxRQUE5QixFQUF3QztBQUN0QyxJQUFBLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBRCxDQUFMLEdBQWUsQ0FBZixHQUFtQixDQUF2QjtBQUNBLElBQUEsQ0FBQyxHQUFHLElBQUo7QUFDRCxHQUhELE1BR087QUFDTCxJQUFBLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLElBQUksQ0FBQyxHQUFMLENBQVMsS0FBVCxJQUFrQixJQUFJLENBQUMsR0FBbEMsQ0FBSjs7QUFDQSxRQUFJLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQyxDQUFiLENBQVIsQ0FBTCxHQUFnQyxDQUFwQyxFQUF1QztBQUNyQyxNQUFBLENBQUM7QUFDRCxNQUFBLENBQUMsSUFBSSxDQUFMO0FBQ0Q7O0FBQ0QsUUFBSSxDQUFDLEdBQUcsS0FBSixJQUFhLENBQWpCLEVBQW9CO0FBQ2xCLE1BQUEsS0FBSyxJQUFJLEVBQUUsR0FBRyxDQUFkO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsTUFBQSxLQUFLLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUksS0FBaEIsQ0FBZDtBQUNEOztBQUNELFFBQUksS0FBSyxHQUFHLENBQVIsSUFBYSxDQUFqQixFQUFvQjtBQUNsQixNQUFBLENBQUM7QUFDRCxNQUFBLENBQUMsSUFBSSxDQUFMO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDLEdBQUcsS0FBSixJQUFhLElBQWpCLEVBQXVCO0FBQ3JCLE1BQUEsQ0FBQyxHQUFHLENBQUo7QUFDQSxNQUFBLENBQUMsR0FBRyxJQUFKO0FBQ0QsS0FIRCxNQUdPLElBQUksQ0FBQyxHQUFHLEtBQUosSUFBYSxDQUFqQixFQUFvQjtBQUN6QixNQUFBLENBQUMsR0FBRyxDQUFFLEtBQUssR0FBRyxDQUFULEdBQWMsQ0FBZixJQUFvQixJQUFJLENBQUMsR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFaLENBQXhCO0FBQ0EsTUFBQSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQVI7QUFDRCxLQUhNLE1BR0E7QUFDTCxNQUFBLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxHQUFHLENBQXBCLENBQVIsR0FBaUMsSUFBSSxDQUFDLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBWixDQUFyQztBQUNBLE1BQUEsQ0FBQyxHQUFHLENBQUo7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBSSxJQUFJLENBQWYsRUFBa0IsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFWLENBQU4sR0FBcUIsQ0FBQyxHQUFHLElBQXpCLEVBQStCLENBQUMsSUFBSSxDQUFwQyxFQUF1QyxDQUFDLElBQUksR0FBNUMsRUFBaUQsSUFBSSxJQUFJLENBQTNFLEVBQThFLENBQUU7O0FBRWhGLEVBQUEsQ0FBQyxHQUFJLENBQUMsSUFBSSxJQUFOLEdBQWMsQ0FBbEI7QUFDQSxFQUFBLElBQUksSUFBSSxJQUFSOztBQUNBLFNBQU8sSUFBSSxHQUFHLENBQWQsRUFBaUIsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFWLENBQU4sR0FBcUIsQ0FBQyxHQUFHLElBQXpCLEVBQStCLENBQUMsSUFBSSxDQUFwQyxFQUF1QyxDQUFDLElBQUksR0FBNUMsRUFBaUQsSUFBSSxJQUFJLENBQTFFLEVBQTZFLENBQUU7O0FBRS9FLEVBQUEsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFULEdBQWEsQ0FBZCxDQUFOLElBQTBCLENBQUMsR0FBRyxHQUE5QjtBQUNELENBbEREOzs7OztBQ2xDQSxJQUFJLE9BQU8sTUFBTSxDQUFDLE1BQWQsS0FBeUIsVUFBN0IsRUFBeUM7QUFDdkM7QUFDQSxFQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsUUFBVCxDQUFrQixJQUFsQixFQUF3QixTQUF4QixFQUFtQztBQUNsRCxRQUFJLFNBQUosRUFBZTtBQUNiLE1BQUEsSUFBSSxDQUFDLE1BQUwsR0FBYyxTQUFkO0FBQ0EsTUFBQSxJQUFJLENBQUMsU0FBTCxHQUFpQixNQUFNLENBQUMsTUFBUCxDQUFjLFNBQVMsQ0FBQyxTQUF4QixFQUFtQztBQUNsRCxRQUFBLFdBQVcsRUFBRTtBQUNYLFVBQUEsS0FBSyxFQUFFLElBREk7QUFFWCxVQUFBLFVBQVUsRUFBRSxLQUZEO0FBR1gsVUFBQSxRQUFRLEVBQUUsSUFIQztBQUlYLFVBQUEsWUFBWSxFQUFFO0FBSkg7QUFEcUMsT0FBbkMsQ0FBakI7QUFRRDtBQUNGLEdBWkQ7QUFhRCxDQWZELE1BZU87QUFDTDtBQUNBLEVBQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCLFNBQXhCLEVBQW1DO0FBQ2xELFFBQUksU0FBSixFQUFlO0FBQ2IsTUFBQSxJQUFJLENBQUMsTUFBTCxHQUFjLFNBQWQ7O0FBQ0EsVUFBSSxRQUFRLEdBQUcsU0FBWCxRQUFXLEdBQVksQ0FBRSxDQUE3Qjs7QUFDQSxNQUFBLFFBQVEsQ0FBQyxTQUFULEdBQXFCLFNBQVMsQ0FBQyxTQUEvQjtBQUNBLE1BQUEsSUFBSSxDQUFDLFNBQUwsR0FBaUIsSUFBSSxRQUFKLEVBQWpCO0FBQ0EsTUFBQSxJQUFJLENBQUMsU0FBTCxDQUFlLFdBQWYsR0FBNkIsSUFBN0I7QUFDRDtBQUNGLEdBUkQ7QUFTRDs7O0FDMUJEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQU1JLE9BQU8sQ0FBQyxTQUFELEM7SUFIQSxRLFlBQVQsTztJQUNVLFMsWUFBVixRO0lBQ1UsUyxZQUFWLFE7O2dCQUlFLE9BQU8sQ0FBQyxRQUFELEM7SUFEQSxRLGFBQVQsTzs7Z0JBRW9CLE9BQU8sQ0FBQyxPQUFELEM7SUFBdEIsVyxhQUFBLFc7O0FBQ1AsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLGVBQUQsQ0FBM0I7O0FBQ0EsSUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLG1CQUFELENBQS9COztBQUVBLElBQU0sZ0JBQWdCLEdBQUcsRUFBekI7O0FBRUEsTUFBTSxDQUFDLE9BQVA7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsaUNBQTJCO0FBQUEsUUFBZCxXQUFjLFFBQWQsV0FBYztBQUFBO0FBQ3pCLFNBQUssVUFBTCxHQUFrQixJQUFJLEdBQUosRUFBbEI7QUFDQSxTQUFLLFdBQUwsR0FBbUIsV0FBbkI7QUFDRDs7QUFUSDtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWUksZ0JBQUEsU0FaSixTQVlJLFNBWkosRUFZZSxPQVpmLFNBWWUsT0FaZixFQVl3QixjQVp4QixTQVl3QixjQVp4QixFQVl3QyxJQVp4QyxTQVl3QyxJQVp4Qyx1QkFZOEMsTUFaOUMsRUFZOEMsTUFaOUMsNkJBWXVELElBQUksR0FBSixFQVp2RDs7QUFjSTtBQUNBLG9CQUFHLE9BQU8sSUFBSSxTQUFTLENBQUMsT0FBRCxDQUFwQixJQUFpQyxPQUFPLENBQUMsVUFBRCxDQUEzQyxFQUF5RDtBQUN2RCxrQkFBQSxPQUFPLEdBQUcsT0FBTyxDQUFDLFVBQUQsQ0FBakI7QUFDRCxpQkFqQkwsQ0FtQkk7OztBQUNBLGdCQUFBLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBRCxDQUFsQixDQXBCSixDQXNCSTs7QUFDTSxnQkFBQSxXQXZCVixHQXVCd0IsRUF2QnhCO0FBQUEsdURBd0JxQixPQXhCckI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXdCYyxnQkFBQSxHQXhCZDs7QUFBQSxxQkF5QlMsU0FBUyxDQUFDLEdBQUQsQ0F6QmxCO0FBQUE7QUFBQTtBQUFBOztBQTBCUTtBQUNJLGdCQUFBLFNBM0JaLEdBMkJ1QixLQUFLLElBQUwsQ0FBVSxHQUFWLENBM0J2Qjs7QUFBQSxvQkE0QlksU0E1Qlo7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSx1QkE4QjJCLEtBQUsscUJBQUwsQ0FDZjtBQUFDLGtCQUFBLFNBQVMsRUFBVCxTQUFEO0FBQVksa0JBQUEsR0FBRyxFQUFFLEdBQWpCO0FBQXNCLGtCQUFBLGNBQWMsRUFBZCxjQUF0QjtBQUFzQyxrQkFBQSxJQUFJLEVBQUosSUFBdEM7QUFBNEMsa0JBQUEsTUFBTSxFQUFOO0FBQTVDLGlCQURlLENBOUIzQjs7QUFBQTtBQThCVSxnQkFBQSxTQTlCVjs7QUFBQTtBQWtDUTtBQUNBLG9CQUFHLFFBQVEsQ0FBQyxTQUFELENBQVgsRUFBdUI7QUFDckIsa0JBQUEsV0FBVyxDQUFDLElBQVosT0FBQSxXQUFXLHNDQUFTLFNBQVQsRUFBWDtBQUNELGlCQUZELE1BRU87QUFDTCxrQkFBQSxXQUFXLENBQUMsSUFBWixDQUFpQixTQUFqQjtBQUNEOztBQXZDVDs7QUFBQTtBQUFBLHNCQTBDUyxHQUFHLEtBQUssSUExQ2pCO0FBQUE7QUFBQTtBQUFBOztBQTJDUTtBQUNBLGdCQUFBLFdBQVcsQ0FBQyxJQUFaLENBQWlCLElBQUksZUFBSixDQUFvQjtBQUFDLGtCQUFBLFFBQVEsRUFBRTtBQUFYLGlCQUFwQixDQUFqQjtBQTVDUjs7QUFBQTtBQStDTSxvQkFBRyxDQUFDLFNBQVMsQ0FBQyxHQUFELENBQWIsRUFBb0I7QUFDbEIsa0JBQUEseUJBQXlCLENBQUMsT0FBRCxDQUF6QjtBQUNELGlCQWpEUCxDQWtETTs7O0FBQ00sZ0JBQUEsR0FuRFosR0FtRGtCLElBQUksQ0FBQyxTQUFMLENBQWUsR0FBZixDQW5EbEI7QUFvRFUsZ0JBQUEsUUFwRFYsR0FvRHFCLEtBQUssSUFBTCxDQUFVLEdBQVYsQ0FwRHJCOztBQXFETSxvQkFBRyxDQUFDLFFBQUosRUFBYztBQUNaO0FBQ0Esa0JBQUEsUUFBUSxHQUFHLElBQUksZUFBSixDQUFvQjtBQUFDLG9CQUFBLFFBQVEsRUFBRTtBQUFYLG1CQUFwQixDQUFYOztBQUNBLHVCQUFLLHFCQUFMLENBQTJCO0FBQUMsb0JBQUEsR0FBRyxFQUFILEdBQUQ7QUFBTSxvQkFBQSxRQUFRLEVBQVIsUUFBTjtBQUFnQixvQkFBQSxHQUFHLEVBQUU7QUFBckIsbUJBQTNCO0FBQ0Q7O0FBQ0QsZ0JBQUEsV0FBVyxDQUFDLElBQVosQ0FBaUIsUUFBakI7O0FBMUROO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQSxpREE2RFcsV0E3RFg7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEseUJBZ0VPLEdBaEVQLEVBZ0VZO0FBQ1I7QUFDQTtBQUNBLFVBQUksUUFBUSxHQUFHLEtBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixHQUFwQixDQUFmOztBQUNBLFVBQUcsQ0FBQyxRQUFKLEVBQWM7QUFDWjtBQUNBLFlBQU0sTUFBTSxHQUFHLEtBQUssV0FBTCxDQUFpQixHQUFqQixDQUFxQixHQUFyQixDQUFmOztBQUNBLFlBQUcsTUFBSCxFQUFXO0FBQ1QsVUFBQSxRQUFRLEdBQUcsTUFBTSxDQUFDLEdBQVAsQ0FBVyxRQUFYLENBQVg7O0FBQ0EsY0FBRyxRQUFILEVBQWE7QUFDWCxpQkFBSyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLEdBQXBCLEVBQXlCLFFBQXpCO0FBQ0Q7QUFDRjtBQUNGOztBQUNELGFBQU8sUUFBUDtBQUNEO0FBL0VIO0FBQUE7QUFBQSxpREFpRjhDO0FBQUEsVUFBckIsR0FBcUIsU0FBckIsR0FBcUI7QUFBQSxVQUFoQixRQUFnQixTQUFoQixRQUFnQjtBQUFBLFVBQU4sR0FBTSxTQUFOLEdBQU07QUFDMUMsV0FBSyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLEdBQXBCLEVBQXlCLFFBQXpCOztBQUNBLFVBQUcsR0FBRyxLQUFLLFNBQVgsRUFBc0I7QUFDcEIsWUFBSSxNQUFNLEdBQUcsS0FBSyxXQUFMLENBQWlCLEdBQWpCLENBQXFCLEdBQXJCLENBQWI7O0FBQ0EsWUFBRyxDQUFDLE1BQUosRUFBWTtBQUNWLFVBQUEsTUFBTSxHQUFHLElBQUksR0FBSixFQUFUO0FBQ0EsZUFBSyxXQUFMLENBQWlCLEdBQWpCLENBQXFCLEdBQXJCLEVBQTBCLE1BQTFCO0FBQ0Q7O0FBQ0QsUUFBQSxNQUFNLENBQUMsR0FBUCxDQUFXLEdBQVgsRUFBZ0IsUUFBaEI7QUFDRDs7QUFDRCxhQUFPLFFBQVA7QUFDRDtBQTVGSDtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBOEYrQixnQkFBQSxTQTlGL0IsU0E4RitCLFNBOUYvQixFQThGMEMsR0E5RjFDLFNBOEYwQyxHQTlGMUMsRUE4RitDLGNBOUYvQyxTQThGK0MsY0E5Ri9DLEVBOEYrRCxJQTlGL0QsU0E4RitELElBOUYvRCxFQThGcUUsTUE5RnJFLFNBOEZxRSxNQTlGckU7QUErRkk7QUFDQSxnQkFBQSxHQUFHLEdBQUcsV0FBVyxDQUFDLElBQUQsRUFBTyxHQUFQLENBQWpCO0FBaEdKO0FBQUEsdUJBaUd1QyxLQUFLLGFBQUwsQ0FDakM7QUFBQyxrQkFBQSxTQUFTLEVBQVQsU0FBRDtBQUFZLGtCQUFBLEdBQUcsRUFBSCxHQUFaO0FBQWlCLGtCQUFBLGNBQWMsRUFBZCxjQUFqQjtBQUFpQyxrQkFBQSxNQUFNLEVBQU47QUFBakMsaUJBRGlDLENBakd2Qzs7QUFBQTtBQUFBO0FBaUdXLGdCQUFBLE9BakdYLHlCQWlHVyxPQWpHWDtBQWlHb0IsZ0JBQUEsU0FqR3BCLHlCQWlHb0IsU0FqR3BCO0FBb0dJO0FBQ0EsZ0JBQUEsSUFBSSxHQUFHLFNBQVMsQ0FBQyxXQUFWLElBQXlCLEdBQWhDOztBQUNBLGdCQUFBLG1CQUFtQixDQUFDO0FBQUMsa0JBQUEsT0FBTyxFQUFQLE9BQUQ7QUFBVSxrQkFBQSxJQUFJLEVBQUo7QUFBVixpQkFBRCxDQUFuQixDQXRHSixDQXdHSTs7O0FBeEdKO0FBQUEsdUJBeUcyQixLQUFLLE9BQUwsQ0FDckI7QUFBQyxrQkFBQSxTQUFTLEVBQVQsU0FBRDtBQUFZLGtCQUFBLE9BQU8sRUFBUCxPQUFaO0FBQXFCLGtCQUFBLGNBQWMsRUFBZCxjQUFyQjtBQUFxQyxrQkFBQSxJQUFJLEVBQUosSUFBckM7QUFBMkMsa0JBQUEsTUFBTSxFQUFOO0FBQTNDLGlCQURxQixDQXpHM0I7O0FBQUE7QUF5R1UsZ0JBQUEsUUF6R1Y7O0FBMkdJLHFCQUFLLHFCQUFMLENBQTJCO0FBQUMsa0JBQUEsR0FBRyxFQUFFLEdBQU47QUFBVyxrQkFBQSxRQUFRLEVBQVIsUUFBWDtBQUFxQixrQkFBQSxHQUFHLEVBQUUsU0FBUyxDQUFDO0FBQXBDLGlCQUEzQjs7QUEzR0osa0RBNEdXLFFBNUdYOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBK0d1QixnQkFBQSxTQS9HdkIsU0ErR3VCLFNBL0d2QixFQStHa0MsR0EvR2xDLFNBK0drQyxHQS9HbEMsRUErR3VDLGNBL0d2QyxTQStHdUMsY0EvR3ZDLEVBK0d1RCxNQS9HdkQsU0ErR3VELE1BL0d2RDs7QUFBQSxzQkFpSE8sTUFBTSxDQUFDLElBQVAsR0FBYyxnQkFqSHJCO0FBQUE7QUFBQTtBQUFBOztBQUFBLHNCQWtIWSxJQUFJLFdBQUosQ0FDSiwyQ0FESSxFQUVKLHdCQUZJLEVBR0o7QUFDRSxrQkFBQSxJQUFJLEVBQUUsU0FBUyxDQUFDLGNBQVYsS0FBNkIsYUFBN0IsR0FDSiwrQkFESSxHQUVKLGtCQUhKO0FBSUUsa0JBQUEsR0FBRyxFQUFFO0FBSlAsaUJBSEksQ0FsSFo7O0FBQUE7QUFBQSxxQkErSE8sTUFBTSxDQUFDLEdBQVAsQ0FBVyxHQUFYLENBL0hQO0FBQUE7QUFBQTtBQUFBOztBQUFBLHNCQWdJWSxJQUFJLFdBQUosQ0FDSixrQ0FESSxFQUVKLHdCQUZJLEVBR0o7QUFDRSxrQkFBQSxJQUFJLEVBQUUsU0FBUyxDQUFDLGNBQVYsS0FBNkIsYUFBN0IsR0FDSiw2QkFESSxHQUVKLGtCQUhKO0FBSUUsa0JBQUEsR0FBRyxFQUFIO0FBSkYsaUJBSEksQ0FoSVo7O0FBQUE7QUEySUk7QUFDQSxnQkFBQSxNQUFNLENBQUMsR0FBUCxDQUFXLEdBQVg7QUE1SUo7QUFBQTtBQUFBLHVCQWtKd0IsY0FBYyxDQUFDLEdBQUQsQ0FsSnRDOztBQUFBO0FBa0pNLGdCQUFBLFNBbEpOO0FBbUpNLGdCQUFBLE9BQU8sR0FBRyxTQUFTLENBQUMsUUFBVixJQUFzQixJQUFoQyxDQW5KTixDQW9KTTs7QUFDQSxvQkFBRyxTQUFTLENBQUMsT0FBRCxDQUFaLEVBQXVCO0FBQ3JCLGtCQUFBLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLE9BQVgsQ0FBVjtBQUNEOztBQXZKUDtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQXlKWSxJQUFJLFdBQUosQ0FDSixtRUFDQSx5REFEQSxHQUVBLCtEQUZBLEdBR0EsdURBSEEsR0FJQSwyREFKQSxHQUtBLGdDQU5JLEVBT0osbUJBUEksRUFRSjtBQUFDLGtCQUFBLElBQUksRUFBRSwrQkFBUDtBQUF3QyxrQkFBQSxHQUFHLEVBQUgsR0FBeEM7QUFBNkMsa0JBQUEsS0FBSztBQUFsRCxpQkFSSSxDQXpKWjs7QUFBQTtBQUFBLG9CQXFLUSxTQUFTLENBQUMsT0FBRCxDQXJLakI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsc0JBc0tZLElBQUksV0FBSixDQUNKLDhEQUNBLHdEQUZJLEVBR0osbUJBSEksRUFHaUI7QUFBQyxrQkFBQSxJQUFJLEVBQUUsd0JBQVA7QUFBaUMsa0JBQUEsR0FBRyxFQUFIO0FBQWpDLGlCQUhqQixDQXRLWjs7QUFBQTtBQTRLSTtBQUNBLG9CQUFHLEVBQUUsY0FBYyxPQUFoQixDQUFILEVBQTZCO0FBQzNCLGtCQUFBLE9BQU8sR0FBRztBQUFDLGdDQUFZO0FBQWIsbUJBQVY7QUFDRCxpQkFGRCxNQUVPO0FBQ0wsa0JBQUEsT0FBTyxHQUFHO0FBQUMsZ0NBQVksT0FBTyxDQUFDLFVBQUQ7QUFBcEIsbUJBQVY7QUFDRCxpQkFqTEwsQ0FtTEk7OztBQUNBLG9CQUFHLFNBQVMsQ0FBQyxVQUFiLEVBQXlCO0FBQ3ZCLHNCQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFELENBQVIsQ0FBWixFQUFtQztBQUNqQyxvQkFBQSxPQUFPLENBQUMsVUFBRCxDQUFQLEdBQXNCLENBQUMsT0FBTyxDQUFDLFVBQUQsQ0FBUixDQUF0QjtBQUNEOztBQUNELGtCQUFBLE9BQU8sQ0FBQyxVQUFELENBQVAsQ0FBb0IsSUFBcEIsQ0FBeUIsU0FBUyxDQUFDLFVBQW5DO0FBQ0Q7O0FBekxMLGtEQTJMVztBQUFDLGtCQUFBLE9BQU8sRUFBUCxPQUFEO0FBQVUsa0JBQUEsU0FBUyxFQUFUO0FBQVYsaUJBM0xYOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQStMQSxTQUFTLHlCQUFULENBQW1DLEdBQW5DLEVBQXdDO0FBQ3RDLFFBQU0sSUFBSSxXQUFKLENBQ0oscURBREksRUFFSixvQkFGSSxFQUVrQjtBQUNwQixJQUFBLElBQUksRUFBRSx1QkFEYztBQUNXLElBQUEsT0FBTyxFQUFFO0FBRHBCLEdBRmxCLENBQU47QUFLRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLG1CQUFULFFBQThDO0FBQUEsTUFBaEIsT0FBZ0IsU0FBaEIsT0FBZ0I7QUFBQSxNQUFQLElBQU8sU0FBUCxJQUFPOztBQUM1QyxNQUFHLENBQUMsT0FBSixFQUFhO0FBQ1g7QUFDRDs7QUFFRCxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsVUFBRCxDQUFuQjs7QUFFQSxNQUFHLFNBQVMsQ0FBQyxHQUFELENBQVosRUFBbUI7QUFDakIsSUFBQSxPQUFPLENBQUMsVUFBRCxDQUFQLEdBQXNCLFdBQVcsQ0FBQyxJQUFELEVBQU8sR0FBUCxDQUFqQztBQUNBO0FBQ0Q7O0FBRUQsTUFBRyxRQUFRLENBQUMsR0FBRCxDQUFYLEVBQWtCO0FBQ2hCLFNBQUksSUFBSSxDQUFDLEdBQUcsQ0FBWixFQUFlLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBdkIsRUFBK0IsRUFBRSxDQUFqQyxFQUFvQztBQUNsQyxVQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsQ0FBRCxDQUFuQjs7QUFDQSxVQUFHLFNBQVMsQ0FBQyxPQUFELENBQVosRUFBdUI7QUFDckIsUUFBQSxHQUFHLENBQUMsQ0FBRCxDQUFILEdBQVMsV0FBVyxDQUFDLElBQUQsRUFBTyxPQUFQLENBQXBCO0FBQ0E7QUFDRDs7QUFDRCxVQUFHLFNBQVMsQ0FBQyxPQUFELENBQVosRUFBdUI7QUFDckIsUUFBQSxtQkFBbUIsQ0FBQztBQUFDLFVBQUEsT0FBTyxFQUFFO0FBQUMsd0JBQVk7QUFBYixXQUFWO0FBQWlDLFVBQUEsSUFBSSxFQUFKO0FBQWpDLFNBQUQsQ0FBbkI7QUFDRDtBQUNGOztBQUNEO0FBQ0Q7O0FBRUQsTUFBRyxDQUFDLFNBQVMsQ0FBQyxHQUFELENBQWIsRUFBb0I7QUFDbEI7QUFDQTtBQUNELEdBN0IyQyxDQStCNUM7OztBQUNBLE9BQUksSUFBTSxJQUFWLElBQWtCLEdBQWxCLEVBQXVCO0FBQ3JCLElBQUEsbUJBQW1CLENBQUM7QUFBQyxNQUFBLE9BQU8sRUFBRSxHQUFHLENBQUMsSUFBRCxDQUFiO0FBQXFCLE1BQUEsSUFBSSxFQUFKO0FBQXJCLEtBQUQsQ0FBbkI7QUFDRDtBQUNGOzs7QUNwUUQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLE1BQU0sQ0FBQyxPQUFQO0FBQUE7O0FBQUE7O0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSx5QkFHZ0I7QUFBQTs7QUFBQSxRQUZkLE9BRWMsdUVBRkosd0NBRUk7QUFBQSxRQURkLElBQ2MsdUVBRFAsY0FDTztBQUFBLFFBQWQsT0FBYyx1RUFBSixFQUFJO0FBQUE7QUFDZCw4QkFBTSxPQUFOO0FBQ0EsVUFBSyxJQUFMLEdBQVksSUFBWjtBQUNBLFVBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxVQUFLLE9BQUwsR0FBZSxPQUFmO0FBSmM7QUFLZjs7QUFoQkg7QUFBQSxrREFBMkMsS0FBM0M7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUVBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFVBQUEsTUFBTSxFQUFJO0FBQUEsTUFDbkIsZUFEbUI7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLGlDQUVaO0FBQ1QsZUFBTywwQkFBUDtBQUNEO0FBSnNCO0FBQUE7QUFBQTs7QUFNekIsRUFBQSxNQUFNLENBQUMsY0FBUCxDQUFzQixlQUF0QixFQUF1QyxXQUF2QyxFQUFvRDtBQUNsRCxJQUFBLFFBQVEsRUFBRSxLQUR3QztBQUVsRCxJQUFBLFVBQVUsRUFBRTtBQUZzQyxHQUFwRDtBQUlBLEVBQUEsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsZUFBZSxDQUFDLFNBQXRDLEVBQWlELGFBQWpELEVBQWdFO0FBQzlELElBQUEsUUFBUSxFQUFFLElBRG9EO0FBRTlELElBQUEsVUFBVSxFQUFFLEtBRmtEO0FBRzlELElBQUEsWUFBWSxFQUFFLElBSGdEO0FBSTlELElBQUEsS0FBSyxFQUFFO0FBSnVELEdBQWhFLEVBVnlCLENBaUJ6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUEsZUFBZSxDQUFDLE9BQWhCLEdBQTBCLFVBQVMsS0FBVCxFQUFnQixHQUFoQixFQUFxQjtBQUM3QyxRQUFHLFNBQVMsQ0FBQyxNQUFWLEdBQW1CLENBQXRCLEVBQXlCO0FBQ3ZCLGFBQU8sT0FBTyxDQUFDLE1BQVIsQ0FDTCxJQUFJLFNBQUosQ0FBYyx1Q0FBZCxDQURLLENBQVA7QUFFRDs7QUFDRCxXQUFPLE1BQU0sQ0FBQyxPQUFQLENBQWUsS0FBZixFQUFzQixHQUF0QixDQUFQO0FBQ0QsR0FORDs7QUFPQSxFQUFBLGVBQWUsQ0FBQyxNQUFoQixHQUF5QixVQUFTLEtBQVQsRUFBZ0I7QUFDdkMsUUFBRyxTQUFTLENBQUMsTUFBVixHQUFtQixDQUF0QixFQUF5QjtBQUN2QixhQUFPLE9BQU8sQ0FBQyxNQUFSLENBQ0wsSUFBSSxTQUFKLENBQWMsc0NBQWQsQ0FESyxDQUFQO0FBRUQ7O0FBQ0QsV0FBTyxNQUFNLENBQUMsTUFBUCxDQUFjLEtBQWQsQ0FBUDtBQUNELEdBTkQ7O0FBT0EsRUFBQSxlQUFlLENBQUMsT0FBaEIsR0FBMEIsVUFBUyxLQUFULEVBQWdCO0FBQ3hDLFFBQUcsU0FBUyxDQUFDLE1BQVYsR0FBbUIsQ0FBdEIsRUFBeUI7QUFDdkIsYUFBTyxPQUFPLENBQUMsTUFBUixDQUNMLElBQUksU0FBSixDQUFjLHVDQUFkLENBREssQ0FBUDtBQUVEOztBQUNELFdBQU8sTUFBTSxDQUFDLE9BQVAsQ0FBZSxLQUFmLENBQVA7QUFDRCxHQU5EOztBQVFBLFNBQU8sZUFBUDtBQUNELENBOUNEOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQSxhLENBRUE7O0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsT0FBTyxDQUFDLGNBQUQsQ0FBUCxDQUF3QixNQUF6Qzs7O0FDTkE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7Ozs7Ozs7O2VBUUksT0FBTyxDQUFDLGFBQUQsQztJQUxULGMsWUFBQSxjO0lBQ0EsaUIsWUFBQSxpQjtJQUNBLFUsWUFBQSxVO0lBQ0EsZSxZQUFBLGU7SUFDQSxVLFlBQUEsVTs7QUFHRixJQUFJLEtBQUo7O0FBQ0EsSUFBRyxPQUFPLElBQVAsS0FBZ0IsV0FBbkIsRUFBZ0M7QUFDOUIsRUFBQSxLQUFLLEdBQUcsSUFBUjtBQUNELENBRkQsTUFFTztBQUNMLEVBQUEsS0FBSyxHQUFHO0FBQ04sSUFBQSxZQUFZLEVBQUUsQ0FEUjtBQUVOLElBQUEsY0FBYyxFQUFFLENBRlY7QUFHTixJQUFBLFNBQVMsRUFBRSxDQUhMO0FBSU4sSUFBQSxrQkFBa0IsRUFBRSxDQUpkO0FBS04sSUFBQSxxQkFBcUIsRUFBRSxDQUxqQjtBQU1OLElBQUEsV0FBVyxFQUFFLENBTlA7QUFPTixJQUFBLDJCQUEyQixFQUFFLENBUHZCO0FBUU4sSUFBQSxZQUFZLEVBQUUsQ0FSUjtBQVNOLElBQUEsYUFBYSxFQUFFLENBVFQ7QUFVTixJQUFBLGtCQUFrQixFQUFFLEVBVmQ7QUFXTixJQUFBLHNCQUFzQixFQUFFLEVBWGxCO0FBWU4sSUFBQSxhQUFhLEVBQUU7QUFaVCxHQUFSO0FBY0Q7O0FBRUQsTUFBTSxDQUFDLE9BQVA7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBLDBCQVFRLElBUlIsRUFRYztBQUNWLFVBQU0sT0FBTyxHQUFHLEVBQWhCO0FBQ0EsTUFBQSxPQUFPLENBQUMsVUFBRCxDQUFQLEdBQXNCLEVBQXRCO0FBRUEsVUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQUwsRUFBakI7O0FBQ0EsV0FBSSxJQUFJLEVBQUUsR0FBRyxDQUFiLEVBQWdCLEVBQUUsR0FBRyxRQUFRLENBQUMsTUFBOUIsRUFBc0MsRUFBRSxFQUF4QyxFQUE0QztBQUMxQyxZQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsRUFBRCxDQUF4Qjs7QUFDQSxZQUFHLE9BQU8sS0FBSyxJQUFmLEVBQXFCO0FBQ25CO0FBQ0QsU0FKeUMsQ0FNMUM7OztBQUNBLFlBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxpQkFBTCxDQUF1QixPQUF2QixDQUFoQjs7QUFDQSxZQUFHLE9BQU8sS0FBSyxJQUFmLEVBQXFCO0FBQ25CO0FBQ0Q7O0FBQ0QsWUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQTNCOztBQUNBLGFBQUksSUFBTSxTQUFWLElBQXVCLFVBQXZCLEVBQW1DO0FBQ2pDO0FBQ0EsY0FBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLFNBQUQsQ0FBVixDQUFzQixPQUF0Qzs7QUFDQSxlQUFJLElBQUksRUFBRSxHQUFHLENBQWIsRUFBZ0IsRUFBRSxHQUFHLE9BQU8sQ0FBQyxNQUE3QixFQUFxQyxFQUFFLEVBQXZDLEVBQTJDO0FBQ3pDLGdCQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsRUFBRCxDQUF0QixDQUR5QyxDQUd6Qzs7QUFDQSxnQkFBTSxNQUFNLEdBQUcsRUFBZixDQUp5QyxDQU16Qzs7QUFDQSxnQkFBRyxPQUFPLENBQUMsT0FBUixDQUFnQixJQUFoQixNQUEwQixDQUE3QixFQUFnQztBQUM5QixjQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCO0FBQUMsZ0JBQUEsSUFBSSxFQUFFLFlBQVA7QUFBcUIsZ0JBQUEsS0FBSyxFQUFFO0FBQTVCLGVBQWpCO0FBQ0QsYUFGRCxNQUVPO0FBQ0wsY0FBQSxNQUFNLENBQUMsT0FBUCxHQUFpQjtBQUFDLGdCQUFBLElBQUksRUFBRSxLQUFQO0FBQWMsZ0JBQUEsS0FBSyxFQUFFO0FBQXJCLGVBQWpCO0FBQ0QsYUFYd0MsQ0FhekM7OztBQUNBLGdCQUFHLFNBQVMsQ0FBQyxPQUFWLENBQWtCLElBQWxCLE1BQTRCLENBQS9CLEVBQWtDO0FBQ2hDLGNBQUEsTUFBTSxDQUFDLFNBQVAsR0FBbUI7QUFBQyxnQkFBQSxJQUFJLEVBQUUsWUFBUDtBQUFxQixnQkFBQSxLQUFLLEVBQUU7QUFBNUIsZUFBbkI7QUFDRCxhQUZELE1BRU87QUFDTCxjQUFBLE1BQU0sQ0FBQyxTQUFQLEdBQW1CO0FBQUMsZ0JBQUEsSUFBSSxFQUFFLEtBQVA7QUFBYyxnQkFBQSxLQUFLLEVBQUU7QUFBckIsZUFBbkI7QUFDRCxhQWxCd0MsQ0FvQnpDOzs7QUFDQSxnQkFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQW5COztBQUNBLGdCQUFHLE1BQU0sQ0FBQyxJQUFQLEtBQWdCLGVBQW5CLEVBQW9DO0FBQ2xDO0FBQ0Esa0JBQU0sY0FBYSxHQUFHLHFCQUFxQixFQUEzQzs7QUFDQSxrQkFBTSxVQUFVLEdBQUcsSUFBSSxjQUFKLEVBQW5CO0FBQ0EsY0FBQSxLQUFLLEdBQUcsRUFBUjs7QUFDQSxtQkFBSSxJQUFJLENBQUMsR0FBRyxDQUFaLEVBQWUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFQLENBQWEsTUFBaEMsRUFBd0MsQ0FBQyxFQUF6QyxFQUE2QztBQUMzQyxvQkFBRyxNQUFNLENBQUMsS0FBUCxDQUFhLENBQWIsRUFBZ0IsUUFBaEIsS0FBNkIsS0FBSyxDQUFDLFlBQXRDLEVBQW9EO0FBQ2xELGtCQUFBLEtBQUssSUFBSSxVQUFVLENBQUMsaUJBQVgsQ0FBNkIsTUFBTSxDQUFDLEtBQVAsQ0FBYSxDQUFiLENBQTdCLENBQVQ7QUFDRCxpQkFGRCxNQUVPLElBQUcsTUFBTSxDQUFDLEtBQVAsQ0FBYSxDQUFiLEVBQWdCLFFBQWhCLEtBQTZCLEtBQUssQ0FBQyxTQUF0QyxFQUFpRDtBQUN0RCxrQkFBQSxLQUFLLElBQUksTUFBTSxDQUFDLEtBQVAsQ0FBYSxDQUFiLEVBQWdCLFNBQXpCO0FBQ0Q7QUFDRjtBQUNGLGFBbEN3QyxDQW9DekM7OztBQUNBLFlBQUEsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsRUFBaEIsQ0FyQ3lDLENBdUN6Qzs7QUFDQSxnQkFBRyxNQUFNLENBQUMsSUFBUCxLQUFnQixVQUFuQixFQUErQjtBQUM3QixrQkFBRyxNQUFNLENBQUMsS0FBUCxDQUFhLE9BQWIsQ0FBcUIsSUFBckIsTUFBK0IsQ0FBbEMsRUFBcUM7QUFDbkMsZ0JBQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLEdBQXFCLFlBQXJCO0FBQ0QsZUFGRCxNQUVPO0FBQ0wsZ0JBQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLEdBQXFCLEtBQXJCO0FBQ0Q7QUFDRixhQU5ELE1BTU87QUFDTDtBQUNBLGNBQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLEdBQXFCLFNBQXJCOztBQUNBLGtCQUFHLE1BQU0sQ0FBQyxJQUFQLEtBQWdCLGlCQUFuQixFQUFzQztBQUNwQyxvQkFBRyxNQUFNLENBQUMsUUFBVixFQUFvQjtBQUNsQixrQkFBQSxNQUFNLENBQUMsTUFBUCxDQUFjLFFBQWQsR0FBeUIsY0FBekI7QUFDQSxrQkFBQSxNQUFNLENBQUMsTUFBUCxDQUFjLFFBQWQsR0FBeUIsTUFBTSxDQUFDLFFBQWhDO0FBQ0QsaUJBSEQsTUFHTztBQUNMLGtCQUFBLE1BQU0sQ0FBQyxNQUFQLENBQWMsUUFBZCxHQUF5QixVQUF6QjtBQUNEO0FBQ0YsZUFQRCxNQU9PO0FBQ0wsZ0JBQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxRQUFkLEdBQXlCLE1BQU0sQ0FBQyxJQUFoQztBQUNEO0FBQ0Y7O0FBQ0QsWUFBQSxNQUFNLENBQUMsTUFBUCxDQUFjLEtBQWQsR0FBc0IsS0FBdEIsQ0E1RHlDLENBOER6Qzs7QUFDQSxZQUFBLE9BQU8sQ0FBQyxVQUFELENBQVAsQ0FBb0IsSUFBcEIsQ0FBeUIsTUFBekI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBTyxPQUFQO0FBQ0Q7QUFqR0g7QUFBQTtBQUFBOztBQW9HQSxTQUFTLHFCQUFULEdBQWlDO0FBQy9CLE1BQUcsT0FBTyxhQUFQLEtBQXlCLFdBQTVCLEVBQXlDO0FBQ3ZDLFdBQU8sT0FBTyxDQUFDLFFBQUQsQ0FBUCxDQUFrQixhQUF6QjtBQUNEOztBQUNELFNBQU8sYUFBUDtBQUNEOzs7QUMzSUQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBLE1BQU0sQ0FBQyxPQUFQO0FBQ0U7QUFDRjtBQUNBO0FBQ0UsMEJBQWM7QUFBQTtBQUNaLFNBQUssU0FBTCxHQUFpQixFQUFqQjtBQUNEOztBQU5IO0FBQUE7QUFBQSwrQkFRYSxNQVJiLEVBUXFCO0FBQ2pCLFVBQU0sSUFBSSxHQUFHLElBQWI7QUFDQSxNQUFBLElBQUksQ0FBQyxPQUFMLEdBQWUsTUFBZjtBQUNBLGFBQU87QUFBUztBQUFXO0FBQ3pCLGVBQU8sSUFBSSxDQUFDLEdBQUwsQ0FBUyxLQUFULENBQWUsSUFBZixFQUFxQixTQUFyQixDQUFQO0FBQ0QsT0FGRDtBQUdEO0FBZEg7QUFBQTtBQUFBO0FBQUEsZ0hBZ0JZLEdBaEJaO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWlCUSxnQkFBQSxPQWpCUixHQWlCa0IsS0FBSyxTQUFMLENBQWUsR0FBZixDQWpCbEI7O0FBQUEscUJBa0JPLE9BbEJQO0FBQUE7QUFBQTtBQUFBOztBQUFBLGlEQW9CYSxPQUFPLENBQUMsT0FBUixDQUFnQixPQUFoQixDQXBCYjs7QUFBQTtBQXVCSTtBQUNBLGdCQUFBLE9BQU8sR0FBRyxLQUFLLFNBQUwsQ0FBZSxHQUFmLElBQXNCLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaEM7QUF4Qko7QUFBQTtBQUFBLHVCQTJCbUIsT0EzQm5COztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQTZCTSx1QkFBTyxLQUFLLFNBQUwsQ0FBZSxHQUFmLENBQVA7QUE3Qk47O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUVBLElBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxXQUFELENBQW5COztBQUVBLElBQU0sbUJBQW1CLEdBQUcsRUFBNUI7O0FBRUEsTUFBTSxDQUFDLE9BQVA7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsaUNBQXdCO0FBQUEsUUFBWCxRQUFXLFFBQVgsUUFBVztBQUFBO0FBQ3RCLFNBQUssUUFBTCxHQUFnQixRQUFoQixDQURzQixDQUV0QjtBQUNBOztBQUNBLFNBQUssS0FBTCxHQUFhLElBQUksR0FBSixDQUFRO0FBQUMsTUFBQSxHQUFHLEVBQUU7QUFBTixLQUFSLENBQWI7QUFDRDs7QUFYSDtBQUFBO0FBQUEsaUNBYWUsU0FiZixFQWEwQjtBQUN0QixhQUFPLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSxTQUFmLENBQVA7QUFDRDtBQWZIO0FBQUE7QUFBQSxpQ0FpQmUsU0FqQmYsRUFpQjBCLFlBakIxQixFQWlCd0M7QUFDcEMsV0FBSyxLQUFMLENBQVcsR0FBWCxDQUFlLFNBQWYsRUFBMEIsWUFBMUI7QUFDRDtBQW5CSDtBQUFBO0FBQUE7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLGVBQUQsQ0FBM0I7O2VBT0ksT0FBTyxDQUFDLFNBQUQsQztJQUpBLFEsWUFBVCxPO0lBQ1UsUyxZQUFWLFE7SUFDVSxTLFlBQVYsUTtJQUNhLFksWUFBYixXOztnQkFTRSxPQUFPLENBQUMsY0FBRCxDO0lBTEQsTyxhQUFSLE07SUFDUyxRLGFBQVQsTztJQUNTLFEsYUFBVCxPO0lBQ2UsYyxhQUFmLGE7SUFDb0IsbUIsYUFBcEIsa0I7O2dCQVNFLE9BQU8sQ0FBQyxXQUFELEM7SUFMRSxVLGFBQVgsUztJQUNpQixnQixhQUFqQixlO0lBQ1csVSxhQUFYLFM7SUFDUyxlLGFBQVQsTztJQUNnQixlLGFBQWhCLGM7O2dCQU1FLE9BQU8sQ0FBQyxPQUFELEM7SUFGRyxXLGFBQVosVTtJQUNhLFksYUFBYixXOztnQkFPRSxPQUFPLENBQUMsUUFBRCxDO0lBSEMsUyxhQUFWLFE7SUFDUyxRLGFBQVQsTztJQUNzQixxQixhQUF0QixvQjs7QUFHRixJQUFNLEdBQUcsR0FBRyxFQUFaO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsR0FBakI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxHQUFHLENBQUMsT0FBSjtBQUFBLDRGQUFjO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDWixZQUFBLFNBRFksUUFDWixTQURZLDZCQUVaLGNBRlksRUFFWixjQUZZLG9DQUVLLElBRkwsd0JBR1osT0FIWSxRQUdaLE9BSFksc0JBSVosT0FKWSxFQUlaLE9BSlksNkJBSUYsRUFKRSwyQ0FLWixhQUxZLEVBS1osYUFMWSxtQ0FLSTtBQUFBLHFCQUFNLFNBQU47QUFBQSxhQUxKOztBQUFBLGlCQVFULFFBQVEsQ0FBQyxPQUFELENBUkM7QUFBQTtBQUFBO0FBQUE7O0FBU04sWUFBQSxJQVRNLEdBU0MsRUFURDtBQVVGLFlBQUEsQ0FWRSxHQVVFLENBVkY7O0FBQUE7QUFBQSxrQkFVSyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BVmpCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBWWMsR0FBRyxDQUFDLE9BQUosQ0FBWTtBQUNoQyxjQUFBLFNBQVMsRUFBVCxTQURnQztBQUVoQyxjQUFBLGNBQWMsRUFBZCxjQUZnQztBQUdoQyxjQUFBLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBRCxDQUhnQjtBQUloQyxjQUFBLE9BQU8sRUFBUCxPQUpnQztBQUtoQyxjQUFBLGFBQWEsRUFBYjtBQUxnQyxhQUFaLENBWmQ7O0FBQUE7QUFZSixZQUFBLFNBWkk7O0FBQUEsa0JBbUJMLFNBQVMsS0FBSyxJQW5CVDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQW9CWSxhQUFhLENBQUM7QUFDOUIsY0FBQSxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUQsQ0FEUTtBQUU5QixjQUFBLFNBQVMsRUFBVCxTQUY4QjtBQUc5QixjQUFBLGNBQWMsRUFBZCxjQUg4QjtBQUk5QixjQUFBLE1BQU0sRUFBRSxPQUpzQjtBQUs5QixjQUFBLEtBQUssRUFBRSxDQUx1QjtBQU05QixjQUFBLE9BQU8sRUFBUDtBQU44QixhQUFELENBcEJ6Qjs7QUFBQTtBQW9CTixZQUFBLFNBcEJNOztBQUFBLGtCQTRCSCxTQUFTLEtBQUssU0E1Qlg7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFnQ1IsWUFBQSxJQUFJLENBQUMsSUFBTCxDQUFVLFNBQVY7O0FBaENRO0FBVXlCLGNBQUUsQ0FWM0I7QUFBQTtBQUFBOztBQUFBO0FBa0NWLGdCQUFHLE9BQU8sQ0FBQyxhQUFSLElBQXlCLElBQUksQ0FBQyxNQUFMLEtBQWdCLENBQTVDLEVBQStDO0FBQzdDO0FBQ00sY0FBQSxTQUZ1QyxHQUUzQixnQkFBZ0IsQ0FDaEMsU0FEZ0MsRUFDckIsY0FEcUIsRUFDTCxZQURLLENBQWhCLElBQzRCLEVBSEQ7O0FBSTdDLGtCQUFHLFNBQVMsQ0FBQyxNQUFWLEtBQXFCLENBQXhCLEVBQTJCO0FBQ3pCLGdCQUFBLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBRCxDQUFYO0FBQ0Q7QUFDRjs7QUF6Q1MsOENBMENILElBMUNHOztBQUFBO0FBNkNaO0FBQ00sWUFBQSxHQTlDTSxHQThDQSxnQkFBZ0IsQ0FBQyxTQUFELEVBQVksY0FBWixFQUE0QixVQUE1QixDQTlDaEI7O0FBQUEsZ0JBK0NSLFlBQVksQ0FBQyxHQUFELENBL0NKO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBZ0RRLGVBQWUsQ0FBQztBQUNoQyxjQUFBLFNBQVMsRUFBVCxTQURnQztBQUVoQyxjQUFBLFFBQVEsRUFBRSxHQUZzQjtBQUdoQyxjQUFBLFNBQVMsRUFBRSxJQUhxQjtBQUloQyxjQUFBLGlCQUFpQixFQUFFLElBSmE7QUFLaEMsY0FBQSxPQUFPLEVBQVA7QUFMZ0MsYUFBRCxDQWhEdkI7O0FBQUE7QUFnRFYsWUFBQSxTQWhEVTs7QUFBQTtBQUFBLGlCQTBEVCxTQUFTLENBQUMsT0FBRCxDQTFEQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsNEJBMkRQLE9BQU8sQ0FBQyxJQUFSLElBQWdCLFNBQVMsT0FBekIsSUFDRCxPQUFPLENBQUMsSUFBUixDQUFhLGNBQWIsQ0FBNEIsT0FBTyxDQUFDLEtBQUQsQ0FBbkMsQ0E1RFE7QUFBQTtBQUFBO0FBQUE7O0FBNkRSO0FBQ00sc0JBQUEsTUE5REUsR0E4RE8sT0FBTyxDQUFDLElBQVIsQ0FBYSxPQUFPLENBQUMsS0FBRCxDQUFwQixDQTlEUDtBQStEQSxzQkFBQSxFQS9EQSxHQStESSxDQS9ESjs7QUFBQTtBQUFBLDRCQStETyxFQUFDLEdBQUcsTUFBTSxDQUFDLE1BL0RsQjtBQUFBO0FBQUE7QUFBQTs7QUFBQSw0QkFnRUgsTUFBTSxDQUFDLEVBQUQsQ0FBTixDQUFVLFFBQVYsS0FBdUIsT0FoRXBCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsMkJBaUVHLE1BQU0sQ0FBQyxFQUFELENBQU4sQ0FBVTtBQWpFYjs7QUFBQTtBQStEMEIsd0JBQUUsRUEvRDVCO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDRCQXVFUCxRQUFRLENBQUMsT0FBRCxDQUFSLElBQXFCLG1CQUFtQixDQUFDLE9BQUQsQ0F2RWpDO0FBQUE7QUFBQTtBQUFBOztBQXdFRixzQkFBQSxLQXhFRSxHQXlFTixHQUFHLENBQUMsWUFBSixDQUFpQjtBQUFDLHdCQUFBLFNBQVMsRUFBVCxTQUFEO0FBQVksd0JBQUEsY0FBYyxFQUFkLGNBQVo7QUFBNEIsd0JBQUEsS0FBSyxFQUFFLE9BQW5DO0FBQTRDLHdCQUFBLE9BQU8sRUFBUDtBQUE1Qyx1QkFBakIsQ0F6RU07O0FBMEVSLDBCQUFHLE9BQU8sQ0FBQyxJQUFSLElBQWdCLG1CQUFtQixDQUFDLE9BQUQsQ0FBdEMsRUFBaUQ7QUFDL0M7QUFDQSw0QkFBRyxDQUFFLE9BQU8sQ0FBQyxJQUFSLENBQWEsY0FBYixDQUE0QixPQUFPLENBQUMsS0FBRCxDQUFuQyxDQUFMLEVBQW1EO0FBQ2pELDBCQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWEsT0FBTyxDQUFDLEtBQUQsQ0FBcEIsSUFBK0IsRUFBL0I7QUFDRDs7QUFDRCx3QkFBQSxPQUFPLENBQUMsSUFBUixDQUFhLE9BQU8sQ0FBQyxLQUFELENBQXBCLEVBQTZCLElBQTdCLENBQWtDO0FBQUMsMEJBQUEsUUFBUSxFQUFFLE9BQVg7QUFBb0IsMEJBQUEsU0FBUyxFQUFFO0FBQS9CLHlCQUFsQztBQUNEOztBQWhGTztBQUFBLDJCQWlGRDtBQWpGQzs7QUFBQTtBQUFBLDJCQXNGUCxPQUFPLENBQUMsT0FBRCxDQXRGQTtBQUFBO0FBQUE7QUFBQTs7QUF1RkYsc0JBQUEsVUF2RkUsR0F1RlUsZ0JBQWdCLENBQ2hDLFNBRGdDLEVBQ3JCLGNBRHFCLEVBQ0wsWUFESyxDQUFoQixJQUM0QixFQXhGdEM7O0FBQUEsMkJBeUZMLFVBQVMsQ0FBQyxRQUFWLENBQW1CLE9BQW5CLENBekZLO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsMkJBMEZDLEdBQUcsQ0FBQyxPQUFKLENBQVk7QUFDakIsMEJBQUEsU0FBUyxFQUFULFNBRGlCO0FBRWpCLDBCQUFBLGNBQWMsRUFBZCxjQUZpQjtBQUdqQiwwQkFBQSxPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQUQsQ0FIQztBQUlqQiwwQkFBQSxPQUFPLEVBQVAsT0FKaUI7QUFLakIsMEJBQUEsYUFBYSxFQUFiO0FBTGlCLHlCQUFaO0FBMUZEOztBQUFBO0FBb0dWO0FBQ00sc0JBQUEsYUFyR0ksR0FxR2EsY0FBYyxLQUFLLFVBckdoQztBQXVHSixzQkFBQSxJQXZHSSxHQXVHRyxFQXZHSCxFQXlHVjs7QUFDTSxzQkFBQSxRQTFHSSxHQTBHTyxTQTFHUCxFQTRHVjtBQUNBOztBQUNBLDBCQUFHLENBQUMsUUFBUSxDQUFDLE9BQUQsQ0FBVCxJQUFzQixDQUFDLG1CQUFtQixDQUFDLE9BQUQsQ0FBN0MsRUFBd0Q7QUFDdEQsd0JBQUEsU0FBUyxHQUFHLFNBQVMsQ0FBQyx1QkFBVixFQUFaO0FBQ0QsdUJBaEhTLENBa0hWOzs7QUFDTSxzQkFBQSxpQkFuSEksR0FvSFIsZ0JBQWdCLENBQUMsUUFBRCxFQUFXLGNBQVgsRUFBMkIsVUFBM0IsQ0FwSFI7O0FBQUEsMEJBcUhOLFlBQVksQ0FBQyxpQkFBRCxDQXJITjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDZCQXNIVSxlQUFlLENBQUM7QUFDaEMsd0JBQUEsU0FBUyxFQUFULFNBRGdDO0FBRWhDLHdCQUFBLFFBQVEsRUFBRSxpQkFGc0I7QUFHaEMsd0JBQUEsU0FBUyxFQUFFLElBSHFCO0FBSWhDLHdCQUFBLGlCQUFpQixFQUFFLElBSmE7QUFLaEMsd0JBQUEsT0FBTyxFQUFQO0FBTGdDLHVCQUFELENBdEh6Qjs7QUFBQTtBQXNIUixzQkFBQSxTQXRIUTs7QUFBQTtBQStIViwwQkFBRyxPQUFPLENBQUMsSUFBUixJQUFnQixTQUFTLE9BQTVCLEVBQXFDO0FBQ25DO0FBQ0EsNEJBQUcsQ0FBQyxPQUFPLENBQUMsSUFBUixDQUFhLGNBQWIsQ0FBNEIsT0FBTyxDQUFDLEtBQUQsQ0FBbkMsQ0FBSixFQUFpRDtBQUMvQywwQkFBQSxPQUFPLENBQUMsSUFBUixDQUFhLE9BQU8sQ0FBQyxLQUFELENBQXBCLElBQStCLEVBQS9CO0FBQ0Q7O0FBQ0Qsd0JBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYSxPQUFPLENBQUMsS0FBRCxDQUFwQixFQUE2QixJQUE3QixDQUFrQztBQUFDLDBCQUFBLFFBQVEsRUFBRSxPQUFYO0FBQW9CLDBCQUFBLFNBQVMsRUFBRTtBQUEvQix5QkFBbEM7QUFDRCx1QkFySVMsQ0F1SVY7QUFDQTtBQUNBOzs7QUFDSSxzQkFBQSxLQTFJTSxHQTBJRSxPQUFPLENBQUMsT0FBRCxDQUFQLElBQW9CLEVBMUl0Qjs7QUEySVYsMEJBQUcsS0FBSyxDQUFDLE1BQU4sR0FBZSxDQUFsQixFQUFxQjtBQUNuQix3QkFBQSxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQU4sQ0FBVyxLQUFYLEVBQWtCLElBQWxCLEVBQVI7QUFDRCx1QkE3SVMsQ0E4SVY7QUFDQTs7O0FBQ00sc0JBQUEsV0FoSkksR0FnSlUsU0FoSlY7QUFBQSw2REFpSlEsS0FqSlI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWlKQSxzQkFBQSxJQWpKQTtBQWtKRixzQkFBQSxhQWxKRSxHQWtKYyxHQUFHLENBQUMsVUFBSixDQUNwQjtBQUFDLHdCQUFBLFNBQVMsRUFBRSxXQUFaO0FBQXlCLHdCQUFBLEdBQUcsRUFBRSxJQUE5QjtBQUFvQyx3QkFBQSxVQUFVLEVBQUU7QUFBQywwQkFBQSxLQUFLLEVBQUU7QUFBUjtBQUFoRCx1QkFEb0IsQ0FsSmQsRUFxSlI7O0FBQ00sc0JBQUEsSUF0SkUsR0FzSkksZ0JBQWdCLENBQUMsUUFBRCxFQUFXLGFBQVgsRUFBMEIsVUFBMUIsQ0F0SnBCOztBQUFBLDBCQXVKSixZQUFZLENBQUMsSUFBRCxDQXZKUjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDZCQXdKWSxlQUFlLENBQUM7QUFDaEMsd0JBQUEsU0FBUyxFQUFULFNBRGdDO0FBRWhDLHdCQUFBLFFBQVEsRUFBRSxJQUZzQjtBQUdoQyx3QkFBQSxPQUFPLEVBQVAsT0FIZ0M7QUFJaEMsd0JBQUEsU0FBUyxFQUFFO0FBSnFCLHVCQUFELENBeEozQjs7QUFBQTtBQXdKTixzQkFBQSxTQXhKTTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBaUtWO0FBQ00sc0JBQUEsSUFsS0ksR0FrS0csTUFBTSxDQUFDLElBQVAsQ0FBWSxPQUFaLEVBQXFCLElBQXJCLEVBbEtIO0FBQUEsOERBbUtvQixJQW5LcEI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW1LQSxzQkFBQSxnQkFuS0E7QUFvS0Ysc0JBQUEsYUFwS0UsR0FvS2MsT0FBTyxDQUFDLGdCQUFELENBcEtyQixFQXNLUjs7QUF0S1EsNEJBdUtMLGdCQUFnQixLQUFLLEtBdktoQjtBQUFBO0FBQUE7QUFBQTs7QUF3S0Ysc0JBQUEsY0F4S0UsR0F3S2UsUUFBUSxDQUFDLGFBQUQsQ0FBUixDQUF3QixHQUF4QixDQUNuQixVQUFBLFdBQVc7QUFBQSwrQkFBSSxHQUFHLENBQUMsVUFBSixDQUFlO0FBQzVCLDBCQUFBLFNBQVMsRUFBVCxTQUQ0QjtBQUU1QiwwQkFBQSxHQUFHLEVBQUUsV0FGdUI7QUFHNUIsMEJBQUEsVUFBVSxFQUFFO0FBQUMsNEJBQUEsS0FBSyxFQUFFO0FBQVIsMkJBSGdCO0FBSTVCLDBCQUFBLElBQUksRUFBRSxPQUFPLENBQUM7QUFKYyx5QkFBZixDQUFKO0FBQUEsdUJBRFEsQ0F4S2Y7O0FBK0tOLDBCQUFHLGNBQWMsQ0FBQyxNQUFmLEtBQTBCLENBQTdCLEVBQWdDO0FBQzlCLHdCQUFBLGNBQWMsR0FBRyxjQUFjLENBQUMsQ0FBRCxDQUEvQjtBQUNELHVCQWpMSyxDQW1MTjs7O0FBQ00sc0JBQUEsS0FwTEEsR0FvTFEsR0FBRyxDQUFDLFVBQUosQ0FDWjtBQUFDLHdCQUFBLFNBQVMsRUFBVCxTQUFEO0FBQVksd0JBQUEsR0FBRyxFQUFFLEtBQWpCO0FBQXdCLHdCQUFBLFVBQVUsRUFBRTtBQUFDLDBCQUFBLEtBQUssRUFBRTtBQUFSO0FBQXBDLHVCQURZLENBcExSO0FBdUxOLHNCQUFBLElBQUksQ0FBQyxLQUFELENBQUosR0FBYyxjQUFkO0FBdkxNOztBQUFBO0FBQUEsNEJBNExMLGdCQUFnQixLQUFLLE9BNUxoQjtBQUFBO0FBQUE7QUFBQTs7QUE2TE47QUFDSSxzQkFBQSxlQTlMRSxHQThMZSxRQUFRLENBQUMsYUFBRCxDQUFSLENBQXdCLEdBQXhCLENBQ25CLFVBQUEsV0FBVztBQUFBLCtCQUFJLEdBQUcsQ0FBQyxVQUFKLENBQWU7QUFDNUIsMEJBQUEsU0FBUyxFQUFFLFFBRGlCO0FBRTVCLDBCQUFBLEdBQUcsRUFBRSxXQUZ1QjtBQUc1QiwwQkFBQSxVQUFVLEVBQUU7QUFBQyw0QkFBQSxLQUFLLEVBQUU7QUFBUjtBQUhnQix5QkFBZixDQUFKO0FBQUEsdUJBRFEsQ0E5TGY7O0FBb01OLDBCQUFHLGVBQWMsQ0FBQyxNQUFmLEtBQTBCLENBQTdCLEVBQWdDO0FBQzlCLHdCQUFBLGVBQWMsR0FBRyxlQUFjLENBQUMsQ0FBRCxDQUEvQjtBQUNELHVCQXRNSyxDQXdNTjs7O0FBQ00sc0JBQUEsTUF6TUEsR0F5TVEsR0FBRyxDQUFDLFVBQUosQ0FDWjtBQUFDLHdCQUFBLFNBQVMsRUFBVCxTQUFEO0FBQVksd0JBQUEsR0FBRyxFQUFFLE9BQWpCO0FBQTBCLHdCQUFBLFVBQVUsRUFBRTtBQUFDLDBCQUFBLEtBQUssRUFBRTtBQUFSO0FBQXRDLHVCQURZLENBek1SO0FBMk1BLHNCQUFBLFdBM01BLEdBMk1ZLGdCQUFnQixDQUNoQyxTQURnQyxFQUNyQixNQURxQixFQUNkLFlBRGMsQ0FBaEIsSUFDbUIsRUE1TS9CLEVBOE1OOztBQUNNLHNCQUFBLFNBL01BLEdBZ05KLFdBQVMsQ0FBQyxRQUFWLENBQW1CLE1BQW5CLEtBQ0EsZUFBZSxDQUFDLFNBQUQsRUFBWSxHQUFaLENBak5YO0FBa05BLHNCQUFBLE9BbE5BLEdBbU5KLFNBQVMsSUFBSyxRQUFRLENBQUMsZUFBRCxDQUFSLElBQTRCLGFBQWEsQ0FBQyxNQUFkLEtBQXlCLENBbk4vRDs7QUFvTk4sc0JBQUEsU0FBUyxDQUFDLElBQUQsRUFBTyxNQUFQLEVBQWMsZUFBZCxFQUE4QjtBQUFDLHdCQUFBLGVBQWUsRUFBRTtBQUFsQix1QkFBOUIsQ0FBVDs7QUFwTk07O0FBQUE7QUFBQSw0QkF5TkwsZ0JBQWdCLEtBQUssVUF6TmhCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsNkJBMk51QixHQUFHLENBQUMsT0FBSixDQUFZO0FBQ3ZDLHdCQUFBLFNBQVMsRUFBVCxTQUR1QztBQUV2Qyx3QkFBQSxjQUFjLEVBQUUsVUFGdUI7QUFHdkMsd0JBQUEsT0FBTyxFQUFFLGFBSDhCO0FBSXZDLHdCQUFBLE9BQU8sRUFBUCxPQUp1QztBQUt2Qyx3QkFBQSxhQUFhLEVBQWI7QUFMdUMsdUJBQVosQ0EzTnZCOztBQUFBO0FBMk5BLHNCQUFBLGdCQTNOQTs7QUFtT047QUFDQSwyQkFBVSxpQkFBVixJQUErQixnQkFBL0IsRUFBK0M7QUFDN0MsNEJBQUcsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsaUJBQXZCLEtBQ0QsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsaUJBQXZCLEVBQTBDLE9BRDVDLEVBQ3FEO0FBQzdDLDBCQUFBLEtBRDZDLEdBQ3JDLGdCQUFjLENBQUMsaUJBQUQsQ0FEdUI7QUFFN0MsMEJBQUEsV0FGNkMsR0FFakMsZ0JBQWdCLENBQ2hDLFNBRGdDLEVBQ3JCLGlCQURxQixFQUNGLFlBREUsQ0FBaEIsSUFDK0IsRUFIRTtBQUk3QywwQkFBQSxRQUo2QyxHQUtqRCxXQUFTLENBQUMsUUFBVixDQUFtQixNQUFuQixLQUE4QixDQUFDLE9BQU8sQ0FBQyxhQUxVOztBQU1uRCwwQkFBQSxTQUFTLENBQ1AsSUFETyxFQUNELGlCQURDLEVBQ2tCLEtBRGxCLEVBQ3lCO0FBQUMsNEJBQUEsZUFBZSxFQUFFO0FBQWxCLDJCQUR6QixDQUFUOztBQUVBLGlDQUFPLGdCQUFjLENBQUMsaUJBQUQsQ0FBckI7QUFDRDtBQUNGOztBQUVELDBCQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksZ0JBQVosRUFBNEIsTUFBNUIsR0FBcUMsQ0FBeEMsRUFBMkM7QUFDekM7QUFDTSx3QkFBQSxPQUZtQyxHQUUzQixHQUFHLENBQUMsVUFBSixDQUFlO0FBQzNCLDBCQUFBLFNBQVMsRUFBVCxTQUQyQjtBQUUzQiwwQkFBQSxHQUFHLEVBQUUsZ0JBRnNCO0FBRzNCLDBCQUFBLFVBQVUsRUFBRTtBQUFDLDRCQUFBLEtBQUssRUFBRTtBQUFSO0FBSGUseUJBQWYsQ0FGMkI7O0FBT3pDLHdCQUFBLFNBQVMsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFjLGdCQUFkLENBQVQ7QUFDRDs7QUExUEs7O0FBQUE7QUFBQSw0QkErUEwsZ0JBQWdCLEtBQUssV0EvUGhCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsNkJBaVF1QixHQUFHLENBQUMsT0FBSixDQUFZO0FBQ3ZDLHdCQUFBLFNBQVMsRUFBVCxTQUR1QztBQUV2Qyx3QkFBQSxjQUFjLEVBQWQsY0FGdUM7QUFHdkMsd0JBQUEsT0FBTyxFQUFFLGFBSDhCO0FBSXZDLHdCQUFBLE9BQU8sRUFBUCxPQUp1QztBQUt2Qyx3QkFBQSxhQUFhLEVBQWI7QUFMdUMsdUJBQVosQ0FqUXZCOztBQUFBO0FBaVFBLHNCQUFBLGdCQWpRQTs7QUF5UU4sMEJBQUcsRUFBRSxRQUFRLENBQUMsZ0JBQUQsQ0FBUixJQUE0QixnQkFBYyxDQUFDLE1BQWYsS0FBMEIsQ0FBeEQsQ0FBSCxFQUErRDtBQUM3RCx3QkFBQSxTQUFTLENBQUMsSUFBRCxFQUFPLGdCQUFQLEVBQXlCLGdCQUF6QixDQUFUO0FBQ0Q7O0FBM1FLOztBQUFBO0FBQUEsNEJBZ1JMLGdCQUFnQixLQUFLLFFBaFJoQjtBQUFBO0FBQUE7QUFBQTs7QUFpUk47QUFDTSxzQkFBQSxXQWxSQSxHQWtSWSxnQkFBZ0IsQ0FDaEMsU0FEZ0MsRUFDckIsY0FEcUIsRUFDTCxZQURLLENBQWhCLElBQzRCLEVBblJ4Qzs7QUFBQSwyQkFvUkgsV0FBUyxDQUFDLFFBQVYsQ0FBbUIsUUFBbkIsQ0FwUkc7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUF3Uk47QUFDTSxzQkFBQSxPQXpSQSxHQXlSUSxHQUFHLENBQUMsVUFBSixDQUFlO0FBQzNCLHdCQUFBLFNBQVMsRUFBVCxTQUQyQjtBQUUzQix3QkFBQSxHQUFHLEVBQUUsZ0JBRnNCO0FBRzNCLHdCQUFBLFVBQVUsRUFBRTtBQUFDLDBCQUFBLEtBQUssRUFBRTtBQUFSO0FBSGUsdUJBQWYsQ0F6UlI7O0FBOFJOLHNCQUFBLFNBQVMsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFjLGFBQWQsQ0FBVDs7QUE5Uk07O0FBQUE7QUFBQSw0QkFvU0wsZ0JBQWdCLEtBQUssUUFBckIsSUFBaUMsZ0JBQWdCLEtBQUssT0FBdEQsSUFDRCxnQkFBZ0IsS0FBSyxXQURwQixJQUVELFVBQVUsQ0FBQyxnQkFBRCxDQXRTSjtBQUFBO0FBQUE7QUFBQTs7QUF1U047QUFDTSxzQkFBQSxPQXhTQSxHQXdTUSxHQUFHLENBQUMsVUFBSixDQUFlO0FBQzNCLHdCQUFBLFNBQVMsRUFBVCxTQUQyQjtBQUUzQix3QkFBQSxHQUFHLEVBQUUsZ0JBRnNCO0FBRzNCLHdCQUFBLFVBQVUsRUFBRTtBQUFDLDBCQUFBLEtBQUssRUFBRTtBQUFSO0FBSGUsdUJBQWYsQ0F4U1I7O0FBNlNOLHNCQUFBLFNBQVMsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFjLGFBQWQsQ0FBVDs7QUE3U007O0FBQUE7QUFBQSwwQkFrVEosUUFBUSxDQUFDLGFBQUQsQ0FsVEo7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNEJBbVRBLElBQUksV0FBSixDQUNKLDJEQURJLEVBRUosb0JBRkksQ0FuVEE7O0FBQUE7QUF3VFI7QUFDQSwwQkFBRyxhQUFhLENBQUMsTUFBZCxLQUF5QixDQUE1QixFQUErQjtBQUN2Qix3QkFBQSxrQkFEdUIsR0FDRixHQUFHLENBQUMsVUFBSixDQUFlO0FBQ3hDLDBCQUFBLFNBQVMsRUFBVCxTQUR3QztBQUV4QywwQkFBQSxHQUFHLEVBQUUsZ0JBRm1DO0FBR3hDLDBCQUFBLEtBQUssRUFBRSxhQUhpQztBQUl4QywwQkFBQSxVQUFVLEVBQUU7QUFBQyw0QkFBQSxLQUFLLEVBQUU7QUFBUiwyQkFKNEI7QUFLeEMsMEJBQUEsT0FBTyxFQUFFO0FBTCtCLHlCQUFmLENBREU7QUFRdkIsd0JBQUEsWUFSdUIsR0FRUixTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixrQkFBdkIsSUFDbkIsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsa0JBQXZCLEVBQTJDLE9BQTNDLENBRG1CLEdBQ21DLElBVDNCO0FBVXpCLHdCQUFBLFVBVnlCLEdBVVosSUFWWTs7QUFXN0IsNEJBQUcsWUFBSCxFQUFpQjtBQUNmLDBCQUFBLGtCQUFrQixDQUFDLFNBQUQsRUFBWSxZQUFaLEVBQTBCLE9BQTFCLENBQWxCOztBQUNBLDhCQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFELENBQUwsQ0FBYixFQUFtQztBQUNqQyw0QkFBQSxJQUFJLENBQUMsWUFBRCxDQUFKLEdBQXFCLEVBQXJCO0FBQ0Q7O0FBQ0QsMEJBQUEsVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFELENBQWpCO0FBQ0Q7O0FBQ0Qsd0JBQUEsU0FBUyxDQUNQLFVBRE8sRUFDSyxrQkFETCxFQUN5QixhQUR6QixFQUN3QztBQUM3QywwQkFBQSxlQUFlLEVBQUU7QUFENEIseUJBRHhDLENBQVQ7QUFJRCx1QkEvVU8sQ0FpVlI7OztBQWpWUSw4REFrVmtCLGFBbFZsQjtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBa1ZFLHNCQUFBLFlBbFZGO0FBbVZOO0FBQ00sc0JBQUEsbUJBcFZBLEdBb1ZxQixHQUFHLENBQUMsVUFBSixDQUFlO0FBQ3hDLHdCQUFBLFNBQVMsRUFBVCxTQUR3QztBQUV4Qyx3QkFBQSxHQUFHLEVBQUUsZ0JBRm1DO0FBR3hDLHdCQUFBLEtBQUssRUFBRSxZQUhpQztBQUl4Qyx3QkFBQSxVQUFVLEVBQUU7QUFBQywwQkFBQSxLQUFLLEVBQUU7QUFBUix5QkFKNEI7QUFLeEMsd0JBQUEsT0FBTyxFQUFFO0FBTCtCLHVCQUFmLENBcFZyQixFQTRWTjtBQUNBOztBQUNNLHNCQUFBLGFBOVZBLEdBOFZlLFNBQVMsQ0FBQyxRQUFWLENBQW1CLEdBQW5CLENBQXVCLG1CQUF2QixJQUNuQixTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixtQkFBdkIsRUFBMkMsT0FBM0MsQ0FEbUIsR0FDbUMsSUEvVmxEO0FBZ1dGLHNCQUFBLFdBaFdFLEdBZ1dXLElBaFdYOztBQWlXTiwwQkFBRyxhQUFILEVBQWlCO0FBQ2Ysd0JBQUEsa0JBQWtCLENBQUMsU0FBRCxFQUFZLGFBQVosRUFBMEIsT0FBMUIsQ0FBbEI7O0FBQ0EsNEJBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQUQsQ0FBTCxDQUFiLEVBQW1DO0FBQ2pDLDBCQUFBLElBQUksQ0FBQyxhQUFELENBQUosR0FBcUIsRUFBckI7QUFDRDs7QUFDRCx3QkFBQSxXQUFVLEdBQUcsSUFBSSxDQUFDLGFBQUQsQ0FBakI7QUFDRDs7QUFFSyxzQkFBQSxXQXpXQSxHQXlXWSxnQkFBZ0IsQ0FDaEMsU0FEZ0MsRUFDckIsbUJBRHFCLEVBQ0QsWUFEQyxDQUFoQixJQUNnQyxFQTFXNUMsRUE0V047O0FBQ00sc0JBQUEsT0E3V0EsR0E2V1UsUUFBUSxDQUFDLFlBQUQsQ0E3V2xCO0FBOFdBLHNCQUFBLE1BOVdBLEdBOFdTLE9BQU8sQ0FBQyxZQUFELENBOVdoQjtBQStXRixzQkFBQSxLQS9XRTs7QUFnWE4sMEJBQUcsTUFBSCxFQUFXO0FBQ1Qsd0JBQUEsS0FBSyxHQUFHLFlBQVksQ0FBQyxPQUFELENBQXBCO0FBQ0QsdUJBRkQsTUFFTyxJQUFHLE9BQUgsRUFBWTtBQUNqQix3QkFBQSxLQUFLLEdBQUcsWUFBWSxDQUFDLFFBQUQsQ0FBcEI7QUFDRCx1QkFwWEssQ0FzWE47OztBQXRYTTtBQUFBLDZCQXVYb0IsR0FBRyxDQUFDLE9BQUosQ0FBWTtBQUNwQyx3QkFBQSxTQUFTLEVBQVQsU0FEb0M7QUFFcEMsd0JBQUEsY0FBYyxFQUFFLG1CQUZvQjtBQUdwQyx3QkFBQSxPQUFPLEVBQUcsTUFBTSxJQUFJLE9BQVgsR0FBc0IsS0FBdEIsR0FBOEIsWUFISDtBQUlwQyx3QkFBQSxPQUFPLEVBQVAsT0FKb0M7QUFLcEMsd0JBQUEsYUFBYSxFQUFiO0FBTG9DLHVCQUFaLENBdlhwQjs7QUFBQTtBQXVYRixzQkFBQSxhQXZYRTs7QUFBQSwyQkFnWUgsTUFoWUc7QUFBQTtBQUFBO0FBQUE7O0FBaVlKO0FBQ0EsMEJBQUcsQ0FBQyxRQUFRLENBQUMsYUFBRCxDQUFaLEVBQTZCO0FBQzNCLHdCQUFBLGFBQWEsR0FBRyxDQUFDLGFBQUQsQ0FBaEI7QUFDRDs7QUFwWUcsMEJBc1lBLFdBQVMsQ0FBQyxRQUFWLENBQW1CLE9BQW5CLENBdFlBO0FBQUE7QUFBQTtBQUFBOztBQXVZRjtBQUNBLHNCQUFBLGFBQWEsd0NBQ1YsR0FBRyxDQUFDLFVBQUosQ0FBZTtBQUNkLHdCQUFBLFNBQVMsRUFBVCxTQURjO0FBRWQsd0JBQUEsR0FBRyxFQUFFLE9BRlM7QUFHZCx3QkFBQSxVQUFVLEVBQUU7QUFBQywwQkFBQSxLQUFLLEVBQUU7QUFBUjtBQUhFLHVCQUFmLENBRFUsRUFLTixhQUxNLENBQWIsQ0F4WUUsQ0FnWkY7O0FBQ0EsMEJBQUcsWUFBWSxZQUFmLEVBQTZCO0FBQzNCLHdCQUFBLGFBQWEsQ0FBQyxHQUFHLENBQUMsVUFBSixDQUFlO0FBQzNCLDBCQUFBLFNBQVMsRUFBVCxTQUQyQjtBQUUzQiwwQkFBQSxHQUFHLEVBQUUsUUFGc0I7QUFHM0IsMEJBQUEsVUFBVSxFQUFFO0FBQUMsNEJBQUEsS0FBSyxFQUFFO0FBQVI7QUFIZSx5QkFBZixDQUFELENBQWIsR0FJTSxZQUFZLENBQUMsUUFBRCxDQUpsQjtBQUtEOztBQXZaQztBQUFBOztBQUFBO0FBeVpGLHNCQUFBLFNBQVMsQ0FBQyxXQUFELEVBQWEsbUJBQWIsRUFBaUMsYUFBakMsRUFBZ0Q7QUFDdkQsd0JBQUEsWUFBWSxFQUFFLElBRHlDO0FBRXZELHdCQUFBLGNBQWMsRUFBRTtBQUZ1Qyx1QkFBaEQsQ0FBVDs7QUF6WkU7O0FBQUE7QUFBQSwyQkFrYUgsT0FsYUc7QUFBQTtBQUFBO0FBQUE7O0FBbWFKLDBCQUFHLFdBQVMsQ0FBQyxRQUFWLENBQW1CLFFBQW5CLE1BQWlDLFdBQVMsQ0FBQyxRQUFWLENBQW1CLEtBQW5CLEtBQ2xDLFdBQVMsQ0FBQyxRQUFWLENBQW1CLFFBQW5CLEtBQWdDLGNBQWMsQ0FBQyxZQUFELENBRDdDLENBQUgsRUFDaUU7QUFDL0Q7QUFDSSx3QkFBQSxTQUYyRDs7QUFHL0QsNEJBQUcsV0FBVSxDQUFDLGNBQVgsQ0FBMEIsbUJBQTFCLENBQUgsRUFBa0Q7QUFDaEQsMEJBQUEsU0FBUyxHQUFHLFdBQVUsQ0FBQyxtQkFBRCxDQUF0QjtBQUNELHlCQUZELE1BRU87QUFDTCwwQkFBQSxXQUFVLENBQUMsbUJBQUQsQ0FBVixHQUFpQyxTQUFTLEdBQUcsRUFBN0M7QUFDRCx5QkFQOEQsQ0FTL0Q7OztBQUNNLHdCQUFBLEdBVnlELEdBVW5ELENBQUMsV0FBUyxDQUFDLFFBQVYsQ0FBbUIsS0FBbkIsSUFDWCxZQUFZLENBQUMsS0FBRCxDQURELEdBQ1csWUFBWSxDQUFDLFFBQUQsQ0FEeEIsS0FFVixHQUFHLENBQUMsVUFBSixDQUFlO0FBQUMsMEJBQUEsU0FBUyxFQUFULFNBQUQ7QUFBWSwwQkFBQSxHQUFHLEVBQUUsT0FBakI7QUFDYiwwQkFBQSxVQUFVLEVBQUU7QUFBQyw0QkFBQSxLQUFLLEVBQUU7QUFBUjtBQURDLHlCQUFmLENBWjZELEVBYy9EO0FBQ0E7O0FBRUEsd0JBQUEsU0FBUyxDQUNQLFNBRE8sRUFDSSxHQURKLEVBQ1MsYUFEVCxFQUN3QjtBQUM3QiwwQkFBQSxlQUFlLEVBQ1osQ0FBQyxPQUFPLENBQUMsYUFBVCxJQUEwQixXQUFTLENBQUMsUUFBVixDQUFtQixNQUFuQjtBQUZBLHlCQUR4QixDQUFUO0FBS0QsdUJBdkJELE1BdUJPLElBQUcsV0FBUyxDQUFDLFFBQVYsQ0FBbUIsUUFBbkIsS0FDUixjQUFjLENBQUMsWUFBRCxDQURULEVBQ3lCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQUcsUUFBUSxDQUFDLGFBQUQsQ0FBUixJQUEyQixhQUFhLENBQUMsTUFBZCxHQUF1QixDQUFyRCxFQUF3RDtBQUN0RCwwQkFBQSxhQUFhLEdBQUc7QUFBQyx5Q0FBYTtBQUFkLDJCQUFoQjtBQUNEOztBQUNELHdCQUFBLFNBQVMsQ0FDUCxXQURPLEVBQ0ssbUJBREwsRUFDeUIsYUFEekIsRUFDd0M7QUFDN0MsMEJBQUEsZUFBZSxFQUNaLENBQUMsT0FBTyxDQUFDLGFBQVQsSUFBMEIsV0FBUyxDQUFDLFFBQVYsQ0FBbUIsTUFBbkI7QUFGZ0IseUJBRHhDLENBQVQ7QUFLRCx1QkFkTSxNQWNBO0FBQ0w7QUFDQTtBQUNBLDRCQUFHLFFBQVEsQ0FBQyxhQUFELENBQVIsSUFBMkIsYUFBYSxDQUFDLE1BQWQsS0FBeUIsQ0FBcEQsSUFDRCxPQUFPLENBQUMsYUFEVixFQUN5QjtBQUN2QiwwQkFBQSxhQUFhLEdBQUcsYUFBYSxDQUFDLENBQUQsQ0FBN0I7QUFDRDs7QUFDRCx3QkFBQSxhQUFhLHdDQUNWLEdBQUcsQ0FBQyxVQUFKLENBQWU7QUFDZCwwQkFBQSxTQUFTLEVBQVQsU0FEYztBQUVkLDBCQUFBLEdBQUcsRUFBRSxRQUZTO0FBR2QsMEJBQUEsVUFBVSxFQUFFO0FBQUMsNEJBQUEsS0FBSyxFQUFFO0FBQVI7QUFIRSx5QkFBZixDQURVLEVBS04sYUFMTSxDQUFiLENBUEssQ0FlTDs7QUFDQSw0QkFBRyxTQUFTLFlBQVosRUFBMEI7QUFDeEIsMEJBQUEsYUFBYSxDQUFDLEdBQUcsQ0FBQyxVQUFKLENBQWU7QUFDM0IsNEJBQUEsU0FBUyxFQUFULFNBRDJCO0FBRTNCLDRCQUFBLEdBQUcsRUFBRSxLQUZzQjtBQUczQiw0QkFBQSxVQUFVLEVBQUU7QUFBQyw4QkFBQSxLQUFLLEVBQUU7QUFBUjtBQUhlLDJCQUFmLENBQUQsQ0FBYixHQUlNLFlBQVksQ0FBQyxLQUFELENBSmxCO0FBS0QseUJBdEJJLENBd0JMOzs7QUFDQSw0QkFBRyxZQUFZLFlBQWYsRUFBNkI7QUFDM0IsMEJBQUEsYUFBYSxDQUFDLEdBQUcsQ0FBQyxVQUFKLENBQWU7QUFDM0IsNEJBQUEsU0FBUyxFQUFULFNBRDJCO0FBRTNCLDRCQUFBLEdBQUcsRUFBRSxRQUZzQjtBQUczQiw0QkFBQSxVQUFVLEVBQUU7QUFBQyw4QkFBQSxLQUFLLEVBQUU7QUFBUjtBQUhlLDJCQUFmLENBQUQsQ0FBYixHQUlNLFlBQVksQ0FBQyxRQUFELENBSmxCO0FBS0Q7O0FBQ0Qsd0JBQUEsU0FBUyxDQUNQLFdBRE8sRUFDSyxtQkFETCxFQUN5QixhQUR6QixFQUN3QztBQUM3QywwQkFBQSxlQUFlLEVBQ1osQ0FBQyxPQUFPLENBQUMsYUFBVCxJQUEwQixXQUFTLENBQUMsUUFBVixDQUFtQixNQUFuQjtBQUZnQix5QkFEeEMsQ0FBVDtBQUtEOztBQTdlRztBQUFBOztBQUFBO0FBQUEsNEJBOGVJLFdBQVMsQ0FBQyxRQUFWLENBQW1CLFdBQW5CLEtBQ1IsV0FBUyxDQUFDLFFBQVYsQ0FBbUIsUUFBbkIsQ0FEUSxJQUN3QixXQUFTLENBQUMsUUFBVixDQUFtQixLQUFuQixDQUR4QixJQUVSLFdBQVMsQ0FBQyxRQUFWLENBQW1CLE9BQW5CLENBaGZJO0FBQUE7QUFBQTtBQUFBOztBQWlmSjtBQUNBO0FBQ0ksc0JBQUEsVUFuZkE7O0FBb2ZKLDBCQUFHLFdBQVUsQ0FBQyxjQUFYLENBQTBCLG1CQUExQixDQUFILEVBQWtEO0FBQ2hELHdCQUFBLFVBQVMsR0FBRyxXQUFVLENBQUMsbUJBQUQsQ0FBdEI7QUFDRCx1QkFGRCxNQUVPO0FBQ0wsd0JBQUEsV0FBVSxDQUFDLG1CQUFELENBQVYsR0FBaUMsVUFBUyxHQUFHLEVBQTdDO0FBQ0Q7O0FBRUcsc0JBQUEsSUExZkE7O0FBQUEsMkJBMmZELFdBQVMsQ0FBQyxRQUFWLENBQW1CLFdBQW5CLENBM2ZDO0FBQUE7QUFBQTtBQUFBOztBQTRmSjtBQUNBO0FBQ0UsMEJBQUcsUUFBUSxDQUFDLGFBQUQsQ0FBWCxFQUE0QjtBQUMxQix3QkFBQSxhQUFhLEdBQUcsYUFBYSxDQUFDLFFBQUQsQ0FBN0I7QUFDRDs7QUFDRCxzQkFBQSxJQUFHLEdBQUcsWUFBWSxDQUFDLFdBQUQsQ0FBbEI7QUFqZ0JFO0FBQUE7O0FBQUE7QUFBQSwyQkFrZ0JNLFdBQVMsQ0FBQyxRQUFWLENBQW1CLFFBQW5CLENBbGdCTjtBQUFBO0FBQUE7QUFBQTs7QUFtZ0JJLHNCQUFBLFFBbmdCSixHQW1nQmUsZ0JBQWdCLENBQy9CLFNBRCtCLEVBQ3BCLG1CQURvQixFQUNBLFFBREEsQ0FBaEIsSUFDNkIsUUFwZ0I1QztBQXFnQkksc0JBQUEsWUFyZ0JKLEdBcWdCbUIsR0FBRyxDQUFDLFVBQUosQ0FDbkI7QUFBQyx3QkFBQSxTQUFTLEVBQVQsU0FBRDtBQUFZLHdCQUFBLEdBQUcsRUFBRSxRQUFqQjtBQUEyQix3QkFBQSxVQUFVLEVBQUU7QUFBQywwQkFBQSxLQUFLLEVBQUU7QUFBUjtBQUF2Qyx1QkFEbUIsQ0FyZ0JuQjs7QUFBQSw0QkF1Z0JDLFFBQVEsS0FBSyxRQXZnQmQ7QUFBQTtBQUFBO0FBQUE7O0FBd2dCQSxzQkFBQSxJQUFHLEdBQUcsWUFBWSxDQUFDLFFBQUQsQ0FBbEI7QUFDQSw2QkFBTyxhQUFhLENBQUMsWUFBRCxDQUFwQjtBQXpnQkE7QUFBQTs7QUFBQTtBQTJnQkksc0JBQUEsTUEzZ0JKO0FBQUEsa0NBNGdCbUIsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFELENBQWIsSUFBMkIsRUFBNUIsQ0E1Z0IzQjtBQUFBO0FBNGdCQyxzQkFBQSxJQTVnQkQ7QUE0Z0JTLHNCQUFBLE1BNWdCVDs7QUFBQSwwQkE2Z0JJLFNBQVMsQ0FBQyxJQUFELENBN2dCYjtBQUFBO0FBQUE7QUFBQTs7QUE4Z0JFO0FBQ0Esc0JBQUEsSUFBRyxHQUFHLElBQU47QUEvZ0JGO0FBQUE7O0FBQUE7QUFBQSxvQ0FpaEJTLE1BQU0sQ0FBQyxNQWpoQmhCO0FBQUEsc0RBa2hCUyxDQWxoQlQseUJBcWhCUyxDQXJoQlQ7QUFBQTs7QUFBQTtBQW1oQk0sNkJBQU8sYUFBYSxDQUFDLFFBQUQsQ0FBcEI7QUFuaEJOOztBQUFBO0FBc2hCTSxzQkFBQSxhQUFhLENBQUMsUUFBRCxDQUFiLEdBQTBCLE1BQU0sQ0FBQyxDQUFELENBQWhDO0FBdGhCTjs7QUFBQTtBQXloQk0sc0JBQUEsYUFBYSxDQUFDLFFBQUQsQ0FBYixHQUEwQixNQUExQjtBQXpoQk47O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsMkJBOGhCTSxXQUFTLENBQUMsUUFBVixDQUFtQixLQUFuQixDQTloQk47QUFBQTtBQUFBO0FBQUE7O0FBK2hCSSxzQkFBQSxLQS9oQkosR0EraEJZLEdBQUcsQ0FBQyxVQUFKLENBQWU7QUFBQyx3QkFBQSxTQUFTLEVBQVQsU0FBRDtBQUFZLHdCQUFBLEdBQUcsRUFBRSxLQUFqQjtBQUMzQix3QkFBQSxVQUFVLEVBQUU7QUFBQywwQkFBQSxLQUFLLEVBQUU7QUFBUjtBQURlLHVCQUFmLENBL2hCWjtBQWlpQkYsc0JBQUEsSUFBRyxHQUFHLGFBQWEsQ0FBQyxLQUFELENBQW5CO0FBQ0EsNkJBQU8sYUFBYSxDQUFDLEtBQUQsQ0FBcEI7QUFsaUJFO0FBQUE7O0FBQUE7QUFBQSwyQkFtaUJNLFdBQVMsQ0FBQyxRQUFWLENBQW1CLE9BQW5CLENBbmlCTjtBQUFBO0FBQUE7QUFBQTs7QUFvaUJJLHNCQUFBLE9BcGlCSixHQW9pQmMsR0FBRyxDQUFDLFVBQUosQ0FBZTtBQUM3Qix3QkFBQSxTQUFTLEVBQVQsU0FENkI7QUFFN0Isd0JBQUEsR0FBRyxFQUFFLE9BRndCO0FBRzdCLHdCQUFBLFVBQVUsRUFBRTtBQUFDLDBCQUFBLEtBQUssRUFBRTtBQUFSO0FBSGlCLHVCQUFmLENBcGlCZDtBQXlpQkUsc0JBQUEsTUF6aUJGO0FBQUEsa0NBMGlCZ0IsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFELENBQWIsSUFBMEIsRUFBM0IsQ0ExaUJ4QjtBQUFBO0FBMGlCRCxzQkFBQSxJQTFpQkM7QUEwaUJPLHNCQUFBLE1BMWlCUDtBQUFBLG9DQTJpQkssTUFBSyxDQUFDLE1BM2lCWDtBQUFBLHNEQTRpQkssQ0E1aUJMLHlCQStpQkssQ0EvaUJMO0FBQUE7O0FBQUE7QUE2aUJFLDZCQUFPLGFBQWEsQ0FBQyxPQUFELENBQXBCO0FBN2lCRjs7QUFBQTtBQWdqQkUsc0JBQUEsYUFBYSxDQUFDLE9BQUQsQ0FBYixHQUF5QixNQUFLLENBQUMsQ0FBRCxDQUE5QjtBQWhqQkY7O0FBQUE7QUFtakJFLHNCQUFBLGFBQWEsQ0FBQyxPQUFELENBQWIsR0FBeUIsTUFBekI7QUFuakJGOztBQUFBO0FBQUEsNEJBeWpCQyxNQUFNLENBQUMsSUFBUCxDQUFZLGFBQVosRUFBMkIsTUFBM0IsS0FBc0MsQ0FBdEMsSUFDRCxTQUFTLFlBMWpCVDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDZCQTJqQnNCLEdBQUcsQ0FBQyxPQUFKLENBQVk7QUFDaEMsd0JBQUEsU0FBUyxFQUFULFNBRGdDO0FBRWhDLHdCQUFBLGNBQWMsRUFBRSxtQkFGZ0I7QUFHaEMsd0JBQUEsT0FBTyxFQUFFO0FBQUMsaUNBQU8sWUFBWSxDQUFDLEtBQUQ7QUFBcEIseUJBSHVCO0FBSWhDLHdCQUFBLE9BQU8sRUFBUCxPQUpnQztBQUtoQyx3QkFBQSxhQUFhLEVBQWI7QUFMZ0MsdUJBQVosQ0EzakJ0Qjs7QUFBQTtBQTJqQkEsc0JBQUEsYUEzakJBOztBQUFBO0FBcWtCSjtBQUNBLDBCQUFHLENBQUMsSUFBSixFQUFTO0FBQ1Asd0JBQUEsSUFBRyxHQUFHLEdBQUcsQ0FBQyxVQUFKLENBQWU7QUFBQywwQkFBQSxTQUFTLEVBQVQsU0FBRDtBQUFZLDBCQUFBLEdBQUcsRUFBRSxPQUFqQjtBQUNuQiwwQkFBQSxVQUFVLEVBQUU7QUFBQyw0QkFBQSxLQUFLLEVBQUU7QUFBUjtBQURPLHlCQUFmLENBQU47QUFFRCx1QkF6a0JHLENBMGtCSjtBQUNBOzs7QUFDQSxzQkFBQSxTQUFTLENBQ1AsVUFETyxFQUNJLElBREosRUFDUyxhQURULEVBQ3dCO0FBQzdCLHdCQUFBLGVBQWUsRUFBRSxXQUFTLENBQUMsUUFBVixDQUFtQixNQUFuQjtBQURZLHVCQUR4QixDQUFUOztBQTVrQkk7QUFBQTs7QUFBQTtBQWlsQko7QUFDQTtBQUNBO0FBQ00sc0JBQUEsU0FwbEJGLEdBb2xCYSxDQUFDLE9BQU8sQ0FBQyxhQUFULElBQ2YsV0FBUyxDQUFDLFFBQVYsQ0FBbUIsTUFBbkIsQ0FEZSxJQUNlLFdBQVMsQ0FBQyxRQUFWLENBQW1CLE9BQW5CLENBRGYsSUFFZCxRQUFRLENBQUMsYUFBRCxDQUFSLElBQTJCLGFBQWEsQ0FBQyxNQUFkLEtBQXlCLENBRnRDLElBR2YsZ0JBQWdCLEtBQUssT0FITixJQUdpQixnQkFBZ0IsS0FBSyxRQXZsQm5ELEVBeWxCSjs7QUFDQSxzQkFBQSxTQUFTLENBQ1AsV0FETyxFQUNLLG1CQURMLEVBQ3lCLGFBRHpCLEVBRVA7QUFBQyx3QkFBQSxlQUFlLEVBQUU7QUFBbEIsdUJBRk8sQ0FBVDs7QUExbEJJO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUEsMkJBaW1CSDtBQWptQkc7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBLDhDQXFtQkwsT0FybUJLOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQWQ7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF3bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxVQUFKLEdBQWlCLGlCQU9YO0FBQUEsTUFOSixTQU1JLFNBTkosU0FNSTtBQUFBLE1BTEosR0FLSSxTQUxKLEdBS0k7QUFBQSwwQkFKSixLQUlJO0FBQUEsTUFKSixLQUlJLDRCQUpJLElBSUo7QUFBQSwrQkFISixVQUdJO0FBQUEsTUFISixVQUdJLGlDQUhTO0FBQUMsSUFBQSxLQUFLLEVBQUU7QUFBUixHQUdUO0FBQUEsNEJBRkosT0FFSTtBQUFBLE1BRkosT0FFSSw4QkFGTSxLQUVOO0FBQUEseUJBREosSUFDSTtBQUFBLE1BREosSUFDSSwyQkFERyxJQUNIOztBQUNKO0FBQ0EsTUFBRyxHQUFHLEtBQUssSUFBWCxFQUFpQjtBQUNmLFdBQU8sR0FBUDtBQUNELEdBSkcsQ0FNSjtBQUNBOzs7QUFDQSxNQUFHLFNBQVMsQ0FBQyxvQkFBVixJQUFrQyxTQUFTLENBQUMsZUFBL0MsRUFBZ0U7QUFDOUQsSUFBQSxTQUFTLEdBQUcsU0FBUyxDQUFDLGVBQXRCO0FBQ0Q7O0FBRUQsTUFBTSxVQUFVLEdBQUcsU0FBUyxDQUFDLFVBQVYsRUFBbkIsQ0FaSSxDQWNKOztBQUNBLE1BQUcsVUFBVSxDQUFDLEdBQUQsQ0FBVixJQUNELEdBQUcsSUFBSSxVQUROLElBRUQsV0FBVyxVQUFVLENBQUMsR0FBRCxDQUZwQixJQUdELFdBQVcsVUFBVSxDQUFDLEdBQUQsQ0FBVixDQUFnQixPQUFoQixDQUhWLElBSUQsV0FBVyxVQUFVLENBQUMsR0FBRCxDQUFWLENBQWdCLE9BQWhCLEVBQXlCLE9BQXpCLENBSmIsRUFJZ0Q7QUFDOUMsV0FBTyxVQUFVLENBQUMsR0FBRCxDQUFWLENBQWdCLE9BQWhCLEVBQXlCLE9BQXpCLEVBQWtDLE9BQWxDLENBQVA7QUFDRCxHQXJCRyxDQXVCSjs7O0FBQ0EsTUFBRyxVQUFVLENBQUMsS0FBWCxJQUFvQixHQUFHLElBQUksVUFBOUIsRUFBMEM7QUFDeEMsUUFBTSxlQUFlLEdBQUcsU0FBUyxDQUFDLFdBQUQsQ0FBVCxJQUEwQixPQUFsRCxDQUR3QyxDQUd4Qzs7QUFDQSxRQUFNLFVBQVUsR0FBRyxFQUFuQjs7QUFDQSxRQUFHLFNBQVMsQ0FBQyxLQUFELENBQVQsSUFBb0IsWUFBWSxLQUFoQyxJQUF5QyxFQUFFLFlBQVksS0FBZCxDQUE1QyxFQUFrRTtBQUNoRSxNQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWdCLFFBQWhCLEVBQTBCLFlBQTFCO0FBQ0QsS0FQdUMsQ0FTeEM7OztBQUNBLFFBQUcsU0FBUyxDQUFDLEtBQUQsQ0FBVCxJQUFvQixlQUFlLEtBQXRDLEVBQTZDO0FBQzNDLE1BQUEsS0FBSyxHQUFHLEtBQUssQ0FBQyxXQUFELENBQUwsQ0FBbUIsQ0FBbkIsQ0FBUjtBQUNELEtBWnVDLENBY3hDO0FBQ0E7OztBQUNBLFFBQUcsUUFBUSxDQUFDLEtBQUQsQ0FBWCxFQUFvQjtBQUNsQjtBQUNBLFVBQUcsWUFBWSxLQUFmLEVBQXNCO0FBQ3BCLFFBQUEsVUFBVSxDQUFDLElBQVgsQ0FDRSxjQURGLEVBQ2tCLGtCQURsQixFQUNzQyxRQUR0QyxFQUNnRCxZQURoRDtBQUVELE9BTGlCLENBTWxCOzs7QUFDQSxVQUFHLFNBQVMsS0FBWixFQUFtQjtBQUNqQixRQUFBLFVBQVUsQ0FBQyxJQUFYLENBQ0UsV0FERixFQUNlLGVBRGY7QUFFRDs7QUFDRCxNQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWdCLFFBQWhCLEVBQTBCLFlBQTFCLEVBQXdDLE1BQXhDLEVBWGtCLENBWWxCOztBQUNBLFVBQUcsRUFBRSxZQUFZLEtBQWQsQ0FBSCxFQUF5QjtBQUN2QixRQUFBLFVBQVUsQ0FBQyxJQUFYLENBQ0UsY0FERixFQUNrQixrQkFEbEIsRUFDc0MsUUFEdEMsRUFDZ0QsWUFEaEQ7QUFFRCxPQWhCaUIsQ0FpQmxCOzs7QUFDQSxVQUFHLEVBQUUsU0FBUyxLQUFYLENBQUgsRUFBc0I7QUFDcEIsUUFBQSxVQUFVLENBQUMsSUFBWCxDQUFnQixXQUFoQixFQUE2QixlQUE3QjtBQUNEO0FBQ0YsS0FyQkQsTUFxQk8sSUFBRyxTQUFTLENBQUMsS0FBRCxDQUFULElBQW9CLENBQUMsUUFBUSxDQUFDLEtBQUQsQ0FBaEMsRUFBeUM7QUFDOUMsTUFBQSxVQUFVLENBQUMsSUFBWCxDQUFnQixLQUFoQixFQUF1QixTQUF2QixFQUFrQyxPQUFsQyxFQUEyQyxXQUEzQztBQUNELEtBdkN1QyxDQXlDeEM7OztBQUNBLFFBQUksY0FBYyxHQUFHLFdBQXJCO0FBQ0EsUUFBSSxtQkFBbUIsR0FBRyxPQUExQjs7QUFFQSxRQUFHLE9BQUgsRUFBWTtBQUNWLE1BQUEsY0FBYyxHQUFHLE9BQWpCO0FBQ0EsTUFBQSxtQkFBbUIsR0FBRyxVQUF0QjtBQUNBLE1BQUEsVUFBVSxDQUFDLElBQVgsQ0FBZ0IsTUFBaEI7QUFDRCxLQUpELE1BSU8sSUFBRyxPQUFPLENBQUMsS0FBRCxDQUFWLEVBQW1CO0FBQ3hCO0FBQ0E7QUFDQSxVQUFHLEVBQUUsWUFBWSxLQUFkLENBQUgsRUFBeUI7QUFDdkIsUUFBQSxVQUFVLENBQUMsSUFBWCxDQUFnQixPQUFoQjtBQUNEOztBQUNELFVBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxPQUFELENBQWxCOztBQUNBLFVBQUcsSUFBSSxDQUFDLE1BQUwsS0FBZ0IsQ0FBbkIsRUFBc0I7QUFDcEI7QUFDQTtBQUNBLFFBQUEsY0FBYyxHQUFHLE1BQWpCO0FBQ0EsUUFBQSxtQkFBbUIsR0FBRyxPQUF0QjtBQUNELE9BTEQsTUFLTztBQUNMLFlBQUksY0FBYyxHQUFJLElBQUksQ0FBQyxNQUFMLEtBQWdCLENBQWpCLEdBQXNCLGVBQXRCLEdBQXdDLElBQTdEO0FBQ0EsWUFBSSxVQUFVLEdBQUcsSUFBakI7O0FBQ0EsYUFBSSxJQUFJLENBQUMsR0FBRyxDQUFaLEVBQWUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUF4QixFQUFnQyxFQUFFLENBQWxDLEVBQXFDO0FBQ25DLGNBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFELENBQWpCO0FBQ0EsY0FBSSxZQUFZLEdBQUcsT0FBbkI7QUFDQSxjQUFJLFFBQVEsR0FBRyxPQUFmOztBQUNBLGNBQUcsUUFBUSxDQUFDLElBQUQsQ0FBWCxFQUFtQjtBQUNqQixnQkFBRyxnQkFBZ0IsSUFBbkIsRUFBeUI7QUFDdkIsa0JBQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQUQsQ0FBSixJQUFxQixFQUF0QixFQUEwQixXQUExQixFQUFiO0FBQ0Esa0JBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxZQUFELENBQWhCO0FBQ0EsY0FBQSxZQUFZLGFBQU0sSUFBTixjQUFjLEdBQWQsQ0FBWjtBQUNELGFBSkQsTUFJTyxJQUFHLGVBQWUsSUFBbEIsRUFBd0I7QUFDN0IsY0FBQSxZQUFZLEdBQUcsSUFBSSxDQUFDLFdBQUQsQ0FBSixDQUFrQixXQUFsQixFQUFmO0FBQ0QsYUFGTSxNQUVBLElBQUcsV0FBVyxJQUFkLEVBQW9CO0FBQ3pCLGNBQUEsUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFELENBQWY7QUFDRCxhQUZNLE1BRUE7QUFDTDtBQUNBLGNBQUEsWUFBWSxHQUFHLE9BQWY7QUFDRDtBQUNGLFdBYkQsTUFhTztBQUNMLFlBQUEsUUFBUSxHQUFHLEtBQVg7QUFDRDs7QUFDRCxjQUFHLGNBQWMsS0FBSyxJQUF0QixFQUE0QjtBQUMxQixZQUFBLGNBQWMsR0FBRyxZQUFqQjtBQUNELFdBRkQsTUFFTyxJQUFHLFlBQVksS0FBSyxjQUFqQixJQUFtQyxRQUFRLENBQUMsSUFBRCxDQUE5QyxFQUFzRDtBQUMzRCxZQUFBLGNBQWMsR0FBRyxPQUFqQjtBQUNEOztBQUNELGNBQUcsVUFBVSxLQUFLLElBQWxCLEVBQXdCO0FBQ3RCLFlBQUEsVUFBVSxHQUFHLFFBQWI7QUFDRCxXQUZELE1BRU8sSUFBRyxRQUFRLEtBQUssVUFBaEIsRUFBNEI7QUFDakMsWUFBQSxVQUFVLEdBQUcsT0FBYjtBQUNELFdBN0JrQyxDQThCbkM7QUFDQTs7O0FBQ0EsY0FBRyxjQUFjLEtBQUssT0FBbkIsSUFBOEIsVUFBVSxLQUFLLE9BQWhELEVBQXlEO0FBQ3ZEO0FBQ0Q7QUFDRjs7QUFDRCxRQUFBLGNBQWMsR0FBRyxjQUFjLElBQUksT0FBbkM7QUFDQSxRQUFBLFVBQVUsR0FBRyxVQUFVLElBQUksT0FBM0I7O0FBQ0EsWUFBRyxVQUFVLEtBQUssT0FBbEIsRUFBMkI7QUFDekIsVUFBQSxjQUFjLEdBQUcsT0FBakI7QUFDQSxVQUFBLG1CQUFtQixHQUFHLFVBQXRCO0FBQ0QsU0FIRCxNQUdPO0FBQ0wsVUFBQSxtQkFBbUIsR0FBRyxjQUF0QjtBQUNEO0FBQ0Y7QUFDRixLQTVETSxNQTREQTtBQUNMLFVBQUcsUUFBUSxDQUFDLEtBQUQsQ0FBWCxFQUFvQjtBQUNsQixZQUFHLGVBQWUsS0FBZixJQUF3QixFQUFFLFlBQVksS0FBZCxDQUEzQixFQUFpRDtBQUMvQyxVQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWdCLFdBQWhCLEVBQTZCLGVBQTdCO0FBQ0EsVUFBQSxtQkFBbUIsR0FBRyxLQUFLLENBQUMsV0FBRCxDQUEzQjtBQUNBLGNBQU0sSUFBRyxHQUFHLEtBQUssQ0FBQyxZQUFELENBQWpCOztBQUNBLGNBQUcsSUFBSCxFQUFRO0FBQ04sWUFBQSxtQkFBbUIsYUFBTSxtQkFBTixjQUE2QixJQUE3QixDQUFuQjtBQUNEO0FBQ0YsU0FQRCxNQU9PLElBQUcsZ0JBQWdCLEtBQWhCLElBQXlCLEVBQUUsWUFBWSxLQUFkLENBQTVCLEVBQWtEO0FBQ3ZELFVBQUEsbUJBQW1CLGNBQU8sS0FBSyxDQUFDLFlBQUQsQ0FBWixDQUFuQjtBQUNELFNBRk0sTUFFQSxJQUFHLFdBQVcsS0FBZCxFQUFxQjtBQUMxQixVQUFBLGNBQWMsR0FBRyxPQUFqQjtBQUNBLFVBQUEsbUJBQW1CLEdBQUcsS0FBSyxDQUFDLE9BQUQsQ0FBM0I7QUFDRDtBQUNGLE9BZEQsTUFjTztBQUNMLFFBQUEsY0FBYyxHQUFHLE9BQWpCO0FBQ0EsUUFBQSxtQkFBbUIsR0FBRyxLQUF0QjtBQUNEOztBQUNELE1BQUEsVUFBVSxDQUFDLElBQVgsQ0FBZ0IsTUFBaEI7QUFDRCxLQWpJdUMsQ0FtSXhDOzs7QUFDQSxJQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWdCLE9BQWhCLEVBcEl3QyxDQXNJeEM7QUFDQTs7QUFDQSxRQUFHLFNBQVMsQ0FBQyxLQUFELENBQVQsSUFBb0IsRUFBRSxZQUFZLEtBQWQsQ0FBdkIsRUFBNkM7QUFDM0M7QUFDQSxNQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWdCLFFBQWhCLEVBQTBCLFlBQTFCO0FBQ0QsS0EzSXVDLENBNkl4Qzs7O0FBQ0EsUUFBRyxRQUFRLENBQUMsS0FBRCxDQUFSLElBQW1CLE1BQU0sQ0FBQyxJQUFQLENBQVksS0FBWixFQUFtQixNQUFuQixLQUE4QixDQUFwRCxFQUF1RDtBQUNyRDtBQUNBLE1BQUEsVUFBVSxDQUFDLElBQVgsQ0FBZ0IsV0FBaEIsRUFBNkIsZUFBN0I7QUFDRDs7QUFFRCxRQUFNLElBQUksR0FBRyxXQUFXLENBQ3RCLFNBRHNCLEVBQ1gsR0FEVyxFQUNOLEtBRE0sRUFDQyxVQURELEVBQ2EsY0FEYixFQUM2QixtQkFEN0IsQ0FBeEI7O0FBRUEsUUFBRyxJQUFJLEtBQUssSUFBWixFQUFrQjtBQUNoQixhQUFPLElBQVA7QUFDRDtBQUNGLEdBaExHLENBa0xKOzs7QUFDQSxNQUFHLFVBQVUsQ0FBQyxLQUFkLEVBQXFCO0FBQ25CLFFBQUcsWUFBWSxTQUFmLEVBQTBCO0FBQ3hCO0FBQ0EsVUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLFFBQUQsQ0FBdkI7O0FBQ0EsVUFBRyxHQUFHLENBQUMsT0FBSixDQUFZLEtBQVosTUFBdUIsQ0FBdkIsSUFBNEIsR0FBRyxLQUFLLEtBQXZDLEVBQThDO0FBQzVDO0FBQ0EsWUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQUosQ0FBVyxLQUFLLENBQUMsTUFBakIsQ0FBZjs7QUFDQSxZQUFHLENBQUMsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsTUFBdkIsQ0FBSixFQUFvQztBQUNsQyxpQkFBTyxNQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsR0EvTEcsQ0FpTUo7OztBQUNBLE1BQUksTUFBTSxHQUFHLElBQWIsQ0FsTUksQ0FtTUo7O0FBQ0EsTUFBTSxjQUFjLEdBQUcsRUFBdkI7QUFDQSxNQUFJLE1BQU0sR0FBRyxTQUFTLENBQUMsWUFBdkIsQ0FyTUksQ0FzTUo7QUFDQTs7QUFDQSxNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQyxNQUFKLEdBQWEsQ0FBdEM7O0FBQ0EsT0FBSSxJQUFJLEdBQUMsR0FBRyxDQUFaLEVBQWUsR0FBQyxHQUFHLGdCQUFKLElBQXdCLEdBQUcsQ0FBQyxHQUFELENBQUgsSUFBVSxNQUFqRCxFQUF5RCxFQUFFLEdBQTNELEVBQThEO0FBQzVELElBQUEsTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRCxDQUFKLENBQWY7O0FBQ0EsUUFBRyxNQUFNLE1BQVQsRUFBaUI7QUFDZixNQUFBLGNBQWMsQ0FBQyxJQUFmLENBQW9CLE1BQU0sQ0FBQyxFQUFELENBQU4sQ0FBVyxDQUFYLENBQXBCO0FBQ0Q7QUFDRixHQTlNRyxDQStNSjs7O0FBQ0EsT0FBSSxJQUFJLEdBQUMsR0FBRyxjQUFjLENBQUMsTUFBZixHQUF3QixDQUFwQyxFQUF1QyxHQUFDLElBQUksQ0FBNUMsRUFBK0MsRUFBRSxHQUFqRCxFQUFvRDtBQUNsRCxRQUFNLEtBQUssR0FBRyxjQUFjLENBQUMsR0FBRCxDQUE1QjtBQUNBLFFBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFwQjs7QUFGa0QsZ0RBR2hDLEtBSGdDO0FBQUE7O0FBQUE7QUFHbEQsNkRBQXlCO0FBQUEsWUFBZixLQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBTSxLQUFLLEdBQUcsS0FBSSxHQUFHLEdBQVAsR0FBYSxHQUFHLENBQUMsTUFBSixDQUFXLEtBQUssQ0FBQyxHQUFOLENBQVUsTUFBckIsQ0FBM0I7QUFDQSxZQUFNLGFBQWEsR0FBSSxTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixLQUF2QixFQUE2QixPQUE3QixLQUNwQixDQUFDLFNBQVMsQ0FBQyxRQUFWLENBQW1CLEdBQW5CLENBQXVCLEtBQXZCLENBQUQsSUFDQSxLQUFLLEtBQUssSUFBVixJQUFrQixTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixLQUF2QixFQUE4QixLQUE5QixNQUF5QyxHQUZ2QyxDQUF2QixDQU51QixDQVV2QjtBQUNBOztBQUNBLFlBQUcsYUFBYSxLQUFLLE1BQU0sS0FBSyxJQUFYLElBQ25CLHFCQUFxQixDQUFDLEtBQUQsRUFBUSxNQUFSLENBQXJCLEdBQXVDLENBRHpCLENBQWhCLEVBQzZDO0FBQzNDLFVBQUEsTUFBTSxHQUFHLEtBQVQ7QUFDRDtBQUNGO0FBbkJpRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBb0JuRCxHQXBPRyxDQXNPSjs7O0FBQ0EsTUFBRyxNQUFNLEtBQUssSUFBZCxFQUFvQjtBQUNsQixXQUFPLE1BQVA7QUFDRCxHQXpPRyxDQTJPSjtBQUNBOzs7QUE1T0ksOENBNk9vQixTQUFTLENBQUMsUUE3TzlCO0FBQUE7O0FBQUE7QUE2T0osMkRBQTRDO0FBQUE7QUFBQSxVQUFqQyxNQUFpQztBQUFBLFVBQTNCLEVBQTJCOztBQUMxQyxVQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsT0FBVCxJQUFvQixHQUFHLENBQUMsVUFBSixDQUFlLE1BQUksR0FBRyxHQUF0QixDQUF2QixFQUFtRDtBQUNqRCxjQUFNLElBQUksV0FBSiwwQkFDYSxHQURiLHVDQUMyQyxNQUQzQyxVQUVKLG9CQUZJLEVBR0o7QUFBQyxVQUFBLElBQUksRUFBRSwwQkFBUDtBQUFtQyxVQUFBLE9BQU8sRUFBRTtBQUE1QyxTQUhJLENBQU47QUFJRDtBQUNGLEtBcFBHLENBc1BKOztBQXRQSTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXVQSixNQUFHLENBQUMsVUFBVSxDQUFDLEtBQWYsRUFBc0I7QUFDcEIsUUFBRyxXQUFXLFNBQWQsRUFBeUI7QUFDdkIsVUFBRyxDQUFDLFNBQVMsQ0FBQyxPQUFELENBQWIsRUFBd0I7QUFDdEI7QUFDQSxlQUFPLEdBQVA7QUFDRCxPQUhELE1BR087QUFDTCxlQUFPLFdBQVcsQ0FBQyxZQUFZLENBQUMsSUFBRCxFQUFPLFNBQVMsQ0FBQyxPQUFELENBQWhCLENBQWIsRUFBeUMsR0FBekMsQ0FBbEI7QUFDRDtBQUNGLEtBUEQsTUFPTztBQUNMLGFBQU8sV0FBVyxDQUFDLElBQUQsRUFBTyxHQUFQLENBQWxCO0FBQ0Q7QUFDRixHQWxRRyxDQW9RSjs7O0FBQ0EsU0FBTyxHQUFQO0FBQ0QsQ0E3UUQ7QUErUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFlBQUosR0FBbUIsaUJBQWlEO0FBQUEsTUFBL0MsU0FBK0MsU0FBL0MsU0FBK0M7QUFBQSxNQUFwQyxjQUFvQyxTQUFwQyxjQUFvQztBQUFBLE1BQXBCLEtBQW9CLFNBQXBCLEtBQW9CO0FBQUEsTUFBYixPQUFhLFNBQWIsT0FBYTs7QUFDbEU7QUFDQSxNQUFHLFFBQVEsQ0FBQyxLQUFELENBQVgsRUFBb0I7QUFDbEI7QUFDQSxRQUFNLEtBQUksR0FBRyxnQkFBZ0IsQ0FBQyxTQUFELEVBQVksY0FBWixFQUE0QixPQUE1QixDQUE3Qjs7QUFDQSxRQUFNLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxTQUFELEVBQVksY0FBWixFQUE0QixXQUE1QixDQUFqQzs7QUFDQSxRQUFNLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxTQUFELEVBQVksY0FBWixFQUE0QixZQUE1QixDQUFsQzs7QUFDQSxRQUFNLFNBQVMsR0FDYixnQkFBZ0IsQ0FBQyxTQUFELEVBQVksY0FBWixFQUE0QixZQUE1QixDQUFoQixJQUE2RCxFQUQvRCxDQUxrQixDQVFsQjs7QUFDQSxRQUFNLGFBQWEsR0FBRyxZQUFZLEtBQVosSUFBcUIsQ0FBQyxTQUFTLENBQUMsUUFBVixDQUFtQixRQUFuQixDQUE1QyxDQVRrQixDQVdsQjs7QUFDQSxRQUFHLENBQUMsYUFBRCxJQUFrQixLQUFJLEtBQUssT0FBOUIsRUFBdUM7QUFDckM7QUFDQSxVQUFHLEtBQUssQ0FBQyxPQUFELENBQUwsS0FBbUIsS0FBdEIsRUFBNEI7QUFDMUIsZUFBTyxLQUFLLENBQUMsUUFBRCxDQUFaO0FBQ0Q7O0FBQ0QsVUFBRyxlQUFlLEtBQWYsSUFBd0IsS0FBSyxDQUFDLFdBQUQsQ0FBTCxLQUF1QixRQUEvQyxJQUNBLGdCQUFnQixLQURoQixJQUN5QixLQUFLLENBQUMsWUFBRCxDQUFMLEtBQXdCLFNBRHBELEVBQytEO0FBQzdELGVBQU8sS0FBSyxDQUFDLFFBQUQsQ0FBWjtBQUNEOztBQUNELFVBQUcsZUFBZSxLQUFmLElBQXdCLEtBQUssQ0FBQyxXQUFELENBQUwsS0FBdUIsUUFBbEQsRUFBNEQ7QUFDMUQsZUFBTyxLQUFLLENBQUMsUUFBRCxDQUFaO0FBQ0Q7O0FBQ0QsVUFBRyxnQkFBZ0IsS0FBaEIsSUFBeUIsS0FBSyxDQUFDLFlBQUQsQ0FBTCxLQUF3QixTQUFwRCxFQUErRDtBQUM3RCxlQUFPLEtBQUssQ0FBQyxRQUFELENBQVo7QUFDRDtBQUNGLEtBM0JpQixDQTZCbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFFBQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksS0FBWixFQUFtQixNQUFwQztBQUNBLFFBQU0sY0FBYyxHQUFJLFFBQVEsS0FBSyxDQUFiLElBQ3JCLFFBQVEsS0FBSyxDQUFiLElBQWtCLFlBQVksS0FBOUIsSUFBdUMsQ0FBQyxhQUQzQztBQUVBLFFBQU0sa0JBQWtCLElBQUksZUFBZSxTQUFuQixDQUF4Qjs7QUFDQSxRQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLFFBQUQsQ0FBTixDQUEvQjs7QUFDQSxRQUFNLGNBQWMsR0FBSSxTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixjQUF2QixLQUN0QixTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixjQUF2QixFQUF1QyxXQUF2QyxNQUF3RCxJQUQxRDs7QUFFQSxRQUFHLGNBQWMsSUFDZixLQUFJLEtBQUssT0FEUixLQUVBLENBQUMsa0JBQUQsSUFBdUIsQ0FBQyxhQUF4QixJQUF5QyxjQUZ6QyxDQUFILEVBRTZEO0FBQzNELGFBQU8sS0FBSyxDQUFDLFFBQUQsQ0FBWjtBQUNEOztBQUVELFFBQU0sSUFBSSxHQUFHLEVBQWIsQ0E5Q2tCLENBZ0RsQjs7QUFDQSxRQUFHLGFBQUgsRUFBa0I7QUFDaEIsTUFBQSxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQUosQ0FBZTtBQUNsQixRQUFBLFNBQVMsRUFBVCxTQURrQjtBQUVsQixRQUFBLEdBQUcsRUFBRSxRQUZhO0FBR2xCLFFBQUEsVUFBVSxFQUFFO0FBQUMsVUFBQSxLQUFLLEVBQUU7QUFBUjtBQUhNLE9BQWYsQ0FBRCxDQUFKLEdBSU0sS0FBSyxDQUFDLFFBQUQsQ0FKWDtBQUtEOztBQUVELFFBQUcsV0FBVyxLQUFkLEVBQXFCO0FBQ25CO0FBQ0EsTUFBQSxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQUosQ0FBZTtBQUNsQixRQUFBLFNBQVMsRUFBVCxTQURrQjtBQUVsQixRQUFBLEdBQUcsRUFBRSxPQUZhO0FBR2xCLFFBQUEsVUFBVSxFQUFFO0FBQUMsVUFBQSxLQUFLLEVBQUU7QUFBUjtBQUhNLE9BQWYsQ0FBRCxDQUFKLEdBSU0sR0FBRyxDQUFDLFVBQUosQ0FDSjtBQUFDLFFBQUEsU0FBUyxFQUFULFNBQUQ7QUFBWSxRQUFBLEdBQUcsRUFBRSxLQUFLLENBQUMsT0FBRCxDQUF0QjtBQUFpQyxRQUFBLFVBQVUsRUFBRTtBQUFDLFVBQUEsS0FBSyxFQUFFO0FBQVI7QUFBN0MsT0FESSxDQUpOO0FBTUQsS0FSRCxNQVFPLElBQUcsZUFBZSxLQUFsQixFQUF5QjtBQUM5QjtBQUNBLE1BQUEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFKLENBQWU7QUFDbEIsUUFBQSxTQUFTLEVBQVQsU0FEa0I7QUFFbEIsUUFBQSxHQUFHLEVBQUUsV0FGYTtBQUdsQixRQUFBLFVBQVUsRUFBRTtBQUFDLFVBQUEsS0FBSyxFQUFFO0FBQVI7QUFITSxPQUFmLENBQUQsQ0FBSixHQUlNLEtBQUssQ0FBQyxXQUFELENBSlg7QUFLRDs7QUFFRCxRQUFHLGdCQUFnQixLQUFuQixFQUEwQjtBQUN4QjtBQUNBLE1BQUEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFKLENBQWU7QUFDbEIsUUFBQSxTQUFTLEVBQVQsU0FEa0I7QUFFbEIsUUFBQSxHQUFHLEVBQUUsWUFGYTtBQUdsQixRQUFBLFVBQVUsRUFBRTtBQUFDLFVBQUEsS0FBSyxFQUFFO0FBQVI7QUFITSxPQUFmLENBQUQsQ0FBSixHQUlNLEtBQUssQ0FBQyxZQUFELENBSlg7QUFLRCxLQWpGaUIsQ0FtRmxCOzs7QUFDQSxJQUFBLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBSixDQUFlO0FBQ2xCLE1BQUEsU0FBUyxFQUFULFNBRGtCO0FBRWxCLE1BQUEsR0FBRyxFQUFFLFFBRmE7QUFHbEIsTUFBQSxVQUFVLEVBQUU7QUFBQyxRQUFBLEtBQUssRUFBRTtBQUFSO0FBSE0sS0FBZixDQUFELENBQUosR0FJTSxLQUFLLENBQUMsUUFBRCxDQUpYO0FBTUEsV0FBTyxJQUFQO0FBQ0QsR0E3RmlFLENBK0ZsRTs7O0FBQ0EsTUFBTSxnQkFBZ0IsR0FBRyxVQUFVLENBQUMsU0FBRCxFQUFZLGNBQVosRUFBNEI7QUFBQyxJQUFBLEtBQUssRUFBRTtBQUFSLEdBQTVCLEVBQ2pDLE9BRGlDLENBQW5DOztBQUVBLE1BQU0sSUFBSSxHQUFHLGdCQUFnQixDQUFDLFNBQUQsRUFBWSxjQUFaLEVBQTRCLE9BQTVCLENBQTdCOztBQUNBLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxVQUFKLENBQWU7QUFDL0IsSUFBQSxTQUFTLEVBQVQsU0FEK0I7QUFFL0IsSUFBQSxHQUFHLEVBQUUsS0FBSyxDQUFDLEtBQUQsQ0FGcUI7QUFHL0IsSUFBQSxVQUFVLEVBQUU7QUFBQyxNQUFBLEtBQUssRUFBRSxJQUFJLEtBQUs7QUFBakIsS0FIbUI7QUFJL0IsSUFBQSxJQUFJLEVBQUUsT0FBTyxDQUFDO0FBSmlCLEdBQWYsQ0FBbEIsQ0FuR2tFLENBeUdsRTs7QUFDQSxNQUFHLElBQUksS0FBSyxLQUFULElBQWtCLElBQUksS0FBSyxRQUEzQixJQUF1QyxnQkFBZ0IsS0FBSyxRQUEvRCxFQUF5RTtBQUN2RSxXQUFPLFNBQVA7QUFDRDs7QUFFRCw4Q0FDRyxHQUFHLENBQUMsVUFBSixDQUFlO0FBQ2QsSUFBQSxTQUFTLEVBQVQsU0FEYztBQUVkLElBQUEsR0FBRyxFQUFFLEtBRlM7QUFHZCxJQUFBLFVBQVUsRUFBRTtBQUFDLE1BQUEsS0FBSyxFQUFFO0FBQVI7QUFIRSxHQUFmLENBREgsRUFLTyxTQUxQO0FBT0QsQ0FySEQ7QUF1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLFdBQVQsQ0FDRSxTQURGLEVBQ2EsR0FEYixFQUNrQixLQURsQixFQUN5QixVQUR6QixFQUNxQyxjQURyQyxFQUNxRCxtQkFEckQsRUFDMEU7QUFDeEUsTUFBRyxtQkFBbUIsS0FBSyxJQUEzQixFQUFpQztBQUMvQixJQUFBLG1CQUFtQixHQUFHLE9BQXRCO0FBQ0QsR0FIdUUsQ0FLeEU7OztBQUNBLE1BQU0sS0FBSyxHQUFHLEVBQWQsQ0FOd0UsQ0FReEU7O0FBQ0EsTUFBRyxDQUFDLG1CQUFtQixLQUFLLEtBQXhCLElBQWlDLG1CQUFtQixLQUFLLFVBQTFELEtBQ0QsU0FBUyxDQUFDLEtBQUQsQ0FEUixJQUNtQixTQUFTLEtBRC9CLEVBQ3NDO0FBQ3BDO0FBQ0EsUUFBRyxtQkFBbUIsS0FBSyxVQUEzQixFQUF1QztBQUNyQyxNQUFBLEtBQUssQ0FBQyxJQUFOLENBQVcsVUFBWDtBQUNELEtBSm1DLENBS3BDOzs7QUFDQSxRQUFNLElBQUksR0FBRyxHQUFHLENBQUMsVUFBSixDQUNYO0FBQUMsTUFBQSxTQUFTLEVBQVQsU0FBRDtBQUFZLE1BQUEsR0FBRyxFQUFFLEtBQUssQ0FBQyxLQUFELENBQXRCO0FBQStCLE1BQUEsVUFBVSxFQUFFO0FBQUMsUUFBQSxLQUFLLEVBQUU7QUFBUjtBQUEzQyxLQURXLENBQWI7O0FBRUEsUUFBRyxTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixJQUF2QixLQUNELFNBQVMsQ0FBQyxRQUFWLENBQW1CLEdBQW5CLENBQXVCLElBQXZCLENBREMsSUFFRCxTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixJQUF2QixFQUE2QixLQUE3QixNQUF3QyxLQUFLLENBQUMsS0FBRCxDQUYvQyxFQUV3RDtBQUN0RDtBQUNBLE1BQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxLQUFYLENBQWlCLEtBQWpCLEVBQXdCLENBQUMsUUFBRCxFQUFXLEtBQVgsQ0FBeEI7QUFDRCxLQUxELE1BS087QUFDTDtBQUNBLE1BQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxLQUFYLENBQWlCLEtBQWpCLEVBQXdCLENBQUMsS0FBRCxFQUFRLFFBQVIsQ0FBeEI7QUFDRDtBQUNGLEdBbEJELE1Ba0JPO0FBQ0wsSUFBQSxLQUFLLENBQUMsSUFBTixDQUFXLG1CQUFYLEVBREssQ0FHTDs7QUFDQSxRQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsSUFBTixDQUFXLFVBQUEsRUFBRTtBQUFBLGFBQUksRUFBRSxDQUFDLFFBQUgsQ0FBWSxHQUFaLENBQUo7QUFBQSxLQUFiLENBQWhCOztBQUNBLFFBQUcsT0FBSCxFQUFZO0FBQ1Y7QUFDQSxNQUFBLEtBQUssQ0FBQyxJQUFOLENBQVcsT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsU0FBaEIsRUFBMkIsR0FBM0IsQ0FBWDtBQUNEO0FBQ0Y7O0FBQ0QsRUFBQSxLQUFLLENBQUMsSUFBTixDQUFXLE9BQVg7QUFFQSxNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsT0FBVixDQUFrQixHQUFsQixDQUFyQjs7QUF2Q3dFLDhDQXdDakQsVUF4Q2lEO0FBQUE7O0FBQUE7QUF3Q3hFLDJEQUFtQztBQUFBLFVBQXpCLFNBQXlCOztBQUNqQztBQUNBLFVBQUcsRUFBRSxTQUFTLElBQUksWUFBZixDQUFILEVBQWlDO0FBQy9CO0FBQ0Q7O0FBRUQsVUFBTSxzQkFBc0IsR0FBRyxZQUFZLENBQUMsU0FBRCxDQUFaLENBQXdCLGNBQXhCLENBQS9COztBQU5pQyxrREFPZixLQVBlO0FBQUE7O0FBQUE7QUFPakMsK0RBQXlCO0FBQUEsY0FBZixJQUFlOztBQUN2QjtBQUNBLGNBQUcsRUFBRSxJQUFJLElBQUksc0JBQVYsQ0FBSCxFQUFzQztBQUNwQztBQUNELFdBSnNCLENBTXZCOzs7QUFDQSxpQkFBTyxzQkFBc0IsQ0FBQyxJQUFELENBQTdCO0FBQ0Q7QUFmZ0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWdCbEM7QUF4RHVFO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBMER4RSxTQUFPLElBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsa0JBQVQsQ0FBNEIsU0FBNUIsRUFBdUMsWUFBdkMsRUFBcUQsT0FBckQsRUFBOEQ7QUFDNUQsTUFBRyxVQUFVLENBQUMsU0FBRCxFQUFZLFlBQVosRUFBMEI7QUFBQyxJQUFBLEtBQUssRUFBRTtBQUFSLEdBQTFCLEVBQXlDLE9BQXpDLENBQVYsS0FBZ0UsT0FBbkUsRUFBNEU7QUFDMUUsVUFBTSxJQUFJLFdBQUosQ0FDSixxRUFDQSxxQkFGSSxFQUdKLG9CQUhJLEVBR2tCO0FBQUMsTUFBQSxJQUFJLEVBQUU7QUFBUCxLQUhsQixDQUFOO0FBSUQ7QUFDRjs7O0FDenBDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFNLEdBQUcsR0FBRyw2Q0FBWjtBQUNBLElBQU0sR0FBRyxHQUFHLG1DQUFaO0FBRUEsTUFBTSxDQUFDLE9BQVAsR0FBaUI7QUFDZjtBQUNBLEVBQUEsZUFBZSxFQUFFLHNDQUZGO0FBSWYsRUFBQSxtQkFBbUIsRUFBRSxzQ0FKTjtBQU1mLEVBQUEsR0FBRyxFQUFILEdBTmU7QUFPZixFQUFBLFFBQVEsRUFBRSxHQUFHLEdBQUcsTUFQRDtBQVFmLEVBQUEsU0FBUyxFQUFFLEdBQUcsR0FBRyxPQVJGO0FBU2YsRUFBQSxRQUFRLEVBQUUsR0FBRyxHQUFHLE1BVEQ7QUFVZixFQUFBLE9BQU8sRUFBRSxHQUFHLEdBQUcsS0FWQTtBQVdmLEVBQUEsUUFBUSxFQUFFLEdBQUcsR0FBRyxNQVhEO0FBWWYsRUFBQSxpQkFBaUIsRUFBRSxHQUFHLEdBQUcsY0FaVjtBQWFmLEVBQUEsZUFBZSxFQUFFLEdBQUcsR0FBRyxZQWJSO0FBY2YsRUFBQSxnQkFBZ0IsRUFBRSxHQUFHLEdBQUcsTUFkVDtBQWVmLEVBQUEsVUFBVSxFQUFFLEdBQUcsR0FBRyxRQWZIO0FBZ0JmLEVBQUEsY0FBYyxFQUFFLEdBQUcsR0FBRyxZQWhCUDtBQWtCZixFQUFBLEdBQUcsRUFBSCxHQWxCZTtBQW1CZixFQUFBLFdBQVcsRUFBRSxHQUFHLEdBQUcsU0FuQko7QUFvQmYsRUFBQSxVQUFVLEVBQUUsR0FBRyxHQUFHLFFBcEJIO0FBcUJmLEVBQUEsV0FBVyxFQUFFLEdBQUcsR0FBRyxTQXJCSjtBQXNCZixFQUFBLFVBQVUsRUFBRSxHQUFHLEdBQUc7QUF0QkgsQ0FBakI7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFELENBQXBCOztBQUNBLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxlQUFELENBQTNCOztlQU9JLE9BQU8sQ0FBQyxTQUFELEM7SUFKQSxRLFlBQVQsTztJQUNVLFMsWUFBVixRO0lBQ1UsUyxZQUFWLFE7SUFDYSxZLFlBQWIsVzs7Z0JBUUUsT0FBTyxDQUFDLE9BQUQsQztJQUpHLGMsYUFBWixVO0lBQ1ksYyxhQUFaLFU7SUFDQSxXLGFBQUEsVztJQUNPLFEsYUFBUCxLOztnQkFNRSxPQUFPLENBQUMsUUFBRCxDO0lBRkEsUSxhQUFULE87SUFDc0IscUIsYUFBdEIsb0I7O0FBR0YsSUFBTSxxQkFBcUIsR0FBRyxJQUFJLEdBQUosRUFBOUI7QUFDQSxJQUFNLDhCQUE4QixHQUFHLEtBQXZDO0FBQ0EsSUFBTSxlQUFlLEdBQUcsY0FBeEI7QUFFQSxJQUFNLEdBQUcsR0FBRyxFQUFaO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsR0FBakI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsR0FBRyxDQUFDLE9BQUo7QUFBQSw0RkFBYztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ1osWUFBQSxTQURZLFFBQ1osU0FEWSxFQUNELFFBREMsUUFDRCxRQURDLEVBQ1MsT0FEVCxRQUNTLE9BRFQsd0JBRVosU0FGWSxFQUVaLFNBRlksK0JBRUEsSUFGQSxnREFHWixpQkFIWSxFQUdaLGlCQUhZLHNDQUdRLEtBSFIsNkNBSVosTUFKWSxFQUlaLE1BSlksNEJBSUgsSUFBSSxHQUFKLEVBSkc7O0FBTVo7QUFDQSxnQkFBRyxTQUFTLENBQUMsUUFBRCxDQUFULElBQXVCLGNBQWMsUUFBckMsSUFDRCxRQUFRLENBQUMsUUFBUSxDQUFDLFVBQUQsQ0FBVCxDQURWLEVBQ2tDO0FBQ2hDLGNBQUEsUUFBUSxHQUFHLFFBQVEsQ0FBQyxVQUFELENBQW5CO0FBQ0Q7O0FBQ0ssWUFBQSxJQVhNLEdBV0MsUUFBUSxDQUFDLFFBQUQsQ0FYVCxFQWFaOztBQWJZLGtCQWNULElBQUksQ0FBQyxNQUFMLEtBQWdCLENBZFA7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkNBZUgsU0FmRzs7QUFBQTtBQUFBO0FBQUEsbUJBbUJXLE9BQU8sQ0FBQyxlQUFSLENBQXdCLE9BQXhCLENBQWdDO0FBQ3JELGNBQUEsU0FBUyxFQUFULFNBRHFEO0FBRXJELGNBQUEsT0FBTyxFQUFFLFFBRjRDO0FBR3JELGNBQUEsY0FBYyxFQUFFLE9BQU8sQ0FBQyxjQUg2QjtBQUlyRCxjQUFBLElBQUksRUFBRSxPQUFPLENBQUM7QUFKdUMsYUFBaEMsQ0FuQlg7O0FBQUE7QUFtQk4sWUFBQSxRQW5CTTs7QUEwQlo7QUFDQSxnQkFBRyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUQsQ0FBUixDQUFZLFFBQWIsQ0FBVCxJQUNELE9BQU8sUUFBUSxDQUFDLENBQUQsQ0FBUixDQUFZLFFBQVosQ0FBcUIsWUFBckIsQ0FBUCxLQUE4QyxTQURoRCxFQUMyRDtBQUN6RDtBQUNBLGNBQUEsU0FBUyxHQUFHLFFBQVEsQ0FBQyxDQUFELENBQVIsQ0FBWSxRQUFaLENBQXFCLFlBQXJCLENBQVo7QUFDRCxhQS9CVyxDQWlDWjtBQUNBOzs7QUFDSSxZQUFBLElBbkNRLEdBbUNELFNBbkNDLEVBcUNaO0FBQ0E7O0FBQ0EsZ0JBQUcsQ0FBQyxTQUFELElBQWMsQ0FBQyxJQUFJLENBQUMsZUFBdkIsRUFBd0M7QUFDdEM7QUFDQSxjQUFBLElBQUksR0FBRyxJQUFJLENBQUMsS0FBTCxFQUFQO0FBQ0EsY0FBQSxJQUFJLENBQUMsZUFBTCxHQUF1QixTQUF2QjtBQUNEOztBQTNDVyxtREE2Q2lCLFFBN0NqQjtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBNkNGLFlBQUEsZUE3Q0U7QUE4Q0ssWUFBQSxHQTlDTCxHQThDWSxlQTlDWixDQThDTCxRQTlDSyxFQWdEVjs7QUFDQSxZQUFBLFNBQVMsR0FBRyxJQUFaLENBakRVLENBbURWOztBQW5EVSxrQkFvRFAsR0FBRyxLQUFLLElBcEREO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQXVETCxDQUFDLGlCQUFELElBQ0QsTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFTLGFBQXJCLEVBQWlDLE1BQWpDLEtBQTRDLENBeER0QztBQUFBO0FBQUE7QUFBQTs7QUF5REEsWUFBQSxhQXpEQSxHQXlEaUIsT0FBTyxJQUFJLE9BQU8sQ0FBQyxhQUFwQixJQUFzQyxPQXpEdEQ7O0FBQUEsa0JBMERILGFBQWEsS0FBSyxPQTFEZjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkEyREUsSUFBSSxXQUFKLENBQ0osZ0VBQ0Esb0JBRkksRUFHSixvQkFISSxFQUlKO0FBQUMsY0FBQSxJQUFJLEVBQUU7QUFBUCxhQUpJLENBM0RGOztBQUFBO0FBQUEsa0JBZ0VJLGFBQWEsS0FBSyxNQWhFdEI7QUFBQTtBQUFBO0FBQUE7O0FBaUVKO0FBQ0EsWUFBQSxPQUFPLENBQUMsSUFBUixDQUFhLHdDQUFiLEVBbEVJLENBb0VKOztBQUNNLFlBQUEsVUFyRUYsR0FxRWMsZUFBZSxDQUFDLFlBQWhCLENBQTZCLFNBQTdCLENBckVkOztBQUFBLGlCQXNFRCxVQXRFQztBQUFBO0FBQUE7QUFBQTs7QUF1RUYsWUFBQSxJQUFJLEdBQUcsU0FBUyxHQUFHLFVBQW5CO0FBdkVFOztBQUFBO0FBMkVFLFlBQUEsWUEzRUYsR0EyRWlCLFNBM0VqQixFQTRFSjs7QUFDQSxZQUFBLElBQUksR0FBRyxTQUFTLEdBQUcsR0FBRyxDQUFDLGlCQUFKLENBQXNCLE9BQXRCLEVBQStCLEtBQS9CLEVBQW5COztBQUNBLDJDQUNFLE1BQU0sQ0FBQyxPQUFQLENBQWUsWUFBWSxhQUEzQixDQURGLHFDQUMwQztBQUFBLDRGQUQvQixJQUMrQiwwQkFEekIsVUFDeUI7O0FBQ3hDLGtCQUFHLFVBQUgsRUFBZTtBQUNiLGdCQUFBLFNBQVMsQ0FBQyxRQUFWLENBQW1CLElBQW5CLElBQ0UsSUFBSSxDQUFDLEtBQUwsQ0FBVyxZQUFZLENBQUMsUUFBYixDQUFzQixJQUF0QixDQUFYLENBREY7QUFFRDtBQUNGOztBQUNELFlBQUEsU0FBUyxhQUFULEdBQXNCLElBQUksQ0FBQyxLQUFMLENBQVcsWUFBWSxhQUF2QixDQUF0QixDQXJGSSxDQXVGSjs7QUFDQSxZQUFBLGVBQWUsQ0FBQyxZQUFoQixDQUE2QixZQUE3QixFQUEyQyxJQUEzQztBQXhGSTs7QUFBQTtBQUFBLGtCQTJGQSxJQUFJLFdBQUosQ0FDSix3QkFESSxFQUVKLG9CQUZJLEVBR0o7QUFBQyxjQUFBLElBQUksRUFBRSx3QkFBUDtBQUFpQyxjQUFBLE9BQU8sRUFBRSxRQUExQztBQUFvRCxjQUFBLGFBQWEsRUFBYjtBQUFwRCxhQUhJLENBM0ZBOztBQUFBO0FBZ0dSLFlBQUEsSUFBSSxHQUFHLFNBQVMsR0FBRyxHQUFHLENBQUMsaUJBQUosQ0FBc0IsT0FBdEIsRUFBK0IsS0FBL0IsRUFBbkI7QUFoR1E7O0FBQUE7QUFvR1Y7QUFDTSxZQUFBLFNBckdJLEdBcUdRLGVBQWUsQ0FBQyxZQUFoQixDQUE2QixTQUE3QixDQXJHUjs7QUFBQSxpQkFzR1AsU0F0R087QUFBQTtBQUFBO0FBQUE7O0FBdUdSLFlBQUEsSUFBSSxHQUFHLFNBQVMsR0FBRyxTQUFuQjtBQXZHUTs7QUFBQTtBQTJHVjtBQUNBLGdCQUFHLFNBQVMsQ0FBQyxHQUFELENBQVQsSUFBa0IsY0FBYyxHQUFuQyxFQUF3QztBQUN0QyxjQUFBLEdBQUcsR0FBRyxHQUFHLENBQUMsVUFBRCxDQUFUO0FBQ0QsYUE5R1MsQ0FnSFY7OztBQWhIVSxnQkFpSE4sU0FBUyxDQUFDLEdBQUQsQ0FqSEg7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBa0hGLElBQUksV0FBSixDQUNKLHFEQURJLEVBRUosb0JBRkksRUFFa0I7QUFBQyxjQUFBLElBQUksRUFBRSx1QkFBUDtBQUFnQyxjQUFBLE9BQU8sRUFBRTtBQUF6QyxhQUZsQixDQWxIRTs7QUFBQTtBQXVIVjtBQUNBO0FBRUE7QUFDQSxZQUFBLElBQUksR0FBRyxJQUFJLENBQUMsS0FBTCxFQUFQLENBM0hVLENBNkhWOztBQUNNLFlBQUEsT0E5SEksR0E4SE0sSUFBSSxHQUFKLEVBOUhOLEVBZ0lWOztBQWhJVSxrQkFpSVAsY0FBYyxHQWpJUDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFrSUwsR0FBRyxDQUFDLFVBQUQsQ0FBSCxLQUFvQixHQWxJZjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFtSUEsSUFBSSxXQUFKLENBQ0osa0NBQWtDLEdBQUcsQ0FBQyxVQUFELENBRGpDLEVBRUosMkJBRkksRUFHSjtBQUFDLGNBQUEsSUFBSSxFQUFFLHdCQUFQO0FBQWlDLGNBQUEsT0FBTyxFQUFFO0FBQTFDLGFBSEksQ0FuSUE7O0FBQUE7QUFBQSxrQkF3SUwsU0FBUyxDQUFDLGNBQVYsSUFDRCxTQUFTLENBQUMsY0FBVixLQUE2QixhQXpJdkI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBMElBLElBQUksV0FBSixDQUNKLGVBQWUsR0FBRyxDQUFDLFVBQUQsQ0FBbEIsR0FBaUMsdUJBQWpDLEdBQ0EsU0FBUyxDQUFDLGNBRk4sRUFHSiwrQkFISSxFQUlKO0FBQUMsY0FBQSxJQUFJLEVBQUUsMEJBQVA7QUFBbUMsY0FBQSxPQUFPLEVBQUU7QUFBNUMsYUFKSSxDQTFJQTs7QUFBQTtBQWdKUixZQUFBLElBQUksQ0FBQyxjQUFMLEdBQXNCLGFBQXRCO0FBQ0EsWUFBQSxJQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1CLEdBQUcsQ0FBQyxVQUFELENBQXRCO0FBQ0EsWUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLFVBQVosRUFBd0IsSUFBeEI7O0FBbEpRO0FBcUpWO0FBQ0EsWUFBQSxJQUFJLENBQUMsY0FBTCxHQUNFLElBQUksQ0FBQyxjQUFMLElBQXVCLFNBQVMsQ0FBQyxjQURuQyxDQXRKVSxDQXlKVjs7QUF6SlUsa0JBMEpQLFdBQVcsR0ExSko7QUFBQTtBQUFBO0FBQUE7O0FBMkpKLFlBQUEsSUEzSkksR0EySkcsR0FBRyxDQUFDLE9BQUQsQ0EzSk47O0FBQUEsa0JBNkpMLElBQUksS0FBSyxJQUFULElBQWlCLGNBQWMsQ0FBQyxJQUFELENBN0oxQjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUEsaUJBK0pFLGNBQWMsQ0FBQyxJQUFELENBL0poQjtBQUFBO0FBQUE7QUFBQTs7QUFnS04sWUFBQSxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFELENBQUwsRUFBZ0IsSUFBaEIsQ0FBbEI7QUFoS007QUFBQTs7QUFBQTtBQUFBLGtCQWtLQSxJQUFJLFdBQUosQ0FDSix1REFDQSw0REFGSSxFQUdKLG9CQUhJLEVBR2tCO0FBQUMsY0FBQSxJQUFJLEVBQUUsa0JBQVA7QUFBMkIsY0FBQSxPQUFPLEVBQUU7QUFBcEMsYUFIbEIsQ0FsS0E7O0FBQUE7QUF3S1IsWUFBQSxJQUFJLENBQUMsT0FBRCxDQUFKLEdBQWdCLElBQWhCO0FBQ0EsWUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLE9BQVosRUFBcUIsSUFBckI7O0FBektRO0FBQUEsa0JBNktQLFlBQVksR0E3S0w7QUFBQTtBQUFBO0FBQUE7O0FBOEtGLFlBQUEsS0E5S0UsR0E4S00sR0FBRyxDQUFDLFFBQUQsQ0E5S1Q7O0FBQUEsa0JBK0tMLEtBQUssS0FBSyxJQS9LTDtBQUFBO0FBQUE7QUFBQTs7QUFnTE4sbUJBQU8sSUFBSSxDQUFDLFFBQUQsQ0FBWDtBQWhMTTtBQUFBOztBQUFBO0FBQUEsZ0JBaUxHLFNBQVMsQ0FBQyxLQUFELENBakxaO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQWtMQSxJQUFJLFdBQUosQ0FDSix3REFDQSxvQ0FGSSxFQUdKLG9CQUhJLEVBR2tCO0FBQUMsY0FBQSxJQUFJLEVBQUUsdUJBQVA7QUFBZ0MsY0FBQSxPQUFPLEVBQUU7QUFBekMsYUFIbEIsQ0FsTEE7O0FBQUE7QUFBQSxrQkFzTEUsQ0FBQyxjQUFjLENBQUMsS0FBRCxDQUFmLElBQTBCLEdBQUcsQ0FBQyxjQUFKLENBQW1CLElBQW5CLEVBQXlCLEdBQXpCLENBdEw1QjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkF1TEEsSUFBSSxXQUFKLENBQ0osd0RBQ0EsbUNBRkksRUFHSixvQkFISSxFQUdrQjtBQUFDLGNBQUEsSUFBSSxFQUFFLHVCQUFQO0FBQWdDLGNBQUEsT0FBTyxFQUFFO0FBQXpDLGFBSGxCLENBdkxBOztBQUFBO0FBNExOLFlBQUEsSUFBSSxDQUFDLFFBQUQsQ0FBSixHQUFpQixVQUFVLENBQUMsSUFBRCxFQUFPLEtBQVAsRUFBYztBQUFDLGNBQUEsS0FBSyxFQUFFLElBQVI7QUFBYyxjQUFBLElBQUksRUFBRTtBQUFwQixhQUFkLEVBQ3pCLFNBRHlCLEVBQ2QsU0FEYyxFQUNILE9BREcsQ0FBM0I7O0FBNUxNO0FBK0xSLFlBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxRQUFaLEVBQXNCLElBQXRCOztBQS9MUTtBQUFBLGtCQW1NUCxlQUFlLEdBbk1SO0FBQUE7QUFBQTtBQUFBOztBQW9NRixZQUFBLE1BcE1FLEdBb01NLEdBQUcsQ0FBQyxXQUFELENBcE1UOztBQUFBLGtCQXFNTCxNQUFLLEtBQUssSUFyTUw7QUFBQTtBQUFBO0FBQUE7O0FBc01OLG1CQUFPLElBQUksQ0FBQyxXQUFELENBQVg7QUF0TU07QUFBQTs7QUFBQTtBQUFBLGdCQXVNRyxTQUFTLENBQUMsTUFBRCxDQXZNWjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkF3TUEsSUFBSSxXQUFKLENBQ0osMkRBQ0Esb0NBRkksRUFHSixvQkFISSxFQUlKO0FBQUMsY0FBQSxJQUFJLEVBQUUsMEJBQVA7QUFBbUMsY0FBQSxPQUFPLEVBQUU7QUFBNUMsYUFKSSxDQXhNQTs7QUFBQTtBQThNTixZQUFBLElBQUksQ0FBQyxXQUFELENBQUosR0FBb0IsTUFBSyxDQUFDLFdBQU4sRUFBcEI7O0FBOU1NO0FBZ05SLFlBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxXQUFaLEVBQXlCLElBQXpCOztBQWhOUTtBQUFBLGtCQW9OUCxnQkFBZ0IsR0FwTlQ7QUFBQTtBQUFBO0FBQUE7O0FBcU5GLFlBQUEsT0FyTkUsR0FxTk0sR0FBRyxDQUFDLFlBQUQsQ0FyTlQ7O0FBQUEsa0JBc05MLFNBQVMsQ0FBQyxjQUFWLEtBQTZCLGFBdE54QjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkF1TkEsSUFBSSxXQUFKLENBQ0osNERBQ0EsU0FBUyxDQUFDLGNBRk4sRUFHSixvQkFISSxFQUlKO0FBQUMsY0FBQSxJQUFJLEVBQUUsd0JBQVA7QUFBaUMsY0FBQSxPQUFPLEVBQUU7QUFBMUMsYUFKSSxDQXZOQTs7QUFBQTtBQUFBLGtCQTZOTCxPQUFLLEtBQUssSUE3Tkw7QUFBQTtBQUFBO0FBQUE7O0FBOE5OLG1CQUFPLElBQUksQ0FBQyxZQUFELENBQVg7QUE5Tk07QUFBQTs7QUFBQTtBQUFBLGtCQStORSxPQUFLLEtBQUssS0FBVixJQUFtQixPQUFLLEtBQUssS0EvTi9CO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQWdPQSxJQUFJLFdBQUosQ0FDSiw0REFDQSx5Q0FGSSxFQUdKLG9CQUhJLEVBSUo7QUFBQyxjQUFBLElBQUksRUFBRSx3QkFBUDtBQUFpQyxjQUFBLE9BQU8sRUFBRTtBQUExQyxhQUpJLENBaE9BOztBQUFBO0FBc09OLFlBQUEsSUFBSSxDQUFDLFlBQUQsQ0FBSixHQUFxQixPQUFyQjs7QUF0T007QUF3T1IsWUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLFlBQVosRUFBMEIsSUFBMUI7O0FBeE9RO0FBQUEsa0JBNk9QLGdCQUFnQixHQTdPVDtBQUFBO0FBQUE7QUFBQTs7QUE4T0YsWUFBQSxPQTlPRSxHQThPTSxHQUFHLENBQUMsWUFBRCxDQTlPVDs7QUFBQSxrQkErT0wsU0FBUyxDQUFDLGNBQVYsS0FBNkIsYUEvT3hCO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQWdQQSxJQUFJLFdBQUosQ0FDSiw0REFDQSxTQUFTLENBQUMsY0FGTixFQUdKLG9CQUhJLEVBSUo7QUFBQyxjQUFBLElBQUksRUFBRSx1QkFBUDtBQUFnQyxjQUFBLE9BQU8sRUFBRTtBQUF6QyxhQUpJLENBaFBBOztBQUFBO0FBQUEsa0JBc1BMLE9BQU8sT0FBUCxLQUFpQixTQXRQWjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkF1UEEsSUFBSSxXQUFKLENBQ0osNkRBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsY0FBQSxJQUFJLEVBQUUsMEJBQVA7QUFBbUMsY0FBQSxPQUFPLEVBQUU7QUFBNUMsYUFISSxDQXZQQTs7QUFBQTtBQTRQUixZQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksWUFBWixFQUEwQixJQUExQjs7QUE1UFE7QUFBQSxrQkFnUVAsYUFBYSxHQWhRTjtBQUFBO0FBQUE7QUFBQTs7QUFpUUYsWUFBQSxPQWpRRSxHQWlRTSxHQUFHLENBQUMsU0FBRCxDQWpRVDs7QUFBQSxrQkFrUUwsU0FBUyxDQUFDLGNBQVYsS0FBNkIsYUFsUXhCO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQW1RQSxJQUFJLFdBQUosQ0FDSix5REFDQSxTQUFTLENBQUMsY0FGTixFQUdKLG9CQUhJLEVBSUo7QUFBQyxjQUFBLElBQUksRUFBRSx1QkFBUDtBQUFnQyxjQUFBLE9BQU8sRUFBRTtBQUF6QyxhQUpJLENBblFBOztBQUFBO0FBQUEsZ0JBeVFKLFNBQVMsQ0FBQyxPQUFELENBelFMO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQTBRQSxJQUFJLFdBQUosQ0FDSixtREFESSxFQUVKLG9CQUZJLEVBR0o7QUFBQyxjQUFBLElBQUksRUFBRSx1QkFBUDtBQUFnQyxjQUFBLE9BQU8sRUFBRTtBQUF6QyxhQUhJLENBMVFBOztBQUFBO0FBQUE7QUFBQSxtQkFpUnFCLE9BQU8sQ0FBQyxlQUFSLENBQXdCLE9BQXhCLENBQWdDO0FBQzNELGNBQUEsU0FBUyxFQUFULFNBRDJEO0FBRTNELGNBQUEsT0FBTyxFQUFFLE9BRmtEO0FBRzNELGNBQUEsY0FBYyxFQUFFLE9BQU8sQ0FBQyxjQUhtQztBQUkzRCxjQUFBLElBQUksRUFBRSxPQUFPLENBQUM7QUFKNkMsYUFBaEMsQ0FqUnJCOztBQUFBO0FBaVJGLFlBQUEsY0FqUkU7O0FBQUEsa0JBdVJMLGNBQWMsQ0FBQyxNQUFmLEtBQTBCLENBdlJyQjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkF3UkEsSUFBSSxXQUFKLENBQ0osa0VBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsY0FBQSxJQUFJLEVBQUUsd0JBQVA7QUFBaUMsY0FBQSxPQUFPLEVBQUU7QUFBMUMsYUFISSxDQXhSQTs7QUFBQTtBQTZSRixZQUFBLGVBN1JFLEdBNlJnQixjQUFjLENBQUMsQ0FBRCxDQUFkLENBQWtCLFlBQWxCLENBQStCLFNBQS9CLENBN1JoQjs7QUFBQSxpQkE4UkwsZUE5Uks7QUFBQTtBQUFBO0FBQUE7O0FBK1JOO0FBQ0E7QUFDQTtBQUNBLFlBQUEsR0FBRyxHQUFHLGVBQU47QUFsU007QUFBQTs7QUFBQTtBQW9TQSxZQUFBLFNBcFNBLEdBb1NZLGNBQWMsQ0FBQyxDQUFELENBQWQsQ0FBa0IsUUFwUzlCOztBQUFBLGtCQXFTSCxhQUFhLFNBclNWO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQXNTRSxJQUFJLFdBQUosQ0FDSiw2QkFDQSw0Q0FGSSxFQUdKLG9CQUhJLEVBSUo7QUFBQyxjQUFBLElBQUksRUFBRSx1QkFBUDtBQUFnQyxjQUFBLE9BQU8sRUFBRTtBQUF6QyxhQUpJLENBdFNGOztBQUFBO0FBNlNOO0FBQ0EsaUJBQVUsR0FBVixJQUFpQixTQUFqQixFQUE0QjtBQUMxQixrQkFBRyxDQUFDLEdBQUcsQ0FBQyxjQUFKLENBQW1CLEdBQW5CLENBQUosRUFBNkI7QUFDM0IsZ0JBQUEsR0FBRyxDQUFDLEdBQUQsQ0FBSCxHQUFXLFNBQVMsQ0FBQyxHQUFELENBQXBCO0FBQ0Q7QUFDRixhQWxUSyxDQW9UTjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsWUFBQSxjQUFjLENBQUMsQ0FBRCxDQUFkLENBQWtCLFlBQWxCLENBQStCLFNBQS9CLEVBQTBDLEdBQTFDOztBQXhUTTtBQTJUUixZQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksU0FBWixFQUF1QixJQUF2Qjs7QUEzVFE7QUE4VFY7QUFDQTtBQUNBO0FBQ0EsWUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLFlBQVosRUFBMEIsR0FBRyxDQUFDLFlBQUQsQ0FBSCxJQUFxQixLQUEvQyxFQWpVVSxDQW1VVjs7QUFuVVUsdURBb1VPLEdBcFVQOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBb1VBLFlBQUEsSUFwVUE7QUFxVVIsWUFBQSxHQUFHLENBQUMsb0JBQUosQ0FBeUI7QUFDdkIsY0FBQSxTQUFTLEVBQUUsSUFEWTtBQUV2QixjQUFBLFFBQVEsRUFBRSxHQUZhO0FBR3ZCLGNBQUEsSUFBSSxFQUFFLElBSGlCO0FBSXZCLGNBQUEsT0FBTyxFQUFQLE9BSnVCO0FBS3ZCLGNBQUEsT0FBTyxFQUFQLE9BTHVCO0FBTXZCLGNBQUEsaUJBQWlCLEVBQWpCO0FBTnVCLGFBQXpCOztBQXJVUSxrQkE4VUwsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFELENBQUosQ0FBVCxJQUF1QixjQUFjLEdBQUcsQ0FBQyxJQUFELENBOVVuQztBQUFBO0FBQUE7QUFBQTs7QUErVUEsWUFBQSxNQS9VQSxHQStVUyxHQUFHLENBQUMsSUFBRCxDQUFILENBQVMsVUFBVCxDQS9VVDtBQWdWRixZQUFBLE9BaFZFLEdBZ1ZRLElBaFZSOztBQWlWTixnQkFBRyxTQUFTLENBQUMsTUFBRCxDQUFaLEVBQXNCO0FBQ2QsY0FBQSxHQURjLEdBQ1IsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFULEVBQWUsTUFBZixDQURILEVBRXBCOztBQUNBLGtCQUFHLE1BQU0sQ0FBQyxHQUFQLENBQVcsR0FBWCxDQUFILEVBQW9CO0FBQ2xCLGdCQUFBLE9BQU8sR0FBRyxLQUFWO0FBQ0QsZUFGRCxNQUVPO0FBQ0wsZ0JBQUEsTUFBTSxDQUFDLEdBQVAsQ0FBVyxHQUFYO0FBQ0Q7QUFDRixhQXpWSyxDQTBWTjs7O0FBMVZNLGlCQTJWSCxPQTNWRztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsbUJBNlZJLEdBQUcsQ0FBQyxPQUFKLENBQVk7QUFDaEIsY0FBQSxTQUFTLEVBQUUsSUFBSSxDQUFDLEtBQUwsRUFESztBQUVoQixjQUFBLFFBQVEsRUFBRSxHQUFHLENBQUMsSUFBRCxDQUFILENBQVMsVUFBVCxDQUZNO0FBR2hCLGNBQUEsaUJBQWlCLEVBQUUsSUFISDtBQUloQixjQUFBLE9BQU8sRUFBUCxPQUpnQjtBQUtoQixjQUFBLE1BQU0sRUFBTjtBQUxnQixhQUFaLENBN1ZKOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFxV0ksSUFBSSxXQUFKLENBQ0osaURBREksRUFFSixvQkFGSSxFQUdKO0FBQ0UsY0FBQSxJQUFJLEVBQUUsd0JBRFI7QUFFRSxjQUFBLE9BQU8sRUFBRSxHQUFHLENBQUMsSUFBRCxDQUFILENBQVMsVUFBVCxDQUZYO0FBR0UsY0FBQSxJQUFJLEVBQUU7QUFIUixhQUhJLENBcldKOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQWtYVjtBQUNBLFlBQUEsZUFBZSxDQUFDLFlBQWhCLENBQTZCLFNBQTdCLEVBQXdDLElBQXhDOztBQW5YVTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUEsNkNBc1hMLElBdFhLOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQWQ7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF5WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLG9CQUFKLEdBQTJCLGlCQU9yQjtBQUFBLE1BTkosU0FNSSxTQU5KLFNBTUk7QUFBQSxNQUxKLFFBS0ksU0FMSixRQUtJO0FBQUEsTUFKSixJQUlJLFNBSkosSUFJSTtBQUFBLE1BSEosT0FHSSxTQUhKLE9BR0k7QUFBQSxNQUZKLE9BRUksU0FGSixPQUVJO0FBQUEsb0NBREosaUJBQ0k7QUFBQSxNQURKLGlCQUNJLHNDQURnQixLQUNoQjs7QUFDSixNQUFHLE9BQU8sQ0FBQyxHQUFSLENBQVksSUFBWixDQUFILEVBQXNCO0FBQ3BCO0FBQ0EsUUFBRyxPQUFPLENBQUMsR0FBUixDQUFZLElBQVosQ0FBSCxFQUFzQjtBQUNwQjtBQUNELEtBSm1CLENBS3BCOzs7QUFDQSxVQUFNLElBQUksV0FBSixDQUNKLHVDQURJLEVBRUosd0JBRkksRUFHSjtBQUFDLE1BQUEsSUFBSSxFQUFFLG9CQUFQO0FBQTZCLE1BQUEsT0FBTyxFQUFFLFFBQXRDO0FBQWdELE1BQUEsSUFBSSxFQUFKO0FBQWhELEtBSEksQ0FBTjtBQUlELEdBWEcsQ0FhSjs7O0FBQ0EsRUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLElBQVosRUFBa0IsS0FBbEIsRUFkSSxDQWdCSjs7QUFDQSxNQUFJLEtBQUo7O0FBQ0EsTUFBRyxRQUFRLENBQUMsY0FBVCxDQUF3QixJQUF4QixDQUFILEVBQWtDO0FBQ2hDLElBQUEsS0FBSyxHQUFHLFFBQVEsQ0FBQyxJQUFELENBQWhCO0FBQ0Q7O0FBRUQsTUFBRyxJQUFJLEtBQUssT0FBVCxJQUNBLFNBQVMsQ0FBQyxLQUFELENBRFQsSUFFQSxDQUFDLEtBQUssQ0FBQyxZQUFELENBQUwsSUFBdUIsTUFBeEIsTUFBb0MsTUFGcEMsSUFHQSxHQUFHLENBQUMsY0FBSixDQUFtQixTQUFuQixFQUE4QixHQUE5QixDQUhILEVBR3VDO0FBRXJDLFFBQU0sVUFBUyxHQUFHLENBQUMsWUFBRCxFQUFlLEtBQWYsRUFBc0IsWUFBdEIsQ0FBbEI7QUFDQSxRQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLEtBQVosQ0FBYjs7QUFDQSxRQUFHLElBQUksQ0FBQyxNQUFMLEtBQWdCLENBQWhCLElBQXFCLElBQUksQ0FBQyxJQUFMLENBQVUsVUFBQSxDQUFDO0FBQUEsYUFBSSxDQUFDLFVBQVMsQ0FBQyxRQUFWLENBQW1CLENBQW5CLENBQUw7QUFBQSxLQUFYLENBQXhCLEVBQWdFO0FBQzlELFlBQU0sSUFBSSxXQUFKLENBQ0osd0RBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsUUFBQSxJQUFJLEVBQUUsc0JBQVA7QUFBK0IsUUFBQSxPQUFPLEVBQUUsUUFBeEM7QUFBa0QsUUFBQSxJQUFJLEVBQUo7QUFBbEQsT0FISSxDQUFOO0FBSUQ7QUFDRixHQWJELE1BYU8sSUFBRyxHQUFHLENBQUMsU0FBSixDQUFjLElBQWQsQ0FBSCxFQUF3QjtBQUM3QixVQUFNLElBQUksV0FBSixDQUNKLHdEQURJLEVBRUosb0JBRkksRUFHSjtBQUFDLE1BQUEsSUFBSSxFQUFFLHNCQUFQO0FBQStCLE1BQUEsT0FBTyxFQUFFLFFBQXhDO0FBQWtELE1BQUEsSUFBSSxFQUFKO0FBQWxELEtBSEksQ0FBTjtBQUlELEdBTE0sTUFLQSxJQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsZUFBWCxDQUFILEVBQWdDO0FBQ3JDO0FBQ0EsSUFBQSxPQUFPLENBQUMsSUFBUixDQUFhLG1EQUNYLDZCQURGLEVBQ2lDO0FBQUMsTUFBQSxJQUFJLEVBQUo7QUFBRCxLQURqQztBQUVBO0FBQ0QsR0FMTSxNQUtBLElBQUcsSUFBSSxLQUFLLEVBQVosRUFBZ0I7QUFDckIsVUFBTSxJQUFJLFdBQUosQ0FDSiwyREFESSxFQUVKLG9CQUZJLEVBR0o7QUFBQyxNQUFBLElBQUksRUFBRSx5QkFBUDtBQUFrQyxNQUFBLE9BQU8sRUFBRTtBQUEzQyxLQUhJLENBQU47QUFJRCxHQWxERyxDQW9ESjs7O0FBQ0EsTUFBTSxlQUFlLEdBQUcsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsSUFBdkIsQ0FBeEIsQ0FyREksQ0F1REo7O0FBQ0EsTUFBRyxTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixJQUF2QixDQUFILEVBQWlDO0FBQy9CLElBQUEsU0FBUyxDQUFDLFFBQVYsV0FBMEIsSUFBMUI7QUFDRCxHQTFERyxDQTRESjs7O0FBQ0EsTUFBSSxVQUFVLEdBQUcsS0FBakI7O0FBQ0EsTUFBRyxTQUFTLENBQUMsS0FBRCxDQUFULElBQW9CLEtBQUssS0FBSyxJQUFqQyxFQUF1QztBQUNyQyxJQUFBLFVBQVUsR0FBRyxJQUFiO0FBQ0EsSUFBQSxLQUFLLEdBQUc7QUFBQyxhQUFPO0FBQVIsS0FBUjtBQUNEOztBQUVELE1BQUcsQ0FBQyxTQUFTLENBQUMsS0FBRCxDQUFiLEVBQXNCO0FBQ3BCLFVBQU0sSUFBSSxXQUFKLENBQ0osMERBQ0EscUJBRkksRUFHSixvQkFISSxFQUlKO0FBQUMsTUFBQSxJQUFJLEVBQUUseUJBQVA7QUFBa0MsTUFBQSxPQUFPLEVBQUU7QUFBM0MsS0FKSSxDQUFOO0FBS0QsR0F6RUcsQ0EyRUo7OztBQUNBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBQ0EsRUFBQSxTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixJQUF2QixFQUE2QixPQUE3QjtBQUNBLEVBQUEsT0FBTyxDQUFDLE9BQVIsR0FBa0IsS0FBbEIsQ0E5RUksQ0FnRko7O0FBQ0EsTUFBTSxTQUFTLEdBQUcsQ0FBQyxZQUFELEVBQWUsS0FBZixFQUFzQixXQUF0QixFQUFtQyxVQUFuQyxFQUErQyxPQUEvQyxDQUFsQixDQWpGSSxDQW1GSjs7QUFDQSxNQUFHLEdBQUcsQ0FBQyxjQUFKLENBQW1CLFNBQW5CLEVBQThCLEdBQTlCLENBQUgsRUFBdUM7QUFDckMsSUFBQSxTQUFTLENBQUMsSUFBVixDQUNFLFVBREYsRUFDYyxZQURkLEVBQzRCLFFBRDVCLEVBQ3NDLE9BRHRDLEVBQytDLFNBRC9DLEVBQzBELFlBRDFEO0FBRUQ7O0FBRUQsT0FBSSxJQUFNLEVBQVYsSUFBZ0IsS0FBaEIsRUFBdUI7QUFDckIsUUFBRyxDQUFDLFNBQVMsQ0FBQyxRQUFWLENBQW1CLEVBQW5CLENBQUosRUFBNEI7QUFDMUIsWUFBTSxJQUFJLFdBQUosQ0FDSixnRUFBZ0UsRUFENUQsRUFFSixvQkFGSSxFQUdKO0FBQUMsUUFBQSxJQUFJLEVBQUUseUJBQVA7QUFBa0MsUUFBQSxPQUFPLEVBQUU7QUFBM0MsT0FISSxDQUFOO0FBSUQ7QUFDRixHQWhHRyxDQWtHSjtBQUNBOzs7QUFDQSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTCxDQUFhLEdBQWIsQ0FBZDtBQUNBLEVBQUEsT0FBTyxDQUFDLGFBQVIsR0FBeUIsS0FBSyxHQUFHLENBQWpDOztBQUVBLE1BQUcsY0FBYyxLQUFqQixFQUF3QjtBQUN0QixRQUFHLFNBQVMsS0FBWixFQUFtQjtBQUNqQixZQUFNLElBQUksV0FBSixDQUNKLGlFQUNBLGNBRkksRUFFWSxvQkFGWixFQUdKO0FBQUMsUUFBQSxJQUFJLEVBQUUsMEJBQVA7QUFBbUMsUUFBQSxPQUFPLEVBQUU7QUFBNUMsT0FISSxDQUFOO0FBSUQ7O0FBQ0QsUUFBRyxXQUFXLEtBQWQsRUFBcUI7QUFDbkIsWUFBTSxJQUFJLFdBQUosQ0FDSixpRUFDQSxnQkFGSSxFQUVjLG9CQUZkLEVBR0o7QUFBQyxRQUFBLElBQUksRUFBRSwwQkFBUDtBQUFtQyxRQUFBLE9BQU8sRUFBRTtBQUE1QyxPQUhJLENBQU47QUFJRDs7QUFDRCxRQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsVUFBRCxDQUFyQjs7QUFDQSxRQUFHLENBQUMsU0FBUyxDQUFDLE9BQUQsQ0FBYixFQUF3QjtBQUN0QixZQUFNLElBQUksV0FBSixDQUNKLHFFQURJLEVBRUosb0JBRkksRUFFa0I7QUFBQyxRQUFBLElBQUksRUFBRSxxQkFBUDtBQUE4QixRQUFBLE9BQU8sRUFBRTtBQUF2QyxPQUZsQixDQUFOO0FBR0Q7O0FBRUQsUUFBRyxDQUFDLEdBQUcsQ0FBQyxTQUFKLENBQWMsT0FBZCxDQUFELElBQTJCLE9BQU8sQ0FBQyxLQUFSLENBQWMsZUFBZCxDQUE5QixFQUE4RDtBQUM1RDtBQUNBLE1BQUEsT0FBTyxDQUFDLElBQVIsQ0FBYSxvREFDWCw2QkFERixFQUNpQztBQUFDLFFBQUEsT0FBTyxFQUFQO0FBQUQsT0FEakM7O0FBRUEsVUFBRyxlQUFILEVBQW9CO0FBQ2xCLFFBQUEsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsSUFBdkIsRUFBNkIsZUFBN0I7QUFDRCxPQUZELE1BRU87QUFDTCxRQUFBLFNBQVMsQ0FBQyxRQUFWLFdBQTBCLElBQTFCO0FBQ0Q7O0FBQ0Q7QUFDRCxLQTlCcUIsQ0FnQ3RCOzs7QUFDQSxRQUFNLEdBQUUsR0FBRyxVQUFVLENBQ25CLFNBRG1CLEVBQ1IsT0FEUSxFQUNDO0FBQUMsTUFBQSxLQUFLLEVBQUUsSUFBUjtBQUFjLE1BQUEsSUFBSSxFQUFFO0FBQXBCLEtBREQsRUFDNkIsUUFEN0IsRUFDdUMsT0FEdkMsRUFFbkIsT0FGbUIsQ0FBckI7O0FBR0EsUUFBRyxDQUFDLGNBQWMsQ0FBQyxHQUFELENBQWxCLEVBQXdCO0FBQ3RCLFlBQU0sSUFBSSxXQUFKLENBQ0osa0VBQ0EsMENBRkksRUFHSixvQkFISSxFQUdrQjtBQUFDLFFBQUEsSUFBSSxFQUFFLHFCQUFQO0FBQThCLFFBQUEsT0FBTyxFQUFFO0FBQXZDLE9BSGxCLENBQU47QUFJRDs7QUFFRCxJQUFBLE9BQU8sQ0FBQyxLQUFELENBQVAsR0FBaUIsR0FBakI7QUFDQSxJQUFBLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLElBQWxCO0FBQ0QsR0E3Q0QsTUE2Q08sSUFBRyxTQUFTLEtBQVosRUFBbUI7QUFDeEIsUUFBSSxJQUFFLEdBQUcsS0FBSyxDQUFDLEtBQUQsQ0FBZDs7QUFDQSxRQUFHLElBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFELENBQW5CLEVBQXlCO0FBQ3ZCLFlBQU0sSUFBSSxXQUFKLENBQ0osbUVBQ0EseUJBRkksRUFHSixvQkFISSxFQUdrQjtBQUFDLFFBQUEsSUFBSSxFQUFFLHFCQUFQO0FBQThCLFFBQUEsT0FBTyxFQUFFO0FBQXZDLE9BSGxCLENBQU47QUFJRDs7QUFDRCxRQUFHLElBQUUsS0FBSyxJQUFWLEVBQWdCO0FBQ2Q7QUFDQSxNQUFBLE9BQU8sQ0FBQyxLQUFELENBQVAsR0FBaUIsSUFBakI7QUFDRCxLQUhELE1BR08sSUFBRyxDQUFDLEdBQUcsQ0FBQyxTQUFKLENBQWMsSUFBZCxDQUFELElBQXNCLElBQUUsQ0FBQyxLQUFILENBQVMsZUFBVCxDQUF6QixFQUFvRDtBQUN6RDtBQUNBLE1BQUEsT0FBTyxDQUFDLElBQVIsQ0FBYSxvREFDWCw2QkFERixFQUNpQztBQUFDLFFBQUEsRUFBRSxFQUFGO0FBQUQsT0FEakM7O0FBRUEsVUFBRyxlQUFILEVBQW9CO0FBQ2xCLFFBQUEsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsSUFBdkIsRUFBNkIsZUFBN0I7QUFDRCxPQUZELE1BRU87QUFDTCxRQUFBLFNBQVMsQ0FBQyxRQUFWLFdBQTBCLElBQTFCO0FBQ0Q7O0FBQ0Q7QUFDRCxLQVZNLE1BVUEsSUFBRyxJQUFFLEtBQUssSUFBVixFQUFnQjtBQUNyQjtBQUNBLE1BQUEsSUFBRSxHQUFHLFVBQVUsQ0FDYixTQURhLEVBQ0YsSUFERSxFQUNFO0FBQUMsUUFBQSxLQUFLLEVBQUUsSUFBUjtBQUFjLFFBQUEsSUFBSSxFQUFFO0FBQXBCLE9BREYsRUFDOEIsUUFEOUIsRUFDd0MsT0FEeEMsRUFDaUQsT0FEakQsQ0FBZjs7QUFFQSxVQUFHLENBQUMsY0FBYyxDQUFDLElBQUQsQ0FBZixJQUF1QixDQUFDLEdBQUcsQ0FBQyxTQUFKLENBQWMsSUFBZCxDQUEzQixFQUE4QztBQUM1QyxjQUFNLElBQUksV0FBSixDQUNKLDZEQUNBLHNEQUZJLEVBR0osb0JBSEksRUFJSjtBQUFDLFVBQUEsSUFBSSxFQUFFLHFCQUFQO0FBQThCLFVBQUEsT0FBTyxFQUFFO0FBQXZDLFNBSkksQ0FBTjtBQUtELE9BVm9CLENBWXJCOzs7QUFDQSxVQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsY0FBWCxDQUFILEVBQStCO0FBQzdCLFlBQU0sV0FBVyxHQUFHLElBQUksR0FBSixDQUFRLE9BQVIsRUFBaUIsR0FBakIsQ0FBcUIsSUFBckIsRUFBMkIsSUFBM0IsQ0FBcEI7O0FBQ0EsWUFBTSxPQUFPLEdBQUcsVUFBVSxDQUN4QixTQUR3QixFQUNiLElBRGEsRUFDUDtBQUFDLFVBQUEsS0FBSyxFQUFFLElBQVI7QUFBYyxVQUFBLElBQUksRUFBRTtBQUFwQixTQURPLEVBRXhCLFFBRndCLEVBRWQsV0FGYyxFQUVELE9BRkMsQ0FBMUI7O0FBR0EsWUFBRyxPQUFPLEtBQUssSUFBZixFQUFtQjtBQUNqQixnQkFBTSxJQUFJLFdBQUosQ0FDSixzREFDQSx1QkFGSSxFQUdKLG9CQUhJLEVBSUo7QUFBQyxZQUFBLElBQUksRUFBRSxxQkFBUDtBQUE4QixZQUFBLE9BQU8sRUFBRTtBQUF2QyxXQUpJLENBQU47QUFLRDtBQUNGOztBQUVELE1BQUEsT0FBTyxDQUFDLEtBQUQsQ0FBUCxHQUFpQixJQUFqQixDQTNCcUIsQ0E0QnJCOztBQUNBLE1BQUEsT0FBTyxDQUFDLE9BQVIsR0FBbUIsVUFBVSxJQUMzQixDQUFDLE9BQU8sQ0FBQyxhQURRLElBRWpCLElBQUUsQ0FBQyxLQUFILENBQVMsZ0JBQVQsQ0FGRjtBQUdEO0FBQ0Y7O0FBRUQsTUFBRyxFQUFFLFNBQVMsT0FBWCxDQUFILEVBQXdCO0FBQ3RCO0FBQ0EsUUFBRyxPQUFPLENBQUMsYUFBWCxFQUEwQjtBQUN4QixVQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFZLENBQVosRUFBZSxLQUFmLENBQWY7O0FBQ0EsVUFBRyxRQUFRLENBQUMsY0FBVCxDQUF3QixNQUF4QixDQUFILEVBQW9DO0FBQ2xDO0FBQ0EsUUFBQSxHQUFHLENBQUMsb0JBQUosQ0FBeUI7QUFDdkIsVUFBQSxTQUFTLEVBQVQsU0FEdUI7QUFDWixVQUFBLFFBQVEsRUFBUixRQURZO0FBQ0YsVUFBQSxJQUFJLEVBQUUsTUFESjtBQUNZLFVBQUEsT0FBTyxFQUFQLE9BRFo7QUFDcUIsVUFBQSxPQUFPLEVBQVA7QUFEckIsU0FBekI7QUFHRDs7QUFFRCxVQUFHLFNBQVMsQ0FBQyxRQUFWLENBQW1CLEdBQW5CLENBQXVCLE1BQXZCLENBQUgsRUFBbUM7QUFDakM7QUFDQSxZQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFZLEtBQUssR0FBRyxDQUFwQixDQUFmO0FBQ0EsUUFBQSxPQUFPLENBQUMsS0FBRCxDQUFQLEdBQWlCLFNBQVMsQ0FBQyxRQUFWLENBQW1CLEdBQW5CLENBQXVCLE1BQXZCLEVBQStCLEtBQS9CLElBQXdDLE1BQXpEO0FBQ0QsT0FKRCxNQUlPO0FBQ0w7QUFDQSxRQUFBLE9BQU8sQ0FBQyxLQUFELENBQVAsR0FBaUIsSUFBakI7QUFDRDtBQUNGLEtBakJELE1BaUJPLElBQUcsSUFBSSxLQUFLLE9BQVosRUFBcUI7QUFDMUI7QUFDQSxNQUFBLE9BQU8sQ0FBQyxLQUFELENBQVAsR0FBaUIsSUFBakI7QUFDRCxLQUhNLE1BR0E7QUFDTDtBQUNBLFVBQUcsRUFBRSxZQUFZLFNBQWQsQ0FBSCxFQUE2QjtBQUMzQixjQUFNLElBQUksV0FBSixDQUNKLDREQURJLEVBRUosb0JBRkksRUFHSjtBQUFDLFVBQUEsSUFBSSxFQUFFLHFCQUFQO0FBQThCLFVBQUEsT0FBTyxFQUFFLFFBQXZDO0FBQWlELFVBQUEsSUFBSSxFQUFKO0FBQWpELFNBSEksQ0FBTjtBQUlELE9BUEksQ0FRTDs7O0FBQ0EsTUFBQSxPQUFPLENBQUMsS0FBRCxDQUFQLEdBQWlCLFNBQVMsQ0FBQyxRQUFELENBQVQsR0FBc0IsSUFBdkM7QUFDRDtBQUNGLEdBN09HLENBK09KOzs7QUFDQSxNQUFHLEtBQUssQ0FBQyxZQUFELENBQUwsS0FBd0IsSUFBeEIsSUFDQSxPQUFPLENBQUMsR0FBUixDQUFZLFlBQVosTUFBOEIsSUFBOUIsSUFBc0MsS0FBSyxDQUFDLFlBQUQsQ0FBTCxLQUF3QixLQURqRSxFQUN5RTtBQUN2RSxJQUFBLFNBQVMsYUFBVCxDQUFvQixJQUFwQixJQUE0QixJQUE1QjtBQUNBLElBQUEsT0FBTyxhQUFQLEdBQW9CLElBQXBCO0FBQ0QsR0FwUEcsQ0FzUEo7OztBQUNBLEVBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxJQUFaLEVBQWtCLElBQWxCOztBQUVBLE1BQUcsV0FBVyxLQUFkLEVBQXFCO0FBQ25CLFFBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxPQUFELENBQWhCOztBQUNBLFFBQUcsQ0FBQyxTQUFTLENBQUMsSUFBRCxDQUFiLEVBQXFCO0FBQ25CLFlBQU0sSUFBSSxXQUFKLENBQ0osbUVBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsUUFBQSxJQUFJLEVBQUUsc0JBQVA7QUFBK0IsUUFBQSxPQUFPLEVBQUU7QUFBeEMsT0FISSxDQUFOO0FBSUQ7O0FBRUQsUUFBSSxJQUFJLEtBQUssT0FBVCxJQUFvQixJQUFJLEtBQUssT0FBakMsRUFBMkM7QUFDekMsVUFBRyxHQUFHLENBQUMsY0FBSixDQUFtQixTQUFuQixFQUE4QixHQUE5QixDQUFILEVBQXVDO0FBQ3JDLGNBQU0sSUFBSSxXQUFKLENBQ0osNkVBQ0ksSUFESiw0QkFESSxFQUdKLG9CQUhJLEVBSUo7QUFBQyxVQUFBLElBQUksRUFBRSxzQkFBUDtBQUErQixVQUFBLE9BQU8sRUFBRTtBQUF4QyxTQUpJLENBQU47QUFLRDtBQUNGLEtBUkQsTUFRTyxJQUFHLElBQUksS0FBSyxLQUFULElBQWtCLElBQUksS0FBSyxRQUE5QixFQUF3QztBQUM3QztBQUNBLE1BQUEsSUFBSSxHQUFHLFVBQVUsQ0FDZixTQURlLEVBQ0osSUFESSxFQUNFO0FBQUMsUUFBQSxLQUFLLEVBQUUsSUFBUjtBQUFjLFFBQUEsSUFBSSxFQUFFO0FBQXBCLE9BREYsRUFDOEIsUUFEOUIsRUFDd0MsT0FEeEMsRUFFZixPQUZlLENBQWpCOztBQUdBLFVBQUcsQ0FBQyxjQUFjLENBQUMsSUFBRCxDQUFsQixFQUEwQjtBQUN4QixjQUFNLElBQUksV0FBSixDQUNKLGdFQUNBLGVBRkksRUFHSixvQkFISSxFQUlKO0FBQUMsVUFBQSxJQUFJLEVBQUUsc0JBQVA7QUFBK0IsVUFBQSxPQUFPLEVBQUU7QUFBeEMsU0FKSSxDQUFOO0FBS0Q7O0FBQ0QsVUFBRyxJQUFJLENBQUMsT0FBTCxDQUFhLElBQWIsTUFBdUIsQ0FBMUIsRUFBNkI7QUFDM0IsY0FBTSxJQUFJLFdBQUosQ0FDSixxRUFDQSw4QkFGSSxFQUdKLG9CQUhJLEVBSUo7QUFBQyxVQUFBLElBQUksRUFBRSxzQkFBUDtBQUErQixVQUFBLE9BQU8sRUFBRTtBQUF4QyxTQUpJLENBQU47QUFLRDtBQUNGLEtBcENrQixDQXNDbkI7OztBQUNBLElBQUEsT0FBTyxDQUFDLE9BQUQsQ0FBUCxHQUFtQixJQUFuQjtBQUNEOztBQUVELE1BQUcsZ0JBQWdCLEtBQW5CLEVBQTBCO0FBQ3hCO0FBQ0EsUUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxZQUFELENBQU4sQ0FBVCxHQUNoQixDQUFDLEtBQUssQ0FBQyxZQUFELENBQU4sQ0FEZ0IsR0FDUyxLQUFLLENBQUMsWUFBRCxDQUFMLElBQXVCLEVBRGxEO0FBRUEsUUFBTSxlQUFlLEdBQUcsQ0FBQyxPQUFELEVBQVUsTUFBVixFQUFrQixRQUFsQixFQUE0QixXQUE1QixDQUF4QjtBQUNBLFFBQUksT0FBTyxHQUFHLElBQWQ7QUFDQSxRQUFNLE1BQU0sR0FBRyxTQUFTLENBQUMsUUFBVixDQUFtQixNQUFuQixDQUFmLENBTndCLENBUXhCOztBQUNBLFFBQUcsR0FBRyxDQUFDLGNBQUosQ0FBbUIsU0FBbkIsRUFBOEIsR0FBOUIsQ0FBSCxFQUF1QztBQUNyQyxNQUFBLGVBQWUsQ0FBQyxJQUFoQixDQUFxQixRQUFyQixFQUErQixLQUEvQixFQUFzQyxPQUF0QyxFQURxQyxDQUdyQzs7QUFDQSxVQUFHLFNBQVMsQ0FBQyxRQUFWLENBQW1CLE9BQW5CLENBQUgsRUFBZ0M7QUFDOUIsWUFBRyxTQUFTLENBQUMsTUFBVixLQUFxQixDQUF4QixFQUEyQjtBQUN6QixnQkFBTSxJQUFJLFdBQUosQ0FDSixpRUFDQSxzQkFGSSxFQUdKLG9CQUhJLEVBSUo7QUFBQyxZQUFBLElBQUksRUFBRSwyQkFBUDtBQUFvQyxZQUFBLE9BQU8sRUFBRTtBQUE3QyxXQUpJLENBQU47QUFLRDtBQUNGLE9BUkQsTUFRTyxJQUFHLFNBQVMsQ0FBQyxRQUFWLENBQW1CLFFBQW5CLENBQUgsRUFBaUM7QUFDdEMsWUFBRyxTQUFTLENBQUMsSUFBVixDQUFlLFVBQUEsR0FBRztBQUFBLGlCQUNuQixHQUFHLEtBQUssUUFBUixJQUFvQixHQUFHLEtBQUssS0FBNUIsSUFBcUMsR0FBRyxLQUFLLFFBQTdDLElBQ0EsR0FBRyxLQUFLLE1BRlc7QUFBQSxTQUFsQixDQUFILEVBRW1CO0FBQ2pCLGdCQUFNLElBQUksV0FBSixDQUNKLGtFQUNBLHVEQUZJLEVBR0osb0JBSEksRUFJSjtBQUFDLFlBQUEsSUFBSSxFQUFFLDJCQUFQO0FBQW9DLFlBQUEsT0FBTyxFQUFFO0FBQTdDLFdBSkksQ0FBTjtBQUtEO0FBQ0YsT0FWTSxNQVVBO0FBQ0w7QUFDQSxRQUFBLE9BQU8sSUFBSSxTQUFTLENBQUMsTUFBVixLQUFxQixNQUFNLEdBQUcsQ0FBSCxHQUFPLENBQWxDLENBQVg7QUFDRDs7QUFFRCxVQUFHLFNBQVMsQ0FBQyxRQUFWLENBQW1CLE9BQW5CLENBQUgsRUFBZ0M7QUFDOUI7QUFDQTtBQUNBLFFBQUEsT0FBTyxDQUFDLE9BQUQsQ0FBUCxHQUFtQixPQUFPLENBQUMsT0FBRCxDQUFQLElBQW9CLEtBQXZDLENBSDhCLENBSzlCOztBQUNBLFlBQUcsQ0FBQyxDQUFDLEtBQUQsRUFBUSxRQUFSLEVBQWtCLFFBQWxCLENBQTJCLE9BQU8sQ0FBQyxPQUFELENBQWxDLENBQUosRUFBa0Q7QUFDaEQsZ0JBQU0sSUFBSSxXQUFKLENBQ0osbUVBQ0EsZ0JBRkksRUFHSixvQkFISSxFQUlKO0FBQUMsWUFBQSxJQUFJLEVBQUUsc0JBQVA7QUFBK0IsWUFBQSxPQUFPLEVBQUU7QUFBeEMsV0FKSSxDQUFOO0FBS0Q7QUFDRjtBQUNGLEtBekNELE1BeUNPO0FBQ0w7QUFDQTtBQUNBLE1BQUEsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxZQUFELENBQU4sQ0FBcEIsQ0FISyxDQUtMOztBQUNBLE1BQUEsT0FBTyxJQUFJLFNBQVMsQ0FBQyxNQUFWLElBQW9CLENBQS9CO0FBQ0QsS0F6RHVCLENBMkR4Qjs7O0FBQ0EsSUFBQSxPQUFPLElBQUksU0FBUyxDQUFDLEtBQVYsQ0FBZ0IsVUFBQSxDQUFDO0FBQUEsYUFBSSxlQUFlLENBQUMsUUFBaEIsQ0FBeUIsQ0FBekIsQ0FBSjtBQUFBLEtBQWpCLENBQVgsQ0E1RHdCLENBOER4Qjs7QUFDQSxJQUFBLE9BQU8sSUFBSSxFQUFFLE1BQU0sSUFBSSxTQUFTLENBQUMsUUFBVixDQUFtQixPQUFuQixDQUFaLENBQVg7O0FBRUEsUUFBRyxDQUFDLE9BQUosRUFBYTtBQUNYLFlBQU0sSUFBSSxXQUFKLENBQ0osK0RBQ0Esd0JBREEsR0FDMkIsZUFBZSxDQUFDLElBQWhCLENBQXFCLElBQXJCLENBRnZCLEVBR0osb0JBSEksRUFJSjtBQUFDLFFBQUEsSUFBSSxFQUFFLDJCQUFQO0FBQW9DLFFBQUEsT0FBTyxFQUFFO0FBQTdDLE9BSkksQ0FBTjtBQUtEOztBQUVELFFBQUcsT0FBTyxDQUFDLE9BQVIsSUFDRCxDQUFDLFNBQVMsQ0FBQyxLQUFWLENBQWdCLFVBQUEsQ0FBQztBQUFBLGFBQUksQ0FBQyxRQUFELEVBQVcsTUFBWCxFQUFtQixRQUFuQixDQUE0QixDQUE1QixDQUFKO0FBQUEsS0FBakIsQ0FESCxFQUN5RDtBQUN2RCxZQUFNLElBQUksV0FBSixDQUNKLHNFQUNBLHlDQUZJLEVBRXVDLG9CQUZ2QyxFQUdKO0FBQUMsUUFBQSxJQUFJLEVBQUUsMEJBQVA7QUFBbUMsUUFBQSxPQUFPLEVBQUU7QUFBNUMsT0FISSxDQUFOO0FBSUQsS0EvRXVCLENBaUZ4Qjs7O0FBQ0EsSUFBQSxPQUFPLENBQUMsWUFBRCxDQUFQLEdBQXdCLFNBQXhCO0FBQ0QsR0F0WEcsQ0F3WEo7OztBQUNBLE1BQUcsWUFBWSxLQUFmLEVBQXNCO0FBQ3BCLFFBQUcsRUFBRSxnQkFBZ0IsS0FBbEIsS0FBNEIsQ0FBQyxPQUFPLENBQUMsWUFBRCxDQUFQLENBQXNCLFFBQXRCLENBQStCLFFBQS9CLENBQWhDLEVBQTBFO0FBQ3hFLFlBQU0sSUFBSSxXQUFKLENBQ0osOEVBQ0ksS0FBSyxDQUFDLFFBQUQsQ0FEVCwwQkFDaUMsSUFEakMsUUFESSxFQUV1QyxvQkFGdkMsRUFHSjtBQUFDLFFBQUEsSUFBSSxFQUFFLHlCQUFQO0FBQWtDLFFBQUEsT0FBTyxFQUFFO0FBQTNDLE9BSEksQ0FBTjtBQUlEOztBQUNELFFBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFFBQUQsQ0FBTixDQUFWLElBQStCLEtBQUssQ0FBQyxRQUFELENBQUwsQ0FBZ0IsT0FBaEIsQ0FBd0IsR0FBeEIsTUFBaUMsQ0FBbkUsRUFBc0U7QUFDcEUsWUFBTSxJQUFJLFdBQUosQ0FDSix1RUFDSSxLQUFLLENBQUMsUUFBRCxDQURULDBCQUNpQyxJQURqQyxRQURJLEVBRXVDLG9CQUZ2QyxFQUdKO0FBQUMsUUFBQSxJQUFJLEVBQUUseUJBQVA7QUFBa0MsUUFBQSxPQUFPLEVBQUU7QUFBM0MsT0FISSxDQUFOO0FBSUQ7O0FBQ0QsSUFBQSxPQUFPLENBQUMsUUFBRCxDQUFQLEdBQW9CLEtBQUssQ0FBQyxRQUFELENBQXpCO0FBQ0QsR0F2WUcsQ0F5WUo7OztBQUNBLE1BQUcsY0FBYyxLQUFqQixFQUF3QjtBQUN0QixJQUFBLE9BQU8sQ0FBQyxVQUFELENBQVAsR0FBc0IsS0FBSyxDQUFDLFVBQUQsQ0FBM0I7QUFDRDs7QUFFRCxNQUFHLGVBQWUsS0FBZixJQUF3QixFQUFFLFdBQVcsS0FBYixDQUEzQixFQUFnRDtBQUM5QyxRQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsV0FBRCxDQUFwQjs7QUFDQSxRQUFHLFFBQVEsS0FBSyxJQUFiLElBQXFCLENBQUMsU0FBUyxDQUFDLFFBQUQsQ0FBbEMsRUFBOEM7QUFDNUMsWUFBTSxJQUFJLFdBQUosQ0FDSiw4REFDQSxtQkFGSSxFQUVpQixvQkFGakIsRUFHSjtBQUFDLFFBQUEsSUFBSSxFQUFFLDBCQUFQO0FBQW1DLFFBQUEsT0FBTyxFQUFFO0FBQTVDLE9BSEksQ0FBTjtBQUlELEtBUDZDLENBUzlDOzs7QUFDQSxRQUFHLFFBQVEsS0FBSyxJQUFoQixFQUFzQjtBQUNwQixNQUFBLFFBQVEsR0FBRyxRQUFRLENBQUMsV0FBVCxFQUFYO0FBQ0Q7O0FBQ0QsSUFBQSxPQUFPLENBQUMsV0FBRCxDQUFQLEdBQXVCLFFBQXZCO0FBQ0QsR0E1WkcsQ0E4Wko7OztBQUNBLE1BQUcsYUFBYSxLQUFoQixFQUF1QjtBQUNyQixRQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsTUFBWCxDQUFILEVBQXVCO0FBQ3JCLFlBQU0sSUFBSSxXQUFKLENBQ0oscUVBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsUUFBQSxJQUFJLEVBQUUseUJBQVA7QUFBa0MsUUFBQSxPQUFPLEVBQUU7QUFBM0MsT0FISSxDQUFOO0FBSUQ7O0FBQ0QsUUFBRyxHQUFHLENBQUMsU0FBSixDQUFjLE9BQU8sQ0FBQyxLQUFELENBQXJCLENBQUgsRUFBa0M7QUFDaEMsWUFBTSxJQUFJLFdBQUosQ0FDSiw4REFESSxFQUVKLG9CQUZJLEVBR0o7QUFBQyxRQUFBLElBQUksRUFBRSx5QkFBUDtBQUFrQyxRQUFBLE9BQU8sRUFBRTtBQUEzQyxPQUhJLENBQU47QUFJRDs7QUFDRCxRQUFHLE9BQU8sS0FBSyxDQUFDLFNBQUQsQ0FBWixLQUE0QixTQUEvQixFQUEwQztBQUN4QyxNQUFBLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLEtBQUssQ0FBQyxTQUFELENBQUwsS0FBcUIsSUFBdkM7QUFDRCxLQUZELE1BRU87QUFDTCxZQUFNLElBQUksV0FBSixDQUNKLG9FQURJLEVBRUosb0JBRkksRUFHSjtBQUFDLFFBQUEsSUFBSSxFQUFFLHVCQUFQO0FBQWdDLFFBQUEsT0FBTyxFQUFFO0FBQXpDLE9BSEksQ0FBTjtBQUlEO0FBQ0Y7O0FBRUQsTUFBRyxnQkFBZ0IsS0FBbkIsRUFBMEI7QUFDeEIsUUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLFlBQUQsQ0FBdkI7O0FBQ0EsUUFBRyxTQUFTLEtBQUssSUFBZCxJQUFzQixTQUFTLEtBQUssS0FBcEMsSUFBNkMsU0FBUyxLQUFLLEtBQTlELEVBQXFFO0FBQ25FLFlBQU0sSUFBSSxXQUFKLENBQ0osc0RBQ0Esd0JBRkksRUFHSixvQkFISSxFQUlKO0FBQUMsUUFBQSxJQUFJLEVBQUUsd0JBQVA7QUFBaUMsUUFBQSxPQUFPLEVBQUU7QUFBMUMsT0FKSSxDQUFOO0FBS0Q7O0FBQ0QsSUFBQSxPQUFPLENBQUMsWUFBRCxDQUFQLEdBQXdCLFNBQXhCO0FBQ0Q7O0FBRUQsTUFBRyxXQUFXLEtBQWQsRUFBcUI7QUFDbkIsUUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLE9BQUQsQ0FBbEI7O0FBQ0EsUUFBRyxDQUFDLFNBQVMsQ0FBQyxJQUFELENBQVYsSUFBcUIsSUFBSSxLQUFLLE9BQVQsSUFBb0IsSUFBSSxDQUFDLE9BQUwsQ0FBYSxHQUFiLE1BQXNCLENBQWxFLEVBQXNFO0FBQ3BFLFlBQU0sSUFBSSxXQUFKLENBQ0osMERBQ0EsbURBRkksRUFHSixvQkFISSxFQUlKO0FBQUMsUUFBQSxJQUFJLEVBQUUscUJBQVA7QUFBOEIsUUFBQSxPQUFPLEVBQUU7QUFBdkMsT0FKSSxDQUFOO0FBS0Q7O0FBQ0QsSUFBQSxPQUFPLENBQUMsT0FBRCxDQUFQLEdBQW1CLElBQW5CO0FBQ0QsR0E1Y0csQ0E4Y0o7OztBQUNBLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxLQUFELENBQWxCOztBQUNBLE1BQUcsRUFBRSxLQUFLLFVBQVAsSUFBcUIsRUFBRSxLQUFLLFdBQS9CLEVBQTRDO0FBQzFDLFVBQU0sSUFBSSxXQUFKLENBQ0osbUVBREksRUFFSixvQkFGSSxFQUVrQjtBQUFDLE1BQUEsSUFBSSxFQUFFLHVCQUFQO0FBQWdDLE1BQUEsT0FBTyxFQUFFO0FBQXpDLEtBRmxCLENBQU47QUFHRCxHQXBkRyxDQXNkSjs7O0FBQ0EsTUFBRyxlQUFlLElBQUksZUFBZSxhQUFsQyxJQUFnRCxDQUFDLGlCQUFwRCxFQUF1RTtBQUNyRTtBQUNBO0FBQ0EsSUFBQSxTQUFTLGFBQVQsQ0FBb0IsSUFBcEIsSUFBNEIsSUFBNUI7QUFDQSxJQUFBLE9BQU8sYUFBUCxHQUFvQixJQUFwQjs7QUFDQSxRQUFHLENBQUMsWUFBWSxDQUFDLGVBQUQsRUFBa0IsT0FBbEIsQ0FBaEIsRUFBNEM7QUFDMUMsVUFBTSxhQUFhLEdBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxhQUFwQixJQUFzQyxPQUE1RDs7QUFDQSxVQUFHLGFBQWEsS0FBSyxPQUFyQixFQUE4QjtBQUM1QixjQUFNLElBQUksV0FBSixDQUNKLDZEQURJLEVBRUosb0JBRkksRUFHSjtBQUFDLFVBQUEsSUFBSSxFQUFFLDZCQUFQO0FBQXNDLFVBQUEsT0FBTyxFQUFFLFFBQS9DO0FBQXlELFVBQUEsSUFBSSxFQUFKO0FBQXpELFNBSEksQ0FBTjtBQUlELE9BTEQsTUFLTyxJQUFHLGFBQWEsS0FBSyxNQUFyQixFQUE2QjtBQUNsQztBQUNBLFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYSxzQ0FBYixFQUFxRDtBQUFDLFVBQUEsSUFBSSxFQUFKO0FBQUQsU0FBckQ7QUFDQTtBQUNEOztBQUNELFlBQU0sSUFBSSxXQUFKLENBQ0osd0JBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsUUFBQSxJQUFJLEVBQUUsd0JBQVA7QUFBaUMsUUFBQSxPQUFPLEVBQUUsUUFBMUM7QUFBb0QsUUFBQSxJQUFJLEVBQUosSUFBcEQ7QUFDRSxRQUFBLGFBQWEsRUFBYjtBQURGLE9BSEksQ0FBTjtBQUtEO0FBQ0Y7QUFDRixDQXRmRDtBQXdmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsU0FBSixHQUFnQixVQUFDLFNBQUQsRUFBWSxLQUFaLEVBQW1CLFVBQW5CLEVBQStCLE9BQS9CLEVBQTJDO0FBQ3pELFNBQU8sVUFBVSxDQUFDLFNBQUQsRUFBWSxLQUFaLEVBQW1CLFVBQW5CLEVBQStCLFNBQS9CLEVBQTBDLFNBQTFDLEVBQ2YsT0FEZSxDQUFqQjtBQUVELENBSEQ7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsVUFBVCxDQUFvQixTQUFwQixFQUErQixLQUEvQixFQUFzQyxVQUF0QyxFQUFrRCxRQUFsRCxFQUE0RCxPQUE1RCxFQUFxRSxPQUFyRSxFQUE4RTtBQUM1RTtBQUNBLE1BQUcsS0FBSyxLQUFLLElBQVYsSUFBa0IsQ0FBQyxTQUFTLENBQUMsS0FBRCxDQUE1QixJQUF1QyxHQUFHLENBQUMsU0FBSixDQUFjLEtBQWQsQ0FBMUMsRUFBZ0U7QUFDOUQsV0FBTyxLQUFQO0FBQ0QsR0FKMkUsQ0FNNUU7OztBQUNBLE1BQUcsS0FBSyxDQUFDLEtBQU4sQ0FBWSxlQUFaLENBQUgsRUFBaUM7QUFDL0IsV0FBTyxJQUFQO0FBQ0QsR0FUMkUsQ0FXNUU7OztBQUNBLE1BQUcsUUFBUSxJQUFJLFFBQVEsQ0FBQyxjQUFULENBQXdCLEtBQXhCLENBQVosSUFDRCxPQUFPLENBQUMsR0FBUixDQUFZLEtBQVosTUFBdUIsSUFEekIsRUFDK0I7QUFDN0IsSUFBQSxHQUFHLENBQUMsb0JBQUosQ0FBeUI7QUFDdkIsTUFBQSxTQUFTLEVBQVQsU0FEdUI7QUFDWixNQUFBLFFBQVEsRUFBUixRQURZO0FBQ0YsTUFBQSxJQUFJLEVBQUUsS0FESjtBQUNXLE1BQUEsT0FBTyxFQUFQLE9BRFg7QUFDb0IsTUFBQSxPQUFPLEVBQVA7QUFEcEIsS0FBekI7QUFHRDs7QUFFRCxFQUFBLFVBQVUsR0FBRyxVQUFVLElBQUksRUFBM0I7O0FBQ0EsTUFBRyxVQUFVLENBQUMsS0FBZCxFQUFxQjtBQUNuQixRQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixLQUF2QixDQUFoQixDQURtQixDQUduQjs7QUFDQSxRQUFHLE9BQU8sS0FBSyxJQUFmLEVBQXFCO0FBQ25CLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUcsU0FBUyxDQUFDLE9BQUQsQ0FBVCxJQUFzQixTQUFTLE9BQWxDLEVBQTJDO0FBQ3pDO0FBQ0EsYUFBTyxPQUFPLENBQUMsS0FBRCxDQUFkO0FBQ0Q7QUFDRixHQWhDMkUsQ0FrQzVFOzs7QUFDQSxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTixDQUFjLEdBQWQsQ0FBZDs7QUFDQSxNQUFHLEtBQUssR0FBRyxDQUFYLEVBQWM7QUFDWixRQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTixDQUFhLENBQWIsRUFBZ0IsS0FBaEIsQ0FBZjtBQUNBLFFBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsS0FBSyxHQUFHLENBQXJCLENBQWYsQ0FGWSxDQUlaO0FBQ0E7O0FBQ0EsUUFBRyxNQUFNLEtBQUssR0FBWCxJQUFrQixNQUFNLENBQUMsT0FBUCxDQUFlLElBQWYsTUFBeUIsQ0FBOUMsRUFBaUQ7QUFDL0MsYUFBTyxLQUFQO0FBQ0QsS0FSVyxDQVVaOzs7QUFDQSxRQUFHLFFBQVEsSUFBSSxRQUFRLENBQUMsY0FBVCxDQUF3QixNQUF4QixDQUFmLEVBQWdEO0FBQzlDLE1BQUEsR0FBRyxDQUFDLG9CQUFKLENBQXlCO0FBQ3ZCLFFBQUEsU0FBUyxFQUFULFNBRHVCO0FBQ1osUUFBQSxRQUFRLEVBQVIsUUFEWTtBQUNGLFFBQUEsSUFBSSxFQUFFLE1BREo7QUFDWSxRQUFBLE9BQU8sRUFBUCxPQURaO0FBQ3FCLFFBQUEsT0FBTyxFQUFQO0FBRHJCLE9BQXpCO0FBR0QsS0FmVyxDQWlCWjs7O0FBQ0EsUUFBTSxRQUFPLEdBQUcsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsTUFBdkIsQ0FBaEI7O0FBQ0EsUUFBRyxRQUFPLElBQUksUUFBTyxDQUFDLE9BQXRCLEVBQStCO0FBQzdCLGFBQU8sUUFBTyxDQUFDLEtBQUQsQ0FBUCxHQUFpQixNQUF4QjtBQUNELEtBckJXLENBdUJaOzs7QUFDQSxRQUFHLGNBQWMsQ0FBQyxLQUFELENBQWpCLEVBQTBCO0FBQ3hCLGFBQU8sS0FBUDtBQUNEO0FBQ0YsR0EvRDJFLENBaUU1RTs7O0FBQ0EsTUFBRyxVQUFVLENBQUMsS0FBWCxJQUFvQixZQUFZLFNBQW5DLEVBQThDO0FBQzVDLFdBQU8sU0FBUyxDQUFDLFFBQUQsQ0FBVCxHQUFzQixLQUE3QjtBQUNELEdBcEUyRSxDQXNFNUU7OztBQUNBLE1BQUcsVUFBVSxDQUFDLElBQVgsSUFBbUIsV0FBVyxTQUFqQyxFQUE0QztBQUMxQyxRQUFHLFNBQVMsQ0FBQyxPQUFELENBQVosRUFBdUI7QUFDckI7QUFDQSxhQUFPLFdBQVcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLElBQVQsRUFBZSxTQUFTLENBQUMsT0FBRCxDQUF4QixDQUFaLEVBQWdELEtBQWhELENBQWxCO0FBQ0Q7QUFDRixHQUxELE1BS08sSUFBRyxVQUFVLENBQUMsSUFBZCxFQUFvQjtBQUN6QixXQUFPLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBVCxFQUFlLEtBQWYsQ0FBbEI7QUFDRDs7QUFFRCxTQUFPLEtBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxpQkFBSixHQUF3QixVQUFBLE9BQU8sRUFBSTtBQUNqQyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBTCxDQUFlO0FBQUMsSUFBQSxjQUFjLEVBQUUsT0FBTyxDQUFDO0FBQXpCLEdBQWYsQ0FBWjtBQUNBLE1BQU0sTUFBTSxHQUFHLHFCQUFxQixDQUFDLEdBQXRCLENBQTBCLEdBQTFCLENBQWY7O0FBQ0EsTUFBRyxNQUFILEVBQVc7QUFDVCxXQUFPLE1BQVA7QUFDRDs7QUFFRCxNQUFNLGNBQWMsR0FBRztBQUNyQixJQUFBLGNBQWMsRUFBRSxPQUFPLENBQUMsY0FESDtBQUVyQixJQUFBLFFBQVEsRUFBRSxJQUFJLEdBQUosRUFGVztBQUdyQixJQUFBLE9BQU8sRUFBRSxJQUhZO0FBSXJCLElBQUEsVUFBVSxFQUFFLHFCQUpTO0FBS3JCLElBQUEsS0FBSyxFQUFFLG1CQUxjO0FBTXJCLElBQUEsdUJBQXVCLEVBQUUsd0JBTko7QUFPckIsaUJBQVc7QUFQVSxHQUF2QixDQVBpQyxDQWdCakM7O0FBQ0EsTUFBRyxxQkFBcUIsQ0FBQyxJQUF0QixLQUErQiw4QkFBbEMsRUFBa0U7QUFDaEU7QUFDQTtBQUNBLElBQUEscUJBQXFCLENBQUMsS0FBdEI7QUFDRDs7QUFDRCxFQUFBLHFCQUFxQixDQUFDLEdBQXRCLENBQTBCLEdBQTFCLEVBQStCLGNBQS9CO0FBQ0EsU0FBTyxjQUFQO0FBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNFLFdBQVMscUJBQVQsR0FBaUM7QUFDL0IsUUFBTSxTQUFTLEdBQUcsSUFBbEIsQ0FEK0IsQ0FHL0I7O0FBQ0EsUUFBRyxTQUFTLENBQUMsT0FBYixFQUFzQjtBQUNwQixhQUFPLFNBQVMsQ0FBQyxPQUFqQjtBQUNEOztBQUNELFFBQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFWLEdBQW9CLEVBQXBDLENBUCtCLENBUy9COztBQUNBLFFBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxZQUFWLEdBQXlCLEVBQTlDO0FBQ0EsUUFBTSxXQUFXLEdBQUcsRUFBcEIsQ0FYK0IsQ0FhL0I7O0FBQ0EsUUFBTSxlQUFlLEdBQUcsQ0FBQyxTQUFTLENBQUMsV0FBRCxDQUFULElBQTBCLE9BQTNCLEVBQW9DLFdBQXBDLEVBQXhCLENBZCtCLENBZ0IvQjs7QUFDQSxRQUFNLGdCQUFnQixHQUFHLFNBQVMsQ0FBQyxZQUFELENBQWxDLENBakIrQixDQW1CL0I7QUFDQTs7QUFDQSxRQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsUUFBM0I7QUFDQSxRQUFNLEtBQUssR0FBRyxvQ0FBSSxRQUFRLENBQUMsSUFBVCxFQUFKLEVBQXFCLElBQXJCLENBQTBCLHFCQUExQixDQUFkOztBQXRCK0IsZ0RBdUJiLEtBdkJhO0FBQUE7O0FBQUE7QUF1Qi9CLDZEQUF5QjtBQUFBLFlBQWYsSUFBZTtBQUN2QixZQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsR0FBVCxDQUFhLElBQWIsQ0FBaEI7O0FBQ0EsWUFBRyxPQUFPLEtBQUssSUFBZixFQUFxQjtBQUNuQjtBQUNEOztBQUVELFlBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxZQUFELENBQVAsSUFBeUIsT0FBekM7QUFDQSxRQUFBLFNBQVMsR0FBRyxHQUFHLE1BQUgsQ0FBVSxTQUFWLEVBQXFCLElBQXJCLEdBQTRCLElBQTVCLENBQWlDLEVBQWpDLENBQVo7O0FBRUEsWUFBRyxPQUFPLENBQUMsS0FBRCxDQUFQLEtBQW1CLElBQXRCLEVBQTRCO0FBQzFCO0FBQ0QsU0FYc0IsQ0FZdkI7OztBQUNBLFlBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBRCxDQUFSLENBQXBCOztBQWJ1QixvREFjTixHQWRNO0FBQUE7O0FBQUE7QUFjdkIsaUVBQXNCO0FBQUEsZ0JBQVosR0FBWTtBQUNwQixnQkFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLEdBQUQsQ0FBbkI7QUFDQSxnQkFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLFNBQUosQ0FBYyxHQUFkLENBQWxCOztBQUVBLGdCQUFHLENBQUMsS0FBSixFQUFXO0FBQ1Q7QUFDQSxjQUFBLE9BQU8sQ0FBQyxHQUFELENBQVAsR0FBZSxLQUFLLEdBQUcsRUFBdkI7O0FBRUEsa0JBQUcsQ0FBQyxTQUFELElBQWMsQ0FBQyxPQUFPLENBQUMsYUFBMUIsRUFBeUM7QUFDdkM7QUFDQSxnQkFBQSxXQUFXLENBQUMsR0FBRCxDQUFYLEdBQW1CLENBQUMsSUFBRCxDQUFuQjtBQUNBLG9CQUFNLGNBQWMsR0FBRztBQUFDLGtCQUFBLEdBQUcsRUFBSCxHQUFEO0FBQU0sa0JBQUEsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFEO0FBQXhCLGlCQUF2Qjs7QUFDQSxvQkFBRyxHQUFHLENBQUMsQ0FBRCxDQUFILElBQVUsWUFBYixFQUEyQjtBQUN6QixrQkFBQSxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUQsQ0FBSixDQUFaLENBQXFCLElBQXJCLENBQTBCLGNBQTFCO0FBQ0QsaUJBRkQsTUFFTztBQUNMLGtCQUFBLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBRCxDQUFKLENBQVosR0FBdUIsQ0FBQyxjQUFELENBQXZCO0FBQ0Q7QUFDRjtBQUNGLGFBZEQsTUFjTyxJQUFHLENBQUMsU0FBRCxJQUFjLENBQUMsT0FBTyxDQUFDLGFBQTFCLEVBQXlDO0FBQzlDO0FBQ0EsY0FBQSxXQUFXLENBQUMsR0FBRCxDQUFYLENBQWlCLElBQWpCLENBQXNCLElBQXRCO0FBQ0QsYUFyQm1CLENBdUJwQjs7O0FBQ0EsZ0JBQUcsQ0FBQyxLQUFLLENBQUMsU0FBRCxDQUFULEVBQXNCO0FBQ3BCLGNBQUEsS0FBSyxDQUFDLFNBQUQsQ0FBTCxHQUFtQjtBQUNqQiw2QkFBYSxFQURJO0FBRWpCLHlCQUFTLEVBRlE7QUFHakIsd0JBQVE7QUFIUyxlQUFuQjtBQUtEOztBQUNELFlBQUEsS0FBSyxHQUFHLEtBQUssQ0FBQyxTQUFELENBQWI7O0FBQ0EsWUFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFDLE1BQUQsQ0FBWixFQUFzQixPQUF0QixDQUFqQjs7QUFFQSxnQkFBRyxPQUFPLENBQUMsT0FBWCxFQUFvQjtBQUNsQjtBQUNBLGNBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBQyxPQUFELENBQVosRUFBdUIsVUFBdkIsQ0FBakI7QUFDRCxhQUhELE1BR08sSUFBRyxPQUFPLENBQUMsT0FBRCxDQUFQLEtBQXFCLE9BQXhCLEVBQWlDO0FBQ3RDLGNBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBQyxNQUFELENBQVosRUFBc0IsT0FBdEIsQ0FBakI7O0FBQ0EsY0FBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFDLFdBQUQsQ0FBWixFQUEyQixPQUEzQixDQUFqQjs7QUFDQSxjQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxLQUFLLENBQUMsT0FBRCxDQUFaLEVBQXVCLE9BQXZCLENBQWpCO0FBQ0QsYUFKTSxNQUlBLElBQUcsV0FBVyxPQUFkLEVBQXVCO0FBQzVCO0FBQ0EsY0FBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFDLE9BQUQsQ0FBWixFQUF1QixPQUFPLENBQUMsT0FBRCxDQUE5QixDQUFqQjtBQUNELGFBSE0sTUFHQSxJQUFHLGVBQWUsT0FBZixJQUEwQixnQkFBZ0IsT0FBN0MsRUFBc0Q7QUFDM0Q7QUFDQSxrQkFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFdBQUQsQ0FBeEI7QUFDQSxrQkFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFlBQUQsQ0FBekI7O0FBQ0Esa0JBQUcsUUFBUSxJQUFJLFNBQWYsRUFBMEI7QUFDeEIsZ0JBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBQyxXQUFELENBQVosRUFDZixVQUFHLFFBQUgsY0FBZSxTQUFmLEVBQTJCLFdBQTNCLEVBRGUsQ0FBakI7QUFFRCxlQUhELE1BR08sSUFBRyxRQUFILEVBQWE7QUFDbEIsZ0JBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBQyxXQUFELENBQVosRUFBMkIsUUFBUSxDQUFDLFdBQVQsRUFBM0IsQ0FBakI7QUFDRCxlQUZNLE1BRUEsSUFBRyxTQUFILEVBQWM7QUFDbkIsZ0JBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBQyxXQUFELENBQVosYUFBK0IsU0FBL0IsRUFBakI7QUFDRCxlQUZNLE1BRUE7QUFDTCxnQkFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFDLFdBQUQsQ0FBWixFQUEyQixPQUEzQixDQUFqQjtBQUNEO0FBQ0YsYUFkTSxNQWNBLElBQUcsZUFBZSxPQUFsQixFQUEyQjtBQUNoQyxjQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxLQUFLLENBQUMsV0FBRCxDQUFaLEVBQ2YsQ0FBQyxPQUFPLENBQUMsV0FBRCxDQUFQLElBQXdCLE9BQXpCLEVBQWtDLFdBQWxDLEVBRGUsQ0FBakI7QUFFRCxhQUhNLE1BR0EsSUFBRyxnQkFBZ0IsT0FBbkIsRUFBNEI7QUFDakMsa0JBQUcsT0FBTyxDQUFDLFlBQUQsQ0FBVixFQUEwQjtBQUN4QixnQkFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFDLFdBQUQsQ0FBWixhQUNYLE9BQU8sQ0FBQyxZQUFELENBREksRUFBakI7QUFFRCxlQUhELE1BR087QUFDTCxnQkFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFDLFdBQUQsQ0FBWixFQUEyQixPQUEzQixDQUFqQjtBQUNEO0FBQ0YsYUFQTSxNQU9BLElBQUcsZ0JBQUgsRUFBcUI7QUFDMUIsY0FBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFDLFdBQUQsQ0FBWixhQUErQixnQkFBL0IsRUFBakI7O0FBQ0EsY0FBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFDLFdBQUQsQ0FBWixFQUEyQixPQUEzQixDQUFqQjs7QUFDQSxjQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxLQUFLLENBQUMsT0FBRCxDQUFaLEVBQXVCLE9BQXZCLENBQWpCO0FBQ0QsYUFKTSxNQUlBO0FBQ0w7QUFDQSxjQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTyxLQUFLLENBQUMsV0FBRCxDQUFaLEVBQTJCLGVBQTNCLENBQWpCOztBQUNBLGNBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLEtBQUssQ0FBQyxXQUFELENBQVosRUFBMkIsT0FBM0IsQ0FBakI7O0FBQ0EsY0FBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sS0FBSyxDQUFDLE9BQUQsQ0FBWixFQUF1QixPQUF2QixDQUFqQjtBQUNEO0FBQ0Y7QUE1RnNCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUE2RnhCLE9BcEg4QixDQXNIL0I7O0FBdEgrQjtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXVIL0IsU0FBSSxJQUFNLEtBQVYsSUFBaUIsWUFBakIsRUFBK0I7QUFDN0IsTUFBQSxZQUFZLENBQUMsWUFBRCxFQUFlLEtBQWYsRUFBb0IsQ0FBcEIsQ0FBWjtBQUNEOztBQUVELFdBQU8sT0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsV0FBUyxZQUFULENBQXNCLE1BQXRCLEVBQThCLEdBQTlCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3RDLFFBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFELENBQXRCO0FBQ0EsUUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLEdBQUQsQ0FBTixHQUFjLEVBQTNCO0FBRUEsUUFBSSxHQUFKO0FBQ0EsUUFBSSxNQUFKOztBQUxzQyxnREFNbkIsT0FObUI7QUFBQTs7QUFBQTtBQU10Qyw2REFBNEI7QUFBQSxZQUFsQixLQUFrQjtBQUMxQixRQUFBLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBWjs7QUFDQSxZQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBZCxFQUFzQjtBQUNwQixVQUFBLE1BQU0sR0FBRyxFQUFUO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsVUFBQSxNQUFNLEdBQUcsR0FBRyxDQUFDLEdBQUQsQ0FBWjtBQUNEOztBQUNELFlBQUcsTUFBTSxJQUFJLElBQWIsRUFBbUI7QUFDakIsVUFBQSxJQUFJLENBQUMsTUFBRCxDQUFKLENBQWEsSUFBYixDQUFrQixLQUFsQjtBQUNELFNBRkQsTUFFTztBQUNMLFVBQUEsSUFBSSxDQUFDLE1BQUQsQ0FBSixHQUFlLENBQUMsS0FBRCxDQUFmO0FBQ0Q7QUFDRjtBQWxCcUM7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFvQnRDLFNBQUksSUFBTSxLQUFWLElBQWlCLElBQWpCLEVBQXVCO0FBQ3JCLFVBQUcsS0FBRyxLQUFLLEVBQVgsRUFBZTtBQUNiO0FBQ0Q7O0FBQ0QsTUFBQSxZQUFZLENBQUMsSUFBRCxFQUFPLEtBQVAsRUFBWSxHQUFHLEdBQUcsQ0FBbEIsQ0FBWjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsV0FBUyxpQkFBVCxDQUEyQixJQUEzQixFQUFpQyxLQUFqQyxFQUF3QyxtQkFBeEMsRUFBNkQ7QUFDM0QsUUFBRyxDQUFDLEtBQUssQ0FBQyxjQUFOLENBQXFCLG1CQUFyQixDQUFKLEVBQStDO0FBQzdDLE1BQUEsS0FBSyxDQUFDLG1CQUFELENBQUwsR0FBNkIsSUFBN0I7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsV0FBUyxtQkFBVCxHQUErQjtBQUM3QixRQUFNLEtBQUssR0FBRyxFQUFkO0FBQ0EsSUFBQSxLQUFLLENBQUMsUUFBTixHQUFpQixJQUFJLENBQUMsS0FBTCxDQUFXLEtBQUssUUFBaEIsQ0FBakI7QUFDQSxJQUFBLEtBQUssQ0FBQyxLQUFOLEdBQWMsS0FBSyxLQUFuQjtBQUNBLElBQUEsS0FBSyxDQUFDLE9BQU4sR0FBZ0IsSUFBaEI7QUFDQSxJQUFBLEtBQUssQ0FBQyxVQUFOLEdBQW1CLEtBQUssVUFBeEI7QUFDQSxJQUFBLEtBQUssYUFBTCxHQUFrQixJQUFJLENBQUMsS0FBTCxDQUFXLGlCQUFYLENBQWxCOztBQUNBLFFBQUcsS0FBSyxlQUFSLEVBQXlCO0FBQ3ZCLE1BQUEsS0FBSyxDQUFDLGVBQU4sR0FBd0IsS0FBSyxlQUFMLENBQXFCLEtBQXJCLEVBQXhCO0FBQ0Q7O0FBQ0QsSUFBQSxLQUFLLENBQUMsdUJBQU4sR0FBZ0MsS0FBSyx1QkFBckM7O0FBQ0EsUUFBRyxXQUFXLElBQWQsRUFBb0I7QUFDbEIsTUFBQSxLQUFLLENBQUMsT0FBRCxDQUFMLEdBQWlCLEtBQUssT0FBTCxDQUFqQjtBQUNEOztBQUNELFFBQUcsZUFBZSxJQUFsQixFQUF3QjtBQUN0QixNQUFBLEtBQUssQ0FBQyxXQUFELENBQUwsR0FBcUIsS0FBSyxXQUFMLENBQXJCO0FBQ0Q7O0FBQ0QsUUFBRyxZQUFZLElBQWYsRUFBcUI7QUFDbkIsTUFBQSxLQUFLLENBQUMsUUFBRCxDQUFMLEdBQWtCLEtBQUssUUFBTCxDQUFsQjtBQUNEOztBQUNELFdBQU8sS0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7OztBQUNFLFdBQVMsd0JBQVQsR0FBb0M7QUFDbEMsUUFBRyxDQUFDLEtBQUssZUFBVCxFQUEwQjtBQUN4QixhQUFPLElBQVA7QUFDRDs7QUFDRCxXQUFPLEtBQUssZUFBTCxDQUFxQixLQUFyQixFQUFQO0FBQ0Q7QUFDRixDQXBQRDtBQXNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsZUFBSixHQUFzQixVQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsSUFBWCxFQUFvQjtBQUN4QztBQUNBLE1BQUcsR0FBRyxLQUFLLElBQVgsRUFBaUI7QUFDZixRQUFHLElBQUksS0FBSyxVQUFaLEVBQXdCO0FBQ3RCLGFBQU8sU0FBUDtBQUNEOztBQUNELFdBQU8sSUFBUDtBQUNELEdBUHVDLENBU3hDOzs7QUFDQSxNQUFHLEdBQUcsQ0FBQyxRQUFKLENBQWEsR0FBYixDQUFpQixHQUFqQixDQUFILEVBQTBCO0FBQ3hCLFFBQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxRQUFKLENBQWEsR0FBYixDQUFpQixHQUFqQixDQUFkOztBQUVBLFFBQUcsWUFBWSxDQUFDLElBQUQsQ0FBZixFQUF1QjtBQUNyQjtBQUNBLGFBQU8sS0FBUDtBQUNEOztBQUNELFFBQUcsS0FBSyxDQUFDLGNBQU4sQ0FBcUIsSUFBckIsQ0FBSCxFQUErQjtBQUM3QjtBQUNBLGFBQU8sS0FBSyxDQUFDLElBQUQsQ0FBWjtBQUNEO0FBQ0YsR0FyQnVDLENBdUJ4Qzs7O0FBQ0EsTUFBRyxJQUFJLEtBQUssV0FBVCxJQUF3QixJQUFJLElBQUksR0FBbkMsRUFBd0M7QUFDdEMsV0FBTyxHQUFHLENBQUMsSUFBRCxDQUFWO0FBQ0QsR0ExQnVDLENBNEJ4Qzs7O0FBQ0EsTUFBRyxJQUFJLEtBQUssWUFBVCxJQUF5QixJQUFJLElBQUksR0FBcEMsRUFBeUM7QUFDdkMsV0FBTyxHQUFHLENBQUMsSUFBRCxDQUFWO0FBQ0Q7O0FBRUQsTUFBRyxJQUFJLEtBQUssVUFBWixFQUF3QjtBQUN0QixXQUFPLFNBQVA7QUFDRDs7QUFDRCxTQUFPLElBQVA7QUFDRCxDQXJDRDtBQXVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsY0FBSixHQUFxQixVQUFDLFNBQUQsRUFBWSxPQUFaLEVBQXdCO0FBQzNDLE1BQUcsT0FBTyxDQUFDLFFBQVIsTUFBc0IsS0FBekIsRUFBZ0M7QUFDOUIsV0FBTyxDQUFDLFNBQVMsQ0FBQyxjQUFYLElBQ0wsU0FBUyxDQUFDLGNBQVYsSUFBNEIsYUFBYSxPQUFPLENBQUMsUUFBUixFQUQzQztBQUVELEdBSEQsTUFHTztBQUNMLFdBQU8sU0FBUyxDQUFDLGNBQVYsS0FBNkIsYUFBcEM7QUFDRDtBQUNGLENBUEQ7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFNBQUosR0FBZ0IsVUFBQSxDQUFDLEVBQUk7QUFDbkIsTUFBRyxDQUFDLFNBQVMsQ0FBQyxDQUFELENBQVYsSUFBaUIsQ0FBQyxDQUFDLENBQUQsQ0FBRCxLQUFTLEdBQTdCLEVBQWtDO0FBQ2hDLFdBQU8sS0FBUDtBQUNEOztBQUNELFVBQU8sQ0FBUDtBQUNFLFNBQUssT0FBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssVUFBTDtBQUNBLFNBQUssVUFBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssV0FBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssS0FBTDtBQUNBLFNBQUssV0FBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssV0FBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssY0FBTDtBQUNBLFNBQUssU0FBTDtBQUNBLFNBQUssV0FBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssYUFBTDtBQUNBLFNBQUssVUFBTDtBQUNBLFNBQUssTUFBTDtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssVUFBTDtBQUNBLFNBQUssUUFBTDtBQUNFLGFBQU8sSUFBUDtBQTVCSjs7QUE4QkEsU0FBTyxLQUFQO0FBQ0QsQ0FuQ0Q7O0FBcUNBLFNBQVMsWUFBVCxDQUFzQixFQUF0QixFQUEwQixFQUExQixFQUE4QjtBQUM1QjtBQUNBLE1BQUksRUFBRSxFQUFFLElBQUkseUJBQU8sRUFBUCxNQUFjLFFBQXRCLENBQUQsSUFDQyxFQUFFLEVBQUUsSUFBSSx5QkFBTyxFQUFQLE1BQWMsUUFBdEIsQ0FESixFQUNzQztBQUNwQyxXQUFPLEVBQUUsS0FBSyxFQUFkO0FBQ0QsR0FMMkIsQ0FNNUI7OztBQUNBLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFOLENBQWMsRUFBZCxDQUFoQjs7QUFDQSxNQUFHLE9BQU8sS0FBSyxLQUFLLENBQUMsT0FBTixDQUFjLEVBQWQsQ0FBZixFQUFrQztBQUNoQyxXQUFPLEtBQVA7QUFDRDs7QUFDRCxNQUFHLE9BQUgsRUFBWTtBQUNWLFFBQUcsRUFBRSxDQUFDLE1BQUgsS0FBYyxFQUFFLENBQUMsTUFBcEIsRUFBNEI7QUFDMUIsYUFBTyxLQUFQO0FBQ0Q7O0FBQ0QsU0FBSSxJQUFJLENBQUMsR0FBRyxDQUFaLEVBQWUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUF0QixFQUE4QixFQUFFLENBQWhDLEVBQW1DO0FBQ2pDLFVBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUQsQ0FBSCxFQUFRLEVBQUUsQ0FBQyxDQUFELENBQVYsQ0FBaEIsRUFBZ0M7QUFDOUIsZUFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPLElBQVA7QUFDRCxHQXJCMkIsQ0FzQjVCOzs7QUFDQSxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLEVBQVosQ0FBWjtBQUNBLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksRUFBWixDQUFaOztBQUNBLE1BQUcsR0FBRyxDQUFDLE1BQUosS0FBZSxHQUFHLENBQUMsTUFBdEIsRUFBOEI7QUFDNUIsV0FBTyxLQUFQO0FBQ0Q7O0FBQ0QsT0FBSSxJQUFNLEVBQVYsSUFBZ0IsRUFBaEIsRUFBb0I7QUFDbEIsUUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUQsQ0FBWDtBQUNBLFFBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFELENBQVgsQ0FGa0IsQ0FHbEI7O0FBQ0EsUUFBRyxFQUFFLEtBQUssWUFBVixFQUF3QjtBQUN0QixVQUFHLEtBQUssQ0FBQyxPQUFOLENBQWMsRUFBZCxLQUFxQixLQUFLLENBQUMsT0FBTixDQUFjLEVBQWQsQ0FBeEIsRUFBMkM7QUFDekMsUUFBQSxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUgsR0FBVyxJQUFYLEVBQUw7QUFDQSxRQUFBLEVBQUUsR0FBRyxFQUFFLENBQUMsS0FBSCxHQUFXLElBQVgsRUFBTDtBQUNEO0FBQ0Y7O0FBQ0QsUUFBRyxDQUFDLFlBQVksQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFoQixFQUEwQjtBQUN4QixhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUNELFNBQU8sSUFBUDtBQUNEOzs7QUM3N0NEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztlQUV3QyxPQUFPLENBQUMsU0FBRCxDO0lBQXhDLGUsWUFBQSxlO0lBQWlCLFksWUFBQSxZOztnQkFDTSxPQUFPLENBQUMsY0FBRCxDO0lBQTlCLG1CLGFBQUEsbUI7O0FBQ1AsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLGdCQUFELENBQTNCOztBQUNBLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxpQkFBRCxDQUE1Qjs7Z0JBQ3NCLE9BQU8sQ0FBQyxRQUFELEM7SUFBdEIsVyxhQUFBLFc7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsWUFNd0M7QUFBQSxpRkFBckQ7QUFBQyxJQUFBLFNBQVMsRUFBRSxJQUFaO0FBQWtCLElBQUEsWUFBWSxFQUFFLENBQUMsQ0FBakM7QUFBb0MsSUFBQSxPQUFPLEVBQUU7QUFBN0MsR0FBcUQ7QUFBQSxNQUx2RCxNQUt1RCxRQUx2RCxNQUt1RDtBQUFBLDRCQUp2RCxTQUl1RDtBQUFBLE1BSnZELFNBSXVELCtCQUozQyxJQUkyQztBQUFBLCtCQUh2RCxZQUd1RDtBQUFBLE1BSHZELFlBR3VELGtDQUh4QyxDQUFDLENBR3VDO0FBQUEsTUFGdkQsT0FFdUQsUUFGdkQsT0FFdUQ7QUFBQSwwQkFEdkQsT0FDdUQ7QUFBQSxNQUR2RCxPQUN1RCw2QkFEN0MsRUFDNkM7O0FBQ3ZELEVBQUEsT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFELENBQXRCLENBRHVELENBRXZEOztBQUNBLEVBQUEsT0FBTyxHQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsU0FBRCxDQUE1Qjs7QUFDQSxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFFQSxNQUFNLEtBQUssR0FBRyxJQUFJLFlBQUosRUFBZDtBQUNBLFNBQU8sS0FBSyxDQUFDLFVBQU4sQ0FBaUIsVUFBUyxHQUFULEVBQWM7QUFDcEMsV0FBTyxZQUFZLENBQUMsR0FBRCxFQUFNLEVBQU4sQ0FBbkI7QUFDRCxHQUZNLENBQVA7O0FBUHVELFdBV3hDLFlBWHdDO0FBQUE7QUFBQTs7QUFBQTtBQUFBLGtHQVd2RCxpQkFBNEIsR0FBNUIsRUFBaUMsU0FBakM7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUNLLEdBQUcsQ0FBQyxPQUFKLENBQVksT0FBWixNQUF5QixDQUF6QixJQUE4QixHQUFHLENBQUMsT0FBSixDQUFZLFFBQVosTUFBMEIsQ0FEN0Q7QUFBQTtBQUFBO0FBQUE7O0FBQUEsb0JBRVUsSUFBSSxXQUFKLENBQ0oscUVBQ0EsWUFGSSxFQUdKLG1CQUhJLEVBR2lCO0FBQUMsZ0JBQUEsSUFBSSxFQUFFLHlCQUFQO0FBQWtDLGdCQUFBLEdBQUcsRUFBSDtBQUFsQyxlQUhqQixDQUZWOztBQUFBO0FBQUEsb0JBT0ssTUFBTSxJQUFJLEdBQUcsQ0FBQyxPQUFKLENBQVksT0FBWixNQUF5QixDQVB4QztBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFRVSxJQUFJLFdBQUosQ0FDSiwrREFDQSxtQ0FGSSxFQUdKLG1CQUhJLEVBR2lCO0FBQUMsZ0JBQUEsSUFBSSxFQUFFLHlCQUFQO0FBQWtDLGdCQUFBLEdBQUcsRUFBSDtBQUFsQyxlQUhqQixDQVJWOztBQUFBO0FBYUU7QUFDSSxjQUFBLEdBZE4sR0FjWSxJQWRaLEVBY2lCOztBQWRqQixvQkFlSyxHQUFHLEtBQUssSUFmYjtBQUFBO0FBQUE7QUFBQTs7QUFBQSwrQ0FnQlcsR0FoQlg7O0FBQUE7QUFvQk0sY0FBQSxTQXBCTixHQW9Ca0IsSUFwQmxCO0FBQUE7QUFBQTtBQUFBLHFCQXNCbUIsUUFBUSxDQUFDLE9BQUQsRUFBVTtBQUMvQixnQkFBQSxHQUFHLEVBQUgsR0FEK0I7QUFFL0IsZ0JBQUEsT0FBTyxFQUFQLE9BRitCO0FBRy9CLGdCQUFBLFNBQVMsRUFBVCxTQUgrQjtBQUkvQixnQkFBQSxjQUFjLEVBQUU7QUFKZSxlQUFWLENBdEIzQjs7QUFBQTtBQXNCSSxjQUFBLE1BdEJKO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkE2QlUsSUFBSSxXQUFKLENBQ0osbURBREksRUFFSiwwQkFGSSxFQUdKO0FBQUMsZ0JBQUEsSUFBSSxFQUFFLHlCQUFQO0FBQWtDLGdCQUFBLEdBQUcsRUFBSCxHQUFsQztBQUF1QyxnQkFBQSxLQUFLO0FBQTVDLGVBSEksQ0E3QlY7O0FBQUE7QUFBQSx3QkFtQ3NCLE1BbkN0QixFQW1DUyxHQW5DVCxXQW1DUyxHQW5DVCxFQW1DYyxJQW5DZCxXQW1DYyxJQW5DZDtBQXFDRSxjQUFBLEdBQUcsR0FBRztBQUFDLGdCQUFBLFVBQVUsRUFBRSxJQUFiO0FBQW1CLGdCQUFBLFdBQVcsRUFBRSxHQUFoQztBQUFxQyxnQkFBQSxRQUFRLEVBQUUsSUFBSSxJQUFJO0FBQXZELGVBQU4sQ0FyQ0YsQ0F1Q0U7O0FBQ00sY0FBQSxVQXhDUixHQXdDcUIsSUFBSSxDQUFDLFlBQUwsQ0FBa0IsR0FBRyxDQUFDLFVBQXRCLENBeENyQjs7QUFBQSxvQkF5Q0ssR0FBRyxDQUFDLFVBQUosSUFBa0IsR0F6Q3ZCO0FBQUE7QUFBQTtBQUFBOztBQUFBLG9CQTBDVSxJQUFJLFdBQUosaUJBQ0ksR0FESiwyQ0FDdUMsVUFEdkMsR0FFSixtQkFGSSxFQUVpQjtBQUNuQixnQkFBQSxJQUFJLEVBQUUseUJBRGE7QUFFbkIsZ0JBQUEsR0FBRyxFQUFILEdBRm1CO0FBR25CLGdCQUFBLGNBQWMsRUFBRSxHQUFHLENBQUM7QUFIRCxlQUZqQixDQTFDVjs7QUFBQTtBQUFBLG9CQW9ESyxHQUFHLENBQUMsT0FBSixDQUFZLElBQVosSUFDRCxHQUFHLENBQUMsT0FBSixDQUFZLGNBQVosTUFBZ0MscUJBckRwQztBQUFBO0FBQUE7QUFBQTs7QUFzREk7QUFDTSxjQUFBLFdBdkRWLEdBdUR3QixlQUFlLENBQUMsR0FBRyxDQUFDLE9BQUosQ0FBWSxJQUFiLENBdkR2QztBQXdEVSxjQUFBLGFBeERWLEdBd0QwQixXQUFXLENBQUMsbUJBQUQsQ0F4RHJDOztBQUFBLG1CQXlETyxLQUFLLENBQUMsT0FBTixDQUFjLGFBQWQsQ0F6RFA7QUFBQTtBQUFBO0FBQUE7O0FBQUEsb0JBMERZLElBQUksV0FBSixDQUNKLG9FQUNBLG1CQUZJLEVBR0osbUJBSEksRUFJSjtBQUFDLGdCQUFBLElBQUksRUFBRSwrQkFBUDtBQUF3QyxnQkFBQSxHQUFHLEVBQUg7QUFBeEMsZUFKSSxDQTFEWjs7QUFBQTtBQWdFSSxrQkFBRyxhQUFILEVBQWtCO0FBQ2hCLGdCQUFBLEdBQUcsQ0FBQyxVQUFKLEdBQWlCLGFBQWEsQ0FBQyxNQUEvQjtBQUNELGVBbEVMLENBb0VJOzs7QUFDQSxjQUFBLFNBQVMsR0FBRyxXQUFXLENBQUMsV0FBRCxDQUF2Qjs7QUFDQSxrQkFBRyxTQUFTLElBQ1YsU0FBUyxDQUFDLElBQVYsSUFBa0IscUJBRGpCLElBRUQsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFKLENBQVksY0FBWixLQUErQixFQUFoQyxFQUNFLEtBREYsQ0FDUSw2QkFEUixDQUZILEVBRzJDO0FBQ3pDLGdCQUFBLEdBQUcsQ0FBQyxPQUFKLENBQVksUUFBWixHQUF1QixXQUFXLENBQUMsR0FBRCxFQUFNLFNBQVMsQ0FBQyxNQUFoQixDQUFsQztBQUNEOztBQTNFTDtBQUFBLG9CQStFSyxDQUFDLFNBQVMsSUFDWCxHQUFHLENBQUMsVUFBSixJQUFrQixHQUFsQixJQUF5QixHQUFHLENBQUMsVUFBSixHQUFpQixHQUR6QyxLQUNpRCxHQUFHLENBQUMsT0FBSixDQUFZLFFBaEZsRTtBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFpRk8sU0FBUyxDQUFDLE1BQVYsS0FBcUIsWUFqRjVCO0FBQUE7QUFBQTtBQUFBOztBQUFBLG9CQWtGWSxJQUFJLFdBQUosQ0FDSiwrREFESSxFQUVKLHlCQUZJLEVBRXVCO0FBQ3pCLGdCQUFBLElBQUksRUFBRSx5QkFEbUI7QUFFekIsZ0JBQUEsR0FBRyxFQUFILEdBRnlCO0FBR3pCLGdCQUFBLGNBQWMsRUFBRSxHQUFHLENBQUMsVUFISztBQUl6QixnQkFBQSxTQUFTLEVBQVQ7QUFKeUIsZUFGdkIsQ0FsRlo7O0FBQUE7QUFBQSxvQkEyRk8sU0FBUyxDQUFDLE9BQVYsQ0FBa0IsR0FBbEIsTUFBMkIsQ0FBQyxDQTNGbkM7QUFBQTtBQUFBO0FBQUE7O0FBQUEsb0JBNEZZLElBQUksV0FBSixDQUNKLG1FQURJLEVBRUosaUNBRkksRUFFK0I7QUFDakMsZ0JBQUEsSUFBSSxFQUFFLDZCQUQyQjtBQUVqQyxnQkFBQSxHQUFHLEVBQUgsR0FGaUM7QUFHakMsZ0JBQUEsY0FBYyxFQUFFLEdBQUcsQ0FBQyxVQUhhO0FBSWpDLGdCQUFBLFNBQVMsRUFBVDtBQUppQyxlQUYvQixDQTVGWjs7QUFBQTtBQXFHSSxjQUFBLFNBQVMsQ0FBQyxJQUFWLENBQWUsR0FBZjtBQXJHSiwrQ0FzR1csWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFKLENBQVksUUFBYixFQUF1QixTQUF2QixDQXRHdkI7O0FBQUE7QUF5R0U7QUFDQSxjQUFBLFNBQVMsQ0FBQyxJQUFWLENBQWUsR0FBZixFQTFHRixDQTJHRTs7QUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsSEUsK0NBb0hTLEdBcEhUOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBWHVEO0FBQUE7QUFBQTtBQWlJeEQsQ0F2SUQ7O0FBeUlBLFNBQVMsUUFBVCxDQUFrQixPQUFsQixFQUEyQixPQUEzQixFQUFvQztBQUNsQyxTQUFPLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDdEMsSUFBQSxPQUFPLENBQUMsT0FBRCxFQUFVLFVBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxJQUFYLEVBQW9CO0FBQ25DLFVBQUcsR0FBSCxFQUFRO0FBQ04sUUFBQSxNQUFNLENBQUMsR0FBRCxDQUFOO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsUUFBQSxPQUFPLENBQUM7QUFBQyxVQUFBLEdBQUcsRUFBSCxHQUFEO0FBQU0sVUFBQSxJQUFJLEVBQUo7QUFBTixTQUFELENBQVA7QUFDRDtBQUNGLEtBTk0sQ0FBUDtBQU9ELEdBUk0sQ0FBUDtBQVNEOzs7QUM5S0Q7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2VBRXdDLE9BQU8sQ0FBQyxTQUFELEM7SUFBeEMsZSxZQUFBLGU7SUFBaUIsWSxZQUFBLFk7O2dCQUNNLE9BQU8sQ0FBQyxjQUFELEM7SUFBOUIsbUIsYUFBQSxtQjs7QUFDUCxJQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsZ0JBQUQsQ0FBM0I7O0FBQ0EsSUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLGlCQUFELENBQTVCOztnQkFDc0IsT0FBTyxDQUFDLFFBQUQsQztJQUF0QixXLGFBQUEsVzs7QUFFUCxJQUFNLGlCQUFpQixHQUFHLGtCQUExQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsWUFJSztBQUFBLGlGQUFsQjtBQUFDLElBQUEsT0FBTyxFQUFFO0FBQVYsR0FBa0I7QUFBQSxNQUhwQixNQUdvQixRQUhwQixNQUdvQjtBQUFBLDBCQUZwQixPQUVvQjtBQUFBLE1BRnBCLE9BRW9CLDZCQUZWLEVBRVU7QUFBQSxNQURwQixHQUNvQixRQURwQixHQUNvQjs7QUFDcEIsRUFBQSxPQUFPLEdBQUcsWUFBWSxDQUFDLE9BQUQsQ0FBdEI7QUFDQSxNQUFNLEtBQUssR0FBRyxJQUFJLFlBQUosRUFBZDtBQUNBLFNBQU8sS0FBSyxDQUFDLFVBQU4sQ0FBaUIsTUFBakIsQ0FBUDs7QUFIb0IsV0FLTCxNQUxLO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDRGQUtwQixpQkFBc0IsR0FBdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0JBQ0ssR0FBRyxDQUFDLE9BQUosQ0FBWSxPQUFaLE1BQXlCLENBQXpCLElBQThCLEdBQUcsQ0FBQyxPQUFKLENBQVksUUFBWixNQUEwQixDQUQ3RDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFFVSxJQUFJLFdBQUosQ0FDSixxRUFDQSxZQUZJLEVBR0osbUJBSEksRUFHaUI7QUFBQyxnQkFBQSxJQUFJLEVBQUUseUJBQVA7QUFBa0MsZ0JBQUEsR0FBRyxFQUFIO0FBQWxDLGVBSGpCLENBRlY7O0FBQUE7QUFBQSxvQkFPSyxNQUFNLElBQUksR0FBRyxDQUFDLE9BQUosQ0FBWSxPQUFaLE1BQXlCLENBUHhDO0FBQUE7QUFBQTtBQUFBOztBQUFBLG9CQVFVLElBQUksV0FBSixDQUNKLCtEQUNBLG1DQUZJLEVBR0osbUJBSEksRUFHaUI7QUFBQyxnQkFBQSxJQUFJLEVBQUUseUJBQVA7QUFBa0MsZ0JBQUEsR0FBRyxFQUFIO0FBQWxDLGVBSGpCLENBUlY7O0FBQUE7QUFBQTtBQUFBO0FBQUEscUJBZ0JnQixJQUFJLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxPQUFYLENBaEJwQjs7QUFBQTtBQWdCSSxjQUFBLEdBaEJKO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFrQlUsSUFBSSxXQUFKLENBQ0osbURBREksRUFFSiwwQkFGSSxFQUdKO0FBQUMsZ0JBQUEsSUFBSSxFQUFFLHlCQUFQO0FBQWtDLGdCQUFBLEdBQUcsRUFBSCxHQUFsQztBQUF1QyxnQkFBQSxLQUFLO0FBQTVDLGVBSEksQ0FsQlY7O0FBQUE7QUFBQSxvQkF3QkssR0FBRyxDQUFDLE1BQUosSUFBYyxHQXhCbkI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsb0JBeUJVLElBQUksV0FBSixDQUNKLG9DQUFvQyxHQUFHLENBQUMsVUFEcEMsRUFFSiwwQkFGSSxFQUV3QjtBQUMxQixnQkFBQSxJQUFJLEVBQUUseUJBRG9CO0FBRTFCLGdCQUFBLEdBQUcsRUFBSCxHQUYwQjtBQUcxQixnQkFBQSxjQUFjLEVBQUUsR0FBRyxDQUFDO0FBSE0sZUFGeEIsQ0F6QlY7O0FBQUE7QUFrQ00sY0FBQSxHQWxDTixHQWtDWTtBQUFDLGdCQUFBLFVBQVUsRUFBRSxJQUFiO0FBQW1CLGdCQUFBLFdBQVcsRUFBRSxHQUFoQztBQUFxQyxnQkFBQSxRQUFRLEVBQUUsR0FBRyxDQUFDO0FBQW5ELGVBbENaO0FBbUNNLGNBQUEsU0FuQ04sR0FtQ2tCLElBbkNsQixFQXFDRTs7QUFDTSxjQUFBLFdBdENSLEdBc0NzQixHQUFHLENBQUMsaUJBQUosQ0FBc0IsY0FBdEIsQ0F0Q3RCOztBQXdDRSxrQkFBRyxpQkFBaUIsQ0FBQyxJQUFsQixDQUF1QixHQUFHLENBQUMscUJBQUosRUFBdkIsQ0FBSCxFQUF3RDtBQUN0RCxnQkFBQSxVQUFVLEdBQUcsR0FBRyxDQUFDLGlCQUFKLENBQXNCLE1BQXRCLENBQWI7QUFDRDs7QUExQ0gsb0JBMkNLLFVBQVUsSUFBSSxXQUFXLEtBQUsscUJBM0NuQztBQUFBO0FBQUE7QUFBQTs7QUE0Q0k7QUFDTSxjQUFBLFdBN0NWLEdBNkN3QixlQUFlLENBQUMsVUFBRCxDQTdDdkM7QUE4Q1UsY0FBQSxhQTlDVixHQThDMEIsV0FBVyxDQUFDLG1CQUFELENBOUNyQzs7QUFBQSxtQkErQ08sS0FBSyxDQUFDLE9BQU4sQ0FBYyxhQUFkLENBL0NQO0FBQUE7QUFBQTtBQUFBOztBQUFBLG9CQWdEWSxJQUFJLFdBQUosQ0FDSix5REFDQSw4QkFGSSxFQUdKLG1CQUhJLEVBSUo7QUFBQyxnQkFBQSxJQUFJLEVBQUUsK0JBQVA7QUFBd0MsZ0JBQUEsR0FBRyxFQUFIO0FBQXhDLGVBSkksQ0FoRFo7O0FBQUE7QUFzREksa0JBQUcsYUFBSCxFQUFrQjtBQUNoQixnQkFBQSxHQUFHLENBQUMsVUFBSixHQUFpQixhQUFhLENBQUMsTUFBL0I7QUFDRCxlQXhETCxDQTBESTs7O0FBQ0EsY0FBQSxTQUFTLEdBQUcsV0FBVyxDQUFDLFdBQUQsQ0FBdkI7O0FBM0RKLG9CQTRETyxTQUFTLElBQ1YsU0FBUyxDQUFDLElBQVYsSUFBa0IscUJBRGpCLElBRUQsQ0FBQyxDQUFDLFdBQVcsSUFBSSxFQUFoQixFQUFvQixLQUFwQixDQUEwQiw2QkFBMUIsQ0E5RFA7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxxQkErRGtCLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRCxFQUFNLFNBQVMsQ0FBQyxNQUFoQixDQUFaLENBL0R4Qjs7QUFBQTtBQStETSxjQUFBLEdBL0ROOztBQUFBO0FBQUEsK0NBbUVTLEdBbkVUOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBTG9CO0FBQUE7QUFBQTtBQTBFckIsQ0E5RUQ7O0FBZ0ZBLFNBQVMsSUFBVCxDQUFjLEdBQWQsRUFBbUIsR0FBbkIsRUFBd0IsT0FBeEIsRUFBaUM7QUFDL0IsRUFBQSxHQUFHLEdBQUcsR0FBRyxJQUFJLGNBQWI7QUFDQSxNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUosRUFBWjtBQUNBLFNBQU8sSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxJQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWE7QUFBQSxhQUFNLE9BQU8sQ0FBQyxHQUFELENBQWI7QUFBQSxLQUFiOztBQUNBLElBQUEsR0FBRyxDQUFDLE9BQUosR0FBYyxVQUFBLEdBQUc7QUFBQSxhQUFJLE1BQU0sQ0FBQyxHQUFELENBQVY7QUFBQSxLQUFqQjs7QUFDQSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsS0FBVCxFQUFnQixHQUFoQixFQUFxQixJQUFyQjs7QUFDQSxTQUFJLElBQU0sQ0FBVixJQUFlLE9BQWYsRUFBd0I7QUFDdEIsTUFBQSxHQUFHLENBQUMsZ0JBQUosQ0FBcUIsQ0FBckIsRUFBd0IsT0FBTyxDQUFDLENBQUQsQ0FBL0I7QUFDRDs7QUFDRCxJQUFBLEdBQUcsQ0FBQyxJQUFKO0FBQ0QsR0FSTSxDQUFQO0FBU0Q7OztBQ3BIRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLGVBQUQsQ0FBM0I7O2VBUUksT0FBTyxDQUFDLFNBQUQsQztJQUxBLFEsWUFBVCxPO0lBQ1UsUyxZQUFWLFE7SUFDZSxjLFlBQWYsYTtJQUNVLFMsWUFBVixRO0lBQ2EsWSxZQUFiLFc7O2dCQVFFLE9BQU8sQ0FBQyxjQUFELEM7SUFKRCxPLGFBQVIsTTtJQUNTLFEsYUFBVCxPO0lBQ1MsUSxhQUFULE87SUFDVyxVLGFBQVgsUzs7Z0JBU0UsT0FBTyxDQUFDLFdBQUQsQztJQUxFLFUsYUFBWCxTO0lBQ2lCLGdCLGFBQWpCLGU7SUFDVyxVLGFBQVgsUztJQUNTLGUsYUFBVCxPO0lBQ2dCLGUsYUFBaEIsYzs7Z0JBS0UsT0FBTyxDQUFDLE9BQUQsQztJQURHLGMsYUFBWixVOztnQkFRRSxPQUFPLENBQUMsUUFBRCxDO0lBSkMsUyxhQUFWLFE7SUFDUyxRLGFBQVQsTztJQUNXLFUsYUFBWCxTO0lBQ21CLGtCLGFBQW5CLGlCOztBQUdGLElBQU0sR0FBRyxHQUFHLEVBQVo7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixHQUFqQjtBQUNBLElBQU0sV0FBVyxHQUFHLHFDQUFwQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLEdBQUcsQ0FBQyxNQUFKO0FBQUEsNEZBQWE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNYLFlBQUEsU0FEVyxRQUNYLFNBRFcsNkJBRVgsY0FGVyxFQUVYLGNBRlcsb0NBRU0sSUFGTix3QkFHWCxPQUhXLFFBR1gsT0FIVyxzQkFJWCxPQUpXLEVBSVgsT0FKVyw2QkFJRCxFQUpDLHdDQUtYLFVBTFcsRUFLWCxVQUxXLGdDQUtFLEtBTEYsNENBTVgsV0FOVyxFQU1YLFdBTlcsaUNBTUcsS0FOSCxrREFPWCxpQkFQVyxFQU9YLGlCQVBXLHNDQU9TLElBUFQsbURBUVgsWUFSVyxFQVFYLFlBUlcsa0NBUUk7QUFBQSxxQkFBTSxTQUFOO0FBQUEsYUFSSjs7QUFBQSxrQkFXUixPQUFPLEtBQUssSUFBWixJQUFvQixPQUFPLEtBQUssU0FYeEI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkNBWUYsSUFaRTs7QUFBQTtBQWVYO0FBQ0EsZ0JBQUcsY0FBYyxLQUFLLFVBQXRCLEVBQWtDO0FBQ2hDLGNBQUEsT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFQLENBQWMsRUFBZCxFQUFrQixPQUFsQixFQUEyQjtBQUFDLGdCQUFBLE9BQU8sRUFBRTtBQUFWLGVBQTNCLENBQVY7QUFDRDs7QUFsQlUsa0JBb0JSLENBQUMsUUFBUSxDQUFDLE9BQUQsQ0FBVCxJQUFzQixDQUFDLFNBQVMsQ0FBQyxPQUFELENBcEJ4QjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFzQk4sQ0FBQyxVQUFELEtBQWdCLGNBQWMsS0FBSyxJQUFuQixJQUNqQixVQUFVLENBQUMsU0FBRCxFQUFZLGNBQVosRUFBNEI7QUFBQyxjQUFBLEtBQUssRUFBRTtBQUFSLGFBQTVCLEVBQ1IsT0FEUSxDQUFWLEtBQ2UsUUFGZCxDQXRCTTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQXlCYyxZQUFZLENBQUM7QUFDaEMsY0FBQSxhQUFhLEVBQUUsT0FEaUI7QUFFaEMsY0FBQSxTQUFTLEVBQVQsU0FGZ0M7QUFHaEMsY0FBQSxjQUFjLEVBQWQsY0FIZ0M7QUFJaEMsY0FBQSxPQUFPLEVBQVAsT0FKZ0M7QUFLaEMsY0FBQSxVQUFVLEVBQVY7QUFMZ0MsYUFBRCxDQXpCMUI7O0FBQUE7QUF5QkQsWUFBQSxNQXpCQzs7QUFBQSxrQkFnQ0osTUFBTSxLQUFLLFNBaENQO0FBQUE7QUFBQTtBQUFBOztBQUFBLDZDQWlDRSxJQWpDRjs7QUFBQTtBQUFBLDZDQW1DQSxNQW5DQTs7QUFBQTtBQUFBLDZDQXVDRixZQUFZLENBQUM7QUFBQyxjQUFBLFNBQVMsRUFBVCxTQUFEO0FBQVksY0FBQSxjQUFjLEVBQWQsY0FBWjtBQUE0QixjQUFBLEtBQUssRUFBRSxPQUFuQztBQUE0QyxjQUFBLE9BQU8sRUFBUDtBQUE1QyxhQUFELENBdkNWOztBQUFBO0FBQUEsaUJBMkNSLFFBQVEsQ0FBQyxPQUFELENBM0NBO0FBQUE7QUFBQTtBQUFBOztBQTRDTCxZQUFBLEtBNUNLLEdBNENFLEVBNUNGO0FBNkNILFlBQUEsU0E3Q0csR0E2Q1MsZ0JBQWdCLENBQ2hDLFNBRGdDLEVBQ3JCLGNBRHFCLEVBQ0wsWUFESyxDQUFoQixJQUM0QixFQTlDckM7QUErQ1QsWUFBQSxVQUFVLEdBQUcsVUFBVSxJQUFJLFNBQVMsQ0FBQyxRQUFWLENBQW1CLE9BQW5CLENBQTNCO0FBQ1EsWUFBQSxDQWhEQyxHQWdERyxDQWhESDs7QUFBQTtBQUFBLGtCQWdETSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BaERsQjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQWtETyxHQUFHLENBQUMsTUFBSixDQUFXO0FBQ3ZCLGNBQUEsU0FBUyxFQUFULFNBRHVCO0FBRXZCLGNBQUEsY0FBYyxFQUFkLGNBRnVCO0FBR3ZCLGNBQUEsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFELENBSE87QUFJdkIsY0FBQSxPQUFPLEVBQVAsT0FKdUI7QUFLdkIsY0FBQSxZQUFZLEVBQVosWUFMdUI7QUFNdkIsY0FBQSxXQUFXLEVBQVgsV0FOdUI7QUFPdkIsY0FBQSxpQkFBaUIsRUFBakI7QUFQdUIsYUFBWCxDQWxEUDs7QUFBQTtBQWtESCxZQUFBLENBbERHOztBQTJEUCxnQkFBRyxVQUFVLElBQUksUUFBUSxDQUFDLENBQUQsQ0FBekIsRUFBOEI7QUFDNUIsY0FBQSxDQUFDLEdBQUc7QUFBQyx5QkFBUztBQUFWLGVBQUo7QUFDRDs7QUE3RE0sa0JBK0RKLENBQUMsS0FBSyxJQS9ERjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQWdFSyxZQUFZLENBQUM7QUFDckIsY0FBQSxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUQsQ0FERDtBQUVyQixjQUFBLFNBQVMsRUFBVCxTQUZxQjtBQUdyQixjQUFBLGNBQWMsRUFBZCxjQUhxQjtBQUlyQixjQUFBLE1BQU0sRUFBRSxPQUphO0FBS3JCLGNBQUEsS0FBSyxFQUFFLENBTGM7QUFNckIsY0FBQSxPQUFPLEVBQVAsT0FOcUI7QUFPckIsY0FBQSxjQUFjLEVBQUUsS0FQSztBQVFyQixjQUFBLFVBQVUsRUFBVjtBQVJxQixhQUFELENBaEVqQjs7QUFBQTtBQWdFTCxZQUFBLENBaEVLOztBQUFBLGtCQTBFRixDQUFDLEtBQUssU0ExRUo7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUErRVAsZ0JBQUcsUUFBUSxDQUFDLENBQUQsQ0FBWCxFQUFnQjtBQUNkLGNBQUEsS0FBSSxHQUFHLEtBQUksQ0FBQyxNQUFMLENBQVksQ0FBWixDQUFQO0FBQ0QsYUFGRCxNQUVPO0FBQ0wsY0FBQSxLQUFJLENBQUMsSUFBTCxDQUFVLENBQVY7QUFDRDs7QUFuRk07QUFnRDBCLGNBQUUsQ0FoRDVCO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDZDQXFGRixLQXJGRTs7QUFBQTtBQXdGWDtBQUVBO0FBQ00sWUFBQSxzQkEzRkssR0EyRm9CLFVBQVUsQ0FDdkMsU0FEdUMsRUFDNUIsY0FENEIsRUFDWjtBQUFDLGNBQUEsS0FBSyxFQUFFO0FBQVIsYUFEWSxFQUNHLE9BREgsQ0EzRjlCLEVBOEZYOztBQUNNLFlBQUEsaUJBL0ZLLEdBZ0dULGdCQUFnQixDQUFDLFNBQUQsRUFBWSxjQUFaLEVBQTRCLFVBQTVCLENBaEdQLEVBa0dYO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFlBQUEsaUJBQWlCLEdBQUcsaUJBQWlCLEtBQ2xDLFNBQVMsQ0FBQyxlQUFWLEdBQTRCLFNBQTVCLEdBQXdDLElBRE4sQ0FBckM7QUFFSSxZQUFBLElBeEdPLEdBd0dBLE1BQU0sQ0FBQyxJQUFQLENBQVksT0FBWixFQUFxQixJQUFyQixFQXhHQTtBQXlHUCxZQUFBLFVBekdPLEdBeUdNLENBQUMsV0F6R1A7O0FBQUEsa0JBMEdSLFVBQVUsSUFBSSxpQkFBZCxJQUFtQyxJQUFJLENBQUMsTUFBTCxJQUFlLENBQWxELElBQ0QsQ0FBQyxJQUFJLENBQUMsUUFBTCxDQUFjLFVBQWQsQ0EzR1E7QUFBQTtBQUFBO0FBQUE7O0FBQUEsbURBNEdRLElBNUdSO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUE0R0MsWUFBQSxHQTVHRDtBQTZHRCxZQUFBLGdCQTdHQyxHQTZHa0IsVUFBVSxDQUNqQyxpQkFEaUMsRUFDZCxHQURjLEVBQ1Q7QUFBQyxjQUFBLEtBQUssRUFBRTtBQUFSLGFBRFMsRUFDTSxPQUROLENBN0c1Qjs7QUFBQSxrQkErR0osZ0JBQWdCLEtBQUssUUEvR2pCO0FBQUE7QUFBQTtBQUFBOztBQWdITDtBQUNBLFlBQUEsVUFBVSxHQUFHLEtBQWI7QUFDQSxZQUFBLFNBQVMsR0FBRyxpQkFBWjtBQWxISzs7QUFBQTtBQUFBLGtCQXFISixnQkFBZ0IsS0FBSyxLQUFyQixJQUE4QixJQUFJLENBQUMsTUFBTCxLQUFnQixDQXJIMUM7QUFBQTtBQUFBO0FBQUE7O0FBc0hMO0FBQ0EsWUFBQSxVQUFVLEdBQUcsS0FBYjtBQXZISzs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBNkhYLGdCQUFHLFVBQUgsRUFBZTtBQUNiO0FBQ0EsY0FBQSxTQUFTLEdBQUcsU0FBUyxDQUFDLHVCQUFWLEVBQVo7QUFDRCxhQWhJVSxDQWtJWDs7O0FBbElXLGdCQW1JUCxZQUFZLENBQUMsaUJBQUQsQ0FuSUw7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkFvSVMsZUFBZSxDQUFDO0FBQ2hDLGNBQUEsU0FBUyxFQUFULFNBRGdDO0FBRWhDLGNBQUEsUUFBUSxFQUFFLGlCQUZzQjtBQUdoQyxjQUFBLFNBQVMsRUFBRSxJQUhxQjtBQUloQyxjQUFBLGlCQUFpQixFQUFFLElBSmE7QUFLaEMsY0FBQSxPQUFPLEVBQVA7QUFMZ0MsYUFBRCxDQXBJeEI7O0FBQUE7QUFvSVQsWUFBQSxTQXBJUzs7QUFBQTtBQUFBLGtCQThJUixjQUFjLE9BOUlOO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBK0lTLGVBQWUsQ0FDL0I7QUFBQyxjQUFBLFNBQVMsRUFBVCxTQUFEO0FBQVksY0FBQSxRQUFRLEVBQUUsT0FBTyxDQUFDLFVBQUQsQ0FBN0I7QUFBMkMsY0FBQSxPQUFPLEVBQVA7QUFBM0MsYUFEK0IsQ0EvSXhCOztBQUFBO0FBK0lULFlBQUEsU0EvSVM7O0FBQUE7QUFtSlg7QUFDQSxZQUFBLGlCQUFpQixHQUFHLFNBQXBCLENBcEpXLENBc0pYOztBQUNJLFlBQUEsT0F2Sk8sR0F1SkcsSUF2SkgsRUF5Slg7O0FBekpXLG9EQTBKTSxJQTFKTjtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBMEpELFlBQUEsSUExSkM7QUEySkgsWUFBQSxpQkEzSkcsR0EySmdCLFVBQVUsQ0FBQyxTQUFELEVBQVksSUFBWixFQUFpQjtBQUFDLGNBQUEsS0FBSyxFQUFFO0FBQVIsYUFBakIsRUFBZ0MsT0FBaEMsQ0EzSjFCOztBQUFBLGtCQTRKTixpQkFBZ0IsS0FBSyxPQTVKZjtBQUFBO0FBQUE7QUFBQTs7QUE2SlA7QUFDQTtBQUNBLFlBQUEsT0FBTyxHQUFHLE9BQU8sSUFBSSxJQUFyQjtBQUNNLFlBQUEsS0FoS0MsR0FnS08sT0FBTyxDQUFDLElBQUQsQ0FoS2Q7QUFpS0QsWUFBQSxNQWpLQyxHQWtLTCxLQUFLLENBQUMsT0FBTixDQUFjLEtBQWQsSUFDRyxLQUFLLENBQUMsTUFBTixHQUFlLENBQWYsR0FBbUIsS0FBSyxDQUFDLEtBQU4sR0FBYyxJQUFkLEVBQW5CLEdBQTBDLEtBRDdDLEdBQ3NELENBQUMsS0FBRCxDQW5LakQ7QUFBQSxvREFvS1csTUFwS1g7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW9LRyxZQUFBLElBcEtIO0FBcUtDLFlBQUEsR0FyS0QsR0FxS08sZ0JBQWdCLENBQUMsaUJBQUQsRUFBb0IsSUFBcEIsRUFBMEIsVUFBMUIsQ0FyS3ZCOztBQUFBLGdCQXNLRCxZQUFZLENBQUMsR0FBRCxDQXRLWDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQXVLZSxlQUFlLENBQUM7QUFDaEMsY0FBQSxTQUFTLEVBQVQsU0FEZ0M7QUFFaEMsY0FBQSxRQUFRLEVBQUUsR0FGc0I7QUFHaEMsY0FBQSxPQUFPLEVBQVAsT0FIZ0M7QUFJaEMsY0FBQSxTQUFTLEVBQUU7QUFKcUIsYUFBRCxDQXZLOUI7O0FBQUE7QUF1S0gsWUFBQSxTQXZLRzs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFrTFg7QUFDSSxZQUFBLElBbkxPLEdBbUxBLEVBbkxBO0FBQUE7QUFBQSxtQkFvTEwsYUFBYSxDQUFDO0FBQ2xCLGNBQUEsU0FBUyxFQUFULFNBRGtCO0FBRWxCLGNBQUEsY0FBYyxFQUFkLGNBRmtCO0FBR2xCLGNBQUEsc0JBQXNCLEVBQXRCLHNCQUhrQjtBQUlsQixjQUFBLE9BQU8sRUFBUCxPQUprQjtBQUtsQixjQUFBLGNBQWMsRUFBRSxJQUxFO0FBTWxCLGNBQUEsT0FBTyxFQUFQLE9BTmtCO0FBT2xCLGNBQUEsVUFBVSxFQUFWLFVBUGtCO0FBUWxCLGNBQUEsT0FBTyxFQUFQLE9BUmtCO0FBU2xCLGNBQUEsaUJBQWlCLEVBQWpCLGlCQVRrQjtBQVVsQixjQUFBLFlBQVksRUFBWjtBQVZrQixhQUFELENBcExSOztBQUFBO0FBZ01YO0FBQ0EsWUFBQSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFaLENBQVA7QUFDSSxZQUFBLEtBbE1PLEdBa01DLElBQUksQ0FBQyxNQWxNTjs7QUFBQSxrQkFvTVIsWUFBWSxJQXBNSjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFzTU4sV0FBVyxJQUFYLEtBQW9CLGVBQWUsSUFBZixJQUF1QixnQkFBZ0IsSUFBM0QsQ0F0TU07QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBdU1ELElBQUksV0FBSixDQUNKLG9FQUNBLDhEQUZJLEVBR0osb0JBSEksRUFHa0I7QUFBQyxjQUFBLElBQUksRUFBRSxzQkFBUDtBQUErQixjQUFBLE9BQU8sRUFBRTtBQUF4QyxhQUhsQixDQXZNQzs7QUFBQTtBQTRNTCxZQUFBLFVBNU1LLEdBNE1RLEtBQUssR0FBRyxDQTVNaEI7O0FBNk1ULGdCQUFHLFdBQVcsSUFBZCxFQUFvQjtBQUNsQixjQUFBLFVBQVUsSUFBSSxDQUFkO0FBQ0Q7O0FBQ0QsZ0JBQUcsWUFBWSxJQUFmLEVBQXFCO0FBQ25CLGNBQUEsVUFBVSxJQUFJLENBQWQ7QUFDRDs7QUFDRCxnQkFBRyxlQUFlLElBQWxCLEVBQXdCO0FBQ3RCLGNBQUEsVUFBVSxJQUFJLENBQWQ7QUFDRDs7QUFDRCxnQkFBRyxnQkFBZ0IsSUFBbkIsRUFBeUI7QUFDdkIsY0FBQSxVQUFVLElBQUksQ0FBZDtBQUNEOztBQXhOUSxrQkF5Tk4sVUFBVSxLQUFLLENBek5UO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQTBORCxJQUFJLFdBQUosQ0FDSixxRUFDQSwrQ0FEQSxHQUVBLGdEQUhJLEVBSUosb0JBSkksRUFJa0I7QUFBQyxjQUFBLElBQUksRUFBRSxzQkFBUDtBQUErQixjQUFBLE9BQU8sRUFBRTtBQUF4QyxhQUpsQixDQTFOQzs7QUFBQTtBQWdPSCxZQUFBLE1BaE9HLEdBZ09NLElBQUksQ0FBQyxRQUFELENBQUosS0FBbUIsSUFBbkIsR0FBMEIsRUFBMUIsR0FBK0IsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFELENBQUwsQ0FoTzdDO0FBaU9ILFlBQUEsS0FqT0csR0FpT0ssVUFBVSxDQUFDLElBQUQsRUFBTyxPQUFQLENBak9mLEVBbU9UOztBQW5PUyxrQkFvT04sZUFBZSxDQUFDLFNBQUQsRUFBWSxHQUFaLENBQWYsSUFBbUMsS0FBSyxDQUFDLFFBQU4sQ0FBZSxPQUFmLENBQW5DLElBQ0QsS0FBSyxDQUFDLE1BQU4sS0FBaUIsQ0FyT1Y7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBLGtCQXVPQyxNQUFNLENBQUMsTUFBUCxLQUFrQixDQXZPbkI7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkF3T2MsWUFBWSxDQUFDO0FBQ2hDLGNBQUEsYUFBYSxFQUFFLElBRGlCO0FBRWhDLGNBQUEsU0FBUyxFQUFULFNBRmdDO0FBR2hDLGNBQUEsY0FBYyxFQUFkLGNBSGdDO0FBSWhDLGNBQUEsT0FBTyxFQUFQLE9BSmdDO0FBS2hDLGNBQUEsT0FBTyxFQUFQLE9BTGdDO0FBTWhDLGNBQUEsVUFBVSxFQUFWO0FBTmdDLGFBQUQsQ0F4TzFCOztBQUFBO0FBd09ELFlBQUEsT0F4T0M7O0FBZ1BQLGdCQUFHLE9BQU0sS0FBSyxTQUFkLEVBQXlCO0FBQ3ZCLGNBQUEsSUFBSSxHQUFHLE9BQVA7QUFDRCxhQUZELE1BRU87QUFDTCxjQUFBLElBQUksR0FBRyxJQUFQO0FBQ0Q7O0FBcFBNO0FBQUE7O0FBQUE7QUFBQSxrQkFxUEMsQ0FBQyxNQUFNLENBQUMsS0FBUCxDQUFhLFVBQUEsQ0FBQztBQUFBLHFCQUFLLFNBQVMsQ0FBQyxDQUFELENBQVQsSUFBZ0IsY0FBYyxDQUFDLENBQUQsQ0FBbkM7QUFBQSxhQUFkLENBQUQsSUFDUixlQUFlLElBdFBSO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQXdQRCxJQUFJLFdBQUosQ0FDSiw4REFESSxFQUVKLG9CQUZJLEVBR0o7QUFBQyxjQUFBLElBQUksRUFBRSwrQkFBUDtBQUF3QyxjQUFBLE9BQU8sRUFBRTtBQUFqRCxhQUhJLENBeFBDOztBQUFBO0FBQUEsZ0JBNFBFLEtBQUssQ0FBQyxLQUFOLENBQVksVUFBQSxDQUFDO0FBQUEscUJBQ3JCLGNBQWMsQ0FBQyxDQUFELENBQWQsSUFBcUIsRUFBRSxTQUFTLENBQUMsQ0FBRCxDQUFULElBQWdCLENBQUMsQ0FBQyxPQUFGLENBQVUsSUFBVixNQUFvQixDQUF0QyxDQUFyQixJQUNELGNBQWMsQ0FBQyxDQUFELENBRlE7QUFBQSxhQUFiLENBNVBGO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQStQRCxJQUFJLFdBQUosQ0FDSix3RUFDQSxxREFGSSxFQUdKLG9CQUhJLEVBR2tCO0FBQUMsY0FBQSxJQUFJLEVBQUUscUJBQVA7QUFBOEIsY0FBQSxPQUFPLEVBQUU7QUFBdkMsYUFIbEIsQ0EvUEM7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsa0JBb1FELFdBQVcsSUFBWCxJQUFtQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBRCxDQUFMLENBcFEzQjtBQUFBO0FBQUE7QUFBQTs7QUFxUVQ7QUFDQSxZQUFBLElBQUksQ0FBQyxPQUFELENBQUosR0FBZ0IsQ0FBQyxJQUFJLENBQUMsT0FBRCxDQUFMLENBQWhCO0FBdFFTO0FBQUE7O0FBQUE7QUFBQSxrQkF1UUQsVUFBVSxJQUFWLElBQWtCLFdBQVcsSUF2UTVCO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQXlRTixLQUFLLEdBQUcsQ0FBUixJQUFhLEVBQUUsS0FBSyxLQUFLLENBQVYsSUFBZSxZQUFZLElBQTdCLENBelFQO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQTBRRCxJQUFJLFdBQUosQ0FDSixtRUFDQSxrRUFEQSxHQUVBLFdBSEksRUFHUyxvQkFIVCxFQUlKO0FBQUMsY0FBQSxJQUFJLEVBQUUsNEJBQVA7QUFBcUMsY0FBQSxPQUFPLEVBQUU7QUFBOUMsYUFKSSxDQTFRQzs7QUFBQTtBQWdSVDtBQUNBLGdCQUFHLFVBQVUsSUFBYixFQUFtQjtBQUNqQixjQUFBLElBQUksR0FBRyxJQUFJLENBQUMsTUFBRCxDQUFYO0FBQ0EsY0FBQSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFaLENBQVA7QUFDQSxjQUFBLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBYjtBQUNEOztBQXJSUTtBQUFBOztBQUFBO0FBQUEsa0JBc1JELEtBQUssS0FBSyxDQUFWLElBQWUsZUFBZSxJQXRSN0I7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkF3UlksWUFBWSxDQUFDLElBQUQsRUFBTztBQUN0QyxjQUFBLGFBQWEsRUFBRSxJQUR1QjtBQUV0QyxjQUFBLFNBQVMsRUFBVCxTQUZzQztBQUd0QyxjQUFBLGNBQWMsRUFBZCxjQUhzQztBQUl0QyxjQUFBLE9BQU8sRUFBUCxPQUpzQztBQUt0QyxjQUFBLE9BQU8sRUFBUCxPQUxzQztBQU10QyxjQUFBLFVBQVUsRUFBVjtBQU5zQyxhQUFQLENBeFJ4Qjs7QUFBQTtBQXdSSCxZQUFBLFFBeFJHOztBQWdTVCxnQkFBRyxRQUFNLEtBQUssU0FBZCxFQUF5QjtBQUN2QixjQUFBLElBQUksR0FBRyxRQUFQO0FBQ0QsYUFGRCxNQUVPO0FBQ0wsY0FBQSxJQUFJLEdBQUcsSUFBUDtBQUNEOztBQXBTUTtBQUFBLGtCQXlTUixTQUFTLENBQUMsSUFBRCxDQUFULElBQ0QsQ0FBQyxPQUFPLENBQUMscUJBRFIsSUFDaUMsQ0FBQyxVQURsQyxLQUVBLGNBQWMsS0FBSyxJQUFuQixJQUEyQixzQkFBc0IsS0FBSyxRQUZ0RCxDQXpTUTtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkE2U04sS0FBSyxLQUFLLENBQVYsSUFBZSxZQUFZLElBQTNCLElBQW1DLFdBQVcsSUFBOUMsSUFDQSxLQUFLLEtBQUssQ0FBVixJQUFlLFNBQVMsSUE5U2xCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBK1NjLFlBQVksQ0FBQztBQUNoQyxjQUFBLGFBQWEsRUFBRSxJQURpQjtBQUVoQyxjQUFBLFNBQVMsRUFBVCxTQUZnQztBQUdoQyxjQUFBLGNBQWMsRUFBZCxjQUhnQztBQUloQyxjQUFBLE9BQU8sRUFBUCxPQUpnQztBQUtoQyxjQUFBLE9BQU8sRUFBUCxPQUxnQztBQU1oQyxjQUFBLFVBQVUsRUFBVjtBQU5nQyxhQUFELENBL1MxQjs7QUFBQTtBQStTRCxZQUFBLFFBL1NDOztBQXVUUCxnQkFBRyxRQUFNLEtBQUssU0FBZCxFQUF5QjtBQUN2QixjQUFBLElBQUksR0FBRyxRQUFQO0FBQ0QsYUFGRCxNQUVPO0FBQ0wsY0FBQSxJQUFJLEdBQUcsSUFBUDtBQUNEOztBQTNUTTtBQUFBLDZDQStUSixJQS9USTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFiOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBa1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztTQUNlLGE7OztBQXVmZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2lHQWpnQkE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNFLFlBQUEsU0FERixTQUNFLFNBREYsRUFFRSxjQUZGLFNBRUUsY0FGRixFQUdFLHNCQUhGLFNBR0Usc0JBSEYsRUFJRSxPQUpGLFNBSUUsT0FKRixFQUtFLGNBTEYsU0FLRSxjQUxGLHdCQU1FLE9BTkYsRUFNRSxPQU5GLDhCQU1ZLEVBTlosa0JBT0UsVUFQRixTQU9FLFVBUEYsRUFRRSxPQVJGLFNBUUUsT0FSRixFQVNFLGlCQVRGLFNBU0UsaUJBVEYsRUFVRSxZQVZGLFNBVUUsWUFWRjtBQVlRLFlBQUEsSUFaUixHQVllLE1BQU0sQ0FBQyxJQUFQLENBQVksT0FBWixFQUFxQixJQUFyQixFQVpmO0FBYVEsWUFBQSxLQWJSLEdBYWdCLEVBYmhCO0FBZ0JFO0FBQ00sWUFBQSxVQWpCUixHQWlCcUIsT0FBTyxDQUFDLE9BQUQsQ0FBUCxJQUNqQixVQUFVLENBQUMsU0FBRCxFQUNQLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBRCxDQUFSLENBQVIsR0FBNkIsT0FBTyxDQUFDLE9BQUQsQ0FBUCxDQUFpQixDQUFqQixDQUE3QixHQUFtRCxPQUFPLENBQUMsT0FBRCxDQURuRCxFQUVSO0FBQUMsY0FBQSxLQUFLLEVBQUU7QUFBUixhQUZRLEVBRU8sT0FGUCxDQUFWLEtBRThCLE9BcEJsQztBQUFBLG9EQXNCbUIsSUF0Qm5CO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFzQlksWUFBQSxLQXRCWjtBQXVCUSxZQUFBLEtBdkJSLEdBdUJnQixPQUFPLENBQUMsS0FBRCxDQXZCdkI7QUF3QlEsWUFBQSxhQXhCUixXQTBCSTs7QUExQkosa0JBMkJPLEtBQUcsS0FBSyxVQTNCZjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQStCSTtBQUNJLFlBQUEsZ0JBaENSLEdBZ0MyQixVQUFVLENBQUMsU0FBRCxFQUFZLEtBQVosRUFBaUI7QUFBQyxjQUFBLEtBQUssRUFBRTtBQUFSLGFBQWpCLEVBQWdDLE9BQWhDLENBaENyQyxFQWtDSTs7QUFsQ0osa0JBbUNPLGdCQUFnQixLQUFLLElBQXJCLElBQ0QsRUFBRSxjQUFjLENBQUMsZ0JBQUQsQ0FBZCxJQUFvQyxVQUFVLENBQUMsZ0JBQUQsQ0FBaEQsQ0FwQ047QUFBQTtBQUFBO0FBQUE7O0FBcUNNO0FBQ0EsWUFBQSxnQkFBZ0IsR0FBRyxZQUFZLENBQUM7QUFDOUIsY0FBQSxnQkFBZ0IsRUFBRSxLQURZO0FBRTlCLGNBQUEsU0FBUyxFQUFULFNBRjhCO0FBRzlCLGNBQUEsY0FBYyxFQUFkLGNBSDhCO0FBSTlCLGNBQUEsTUFBTSxFQUFFLE9BSnNCO0FBSzlCLGNBQUEsT0FBTyxFQUFQLE9BTDhCO0FBTTlCLGNBQUEsVUFBVSxFQUFWLFVBTjhCO0FBTzlCLGNBQUEsS0FBSyxFQUFMLEtBUDhCO0FBUTlCLGNBQUEsY0FBYyxFQUFkO0FBUjhCLGFBQUQsQ0FBL0I7O0FBdENOLGtCQWdEUyxnQkFBZ0IsS0FBSyxTQWhEOUI7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQSxpQkFxRE8sVUFBVSxDQUFDLGdCQUFELENBckRqQjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFzRFMsc0JBQXNCLEtBQUssVUF0RHBDO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQXVEYyxJQUFJLFdBQUosQ0FDSixvRUFDQSxXQUZJLEVBRVMsb0JBRlQsRUFHSjtBQUFDLGNBQUEsSUFBSSxFQUFFLDhCQUFQO0FBQXVDLGNBQUEsS0FBSyxFQUFMO0FBQXZDLGFBSEksQ0F2RGQ7O0FBQUE7QUFBQSxrQkE0RFMsZ0JBQWdCLElBQUksY0FBcEIsSUFDQSxnQkFBZ0IsS0FBSyxXQURyQixJQUVBLGdCQUFnQixLQUFLLE9BOUQ5QjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkErRGMsSUFBSSxXQUFKLENBQ0osc0RBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsY0FBQSxJQUFJLEVBQUUsb0JBQVA7QUFBNkIsY0FBQSxPQUFPLEVBQUU7QUFBdEMsYUFISSxDQS9EZDs7QUFBQTtBQUFBLGtCQXVFTyxnQkFBZ0IsS0FBSyxLQXZFNUI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsZ0JBd0VVLFNBQVMsQ0FBQyxLQUFELENBeEVuQjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxnQkF5RVksT0FBTyxDQUFDLE9BekVwQjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkEwRWdCLElBQUksV0FBSixDQUNKLG9EQURJLEVBRUosb0JBRkksRUFFa0I7QUFBQyxjQUFBLElBQUksRUFBRSxtQkFBUDtBQUE0QixjQUFBLEtBQUssRUFBTDtBQUE1QixhQUZsQixDQTFFaEI7O0FBQUE7QUFBQSxpQkE4RVcsU0FBUyxDQUFDLEtBQUQsQ0E5RXBCO0FBQUE7QUFBQTtBQUFBOztBQUFBLGdCQWdGYyxjQUFjLENBQUMsS0FBRCxDQWhGNUI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBaUZrQixJQUFJLFdBQUosQ0FDSixrRUFDQSx3QkFGSSxFQUdKLG9CQUhJLEVBR2tCO0FBQUMsY0FBQSxJQUFJLEVBQUUsbUJBQVA7QUFBNEIsY0FBQSxLQUFLLEVBQUw7QUFBNUIsYUFIbEIsQ0FqRmxCOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLGlCQXNGa0IsUUFBUSxDQUFDLEtBQUQsQ0F0RjFCO0FBQUE7QUFBQTtBQUFBOztBQUFBLGdCQXVGYyxLQUFLLENBQUMsS0FBTixDQUFZLFVBQUEsQ0FBQztBQUFBLHFCQUFJLFNBQVMsQ0FBQyxDQUFELENBQWI7QUFBQSxhQUFiLENBdkZkO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQXdGa0IsSUFBSSxXQUFKLENBQ0osa0VBQ0Esd0JBRkksRUFHSixvQkFISSxFQUdrQjtBQUFDLGNBQUEsSUFBSSxFQUFFLG1CQUFQO0FBQTRCLGNBQUEsS0FBSyxFQUFMO0FBQTVCLGFBSGxCLENBeEZsQjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxrQkE4RmdCLElBQUksV0FBSixDQUNKLGtFQUNBLHdCQUZJLEVBR0osb0JBSEksRUFHa0I7QUFBQyxjQUFBLElBQUksRUFBRSxtQkFBUDtBQUE0QixjQUFBLEtBQUssRUFBTDtBQUE1QixhQUhsQixDQTlGaEI7O0FBQUE7QUFxR00sWUFBQSxTQUFTLENBQ1AsY0FETyxFQUNTLEtBRFQsRUFFUCxRQUFRLENBQUMsS0FBRCxDQUFSLENBQWdCLEdBQWhCLENBQW9CLFVBQUEsQ0FBQztBQUFBLHFCQUNuQixTQUFTLENBQUMsQ0FBRCxDQUFULEdBQWUsVUFBVSxDQUFDLFNBQUQsRUFBWSxDQUFaLEVBQWU7QUFBQyxnQkFBQSxJQUFJLEVBQUU7QUFBUCxlQUFmLEVBQTZCLE9BQTdCLENBQXpCLEdBQWlFLENBRDlDO0FBQUEsYUFBckIsQ0FGTyxFQUlQO0FBQUMsY0FBQSxlQUFlLEVBQUUsT0FBTyxDQUFDO0FBQTFCLGFBSk8sQ0FBVDs7QUFyR047O0FBQUE7QUFBQSxrQkE2R08sZ0JBQWdCLEtBQUssT0E3RzVCO0FBQUE7QUFBQTtBQUFBOztBQThHTTtBQUNBO0FBQ0EsZ0JBQUcsU0FBUyxDQUFDLEtBQUQsQ0FBWixFQUFxQjtBQUNuQixjQUFBLEtBQUssR0FBRyxNQUFNLENBQUMsV0FBUCxDQUFtQixNQUFNLENBQUMsT0FBUCxDQUFlLEtBQWYsRUFBc0IsR0FBdEIsQ0FBMEI7QUFBQTtBQUFBLG9CQUFFLENBQUY7QUFBQSxvQkFBSyxDQUFMOztBQUFBLHVCQUFZLENBQy9ELFVBQVUsQ0FBQyxpQkFBRCxFQUFvQixDQUFwQixFQUF1QjtBQUFDLGtCQUFBLEtBQUssRUFBRTtBQUFSLGlCQUF2QixDQURxRCxFQUUvRCxRQUFRLENBQUMsQ0FBRCxDQUFSLENBQVksR0FBWixDQUFnQixVQUFBLEVBQUU7QUFBQSx5QkFDaEIsVUFBVSxDQUFDLGlCQUFELEVBQW9CLEVBQXBCLEVBQXdCO0FBQUMsb0JBQUEsSUFBSSxFQUFFLElBQVA7QUFBYSxvQkFBQSxLQUFLLEVBQUU7QUFBcEIsbUJBQXhCLENBRE07QUFBQSxpQkFBbEIsQ0FGK0QsQ0FBWjtBQUFBLGVBQTFCLENBQW5CLENBQVI7QUFNRDs7QUFDRCxZQUFBLGtCQUFrQixDQUFDLEtBQUQsRUFBUSxPQUFPLENBQUMsT0FBaEIsQ0FBbEI7O0FBQ0EsWUFBQSxTQUFTLENBQ1AsY0FETyxFQUNTLE9BRFQsRUFFUCxRQUFRLENBQUMsS0FBRCxDQUFSLENBQWdCLEdBQWhCLENBQW9CLFVBQUEsQ0FBQztBQUFBLHFCQUNuQixTQUFTLENBQUMsQ0FBRCxDQUFULEdBQ0UsVUFBVSxDQUFDLGlCQUFELEVBQW9CLENBQXBCLEVBQ1I7QUFBQyxnQkFBQSxJQUFJLEVBQUUsSUFBUDtBQUFhLGdCQUFBLEtBQUssRUFBRTtBQUFwQixlQURRLEVBQ21CLE9BRG5CLENBRFosR0FFMEMsQ0FIdkI7QUFBQSxhQUFyQixDQUZPLEVBTVA7QUFBQyxjQUFBLGVBQWUsRUFBRSxPQUFPLENBQUM7QUFBMUIsYUFOTyxDQUFUOztBQXpITjs7QUFBQTtBQUFBLGtCQXNJTyxnQkFBZ0IsS0FBSyxXQUFyQixJQUFvQyxlQUFlLENBQUMsU0FBRCxFQUFZLEdBQVosQ0F0STFEO0FBQUE7QUFBQTtBQUFBOztBQUFBLDJCQXVJNkIsUUF2STdCO0FBQUE7QUFBQSxtQkF1STRDLEdBQUcsQ0FBQyxNQUFKLENBQVc7QUFDL0MsY0FBQSxTQUFTLEVBQVQsU0FEK0M7QUFFL0MsY0FBQSxjQUFjLEVBQWQsY0FGK0M7QUFHL0MsY0FBQSxPQUFPLEVBQUUsS0FIc0M7QUFJL0MsY0FBQSxPQUFPLEVBQVAsT0FKK0M7QUFLL0MsY0FBQSxZQUFZLEVBQVo7QUFMK0MsYUFBWCxDQXZJNUM7O0FBQUE7QUFBQTtBQXVJWSxZQUFBLGNBdklaOztBQUFBLGdCQWdKVSxjQUFjLENBQUMsS0FBZixDQUFxQixVQUFBLENBQUM7QUFBQSxxQkFBSSxVQUFVLENBQUMsQ0FBRCxDQUFkO0FBQUEsYUFBdEIsQ0FoSlY7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBaUpjLElBQUksV0FBSixDQUNKLDZCQUNBLGtEQUZJLEVBR0osb0JBSEksRUFHa0I7QUFBQyxjQUFBLElBQUksRUFBRSx5QkFBUDtBQUFrQyxjQUFBLEtBQUssRUFBTDtBQUFsQyxhQUhsQixDQWpKZDs7QUFBQTtBQXVKTSxZQUFBLFNBQVMsQ0FDUCxjQURPLEVBQ1MsV0FEVCxFQUNzQixjQUR0QixFQUNzQztBQUFDLGNBQUEsZUFBZSxFQUFFO0FBQWxCLGFBRHRDLENBQVQ7O0FBdkpOOztBQUFBO0FBQUEsa0JBNkpPLGdCQUFnQixLQUFLLFFBQXJCLElBQ0QsRUFBRSxTQUFTLENBQUMsS0FBRCxDQUFULElBQW9CLFFBQVEsQ0FBQyxLQUFELENBQTlCLENBOUpOO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQStKWSxJQUFJLFdBQUosQ0FDSiwyREFDQSxxQkFGSSxFQUdKLG9CQUhJLEVBR2tCO0FBQUMsY0FBQSxJQUFJLEVBQUUsc0JBQVA7QUFBK0IsY0FBQSxLQUFLLEVBQUw7QUFBL0IsYUFIbEIsQ0EvSlo7O0FBQUE7QUFBQSxrQkFxS08sZ0JBQWdCLEtBQUssUUFySzVCO0FBQUE7QUFBQTtBQUFBOztBQXNLTTtBQUNBO0FBQ0EsWUFBQSxlQUFlLEdBQUcsS0FBbEI7O0FBQ0EsZ0JBQUcsVUFBVSxJQUFJLGVBQWUsQ0FBQyxTQUFELEVBQVksR0FBWixDQUFoQyxFQUFrRDtBQUNoRDtBQUNBLGNBQUEsY0FBYyxDQUFDLFFBQUQsQ0FBZCxHQUEyQixLQUEzQjtBQUNELGFBSEQsTUFHTztBQUNMLGNBQUEsU0FBUyxDQUNQLGNBRE8sRUFDUyxRQURULEVBQ21CLEtBRG5CLEVBQzBCO0FBQUMsZ0JBQUEsZUFBZSxFQUFFLE9BQU8sQ0FBQztBQUExQixlQUQxQixDQUFUO0FBRUQ7O0FBL0tQOztBQUFBO0FBQUEsa0JBcUxPLGdCQUFnQixLQUFLLFdBckw1QjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFzTFMsS0FBSyxLQUFLLElBdExuQjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBLGtCQTBMUyxDQUFDLFNBQVMsQ0FBQyxLQUFELENBQVYsSUFBcUIsQ0FBQyxPQUFPLENBQUMsT0ExTHZDO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQTJMYyxJQUFJLFdBQUosQ0FDSiw2REFESSxFQUVKLG9CQUZJLEVBR0o7QUFBQyxjQUFBLElBQUksRUFBRSxnQ0FBUDtBQUF5QyxjQUFBLEtBQUssRUFBTDtBQUF6QyxhQUhJLENBM0xkOztBQUFBO0FBZ01NO0FBQ0EsWUFBQSxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUQsQ0FBUixDQUFnQixHQUFoQixDQUFvQixVQUFBLENBQUM7QUFBQSxxQkFBSSxTQUFTLENBQUMsQ0FBRCxDQUFULEdBQWUsQ0FBQyxDQUFDLFdBQUYsRUFBZixHQUFpQyxDQUFyQztBQUFBLGFBQXJCLENBQVIsQ0FqTU4sQ0FtTU07O0FBbk1OLG9EQW9Nd0IsS0FwTXhCOztBQUFBO0FBb01NLHFFQUF5QjtBQUFmLGdCQUFBLElBQWU7O0FBQ3ZCLG9CQUFHLFNBQVMsQ0FBQyxJQUFELENBQVQsSUFBbUIsQ0FBQyxJQUFJLENBQUMsS0FBTCxDQUFXLFdBQVgsQ0FBdkIsRUFBZ0Q7QUFDOUMsa0JBQUEsT0FBTyxDQUFDLElBQVIsMENBQStDLElBQS9DO0FBQ0Q7QUFDRjtBQXhNUDtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQTBNTSxZQUFBLFNBQVMsQ0FDUCxjQURPLEVBQ1MsV0FEVCxFQUNzQixLQUR0QixFQUM2QjtBQUFDLGNBQUEsZUFBZSxFQUFFLE9BQU8sQ0FBQztBQUExQixhQUQ3QixDQUFUOztBQTFNTjs7QUFBQTtBQUFBLGtCQWdOTyxnQkFBZ0IsS0FBSyxZQWhONUI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBaU5TLENBQUMsU0FBUyxDQUFDLEtBQUQsQ0FBVixJQUFxQixDQUFDLE9BQU8sQ0FBQyxPQWpOdkM7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBa05jLElBQUksV0FBSixDQUNKLDhEQURJLEVBRUosb0JBRkksRUFHSjtBQUFDLGNBQUEsSUFBSSxFQUFFLHdCQUFQO0FBQWlDLGNBQUEsS0FBSyxFQUFMO0FBQWpDLGFBSEksQ0FsTmQ7O0FBQUE7QUF3Tk0sWUFBQSxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUQsQ0FBaEIsQ0F4Tk4sQ0EwTk07O0FBMU5OLG9EQTJOdUIsS0EzTnZCO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEyTmdCLFlBQUEsR0EzTmhCOztBQUFBLGtCQTROVyxTQUFTLENBQUMsR0FBRCxDQUFULElBQWtCLEdBQUcsS0FBSyxLQUExQixJQUFtQyxHQUFHLEtBQUssS0E1TnREO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQTZOZ0IsSUFBSSxXQUFKLENBQ0osOERBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsY0FBQSxJQUFJLEVBQUUsd0JBQVA7QUFBaUMsY0FBQSxLQUFLLEVBQUw7QUFBakMsYUFISSxDQTdOaEI7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQW9PTSxZQUFBLFNBQVMsQ0FDUCxjQURPLEVBQ1MsWUFEVCxFQUN1QixLQUR2QixFQUVQO0FBQUMsY0FBQSxlQUFlLEVBQUUsT0FBTyxDQUFDO0FBQTFCLGFBRk8sQ0FBVDs7QUFwT047O0FBQUE7QUFBQSxrQkEyT08sZ0JBQWdCLEtBQUssUUEzTzVCO0FBQUE7QUFBQTtBQUFBOztBQUFBLGdCQTRPVSxTQUFTLENBQUMsS0FBRCxDQTVPbkI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBNk9jLElBQUksV0FBSixDQUNKLDBEQURJLEVBRUosb0JBRkksRUFHSjtBQUFDLGNBQUEsSUFBSSxFQUFFLHNCQUFQO0FBQStCLGNBQUEsS0FBSyxFQUFMO0FBQS9CLGFBSEksQ0E3T2Q7O0FBQUE7QUFrUE0sWUFBQSxTQUFTLENBQUMsY0FBRCxFQUFpQixRQUFqQixFQUEyQixLQUEzQixDQUFUOztBQWxQTjs7QUFBQTtBQUFBLGtCQXVQTyxnQkFBZ0IsS0FBSyxVQXZQNUI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsZ0JBd1BVLFNBQVMsQ0FBQyxLQUFELENBeFBuQjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkF5UGMsSUFBSSxXQUFKLENBQ0osNkRBREksRUFFSixvQkFGSSxFQUVrQjtBQUFDLGNBQUEsSUFBSSxFQUFFLHdCQUFQO0FBQWlDLGNBQUEsS0FBSyxFQUFMO0FBQWpDLGFBRmxCLENBelBkOztBQUFBO0FBQUE7QUFBQSxtQkE4UDRCLEdBQUcsQ0FBQyxNQUFKLENBQVc7QUFDL0IsY0FBQSxTQUFTLEVBQVQsU0FEK0I7QUFFL0IsY0FBQSxjQUFjLEVBQ2QsVUFIK0I7QUFJL0IsY0FBQSxPQUFPLEVBQUUsS0FKc0I7QUFLL0IsY0FBQSxPQUFPLEVBQVAsT0FMK0I7QUFNL0IsY0FBQSxZQUFZLEVBQVo7QUFOK0IsYUFBWCxDQTlQNUI7O0FBQUE7QUE4UE0sWUFBQSxhQTlQTjs7QUFzUU07QUFDQSxnQkFBRyxjQUFjLGFBQWpCLEVBQWdDO0FBQzlCLG1CQUFVLFFBQVYsSUFBc0IsYUFBYSxDQUFDLFVBQUQsQ0FBbkMsRUFBaUQ7QUFDL0MsZ0JBQUEsU0FBUyxDQUNQLGNBRE8sRUFDUyxRQURULEVBQ21CLGFBQWEsQ0FBQyxVQUFELENBQWIsQ0FBMEIsUUFBMUIsQ0FEbkIsRUFFUDtBQUFDLGtCQUFBLGVBQWUsRUFBRTtBQUFsQixpQkFGTyxDQUFUO0FBR0Q7QUFDRixhQTdRUCxDQStRTTtBQUNBOzs7QUFDSSxZQUFBLFVBalJWLEdBaVJ1QixjQUFjLENBQUMsVUFBRCxDQUFkLElBQThCLElBalJyRDtBQUFBLHdEQWtSNEIsYUFsUjVCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBa1JnQixZQUFBLFNBbFJoQjs7QUFBQSxrQkFtUlcsU0FBUSxLQUFLLFVBblJ4QjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQXNSUSxnQkFBRyxVQUFVLEtBQUssSUFBbEIsRUFBd0I7QUFDdEIsY0FBQSxVQUFVLEdBQUcsY0FBYyxDQUFDLFVBQUQsQ0FBZCxHQUE2QixFQUExQztBQUNEOztBQUNELFlBQUEsU0FBUyxDQUFDLFVBQUQsRUFBYSxTQUFiLEVBQXVCLEVBQXZCLEVBQTJCO0FBQUMsY0FBQSxlQUFlLEVBQUU7QUFBbEIsYUFBM0IsQ0FBVDs7QUFDTSxZQUFBLEtBMVJkLEdBMFJzQixhQUFhLENBQUMsU0FBRCxDQTFSbkM7QUEyUmdCLFlBQUEsRUEzUmhCLEdBMlJxQixDQTNSckI7O0FBQUE7QUFBQSxrQkEyUndCLEVBQUUsR0FBRyxLQUFLLENBQUMsTUEzUm5DO0FBQUE7QUFBQTtBQUFBOztBQTRSZ0IsWUFBQSxJQTVSaEIsR0E0UnVCLEtBQUssQ0FBQyxFQUFELENBNVI1Qjs7QUFBQSxrQkE2UmEsUUFBUSxDQUFDLElBQUQsQ0FBUixJQUFrQixPQUFPLENBQUMsSUFBRCxDQTdSdEM7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBOFJrQixJQUFJLFdBQUosQ0FDSiw0REFDQSxxQkFGSSxFQUVtQixvQkFGbkIsRUFHSjtBQUFDLGNBQUEsSUFBSSxFQUFFLGdDQUFQO0FBQXlDLGNBQUEsS0FBSyxFQUFFO0FBQWhELGFBSEksQ0E5UmxCOztBQUFBO0FBbVNVLFlBQUEsU0FBUyxDQUFDLFVBQUQsRUFBYSxTQUFiLEVBQXVCLElBQXZCLEVBQTZCO0FBQUMsY0FBQSxlQUFlLEVBQUU7QUFBbEIsYUFBN0IsQ0FBVDs7QUFuU1Y7QUEyUjJDLGNBQUUsRUEzUjdDO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBLGtCQTJTTyxnQkFBZ0IsS0FBSyxPQTNTNUI7QUFBQTtBQUFBO0FBQUE7O0FBNFNNLFlBQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxLQUFYO0FBNVNOOztBQUFBO0FBZ1RJO0FBQ0ksWUFBQSxPQWpUUixHQWlUa0IsU0FqVGxCO0FBa1RVLFlBQUEsR0FsVFYsR0FrVGdCLGdCQUFnQixDQUFDLFNBQUQsRUFBWSxLQUFaLEVBQWlCLFVBQWpCLENBbFRoQzs7QUFBQSxnQkFtVFEsWUFBWSxDQUFDLEdBQUQsQ0FuVHBCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBb1RzQixlQUFlLENBQUM7QUFDOUIsY0FBQSxTQUFTLEVBQVQsU0FEOEI7QUFFOUIsY0FBQSxRQUFRLEVBQUUsR0FGb0I7QUFHOUIsY0FBQSxTQUFTLEVBQUUsSUFIbUI7QUFJOUIsY0FBQSxpQkFBaUIsRUFBRSxJQUpXO0FBSzlCLGNBQUEsT0FBTyxFQUFQO0FBTDhCLGFBQUQsQ0FwVHJDOztBQUFBO0FBb1RNLFlBQUEsT0FwVE47O0FBQUE7QUE2VFUsWUFBQSxTQTdUVixHQTZUc0IsZ0JBQWdCLENBQUMsT0FBRCxFQUFVLEtBQVYsRUFBZSxZQUFmLENBQWhCLElBQWdELEVBN1R0RTs7QUFBQSxrQkErVE8sU0FBUyxDQUFDLFFBQVYsQ0FBbUIsV0FBbkIsS0FBbUMsU0FBUyxDQUFDLEtBQUQsQ0EvVG5EO0FBQUE7QUFBQTtBQUFBOztBQWdVWSxZQUFBLFNBaFVaLEdBZ1V3QixnQkFBZ0IsQ0FBQyxPQUFELEVBQVUsS0FBVixFQUFlLFlBQWYsQ0FoVXhDLEVBaVVNOztBQUNBLFlBQUEsYUFBYSxHQUFHLGtCQUFrQixDQUFDLE9BQUQsRUFBVSxLQUFWLEVBQWlCLFNBQWpCLEVBQTRCLE9BQTVCLENBQWxDO0FBbFVOO0FBQUE7O0FBQUE7QUFBQSxrQkFtVWMsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsUUFBbkIsS0FBZ0MsU0FBUyxDQUFDLEtBQUQsQ0FuVXZEO0FBQUE7QUFBQTtBQUFBOztBQW9VTTtBQUNNLFlBQUEsT0FyVVosR0FxVXNCLFNBQVMsQ0FBQyxRQUFWLENBQW1CLFFBQW5CLENBclV0QjtBQXNVWSxZQUFBLFFBdFVaLEdBc1V1QixnQkFBZ0IsQ0FBQyxPQUFELEVBQVUsS0FBVixFQUFlLFFBQWYsQ0FBaEIsSUFBNEMsUUF0VW5FO0FBdVVZLFlBQUEsYUF2VVosR0F1VTRCLFFBQVEsS0FBSyxRQUFiLElBQ3BCLFVBQVUsQ0FBQyxTQUFELEVBQVksUUFBWixFQUFzQjtBQUFDLGNBQUEsS0FBSyxFQUFFO0FBQVIsYUFBdEIsRUFBcUMsT0FBckMsQ0F4VWxCO0FBQUE7QUFBQSxtQkEwVTRCLGVBQWUsQ0FBQztBQUNwQyxjQUFBLFNBQVMsRUFBRSxPQUR5QjtBQUVwQyxjQUFBLE9BQU8sRUFBUCxPQUZvQztBQUdwQyxjQUFBLGNBQWMsRUFBRSxLQUhvQjtBQUlwQyxjQUFBLEtBQUssRUFBTCxLQUpvQztBQUtwQyxjQUFBLFlBQVksRUFBWixZQUxvQztBQU1wQyxjQUFBLE9BQU8sRUFBUCxPQU5vQztBQU9wQyxjQUFBLFFBQVEsRUFBUixRQVBvQztBQVFwQyxjQUFBLGFBQWEsRUFBYjtBQVJvQyxhQUFELENBMVUzQzs7QUFBQTtBQTBVTSxZQUFBLGFBMVVOO0FBQUE7QUFBQTs7QUFBQTtBQUFBLGtCQW9WYyxTQUFTLENBQUMsUUFBVixDQUFtQixLQUFuQixLQUE2QixTQUFTLENBQUMsS0FBRCxDQXBWcEQ7QUFBQTtBQUFBO0FBQUE7O0FBcVZNO0FBQ00sWUFBQSxRQXRWWixHQXNWc0IsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsUUFBbkIsQ0F0VnRCO0FBQUE7QUFBQSxtQkF1VjRCLGVBQWUsQ0FBQztBQUNwQyxjQUFBLFNBQVMsRUFBRSxPQUR5QjtBQUVwQyxjQUFBLE9BQU8sRUFBUCxPQUZvQztBQUdwQyxjQUFBLGNBQWMsRUFBRSxLQUhvQjtBQUlwQyxjQUFBLEtBQUssRUFBTCxLQUpvQztBQUtwQyxjQUFBLFlBQVksRUFBWixZQUxvQztBQU1wQyxjQUFBLE9BQU8sRUFBUCxRQU5vQztBQU9wQyxjQUFBLFFBQVEsRUFBRTtBQVAwQixhQUFELENBdlYzQzs7QUFBQTtBQXVWTSxZQUFBLGFBdlZOO0FBQUE7QUFBQTs7QUFBQTtBQUFBLGtCQWdXYyxTQUFTLENBQUMsUUFBVixDQUFtQixPQUFuQixLQUErQixTQUFTLENBQUMsS0FBRCxDQWhXdEQ7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkFrVzRCLGVBQWUsQ0FBQztBQUNwQztBQUNBLGNBQUEsU0FBUyxFQUFFLE9BQU8sQ0FBQyx1QkFBUixFQUZ5QjtBQUdwQyxjQUFBLE9BQU8sRUFBUCxPQUhvQztBQUlwQyxjQUFBLGNBQWMsRUFBRSxLQUpvQjtBQUtwQyxjQUFBLEtBQUssRUFBTCxLQUxvQztBQU1wQyxjQUFBLFlBQVksRUFBWixZQU5vQztBQU9wQyxjQUFBLE9BQU8sRUFBRSxLQVAyQjtBQVFwQyxjQUFBLFFBQVEsRUFBRTtBQVIwQixhQUFELENBbFczQzs7QUFBQTtBQWtXTSxZQUFBLGFBbFdOO0FBQUE7QUFBQTs7QUFBQTtBQTZXTTtBQUNNLFlBQUEsTUE5V1osR0E4V3NCLGdCQUFnQixLQUFLLE9BOVczQzs7QUFBQSxrQkErV1MsTUFBTSxJQUFJLGdCQUFnQixLQUFLLE1BL1d4QztBQUFBO0FBQUE7QUFBQTs7QUFnWFksWUFBQSxrQkFoWFosR0FnWGlDLGNBaFhqQzs7QUFpWFEsZ0JBQUcsTUFBTSxJQUFJLHNCQUFzQixLQUFLLFFBQXhDLEVBQWtEO0FBQ2hELGNBQUEsa0JBQWtCLEdBQUcsSUFBckI7QUFDRDs7QUFuWFQ7QUFBQSxtQkFvWDhCLEdBQUcsQ0FBQyxNQUFKLENBQVc7QUFDL0IsY0FBQSxTQUFTLEVBQUUsT0FEb0I7QUFFL0IsY0FBQSxjQUFjLEVBQUUsa0JBRmU7QUFHL0IsY0FBQSxPQUFPLEVBQUUsS0FIc0I7QUFJL0IsY0FBQSxPQUFPLEVBQVAsT0FKK0I7QUFLL0IsY0FBQSxVQUFVLEVBQUUsTUFMbUI7QUFNL0IsY0FBQSxZQUFZLEVBQVo7QUFOK0IsYUFBWCxDQXBYOUI7O0FBQUE7QUFvWFEsWUFBQSxhQXBYUjtBQUFBO0FBQUE7O0FBQUE7QUFBQSxrQkE2WFEsZ0JBQWdCLENBQUMsU0FBRCxFQUFZLEtBQVosRUFBaUIsT0FBakIsQ0FBaEIsS0FBOEMsT0E3WHREO0FBQUE7QUFBQTtBQUFBOztBQThYUSxZQUFBLGFBQWEsR0FBRztBQUNkLHVCQUFTLE9BREs7QUFFZCx3QkFBVTtBQUZJLGFBQWhCO0FBOVhSO0FBQUE7O0FBQUE7QUFBQTtBQUFBLG1CQW9ZOEIsR0FBRyxDQUFDLE1BQUosQ0FBVztBQUMvQixjQUFBLFNBQVMsRUFBRSxPQURvQjtBQUUvQixjQUFBLGNBQWMsRUFBRSxLQUZlO0FBRy9CLGNBQUEsT0FBTyxFQUFFLEtBSHNCO0FBSS9CLGNBQUEsT0FBTyxFQUFQLE9BSitCO0FBSy9CLGNBQUEsVUFBVSxFQUFFLEtBTG1CO0FBTS9CLGNBQUEsWUFBWSxFQUFaO0FBTitCLGFBQVgsQ0FwWTlCOztBQUFBO0FBb1lRLFlBQUEsYUFwWVI7O0FBQUE7QUFBQSxrQkFnWk8sYUFBYSxLQUFLLElBQWxCLElBQTBCLGdCQUFnQixLQUFLLFFBaFp0RDtBQUFBO0FBQUE7QUFBQTs7QUFpWk07QUFDQSxZQUFBLGFBQWEsR0FBRyxZQUFZLENBQUM7QUFDM0IsY0FBQSxhQUFhLEVBQUUsS0FEWTtBQUUzQixjQUFBLGdCQUFnQixFQUFoQixnQkFGMkI7QUFHM0IsY0FBQSxTQUFTLEVBQUUsT0FIZ0I7QUFJM0IsY0FBQSxjQUFjLEVBQWQsY0FKMkI7QUFLM0IsY0FBQSxNQUFNLEVBQUUsT0FMbUI7QUFNM0IsY0FBQSxPQUFPLEVBQVAsT0FOMkI7QUFPM0IsY0FBQSxVQUFVLEVBQVYsVUFQMkI7QUFRM0IsY0FBQSxHQUFHLEVBQUgsS0FSMkI7QUFTM0IsY0FBQSxjQUFjLEVBQWQ7QUFUMkIsYUFBRCxDQUE1Qjs7QUFsWk4sa0JBNlpTLGFBQWEsS0FBSyxTQTdaM0I7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFrYUk7QUFDQSxnQkFBRyxnQkFBZ0IsS0FBSyxPQUFyQixJQUFnQyxDQUFDLE9BQU8sQ0FBQyxhQUFELENBQXhDLElBQ0QsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsT0FBbkIsQ0FERixFQUMrQjtBQUM3QjtBQUNBLGNBQUEsYUFBYSxHQUFHO0FBQUMseUJBQVMsUUFBUSxDQUFDLGFBQUQ7QUFBbEIsZUFBaEI7QUFDRCxhQXZhTCxDQXlhSTtBQUNBO0FBQ0E7OztBQUNBLGdCQUFHLFNBQVMsQ0FBQyxRQUFWLENBQW1CLFFBQW5CLEtBQ0QsQ0FBQyxTQUFTLENBQUMsSUFBVixDQUFlLFVBQUEsR0FBRztBQUFBLHFCQUFJLEdBQUcsS0FBSyxLQUFSLElBQWlCLEdBQUcsS0FBSyxRQUE3QjtBQUFBLGFBQWxCLENBREgsRUFDNkQ7QUFDM0Q7QUFDQSxjQUFBLGFBQWEsR0FBRyxRQUFRLENBQUMsYUFBRCxDQUFSLENBQ2IsR0FEYSxDQUNULFVBQUEsQ0FBQztBQUFBLHVCQUFLO0FBQUMsNEJBQVUsUUFBUSxDQUFDLENBQUQ7QUFBbkIsaUJBQUw7QUFBQSxlQURRLENBQWhCO0FBRUQsYUFqYkwsQ0FtYkk7QUFDQTs7O0FBcGJKLGtCQXFiTyxPQUFPLENBQUMsUUFBUixDQUFpQixHQUFqQixDQUFxQixLQUFyQixLQUE2QixPQUFPLENBQUMsUUFBUixDQUFpQixHQUFqQixDQUFxQixLQUFyQixFQUEwQixPQXJiOUQ7QUFBQTtBQUFBO0FBQUE7O0FBc2JZLFlBQUEsV0F0YlosR0F1YlEsY0FBYyxDQUFDLFVBQUQsQ0FBZCxHQUE2QixjQUFjLENBQUMsVUFBRCxDQUFkLElBQThCLEVBdmJuRTtBQXdiTSxZQUFBLGFBQWEsR0FBRyxRQUFRLENBQUMsYUFBRCxDQUF4QjtBQUNRLFlBQUEsR0F6YmQsR0F5Ym1CLENBemJuQjs7QUFBQTtBQUFBLGtCQXlic0IsR0FBRSxHQUFHLGFBQWEsQ0FBQyxNQXpiekM7QUFBQTtBQUFBO0FBQUE7O0FBMGJjLFlBQUEsS0ExYmQsR0EwYnFCLGFBQWEsQ0FBQyxHQUFELENBMWJsQzs7QUFBQSxrQkEyYlcsUUFBUSxDQUFDLEtBQUQsQ0FBUixJQUFrQixPQUFPLENBQUMsS0FBRCxDQTNicEM7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBNGJnQixJQUFJLFdBQUosQ0FDSiw0REFDQSxxQkFGSSxFQUVtQixvQkFGbkIsRUFHSjtBQUFDLGNBQUEsSUFBSSxFQUFFLGdDQUFQO0FBQXlDLGNBQUEsS0FBSyxFQUFFO0FBQWhELGFBSEksQ0E1YmhCOztBQUFBO0FBaWNRLFlBQUEsU0FBUyxDQUFDLFdBQUQsRUFBYSxnQkFBYixFQUErQixLQUEvQixFQUFxQztBQUFDLGNBQUEsZUFBZSxFQUFFO0FBQWxCLGFBQXJDLENBQVQ7O0FBamNSO0FBeWJpRCxjQUFFLEdBemJuRDtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQXNjSTtBQUNBO0FBQ0EsWUFBQSxTQUFTLENBQUMsY0FBRCxFQUFpQixnQkFBakIsRUFBbUMsYUFBbkMsRUFBa0Q7QUFDekQsY0FBQSxlQUFlLEVBQUU7QUFEd0MsYUFBbEQsQ0FBVDs7QUF4Y0o7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBLGtCQStjSyxZQUFZLGNBL2NqQjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFnZE8sY0FBYyxDQUFDLE9BQUQsQ0FBZCxLQUE0QixPQUE1QixJQUF1QyxlQUFlLENBQUMsU0FBRCxFQUFZLEdBQVosQ0FoZDdEO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQSxrQkFtZGMsQ0FBQyxTQUFTLENBQUMsZUFBRCxDQUFULElBQThCLFFBQVEsQ0FBQyxlQUFELENBQXZDLEtBQ1IsQ0FBQyxPQUFPLENBQUMsT0FwZGY7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBcWRZLElBQUksV0FBSixDQUNKLDJEQUNBLHFCQUZJLEVBR0osb0JBSEksRUFJSjtBQUFDLGNBQUEsSUFBSSxFQUFFLDRCQUFQO0FBQXFDLGNBQUEsS0FBSyxFQUFFO0FBQTVDLGFBSkksQ0FyZFo7O0FBQUE7QUFBQSw2QkE4ZG1CLEtBOWRuQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQThkWSxZQUFBLEdBOWRaO0FBK2RVLFlBQUEsWUEvZFYsR0ErZHlCLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRCxDQUFSLENBQVIsR0FBeUIsT0FBTyxDQUFDLEdBQUQsQ0FBaEMsR0FBd0MsQ0FBQyxPQUFPLENBQUMsR0FBRCxDQUFSLENBL2RqRTtBQUFBLG9EQWdlb0IsWUFoZXBCO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFnZWMsWUFBQSxFQWhlZDs7QUFBQSxrQkFpZVMsQ0FBQyxTQUFTLENBQUMsRUFBRCxDQUFWLElBQWtCLE1BQU0sQ0FBQyxJQUFQLENBQVksRUFBWixFQUFnQixJQUFoQixDQUFxQixVQUFBLENBQUM7QUFBQSxxQkFDekMsVUFBVSxDQUFDLFNBQUQsRUFBWSxDQUFaLEVBQWU7QUFBQyxnQkFBQSxLQUFLLEVBQUU7QUFBUixlQUFmLEVBQThCLE9BQTlCLENBQVYsS0FBcUQsUUFEWjtBQUFBLGFBQXRCLENBamUzQjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFtZWMsSUFBSSxXQUFKLENBQ0osNkRBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsY0FBQSxJQUFJLEVBQUUscUJBQVA7QUFBOEIsY0FBQSxLQUFLLEVBQUU7QUFBckMsYUFISSxDQW5lZDs7QUFBQTtBQUFBO0FBQUEsbUJBd2VZLGFBQWEsQ0FBQztBQUNsQixjQUFBLFNBQVMsRUFBVCxTQURrQjtBQUVsQixjQUFBLGNBQWMsRUFBZCxjQUZrQjtBQUdsQixjQUFBLHNCQUFzQixFQUF0QixzQkFIa0I7QUFJbEIsY0FBQSxPQUFPLEVBQUUsRUFKUztBQUtsQixjQUFBLGNBQWMsRUFBZCxjQUxrQjtBQU1sQixjQUFBLE9BQU8sRUFBUCxPQU5rQjtBQU9sQixjQUFBLFVBQVUsRUFBVixVQVBrQjtBQVFsQixjQUFBLGlCQUFpQixFQUFqQixpQkFSa0I7QUFTbEIsY0FBQSxPQUFPLEVBQVAsT0FUa0I7QUFVbEIsY0FBQSxZQUFZLEVBQVo7QUFWa0IsYUFBRCxDQXhlekI7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHOzs7O0FBa2dCQSxTQUFTLFlBQVQsUUFBbUU7QUFBQSxNQUE1QyxTQUE0QyxTQUE1QyxTQUE0QztBQUFBLE1BQWpDLGNBQWlDLFNBQWpDLGNBQWlDO0FBQUEsTUFBakIsS0FBaUIsU0FBakIsS0FBaUI7QUFBQSxNQUFWLE9BQVUsU0FBVixPQUFVOztBQUNqRTtBQUNBLE1BQUcsS0FBSyxLQUFLLElBQVYsSUFBa0IsS0FBSyxLQUFLLFNBQS9CLEVBQTBDO0FBQ3hDLFdBQU8sSUFBUDtBQUNELEdBSmdFLENBTWpFOzs7QUFDQSxNQUFNLGdCQUFnQixHQUFHLFVBQVUsQ0FDakMsU0FEaUMsRUFDdEIsY0FEc0IsRUFDTjtBQUFDLElBQUEsS0FBSyxFQUFFO0FBQVIsR0FETSxFQUNTLE9BRFQsQ0FBbkM7O0FBRUEsTUFBRyxnQkFBZ0IsS0FBSyxLQUF4QixFQUErQjtBQUM3QixXQUFPLFVBQVUsQ0FBQyxTQUFELEVBQVksS0FBWixFQUFtQjtBQUFDLE1BQUEsSUFBSSxFQUFFO0FBQVAsS0FBbkIsRUFBaUMsT0FBakMsQ0FBakI7QUFDRCxHQUZELE1BRU8sSUFBRyxnQkFBZ0IsS0FBSyxPQUF4QixFQUFpQztBQUN0QyxXQUFPLFVBQVUsQ0FBQyxTQUFELEVBQVksS0FBWixFQUFtQjtBQUFDLE1BQUEsS0FBSyxFQUFFLElBQVI7QUFBYyxNQUFBLElBQUksRUFBRTtBQUFwQixLQUFuQixFQUE4QyxPQUE5QyxDQUFqQjtBQUNELEdBYmdFLENBZWpFOzs7QUFDQSxNQUFNLElBQUksR0FBRyxnQkFBZ0IsQ0FBQyxTQUFELEVBQVksY0FBWixFQUE0QixPQUE1QixDQUE3QixDQWhCaUUsQ0FrQmpFOzs7QUFDQSxNQUFHLENBQUMsSUFBSSxLQUFLLEtBQVQsSUFBa0IsZ0JBQWdCLEtBQUssUUFBeEMsS0FBcUQsU0FBUyxDQUFDLEtBQUQsQ0FBakUsRUFBMEU7QUFDeEUsV0FBTztBQUFDLGFBQU8sVUFBVSxDQUFDLFNBQUQsRUFBWSxLQUFaLEVBQW1CO0FBQUMsUUFBQSxJQUFJLEVBQUU7QUFBUCxPQUFuQixFQUFpQyxPQUFqQztBQUFsQixLQUFQO0FBQ0QsR0FyQmdFLENBc0JqRTs7O0FBQ0EsTUFBRyxJQUFJLEtBQUssUUFBVCxJQUFxQixTQUFTLENBQUMsS0FBRCxDQUFqQyxFQUEwQztBQUN4QyxXQUFPO0FBQ0wsYUFBTyxVQUFVLENBQUMsU0FBRCxFQUFZLEtBQVosRUFBbUI7QUFBQyxRQUFBLEtBQUssRUFBRSxJQUFSO0FBQWMsUUFBQSxJQUFJLEVBQUU7QUFBcEIsT0FBbkIsRUFBOEMsT0FBOUM7QUFEWixLQUFQO0FBR0QsR0EzQmdFLENBNkJqRTs7O0FBQ0EsTUFBRyxVQUFVLENBQUMsZ0JBQUQsQ0FBYixFQUFpQztBQUMvQixXQUFPLEtBQVA7QUFDRDs7QUFFRCxNQUFNLElBQUksR0FBRyxFQUFiOztBQUVBLE1BQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFELEVBQVEsUUFBUixFQUFrQixPQUFsQixFQUEyQixRQUEzQixDQUFvQyxJQUFwQyxDQUFaLEVBQXVEO0FBQ3JEO0FBQ0EsSUFBQSxJQUFJLENBQUMsT0FBRCxDQUFKLEdBQWdCLElBQWhCO0FBQ0QsR0FIRCxNQUdPLElBQUcsU0FBUyxDQUFDLEtBQUQsQ0FBWixFQUFxQjtBQUMxQjtBQUNBLFFBQU0sUUFBUSxHQUFHLGdCQUFnQixDQUFDLFNBQUQsRUFBWSxjQUFaLEVBQTRCLFdBQTVCLENBQWpDOztBQUNBLFFBQUcsUUFBUSxLQUFLLElBQWhCLEVBQXNCO0FBQ3BCLE1BQUEsSUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQixRQUFwQjtBQUNEOztBQUNELFFBQU0sU0FBUyxHQUFHLGdCQUFnQixDQUFDLFNBQUQsRUFBWSxjQUFaLEVBQTRCLFlBQTVCLENBQWxDOztBQUNBLFFBQUcsU0FBUyxLQUFLLElBQWpCLEVBQXVCO0FBQ3JCLE1BQUEsSUFBSSxDQUFDLFlBQUQsQ0FBSixHQUFxQixTQUFyQjtBQUNEO0FBQ0YsR0FqRGdFLENBa0RqRTs7O0FBQ0EsTUFBRyxDQUFDLENBQUMsU0FBRCxFQUFZLFFBQVosRUFBc0IsUUFBdEIsRUFBZ0MsUUFBaEMsMEJBQWdELEtBQWhELEVBQUosRUFBNEQ7QUFDMUQsSUFBQSxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQU4sRUFBUjtBQUNEOztBQUNELEVBQUEsSUFBSSxDQUFDLFFBQUQsQ0FBSixHQUFpQixLQUFqQjtBQUVBLFNBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsa0JBQVQsQ0FBNEIsU0FBNUIsRUFBdUMsV0FBdkMsRUFBb0QsU0FBcEQsRUFBK0QsT0FBL0QsRUFBd0U7QUFDdEUsTUFBTSxJQUFJLEdBQUcsRUFBYjtBQUNBLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksV0FBWixFQUF5QixJQUF6QixFQUFiOztBQUZzRSw4Q0FHckQsSUFIcUQ7QUFBQTs7QUFBQTtBQUd0RSwyREFBdUI7QUFBQSxVQUFiLEdBQWE7O0FBQ3JCLFVBQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxTQUFELEVBQVksR0FBWixFQUFpQjtBQUFDLFFBQUEsS0FBSyxFQUFFO0FBQVIsT0FBakIsRUFBZ0MsT0FBaEMsQ0FBOUI7O0FBQ0EsVUFBSSxHQUFHLEdBQUcsV0FBVyxDQUFDLEdBQUQsQ0FBckI7O0FBQ0EsVUFBRyxDQUFDLFFBQVEsQ0FBQyxHQUFELENBQVosRUFBbUI7QUFDakIsUUFBQSxHQUFHLEdBQUcsQ0FBQyxHQUFELENBQU47QUFDRDs7QUFMb0Isa0RBTUgsR0FORztBQUFBOztBQUFBO0FBTXJCLCtEQUF1QjtBQUFBLGNBQWIsSUFBYTs7QUFDckIsY0FBRyxJQUFJLEtBQUssSUFBWixFQUFrQjtBQUNoQjtBQUNBO0FBQ0Q7O0FBQ0QsY0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFELENBQWIsRUFBcUI7QUFDbkIsa0JBQU0sSUFBSSxXQUFKLENBQ0osOERBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsY0FBQSxJQUFJLEVBQUUsNEJBQVA7QUFBcUMsY0FBQSxXQUFXLEVBQVg7QUFBckMsYUFISSxDQUFOO0FBSUQ7O0FBQ0QsY0FBTSxJQUFHLEdBQUc7QUFBQyxzQkFBVTtBQUFYLFdBQVo7O0FBQ0EsY0FBRyxXQUFXLEtBQUssT0FBbkIsRUFBNEI7QUFDMUIsWUFBQSxJQUFHLENBQUMsV0FBRCxDQUFILEdBQW1CLEdBQUcsQ0FBQyxXQUFKLEVBQW5CO0FBQ0Q7O0FBQ0QsY0FBRyxTQUFILEVBQWM7QUFDWixZQUFBLElBQUcsQ0FBQyxZQUFELENBQUgsR0FBb0IsU0FBcEI7QUFDRDs7QUFDRCxVQUFBLElBQUksQ0FBQyxJQUFMLENBQVUsSUFBVjtBQUNEO0FBekJvQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBMEJ0QjtBQTdCcUU7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUE4QnRFLFNBQU8sSUFBUDtBQUNEOztTQUVjLGU7Ozs7O21HQUFmO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDRyxZQUFBLFNBREgsU0FDRyxTQURILEVBQ2MsT0FEZCxTQUNjLE9BRGQsRUFDdUIsY0FEdkIsU0FDdUIsY0FEdkIsRUFDdUMsS0FEdkMsU0FDdUMsS0FEdkMsRUFDOEMsWUFEOUMsU0FDOEMsWUFEOUMsRUFDNEQsT0FENUQsU0FDNEQsT0FENUQsRUFFSSxRQUZKLFNBRUksUUFGSixFQUVjLGFBRmQsU0FFYyxhQUZkO0FBR1EsWUFBQSxJQUhSLEdBR2UsRUFIZjtBQUlRLFlBQUEsSUFKUixHQUllLE1BQU0sQ0FBQyxJQUFQLENBQVksS0FBWixFQUFtQixJQUFuQixFQUpmO0FBS1EsWUFBQSxXQUxSLEdBS3NCLFFBQVEsS0FBSyxPQUxuQztBQUFBLHFEQU1pQixJQU5qQjtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTVUsWUFBQSxHQU5WOztBQUFBLGlCQVFPLFdBUlA7QUFBQTtBQUFBO0FBQUE7O0FBU1ksWUFBQSxHQVRaLEdBU2tCLGdCQUFnQixDQUFDLFNBQUQsRUFBWSxHQUFaLEVBQWlCLFVBQWpCLENBVGxDOztBQUFBLGdCQVVVLFlBQVksQ0FBQyxHQUFELENBVnRCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBVzBCLGVBQWUsQ0FBQztBQUNoQyxjQUFBLFNBQVMsRUFBVCxTQURnQztBQUVoQyxjQUFBLFFBQVEsRUFBRSxHQUZzQjtBQUdoQyxjQUFBLFNBQVMsRUFBRSxLQUhxQjtBQUloQyxjQUFBLE9BQU8sRUFBUDtBQUpnQyxhQUFELENBWHpDOztBQUFBO0FBV1EsWUFBQSxTQVhSOztBQUFBO0FBb0JRLFlBQUEsR0FwQlIsR0FvQmMsS0FBSyxDQUFDLEdBQUQsQ0FwQm5COztBQXFCSSxnQkFBRyxDQUFDLFFBQVEsQ0FBQyxHQUFELENBQVosRUFBbUI7QUFDakIsY0FBQSxHQUFHLEdBQUcsQ0FBQyxHQUFELENBQU47QUFDRDs7QUF2Qkw7QUFBQSxtQkF5QmdCLEdBQUcsQ0FBQyxNQUFKLENBQVc7QUFDckIsY0FBQSxTQUFTLEVBQVQsU0FEcUI7QUFFckIsY0FBQSxjQUFjLEVBQWQsY0FGcUI7QUFHckIsY0FBQSxPQUFPLEVBQUUsR0FIWTtBQUlyQixjQUFBLE9BQU8sRUFBUCxPQUpxQjtBQUtyQixjQUFBLFVBQVUsRUFBRSxLQUxTO0FBTXJCLGNBQUEsV0FBVyxFQUFFLElBTlE7QUFPckIsY0FBQSxZQUFZLEVBQVo7QUFQcUIsYUFBWCxDQXpCaEI7O0FBQUE7QUF5QkksWUFBQSxHQXpCSjtBQW1DSTtBQUNJLFlBQUEsV0FwQ1I7O0FBcUNJLGdCQUFHLGFBQUgsRUFBa0I7QUFDaEIsa0JBQUcsR0FBRyxLQUFLLE9BQVgsRUFBb0I7QUFDbEIsZ0JBQUEsV0FBVyxHQUFHLE9BQWQ7QUFDRCxlQUZELE1BRU87QUFDTCxnQkFBQSxXQUFXLEdBQUcsWUFBWSxDQUN4QjtBQUFDLGtCQUFBLFNBQVMsRUFBVCxTQUFEO0FBQVksa0JBQUEsY0FBYyxFQUFFLFFBQTVCO0FBQXNDLGtCQUFBLEtBQUssRUFBRSxHQUE3QztBQUFrRCxrQkFBQSxPQUFPLEVBQVA7QUFBbEQsaUJBRHdCLENBQTFCO0FBRUQ7QUFDRixhQVBELE1BT087QUFDTCxjQUFBLFdBQVcsR0FBRyxVQUFVLENBQUMsU0FBRCxFQUFZLEdBQVosRUFBaUI7QUFBQyxnQkFBQSxLQUFLLEVBQUU7QUFBUixlQUFqQixFQUFnQyxPQUFoQyxDQUF4QjtBQUNEOztBQUVELGdCQUFHLFFBQVEsS0FBSyxLQUFoQixFQUF1QjtBQUNyQjtBQUNBLGNBQUEsR0FBRyxHQUFHLFVBQVUsQ0FBQyxTQUFELEVBQVksR0FBWixFQUFpQjtBQUFDLGdCQUFBLElBQUksRUFBRTtBQUFQLGVBQWpCLEVBQStCLE9BQS9CLENBQWhCO0FBQ0QsYUFIRCxNQUdPLElBQUcsV0FBSCxFQUFnQjtBQUNyQixjQUFBLEdBQUcsR0FBRyxXQUFOO0FBQ0Q7O0FBckRMLHFEQXVEb0IsR0F2RHBCO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF1RFksWUFBQSxJQXZEWjs7QUF3RE07QUFDQSxnQkFBRyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBRCxDQUF2QixFQUErQjtBQUM3QixjQUFBLElBQUksR0FBRztBQUFDLDBCQUFVLENBQUMsSUFBRDtBQUFYLGVBQVA7QUFDRDs7QUEzRFAsa0JBNERTLFFBQVEsS0FBSyxPQTVEdEI7QUFBQTtBQUFBO0FBQUE7O0FBNkRRLGdCQUFHLFdBQVcsS0FBSyxPQUFuQixFQUE0QixDQUMxQjtBQUNELGFBRkQsTUFFTyxJQUFHLElBQUksQ0FBQyxPQUFELENBQVAsRUFBa0I7QUFDdkIsY0FBQSxJQUFJLENBQUMsT0FBRCxDQUFKLEdBQWdCLENBQUMsR0FBRCxFQUFNLE1BQU4sQ0FBYSxJQUFJLENBQUMsT0FBRCxDQUFqQixDQUFoQjtBQUNELGFBRk0sTUFFQTtBQUNMLGNBQUEsSUFBSSxDQUFDLE9BQUQsQ0FBSixHQUFnQixDQUFDLEdBQUQsQ0FBaEI7QUFDRDs7QUFuRVQ7QUFBQTs7QUFBQTtBQUFBLGtCQW9FZ0IsUUFBUSxDQUFDLElBQUQsQ0FBUixJQUNSLENBQUMsQ0FBQyxXQUFELEVBQWMsT0FBZCxFQUF1QixRQUF2QixFQUFpQyxRQUFqQyxDQUEwQyxRQUExQyxDQXJFVDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFzRWMsSUFBSSxXQUFKLENBQ0oscUZBQ1ksUUFEWixRQURJLEVBR0osb0JBSEksRUFJSjtBQUFDLGNBQUEsSUFBSSxFQUFFLHNCQUFQO0FBQStCLGNBQUEsS0FBSyxFQUFFO0FBQXRDLGFBSkksQ0F0RWQ7O0FBQUE7QUEyRWEsZ0JBQUcsYUFBSCxFQUFrQjtBQUN2QjtBQUNBO0FBQ0Esa0JBQUcsV0FBVyxLQUFLLE9BQW5CLEVBQTRCO0FBQzFCO0FBQ0EsZ0JBQUEsU0FBUyxDQUFDLElBQUQsRUFBTyxhQUFQLEVBQXNCLFdBQXRCLEVBQW1DO0FBQzFDLGtCQUFBLGVBQWUsRUFBRSxJQUR5QjtBQUUxQyxrQkFBQSxZQUFZLEVBQUU7QUFGNEIsaUJBQW5DLENBQVQ7QUFJRDtBQUNGLGFBVk0sTUFVQSxJQUFHLFdBQVcsS0FBSyxPQUFoQixJQUEyQixFQUFFLFFBQVEsSUFBSSxJQUFkLENBQTlCLEVBQW1EO0FBQ3hELGNBQUEsSUFBSSxDQUFDLFFBQUQsQ0FBSixHQUFpQixHQUFqQjtBQUNEOztBQXZGUDtBQXdGTSxZQUFBLElBQUksQ0FBQyxJQUFMLENBQVUsSUFBVjs7QUF4Rk47QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUEsOENBMkZTLElBM0ZUOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEc7Ozs7O0FDOS9CQTtBQUNBO0FBQ0E7QUFDQTs7ZUFJSSxPQUFPLENBQUMsY0FBRCxDO0lBRFcsbUIsWUFBcEIsa0I7O2dCQUtFLE9BQU8sQ0FBQyxXQUFELEM7SUFEWSxvQixhQUFyQixtQjs7QUFHRixJQUFNLEdBQUcsR0FBRyxFQUFaO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsR0FBakI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxHQUFHLENBQUMsT0FBSixHQUFjLFVBQUEsS0FBSyxFQUFJO0FBQ3JCLE1BQU0sWUFBWSxHQUFHLG9CQUFvQixDQUFDLEtBQUQsQ0FBekMsQ0FEcUIsQ0FHckI7OztBQUNBLE1BQU0sU0FBUyxHQUFHLEVBQWxCO0FBQ0EsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxZQUFaLEVBQTBCLElBQTFCLEVBQWI7O0FBQ0EsT0FBSSxJQUFJLEVBQUUsR0FBRyxDQUFiLEVBQWdCLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBMUIsRUFBa0MsRUFBRSxFQUFwQyxFQUF3QztBQUN0QyxRQUFNLElBQUksR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUQsQ0FBTCxDQUF6QixDQURzQyxDQUV0Qzs7QUFDQSxRQUFHLENBQUMsbUJBQW1CLENBQUMsSUFBRCxDQUF2QixFQUErQjtBQUM3QixNQUFBLFNBQVMsQ0FBQyxJQUFWLENBQWUsSUFBZjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBTyxTQUFQO0FBQ0QsQ0FkRDs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFFb0IsT0FBTyxDQUFDLFdBQUQsQztJQUFwQixTLFlBQUEsUzs7QUFDUCxJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsY0FBRCxDQUExQjs7QUFDQSxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBRCxDQUFyQjs7QUFDQSxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsUUFBRCxDQUFwQjs7QUFDQSxJQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsT0FBRCxDQUFuQjs7QUFDQSxJQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsZUFBRCxDQUEzQjs7Z0JBSUksT0FBTyxDQUFDLFdBQUQsQztJQUZNLGMsYUFBZixhO0lBQ29CLG1CLGFBQXBCLGtCOztBQUdGLElBQU0sR0FBRyxHQUFHLEVBQVo7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixHQUFqQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxHQUFHLENBQUMsb0JBQUosR0FBMkIsVUFBQyxLQUFELEVBQVEsS0FBUixFQUFlLE9BQWYsRUFBMkI7QUFDcEQ7QUFDQSxNQUFNLEtBQUssR0FBRztBQUNaLElBQUEsT0FBTyxFQUFQLE9BRFk7QUFFWixJQUFBLFFBQVEsRUFBRSxLQUZFO0FBR1osSUFBQSxLQUFLLEVBQUUsVUFISztBQUlaLElBQUEsUUFBUSxFQUFFO0FBQUMsa0JBQVk7QUFBYixLQUpFO0FBS1osSUFBQSxZQUFZLEVBQUUsRUFMRjtBQU1aLElBQUEsSUFBSSxFQUFFLEVBTk07QUFPWixJQUFBLFFBQVEsRUFBRTtBQVBFLEdBQWQsQ0FGb0QsQ0FZcEQ7QUFDQTs7QUFDQSxNQUFNLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxnQkFBVCxDQUEwQixLQUExQixDQUFmOztBQUNBLEVBQUEsY0FBYyxDQUFDLEtBQUQsRUFBUSxLQUFLLENBQUMsUUFBZCxFQUF3QixVQUF4QixFQUFvQyxNQUFwQyxDQUFkOztBQUNBLE1BQUcsT0FBTyxDQUFDLE1BQVgsRUFBbUI7QUFDakIsSUFBQSxLQUFLLENBQUMsUUFBTixDQUFlLFNBQWYsSUFBNEIsbUJBQW1CLENBQUMsS0FBSyxDQUFDLFFBQVAsQ0FBL0M7QUFDQSxJQUFBLEtBQUssQ0FBQyxLQUFOLEdBQWMsU0FBZDtBQUNEOztBQUNELEVBQUEsS0FBSyxDQUFDLFFBQU4sR0FBaUIsS0FBSyxDQUFDLFFBQU4sQ0FBZSxLQUFLLENBQUMsS0FBckIsQ0FBakIsQ0FwQm9ELENBc0JwRDs7QUFDQSxNQUFNLE1BQU0sR0FBRyxFQUFmO0FBQ0EsRUFBQSxHQUFHLENBQUMsS0FBSixDQUFVLEtBQVYsRUFBaUIsTUFBTSxDQUFDLElBQVAsQ0FBWSxLQUFLLENBQUMsUUFBbEIsRUFBNEIsSUFBNUIsRUFBakIsRUFBcUQsS0FBckQsRUFBNEQsTUFBNUQsRUF4Qm9ELENBMEJwRDs7QUFDQSxNQUFHLE9BQU8sQ0FBQyx5QkFBWCxFQUFzQztBQUNwQztBQUNBLElBQUEsT0FBTyxDQUFDLGFBQVIsR0FDRSxNQUFNLENBQUMsSUFBUCxDQUFZLEtBQUssQ0FBQyxRQUFsQixFQUE0QixNQUE1QixDQUFtQyxVQUFBLEVBQUU7QUFBQSxhQUFJLEtBQUssQ0FBQyxRQUFOLENBQWUsRUFBZixFQUFtQixNQUFuQixLQUE4QixDQUFsQztBQUFBLEtBQXJDLENBREY7QUFFRCxHQS9CbUQsQ0FpQ3BEOzs7QUFDQSxFQUFBLE9BQU8sQ0FBQyxJQUFSLEdBQWUsRUFBZjtBQUNBLFNBQU8sZ0JBQWdCLENBQUMsTUFBRCxFQUFTLE9BQVQsQ0FBdkI7QUFDRCxDQXBDRDtBQXNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxLQUFKLEdBQVksVUFBQyxLQUFELEVBQVEsUUFBUixFQUFrQixLQUFsQixFQUF5QixNQUF6QixFQUFxRDtBQUFBLE1BQXBCLFFBQW9CLHVFQUFULElBQVM7O0FBQy9EO0FBQ0EsRUFBQSxjQUFjLENBQUMsS0FBRCxDQUFkOztBQUNBLEVBQUEsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFELENBQWIsQ0FIK0QsQ0FLL0Q7O0FBQ0EsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQXRCO0FBQ0EsTUFBTSxLQUFLLEdBQUc7QUFDWixJQUFBLEtBQUssRUFBRSxhQUFhLENBQUMsS0FBRCxFQUFRLE9BQVIsRUFBaUIsT0FBakIsQ0FEUjtBQUVaLElBQUEsUUFBUSxFQUFFLGFBQWEsQ0FBQyxLQUFELEVBQVEsT0FBUixFQUFpQixVQUFqQixDQUZYO0FBR1osSUFBQSxVQUFVLEVBQUUsYUFBYSxDQUFDLEtBQUQsRUFBUSxPQUFSLEVBQWlCLFlBQWpCO0FBSGIsR0FBZCxDQVArRCxDQWEvRDs7QUFDQSxNQUFHLENBQUMsS0FBSyxDQUFDLElBQU4sQ0FBVyxjQUFYLENBQTBCLEtBQUssQ0FBQyxLQUFoQyxDQUFKLEVBQTRDO0FBQzFDLElBQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxLQUFLLENBQUMsS0FBakIsSUFBMEIsRUFBMUI7QUFDRDs7QUFDRCxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsSUFBTixDQUFXLEtBQUssQ0FBQyxLQUFqQixDQUFiLENBakIrRCxDQW1CL0Q7O0FBQ0EsTUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFDLEtBQUQsRUFBUSxRQUFSLEVBQWtCLEtBQWxCLEVBQXlCLEtBQXpCLENBQS9CLENBcEIrRCxDQXNCL0Q7OztBQUNBLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksT0FBWixFQUFxQixJQUFyQixFQUFaOztBQXZCK0QsNkNBd0IvQyxHQXhCK0M7QUFBQTs7QUFBQTtBQUFBO0FBQUEsVUF3QnJELEVBeEJxRDtBQXlCN0QsVUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLEVBQUQsQ0FBdkI7QUFFQTtBQUNKO0FBQ0E7O0FBQ0ksVUFBRyxRQUFRLEtBQUssSUFBaEIsRUFBc0I7QUFDcEIsUUFBQSxLQUFLLENBQUMsWUFBTix3Q0FBdUIsS0FBSyxDQUFDLEtBQTdCLEVBQXFDLEVBQXJDO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsUUFBQSxLQUFLLENBQUMsWUFBTixDQUFtQixLQUFLLENBQUMsS0FBekIsSUFBa0MsS0FBSyxDQUFDLFlBQU4sQ0FBbUIsS0FBSyxDQUFDLEtBQXpCLEtBQW1DLEVBQXJFO0FBQ0Q7O0FBRUQsVUFBRyxLQUFLLENBQUMsS0FBTixLQUFnQixPQUFoQixJQUEyQixFQUFFLElBQUksSUFBcEMsRUFBMEM7QUFDeEM7QUFDQTtBQUNBO0FBRUE7QUFDQSxRQUFBLGVBQWUsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixJQUFJLENBQUMsRUFBRCxDQUF2QixDQUFmOztBQUNBO0FBQ0QsT0E1QzRELENBOEM3RDs7O0FBQ0EsVUFBTSxNQUFNLEdBQUc7QUFBQyxlQUFPO0FBQVIsT0FBZjs7QUFDQSxVQUFHLEVBQUUsQ0FBQyxPQUFILENBQVcsSUFBWCxNQUFxQixDQUF4QixFQUEyQjtBQUN6QixRQUFBLElBQUksQ0FBQyxRQUFMLENBQWMsS0FBSyxDQUFDLFFBQXBCLEVBQThCLEVBQTlCLEVBQWtDLE1BQWxDLEVBQTBDO0FBQUMsVUFBQSxlQUFlLEVBQUU7QUFBbEIsU0FBMUM7QUFDRDs7QUFDRCxNQUFBLElBQUksQ0FBQyxFQUFELENBQUosR0FBVyxNQUFYLENBbkQ2RCxDQXFEN0Q7O0FBQ0EsVUFBRyxDQUFDLEtBQUssQ0FBQyxLQUFOLEtBQWdCLFFBQWhCLElBQTRCLEtBQUssQ0FBQyxLQUFOLEtBQWdCLE9BQTdDLEtBQXlELEtBQUssQ0FBQyxJQUFsRSxFQUF3RTtBQUN0RSxjQUFNLElBQUksV0FBSixDQUNKLGtEQURJLEVBRUosb0JBRkksRUFFa0I7QUFBQyxVQUFBLElBQUksRUFBRSxzQkFBUDtBQUErQixVQUFBLEtBQUssRUFBTDtBQUEvQixTQUZsQixDQUFOO0FBR0Q7O0FBRUQsVUFBRyxDQUFDLEtBQUssQ0FBQyxRQUFQLElBQW1CLEtBQUssQ0FBQyxZQUFOLENBQW1CLEtBQUssQ0FBQyxLQUF6QixFQUFnQyxjQUFoQyxDQUErQyxFQUEvQyxDQUF0QixFQUEwRTtBQUN4RTtBQUNBO0FBQ0E7QUFDRCxPQWhFNEQsQ0FrRTdEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxVQUFHLEtBQUssQ0FBQyxRQUFOLEtBQ0EsS0FBSyxDQUFDLEtBQU4sS0FBZ0IsUUFBaEIsSUFDRCx5QkFBeUIsQ0FBQyxPQUFELEVBQVUsS0FBSyxDQUFDLEtBQWhCLEVBQXVCLEtBQUssQ0FBQyxZQUE3QixDQUZ4QixDQUFILEVBRXdFO0FBQ3RFLFFBQUEsZUFBZSxDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLE1BQW5CLENBQWY7O0FBQ0E7QUFDRCxPQTNFNEQsQ0E2RTdEOzs7QUFDQSxVQUFHLEtBQUssQ0FBQyxRQUFOLEtBQ0MsS0FBSyxDQUFDLEtBQU4sSUFBZSxRQUFmLElBQTJCLEtBQUssQ0FBQyxLQUFOLElBQWUsT0FEM0MsS0FFQSxLQUFLLENBQUMsWUFBTixDQUFtQixLQUFLLENBQUMsS0FBekIsRUFBZ0MsY0FBaEMsQ0FBK0MsRUFBL0MsQ0FGSCxFQUV1RDtBQUNyRCxRQUFBLGVBQWUsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixNQUFuQixDQUFmOztBQUNBO0FBQ0QsT0FuRjRELENBcUY3RDs7O0FBQ0EsVUFBRyxLQUFLLENBQUMsS0FBTixLQUFnQixPQUFuQixFQUE0QjtBQUMxQjtBQUNBLFlBQUcsRUFBRSxJQUFJLEtBQUssQ0FBQyxZQUFOLENBQW1CLEtBQUssQ0FBQyxLQUF6QixDQUFULEVBQTBDO0FBQ3hDLFVBQUEsWUFBWSxDQUFDLEtBQUQsRUFBUSxFQUFSLENBQVo7QUFDRDtBQUNGOztBQUVELE1BQUEsS0FBSyxDQUFDLFlBQU4sQ0FBbUIsS0FBSyxDQUFDLEtBQXpCLEVBQWdDLEVBQWhDLElBQXNDO0FBQUMsUUFBQSxNQUFNLEVBQU4sTUFBRDtBQUFTLFFBQUEsUUFBUSxFQUFSO0FBQVQsT0FBdEMsQ0E3RjZELENBK0Y3RDs7QUFDQSxNQUFBLEtBQUssQ0FBQyxZQUFOLENBQW1CLElBQW5CLENBQXdCO0FBQUMsUUFBQSxPQUFPLEVBQVAsT0FBRDtBQUFVLFFBQUEsS0FBSyxFQUFFLEtBQUssQ0FBQztBQUF2QixPQUF4QixFQWhHNkQsQ0FrRzdEOztBQUNBLFVBQUcsRUFBRSxJQUFJLEtBQUssQ0FBQyxRQUFmLEVBQXlCO0FBQ3ZCLFlBQUksT0FBTyxHQUFHLEtBQWQ7QUFDQSxZQUFJLFFBQVEsR0FBRyxJQUFmOztBQUNBLFlBQUcsRUFBRSxZQUFZLEtBQWQsQ0FBSCxFQUF5QjtBQUN2QixVQUFBLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBTixLQUFnQixTQUExQjtBQUNBLFVBQUEsUUFBUSxHQUFHLEVBQVg7QUFDRCxTQUhELE1BR087QUFDTCxVQUFBLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBRCxDQUFMLENBQWdCLENBQWhCLENBQVg7QUFDQSxVQUFBLE9BQU8sR0FBRyxFQUFFLEVBQUUsS0FBSyxTQUFQLElBQW9CLEVBQUUsS0FBSyxVQUE3QixDQUFWOztBQUNBLGNBQUcsQ0FBQyxLQUFLLENBQUMsUUFBTixDQUFlLFFBQWYsQ0FBSixFQUE4QjtBQUM1QixZQUFBLFFBQVEsR0FBRyxFQUFYO0FBQ0Q7QUFDRjs7QUFFRCxZQUFHLE9BQUgsRUFBWTtBQUNWO0FBQ0EsVUFBQSxHQUFHLENBQUMsS0FBSixpQ0FDTSxLQUROO0FBQ2EsWUFBQSxLQUFLLEVBQUUsRUFEcEI7QUFDd0IsWUFBQSxRQUFRLEVBQUU7QUFEbEMsY0FFRSxNQUFNLENBQUMsSUFBUCxDQUFZLEtBQUssQ0FBQyxRQUFOLENBQWUsRUFBZixDQUFaLEVBQWdDLElBQWhDLEVBRkYsRUFFMEMsQ0FBQyxRQUFELENBRjFDLEVBRXNELE1BRnRELEVBRThELFFBRjlEO0FBR0Q7QUFDRixPQXZINEQsQ0F5SDdEOzs7QUFDQSxVQUFHLGVBQWUsS0FBbEIsRUFBeUI7QUFDdkIsUUFBQSxHQUFHLENBQUMsS0FBSixpQ0FDTSxLQUROO0FBQ2EsVUFBQSxRQUFRLEVBQUU7QUFEdkIsWUFFRSxRQUZGLEVBRVksS0FBSyxDQUFDLFdBQUQsQ0FGakIsRUFFZ0MsTUFGaEMsRUFFd0MsV0FGeEM7QUFHRCxPQTlINEQsQ0FnSTdEOzs7QUFoSTZELGtEQWlJM0MsTUFBTSxDQUFDLElBQVAsQ0FBWSxPQUFaLEVBQXFCLElBQXJCLEVBakkyQztBQUFBOztBQUFBO0FBaUk3RCwrREFBK0M7QUFBQSxjQUFyQyxJQUFxQzs7QUFDN0M7QUFDQSxjQUFHLFNBQVMsQ0FBQyxJQUFELENBQVosRUFBb0I7QUFDbEIsWUFBQSxNQUFNLENBQUMsSUFBRCxDQUFOLEdBQWUsSUFBSSxDQUFDLEtBQUwsQ0FBVyxPQUFPLENBQUMsSUFBRCxDQUFsQixDQUFmOztBQUVBLGdCQUFHLElBQUksS0FBSyxPQUFaLEVBQXFCO0FBQ25CO0FBRG1CLDBEQUVELE9BQU8sQ0FBQyxPQUFELENBRk47QUFBQTs7QUFBQTtBQUVuQix1RUFBb0M7QUFBQSxzQkFBMUIsSUFBMEI7O0FBQ2xDLHNCQUFHLElBQUksQ0FBQyxPQUFMLENBQWEsSUFBYixNQUF1QixDQUExQixFQUE2QjtBQUMzQixvQkFBQSxJQUFJLENBQUMsUUFBTCxDQUNFLEtBQUssQ0FBQyxRQURSLEVBQ2tCLElBRGxCLEVBQ3dCLE1BRHhCLEVBQ2dDO0FBQUMsc0JBQUEsZUFBZSxFQUFFO0FBQWxCLHFCQURoQztBQUVEO0FBQ0Y7QUFQa0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFwQjs7QUFDRDtBQUNELFdBZjRDLENBaUI3Qzs7O0FBQ0EsY0FBRyxLQUFLLENBQUMsUUFBTixJQUFrQixFQUFFLElBQUksSUFBSSxLQUFWLENBQXJCLEVBQXVDO0FBQ3JDO0FBQ0QsV0FwQjRDLENBc0I3Qzs7O0FBdEI2QyxzREF1QjlCLE9BQU8sQ0FBQyxJQUFELENBdkJ1QjtBQUFBOztBQUFBO0FBdUI3QyxtRUFBOEI7QUFBQSxrQkFBcEIsQ0FBb0I7O0FBQzVCLGtCQUFNLFNBQVEsR0FBSSxJQUFJLElBQUksS0FBUixHQUNoQixLQUFLLENBQUMsSUFBRCxDQURXLEdBQ0Ysb0JBQW9CLENBQUMsS0FBRCxDQURwQyxDQUQ0QixDQUk1Qjs7O0FBQ0Esa0JBQUcsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsQ0FBbEIsQ0FBSCxFQUF5QjtBQUN2QixvQkFBTSxVQUFRLEdBQ1gsS0FBSyxDQUFDLElBQUQsQ0FBTCxJQUFlLEtBQUssQ0FBQyxJQUFELENBQUwsQ0FBWSxDQUFaLENBQWYsSUFBaUMsS0FBSyxDQUFDLElBQUQsQ0FBTCxDQUFZLENBQVosRUFBZSxPQUFmLENBQWxDLEdBQ0UsS0FBSyxDQUFDLElBQUQsQ0FBTCxDQUFZLENBQVosRUFBZSxPQUFmLENBREYsR0FFRSxvQkFBb0IsQ0FBQyxLQUFELENBSHhCLENBRHVCLENBTXZCOzs7QUFDQSxvQkFBTSxJQUFJLEdBQUc7QUFBQywyQkFBUztBQUFWLGlCQUFiOztBQUNBLGdCQUFBLGVBQWUsQ0FBQyxNQUFELEVBQVMsSUFBVCxFQUFlLElBQWYsQ0FBZixDQVJ1QixDQVV2Qjs7O0FBQ0Esb0JBQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFELENBQWI7O0FBWHVCLDREQVlQLEdBWk87QUFBQTs7QUFBQTtBQVl2Qix5RUFBcUI7QUFBQSx3QkFBWCxFQUFXOztBQUNuQix3QkFBRyxVQUFVLENBQUMsa0JBQVgsQ0FBOEIsRUFBOUIsQ0FBSCxFQUFzQztBQUNwQztBQUNBLHNCQUFBLEdBQUcsQ0FBQyxLQUFKLGlDQUNNLEtBRE47QUFDYSx3QkFBQSxRQUFRLEVBQUU7QUFEdkIsMEJBRUUsQ0FBQyxFQUFFLENBQUMsS0FBRCxDQUFILENBRkYsRUFFZSxVQUZmLEVBRXlCLElBRnpCLEVBRStCLE9BRi9CO0FBR0QscUJBTEQsTUFLTztBQUNMO0FBQ0Esc0JBQUEsZUFBZSxDQUFDLElBQUQsRUFBTyxPQUFQLEVBQWdCLElBQUksQ0FBQyxLQUFMLENBQVcsRUFBWCxDQUFoQixDQUFmO0FBQ0Q7QUFDRjtBQXRCc0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXVCeEIsZUF2QkQsTUF1Qk8sSUFBRyxVQUFVLENBQUMsa0JBQVgsQ0FBOEIsQ0FBOUIsQ0FBSCxFQUFxQztBQUMxQztBQUNBLGdCQUFBLEdBQUcsQ0FBQyxLQUFKLGlDQUNNLEtBRE47QUFDYSxrQkFBQSxRQUFRLEVBQUU7QUFEdkIsb0JBRUUsQ0FBQyxDQUFDLENBQUMsS0FBRCxDQUFGLENBRkYsRUFFYyxTQUZkLEVBRXdCLE1BRnhCLEVBRWdDLElBRmhDO0FBR0QsZUFMTSxNQUtBLElBQUcsV0FBVyxDQUFDLFNBQVEsQ0FBQyxDQUFELENBQVQsRUFBYyxDQUFkLENBQWQsRUFBZ0M7QUFDckM7QUFDQSxnQkFBQSxlQUFlLENBQUMsTUFBRCxFQUFTLElBQVQsRUFBZSxJQUFJLENBQUMsS0FBTCxDQUFXLENBQVgsQ0FBZixDQUFmO0FBQ0Q7QUFDRjtBQTVENEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQTZEOUMsU0E5TDRELENBZ003RDs7QUFoTTZEO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0RBaU0zQyxNQUFNLENBQUMsSUFBUCxDQUFZLEtBQVosRUFBbUIsSUFBbkIsRUFqTTJDO0FBQUE7O0FBQUE7QUFpTTdELCtEQUE2QztBQUFBLGNBQW5DLEtBQW1DOztBQUMzQztBQUNBLGNBQUcsS0FBSSxLQUFLLE9BQVosRUFBcUI7QUFDbkIsZ0JBQUcsQ0FBQyxLQUFLLENBQUMsUUFBTixDQUFlLEtBQUssQ0FBQyxLQUFELENBQUwsQ0FBWSxDQUFaLENBQWYsQ0FBRCxJQUNBLEVBQUUsY0FBYyxLQUFLLENBQUMsS0FBRCxDQUFMLENBQVksQ0FBWixDQUFoQixDQURILEVBQ29DO0FBQ2xDO0FBQ0QsYUFKa0IsQ0FLbkI7O0FBQ0QsV0FORCxNQU1PLElBQUcsU0FBUyxDQUFDLEtBQUQsQ0FBWixFQUFvQjtBQUN6QjtBQUNELFdBVjBDLENBWTNDO0FBQ0E7OztBQUNBLGNBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFELENBQUwsQ0FBWSxDQUFaLEtBQWtCLEVBQS9COztBQUNBLGNBQU0sYUFBYSxHQUFHLGFBQWEsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQixhQUFoQixDQUFuQzs7QUFDQSxjQUFHLENBQUMsYUFBRCxJQUFrQixFQUFFLEtBQUksSUFBSSxNQUFWLENBQXJCLEVBQXdDO0FBQ3RDLGdCQUFJLFFBQVEsR0FBRyxPQUFmOztBQUNBLGdCQUFHLGNBQWMsSUFBakIsRUFBdUI7QUFDckIsY0FBQSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxJQUFJLENBQUMsVUFBRCxDQUFmLENBQVg7QUFDRDs7QUFDRCxnQkFBRyxDQUFDLEtBQUssQ0FBQyxPQUFOLENBQWMsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLGNBQUEsUUFBUSxHQUFHLENBQUMsUUFBRCxDQUFYO0FBQ0Q7O0FBQ0QsWUFBQSxNQUFNLENBQUMsS0FBRCxDQUFOLEdBQWUsQ0FBQztBQUFDLDJCQUFhO0FBQWQsYUFBRCxDQUFmO0FBQ0Q7QUFDRixTQTNONEQsQ0E2TjdEO0FBQ0E7O0FBOU42RDtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtEQStOcEMsTUFBTSxDQUFDLElBQVAsQ0FBWSxLQUFLLENBQUMsVUFBRCxDQUFMLElBQXFCLEVBQWpDLEVBQXFDLElBQXJDLEVBL05vQztBQUFBOztBQUFBO0FBK043RCwrREFBc0U7QUFBQSxjQUE1RCxXQUE0RDtBQUNwRSxjQUFNLFVBQVEsR0FBRyxLQUFLLENBQUMsVUFBRCxDQUFMLENBQWtCLFdBQWxCLENBQWpCOztBQUNBLDBDQUFxQixNQUFNLENBQUMsSUFBUCxDQUFZLEtBQUssQ0FBQyxRQUFsQixDQUFyQixrQ0FBa0Q7QUFBOUMsZ0JBQU0sUUFBTyxtQkFBYjtBQUNGLGdCQUFNLFVBQVUsR0FDZCxJQUFJLENBQUMsU0FBTCxDQUFlLEtBQUssQ0FBQyxRQUFOLENBQWUsUUFBZixDQUFmLEVBQXdDLFdBQXhDLENBREY7O0FBRUEsZ0JBQUcsVUFBVSxDQUFDLElBQVgsQ0FBZ0IsVUFBQSxDQUFDO0FBQUEscUJBQUksQ0FBQyxDQUFDLEtBQUQsQ0FBRCxLQUFhLEVBQWpCO0FBQUEsYUFBakIsQ0FBSCxFQUEwQztBQUN4QztBQUNBLGNBQUEsTUFBTSxDQUFDLFVBQUQsQ0FBTixHQUFxQixNQUFNLENBQUMsVUFBRCxDQUFOLElBQXNCLEVBQTNDO0FBQ0EsY0FBQSxJQUFJLENBQUMsUUFBTCxDQUNFLE1BQU0sQ0FBQyxVQUFELENBRFIsRUFDc0IsV0FEdEIsRUFDbUMsRUFEbkMsRUFDdUM7QUFBQyxnQkFBQSxlQUFlLEVBQUU7QUFBbEIsZUFEdkM7QUFFQSxjQUFBLEdBQUcsQ0FBQyxLQUFKLGlDQUNNLEtBRE47QUFDYSxnQkFBQSxRQUFRLEVBQUU7QUFEdkIsa0JBRUUsQ0FBQyxRQUFELENBRkYsRUFFYSxVQUZiLEVBRXVCLE1BQU0sQ0FBQyxVQUFELENBQU4sQ0FBbUIsV0FBbkIsQ0FGdkIsRUFHRSxRQUhGO0FBSUQ7QUFDRjtBQUNGLFNBL080RCxDQWlQN0Q7O0FBalA2RDtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWtQN0QsTUFBQSxlQUFlLENBQUMsTUFBRCxFQUFTLFFBQVQsRUFBbUIsTUFBbkIsQ0FBZixDQWxQNkQsQ0FvUDdEOzs7QUFDQSxNQUFBLEtBQUssQ0FBQyxZQUFOLENBQW1CLEdBQW5CO0FBclA2RDs7QUF3Qi9ELHdEQUFxQjtBQUFBOztBQUFBLCtCQTBEakI7QUFvS0g7QUF0UDhEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1UGhFLENBdlBEO0FBeVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxXQUFKLEdBQWtCLFVBQUMsS0FBRCxFQUFRLE9BQVIsRUFBb0I7QUFDcEM7QUFDQSxNQUFHLEtBQUssQ0FBQyxPQUFOLENBQWMsS0FBZCxDQUFILEVBQXlCO0FBQ3ZCLFFBQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxHQUFOLENBQVUsVUFBQSxDQUFDO0FBQUEsYUFBSSxHQUFHLENBQUMsV0FBSixDQUFnQixDQUFoQixFQUFtQixPQUFuQixDQUFKO0FBQUEsS0FBWCxDQUFoQjtBQUNBLFdBQU8sT0FBTyxDQUFDLE1BQVIsQ0FBZSxVQUFBLENBQUM7QUFBQSxhQUFJLENBQUo7QUFBQSxLQUFoQixDQUFQLENBRnVCLENBRVE7QUFDaEM7O0FBRUQsTUFBRyxLQUFLLEtBQUssT0FBYixFQUFzQjtBQUNwQixXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFHLEtBQUssQ0FBQyxRQUFOLENBQWUsS0FBZixDQUFILEVBQTBCO0FBQ3hCO0FBQ0EsUUFBRyxTQUFTLEtBQVosRUFBbUI7QUFDakIsVUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLEtBQUQsQ0FBaEI7O0FBQ0EsVUFBRyxPQUFPLENBQUMsSUFBUixDQUFhLGNBQWIsQ0FBNEIsRUFBNUIsQ0FBSCxFQUFvQztBQUNsQyxZQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsSUFBUixDQUFhLEVBQWIsRUFBaUIsT0FBakIsQ0FBeUIsS0FBekIsQ0FBWjs7QUFDQSxZQUFHLEdBQUcsS0FBSyxDQUFDLENBQVosRUFBZTtBQUNiO0FBQ0EsaUJBQU8sT0FBTyxDQUFDLElBQVIsQ0FBYSxFQUFiLEVBQWlCLEdBQWpCLENBQVA7QUFDRCxTQUxpQyxDQU1sQzs7O0FBQ0EsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFhLEVBQWIsRUFBaUIsSUFBakIsQ0FBc0IsS0FBdEI7QUFDRCxPQVJELE1BUU87QUFDTDtBQUNBLFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYSxFQUFiLElBQW1CLENBQUMsS0FBRCxDQUFuQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBSSxJQUFNLEdBQVYsSUFBaUIsS0FBakIsRUFBd0I7QUFDdEIsTUFBQSxLQUFLLENBQUMsR0FBRCxDQUFMLEdBQWEsR0FBRyxDQUFDLFdBQUosQ0FBZ0IsS0FBSyxDQUFDLEdBQUQsQ0FBckIsRUFBNEIsT0FBNUIsQ0FBYjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBTyxLQUFQO0FBQ0QsQ0FsQ0Q7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsb0JBQVQsQ0FBOEIsS0FBOUIsRUFBcUM7QUFDbkMsTUFBTSxLQUFLLEdBQUcsRUFBZDs7QUFDQSxPQUFJLElBQU0sR0FBVixJQUFpQixLQUFqQixFQUF3QjtBQUN0QixRQUFHLEtBQUssQ0FBQyxHQUFELENBQUwsS0FBZSxTQUFsQixFQUE2QjtBQUMzQixNQUFBLEtBQUssQ0FBQyxNQUFNLEdBQVAsQ0FBTCxHQUFtQixDQUFDLEtBQUssQ0FBQyxHQUFELENBQU4sQ0FBbkI7QUFDRDtBQUNGOztBQUNELFNBQU8sQ0FBQyxLQUFELENBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLHlCQUFULENBQW1DLGNBQW5DLEVBQW1ELEtBQW5ELEVBQTBELFlBQTFELEVBQXdFO0FBQ3RFLE9BQUksSUFBSSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQWIsR0FBc0IsQ0FBbEMsRUFBcUMsQ0FBQyxJQUFJLENBQTFDLEVBQTZDLEVBQUUsQ0FBL0MsRUFBa0Q7QUFDaEQsUUFBTSxPQUFPLEdBQUcsWUFBWSxDQUFDLENBQUQsQ0FBNUI7O0FBQ0EsUUFBRyxPQUFPLENBQUMsS0FBUixLQUFrQixLQUFsQixJQUNELE9BQU8sQ0FBQyxPQUFSLENBQWdCLEtBQWhCLE1BQTJCLGNBQWMsQ0FBQyxLQUFELENBRDNDLEVBQ29EO0FBQ2xELGFBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsYUFBVCxDQUF1QixLQUF2QixFQUE4QixPQUE5QixFQUF1QyxJQUF2QyxFQUE2QztBQUMzQyxNQUFNLElBQUksR0FBRyxNQUFNLElBQW5CO0FBQ0EsTUFBSSxJQUFJLEdBQUksSUFBSSxJQUFJLEtBQVIsR0FBZ0IsS0FBSyxDQUFDLElBQUQsQ0FBTCxDQUFZLENBQVosQ0FBaEIsR0FBaUMsT0FBTyxDQUFDLElBQUQsQ0FBcEQ7O0FBQ0EsTUFBRyxJQUFJLEtBQUssT0FBWixFQUFxQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUcsSUFBSSxLQUFLLElBQVosRUFBa0I7QUFDaEIsTUFBQSxJQUFJLEdBQUcsT0FBUDtBQUNELEtBRkQsTUFFTyxJQUFHLElBQUksS0FBSyxLQUFaLEVBQW1CO0FBQ3hCLE1BQUEsSUFBSSxHQUFHLFFBQVA7QUFDRCxLQUZNLE1BRUEsSUFBRyxJQUFJLEtBQUssU0FBVCxJQUFzQixJQUFJLEtBQUssUUFBL0IsSUFBMkMsSUFBSSxLQUFLLE9BQXBELElBQ1IsSUFBSSxLQUFLLFFBREQsSUFDYSxJQUFJLEtBQUssT0FEdEIsSUFDaUMsSUFBSSxLQUFLLE9BRDdDLEVBQ3NEO0FBQzNELFlBQU0sSUFBSSxXQUFKLENBQ0osa0RBREksRUFFSixvQkFGSSxFQUVrQjtBQUFDLFFBQUEsSUFBSSxFQUFFLHNCQUFQO0FBQStCLFFBQUEsS0FBSyxFQUFMO0FBQS9CLE9BRmxCLENBQU47QUFHRDtBQUNGOztBQUNELFNBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0FBQzdCLE1BQUcsQ0FBQyxLQUFLLENBQUMsT0FBTixDQUFjLEtBQWQsQ0FBRCxJQUF5QixLQUFLLENBQUMsTUFBTixLQUFpQixDQUExQyxJQUErQyxDQUFDLEtBQUssQ0FBQyxRQUFOLENBQWUsS0FBSyxDQUFDLENBQUQsQ0FBcEIsQ0FBbkQsRUFBNkU7QUFDM0UsVUFBTSxJQUFJLFdBQUosQ0FDSixrRUFESSxFQUVKLG9CQUZJLEVBRWtCO0FBQUMsTUFBQSxLQUFLLEVBQUw7QUFBRCxLQUZsQixDQUFOO0FBR0Q7O0FBRUQsTUFBRyxTQUFTLEtBQUssQ0FBQyxDQUFELENBQWpCLEVBQXNCO0FBQUEsZ0RBQ0osSUFBSSxDQUFDLE9BQUwsQ0FBYSxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVMsS0FBVCxDQUFiLENBREk7QUFBQTs7QUFBQTtBQUNwQiw2REFBK0M7QUFBQSxZQUFyQyxFQUFxQzs7QUFDN0M7QUFDQSxZQUFHLEVBQUUsS0FBSyxDQUFDLFFBQU4sQ0FBZSxFQUFmLEtBQXNCLEdBQUcsQ0FBQyxVQUFKLENBQWUsRUFBZixDQUF4QixLQUNBLEtBQUssQ0FBQyxRQUFOLENBQWUsRUFBZixLQUFzQixFQUFFLENBQUMsT0FBSCxDQUFXLElBQVgsTUFBcUIsQ0FEOUMsRUFDa0Q7QUFDaEQsZ0JBQU0sSUFBSSxXQUFKLENBQ0osK0NBREksRUFFSixvQkFGSSxFQUVrQjtBQUFDLFlBQUEsSUFBSSxFQUFFLGVBQVA7QUFBd0IsWUFBQSxLQUFLLEVBQUw7QUFBeEIsV0FGbEIsQ0FBTjtBQUdEO0FBQ0Y7QUFUbUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVVyQjs7QUFFRCxNQUFHLFdBQVcsS0FBSyxDQUFDLENBQUQsQ0FBbkIsRUFBd0I7QUFBQSxnREFDSixJQUFJLENBQUMsT0FBTCxDQUFhLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUyxPQUFULENBQWIsQ0FESTtBQUFBOztBQUFBO0FBQ3RCLDZEQUFtRDtBQUFBLFlBQXpDLElBQXlDOztBQUNqRDtBQUNBLFlBQUcsRUFBRSxLQUFLLENBQUMsUUFBTixDQUFlLElBQWYsS0FBd0IsR0FBRyxDQUFDLFVBQUosQ0FBZSxJQUFmLENBQTFCLEtBQ0EsS0FBSyxDQUFDLFFBQU4sQ0FBZSxJQUFmLEtBQXdCLElBQUksQ0FBQyxPQUFMLENBQWEsSUFBYixNQUF1QixDQURsRCxFQUNzRDtBQUNwRCxnQkFBTSxJQUFJLFdBQUosQ0FDSixpREFESSxFQUVKLG9CQUZJLEVBRWtCO0FBQUMsWUFBQSxJQUFJLEVBQUUsZUFBUDtBQUF3QixZQUFBLEtBQUssRUFBTDtBQUF4QixXQUZsQixDQUFOO0FBR0Q7QUFDRjtBQVRxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVXZCO0FBQ0Y7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxlQUFULENBQXlCLEtBQXpCLEVBQWdDLFFBQWhDLEVBQTBDLEtBQTFDLEVBQWlELEtBQWpELEVBQXdEO0FBQ3REO0FBQ0EsTUFBTSxJQUFJLEdBQUcsRUFBYjs7QUFGc0QsK0NBR3RDLFFBSHNDO0FBQUE7O0FBQUE7QUFHdEQsOERBQTBCO0FBQUEsVUFBaEIsRUFBZ0I7QUFDeEIsVUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLFFBQU4sQ0FBZSxLQUFLLENBQUMsS0FBckIsRUFBNEIsRUFBNUIsQ0FBaEI7O0FBQ0EsVUFBRyxjQUFjLENBQUMsS0FBRCxFQUFRLE9BQVIsRUFBaUIsS0FBakIsRUFBd0IsS0FBeEIsQ0FBakIsRUFBaUQ7QUFDL0MsUUFBQSxJQUFJLENBQUMsRUFBRCxDQUFKLEdBQVcsT0FBWDtBQUNEO0FBQ0Y7QUFScUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFTdEQsU0FBTyxJQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQixPQUEvQixFQUF3QyxLQUF4QyxFQUErQyxLQUEvQyxFQUFzRDtBQUNwRDtBQUNBLE1BQUksUUFBUSxHQUFHLElBQWY7QUFDQSxNQUFJLFdBQVcsR0FBRyxLQUFsQjs7QUFFQSxPQUFJLElBQU0sR0FBVixJQUFpQixLQUFqQixFQUF3QjtBQUN0QixRQUFJLFNBQVMsR0FBRyxLQUFoQjtBQUNBLFFBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFMLENBQWUsT0FBZixFQUF3QixHQUF4QixDQUFuQjtBQUNBLFFBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxTQUFMLENBQWUsS0FBZixFQUFzQixHQUF0QixFQUEyQixNQUEzQixLQUFzQyxDQUF0RDs7QUFFQSxRQUFHLEdBQUcsS0FBSyxLQUFYLEVBQWtCO0FBQ2hCO0FBQ0EsVUFBRyxLQUFLLENBQUMsYUFBTixDQUFvQixLQUFLLENBQUMsS0FBRCxDQUFMLENBQWEsQ0FBYixLQUFtQixFQUF2QyxDQUFILEVBQStDO0FBQzdDLFFBQUEsU0FBUyxHQUFHLElBQVo7QUFDRCxPQUZELE1BRU8sSUFBRyxLQUFLLENBQUMsS0FBRCxDQUFMLENBQWEsTUFBYixJQUF1QixDQUExQixFQUE2QjtBQUNsQyxRQUFBLFNBQVMsR0FBRyxLQUFLLENBQUMsS0FBRCxDQUFMLENBQWEsUUFBYixDQUFzQixVQUFVLENBQUMsQ0FBRCxDQUFoQyxDQUFaO0FBQ0Q7O0FBQ0QsVUFBRyxDQUFDLEtBQUssQ0FBQyxVQUFWLEVBQXNCO0FBQ3BCLGVBQU8sU0FBUDtBQUNEO0FBQ0YsS0FWRCxNQVVPLElBQUcsR0FBRyxLQUFLLE9BQVgsRUFBb0I7QUFDekI7QUFDQTtBQUNBLE1BQUEsUUFBUSxHQUFHLEtBQVg7O0FBQ0EsVUFBRyxPQUFILEVBQVk7QUFDVixZQUFHLFVBQVUsQ0FBQyxNQUFYLEdBQW9CLENBQXZCLEVBQTBCO0FBQ3hCO0FBQ0EsaUJBQU8sS0FBUDtBQUNEOztBQUNELFFBQUEsU0FBUyxHQUFHLElBQVo7QUFDRCxPQU5ELE1BTU8sSUFBRyxLQUFLLENBQUMsT0FBRCxDQUFMLENBQWUsTUFBZixLQUEwQixDQUExQixJQUNSLEtBQUssQ0FBQyxhQUFOLENBQW9CLEtBQUssQ0FBQyxPQUFELENBQUwsQ0FBZSxDQUFmLENBQXBCLENBREssRUFDbUM7QUFDeEM7QUFDQSxRQUFBLFNBQVMsR0FBRyxVQUFVLENBQUMsTUFBWCxHQUFvQixDQUFoQztBQUNELE9BSk0sTUFJQTtBQUNMO0FBREsscURBRWEsS0FBSyxDQUFDLE9BQUQsQ0FGbEI7QUFBQTs7QUFBQTtBQUFBO0FBQUEsZ0JBRUssSUFGTDs7QUFHSCxnQkFBRyxLQUFLLENBQUMsUUFBTixDQUFlLElBQWYsS0FBd0IsY0FBYyxJQUF6QyxFQUErQztBQUM3QztBQUNBLGNBQUEsU0FBUyxHQUFHLElBQVo7QUFDRCxhQUhELE1BR087QUFDTCxjQUFBLFNBQVMsR0FBRyxTQUFTLElBQUksVUFBVSxDQUFDLElBQVgsQ0FBZ0IsVUFBQSxFQUFFO0FBQUEsdUJBQUksRUFBRSxLQUFLLElBQVg7QUFBQSxlQUFsQixDQUF6QjtBQUNEO0FBUkU7O0FBRUwsb0VBQWtDO0FBQUE7QUFPakM7QUFUSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVU47O0FBQ0QsVUFBRyxDQUFDLEtBQUssQ0FBQyxVQUFWLEVBQXNCO0FBQ3BCLGVBQU8sU0FBUDtBQUNEO0FBQ0YsS0E1Qk0sTUE0QkEsSUFBRyxTQUFTLENBQUMsR0FBRCxDQUFaLEVBQW1CO0FBQ3hCO0FBQ0QsS0FGTSxNQUVBO0FBQUE7QUFDTDtBQUNBLFlBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFMLENBQWUsS0FBZixFQUFzQixHQUF0QixFQUEyQixDQUEzQixDQUFsQjtBQUNBLFlBQUksVUFBVSxHQUFHLEtBQWpCOztBQUNBLFlBQUcsU0FBSCxFQUFjO0FBQ1osVUFBQSxjQUFjLENBQUMsQ0FBQyxTQUFELENBQUQsQ0FBZDs7QUFDQSxVQUFBLFVBQVUsR0FBRyxjQUFjLFNBQTNCO0FBQ0QsU0FQSSxDQVNMOzs7QUFDQSxRQUFBLFFBQVEsR0FBRyxLQUFYLENBVkssQ0FZTDtBQUNBOztBQUNBLFlBQUcsVUFBVSxDQUFDLE1BQVgsS0FBc0IsQ0FBdEIsSUFBMkIsVUFBOUIsRUFBMEM7QUFDeEM7QUFDRCxTQWhCSSxDQWtCTDs7O0FBQ0EsWUFBRyxVQUFVLENBQUMsTUFBWCxHQUFvQixDQUFwQixJQUF5QixPQUE1QixFQUFxQztBQUNuQztBQUFBLGVBQU87QUFBUDtBQUNEOztBQUVELFlBQUcsU0FBUyxLQUFLLFNBQWpCLEVBQTRCO0FBQzFCO0FBQ0E7QUFDQSxjQUFHLFVBQVUsQ0FBQyxNQUFYLEdBQW9CLENBQXZCLEVBQTBCO0FBQ3hCO0FBQUEsaUJBQU87QUFBUDtBQUNEOztBQUNELFVBQUEsU0FBUyxHQUFHLElBQVo7QUFDRCxTQVBELE1BT087QUFDTCxjQUFHLFVBQVUsQ0FBQyxNQUFYLENBQWtCLFNBQWxCLENBQUgsRUFBaUM7QUFDL0IsZ0JBQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxPQUFELENBQVQsQ0FBbUIsQ0FBbkIsQ0FBbEI7O0FBQ0EsZ0JBQUcsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsVUFBVSxDQUFDLENBQUQsQ0FBNUIsQ0FBSCxFQUFxQztBQUNuQyxrQkFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLENBQUQsQ0FBVixDQUFjLE9BQWQsQ0FBdkI7O0FBRUEsa0JBQUcsVUFBVSxDQUFDLE9BQVgsQ0FBbUIsU0FBbkIsQ0FBSCxFQUFrQztBQUNoQztBQUNBLGdCQUFBLFNBQVMsR0FBRyxjQUFjLENBQUMsSUFBZixDQUFvQixVQUFBLEVBQUU7QUFBQSx5QkFBSSxXQUFXLENBQUMsU0FBRCxFQUFZLEVBQVosQ0FBZjtBQUFBLGlCQUF0QixDQUFaO0FBQ0QsZUFIRCxNQUdPLElBQUcsVUFBVSxDQUFDLFNBQVgsQ0FBcUIsU0FBckIsS0FDUixVQUFVLENBQUMsa0JBQVgsQ0FBOEIsU0FBOUIsQ0FESyxFQUNxQztBQUMxQyxnQkFBQSxTQUFTLEdBQUcsY0FBYyxDQUFDLElBQWYsQ0FBb0IsVUFBQSxFQUFFO0FBQUEseUJBQUksVUFBVSxDQUM5QyxLQUQ4QyxFQUN2QyxTQUR1QyxFQUM1QixFQUQ0QixFQUN4QixLQUR3QixDQUFkO0FBQUEsaUJBQXRCLENBQVo7QUFFRDtBQUNGO0FBQ0YsV0FkRCxNQWNPLElBQUcsVUFBVSxDQUFDLE9BQVgsQ0FBbUIsU0FBbkIsQ0FBSCxFQUFrQztBQUN2QyxZQUFBLFNBQVMsR0FBRyxVQUFVLENBQUMsSUFBWCxDQUFnQixVQUFBLEVBQUU7QUFBQSxxQkFBSSxXQUFXLENBQUMsU0FBRCxFQUFZLEVBQVosQ0FBZjtBQUFBLGFBQWxCLENBQVo7QUFDRCxXQUZNLE1BRUEsSUFBRyxVQUFVLENBQUMsa0JBQVgsQ0FBOEIsU0FBOUIsQ0FBSCxFQUE2QztBQUNsRCxZQUFBLFNBQVMsR0FDUCxVQUFVLENBQUMsSUFBWCxDQUFnQixVQUFBLEVBQUU7QUFBQSxxQkFBSSxVQUFVLENBQUMsS0FBRCxFQUFRLFNBQVIsRUFBbUIsRUFBbkIsRUFBdUIsS0FBdkIsQ0FBZDtBQUFBLGFBQWxCLENBREY7QUFFRCxXQUhNLE1BR0EsSUFBRyxLQUFLLENBQUMsUUFBTixDQUFlLFNBQWYsQ0FBSCxFQUE4QjtBQUNuQyxZQUFBLFNBQVMsR0FBRyxVQUFVLENBQUMsTUFBWCxHQUFvQixDQUFoQztBQUNELFdBRk0sTUFFQTtBQUNMLFlBQUEsU0FBUyxHQUFHLEtBQVo7QUFDRDtBQUNGO0FBdkRJOztBQUFBLGdDQWVIO0FBZkc7QUF3RE4sS0FyR3FCLENBdUd0Qjs7O0FBQ0EsUUFBRyxDQUFDLFNBQUQsSUFBYyxLQUFLLENBQUMsVUFBdkIsRUFBbUM7QUFDakMsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQsSUFBQSxXQUFXLEdBQUcsV0FBVyxJQUFJLFNBQTdCO0FBQ0QsR0FsSG1ELENBb0hwRDs7O0FBQ0EsU0FBTyxRQUFRLElBQUksV0FBbkI7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxZQUFULENBQXNCLEtBQXRCLEVBQTZCLEVBQTdCLEVBQWlDO0FBQy9CO0FBQ0EsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLFlBQU4sQ0FBbUIsS0FBSyxDQUFDLEtBQXpCLENBQWY7QUFDQSxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsRUFBRCxDQUFwQjtBQUNBLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFyQjtBQUNBLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxRQUF2QixDQUwrQixDQU8vQjs7QUFDQSxNQUFNLE9BQU8sR0FBRztBQUFDLFdBQU87QUFBUixHQUFoQixDQVIrQixDQVUvQjs7QUFDQSxNQUFHLEtBQUssQ0FBQyxPQUFOLENBQWMsTUFBZCxDQUFILEVBQTBCO0FBQ3hCO0FBQ0EsU0FBSSxJQUFJLENBQUMsR0FBRyxDQUFaLEVBQWUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUExQixFQUFrQyxFQUFFLENBQXBDLEVBQXVDO0FBQ3JDLFVBQUcsSUFBSSxDQUFDLGFBQUwsQ0FBbUIsTUFBTSxDQUFDLENBQUQsQ0FBekIsRUFBOEIsT0FBOUIsQ0FBSCxFQUEyQztBQUN6QyxRQUFBLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxPQUFaO0FBQ0E7QUFDRDtBQUNGO0FBQ0YsR0FSRCxNQVFPO0FBQ0w7QUFDQSxRQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTixDQUFjLE1BQU0sQ0FBQyxRQUFELENBQXBCLENBQWpCO0FBQ0EsSUFBQSxJQUFJLENBQUMsV0FBTCxDQUFpQixNQUFqQixFQUF5QixRQUF6QixFQUFtQyxPQUFuQyxFQUE0QztBQUFDLE1BQUEsZUFBZSxFQUFFO0FBQWxCLEtBQTVDO0FBQ0EsSUFBQSxJQUFJLENBQUMsUUFBTCxDQUFjLE1BQWQsRUFBc0IsUUFBdEIsRUFBZ0MsT0FBaEMsRUFBeUM7QUFBQyxNQUFBLGVBQWUsRUFBRTtBQUFsQixLQUF6QztBQUNELEdBeEI4QixDQTBCL0I7OztBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsU0FBbkIsZ0JBQW1CLENBQUEsRUFBRSxFQUFJO0FBQzdCO0FBQ0EsUUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxNQUFaLENBQVo7O0FBQ0EsNkJBQWtCLEdBQWxCLDRCQUF1QjtBQUFuQixVQUFNLElBQUksWUFBVjs7QUFDRixVQUFHLElBQUksSUFBSSxNQUFSLElBQWtCLEtBQUssQ0FBQyxRQUFOLENBQWUsTUFBTSxDQUFDLElBQUQsQ0FBTixDQUFhLE1BQTVCLENBQWxCLElBQ0QsTUFBTSxDQUFDLElBQUQsQ0FBTixDQUFhLE1BQWIsQ0FBb0IsS0FBcEIsTUFBK0IsRUFEakMsRUFDcUM7QUFDbkMsZUFBTyxNQUFNLENBQUMsSUFBRCxDQUFiO0FBQ0EsUUFBQSxnQkFBZ0IsQ0FBQyxJQUFELENBQWhCO0FBQ0Q7QUFDRjtBQUNGLEdBVkQ7O0FBV0EsRUFBQSxnQkFBZ0IsQ0FBQyxFQUFELENBQWhCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLGdCQUFULENBQTBCLEtBQTFCLEVBQWlDLE9BQWpDLEVBQTBDO0FBQ3hDO0FBQ0EsTUFBRyxLQUFLLENBQUMsT0FBTixDQUFjLEtBQWQsQ0FBSCxFQUF5QjtBQUN2QixXQUFPLEtBQUssQ0FBQyxHQUFOLENBQVUsVUFBQSxLQUFLO0FBQUEsYUFBSSxnQkFBZ0IsQ0FBQyxLQUFELEVBQVEsT0FBUixDQUFwQjtBQUFBLEtBQWYsQ0FBUDtBQUNEOztBQUVELE1BQUcsS0FBSyxDQUFDLFFBQU4sQ0FBZSxLQUFmLENBQUgsRUFBMEI7QUFDeEI7QUFDQSxRQUFHLGVBQWUsS0FBbEIsRUFBeUI7QUFDdkIsYUFBTyxLQUFLLENBQUMsV0FBRCxDQUFMLENBQW1CLENBQW5CLENBQVA7QUFDRCxLQUp1QixDQU14Qjs7O0FBQ0EsUUFBRyxVQUFVLENBQUMsT0FBWCxDQUFtQixLQUFuQixDQUFILEVBQThCO0FBQzVCLGFBQU8sS0FBUDtBQUNELEtBVHVCLENBV3hCOzs7QUFDQSxRQUFHLFVBQVUsQ0FBQyxNQUFYLENBQWtCLEtBQWxCLENBQUgsRUFBNkI7QUFDM0IsTUFBQSxLQUFLLENBQUMsT0FBRCxDQUFMLEdBQWlCLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxPQUFELENBQU4sRUFBaUIsT0FBakIsQ0FBakM7QUFDQSxhQUFPLEtBQVA7QUFDRCxLQWZ1QixDQWlCeEI7OztBQUNBLFFBQUcsU0FBUyxLQUFaLEVBQW1CO0FBQ2pCLFVBQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxLQUFELENBQWhCOztBQUNBLFVBQUcsT0FBTyxDQUFDLElBQVIsQ0FBYSxjQUFiLENBQTRCLEVBQTVCLENBQUgsRUFBb0M7QUFDbEMsWUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLElBQVIsQ0FBYSxFQUFiLEVBQWlCLE9BQWpCLENBQXlCLEtBQXpCLENBQVo7O0FBQ0EsWUFBRyxHQUFHLEtBQUssQ0FBQyxDQUFaLEVBQWU7QUFDYjtBQUNBLGlCQUFPLE9BQU8sQ0FBQyxJQUFSLENBQWEsRUFBYixFQUFpQixHQUFqQixDQUFQO0FBQ0QsU0FMaUMsQ0FNbEM7OztBQUNBLFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYSxFQUFiLEVBQWlCLElBQWpCLENBQXNCLEtBQXRCO0FBQ0QsT0FSRCxNQVFPO0FBQ0w7QUFDQSxRQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWEsRUFBYixJQUFtQixDQUFDLEtBQUQsQ0FBbkI7QUFDRDtBQUNGLEtBaEN1QixDQWtDeEI7OztBQUNBLFNBQUksSUFBTSxJQUFWLElBQWtCLEtBQWxCLEVBQXlCO0FBQ3ZCO0FBQ0EsVUFBRyxJQUFJLEtBQUssS0FBVCxJQUFrQixPQUFPLENBQUMsYUFBUixDQUFzQixRQUF0QixDQUErQixLQUFLLENBQUMsSUFBRCxDQUFwQyxDQUFyQixFQUFrRTtBQUNoRSxlQUFPLEtBQUssQ0FBQyxLQUFELENBQVo7QUFDQTtBQUNEOztBQUVELE1BQUEsS0FBSyxDQUFDLElBQUQsQ0FBTCxHQUFjLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFELENBQU4sRUFBYyxPQUFkLENBQTlCO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPLEtBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLGVBQVQsQ0FBeUIsTUFBekIsRUFBaUMsUUFBakMsRUFBMkMsTUFBM0MsRUFBbUQ7QUFDakQsTUFBRyxLQUFLLENBQUMsUUFBTixDQUFlLE1BQWYsQ0FBSCxFQUEyQjtBQUN6QixJQUFBLElBQUksQ0FBQyxRQUFMLENBQWMsTUFBZCxFQUFzQixRQUF0QixFQUFnQyxNQUFoQyxFQUF3QztBQUFDLE1BQUEsZUFBZSxFQUFFO0FBQWxCLEtBQXhDO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsSUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE1BQVo7QUFDRDtBQUNGO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxVQUFULENBQW9CLEtBQXBCLEVBQTJCLE9BQTNCLEVBQW9DLEtBQXBDLEVBQTJDLEtBQTNDLEVBQWtEO0FBQ2hELE1BQUcsRUFBRSxTQUFTLEtBQVgsQ0FBSCxFQUFzQjtBQUNwQixXQUFPLEtBQVA7QUFDRDs7QUFDRCxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsUUFBTixDQUFlLEtBQUssQ0FBQyxLQUFELENBQXBCLENBQW5CO0FBQ0EsU0FBTyxVQUFVLElBQUksY0FBYyxDQUFDLEtBQUQsRUFBUSxVQUFSLEVBQW9CLE9BQXBCLEVBQTZCLEtBQTdCLENBQW5DO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsV0FBVCxDQUFxQixPQUFyQixFQUE4QixLQUE5QixFQUFxQztBQUNuQyxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsUUFBRCxDQUFoQjtBQUNBLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxPQUFELENBQWhCO0FBQ0EsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLFdBQUQsQ0FBaEI7QUFDQSxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsUUFBRCxDQUFQLEdBQ1IsS0FBSyxDQUFDLE9BQU4sQ0FBYyxPQUFPLENBQUMsUUFBRCxDQUFyQixJQUNDLE9BQU8sQ0FBQyxRQUFELENBRFIsR0FDcUIsQ0FBQyxPQUFPLENBQUMsUUFBRCxDQUFSLENBRmIsR0FHVCxFQUhGO0FBSUEsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLE9BQUQsQ0FBUCxHQUNSLEtBQUssQ0FBQyxPQUFOLENBQWMsT0FBTyxDQUFDLE9BQUQsQ0FBckIsSUFDQyxPQUFPLENBQUMsT0FBRCxDQURSLEdBQ29CLENBQUMsT0FBTyxDQUFDLE9BQUQsQ0FBUixDQUZaLEdBR1QsRUFIRjtBQUlBLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxXQUFELENBQVAsR0FDUixLQUFLLENBQUMsT0FBTixDQUFjLE9BQU8sQ0FBQyxXQUFELENBQXJCLElBQ0MsT0FBTyxDQUFDLFdBQUQsQ0FEUixHQUN3QixDQUFDLE9BQU8sQ0FBQyxXQUFELENBQVIsQ0FGaEIsR0FHVCxFQUhGOztBQUtBLE1BQUcsRUFBRSxDQUFDLE1BQUgsS0FBYyxDQUFkLElBQW1CLEVBQUUsQ0FBQyxNQUFILEtBQWMsQ0FBakMsSUFBc0MsRUFBRSxDQUFDLE1BQUgsS0FBYyxDQUF2RCxFQUEwRDtBQUN4RCxXQUFPLElBQVA7QUFDRDs7QUFDRCxNQUFHLEVBQUUsRUFBRSxDQUFDLFFBQUgsQ0FBWSxFQUFaLEtBQW1CLEtBQUssQ0FBQyxhQUFOLENBQW9CLEVBQUUsQ0FBQyxDQUFELENBQXRCLENBQXJCLENBQUgsRUFBcUQ7QUFDbkQsV0FBTyxLQUFQO0FBQ0Q7O0FBQ0QsTUFBRyxFQUFFLENBQUMsRUFBRCxJQUFPLEVBQUUsQ0FBQyxNQUFILEtBQWMsQ0FBckIsSUFBMEIsRUFBRSxDQUFDLFFBQUgsQ0FBWSxFQUFaLENBQTFCLElBQTZDLEVBQUUsSUFDbEQsS0FBSyxDQUFDLGFBQU4sQ0FBb0IsRUFBRSxDQUFDLENBQUQsQ0FBdEIsQ0FEQyxDQUFILEVBQytCO0FBQzdCLFdBQU8sS0FBUDtBQUNEOztBQUNELE1BQUcsRUFBRSxDQUFDLEVBQUQsSUFBTyxFQUFFLENBQUMsTUFBSCxLQUFjLENBQXJCLElBQTBCLEVBQUUsQ0FBQyxRQUFILENBQVksRUFBWixDQUExQixJQUE2QyxFQUFFLElBQ2xELEtBQUssQ0FBQyxhQUFOLENBQW9CLEVBQUUsQ0FBQyxDQUFELENBQXRCLENBREMsQ0FBSCxFQUMrQjtBQUM3QixXQUFPLEtBQVA7QUFDRDs7QUFDRCxTQUFPLElBQVA7QUFDRDs7O0FDeHpCRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxlQUFELENBQTNCOztBQUNBLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxjQUFELENBQTFCOztBQUNBLElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFELENBQXJCOztBQUNBLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFELENBQXBCLEMsQ0FFQTs7O2VBbUJJLE9BQU8sQ0FBQyxhQUFELEM7SUFoQlQsUSxZQUFBLFE7SUFDQSxTLFlBQUEsUztJQUNBLFEsWUFBQSxRO0lBQ0EsTyxZQUFBLE87SUFDQSxRLFlBQUEsUTtJQUdBLGdCLFlBQUEsZ0I7SUFLQSxXLFlBQUEsVztJQUNBLFUsWUFBQSxVO0lBQ0EsVyxZQUFBLFc7SUFDQSxVLFlBQUEsVTs7QUFHRixJQUFNLFdBQVcsR0FBRyxxQ0FBcEI7QUFFQSxJQUFNLEdBQUcsR0FBRyxFQUFaO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsR0FBakI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLEdBQUcsQ0FBQyxPQUFKO0FBQUEsNEZBQWMsaUJBQ1osT0FEWTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUNBR1YsVUFIVSxFQUdWLFVBSFUsZ0NBR0csS0FISCwrQ0FJVixjQUpVLEVBSVYsY0FKVSxvQ0FJTyxLQUpQLGlEQUtWLFlBTFUsRUFLVixZQUxVLGtDQUtLLElBTEw7QUFRTixZQUFBLFlBUk0sR0FRUyxFQVJUO0FBU04sWUFBQSxRQVRNLEdBU0s7QUFBQywwQkFBWTtBQUFiLGFBVEw7QUFVTixZQUFBLGNBVk0sR0FVVyxFQVZYO0FBQUEsbURBWU0sT0FaTjtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBWUYsWUFBQSxJQVpFO0FBYVY7QUFDTSxZQUFBLEtBZEksR0FjSSxJQUFJLENBQUMsS0FBTCxDQUFXLFFBQVgsS0FBd0IsY0FBekIsR0FDWCxVQURXLEdBQ0UsSUFBSSxDQUFDLEtBQUwsQ0FBVyxLQWZoQjs7QUFnQlYsZ0JBQUcsRUFBRSxLQUFJLElBQUksUUFBVixDQUFILEVBQXdCO0FBQ3RCLGNBQUEsUUFBUSxDQUFDLEtBQUQsQ0FBUixHQUFpQixFQUFqQjtBQUNEOztBQUNELGdCQUFHLEtBQUksS0FBSyxVQUFULElBQXVCLEVBQUUsS0FBSSxJQUFJLFlBQVYsQ0FBMUIsRUFBbUQ7QUFDakQsY0FBQSxZQUFZLENBQUMsS0FBRCxDQUFaLEdBQXFCO0FBQUMsdUJBQU87QUFBUixlQUFyQjtBQUNEOztBQUVLLFlBQUEsT0F2QkksR0F1Qk0sUUFBUSxDQUFDLEtBQUQsQ0F2QmQsRUF5QlY7O0FBQ00sWUFBQSxDQTFCSSxHQTBCQSxJQUFJLENBQUMsT0FBTCxDQUFhLEtBMUJiO0FBMkJKLFlBQUEsQ0EzQkksR0EyQkEsSUFBSSxDQUFDLFNBQUwsQ0FBZSxLQTNCZjtBQTRCSixZQUFBLENBNUJJLEdBNEJBLElBQUksQ0FBQyxNQTVCTDs7QUE4QlYsZ0JBQUcsRUFBRSxDQUFDLElBQUksT0FBUCxDQUFILEVBQW9CO0FBQ2xCLGNBQUEsT0FBTyxDQUFDLENBQUQsQ0FBUCxHQUFhO0FBQUMsdUJBQU87QUFBUixlQUFiO0FBQ0Q7O0FBQ0ssWUFBQSxLQWpDSSxHQWlDRyxPQUFPLENBQUMsQ0FBRCxDQWpDVjtBQW1DSixZQUFBLFlBbkNJLEdBbUNXLENBQUMsQ0FBQyxRQUFGLENBQVcsUUFBWCxDQUFvQixNQUFwQixDQW5DWDs7QUFvQ1YsZ0JBQUcsWUFBWSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUYsSUFBVyxPQUFiLENBQW5CLEVBQTBDO0FBQ3hDLGNBQUEsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFILENBQVAsR0FBbUI7QUFBQyx1QkFBTyxDQUFDLENBQUM7QUFBVixlQUFuQjtBQUNEOztBQXRDUyxrQkF3Q1AsQ0FBQyxLQUFLLFFBQU4sSUFBa0IsQ0FBQyxVQUFuQixJQUFpQyxZQXhDMUI7QUFBQTtBQUFBO0FBQUE7O0FBeUNSLFlBQUEsSUFBSSxDQUFDLFFBQUwsQ0FBYyxLQUFkLEVBQW9CLE9BQXBCLEVBQTZCLENBQUMsQ0FBQyxLQUEvQixFQUFzQztBQUFDLGNBQUEsZUFBZSxFQUFFO0FBQWxCLGFBQXRDO0FBekNROztBQUFBO0FBNkNKLFlBQUEsS0E3Q0ksR0E2Q0ksWUFBWSxDQUFDLENBQUQsRUFBSSxjQUFKLEVBQW9CLFlBQXBCLENBN0NoQjtBQThDVixZQUFBLElBQUksQ0FBQyxRQUFMLENBQWMsS0FBZCxFQUFvQixDQUFwQixFQUF1QixLQUF2QixFQUE4QjtBQUFDLGNBQUEsZUFBZSxFQUFFO0FBQWxCLGFBQTlCLEVBOUNVLENBZ0RWO0FBQ0E7O0FBQ0EsZ0JBQUcsWUFBSCxFQUFpQjtBQUNmLGtCQUFHLENBQUMsQ0FBQyxLQUFGLEtBQVksT0FBZixFQUF3QjtBQUN0QjtBQUNNLGdCQUFBLE1BRmdCLEdBRVAsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFILENBRkE7O0FBR3RCLG9CQUFHLEVBQUUsWUFBWSxNQUFkLENBQUgsRUFBMEI7QUFDeEIsa0JBQUEsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsRUFBaEI7QUFDRDs7QUFDRCxnQkFBQSxNQUFNLENBQUMsTUFBUCxDQUFjLElBQWQsQ0FBbUI7QUFDakIsa0JBQUEsSUFBSSxFQUFKLEtBRGlCO0FBRWpCLGtCQUFBLFFBQVEsRUFBRSxDQUZPO0FBR2pCLGtCQUFBLEtBQUssRUFBTDtBQUhpQixpQkFBbkI7QUFLRCxlQVhELE1BV08sSUFBRyxDQUFDLENBQUMsS0FBRixJQUFXLGNBQWQsRUFBOEI7QUFDbkM7QUFDQSxnQkFBQSxjQUFjLENBQUMsQ0FBQyxDQUFDLEtBQUgsQ0FBZCxHQUEwQixLQUExQjtBQUNELGVBSE0sTUFHQTtBQUNMO0FBQ0EsZ0JBQUEsY0FBYyxDQUFDLENBQUMsQ0FBQyxLQUFILENBQWQsR0FBMEI7QUFDeEIsa0JBQUEsSUFBSSxFQUFKLEtBRHdCO0FBRXhCLGtCQUFBLFFBQVEsRUFBRSxDQUZjO0FBR3hCLGtCQUFBLEtBQUssRUFBTDtBQUh3QixpQkFBMUI7QUFLRDtBQUNGOztBQXpFUztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUEsdURBOElNLFFBOUlOOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBOElGLFlBQUEsSUE5SUU7QUErSUosWUFBQSxXQS9JSSxHQStJVSxRQUFRLENBQUMsSUFBRCxDQS9JbEIsRUFpSlY7O0FBakpVLGdCQWtKTCxPQUFPLElBQUksV0FsSk47QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFzSlY7QUFDTSxZQUFBLEdBdkpJLEdBdUpFLFdBQVcsQ0FBQyxPQUFELENBdkpiOztBQUFBLGdCQXdKTixHQUFHLENBQUMsTUF4SkU7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQSxvREEySk8sR0FBRyxDQUFDLE1BM0pYO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEySkYsWUFBQSxLQTNKRTtBQTRKSixZQUFBLElBNUpJLEdBNEpHLEtBQUssQ0FBQyxJQTVKVDtBQTZKSixZQUFBLFFBN0pJLEdBNkpPLEtBQUssQ0FBQyxRQTdKYjtBQThKSixZQUFBLElBOUpJLEdBOEpHLEtBQUssQ0FBQyxLQTlKVDtBQStKRixZQUFBLElBL0pFLEdBK0pLLEVBL0pMO0FBZ0tGLFlBQUEsU0FoS0UsR0FnS1UsRUFoS1YsRUFrS1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNJLFlBQUEsWUF4S0ksR0F3S1csTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFaLEVBQWtCLE1BeEs3Qjs7QUFBQTtBQUFBLGtCQXlLRixRQUFRLEtBQUssUUFBYixJQUNKLEtBQUssQ0FBQyxRQUFOLENBQWUsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFELENBQUwsQ0FBN0IsQ0FESSxJQUVKLEtBQUssQ0FBQyxPQUFOLENBQWMsSUFBSSxDQUFDLFNBQUQsQ0FBbEIsQ0FGSSxJQUU4QixJQUFJLENBQUMsU0FBRCxDQUFKLENBQWdCLE1BQWhCLEtBQTJCLENBRnpELElBR0osS0FBSyxDQUFDLE9BQU4sQ0FBYyxJQUFJLENBQUMsUUFBRCxDQUFsQixDQUhJLElBRzZCLElBQUksQ0FBQyxRQUFELENBQUosQ0FBZSxNQUFmLEtBQTBCLENBSHZELEtBSUgsWUFBWSxLQUFLLENBQWpCLElBQ0UsWUFBWSxLQUFLLENBQWpCLElBQXNCLEtBQUssQ0FBQyxPQUFOLENBQWMsSUFBSSxDQUFDLE9BQUQsQ0FBbEIsQ0FBdEIsSUFDRCxJQUFJLENBQUMsT0FBRCxDQUFKLENBQWMsTUFBZCxLQUF5QixDQUR4QixJQUM2QixJQUFJLENBQUMsT0FBRCxDQUFKLENBQWMsQ0FBZCxNQUFxQixRQU5qRCxDQXpLRTtBQUFBO0FBQUE7QUFBQTs7QUFnTE4sWUFBQSxJQUFJLENBQUMsSUFBTCxDQUFVLElBQUksQ0FBQyxTQUFELENBQUosQ0FBZ0IsQ0FBaEIsQ0FBVjtBQUNBLFlBQUEsU0FBUyxDQUFDLElBQVYsQ0FBZSxJQUFJLENBQUMsS0FBRCxDQUFuQixFQWpMTSxDQW1MTjs7QUFDQSxZQUFBLEtBQUssR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUQsQ0FBTCxDQUF0QjtBQUNBLFlBQUEsSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFiO0FBQ0EsWUFBQSxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQWpCO0FBQ0EsWUFBQSxJQUFJLEdBQUcsS0FBSyxDQUFDLEtBQWI7QUFDQSxZQUFBLFlBQVksR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLElBQVosRUFBa0IsTUFBakMsQ0F4TE0sQ0EwTE47O0FBMUxNLGdCQTJMRixVQUFVLENBQUMsV0FBWCxDQUF1QixJQUF2QixDQTNMRTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFnTVI7QUFDQSxtQkFBTyxJQUFJLENBQUMsS0FBRCxDQUFYO0FBQ0EsWUFBQSxJQUFJLENBQUMsT0FBRCxDQUFKLEdBQWdCLElBQUksQ0FBQyxPQUFMLEVBQWhCOztBQUNBLHNDQUFzQixTQUF0QixnQ0FBaUM7QUFBdkIsY0FBQSxRQUF1QjtBQUMvQixxQkFBTyxXQUFXLENBQUMsUUFBRCxDQUFsQjtBQUNEOztBQXJNTztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBd01WLG1CQUFPLEdBQUcsQ0FBQyxNQUFYO0FBeE1VO0FBQUE7O0FBQUE7QUEyTU4sWUFBQSxNQTNNTSxHQTJNRyxFQTNNSDtBQTRNTixZQUFBLFFBNU1NLEdBNE1LLE1BQU0sQ0FBQyxJQUFQLENBQVksWUFBWixFQUEwQixJQUExQixFQTVNTDtBQUFBLG9EQTZNUyxRQTdNVDs7QUFBQTtBQTZNWixxRUFBK0I7QUFBckIsZ0JBQUEsT0FBcUI7QUFDdkIsZ0JBQUEsTUFEdUIsR0FDaEIsWUFBWSxDQUFDLE9BQUQsQ0FESTs7QUFFN0Isb0JBQUcsT0FBTyxJQUFJLFFBQWQsRUFBd0I7QUFDaEIsa0JBQUEsS0FEZ0IsR0FDUixNQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCLEVBRFQ7QUFFaEIsa0JBQUEsWUFGZ0IsR0FFRixRQUFRLENBQUMsT0FBRCxDQUZOO0FBR2hCLGtCQUFBLGFBSGdCLEdBR0EsTUFBTSxDQUFDLElBQVAsQ0FBWSxZQUFaLEVBQXlCLElBQXpCLEVBSEE7QUFBQSwwREFJSSxhQUpKOztBQUFBO0FBSXRCLDJFQUF5QztBQUEvQixzQkFBQSxZQUErQjtBQUNqQyxzQkFBQSxNQURpQyxHQUMxQixZQUFXLENBQUMsWUFBRCxDQURlLEVBRXZDOztBQUNBLDBCQUFHLENBQUMsVUFBVSxDQUFDLGtCQUFYLENBQThCLE1BQTlCLENBQUosRUFBeUM7QUFDdkMsd0JBQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxNQUFYO0FBQ0Q7QUFDRjtBQVZxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBV3ZCLGlCQWI0QixDQWM3Qjs7O0FBQ0Esb0JBQUcsQ0FBQyxVQUFVLENBQUMsa0JBQVgsQ0FBOEIsTUFBOUIsQ0FBSixFQUF5QztBQUN2QyxrQkFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE1BQVo7QUFDRDtBQUNGO0FBL05XO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkNBaU9MLE1Bak9LOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQWQ7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxZQUFULENBQXNCLENBQXRCLEVBQXlCLGNBQXpCLEVBQXlDLFlBQXpDLEVBQXVEO0FBQ3JEO0FBQ0EsTUFBRyxDQUFDLENBQUMsUUFBRixDQUFXLFFBQVgsQ0FBb0IsTUFBcEIsQ0FBSCxFQUFnQztBQUM5QixXQUFPO0FBQUMsYUFBTyxDQUFDLENBQUM7QUFBVixLQUFQO0FBQ0QsR0FKb0QsQ0FNckQ7OztBQUNBLE1BQU0sSUFBSSxHQUFHO0FBQUMsY0FBVSxDQUFDLENBQUM7QUFBYixHQUFiLENBUHFELENBU3JEOztBQUNBLE1BQUcsQ0FBQyxDQUFDLFFBQUwsRUFBZTtBQUNiLElBQUEsSUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQixDQUFDLENBQUMsUUFBdEI7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFJLElBQUksR0FBRyxDQUFDLENBQUMsUUFBRixDQUFXLEtBQXRCOztBQUNBLFFBQUcsQ0FBQyxJQUFKLEVBQVU7QUFDUixNQUFBLElBQUksR0FBRyxVQUFQO0FBQ0Q7O0FBQ0QsUUFBRyxJQUFJLEtBQUssZ0JBQVosRUFBOEI7QUFDNUIsTUFBQSxJQUFJLEdBQUcsT0FBUDs7QUFDQSxVQUFJO0FBQ0YsUUFBQSxJQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCLElBQUksQ0FBQyxLQUFMLENBQVcsSUFBSSxDQUFDLFFBQUQsQ0FBZixDQUFqQjtBQUNELE9BRkQsQ0FFRSxPQUFNLENBQU4sRUFBUztBQUNULGNBQU0sSUFBSSxXQUFKLENBQ0osbUNBREksRUFFSiwyQkFGSSxFQUdKO0FBQUMsVUFBQSxJQUFJLEVBQUUsc0JBQVA7QUFBK0IsVUFBQSxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQUQsQ0FBMUM7QUFBc0QsVUFBQSxLQUFLLEVBQUU7QUFBN0QsU0FISSxDQUFOO0FBSUQ7QUFDRixLQWZJLENBZ0JMOzs7QUFDQSxRQUFHLGNBQUgsRUFBbUI7QUFDakIsVUFBRyxJQUFJLEtBQUssV0FBWixFQUF5QjtBQUN2QixZQUFHLElBQUksQ0FBQyxRQUFELENBQUosS0FBbUIsTUFBdEIsRUFBOEI7QUFDNUIsVUFBQSxJQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCLElBQWpCO0FBQ0QsU0FGRCxNQUVPLElBQUcsSUFBSSxDQUFDLFFBQUQsQ0FBSixLQUFtQixPQUF0QixFQUErQjtBQUNwQyxVQUFBLElBQUksQ0FBQyxRQUFELENBQUosR0FBaUIsS0FBakI7QUFDRDtBQUNGLE9BTkQsTUFNTyxJQUFHLEtBQUssQ0FBQyxTQUFOLENBQWdCLElBQUksQ0FBQyxRQUFELENBQXBCLENBQUgsRUFBb0M7QUFDekMsWUFBRyxJQUFJLEtBQUssV0FBWixFQUF5QjtBQUN2QixjQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQUQsQ0FBTCxFQUFpQixFQUFqQixDQUFsQjs7QUFDQSxjQUFHLENBQUMsQ0FBQyxPQUFGLENBQVUsQ0FBVixNQUFpQixJQUFJLENBQUMsUUFBRCxDQUF4QixFQUFvQztBQUNsQyxZQUFBLElBQUksQ0FBQyxRQUFELENBQUosR0FBaUIsQ0FBakI7QUFDRDtBQUNGLFNBTEQsTUFLTyxJQUFHLElBQUksS0FBSyxVQUFaLEVBQXdCO0FBQzdCLFVBQUEsSUFBSSxDQUFDLFFBQUQsQ0FBSixHQUFpQixVQUFVLENBQUMsSUFBSSxDQUFDLFFBQUQsQ0FBTCxDQUEzQjtBQUNEO0FBQ0YsT0FoQmdCLENBaUJqQjs7O0FBQ0EsVUFBRyxDQUFDLENBQUMsV0FBRCxFQUFjLFdBQWQsRUFBMkIsVUFBM0IsRUFBdUMsVUFBdkMsRUFBbUQsUUFBbkQsQ0FBNEQsSUFBNUQsQ0FBSixFQUF1RTtBQUNyRSxRQUFBLElBQUksQ0FBQyxPQUFELENBQUosR0FBZ0IsSUFBaEI7QUFDRDtBQUNGLEtBckJELE1BcUJPLElBQUcsWUFBWSxLQUFLLGVBQWpCLElBQ1IsSUFBSSxDQUFDLFVBQUwsQ0FBZ0IsNkJBQWhCLENBREssRUFDMkM7QUFBQSx3QkFDaEIsSUFBSSxDQUFDLEtBQUwsQ0FBVyxNQUFYLENBRGdCO0FBQUE7QUFBQSxVQUN2QyxRQUR1QztBQUFBLFVBQzdCLFNBRDZCOztBQUVoRCxVQUFHLFFBQVEsQ0FBQyxNQUFULEdBQWtCLENBQXJCLEVBQXdCO0FBQ3RCLFFBQUEsSUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQixRQUFwQjs7QUFDQSxZQUFHLENBQUMsUUFBUSxDQUFDLEtBQVQsQ0FBZSxXQUFmLENBQUosRUFBaUM7QUFDL0IsVUFBQSxPQUFPLENBQUMsSUFBUiwwQ0FBK0MsUUFBL0M7QUFDRDtBQUNGOztBQUNELE1BQUEsSUFBSSxDQUFDLFlBQUQsQ0FBSixHQUFxQixTQUFyQjtBQUNELEtBVk0sTUFVQSxJQUFHLElBQUksS0FBSyxVQUFaLEVBQXdCO0FBQzdCLE1BQUEsSUFBSSxDQUFDLE9BQUQsQ0FBSixHQUFnQixJQUFoQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxJQUFQO0FBQ0Q7OztBQzFWRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBRCxDQUFyQjs7QUFFQSxJQUFNLEdBQUcsR0FBRyxFQUFaO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsR0FBakI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxHQUFHLENBQUMsU0FBSixHQUFnQixVQUFBLENBQUMsRUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUcsS0FBSyxDQUFDLFFBQU4sQ0FBZSxDQUFmLEtBQ0QsRUFBRyxZQUFZLENBQWIsSUFBb0IsVUFBVSxDQUE5QixJQUFxQyxXQUFXLENBQWxELENBREYsRUFDeUQ7QUFDdkQsUUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxDQUFaLEVBQWUsTUFBaEM7QUFDQSxXQUFRLFFBQVEsR0FBRyxDQUFYLElBQWdCLEVBQUUsU0FBUyxDQUFYLENBQXhCO0FBQ0Q7O0FBQ0QsU0FBTyxLQUFQO0FBQ0QsQ0FYRDtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsa0JBQUosR0FBeUIsVUFBQSxDQUFDO0FBQUEsU0FDeEI7QUFDQTtBQUNBO0FBQ0MsSUFBQSxLQUFLLENBQUMsUUFBTixDQUFlLENBQWYsS0FBcUIsTUFBTSxDQUFDLElBQVAsQ0FBWSxDQUFaLEVBQWUsTUFBZixLQUEwQixDQUEvQyxJQUFxRCxTQUFTO0FBSnZDO0FBQUEsQ0FBMUI7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLE9BQUosR0FBYyxVQUFBLENBQUM7QUFBQSxTQUNiO0FBQ0E7QUFDQTtBQUNBLElBQUEsS0FBSyxDQUFDLFFBQU4sQ0FBZSxDQUFmLEtBQXNCLFlBQVk7QUFKckI7QUFBQSxDQUFmO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsVUFBQSxDQUFDO0FBQUEsU0FDWjtBQUNBO0FBQ0E7QUFDQSxJQUFBLEtBQUssQ0FBQyxRQUFOLENBQWUsQ0FBZixLQUFzQixXQUFXO0FBSnJCO0FBQUEsQ0FBZDtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxPQUFKLEdBQWMsVUFBQSxDQUFDLEVBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPLEtBQUssQ0FBQyxRQUFOLENBQWUsQ0FBZixLQUNMLFlBQVksQ0FEUCxJQUVMLE1BQU0sQ0FBQyxJQUFQLENBQVksQ0FBWixFQUNHLE1BREgsQ0FDVSxVQUFBLEdBQUc7QUFBQSxXQUFJLEdBQUcsS0FBSyxLQUFSLElBQWlCLEdBQUcsS0FBSyxRQUE3QjtBQUFBLEdBRGIsRUFDb0QsTUFEcEQsS0FDK0QsQ0FIakU7QUFJRCxDQVREO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLGFBQUosR0FBb0IsVUFBQSxDQUFDLEVBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPLEdBQUcsQ0FBQyxPQUFKLENBQVksQ0FBWixLQUFrQixFQUFFLFNBQVMsQ0FBWCxDQUF6QjtBQUNELENBTkQ7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFdBQUosR0FBa0IsVUFBQSxDQUFDLEVBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFHLEtBQUssQ0FBQyxRQUFOLENBQWUsQ0FBZixDQUFILEVBQXNCO0FBQ3BCLFFBQUcsU0FBUyxDQUFaLEVBQWU7QUFDYixhQUFRLENBQUMsQ0FBQyxLQUFELENBQUQsQ0FBUyxPQUFULENBQWlCLElBQWpCLE1BQTJCLENBQW5DO0FBQ0Q7O0FBQ0QsV0FBUSxNQUFNLENBQUMsSUFBUCxDQUFZLENBQVosRUFBZSxNQUFmLEtBQTBCLENBQTFCLElBQ04sRUFBRyxZQUFZLENBQWIsSUFBb0IsVUFBVSxDQUE5QixJQUFxQyxXQUFXLENBQWxELENBREY7QUFFRDs7QUFDRCxTQUFPLEtBQVA7QUFDRCxDQWJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLGNBQUQsQ0FBeEI7O0FBQ0EsSUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQUQsQ0FBcEI7O0FBQ0EsSUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLG1CQUFELENBQS9COztBQUNBLElBQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUE5Qjs7QUFDQSxJQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsZUFBRCxDQUEzQjs7QUFDQSxJQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsV0FBRCxDQUFuQjs7QUFDQSxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBRCxDQUF0Qjs7QUFDQSxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsUUFBRCxDQUFwQjs7ZUFFMEIsT0FBTyxDQUFDLFVBQUQsQztJQUFsQixPLFlBQVIsTTs7Z0JBQ3FCLE9BQU8sQ0FBQyxXQUFELEM7SUFBbkIsUSxhQUFULE87O2dCQUNxQixPQUFPLENBQUMsV0FBRCxDO0lBQW5CLFEsYUFBVCxPOztnQkFDaUIsT0FBTyxDQUFDLFNBQUQsQztJQUFqQixNLGFBQVAsSzs7Z0JBS0gsT0FBTyxDQUFDLFNBQUQsQztJQUZhLHFCLGFBQXRCLG9CO0lBQ2EsWSxhQUFiLFc7O2dCQU9FLE9BQU8sQ0FBQyxTQUFELEM7SUFIQSxRLGFBQVQsTztJQUNVLFMsYUFBVixRO0lBQ1UsUyxhQUFWLFE7O2dCQUtFLE9BQU8sQ0FBQyxjQUFELEM7SUFEVyxtQixhQUFwQixrQjs7Z0JBUUUsT0FBTyxDQUFDLFdBQUQsQztJQUpFLFUsYUFBWCxTO0lBQ21CLGtCLGFBQW5CLGlCO0lBQ1MsZSxhQUFULE87SUFDZ0IsZSxhQUFoQixjOztnQkFNRSxPQUFPLENBQUMsV0FBRCxDO0lBRkEsUSxhQUFULE87SUFDWSxXLGFBQVosVTs7aUJBT0UsT0FBTyxDQUFDLFdBQUQsQztJQUhNLGMsY0FBZixhO0lBQ3FCLG9CLGNBQXJCLG1CO0lBQ2UsYyxjQUFmLGEsRUFHRjs7O0FBQ0EsSUFBTSxPQUFPLEdBQ1gsT0FBTyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDLE9BQU8sQ0FBQyxRQUExQyxJQUFzRCxPQUFPLENBQUMsUUFBUixDQUFpQixJQUR6RTs7QUFFQSxJQUFNLFFBQVEsR0FBRyxDQUFDLE9BQUQsS0FDZCxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUMsT0FBTyxJQUFQLEtBQWdCLFdBRG5DLENBQWpCO0FBR0E7QUFDQTs7O0FBQ0EsSUFBTSxPQUFPLEdBQUcsU0FBVixPQUFVLENBQVMsTUFBVCxFQUFpQjtBQUVqQztBQUNBLE1BQU0sV0FBVyxHQUFHLEVBQXBCLENBSGlDLENBS2pDO0FBQ0E7O0FBQ0EsTUFBTSwrQkFBK0IsR0FBRyxHQUF4Qzs7QUFDQSxNQUFNLHFCQUFxQixHQUFHLElBQUksR0FBSixDQUFRO0FBQUMsSUFBQSxHQUFHLEVBQUU7QUFBTixHQUFSLENBQTlCO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsRUFBQSxNQUFNLENBQUMsT0FBUDtBQUFBLDZGQUFpQixpQkFBZSxLQUFmLEVBQXNCLEdBQXRCLEVBQTJCLE9BQTNCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUNaLE1BQVUsTUFBVixHQUFtQixDQURQO0FBQUE7QUFBQTtBQUFBOztBQUFBLG9CQUVQLElBQUksU0FBSixDQUFjLHVDQUFkLENBRk87O0FBQUE7QUFBQSxvQkFLWixHQUFHLEtBQUssSUFMSTtBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFNUCxJQUFJLFdBQUosQ0FDSiwwQ0FESSxFQUVKLHFCQUZJLEVBRW1CO0FBQUMsZ0JBQUEsSUFBSSxFQUFFO0FBQVAsZUFGbkIsQ0FOTzs7QUFBQTtBQUFBLG9CQVlaLEtBQUssS0FBSyxJQVpFO0FBQUE7QUFBQTtBQUFBOztBQUFBLCtDQWFOLElBYk07O0FBQUE7QUFnQmY7QUFDQSxjQUFBLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBRCxFQUFVO0FBQzlCLGdCQUFBLElBQUksRUFBRSxTQUFTLENBQUMsS0FBRCxDQUFULEdBQW1CLEtBQW5CLEdBQTJCLEVBREg7QUFFOUIsZ0JBQUEsYUFBYSxFQUFFLElBRmU7QUFHOUIsZ0JBQUEsaUJBQWlCLEVBQUUsSUFIVztBQUk5QixnQkFBQSxLQUFLLEVBQUUsS0FKdUI7QUFLOUIsZ0JBQUEsYUFBYSxFQUFFLEtBTGU7QUFNOUIsZ0JBQUEsSUFBSSxFQUFFLEtBTndCO0FBTzlCLGdCQUFBLE1BQU0sRUFBRSxJQUFJLGdCQUFKLENBQXFCLEtBQXJCLENBUHNCO0FBUTlCLGdCQUFBLGVBQWUsRUFBRSxJQUFJLGVBQUosQ0FDZjtBQUFDLGtCQUFBLFdBQVcsRUFBRTtBQUFkLGlCQURlO0FBUmEsZUFBVixDQUF0Qjs7QUFXQSxrQkFBRyxPQUFPLENBQUMsSUFBWCxFQUFpQjtBQUNmO0FBQ0E7QUFDQSxnQkFBQSxPQUFPLENBQUMsYUFBUixHQUF3QixJQUF4QjtBQUNEOztBQUNELGtCQUFHLENBQUMsT0FBTyxDQUFDLGlCQUFaLEVBQStCO0FBQzdCLHVCQUFPLE9BQU8sQ0FBQyxJQUFmO0FBQ0QsZUFuQ2MsQ0FxQ2Y7OztBQXJDZSxtQkF1Q1osT0FBTyxDQUFDLGFBdkNJO0FBQUE7QUFBQTtBQUFBOztBQXdDYixjQUFBLFFBQVEsR0FBRyxLQUFYO0FBeENhO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHFCQTBDSSxNQUFNLENBQUMsTUFBUCxDQUFjLEtBQWQsRUFBcUIsT0FBckIsQ0ExQ0o7O0FBQUE7QUEwQ2IsY0FBQSxRQTFDYTs7QUFBQTtBQUFBO0FBQUEscUJBOENTLE1BQU0sQ0FBQyxjQUFQLENBQ3RCLGtCQUFrQixDQUFDLE9BQUQsQ0FESSxFQUNPLEdBRFAsRUFDWSxPQURaLENBOUNUOztBQUFBO0FBOENULGNBQUEsU0E5Q1M7QUFBQTtBQUFBLHFCQWtETyxRQUFRLENBQUM7QUFDN0IsZ0JBQUEsU0FBUyxFQUFULFNBRDZCO0FBRTdCLGdCQUFBLE9BQU8sRUFBRSxRQUZvQjtBQUc3QixnQkFBQSxPQUFPLEVBQVAsT0FINkI7QUFJN0IsZ0JBQUEsYUFBYSxFQUFFLE9BQU8sQ0FBQztBQUpNLGVBQUQsQ0FsRGY7O0FBQUE7QUFrRFgsY0FBQSxTQWxEVzs7QUF5RGY7QUFDQSxrQkFBRyxPQUFPLENBQUMsYUFBUixJQUF5QixDQUFDLE9BQU8sQ0FBQyxLQUFsQyxJQUEyQyxRQUFRLENBQUMsU0FBRCxDQUF0RCxFQUFtRTtBQUNqRSxvQkFBRyxTQUFTLENBQUMsTUFBVixLQUFxQixDQUF4QixFQUEyQjtBQUN6QjtBQUNBLGtCQUFBLFNBQVMsR0FBRyxTQUFTLENBQUMsQ0FBRCxDQUFyQjtBQUNELGlCQUhELE1BR08sSUFBRyxTQUFTLENBQUMsTUFBVixLQUFxQixDQUF4QixFQUEyQjtBQUNoQztBQUNBLGtCQUFBLFNBQVMsR0FBRyxFQUFaO0FBQ0Q7QUFDRixlQVJELE1BUU8sSUFBRyxPQUFPLENBQUMsS0FBUixJQUFpQixTQUFTLENBQUMsU0FBRCxDQUE3QixFQUEwQztBQUMvQztBQUNBLGdCQUFBLFNBQVMsR0FBRyxDQUFDLFNBQUQsQ0FBWjtBQUNELGVBckVjLENBdUVmOzs7QUFDQSxrQkFBRyxTQUFTLENBQUMsR0FBRCxDQUFULElBQWtCLGNBQWMsR0FBbkMsRUFBd0M7QUFDdEMsZ0JBQUEsR0FBRyxHQUFHLEdBQUcsQ0FBQyxVQUFELENBQVQ7QUFDRCxlQTFFYyxDQTRFZjs7O0FBQ0EsY0FBQSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxHQUFYLENBQU47O0FBQ0Esa0JBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRCxDQUFaLEVBQW1CO0FBQ2pCLGdCQUFBLEdBQUcsR0FBRyxDQUFDLEdBQUQsQ0FBTjtBQUNELGVBaEZjLENBaUZmOzs7QUFDTSxjQUFBLEdBbEZTLEdBa0ZILEdBbEZHO0FBbUZmLGNBQUEsR0FBRyxHQUFHLEVBQU47O0FBQ0EsbUJBQVEsQ0FBUixHQUFZLENBQVosRUFBZSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQXZCLEVBQStCLEVBQUUsQ0FBakMsRUFBb0M7QUFDbEMsb0JBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUQsQ0FBSixDQUFWLElBQXNCLE1BQU0sQ0FBQyxJQUFQLENBQVksR0FBRyxDQUFDLENBQUQsQ0FBZixFQUFvQixNQUFwQixHQUE2QixDQUF0RCxFQUF5RDtBQUN2RCxrQkFBQSxHQUFHLENBQUMsSUFBSixDQUFTLEdBQUcsQ0FBQyxDQUFELENBQVo7QUFDRDtBQUNGLGVBeEZjLENBMEZmOzs7QUFDTSxjQUFBLFVBM0ZTLEdBMkZLLEdBQUcsQ0FBQyxNQUFKLEdBQWEsQ0EzRmxCOztBQTRGZixrQkFBRyxHQUFHLENBQUMsTUFBSixLQUFlLENBQWxCLEVBQXFCO0FBQ25CLGdCQUFBLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBRCxDQUFUO0FBQ0QsZUE5RmMsQ0FnR2Y7OztBQUNBLGtCQUFHLFFBQVEsQ0FBQyxTQUFELENBQVgsRUFBd0I7QUFDdEI7QUFDTSxnQkFBQSxVQUZnQixHQUVILFdBQVcsQ0FBQztBQUM3QixrQkFBQSxTQUFTLEVBQVQsU0FENkI7QUFDbEIsa0JBQUEsR0FBRyxFQUFFLFFBRGE7QUFDSCxrQkFBQSxVQUFVLEVBQUU7QUFBQyxvQkFBQSxLQUFLLEVBQUU7QUFBUjtBQURULGlCQUFELENBRlI7QUFLaEIsZ0JBQUEsS0FMZ0IsR0FLUixTQUxRO0FBTXRCLGdCQUFBLFNBQVMsR0FBRyxFQUFaOztBQUNBLG9CQUFHLFVBQUgsRUFBZTtBQUNiLGtCQUFBLFNBQVMsQ0FBQyxVQUFELENBQVQsR0FBd0IsR0FBeEI7QUFDRDs7QUFDRCxnQkFBQSxTQUFTLENBQUMsVUFBRCxDQUFULEdBQXdCLEtBQXhCO0FBQ0QsZUFYRCxNQVdPLElBQUcsU0FBUyxDQUFDLFNBQUQsQ0FBVCxJQUF3QixVQUEzQixFQUF1QztBQUM1QztBQUNNLGdCQUFBLE1BRnNDLEdBRTlCLFNBRjhCO0FBRzVDLGdCQUFBLFNBQVMsR0FBRztBQUFDLDhCQUFZO0FBQWIsaUJBQVo7O0FBQ0EscUJBQVUsR0FBVixJQUFpQixNQUFqQixFQUF3QjtBQUN0QixrQkFBQSxTQUFTLENBQUMsR0FBRCxDQUFULEdBQWlCLE1BQUssQ0FBQyxHQUFELENBQXRCO0FBQ0Q7QUFDRjs7QUFuSGMsK0NBcUhSLFNBckhROztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQWpCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBd0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsRUFBQSxNQUFNLENBQUMsTUFBUDtBQUFBLDhGQUFnQixrQkFBZSxLQUFmLEVBQXNCLE9BQXRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUNYLE9BQVUsTUFBVixHQUFtQixDQURSO0FBQUE7QUFBQTtBQUFBOztBQUFBLG9CQUVOLElBQUksU0FBSixDQUFjLHNDQUFkLENBRk07O0FBQUE7QUFLZDtBQUNBLGNBQUEsT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFELEVBQVU7QUFDOUIsZ0JBQUEscUJBQXFCLEVBQUUsS0FETztBQUU5QixnQkFBQSxlQUFlLEVBQUUsSUFBSSxlQUFKLENBQ2Y7QUFBQyxrQkFBQSxXQUFXLEVBQUU7QUFBZCxpQkFEZTtBQUZhLGVBQVYsQ0FBdEI7O0FBS0Esa0JBQUcsT0FBTyxDQUFDLFlBQVIsS0FBeUIsS0FBNUIsRUFBbUM7QUFDakMsZ0JBQUEsT0FBTyxDQUFDLFlBQVIsR0FBdUIsU0FBdkI7QUFDRCxlQWJhLENBZWQ7OztBQUNNLGNBQUEsU0FoQlEsR0FnQkksRUFoQkosRUFrQmQ7O0FBQ00sY0FBQSxpQkFuQlEsR0FtQlksRUFuQlosRUFxQmQ7O0FBQ0Esa0JBQUcsbUJBQW1CLE9BQXRCLEVBQStCO0FBQ3ZCLGdCQUFBLGFBRHVCLEdBQ1AsSUFBSSxDQUFDLEtBQUwsQ0FBVyxPQUFPLENBQUMsYUFBbkIsQ0FETzs7QUFFN0Isb0JBQUcsU0FBUyxDQUFDLGFBQUQsQ0FBVCxJQUE0QixjQUFjLGFBQTdDLEVBQTREO0FBQzFELGtCQUFBLFNBQVMsQ0FBQyxhQUFWLEdBQTBCLGFBQTFCO0FBQ0QsaUJBRkQsTUFFTztBQUNMLGtCQUFBLFNBQVMsQ0FBQyxhQUFWLEdBQTBCO0FBQUMsZ0NBQVk7QUFBYixtQkFBMUI7QUFDRDs7QUFDRCxnQkFBQSxpQkFBaUIsQ0FBQyxJQUFsQixDQUF1QixTQUFTLENBQUMsYUFBakM7QUFDRCxlQTlCYSxDQWdDZDs7O0FBaENjLGtCQWtDVixTQUFTLENBQUMsS0FBRCxDQWxDQztBQUFBO0FBQUE7QUFBQTs7QUFtQ1o7QUFDQSxjQUFBLFNBQVMsQ0FBQyxLQUFWLEdBQWtCLElBQUksQ0FBQyxLQUFMLENBQVcsS0FBWCxDQUFsQjtBQXBDWTtBQUFBOztBQUFBO0FBQUE7QUFBQSxxQkF1Q1ksTUFBTSxDQUFDLEdBQVAsQ0FBVyxLQUFYLEVBQWtCLE9BQWxCLENBdkNaOztBQUFBO0FBdUNOLGNBQUEsU0F2Q007QUF3Q1osY0FBQSxXQUFXLEdBQUcsU0FBUyxDQUFDLFdBQXhCO0FBQ0EsY0FBQSxTQUFTLENBQUMsS0FBVixHQUFrQixTQUFTLENBQUMsUUFBNUI7O0FBQ0Esa0JBQUcsU0FBUyxDQUFDLFVBQWIsRUFBeUI7QUFDdkI7QUFDQSxnQkFBQSxTQUFTLENBQUMsYUFBVixHQUEwQjtBQUFDLDhCQUFZLFNBQVMsQ0FBQztBQUF2QixpQkFBMUI7QUFDQSxnQkFBQSxpQkFBaUIsQ0FBQyxJQUFsQixDQUF1QixTQUFTLENBQUMsYUFBakM7QUFDRDs7QUE5Q1c7QUFpRGQ7QUFDQSxrQkFBRyxFQUFFLFVBQVUsT0FBWixDQUFILEVBQXlCO0FBQ3ZCLGdCQUFBLE9BQU8sQ0FBQyxJQUFSLEdBQWUsV0FBVyxJQUFJLEVBQTlCO0FBQ0QsZUFwRGEsQ0FzRGQ7OztBQUNJLGNBQUEsU0F2RFUsR0F1REUsa0JBQWtCLENBQUMsT0FBRCxDQXZEcEI7QUFBQSwyQ0F3RFEsaUJBeERSOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBd0RKLGNBQUEsUUF4REk7QUFBQTtBQUFBLHFCQXlETSxlQUFlLENBQUM7QUFBQyxnQkFBQSxTQUFTLEVBQVQsU0FBRDtBQUFZLGdCQUFBLFFBQVEsRUFBUixRQUFaO0FBQXNCLGdCQUFBLE9BQU8sRUFBUDtBQUF0QixlQUFELENBekRyQjs7QUFBQTtBQXlEWixjQUFBLFNBekRZOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxxQkE2RE8sT0FBTyxDQUFDO0FBQzNCLGdCQUFBLFNBQVMsRUFBVCxTQUQyQjtBQUUzQixnQkFBQSxPQUFPLEVBQUUsU0FBUyxDQUFDLEtBRlE7QUFHM0IsZ0JBQUEsT0FBTyxFQUFQLE9BSDJCO0FBSTNCLGdCQUFBLFlBQVksRUFBRSxPQUFPLENBQUM7QUFKSyxlQUFELENBN0RkOztBQUFBO0FBNkRWLGNBQUEsUUE3RFU7O0FBb0VkO0FBQ0Esa0JBQUcsU0FBUyxDQUFDLFFBQUQsQ0FBVCxJQUF3QixZQUFZLFFBQXBDLElBQ0QsTUFBTSxDQUFDLElBQVAsQ0FBWSxRQUFaLEVBQXNCLE1BQXRCLEtBQWlDLENBRG5DLEVBQ3NDO0FBQ3BDLGdCQUFBLFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBRCxDQUFuQjtBQUNELGVBSEQsTUFHTyxJQUFHLFFBQVEsS0FBSyxJQUFoQixFQUFzQjtBQUMzQixnQkFBQSxRQUFRLEdBQUcsRUFBWDtBQUNELGVBMUVhLENBNEVkOzs7QUFDQSxrQkFBRyxDQUFDLFFBQVEsQ0FBQyxRQUFELENBQVosRUFBd0I7QUFDdEIsZ0JBQUEsUUFBUSxHQUFHLENBQUMsUUFBRCxDQUFYO0FBQ0Q7O0FBL0VhLGdEQWlGUCxRQWpGTzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFoQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQW9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsRUFBQSxNQUFNLENBQUMsT0FBUDtBQUFBLDhGQUFpQixrQkFBZSxLQUFmLEVBQXNCLEdBQXRCLEVBQTJCLE9BQTNCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUNaLE9BQVUsTUFBVixHQUFtQixDQURQO0FBQUE7QUFBQTtBQUFBOztBQUFBLGdEQUVOLElBQUksU0FBSixDQUFjLHVDQUFkLENBRk07O0FBQUE7QUFLZixrQkFBRyxPQUFPLEdBQVAsS0FBZSxVQUFsQixFQUE4QjtBQUM1QixnQkFBQSxHQUFHLEdBQUcsSUFBTjtBQUNELGVBRkQsTUFFTztBQUNMLGdCQUFBLEdBQUcsR0FBRyxHQUFHLElBQUksSUFBYjtBQUNELGVBVGMsQ0FXZjs7O0FBQ0EsY0FBQSxPQUFPLEdBQUcsWUFBWSxDQUFDLE9BQUQsRUFBVTtBQUM5QixnQkFBQSxJQUFJLEVBQUUsU0FBUyxDQUFDLEtBQUQsQ0FBVCxHQUFtQixLQUFuQixHQUEyQixFQURIO0FBRTlCLGdCQUFBLGVBQWUsRUFBRSxJQUFJLGVBQUosQ0FDZjtBQUFDLGtCQUFBLFdBQVcsRUFBRTtBQUFkLGlCQURlO0FBRmEsZUFBVixDQUF0QixDQVplLENBa0JmOztBQWxCZTtBQUFBLHFCQW1CUSxNQUFNLENBQUMsTUFBUCxDQUFjLEtBQWQsRUFBcUIsT0FBckIsQ0FuQlI7O0FBQUE7QUFtQlQsY0FBQSxRQW5CUztBQXFCZjtBQUNNLGNBQUEsU0F0QlMsR0FzQkcsUUFBUSxDQUFDLFFBQUQsQ0F0Qlg7O0FBQUEsb0JBd0JaLEdBQUcsS0FBSyxJQXhCSTtBQUFBO0FBQUE7QUFBQTs7QUFBQSxnREEwQk4sU0ExQk07O0FBQUE7QUE2QmY7QUFDQSxjQUFBLE9BQU8sQ0FBQyxLQUFSLEdBQWdCLElBQWhCO0FBQ0EsY0FBQSxPQUFPLENBQUMsYUFBUixHQUF3QixJQUF4QjtBQS9CZTtBQUFBLHFCQWdDUyxNQUFNLENBQUMsT0FBUCxDQUFlLFNBQWYsRUFBMEIsR0FBMUIsRUFBK0IsT0FBL0IsQ0FoQ1Q7O0FBQUE7QUFnQ1QsY0FBQSxTQWhDUztBQUFBLGdEQWtDUixTQWxDUTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFqQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEVBQUEsTUFBTSxDQUFDLEtBQVA7QUFBQSw4RkFBZSxrQkFBZSxLQUFmLEVBQXNCLEtBQXRCLEVBQTZCLE9BQTdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0JBQ1YsT0FBVSxNQUFWLEdBQW1CLENBRFQ7QUFBQTtBQUFBO0FBQUE7O0FBQUEsb0JBRUwsSUFBSSxTQUFKLENBQWMscUNBQWQsQ0FGSzs7QUFBQTtBQUtiO0FBQ0EsY0FBQSxPQUFPLEdBQUcsWUFBWSxDQUFDLE9BQUQsRUFBVTtBQUM5QixnQkFBQSxJQUFJLEVBQUUsU0FBUyxDQUFDLEtBQUQsQ0FBVCxHQUFtQixLQUFuQixHQUEyQixFQURIO0FBRTlCLGdCQUFBLEtBQUssRUFBRSxPQUZ1QjtBQUc5QixnQkFBQSxRQUFRLEVBQUUsS0FIb0I7QUFJOUIsZ0JBQUEsVUFBVSxFQUFFLEtBSmtCO0FBSzlCLGdCQUFBLFdBQVcsRUFBRSxLQUxpQjtBQU05QixnQkFBQSxhQUFhLEVBQUUsRUFOZTtBQU85QixnQkFBQSxlQUFlLEVBQUUsSUFBSSxlQUFKLENBQ2Y7QUFBQyxrQkFBQSxXQUFXLEVBQUU7QUFBZCxpQkFEZTtBQVBhLGVBQVYsQ0FBdEIsQ0FOYSxDQWlCYjs7QUFqQmEsbUJBa0JWLFNBQVMsQ0FBQyxLQUFELENBbEJDO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEscUJBb0JhLE1BQU0sQ0FBQyxHQUFQLENBQVcsS0FBWCxFQUFrQixPQUFsQixDQXBCYjs7QUFBQTtBQW9CTCxjQUFBLFNBcEJLO0FBcUJYLGNBQUEsS0FBSyxHQUFHLFNBQVMsQ0FBQyxRQUFsQjs7QUFFQSxrQkFBRyxTQUFTLENBQUMsVUFBYixFQUF5QjtBQUN2QjtBQUNJLGdCQUFBLEdBRm1CLEdBRWIsS0FBSyxDQUFDLFVBQUQsQ0FGUTs7QUFHdkIsb0JBQUcsQ0FBQyxHQUFKLEVBQVM7QUFDUCxrQkFBQSxHQUFHLEdBQUcsU0FBUyxDQUFDLFVBQWhCO0FBQ0QsaUJBRkQsTUFFTyxJQUFHLFFBQVEsQ0FBQyxHQUFELENBQVgsRUFBa0I7QUFDdkIsa0JBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxTQUFTLENBQUMsVUFBbkI7QUFDRCxpQkFGTSxNQUVBO0FBQ0wsa0JBQUEsR0FBRyxHQUFHLENBQUMsR0FBRCxFQUFNLFNBQVMsQ0FBQyxVQUFoQixDQUFOO0FBQ0Q7O0FBQ0QsZ0JBQUEsS0FBSyxDQUFDLFVBQUQsQ0FBTCxHQUFvQixHQUFwQjtBQUNEOztBQWxDVTtBQXFDUCxjQUFBLFlBckNPLEdBcUNRLEtBQUssR0FBRyxLQUFLLENBQUMsVUFBRCxDQUFMLElBQXFCLEVBQXhCLEdBQTZCLEVBckMxQyxFQXVDYjs7QUF2Q2E7QUFBQSxxQkF3Q1csTUFBTSxDQUFDLGNBQVAsQ0FDdEIsa0JBQWtCLENBQUMsT0FBRCxDQURJLEVBQ08sWUFEUCxFQUNxQixPQURyQixDQXhDWDs7QUFBQTtBQXdDUCxjQUFBLFNBeENPOztBQTJDYjtBQUNBLGtCQUFHLENBQUMsT0FBTyxDQUFDLGNBQVIsQ0FBdUIsV0FBdkIsQ0FBSixFQUF5QztBQUN2QyxnQkFBQSxPQUFPLENBQUMsU0FBUixHQUFvQixlQUFlLENBQUMsU0FBRCxFQUFZLEdBQVosQ0FBbkM7QUFDRDs7QUFDRCxrQkFBRyxDQUFDLE9BQU8sQ0FBQyxjQUFSLENBQXVCLDJCQUF2QixDQUFKLEVBQXlEO0FBQ3ZELGdCQUFBLE9BQU8sQ0FBQyx5QkFBUixHQUFvQyxlQUFlLENBQUMsU0FBRCxFQUFZLEdBQVosQ0FBbkQ7QUFDRCxlQWpEWSxDQW1EYjs7O0FBbkRhO0FBQUEscUJBb0RVLE1BQU0sQ0FBQyxNQUFQLENBQWMsS0FBZCxFQUFxQixPQUFyQixDQXBEVjs7QUFBQTtBQW9EUCxjQUFBLFFBcERPO0FBc0RiO0FBQ00sY0FBQSxJQXZETyxxQkF1REksT0F2REo7QUF3RGIsY0FBQSxJQUFJLENBQUMsT0FBTCxHQUFlLElBQWY7QUFDQSxjQUFBLElBQUksQ0FBQyxxQkFBTCxHQUE2QixJQUE3QjtBQXpEYTtBQUFBLHFCQTBEZSxNQUFNLENBQUMsTUFBUCxDQUFjLEtBQWQsRUFBcUIsSUFBckIsQ0ExRGY7O0FBQUE7QUEwRFAsY0FBQSxhQTFETztBQTREYjtBQUNBO0FBQ00sY0FBQSxTQTlETyxHQThESyxNQUFNLENBQUMsSUFBUCxDQUFZLEtBQVosRUFDZixHQURlLENBQ1gsVUFBQSxHQUFHO0FBQUEsdUJBQUksVUFBVSxDQUFDLFNBQUQsRUFBWSxHQUFaLEVBQWlCO0FBQUMsa0JBQUEsS0FBSyxFQUFFO0FBQVIsaUJBQWpCLENBQWQ7QUFBQSxlQURRLENBOURMO0FBZ0ViLGNBQUEsSUFBSSxDQUFDLE1BQUwsR0FBYyxDQUFDLFNBQVMsQ0FBQyxRQUFWLENBQW1CLFFBQW5CLENBQWY7QUFDQSxjQUFBLElBQUksQ0FBQyxJQUFMLEdBQVksZUFBZSxDQUFDLFNBQUQsRUFBWSxHQUFaLENBQTNCLENBakVhLENBbUViOztBQUNNLGNBQUEsTUFwRU8sR0FvRUUscUJBQXFCLENBQUMsUUFBRCxFQUFXLGFBQVgsRUFBMEIsSUFBMUIsQ0FwRXZCO0FBc0ViLGNBQUEsSUFBSSxDQUFDLEtBQUwsR0FBYSxDQUFDLE9BQU8sQ0FBQyxTQUF0QjtBQUNBLGNBQUEsSUFBSSxDQUFDLGFBQUwsR0FBcUIsSUFBckI7QUFDQSxjQUFBLElBQUksQ0FBQyxJQUFMLEdBQVksRUFBWjtBQUNBLGNBQUEsSUFBSSxDQUFDLE9BQUwsR0FBZSxJQUFmO0FBekVhO0FBQUEscUJBMEVTLE1BQU0sQ0FBQyxPQUFQLENBQWUsTUFBZixFQUF1QixZQUF2QixFQUFxQyxJQUFyQyxDQTFFVDs7QUFBQTtBQTBFVCxjQUFBLFNBMUVTO0FBNEViO0FBQ0EsY0FBQSxJQUFJLENBQUMsSUFBTCxHQUFZLEVBQVo7QUFDQSxjQUFBLFNBQVMsR0FBRyxZQUFZLENBQUMsU0FBRCxFQUFZLElBQVosQ0FBeEI7QUE5RWEsZ0RBZ0ZOLFNBaEZNOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQWY7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFtRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxJQUFQO0FBQUEsOEZBQWMsa0JBQWUsS0FBZixFQUFzQixHQUF0QixFQUEyQixPQUEzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDWjtBQUNBO0FBQ00sY0FBQSxLQUhNLEdBR0UsRUFIRjs7QUFJWixrQkFBRyxHQUFILEVBQVE7QUFDTixnQkFBQSxLQUFLLENBQUMsVUFBRCxDQUFMLEdBQW9CLEdBQXBCO0FBQ0Q7O0FBQ0QsY0FBQSxLQUFLLENBQUMsUUFBRCxDQUFMLEdBQWtCLE9BQWxCO0FBUFksZ0RBUUwsTUFBTSxDQUFDLEtBQVAsQ0FBYSxLQUFiLEVBQW9CLEtBQXBCLEVBQTJCLE9BQTNCLENBUks7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBZDs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsRUFBQSxNQUFNLENBQUMsU0FBUCxHQUFtQixNQUFNLENBQUMsUUFBUDtBQUFBLDhGQUFrQixrQkFBZSxLQUFmLEVBQXNCLE9BQXRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUNoQyxPQUFVLE1BQVYsR0FBbUIsQ0FEYTtBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFFM0IsSUFBSSxTQUFKLENBQWMsd0NBQWQsQ0FGMkI7O0FBQUE7QUFLbkM7QUFDQSxjQUFBLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBRCxFQUFVO0FBQzlCLGdCQUFBLElBQUksRUFBRSxTQUFTLENBQUMsS0FBRCxDQUFULEdBQW1CLEtBQW5CLEdBQTJCLEVBREg7QUFFOUIsZ0JBQUEsU0FBUyxFQUFFLFdBRm1CO0FBRzlCLGdCQUFBLGFBQWEsRUFBRSxLQUhlO0FBSTlCLGdCQUFBLGVBQWUsRUFBRSxJQUFJLGVBQUosQ0FDZjtBQUFDLGtCQUFBLFdBQVcsRUFBRTtBQUFkLGlCQURlO0FBSmEsZUFBVixDQUF0Qjs7QUFObUMsb0JBYWhDLGlCQUFpQixPQWJlO0FBQUE7QUFBQTtBQUFBOztBQUFBLG9CQWM5QixPQUFPLENBQUMsV0FBUixLQUF3QixxQkFBeEIsSUFDRCxPQUFPLENBQUMsV0FBUixLQUF3QixvQkFmTztBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFnQnpCLElBQUksV0FBSixDQUNKLHdDQURJLEVBRUosc0JBRkksQ0FoQnlCOztBQUFBO0FBb0JqQztBQUNNLGNBQUEsV0FyQjJCLEdBcUJiLE1BQU0sQ0FBQyxLQUFQLENBQWEsS0FBYixDQXJCYSxFQXVCakM7O0FBdkJpQyxnREF3QjFCLFFBQVEsQ0FBQyxRQUFULENBQWtCLFdBQWxCLEVBQStCLE9BQS9CLENBeEIwQjs7QUFBQTtBQTJCbkM7QUFDTSxjQUFBLElBNUI2QixxQkE0QmxCLE9BNUJrQjtBQTZCbkMscUJBQU8sSUFBSSxDQUFDLE1BQVo7QUFDQSxjQUFBLElBQUksQ0FBQyxxQkFBTCxHQUE2QixLQUE3QjtBQTlCbUM7QUFBQSxxQkErQmIsTUFBTSxDQUFDLEtBQVAsQ0FBYSxLQUFiLEVBQW9CLElBQXBCLENBL0JhOztBQUFBO0FBK0I3QixjQUFBLE9BL0I2QjtBQUFBLGdEQWtDNUIsUUFBUSxDQUFDLFFBQVQsQ0FBa0IsT0FBbEIsRUFBMkIsT0FBM0IsQ0FsQzRCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQWxCOztBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQW5CO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxPQUFQO0FBQUEsOEZBQWlCLGtCQUFlLE9BQWYsRUFBd0IsT0FBeEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFDWixPQUFVLE1BQVYsR0FBbUIsQ0FEUDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFFUCxJQUFJLFNBQUosQ0FBYyxnREFBZCxDQUZPOztBQUFBO0FBS2Y7QUFDQSxjQUFBLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBRCxFQUFVO0FBQzlCLGdCQUFBLE1BQU0sRUFBRSxTQUFTLENBQUMsT0FBRCxDQUFULEdBQXFCLHFCQUFyQixHQUE2QztBQUR2QixlQUFWLENBQXRCO0FBTmUseUJBVUUsT0FWRixFQVVSLE1BVlEsWUFVUixNQVZRO0FBQUEsMEJBV0csT0FYSCxFQVdWLFNBWFUsYUFXVixTQVhVLEVBYWY7O0FBYmUsbUJBY1osTUFkWTtBQUFBO0FBQUE7QUFBQTs7QUFlYjtBQUNBLGNBQUEsU0FBUyxHQUFHLFNBQVMsSUFBSSxXQUFXLENBQUMsTUFBRCxDQUFwQzs7QUFoQmEsa0JBaUJULFNBakJTO0FBQUE7QUFBQTtBQUFBOztBQUFBLG9CQWtCTCxJQUFJLFdBQUosQ0FDSix1QkFESSxFQUVKLHNCQUZJLEVBRW9CO0FBQUMsZ0JBQUEsTUFBTSxFQUFOO0FBQUQsZUFGcEIsQ0FsQks7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBdUJiO0FBQ0EsY0FBQSxTQUFTLEdBQUc7QUFBQSx1QkFBTSxPQUFOO0FBQUEsZUFBWjs7QUF4QmE7QUFBQTtBQUFBLHFCQTRCYSxTQUFTLENBQUMsT0FBRCxDQTVCdEI7O0FBQUE7QUE0QlQsY0FBQSxhQTVCUztBQUFBLGdEQTZCUixRQUFRLENBQUMsYUFBRCxFQUFnQixPQUFoQixDQTdCQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFqQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEVBQUEsTUFBTSxDQUFDLEtBQVA7QUFBQSw4RkFBZSxrQkFBZSxLQUFmLEVBQXNCLE9BQXRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFDVixPQUFVLE1BQVYsR0FBbUIsQ0FEVDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFFTCxJQUFJLFNBQUosQ0FBYyw4Q0FBZCxDQUZLOztBQUFBO0FBS2I7QUFDQSxjQUFBLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBRCxFQUFVO0FBQzlCLGdCQUFBLElBQUksRUFBRSxTQUFTLENBQUMsS0FBRCxDQUFULEdBQW1CLEtBQW5CLEdBQTJCLEVBREg7QUFFOUIsZ0JBQUEsYUFBYSxFQUFFLEtBRmU7QUFHOUIsZ0JBQUEsZUFBZSxFQUFFLElBQUksZUFBSixDQUNmO0FBQUMsa0JBQUEsV0FBVyxFQUFFO0FBQWQsaUJBRGU7QUFIYSxlQUFWLENBQXRCLENBTmEsQ0FhYjs7QUFiYSxtQkFlVixPQUFPLENBQUMsYUFmRTtBQUFBO0FBQUE7QUFBQTs7QUFnQlgsY0FBQSxRQUFRLEdBQUcsS0FBWDtBQWhCVztBQUFBOztBQUFBO0FBQUE7QUFBQSxxQkFtQk0sTUFBTSxDQUFDLE1BQVAsQ0FBYyxLQUFkLEVBQXFCLE9BQXJCLENBbkJOOztBQUFBO0FBbUJYLGNBQUEsUUFuQlc7O0FBQUE7QUFzQmI7QUFDTSxjQUFBLE9BdkJPLEdBdUJHLE1BQU0sQ0FBQyxRQUFELEVBQVcsT0FBWCxDQXZCVDs7QUFBQSxtQkF3QlYsT0FBTyxDQUFDLE1BeEJFO0FBQUE7QUFBQTtBQUFBOztBQUFBLG9CQXlCUixPQUFPLENBQUMsTUFBUixLQUFtQixxQkFBbkIsSUFDRCxPQUFPLENBQUMsTUFBUixLQUFtQixvQkExQlY7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxxQkEyQkksTUFBTSxDQUFDLFNBQVAsQ0FBaUIsT0FBakIsQ0EzQko7O0FBQUE7QUFBQTs7QUFBQTtBQUFBLG9CQTZCTCxJQUFJLFdBQUosQ0FDSix3QkFESSxFQUVKLHNCQUZJLEVBRW9CO0FBQUMsZ0JBQUEsTUFBTSxFQUFFLE9BQU8sQ0FBQztBQUFqQixlQUZwQixDQTdCSzs7QUFBQTtBQUFBLGdEQWtDTixPQWxDTTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFmOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxhQUFQO0FBQUEsOEZBQXVCLGtCQUFlLEtBQWYsRUFBc0IsT0FBdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFDbEIsT0FBVSxNQUFWLEdBQW1CLENBREQ7QUFBQTtBQUFBO0FBQUE7O0FBQUEsb0JBRWIsSUFBSSxTQUFKLENBQWMsK0NBQWQsQ0FGYTs7QUFBQTtBQUtyQjtBQUNBLGNBQUEsT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFELEVBQVU7QUFDOUIsZ0JBQUEsSUFBSSxFQUFFLFNBQVMsQ0FBQyxLQUFELENBQVQsR0FBbUIsS0FBbkIsR0FBMkIsRUFESDtBQUU5QixnQkFBQSxlQUFlLEVBQUUsSUFBSSxlQUFKLENBQ2Y7QUFBQyxrQkFBQSxXQUFXLEVBQUU7QUFBZCxpQkFEZTtBQUZhLGVBQVYsQ0FBdEIsQ0FOcUIsQ0FZckI7O0FBWnFCO0FBQUEscUJBYUUsTUFBTSxDQUFDLE1BQVAsQ0FBYyxLQUFkLEVBQXFCLE9BQXJCLENBYkY7O0FBQUE7QUFhZixjQUFBLFFBYmU7QUFBQSxnREFlZCxvQkFBb0IsQ0FBQyxRQUFELEVBQVcsT0FBWCxDQWZOOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQXZCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsRUFBQSxNQUFNLENBQUMsS0FBUDtBQUFBLCtGQUFlLG1CQUFlLElBQWYsRUFBcUIsR0FBckIsRUFBMEIsT0FBMUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFDVixRQUFVLE1BQVYsR0FBbUIsQ0FEVDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFFTCxJQUFJLFNBQUosQ0FBYyxxQ0FBZCxDQUZLOztBQUFBO0FBQUEsa0JBSVQsUUFBUSxDQUFDLElBQUQsQ0FKQztBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFLTCxJQUFJLFNBQUosQ0FBYywyQ0FBZCxDQUxLOztBQUFBO0FBUWIsa0JBQUcsT0FBTyxHQUFQLEtBQWUsVUFBbEIsRUFBOEI7QUFDNUIsZ0JBQUEsR0FBRyxHQUFHLElBQU47QUFDRCxlQUZELE1BRU87QUFDTCxnQkFBQSxHQUFHLEdBQUcsR0FBRyxJQUFJLElBQWI7QUFDRCxlQVpZLENBY2I7OztBQUNBLGNBQUEsT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFELEVBQVU7QUFDOUIsZ0JBQUEsZUFBZSxFQUFFLElBQUksZUFBSixDQUNmO0FBQUMsa0JBQUEsV0FBVyxFQUFFO0FBQWQsaUJBRGU7QUFEYSxlQUFWLENBQXRCLENBZmEsQ0FvQmI7O0FBcEJhO0FBQUEscUJBcUJVLE9BQU8sQ0FBQyxHQUFSLENBQVksSUFBSSxDQUFDLEdBQUwsQ0FBUyxVQUFBLEdBQUcsRUFBSTtBQUNqRCxvQkFBTSxJQUFJLHFCQUFPLE9BQVAsQ0FBVjs7QUFDQSx1QkFBTyxNQUFNLENBQUMsTUFBUCxDQUFjLEdBQWQsRUFBbUIsSUFBbkIsQ0FBUDtBQUNELGVBSGtDLENBQVosQ0FyQlY7O0FBQUE7QUFxQlAsY0FBQSxRQXJCTztBQTBCVCxjQUFBLFVBMUJTLEdBMEJJLElBMUJKOztBQTJCYixrQkFBRyxnQkFBZ0IsT0FBbkIsRUFBNEI7QUFDMUIsZ0JBQUEsVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUFyQjtBQUNEOztBQUVLLGNBQUEsTUEvQk8sR0ErQkUsT0FBTyxDQUFDLE1BQVIsSUFBa0IsSUFBSSxnQkFBSixDQUFxQixLQUFyQixDQS9CcEI7QUFnQ1AsY0FBQSxNQWhDTyxHQWdDRTtBQUFDLDRCQUFZO0FBQWIsZUFoQ0Y7QUFrQ0wsY0FBQSxDQWxDSyxHQWtDRCxDQWxDQzs7QUFBQTtBQUFBLG9CQWtDRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BbENmO0FBQUE7QUFBQTtBQUFBOztBQW1DWDtBQUNNLGNBQUEsR0FwQ0ssR0FvQ0MsSUFBSSxDQUFDLGlCQUFMLENBQXVCLFFBQVEsQ0FBQyxDQUFELENBQS9CLEVBQW9DO0FBQzlDLGdCQUFBLE1BQU0sRUFBRSxJQUFJLGdCQUFKLENBQXFCLFFBQVEsQ0FBUixHQUFZLEdBQWpDO0FBRHNDLGVBQXBDLENBcENELEVBd0NYO0FBQ0E7O0FBQ00sY0FBQSxPQTFDSyxHQTBDTSxVQUFVLElBQUksQ0FBQyxLQUFLLENBQXJCLEdBQTBCLE1BQTFCLEdBQW1DO0FBQUMsNEJBQVk7QUFBYixlQTFDeEM7O0FBMkNYLGNBQUEsY0FBYyxDQUFDLEdBQUQsRUFBTSxPQUFOLEVBQWUsVUFBZixFQUEyQixNQUEzQixDQUFkOztBQTNDVyxvQkE2Q1IsT0FBTyxLQUFLLE1BN0NKO0FBQUE7QUFBQTtBQUFBOztBQUFBLDJEQStDYyxPQS9DZDs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQStDQyxjQUFBLFNBL0NEO0FBZ0RELGNBQUEsUUFoREMsR0FnRFUsT0FBTyxDQUFDLFNBQUQsQ0FoRGpCOztBQUFBLGtCQWlERixTQUFTLElBQUksTUFqRFg7QUFBQTtBQUFBO0FBQUE7O0FBa0RMLGNBQUEsTUFBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQixRQUFwQjtBQWxESzs7QUFBQTtBQXFERCxjQUFBLE9BckRDLEdBcURTLE1BQU0sQ0FBQyxTQUFELENBckRmOztBQXNEUCxtQkFBVSxHQUFWLElBQWlCLFFBQWpCLEVBQTJCO0FBQ3pCLG9CQUFHLEVBQUUsR0FBRyxJQUFJLE9BQVQsQ0FBSCxFQUFzQjtBQUNwQixrQkFBQSxPQUFPLENBQUMsR0FBRCxDQUFQLEdBQWUsUUFBUSxDQUFDLEdBQUQsQ0FBdkI7QUFDRDtBQUNGOztBQTFETTtBQUFBOztBQUFBO0FBa0N1QixnQkFBRSxDQWxDekI7QUFBQTtBQUFBOztBQUFBO0FBK0RiO0FBQ00sY0FBQSxZQWhFTyxHQWdFUSxjQUFjLENBQUMsTUFBRCxDQWhFdEIsRUFrRWI7O0FBQ00sY0FBQSxTQW5FTyxHQW1FSyxFQW5FTDtBQW9FUCxjQUFBLElBcEVPLEdBb0VBLE1BQU0sQ0FBQyxJQUFQLENBQVksWUFBWixFQUEwQixJQUExQixFQXBFQTs7QUFxRWIsbUJBQVEsRUFBUixHQUFhLENBQWIsRUFBZ0IsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUExQixFQUFrQyxFQUFFLEVBQXBDLEVBQXdDO0FBQ2hDLGdCQUFBLElBRGdDLEdBQ3pCLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRCxDQUFMLENBRGEsRUFFdEM7O0FBQ0Esb0JBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFELENBQXZCLEVBQStCO0FBQzdCLGtCQUFBLFNBQVMsQ0FBQyxJQUFWLENBQWUsSUFBZjtBQUNEO0FBQ0Y7O0FBM0VZLG9CQTZFVixHQUFHLEtBQUssSUE3RUU7QUFBQTtBQUFBO0FBQUE7O0FBQUEsaURBOEVKLFNBOUVJOztBQUFBO0FBaUZiO0FBQ0EsY0FBQSxPQUFPLENBQUMsS0FBUixHQUFnQixJQUFoQjtBQUNBLGNBQUEsT0FBTyxDQUFDLGFBQVIsR0FBd0IsSUFBeEI7QUFuRmE7QUFBQSxxQkFvRlcsTUFBTSxDQUFDLE9BQVAsQ0FBZSxTQUFmLEVBQTBCLEdBQTFCLEVBQStCLE9BQS9CLENBcEZYOztBQUFBO0FBb0ZQLGNBQUEsU0FwRk87QUFBQSxpREFzRk4sU0F0Rk07O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBZjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsRUFBQSxNQUFNLENBQUMsY0FBUCxDQUFzQixNQUF0QixFQUE4QixnQkFBOUIsRUFBZ0Q7QUFDOUMsSUFBQSxHQUFHLEVBQUU7QUFBQSxhQUFNLE1BQU0sQ0FBQyxlQUFiO0FBQUEsS0FEeUM7QUFFOUMsSUFBQSxHQUFHLEVBQUUsYUFBQSxDQUFDO0FBQUEsYUFBSSxNQUFNLENBQUMsZUFBUCxHQUF5QixDQUE3QjtBQUFBO0FBRndDLEdBQWhELEVBbnZCaUMsQ0F1dkJqQzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxjQUFQO0FBQUEsK0ZBQXdCLG1CQUFNLEdBQU47QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUNoQixJQUFJLFdBQUosQ0FDSiw2REFDQSxnQ0FGSSxFQUU4QiwwQkFGOUIsRUFHSjtBQUFDLGdCQUFBLElBQUksRUFBRSx5QkFBUDtBQUFrQyxnQkFBQSxHQUFHLEVBQUg7QUFBbEMsZUFISSxDQURnQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUF4Qjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxHQUFQO0FBQUEsK0ZBQWEsbUJBQWUsR0FBZixFQUFvQixPQUFwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFWCxrQkFBRyxPQUFPLE9BQU8sQ0FBQyxjQUFmLEtBQWtDLFVBQXJDLEVBQWlEO0FBQy9DLGdCQUFBLElBQUksR0FBRyxPQUFPLENBQUMsY0FBZjtBQUNELGVBRkQsTUFFTztBQUNMLGdCQUFBLElBQUksR0FBRyxNQUFNLENBQUMsY0FBZDtBQUNEOztBQU5VO0FBQUEscUJBUWEsSUFBSSxDQUFDLEdBQUQsQ0FSakI7O0FBQUE7QUFRTCxjQUFBLFNBUks7QUFBQTs7QUFBQSxrQkFXTCxTQUFTLENBQUMsUUFYTDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxvQkFZRCxJQUFJLFdBQUosQ0FDSiw0Q0FESSxFQUVKLDJCQUZJLENBWkM7O0FBQUE7QUFnQlQsa0JBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxRQUFYLENBQVosRUFBa0M7QUFDaEMsZ0JBQUEsU0FBUyxDQUFDLFFBQVYsR0FBcUIsSUFBSSxDQUFDLEtBQUwsQ0FBVyxTQUFTLENBQUMsUUFBckIsQ0FBckI7QUFDRDs7QUFsQlE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFvQkgsSUFBSSxXQUFKLENBQ0oscURBREksRUFFSiwwQkFGSSxFQUV3QjtBQUMxQixnQkFBQSxJQUFJLEVBQUUseUJBRG9CO0FBRTFCLGdCQUFBLEtBQUssZUFGcUI7QUFHMUIsZ0JBQUEsU0FBUyxFQUFUO0FBSDBCLGVBRnhCLENBcEJHOztBQUFBO0FBQUEsaURBNkJKLFNBN0JJOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQWI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxjQUFQO0FBQUEsK0ZBQXdCLG1CQUN0QixTQURzQixFQUNYLFFBRFcsRUFDRCxPQURDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFdEI7QUFDQSxjQUFBLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBRCxFQUFVO0FBQzlCLGdCQUFBLElBQUksRUFBRSxFQUR3QjtBQUU5QixnQkFBQSxlQUFlLEVBQUUsSUFBSSxlQUFKLENBQ2Y7QUFBQyxrQkFBQSxXQUFXLEVBQUU7QUFBZCxpQkFEZTtBQUZhLGVBQVYsQ0FBdEIsQ0FIc0IsQ0FTdEI7O0FBVHNCLG9CQVVuQixRQUFRLEtBQUssSUFWTTtBQUFBO0FBQUE7QUFBQTs7QUFBQSxpREFXYixrQkFBa0IsQ0FBQyxPQUFELENBWEw7O0FBQUE7QUFjdEI7QUFDQSxjQUFBLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLFFBQVgsQ0FBWDs7QUFDQSxrQkFBRyxFQUFFLFNBQVMsQ0FBQyxRQUFELENBQVQsSUFBdUIsY0FBYyxRQUF2QyxDQUFILEVBQXFEO0FBQ25ELGdCQUFBLFFBQVEsR0FBRztBQUFDLDhCQUFZO0FBQWIsaUJBQVg7QUFDRDs7QUFsQnFCLGlEQW9CZixlQUFlLENBQUM7QUFBQyxnQkFBQSxTQUFTLEVBQVQsU0FBRDtBQUFZLGdCQUFBLFFBQVEsRUFBUixRQUFaO0FBQXNCLGdCQUFBLE9BQU8sRUFBUDtBQUF0QixlQUFELENBcEJBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQXhCOztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BcnpCaUMsQ0E0MEJqQzs7O0FBQ0EsRUFBQSxNQUFNLENBQUMsZUFBUCxHQUF5QixPQUFPLENBQUMsV0FBRCxDQUFQLENBQXFCLGVBQTlDO0FBRUE7QUFDQTtBQUNBOztBQUNBLEVBQUEsTUFBTSxDQUFDLGVBQVAsR0FBeUIsRUFBekI7QUFDQSxFQUFBLE1BQU0sQ0FBQyxlQUFQLENBQXVCLElBQXZCLEdBQThCLE9BQU8sQ0FBQyx3QkFBRCxDQUFyQztBQUNBLEVBQUEsTUFBTSxDQUFDLGVBQVAsQ0FBdUIsR0FBdkIsR0FBNkIsT0FBTyxDQUFDLHVCQUFELENBQXBDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsRUFBQSxNQUFNLENBQUMsaUJBQVAsR0FBMkIsVUFBUyxJQUFULEVBQWU7QUFDeEMsUUFBRyxFQUFFLElBQUksSUFBSSxNQUFNLENBQUMsZUFBakIsQ0FBSCxFQUFzQztBQUNwQyxZQUFNLElBQUksV0FBSixDQUNKLG9DQUFvQyxJQUFwQyxHQUEyQyxHQUR2QyxFQUVKLDhCQUZJLEVBR0o7QUFBQyxRQUFBLElBQUksRUFBSjtBQUFELE9BSEksQ0FBTjtBQUlELEtBTnVDLENBUXhDOzs7QUFDQSxJQUFBLE1BQU0sQ0FBQyxjQUFQLEdBQXdCLE1BQU0sQ0FBQyxlQUFQLENBQXVCLElBQXZCLEVBQTZCLEtBQTdCLENBQ3RCLE1BRHNCLEVBQ2QsS0FBSyxDQUFDLFNBQU4sQ0FBZ0IsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBMkIsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FEYyxDQUF4QjtBQUVELEdBWEQ7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsRUFBQSxNQUFNLENBQUMsaUJBQVAsR0FBMkIsVUFBUyxXQUFULEVBQXNCLE1BQXRCLEVBQThCO0FBQ3ZELElBQUEsV0FBVyxDQUFDLFdBQUQsQ0FBWCxHQUEyQixNQUEzQjtBQUNELEdBRkQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxtQkFBUCxHQUE2QixVQUFTLFdBQVQsRUFBc0I7QUFDakQsV0FBTyxXQUFXLENBQUMsV0FBRCxDQUFsQjtBQUNELEdBRkQsQ0E3M0JpQyxDQWk0QmpDOzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxpQkFBUCxDQUF5QixxQkFBekIsRUFBZ0QsTUFBTSxDQUFDLEtBQXZEO0FBQ0EsRUFBQSxNQUFNLENBQUMsaUJBQVAsQ0FBeUIsb0JBQXpCLEVBQStDLE1BQU0sQ0FBQyxLQUF0RCxFQW40QmlDLENBcTRCakM7O0FBQ0EsRUFBQSxNQUFNLENBQUMsaUJBQVAsQ0FBeUIsVUFBekIsRUFBcUMsSUFBSSxDQUFDLEtBQTFDO0FBRUE7O0FBQ0EsRUFBQSxNQUFNLENBQUMsR0FBUCxHQUFhLE9BQU8sQ0FBQyxPQUFELENBQXBCO0FBRUE7O0FBQ0EsRUFBQSxNQUFNLENBQUMsSUFBUCxHQUFjLElBQWQsQ0E1NEJpQyxDQTY0QmpDOztBQUNBLEVBQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxNQUFkLEVBQXNCLElBQXRCLEVBOTRCaUMsQ0FnNUJqQzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLE1BQWxCLENBajVCaUMsQ0FtNUJqQzs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxZQUFQLEdBQXNCLE9BQU8sQ0FBQyxnQkFBRCxDQUE3QjtBQUVBOztBQUNBLEVBQUEsTUFBTSxDQUFDLGVBQVAsR0FBeUIsT0FBTyxDQUFDLG1CQUFELENBQVAsQ0FBNkIsTUFBN0IsQ0FBekIsQ0F2NUJpQyxDQXk1QmpDOztBQUNBLE1BQUcsUUFBUSxJQUFJLE9BQU8sTUFBTSxDQUFDLGVBQWQsS0FBa0MsV0FBakQsRUFBOEQ7QUFDNUQsSUFBQSxNQUFNLENBQUMsY0FBUCxDQUFzQixNQUF0QixFQUE4QixpQkFBOUIsRUFBaUQ7QUFDL0MsTUFBQSxRQUFRLEVBQUUsSUFEcUM7QUFFL0MsTUFBQSxVQUFVLEVBQUUsS0FGbUM7QUFHL0MsTUFBQSxZQUFZLEVBQUUsSUFIaUM7QUFJL0MsTUFBQSxLQUFLLEVBQUUsTUFBTSxDQUFDO0FBSmlDLEtBQWpEO0FBTUQsR0FqNkJnQyxDQW02QmpDOzs7QUFDQSxNQUFHLE9BQUgsRUFBWTtBQUNWO0FBQ0EsSUFBQSxNQUFNLENBQUMsaUJBQVAsQ0FBeUIsTUFBekI7QUFDRCxHQUhELE1BR08sSUFBRyxPQUFPLGNBQVAsS0FBMEIsV0FBN0IsRUFBMEM7QUFDL0M7QUFDQSxJQUFBLE1BQU0sQ0FBQyxpQkFBUCxDQUF5QixLQUF6QjtBQUNEOztBQUVELFdBQVMsWUFBVCxDQUFzQixPQUF0QixVQUdHO0FBQUEsdUNBRkQsY0FFQztBQUFBLFFBRkQsY0FFQyxzQ0FGZ0IsTUFBTSxDQUFDLGNBRXZCO0FBQUEsUUFERSxRQUNGO0FBQ0QsV0FBTyxNQUFNLENBQUMsTUFBUCxDQUFjLEVBQWQsRUFBa0I7QUFBQyxNQUFBLGNBQWMsRUFBZDtBQUFELEtBQWxCLEVBQW9DLFFBQXBDLEVBQThDLE9BQTlDLENBQVA7QUFDRCxHQWo3QmdDLENBbTdCakM7OztBQUNBLFNBQU8sTUFBUDtBQUNDLENBcjdCRCxDLENBdTdCQTtBQUVBOzs7QUFDQSxJQUFNLE9BQU8sR0FBRyxTQUFWLE9BQVUsR0FBVztBQUN6QixTQUFPLE9BQU8sQ0FBQyxZQUFXO0FBQ3hCLFdBQU8sT0FBTyxFQUFkO0FBQ0QsR0FGYSxDQUFkO0FBR0QsQ0FKRCxDLENBTUE7OztBQUNBLE9BQU8sQ0FBQyxPQUFELENBQVAsQyxDQUNBOztBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLE9BQWpCOzs7OztBQzdoQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2VBRW9CLE9BQU8sQ0FBQyxXQUFELEM7SUFBcEIsUyxZQUFBLFM7O0FBQ1AsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLGNBQUQsQ0FBMUI7O0FBQ0EsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQUQsQ0FBckI7O0FBQ0EsSUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQUQsQ0FBcEI7O0FBQ0EsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLGVBQUQsQ0FBM0I7O0FBRUEsSUFBTSxHQUFHLEdBQUcsRUFBWjtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLEdBQWpCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLEdBQUcsQ0FBQyxtQkFBSixHQUEwQixVQUFDLEtBQUQsRUFBUSxPQUFSLEVBQW9CO0FBQzVDLEVBQUEsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFyQixDQUQ0QyxDQUc1Qzs7QUFDQSxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBUixJQUFrQixJQUFJLElBQUksQ0FBQyxnQkFBVCxDQUEwQixLQUExQixDQUFqQztBQUNBLE1BQU0sTUFBTSxHQUFHO0FBQUMsZ0JBQVk7QUFBYixHQUFmO0FBQ0EsRUFBQSxHQUFHLENBQUMsYUFBSixDQUFrQixLQUFsQixFQUF5QixNQUF6QixFQUFpQyxVQUFqQyxFQUE2QyxNQUE3QyxFQU40QyxDQVE1Qzs7QUFDQSxTQUFPLEdBQUcsQ0FBQyxhQUFKLENBQWtCLE1BQWxCLENBQVA7QUFDRCxDQVZEO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLGFBQUosR0FBb0IsVUFBQyxLQUFELEVBQVEsTUFBUixFQUFnQixLQUFoQixFQUF1QixNQUF2QixFQUErQixJQUEvQixFQUFxQyxJQUFyQyxFQUE4QztBQUNoRTtBQUNBLE1BQUcsS0FBSyxDQUFDLE9BQU4sQ0FBYyxLQUFkLENBQUgsRUFBeUI7QUFBQSwrQ0FDTCxLQURLO0FBQUE7O0FBQUE7QUFDdkIsMERBQXlCO0FBQUEsWUFBZixJQUFlO0FBQ3ZCLFFBQUEsR0FBRyxDQUFDLGFBQUosQ0FBa0IsSUFBbEIsRUFBd0IsTUFBeEIsRUFBZ0MsS0FBaEMsRUFBdUMsTUFBdkMsRUFBK0MsU0FBL0MsRUFBMEQsSUFBMUQ7QUFDRDtBQUhzQjtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUl2QjtBQUNELEdBUCtELENBU2hFOzs7QUFDQSxNQUFHLENBQUMsS0FBSyxDQUFDLFFBQU4sQ0FBZSxLQUFmLENBQUosRUFBMkI7QUFDekIsUUFBRyxJQUFILEVBQVM7QUFDUCxNQUFBLElBQUksQ0FBQyxJQUFMLENBQVUsS0FBVjtBQUNEOztBQUNEO0FBQ0QsR0FmK0QsQ0FpQmhFOzs7QUFDQSxNQUFHLFVBQVUsQ0FBQyxPQUFYLENBQW1CLEtBQW5CLENBQUgsRUFBOEI7QUFDNUIsUUFBRyxXQUFXLEtBQWQsRUFBcUI7QUFDbkIsVUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLE9BQUQsQ0FBaEIsQ0FEbUIsQ0FFbkI7O0FBQ0EsVUFBRyxJQUFJLENBQUMsT0FBTCxDQUFhLElBQWIsTUFBdUIsQ0FBMUIsRUFBNkI7QUFDM0IsUUFBQSxLQUFLLENBQUMsT0FBRCxDQUFMLEdBQWlCLElBQUksR0FBRyxNQUFNLENBQUMsS0FBUCxDQUFhLElBQWIsQ0FBeEI7QUFDRDtBQUNGOztBQUNELFFBQUcsSUFBSCxFQUFTO0FBQ1AsTUFBQSxJQUFJLENBQUMsSUFBTCxDQUFVLEtBQVY7QUFDRDs7QUFDRDtBQUNELEdBWkQsTUFZTyxJQUFHLElBQUksSUFBSSxVQUFVLENBQUMsTUFBWCxDQUFrQixLQUFsQixDQUFYLEVBQXFDO0FBQzFDLFFBQU0sS0FBSyxHQUFHLEVBQWQ7QUFDQSxJQUFBLEdBQUcsQ0FBQyxhQUFKLENBQWtCLEtBQUssQ0FBQyxPQUFELENBQXZCLEVBQWtDLE1BQWxDLEVBQTBDLEtBQTFDLEVBQWlELE1BQWpELEVBQXlELElBQXpELEVBQStELEtBQS9EO0FBQ0EsSUFBQSxJQUFJLENBQUMsSUFBTCxDQUFVO0FBQUMsZUFBUztBQUFWLEtBQVY7QUFDQTtBQUNELEdBbkMrRCxDQXFDaEU7QUFFQTs7O0FBQ0EsTUFBRyxXQUFXLEtBQWQsRUFBcUI7QUFDbkIsUUFBTSxNQUFLLEdBQUcsS0FBSyxDQUFDLE9BQUQsQ0FBbkI7O0FBRG1CLGdEQUVELE1BRkM7QUFBQTs7QUFBQTtBQUVuQiw2REFBeUI7QUFBQSxZQUFmLEtBQWU7O0FBQ3ZCLFlBQUcsS0FBSSxDQUFDLE9BQUwsQ0FBYSxJQUFiLE1BQXVCLENBQTFCLEVBQTZCO0FBQzNCLFVBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxLQUFiO0FBQ0Q7QUFDRjtBQU5rQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT3BCLEdBL0MrRCxDQWlEaEU7OztBQUNBLE1BQUcsS0FBSyxDQUFDLFdBQU4sQ0FBa0IsSUFBbEIsQ0FBSCxFQUE0QjtBQUMxQixJQUFBLElBQUksR0FBRyxVQUFVLENBQUMsV0FBWCxDQUF1QixLQUF2QixJQUNMLE1BQU0sQ0FBQyxLQUFQLENBQWEsS0FBSyxDQUFDLEtBQUQsQ0FBbEIsQ0FESyxHQUN3QixLQUFLLENBQUMsS0FBRCxDQURwQztBQUVELEdBckQrRCxDQXVEaEU7OztBQUNBLE1BQUcsSUFBSCxFQUFTO0FBQ1AsSUFBQSxJQUFJLENBQUMsSUFBTCxDQUFVO0FBQUMsYUFBTztBQUFSLEtBQVY7QUFDRCxHQTFEK0QsQ0E0RGhFOzs7QUFDQSxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsS0FBRCxDQUF2QjtBQUNBLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxJQUFELENBQVIsR0FBaUIsUUFBUSxDQUFDLElBQUQsQ0FBUixJQUFrQixFQUFuRDtBQUNBLEVBQUEsT0FBTyxDQUFDLEtBQUQsQ0FBUCxHQUFpQixJQUFqQjtBQUNBLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksS0FBWixFQUFtQixJQUFuQixFQUFuQjs7QUFoRWdFLDhDQWlFNUMsVUFqRTRDO0FBQUE7O0FBQUE7QUFpRWhFLDJEQUFnQztBQUFBLFVBQXhCLFFBQXdCOztBQUM5QjtBQUNBLFVBQUcsUUFBUSxLQUFLLEtBQWhCLEVBQXVCO0FBQ3JCO0FBQ0QsT0FKNkIsQ0FNOUI7OztBQUNBLFVBQUcsUUFBUSxLQUFLLFVBQWhCLEVBQTRCO0FBQzFCLFlBQU0sY0FBYyxHQUFHO0FBQUMsaUJBQU87QUFBUixTQUF2QjtBQUNBLFlBQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFELENBQXhCOztBQUNBLGFBQUksSUFBTSxlQUFWLElBQTZCLFVBQTdCLEVBQXlDO0FBQ3ZDLGNBQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxlQUFELENBQXhCOztBQUR1QyxzREFFckIsS0FGcUI7QUFBQTs7QUFBQTtBQUV2QyxtRUFBeUI7QUFBQSxrQkFBZixJQUFlO0FBQ3ZCLGtCQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBRCxDQUFuQjs7QUFDQSxrQkFBRyxVQUFVLENBQUMsV0FBWCxDQUF1QixJQUF2QixDQUFILEVBQWlDO0FBQy9CLGdCQUFBLFFBQVEsR0FBRyxNQUFNLENBQUMsS0FBUCxDQUFhLFFBQWIsQ0FBWDtBQUNEOztBQUNELGNBQUEsR0FBRyxDQUFDLGFBQUosQ0FBa0IsSUFBbEIsRUFBd0IsTUFBeEIsRUFBZ0MsS0FBaEMsRUFBdUMsTUFBdkMsRUFBK0MsUUFBL0M7QUFDQSxjQUFBLElBQUksQ0FBQyxRQUFMLENBQ0UsUUFBUSxDQUFDLFFBQUQsQ0FEVixFQUNzQixlQUR0QixFQUN1QyxjQUR2QyxFQUVFO0FBQUMsZ0JBQUEsZUFBZSxFQUFFLElBQWxCO0FBQXdCLGdCQUFBLGNBQWMsRUFBRTtBQUF4QyxlQUZGO0FBR0Q7QUFYc0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVl4Qzs7QUFDRDtBQUNELE9BeEI2QixDQTBCOUI7OztBQUNBLFVBQUcsUUFBUSxLQUFLLFFBQWhCLEVBQTBCO0FBQ3hCO0FBQ0EsWUFBRyxFQUFFLElBQUksSUFBSSxNQUFWLENBQUgsRUFBc0I7QUFDcEIsVUFBQSxNQUFNLENBQUMsSUFBRCxDQUFOLEdBQWUsRUFBZjtBQUNEOztBQUNELFFBQUEsR0FBRyxDQUFDLGFBQUosQ0FBa0IsS0FBSyxDQUFDLFFBQUQsQ0FBdkIsRUFBbUMsTUFBbkMsRUFBMkMsSUFBM0MsRUFBaUQsTUFBakQ7QUFDQTtBQUNELE9BbEM2QixDQW9DOUI7OztBQUNBLFVBQUcsUUFBUSxLQUFLLFdBQWhCLEVBQTZCO0FBQzNCLFFBQUEsR0FBRyxDQUFDLGFBQUosQ0FBa0IsS0FBSyxDQUFDLFFBQUQsQ0FBdkIsRUFBbUMsTUFBbkMsRUFBMkMsS0FBM0MsRUFBa0QsTUFBbEQ7QUFDQTtBQUNELE9BeEM2QixDQTBDOUI7OztBQUNBLFVBQUcsUUFBUSxLQUFLLE9BQWIsSUFBd0IsU0FBUyxDQUFDLFFBQUQsQ0FBcEMsRUFBZ0Q7QUFDOUMsWUFBRyxRQUFRLEtBQUssUUFBYixJQUF5QixRQUFRLElBQUksT0FBckMsS0FDQSxLQUFLLENBQUMsUUFBRCxDQUFMLEtBQW9CLE9BQU8sQ0FBQyxRQUFELENBQTNCLElBQ0QsS0FBSyxDQUFDLFFBQUQsQ0FBTCxDQUFnQixLQUFoQixNQUEyQixPQUFPLENBQUMsUUFBRCxDQUFQLENBQWtCLEtBQWxCLENBRjFCLENBQUgsRUFFd0Q7QUFDdEQsZ0JBQU0sSUFBSSxXQUFKLENBQ0osK0RBREksRUFFSixvQkFGSSxFQUdKO0FBQUMsWUFBQSxJQUFJLEVBQUUscUJBQVA7QUFBOEIsWUFBQSxPQUFPLEVBQVA7QUFBOUIsV0FISSxDQUFOO0FBSUQ7O0FBQ0QsUUFBQSxPQUFPLENBQUMsUUFBRCxDQUFQLEdBQW9CLEtBQUssQ0FBQyxRQUFELENBQXpCO0FBQ0E7QUFDRCxPQXRENkIsQ0F3RDlCOzs7QUFDQSxVQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsUUFBRCxDQUFyQixDQXpEOEIsQ0EyRDlCOztBQUNBLFVBQUcsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsSUFBakIsTUFBMkIsQ0FBOUIsRUFBaUM7QUFDL0IsUUFBQSxRQUFRLEdBQUcsTUFBTSxDQUFDLEtBQVAsQ0FBYSxRQUFiLENBQVg7QUFDRCxPQTlENkIsQ0FnRTlCOzs7QUFDQSxVQUFHLE9BQU8sQ0FBQyxNQUFSLEtBQW1CLENBQXRCLEVBQXlCO0FBQ3ZCLFFBQUEsSUFBSSxDQUFDLFFBQUwsQ0FBYyxPQUFkLEVBQXVCLFFBQXZCLEVBQWlDLEVBQWpDLEVBQXFDO0FBQUMsVUFBQSxlQUFlLEVBQUU7QUFBbEIsU0FBckM7QUFDQTtBQUNEOztBQXBFNkIsa0RBcUVqQixPQXJFaUI7QUFBQTs7QUFBQTtBQXFFOUIsK0RBQXNCO0FBQUEsY0FBZCxDQUFjOztBQUNwQixjQUFHLFFBQVEsS0FBSyxPQUFoQixFQUF5QjtBQUN2QjtBQUNBLFlBQUEsQ0FBQyxHQUFJLENBQUMsQ0FBQyxPQUFGLENBQVUsSUFBVixNQUFvQixDQUFyQixHQUEwQixNQUFNLENBQUMsS0FBUCxDQUFhLENBQWIsQ0FBMUIsR0FBNEMsQ0FBaEQ7QUFDRCxXQUptQixDQU1wQjs7O0FBQ0EsY0FBRyxVQUFVLENBQUMsU0FBWCxDQUFxQixDQUFyQixLQUEyQixVQUFVLENBQUMsa0JBQVgsQ0FBOEIsQ0FBOUIsQ0FBOUIsRUFBZ0U7QUFDOUQ7QUFDQSxnQkFBRyxTQUFTLENBQVQsSUFBYyxDQUFDLENBQUMsQ0FBQyxLQUFELENBQW5CLEVBQTRCO0FBQzFCO0FBQ0QsYUFKNkQsQ0FNOUQ7OztBQUNBLGdCQUFNLEVBQUUsR0FBRyxVQUFVLENBQUMsV0FBWCxDQUF1QixDQUF2QixJQUNULE1BQU0sQ0FBQyxLQUFQLENBQWEsQ0FBQyxDQUFDLEtBQUQsQ0FBZCxDQURTLEdBQ2dCLENBQUMsQ0FBQyxLQUFELENBRDVCLENBUDhELENBVTlEOztBQUNBLFlBQUEsSUFBSSxDQUFDLFFBQUwsQ0FDRSxPQURGLEVBQ1csUUFEWCxFQUNxQjtBQUFDLHFCQUFPO0FBQVIsYUFEckIsRUFFRTtBQUFDLGNBQUEsZUFBZSxFQUFFLElBQWxCO0FBQXdCLGNBQUEsY0FBYyxFQUFFO0FBQXhDLGFBRkY7QUFHQSxZQUFBLEdBQUcsQ0FBQyxhQUFKLENBQWtCLENBQWxCLEVBQXFCLE1BQXJCLEVBQTZCLEtBQTdCLEVBQW9DLE1BQXBDLEVBQTRDLEVBQTVDO0FBQ0QsV0FmRCxNQWVPLElBQUcsVUFBVSxDQUFDLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBSCxFQUEwQjtBQUMvQixZQUFBLElBQUksQ0FBQyxRQUFMLENBQ0UsT0FERixFQUNXLFFBRFgsRUFDcUIsQ0FEckIsRUFFRTtBQUFDLGNBQUEsZUFBZSxFQUFFLElBQWxCO0FBQXdCLGNBQUEsY0FBYyxFQUFFO0FBQXhDLGFBRkY7QUFHRCxXQUpNLE1BSUEsSUFBRyxVQUFVLENBQUMsTUFBWCxDQUFrQixDQUFsQixDQUFILEVBQXlCO0FBQzlCO0FBQ0EsZ0JBQU0sTUFBSyxHQUFHLEVBQWQ7QUFDQSxZQUFBLEdBQUcsQ0FBQyxhQUFKLENBQWtCLENBQUMsQ0FBQyxPQUFELENBQW5CLEVBQThCLE1BQTlCLEVBQXNDLEtBQXRDLEVBQTZDLE1BQTdDLEVBQXFELElBQXJELEVBQTJELE1BQTNEO0FBQ0EsWUFBQSxDQUFDLEdBQUc7QUFBQyx1QkFBUztBQUFWLGFBQUo7QUFDQSxZQUFBLElBQUksQ0FBQyxRQUFMLENBQ0UsT0FERixFQUNXLFFBRFgsRUFDcUIsQ0FEckIsRUFFRTtBQUFDLGNBQUEsZUFBZSxFQUFFLElBQWxCO0FBQXdCLGNBQUEsY0FBYyxFQUFFO0FBQXhDLGFBRkY7QUFHRCxXQVJNLE1BUUE7QUFDTDtBQUNBLFlBQUEsR0FBRyxDQUFDLGFBQUosQ0FBa0IsQ0FBbEIsRUFBcUIsTUFBckIsRUFBNkIsS0FBN0IsRUFBb0MsTUFBcEMsRUFBNEMsSUFBNUM7QUFDQSxZQUFBLElBQUksQ0FBQyxRQUFMLENBQ0UsT0FERixFQUNXLFFBRFgsRUFDcUIsQ0FEckIsRUFDd0I7QUFBQyxjQUFBLGVBQWUsRUFBRSxJQUFsQjtBQUF3QixjQUFBLGNBQWMsRUFBRTtBQUF4QyxhQUR4QjtBQUVEO0FBQ0Y7QUE3RzZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUE4Ry9CO0FBL0srRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0xqRSxDQWhMRDtBQWtMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsa0JBQUosR0FBeUIsVUFBQSxNQUFNLEVBQUk7QUFDakMsTUFBTSxNQUFNLEdBQUcsRUFBZjs7QUFEaUMsOENBRWYsTUFBTSxDQUFDLElBQVAsQ0FBWSxNQUFaLEVBQW9CLElBQXBCLEVBRmU7QUFBQTs7QUFBQTtBQUVqQywyREFBOEM7QUFBQSxVQUFwQyxJQUFvQzs7QUFBQSxrREFDNUIsTUFBTSxDQUFDLElBQVAsQ0FBWSxNQUFNLENBQUMsSUFBRCxDQUFsQixFQUEwQixJQUExQixFQUQ0QjtBQUFBOztBQUFBO0FBQzVDLCtEQUFrRDtBQUFBLGNBQXhDLEVBQXdDO0FBQ2hELGNBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFELENBQU4sQ0FBYSxFQUFiLENBQWI7O0FBQ0EsY0FBRyxFQUFFLEVBQUUsSUFBSSxNQUFSLENBQUgsRUFBb0I7QUFDbEIsWUFBQSxNQUFNLENBQUMsRUFBRCxDQUFOLEdBQWE7QUFBQyxxQkFBTztBQUFSLGFBQWI7QUFDRDs7QUFDRCxjQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsRUFBRCxDQUF6Qjs7QUFMZ0Qsc0RBTzFCLE1BQU0sQ0FBQyxJQUFQLENBQVksSUFBWixFQUFrQixJQUFsQixFQVAwQjtBQUFBOztBQUFBO0FBT2hELG1FQUFnRDtBQUFBLGtCQUF0QyxRQUFzQzs7QUFDOUMsa0JBQUcsU0FBUyxDQUFDLFFBQUQsQ0FBVCxJQUF1QixRQUFRLEtBQUssT0FBdkMsRUFBZ0Q7QUFDOUM7QUFDQSxnQkFBQSxVQUFVLENBQUMsUUFBRCxDQUFWLEdBQXVCLElBQUksQ0FBQyxLQUFMLENBQVcsSUFBSSxDQUFDLFFBQUQsQ0FBZixDQUF2QjtBQUNELGVBSEQsTUFHTztBQUNMO0FBREssNERBRWMsSUFBSSxDQUFDLFFBQUQsQ0FGbEI7QUFBQTs7QUFBQTtBQUVMLHlFQUFtQztBQUFBLHdCQUF6QixLQUF5QjtBQUNqQyxvQkFBQSxJQUFJLENBQUMsUUFBTCxDQUNFLFVBREYsRUFDYyxRQURkLEVBQ3dCLElBQUksQ0FBQyxLQUFMLENBQVcsS0FBWCxDQUR4QixFQUVFO0FBQUMsc0JBQUEsZUFBZSxFQUFFLElBQWxCO0FBQXdCLHNCQUFBLGNBQWMsRUFBRTtBQUF4QyxxQkFGRjtBQUdEO0FBTkk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9OO0FBQ0Y7QUFuQitDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFvQmpEO0FBckIyQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBc0I3QztBQXhCZ0M7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEwQmpDLFNBQU8sTUFBUDtBQUNELENBM0JEOztBQTZCQSxHQUFHLENBQUMsYUFBSixHQUFvQixVQUFBLE1BQU0sRUFBSTtBQUM1QjtBQUNBLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxVQUFELENBQTNCO0FBQ0EsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxNQUFaLEVBQW9CLElBQXBCLEVBQW5COztBQUg0QiwrQ0FJTCxVQUpLO0FBQUE7O0FBQUE7QUFJNUIsOERBQW1DO0FBQUEsVUFBekIsU0FBeUI7O0FBQ2pDLFVBQUcsU0FBUyxLQUFLLFVBQWpCLEVBQTZCO0FBQzNCO0FBQ0Q7O0FBQ0QsVUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLFNBQUQsQ0FBdEI7QUFDQSxVQUFJLE9BQU8sR0FBRyxZQUFZLENBQUMsU0FBRCxDQUExQjs7QUFDQSxVQUFHLENBQUMsT0FBSixFQUFhO0FBQ1gsUUFBQSxZQUFZLENBQUMsU0FBRCxDQUFaLEdBQTBCLE9BQU8sR0FBRztBQUNsQyxpQkFBTyxTQUQyQjtBQUVsQyxvQkFBVTtBQUZ3QixTQUFwQztBQUlELE9BTEQsTUFLTyxJQUFHLEVBQUUsWUFBWSxPQUFkLENBQUgsRUFBMkI7QUFDaEMsUUFBQSxPQUFPLENBQUMsUUFBRCxDQUFQLEdBQW9CLEVBQXBCO0FBQ0Q7O0FBQ0QsVUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFFBQUQsQ0FBckI7O0FBZGlDLG1EQWVqQixNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsSUFBckIsRUFmaUI7QUFBQTs7QUFBQTtBQWVqQyxrRUFBNkM7QUFBQSxjQUFuQyxFQUFtQztBQUMzQyxjQUFNLElBQUksR0FBRyxPQUFPLENBQUMsRUFBRCxDQUFwQixDQUQyQyxDQUUzQzs7QUFDQSxjQUFHLENBQUMsVUFBVSxDQUFDLGtCQUFYLENBQThCLElBQTlCLENBQUosRUFBeUM7QUFDdkMsWUFBQSxLQUFLLENBQUMsSUFBTixDQUFXLElBQVg7QUFDRDtBQUNGO0FBckJnQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBc0JsQztBQTFCMkI7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEyQjVCLFNBQU8sWUFBUDtBQUNELENBNUJEOzs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2VBRXdCLE9BQU8sQ0FBQyxXQUFELEM7SUFBeEIsYSxZQUFBLGE7O2dCQUNhLE9BQU8sQ0FBQyxXQUFELEM7SUFBcEIsUyxhQUFBLFM7O0FBQ1AsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLGNBQUQsQ0FBMUI7O0FBQ0EsSUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsY0FBRCxDQUFoQzs7QUFDQSxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBRCxDQUFyQjs7QUFDQSxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsUUFBRCxDQUFwQjs7Z0JBb0JJLE9BQU8sQ0FBQyxhQUFELEM7SUFmVCxTLGFBQUEsUztJQUNBLFEsYUFBQSxRO0lBQ0EsTyxhQUFBLE87SUFDQSxRLGFBQUEsUTtJQUdBLGdCLGFBQUEsZ0I7SUFFQSxjLGFBQUEsYztJQUdBLFcsYUFBQSxXO0lBQ0EsVSxhQUFBLFU7SUFDQSxXLGFBQUEsVztJQUNBLFUsYUFBQSxVOztnQkFLRSxPQUFPLENBQUMsT0FBRCxDO0lBREcsYyxhQUFaLFU7O0FBR0YsSUFBTSxHQUFHLEdBQUcsRUFBWjtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLEdBQWpCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxHQUFHLENBQUMsS0FBSixHQUFZLFVBQUMsS0FBRCxFQUFRLE9BQVIsRUFBb0I7QUFDOUI7QUFDQSxNQUFNLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxnQkFBVCxDQUEwQixLQUExQixDQUFmO0FBQ0EsTUFBTSxPQUFPLEdBQUc7QUFBQyxnQkFBWTtBQUFiLEdBQWhCO0FBQ0EsRUFBQSxhQUFhLENBQUMsS0FBRCxFQUFRLE9BQVIsRUFBaUIsVUFBakIsRUFBNkIsTUFBN0IsQ0FBYjtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBQ0EsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxPQUFaLEVBQXFCLElBQXJCLEVBQW5COztBQVA4Qiw2Q0FRUCxVQVJPO0FBQUE7O0FBQUE7QUFROUIsd0RBQW1DO0FBQUEsVUFBekIsU0FBeUI7QUFDakMsVUFBSSxTQUFTLFNBQWI7O0FBQ0EsVUFBRyxTQUFTLEtBQUssVUFBakIsRUFBNkI7QUFDM0IsUUFBQSxTQUFTLEdBQUc7QUFBQyxVQUFBLFFBQVEsRUFBRSxjQUFYO0FBQTJCLFVBQUEsS0FBSyxFQUFFO0FBQWxDLFNBQVo7QUFDRCxPQUZELE1BRU8sSUFBRyxjQUFjLENBQUMsU0FBRCxDQUFqQixFQUE4QjtBQUNuQyxZQUFHLFNBQVMsQ0FBQyxVQUFWLENBQXFCLElBQXJCLENBQUgsRUFBK0I7QUFDN0IsVUFBQSxTQUFTLEdBQUc7QUFBQyxZQUFBLFFBQVEsRUFBRTtBQUFYLFdBQVo7QUFDRCxTQUZELE1BRU87QUFDTCxVQUFBLFNBQVMsR0FBRztBQUFDLFlBQUEsUUFBUSxFQUFFO0FBQVgsV0FBWjtBQUNEOztBQUNELFFBQUEsU0FBUyxDQUFDLEtBQVYsR0FBa0IsU0FBbEI7QUFDRCxPQVBNLE1BT0E7QUFDTDtBQUNBO0FBQ0Q7O0FBQ0QsTUFBQSxXQUFXLENBQUMsT0FBRCxFQUFVLE9BQU8sQ0FBQyxTQUFELENBQWpCLEVBQThCLFNBQTlCLEVBQXlDLE1BQXpDLEVBQWlELE9BQWpELENBQVg7QUFDRDtBQXhCNkI7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEwQjlCLFNBQU8sT0FBUDtBQUNELENBM0JEO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsV0FBVCxDQUFxQixPQUFyQixFQUE4QixLQUE5QixFQUFxQyxTQUFyQyxFQUFnRCxNQUFoRCxFQUF3RCxPQUF4RCxFQUFpRTtBQUMvRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLEtBQVosRUFBbUIsSUFBbkIsRUFBWjs7QUFEK0QsOENBRS9DLEdBRitDO0FBQUE7O0FBQUE7QUFFL0QsMkRBQXFCO0FBQUEsVUFBWCxFQUFXO0FBQ25CLFVBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxFQUFELENBQWxCO0FBQ0EsVUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFaLEVBQWtCLElBQWxCLEVBQW5COztBQUZtQixrREFHQyxVQUhEO0FBQUE7O0FBQUE7QUFHbkIsK0RBQWdDO0FBQUEsY0FBeEIsUUFBd0I7QUFDOUIsY0FBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQUQsQ0FBbEI7O0FBQ0EsY0FBRyxRQUFRLEtBQUssT0FBaEIsRUFBeUI7QUFDdkIsWUFBQSxRQUFRLEdBQUcsUUFBWDtBQUNELFdBRkQsTUFFTyxJQUFHLFNBQVMsQ0FBQyxRQUFELENBQVosRUFBd0I7QUFDN0I7QUFDRDs7QUFONkIsc0RBUVosS0FSWTtBQUFBOztBQUFBO0FBUTlCLG1FQUF5QjtBQUFBLGtCQUFmLElBQWU7QUFDdkI7QUFDQSxrQkFBTSxPQUFPLEdBQUc7QUFDZCxnQkFBQSxRQUFRLEVBQUUsRUFBRSxDQUFDLFVBQUgsQ0FBYyxJQUFkLElBQXNCLFdBQXRCLEdBQW9DLFdBRGhDO0FBRWQsZ0JBQUEsS0FBSyxFQUFFO0FBRk8sZUFBaEIsQ0FGdUIsQ0FPdkI7O0FBQ0Esa0JBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRCxDQUFsQixFQUF3QjtBQUN0QjtBQUNELGVBVnNCLENBWXZCOzs7QUFDQSxrQkFBTSxTQUFTLEdBQUc7QUFDaEIsZ0JBQUEsUUFBUSxFQUFFLFFBQVEsQ0FBQyxVQUFULENBQW9CLElBQXBCLElBQTRCLFdBQTVCLEdBQTBDLFdBRHBDO0FBRWhCLGdCQUFBLEtBQUssRUFBRTtBQUZTLGVBQWxCLENBYnVCLENBa0J2Qjs7QUFDQSxrQkFBRyxDQUFDLGNBQWMsQ0FBQyxRQUFELENBQWxCLEVBQThCO0FBQzVCO0FBQ0QsZUFyQnNCLENBdUJ2Qjs7O0FBQ0Esa0JBQUcsU0FBUyxDQUFDLFFBQVYsS0FBdUIsV0FBdkIsSUFDRCxDQUFDLE9BQU8sQ0FBQyxxQkFEWCxFQUNrQztBQUNoQztBQUNELGVBM0JzQixDQTZCdkI7OztBQUNBLGtCQUFNLE1BQU0sR0FDVixZQUFZLENBQUMsSUFBRCxFQUFPLE1BQVAsRUFBZSxPQUFmLEVBQXdCLFNBQXhCLEVBQW1DLE9BQU8sQ0FBQyxZQUEzQyxDQURkLENBOUJ1QixDQWdDdkI7OztBQUNBLGtCQUFHLE1BQUgsRUFBVztBQUNULGdCQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWE7QUFDWCxrQkFBQSxPQUFPLEVBQVAsT0FEVztBQUVYLGtCQUFBLFNBQVMsRUFBVCxTQUZXO0FBR1gsa0JBQUEsTUFBTSxFQUFOLE1BSFc7QUFJWCxrQkFBQSxLQUFLLEVBQUU7QUFKSSxpQkFBYjtBQU1EO0FBQ0Y7QUFqRDZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFrRC9CO0FBckRrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBc0RwQjtBQXhEOEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXlEaEU7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLFVBQVQsQ0FBb0IsSUFBcEIsRUFBMEIsTUFBMUIsRUFBa0MsT0FBbEMsRUFBMkMsU0FBM0MsRUFBc0QsWUFBdEQsRUFBb0U7QUFDbEUsTUFBTSxLQUFLLEdBQUc7QUFBQyxJQUFBLFFBQVEsRUFBRSxXQUFYO0FBQXdCLElBQUEsS0FBSyxFQUFFO0FBQS9CLEdBQWQ7QUFDQSxNQUFNLElBQUksR0FBRztBQUFDLElBQUEsUUFBUSxFQUFFLFdBQVg7QUFBd0IsSUFBQSxLQUFLLEVBQUU7QUFBL0IsR0FBYjtBQUNBLE1BQU0sR0FBRyxHQUFHO0FBQUMsSUFBQSxRQUFRLEVBQUUsV0FBWDtBQUF3QixJQUFBLEtBQUssRUFBRTtBQUEvQixHQUFaO0FBRUEsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUwsRUFBYixDQUxrRSxDQU1sRTs7QUFDQSxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUc7QUFBQyxJQUFBLFFBQVEsRUFBRSxXQUFYO0FBQXdCLElBQUEsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFQO0FBQS9CLEdBQUgsR0FBb0QsR0FBdkU7QUFDQSxNQUFJLE9BQU8sR0FBRyxNQUFkOztBQVJrRSw4Q0FVaEQsSUFWZ0Q7QUFBQTs7QUFBQTtBQVVsRSwyREFBd0I7QUFBQSxVQUFkLElBQWM7O0FBQ3RCLFVBQU0sT0FBTSxHQUFHLFlBQVksQ0FBQyxJQUFELEVBQU8sTUFBUCxFQUFlLE9BQWYsRUFBd0IsU0FBeEIsRUFBbUMsWUFBbkMsQ0FBM0I7O0FBQ0EsVUFBTSxJQUFJLEdBQUc7QUFBQyxRQUFBLFFBQVEsRUFBRSxXQUFYO0FBQXdCLFFBQUEsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFQO0FBQS9CLE9BQWI7QUFDQSxNQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWE7QUFDWCxRQUFBLE9BQU8sRUFBUCxPQURXO0FBRVgsUUFBQSxTQUFTLEVBQUUsS0FGQTtBQUdYLFFBQUEsTUFBTSxFQUFOLE9BSFc7QUFJWCxRQUFBLEtBQUssRUFBRTtBQUpJLE9BQWI7QUFNQSxNQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWE7QUFDWCxRQUFBLE9BQU8sRUFBUCxPQURXO0FBRVgsUUFBQSxTQUFTLEVBQUUsSUFGQTtBQUdYLFFBQUEsTUFBTSxFQUFFLElBSEc7QUFJWCxRQUFBLEtBQUssRUFBRTtBQUpJLE9BQWI7QUFNQSxNQUFBLE9BQU8sR0FBRyxJQUFWO0FBQ0QsS0ExQmlFLENBNEJsRTs7QUE1QmtFO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBNkJsRSxNQUFHLElBQUgsRUFBUztBQUNQLFFBQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxJQUFELEVBQU8sTUFBUCxFQUFlLE9BQWYsRUFBd0IsU0FBeEIsRUFBbUMsWUFBbkMsQ0FBM0I7O0FBQ0EsSUFBQSxPQUFPLENBQUMsSUFBUixDQUFhO0FBQ1gsTUFBQSxPQUFPLEVBQVAsT0FEVztBQUVYLE1BQUEsU0FBUyxFQUFFLEtBRkE7QUFHWCxNQUFBLE1BQU0sRUFBTixNQUhXO0FBSVgsTUFBQSxLQUFLLEVBQUU7QUFKSSxLQUFiO0FBTUEsSUFBQSxPQUFPLENBQUMsSUFBUixDQUFhO0FBQ1gsTUFBQSxPQUFPLEVBQVAsT0FEVztBQUVYLE1BQUEsU0FBUyxFQUFFLElBRkE7QUFHWCxNQUFBLE1BQU0sRUFBRSxHQUhHO0FBSVgsTUFBQSxLQUFLLEVBQUU7QUFKSSxLQUFiO0FBTUQ7O0FBRUQsU0FBTyxNQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEIsTUFBNUIsRUFBb0MsT0FBcEMsRUFBNkMsU0FBN0MsRUFBd0QsWUFBeEQsRUFBc0U7QUFDcEUsTUFBTSxNQUFNLEdBQUcsRUFBZixDQURvRSxDQUdwRTs7QUFDQSxNQUFHLFVBQVUsQ0FBQyxPQUFYLENBQW1CLElBQW5CLENBQUgsRUFBNkI7QUFDM0IsSUFBQSxNQUFNLENBQUMsUUFBUCxHQUFrQixTQUFsQjtBQUNBLElBQUEsTUFBTSxDQUFDLEtBQVAsR0FBZSxTQUFmO0FBQ0EsSUFBQSxNQUFNLENBQUMsUUFBUCxHQUFrQjtBQUNoQixNQUFBLFFBQVEsRUFBRTtBQURNLEtBQWxCO0FBR0EsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQUQsQ0FBaEI7QUFDQSxRQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBRCxDQUFKLElBQWlCLElBQWxDLENBUDJCLENBUzNCOztBQUNBLFFBQUcsUUFBUSxLQUFLLE9BQWhCLEVBQXlCO0FBQ3ZCLE1BQUEsTUFBTSxDQUFDLEtBQVAsR0FBZSxnQkFBZ0IsQ0FBQyxLQUFELENBQS9CO0FBQ0EsTUFBQSxNQUFNLENBQUMsUUFBUCxDQUFnQixLQUFoQixHQUF3QixnQkFBeEI7QUFDRCxLQUhELE1BR08sSUFBRyxLQUFLLENBQUMsU0FBTixDQUFnQixLQUFoQixDQUFILEVBQTJCO0FBQ2hDLE1BQUEsTUFBTSxDQUFDLEtBQVAsR0FBZSxLQUFLLENBQUMsUUFBTixFQUFmO0FBQ0EsTUFBQSxNQUFNLENBQUMsUUFBUCxDQUFnQixLQUFoQixHQUF3QixRQUFRLElBQUksV0FBcEM7QUFDRCxLQUhNLE1BR0EsSUFBRyxLQUFLLENBQUMsUUFBTixDQUFlLEtBQWYsS0FBeUIsUUFBUSxLQUFLLFVBQXpDLEVBQXFEO0FBQzFELFVBQUcsQ0FBQyxLQUFLLENBQUMsUUFBTixDQUFlLEtBQWYsQ0FBSixFQUEyQjtBQUN6QixRQUFBLEtBQUssR0FBRyxVQUFVLENBQUMsS0FBRCxDQUFsQjtBQUNELE9BSHlELENBSTFEOzs7QUFDQSxNQUFBLE1BQU0sQ0FBQyxLQUFQLEdBQWUsS0FBSyxDQUFDLGFBQU4sQ0FBb0IsRUFBcEIsRUFBd0IsT0FBeEIsQ0FBZ0MsWUFBaEMsRUFBOEMsS0FBOUMsQ0FBZjtBQUNBLE1BQUEsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsS0FBaEIsR0FBd0IsUUFBUSxJQUFJLFVBQXBDO0FBQ0QsS0FQTSxNQU9BLElBQUcsS0FBSyxDQUFDLFFBQU4sQ0FBZSxLQUFmLENBQUgsRUFBMEI7QUFDL0IsTUFBQSxNQUFNLENBQUMsS0FBUCxHQUFlLEtBQUssQ0FBQyxPQUFOLENBQWMsQ0FBZCxDQUFmO0FBQ0EsTUFBQSxNQUFNLENBQUMsUUFBUCxDQUFnQixLQUFoQixHQUF3QixRQUFRLElBQUksV0FBcEM7QUFDRCxLQUhNLE1BR0EsSUFBRyxZQUFZLEtBQUssZUFBakIsSUFDUixnQkFBZ0IsSUFEWCxFQUNpQjtBQUN0QixVQUFNLFNBQVEsR0FBRyxpQ0FDZCxJQUFJLENBQUMsV0FBRCxDQUFKLElBQXFCLEVBRFAsZUFFWCxJQUFJLENBQUMsWUFBRCxDQUZPLENBQWpCOztBQUdBLE1BQUEsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsS0FBaEIsR0FBd0IsU0FBeEI7QUFDQSxNQUFBLE1BQU0sQ0FBQyxLQUFQLEdBQWUsS0FBZjtBQUNELEtBUE0sTUFPQSxJQUFHLGVBQWUsSUFBbEIsRUFBd0I7QUFDN0IsTUFBQSxNQUFNLENBQUMsS0FBUCxHQUFlLEtBQWY7QUFDQSxNQUFBLE1BQU0sQ0FBQyxRQUFQLENBQWdCLEtBQWhCLEdBQXdCLFFBQVEsSUFBSSxjQUFwQztBQUNBLE1BQUEsTUFBTSxDQUFDLFFBQVAsR0FBa0IsSUFBSSxDQUFDLFdBQUQsQ0FBdEI7QUFDRCxLQUpNLE1BSUE7QUFDTCxNQUFBLE1BQU0sQ0FBQyxLQUFQLEdBQWUsS0FBZjtBQUNBLE1BQUEsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsS0FBaEIsR0FBd0IsUUFBUSxJQUFJLFVBQXBDO0FBQ0Q7QUFDRixHQXpDRCxNQXlDTyxJQUFHLFVBQVUsQ0FBQyxNQUFYLENBQWtCLElBQWxCLENBQUgsRUFBNEI7QUFDakMsUUFBTSxLQUFLLEdBQ1QsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFELENBQUwsRUFBZ0IsTUFBaEIsRUFBd0IsT0FBeEIsRUFBaUMsU0FBakMsRUFBNEMsWUFBNUMsQ0FEWjs7QUFFQSxJQUFBLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLEtBQUssQ0FBQyxRQUF4QjtBQUNBLElBQUEsTUFBTSxDQUFDLEtBQVAsR0FBZSxLQUFLLENBQUMsS0FBckI7QUFDRCxHQUxNLE1BS0E7QUFDTDtBQUNBLFFBQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxRQUFOLENBQWUsSUFBZixJQUF1QixJQUFJLENBQUMsS0FBRCxDQUEzQixHQUFxQyxJQUFoRDtBQUNBLElBQUEsTUFBTSxDQUFDLFFBQVAsR0FBa0IsRUFBRSxDQUFDLFVBQUgsQ0FBYyxJQUFkLElBQXNCLFdBQXRCLEdBQW9DLFdBQXREO0FBQ0EsSUFBQSxNQUFNLENBQUMsS0FBUCxHQUFlLEVBQWY7QUFDRCxHQXZEbUUsQ0F5RHBFOzs7QUFDQSxNQUFHLE1BQU0sQ0FBQyxRQUFQLEtBQW9CLFdBQXBCLElBQW1DLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxLQUFSLENBQXJELEVBQXFFO0FBQ25FLFdBQU8sSUFBUDtBQUNEOztBQUVELFNBQU8sTUFBUDtBQUNEOzs7QUN2UkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBTSxHQUFHLEdBQUcsRUFBWjtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLEdBQWpCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsR0FBRyxDQUFDLE9BQUosR0FBYyxLQUFLLENBQUMsT0FBcEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxHQUFHLENBQUMsU0FBSixHQUFnQixVQUFBLENBQUM7QUFBQSxTQUFLLE9BQU8sQ0FBUCxLQUFhLFNBQWIsSUFDcEIsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsUUFBakIsQ0FBMEIsSUFBMUIsQ0FBK0IsQ0FBL0IsTUFBc0Msa0JBRHZCO0FBQUEsQ0FBakI7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFFBQUosR0FBZSxVQUFBLENBQUM7QUFBQSxTQUFJLEdBQUcsQ0FBQyxRQUFKLENBQWEsQ0FBYixNQUNqQixNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsT0FBVixDQUFrQixHQUFsQixNQUEyQixDQUFDLENBQTVCLElBQWlDLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBVCxLQUFlLElBRC9CLENBQUo7QUFBQSxDQUFoQjtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsYUFBSixHQUFvQixVQUFBLENBQUM7QUFBQSxTQUFJLEdBQUcsQ0FBQyxRQUFKLENBQWEsQ0FBYixLQUFtQixNQUFNLENBQUMsSUFBUCxDQUFZLENBQVosRUFBZSxNQUFmLEtBQTBCLENBQWpEO0FBQUEsQ0FBckI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFFBQUosR0FBZSxVQUFBLENBQUM7QUFBQSxTQUFLLE9BQU8sQ0FBUCxLQUFhLFFBQWIsSUFDbkIsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsUUFBakIsQ0FBMEIsSUFBMUIsQ0FBK0IsQ0FBL0IsTUFBc0MsaUJBRHhCO0FBQUEsQ0FBaEI7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFNBQUosR0FBZ0IsVUFBQSxDQUFDO0FBQUEsU0FBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBRCxDQUFYLENBQU4sSUFBeUIsUUFBUSxDQUFDLENBQUQsQ0FBckM7QUFBQSxDQUFqQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsUUFBSixHQUFlLFVBQUEsQ0FBQztBQUFBLFNBQUksTUFBTSxDQUFDLFNBQVAsQ0FBaUIsUUFBakIsQ0FBMEIsSUFBMUIsQ0FBK0IsQ0FBL0IsTUFBc0MsaUJBQTFDO0FBQUEsQ0FBaEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFFBQUosR0FBZSxVQUFBLENBQUM7QUFBQSxTQUFLLE9BQU8sQ0FBUCxLQUFhLFFBQWIsSUFDbkIsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsUUFBakIsQ0FBMEIsSUFBMUIsQ0FBK0IsQ0FBL0IsTUFBc0MsaUJBRHhCO0FBQUEsQ0FBaEI7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFdBQUosR0FBa0IsVUFBQSxDQUFDO0FBQUEsU0FBSSxPQUFPLENBQVAsS0FBYSxXQUFqQjtBQUFBLENBQW5COzs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQUQsQ0FBckI7O0FBRUEsSUFBTSxHQUFHLEdBQUcsRUFBWjtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLEdBQWpCLEMsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLEdBQUcsQ0FBQyxPQUFKLEdBQWM7QUFDWixFQUFBLE1BQU0sRUFBRTtBQUNOO0FBQ0EsSUFBQSxJQUFJLEVBQUUsQ0FDSixNQURJLEVBQ0ksUUFESixFQUNjLFdBRGQsRUFDMkIsTUFEM0IsRUFDbUMsT0FEbkMsRUFDNEMsVUFENUMsQ0FGQTs7QUFLTjtBQUNBLElBQUEsS0FBSyxFQUFFO0FBTkQsR0FESTtBQVNaLEVBQUEsSUFBSSxFQUFFO0FBQ0osSUFBQSxJQUFJLEVBQUUsQ0FDSixNQURJLEVBQ0ksVUFESixFQUNnQixRQURoQixFQUMwQixXQUQxQixFQUN1QyxNQUR2QyxFQUMrQyxNQUQvQyxFQUN1RCxVQUR2RCxFQUVKLFVBRkksRUFFUSxNQUZSLEVBRWdCLE1BRmhCLEVBRXdCLFdBRnhCLEVBRXFDLE1BRnJDLEVBRTZDLE9BRjdDLEVBRXNELFVBRnRELENBREY7O0FBS0o7QUFDQSxJQUFBLEtBQUssRUFBRTtBQU5IO0FBVE0sQ0FBZDs7QUFrQkEsR0FBRyxDQUFDLEtBQUosR0FBWSxVQUFDLEdBQUQsRUFBTSxNQUFOLEVBQWlCO0FBQzNCLE1BQU0sTUFBTSxHQUFHLEVBQWY7QUFDQSxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBSixDQUFZLE1BQU0sSUFBSSxNQUF0QixDQUFWO0FBQ0EsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUYsQ0FBUSxJQUFSLENBQWEsR0FBYixDQUFWO0FBQ0EsTUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUYsQ0FBTyxNQUFmOztBQUNBLFNBQU0sQ0FBQyxFQUFQLEVBQVc7QUFDVCxJQUFBLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBRixDQUFPLENBQVAsQ0FBRCxDQUFOLEdBQXFCLENBQUMsQ0FBQyxDQUFELENBQUQsS0FBUyxTQUFWLEdBQXVCLElBQXZCLEdBQThCLENBQUMsQ0FBQyxDQUFELENBQW5EO0FBQ0QsR0FQMEIsQ0FTM0I7OztBQUNBLE1BQUksTUFBTSxDQUFDLE1BQVAsS0FBa0IsT0FBbEIsSUFBNkIsTUFBTSxDQUFDLElBQVAsS0FBZ0IsS0FBOUMsSUFDQSxNQUFNLENBQUMsTUFBUCxLQUFrQixNQUFsQixJQUE0QixNQUFNLENBQUMsSUFBUCxLQUFnQixJQUQvQyxFQUNzRDtBQUNwRCxJQUFBLE1BQU0sQ0FBQyxJQUFQLEdBQWMsTUFBTSxDQUFDLElBQVAsQ0FBWSxPQUFaLENBQW9CLE1BQU0sTUFBTSxDQUFDLElBQWpDLEVBQXVDLEVBQXZDLENBQWQ7QUFDQSxJQUFBLE1BQU0sQ0FBQyxTQUFQLEdBQW1CLE1BQU0sQ0FBQyxTQUFQLENBQWlCLE9BQWpCLENBQXlCLE1BQU0sTUFBTSxDQUFDLElBQXRDLEVBQTRDLEVBQTVDLENBQW5CO0FBQ0EsSUFBQSxNQUFNLENBQUMsSUFBUCxHQUFjLElBQWQ7QUFDRDs7QUFFRCxFQUFBLE1BQU0sQ0FBQyxjQUFQLEdBQXdCLEdBQUcsQ0FBQyxpQkFBSixDQUFzQixNQUFNLENBQUMsSUFBN0IsQ0FBeEI7QUFDQSxTQUFPLE1BQVA7QUFDRCxDQW5CRDtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsV0FBSixHQUFrQixVQUFDLElBQUQsRUFBTyxHQUFQLEVBQWU7QUFDL0I7QUFDQSxNQUFHLElBQUksS0FBSyxJQUFaLEVBQWtCO0FBQ2hCLFdBQU8sR0FBUDtBQUNELEdBSjhCLENBSy9COzs7QUFDQSxNQUFHLEdBQUcsQ0FBQyxVQUFKLENBQWUsR0FBZixDQUFILEVBQXdCO0FBQ3RCLFdBQU8sR0FBUDtBQUNELEdBUjhCLENBVS9COzs7QUFDQSxNQUFHLENBQUMsSUFBRCxJQUFTLEtBQUssQ0FBQyxRQUFOLENBQWUsSUFBZixDQUFaLEVBQWtDO0FBQ2hDLElBQUEsSUFBSSxHQUFHLEdBQUcsQ0FBQyxLQUFKLENBQVUsSUFBSSxJQUFJLEVBQWxCLENBQVA7QUFDRCxHQWI4QixDQWUvQjs7O0FBQ0EsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLEtBQUosQ0FBVSxHQUFWLENBQVosQ0FoQitCLENBa0IvQjs7QUFDQSxNQUFNLFNBQVMsR0FBRztBQUNoQixJQUFBLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBTCxJQUFpQjtBQURYLEdBQWxCOztBQUlBLE1BQUcsR0FBRyxDQUFDLFNBQUosS0FBa0IsSUFBckIsRUFBMkI7QUFDekIsSUFBQSxTQUFTLENBQUMsU0FBVixHQUFzQixHQUFHLENBQUMsU0FBMUI7QUFDQSxJQUFBLFNBQVMsQ0FBQyxJQUFWLEdBQWlCLEdBQUcsQ0FBQyxJQUFyQjtBQUNBLElBQUEsU0FBUyxDQUFDLEtBQVYsR0FBa0IsR0FBRyxDQUFDLEtBQXRCO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsSUFBQSxTQUFTLENBQUMsU0FBVixHQUFzQixJQUFJLENBQUMsU0FBM0I7O0FBRUEsUUFBRyxHQUFHLENBQUMsSUFBSixLQUFhLEVBQWhCLEVBQW9CO0FBQ2xCLE1BQUEsU0FBUyxDQUFDLElBQVYsR0FBaUIsSUFBSSxDQUFDLElBQXRCOztBQUNBLFVBQUcsR0FBRyxDQUFDLEtBQUosS0FBYyxJQUFqQixFQUF1QjtBQUNyQixRQUFBLFNBQVMsQ0FBQyxLQUFWLEdBQWtCLEdBQUcsQ0FBQyxLQUF0QjtBQUNELE9BRkQsTUFFTztBQUNMLFFBQUEsU0FBUyxDQUFDLEtBQVYsR0FBa0IsSUFBSSxDQUFDLEtBQXZCO0FBQ0Q7QUFDRixLQVBELE1BT087QUFDTCxVQUFHLEdBQUcsQ0FBQyxJQUFKLENBQVMsT0FBVCxDQUFpQixHQUFqQixNQUEwQixDQUE3QixFQUFnQztBQUM5QjtBQUNBLFFBQUEsU0FBUyxDQUFDLElBQVYsR0FBaUIsR0FBRyxDQUFDLElBQXJCO0FBQ0QsT0FIRCxNQUdPO0FBQ0w7QUFDQSxZQUFJLElBQUksR0FBRyxJQUFJLENBQUMsSUFBaEIsQ0FGSyxDQUlMOztBQUNBLFFBQUEsSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFMLENBQVksQ0FBWixFQUFlLElBQUksQ0FBQyxXQUFMLENBQWlCLEdBQWpCLElBQXdCLENBQXZDLENBQVA7O0FBQ0EsWUFBRyxDQUFDLElBQUksQ0FBQyxNQUFMLEdBQWMsQ0FBZCxJQUFtQixJQUFJLENBQUMsU0FBekIsS0FBdUMsSUFBSSxDQUFDLE1BQUwsQ0FBWSxDQUFDLENBQWIsTUFBb0IsR0FBOUQsRUFBbUU7QUFDakUsVUFBQSxJQUFJLElBQUksR0FBUjtBQUNEOztBQUNELFFBQUEsSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFaO0FBRUEsUUFBQSxTQUFTLENBQUMsSUFBVixHQUFpQixJQUFqQjtBQUNEOztBQUNELE1BQUEsU0FBUyxDQUFDLEtBQVYsR0FBa0IsR0FBRyxDQUFDLEtBQXRCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFHLEdBQUcsQ0FBQyxJQUFKLEtBQWEsRUFBaEIsRUFBb0I7QUFDbEI7QUFDQSxJQUFBLFNBQVMsQ0FBQyxJQUFWLEdBQWlCLEdBQUcsQ0FBQyxpQkFBSixDQUFzQixTQUFTLENBQUMsSUFBaEMsQ0FBakI7QUFDRCxHQTdEOEIsQ0ErRC9COzs7QUFDQSxNQUFJLElBQUksR0FBRyxTQUFTLENBQUMsUUFBckI7O0FBQ0EsTUFBRyxTQUFTLENBQUMsU0FBVixLQUF3QixJQUEzQixFQUFpQztBQUMvQixJQUFBLElBQUksSUFBSSxPQUFPLFNBQVMsQ0FBQyxTQUF6QjtBQUNEOztBQUNELEVBQUEsSUFBSSxJQUFJLFNBQVMsQ0FBQyxJQUFsQjs7QUFDQSxNQUFHLFNBQVMsQ0FBQyxLQUFWLEtBQW9CLElBQXZCLEVBQTZCO0FBQzNCLElBQUEsSUFBSSxJQUFJLE1BQU0sU0FBUyxDQUFDLEtBQXhCO0FBQ0Q7O0FBQ0QsTUFBRyxHQUFHLENBQUMsUUFBSixLQUFpQixJQUFwQixFQUEwQjtBQUN4QixJQUFBLElBQUksSUFBSSxNQUFNLEdBQUcsQ0FBQyxRQUFsQjtBQUNELEdBMUU4QixDQTRFL0I7OztBQUNBLE1BQUcsSUFBSSxLQUFLLEVBQVosRUFBZ0I7QUFDZCxJQUFBLElBQUksR0FBRyxJQUFQO0FBQ0Q7O0FBRUQsU0FBTyxJQUFQO0FBQ0QsQ0FsRkQ7QUFvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFVBQUosR0FBaUIsVUFBQyxJQUFELEVBQU8sR0FBUCxFQUFlO0FBQzlCO0FBQ0EsTUFBRyxJQUFJLEtBQUssSUFBWixFQUFrQjtBQUNoQixXQUFPLEdBQVA7QUFDRDs7QUFFRCxNQUFHLENBQUMsSUFBRCxJQUFTLEtBQUssQ0FBQyxRQUFOLENBQWUsSUFBZixDQUFaLEVBQWtDO0FBQ2hDLElBQUEsSUFBSSxHQUFHLEdBQUcsQ0FBQyxLQUFKLENBQVUsSUFBSSxJQUFJLEVBQWxCLENBQVA7QUFDRCxHQVI2QixDQVU5Qjs7O0FBQ0EsTUFBSSxJQUFJLEdBQUcsRUFBWDs7QUFDQSxNQUFHLElBQUksQ0FBQyxJQUFMLEtBQWMsRUFBakIsRUFBcUI7QUFDbkIsSUFBQSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBTCxJQUFpQixFQUFsQixJQUF3QixJQUF4QixJQUFnQyxJQUFJLENBQUMsU0FBTCxJQUFrQixFQUFsRCxDQUFSO0FBQ0QsR0FGRCxNQUVPLElBQUcsR0FBRyxDQUFDLE9BQUosQ0FBWSxJQUFaLENBQUgsRUFBc0I7QUFDM0I7QUFDQSxJQUFBLElBQUksSUFBSSxJQUFSO0FBQ0QsR0FqQjZCLENBbUI5Qjs7O0FBQ0EsTUFBRyxHQUFHLENBQUMsT0FBSixDQUFZLElBQVosTUFBc0IsQ0FBekIsRUFBNEI7QUFDMUIsV0FBTyxHQUFQO0FBQ0QsR0F0QjZCLENBd0I5Qjs7O0FBQ0EsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLEtBQUosQ0FBVSxHQUFHLENBQUMsTUFBSixDQUFXLElBQUksQ0FBQyxNQUFoQixDQUFWLENBQVosQ0F6QjhCLENBMkI5QjtBQUNBOztBQUNBLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFMLENBQW9CLEtBQXBCLENBQTBCLEdBQTFCLENBQXJCO0FBQ0EsTUFBTSxXQUFXLEdBQUcsR0FBRyxDQUFDLGNBQUosQ0FBbUIsS0FBbkIsQ0FBeUIsR0FBekIsQ0FBcEI7QUFDQSxNQUFNLElBQUksR0FBSSxHQUFHLENBQUMsUUFBSixJQUFnQixHQUFHLENBQUMsS0FBckIsR0FBOEIsQ0FBOUIsR0FBa0MsQ0FBL0M7O0FBQ0EsU0FBTSxZQUFZLENBQUMsTUFBYixHQUFzQixDQUF0QixJQUEyQixXQUFXLENBQUMsTUFBWixHQUFxQixJQUF0RCxFQUE0RDtBQUMxRCxRQUFHLFlBQVksQ0FBQyxDQUFELENBQVosS0FBb0IsV0FBVyxDQUFDLENBQUQsQ0FBbEMsRUFBdUM7QUFDckM7QUFDRDs7QUFDRCxJQUFBLFlBQVksQ0FBQyxLQUFiO0FBQ0EsSUFBQSxXQUFXLENBQUMsS0FBWjtBQUNELEdBdEM2QixDQXdDOUI7OztBQUNBLE1BQUksSUFBSSxHQUFHLEVBQVg7O0FBQ0EsTUFBRyxZQUFZLENBQUMsTUFBYixHQUFzQixDQUF6QixFQUE0QjtBQUMxQjtBQUNBO0FBQ0EsSUFBQSxZQUFZLENBQUMsR0FBYjs7QUFDQSxTQUFJLElBQUksQ0FBQyxHQUFHLENBQVosRUFBZSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQWhDLEVBQXdDLEVBQUUsQ0FBMUMsRUFBNkM7QUFDM0MsTUFBQSxJQUFJLElBQUksS0FBUjtBQUNEO0FBQ0YsR0FqRDZCLENBbUQ5Qjs7O0FBQ0EsRUFBQSxJQUFJLElBQUksV0FBVyxDQUFDLElBQVosQ0FBaUIsR0FBakIsQ0FBUixDQXBEOEIsQ0FzRDlCOztBQUNBLE1BQUcsR0FBRyxDQUFDLEtBQUosS0FBYyxJQUFqQixFQUF1QjtBQUNyQixJQUFBLElBQUksSUFBSSxNQUFNLEdBQUcsQ0FBQyxLQUFsQjtBQUNEOztBQUNELE1BQUcsR0FBRyxDQUFDLFFBQUosS0FBaUIsSUFBcEIsRUFBMEI7QUFDeEIsSUFBQSxJQUFJLElBQUksTUFBTSxHQUFHLENBQUMsUUFBbEI7QUFDRCxHQTVENkIsQ0E4RDlCOzs7QUFDQSxNQUFHLElBQUksS0FBSyxFQUFaLEVBQWdCO0FBQ2QsSUFBQSxJQUFJLEdBQUcsSUFBUDtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNELENBcEVEO0FBc0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxpQkFBSixHQUF3QixVQUFBLElBQUksRUFBSTtBQUM5QjtBQUVBO0FBQ0EsTUFBRyxJQUFJLENBQUMsTUFBTCxLQUFnQixDQUFuQixFQUFzQjtBQUNwQixXQUFPLEVBQVA7QUFDRDs7QUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLEdBQVgsQ0FBZDtBQUNBLE1BQU0sTUFBTSxHQUFHLEVBQWY7O0FBRUEsU0FBTSxLQUFLLENBQUMsTUFBTixHQUFlLENBQXJCLEVBQXdCO0FBQ3RCLFFBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFOLEVBQWI7QUFDQSxRQUFNLElBQUksR0FBRyxLQUFLLENBQUMsTUFBTixLQUFpQixDQUE5Qjs7QUFFQSxRQUFHLElBQUksS0FBSyxHQUFaLEVBQWlCO0FBQ2YsVUFBRyxJQUFILEVBQVM7QUFDUDtBQUNBLFFBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxFQUFaO0FBQ0Q7O0FBQ0Q7QUFDRDs7QUFFRCxRQUFHLElBQUksS0FBSyxJQUFaLEVBQWtCO0FBQ2hCLE1BQUEsTUFBTSxDQUFDLEdBQVA7O0FBQ0EsVUFBRyxJQUFILEVBQVM7QUFDUDtBQUNBLFFBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxFQUFaO0FBQ0Q7O0FBQ0Q7QUFDRDs7QUFFRCxJQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksSUFBWjtBQUNELEdBakM2QixDQW1DOUI7OztBQUNBLE1BQUcsSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZLEdBQVosSUFBbUIsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsQ0FBbkMsSUFBd0MsTUFBTSxDQUFDLENBQUQsQ0FBTixLQUFjLEVBQXpELEVBQTZEO0FBQzNELElBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxFQUFmO0FBQ0Q7O0FBQ0QsTUFBRyxNQUFNLENBQUMsTUFBUCxLQUFrQixDQUFsQixJQUF1QixNQUFNLENBQUMsQ0FBRCxDQUFOLEtBQWMsRUFBeEMsRUFBNEM7QUFDMUMsV0FBTyxHQUFQO0FBQ0Q7O0FBRUQsU0FBTyxNQUFNLENBQUMsSUFBUCxDQUFZLEdBQVosQ0FBUDtBQUNELENBNUNELEMsQ0E4Q0E7QUFDQTtBQUVBOzs7QUFDQSxJQUFNLGVBQWUsR0FBRyxzQ0FBeEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsR0FBRyxDQUFDLFVBQUosR0FBaUIsVUFBQSxDQUFDO0FBQUEsU0FBSSxLQUFLLENBQUMsUUFBTixDQUFlLENBQWYsS0FBcUIsZUFBZSxDQUFDLElBQWhCLENBQXFCLENBQXJCLENBQXpCO0FBQUEsQ0FBbEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsVUFBSixHQUFpQixVQUFBLENBQUM7QUFBQSxTQUFJLEtBQUssQ0FBQyxRQUFOLENBQWUsQ0FBZixDQUFKO0FBQUEsQ0FBbEI7OztBQzVTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsY0FBRCxDQUExQjs7QUFDQSxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBRCxDQUFyQixDLENBQ0E7OztBQUNBLElBQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLGNBQUQsQ0FBUCxDQUF3QixnQkFBakQ7O0FBQ0EsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLGVBQUQsQ0FBM0IsQyxDQUVBOzs7QUFDQSxJQUFNLGtCQUFrQixHQUFHLDhCQUEzQjtBQUNBLElBQU0saUJBQWlCLEdBQUcsK0JBQTFCO0FBQ0EsSUFBTSx3QkFBd0IsR0FDNUIscURBREY7QUFHQSxJQUFNLFFBQVEsR0FBRztBQUNmLEVBQUEsT0FBTyxFQUFFO0FBQ1AsSUFBQSxNQUFNLEVBQUU7QUFERDtBQURNLENBQWpCO0FBTUEsSUFBTSxHQUFHLEdBQUcsRUFBWjtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLEdBQWpCO0FBQ0EsR0FBRyxDQUFDLGdCQUFKLEdBQXVCLGdCQUF2QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsR0FBRyxDQUFDLEtBQUosR0FBWSxVQUFTLEtBQVQsRUFBZ0I7QUFDMUIsTUFBRyxLQUFLLElBQUkseUJBQU8sS0FBUCxNQUFpQixRQUE3QixFQUF1QztBQUNyQyxRQUFJLElBQUo7O0FBQ0EsUUFBRyxLQUFLLENBQUMsT0FBTixDQUFjLEtBQWQsQ0FBSCxFQUF5QjtBQUN2QixNQUFBLElBQUksR0FBRyxFQUFQOztBQUNBLFdBQUksSUFBSSxDQUFDLEdBQUcsQ0FBWixFQUFlLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBekIsRUFBaUMsRUFBRSxDQUFuQyxFQUFzQztBQUNwQyxRQUFBLElBQUksQ0FBQyxDQUFELENBQUosR0FBVSxHQUFHLENBQUMsS0FBSixDQUFVLEtBQUssQ0FBQyxDQUFELENBQWYsQ0FBVjtBQUNEO0FBQ0YsS0FMRCxNQUtPLElBQUcsS0FBSyxZQUFZLEdBQXBCLEVBQXlCO0FBQzlCLE1BQUEsSUFBSSxHQUFHLElBQUksR0FBSixFQUFQOztBQUQ4QixpREFFVixLQUZVO0FBQUE7O0FBQUE7QUFFOUIsNERBQTJCO0FBQUE7QUFBQSxjQUFoQixDQUFnQjtBQUFBLGNBQWIsQ0FBYTs7QUFDekIsVUFBQSxJQUFJLENBQUMsR0FBTCxDQUFTLENBQVQsRUFBWSxHQUFHLENBQUMsS0FBSixDQUFVLENBQVYsQ0FBWjtBQUNEO0FBSjZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLL0IsS0FMTSxNQUtBLElBQUcsS0FBSyxZQUFZLEdBQXBCLEVBQXlCO0FBQzlCLE1BQUEsSUFBSSxHQUFHLElBQUksR0FBSixFQUFQOztBQUQ4QixrREFFZixLQUZlO0FBQUE7O0FBQUE7QUFFOUIsK0RBQXNCO0FBQUEsY0FBWixFQUFZO0FBQ3BCLFVBQUEsSUFBSSxDQUFDLEdBQUwsQ0FBUyxHQUFHLENBQUMsS0FBSixDQUFVLEVBQVYsQ0FBVDtBQUNEO0FBSjZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLL0IsS0FMTSxNQUtBLElBQUcsS0FBSyxDQUFDLFFBQU4sQ0FBZSxLQUFmLENBQUgsRUFBMEI7QUFDL0IsTUFBQSxJQUFJLEdBQUcsRUFBUDs7QUFDQSxXQUFJLElBQU0sR0FBVixJQUFpQixLQUFqQixFQUF3QjtBQUN0QixRQUFBLElBQUksQ0FBQyxHQUFELENBQUosR0FBWSxHQUFHLENBQUMsS0FBSixDQUFVLEtBQUssQ0FBQyxHQUFELENBQWYsQ0FBWjtBQUNEO0FBQ0YsS0FMTSxNQUtBO0FBQ0wsTUFBQSxJQUFJLEdBQUcsS0FBSyxDQUFDLFFBQU4sRUFBUDtBQUNEOztBQUNELFdBQU8sSUFBUDtBQUNEOztBQUNELFNBQU8sS0FBUDtBQUNELENBN0JEO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxPQUFKLEdBQWMsVUFBUyxLQUFULEVBQWdCO0FBQzVCLFNBQU8sS0FBSyxDQUFDLE9BQU4sQ0FBYyxLQUFkLElBQXVCLEtBQXZCLEdBQStCLENBQUMsS0FBRCxDQUF0QztBQUNELENBRkQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxZQUFKLEdBQW1CLFlBQWtCO0FBQUEsTUFBakIsT0FBaUIsdUVBQVAsRUFBTztBQUNuQyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsSUFBckIsQ0FDaEIsVUFBQSxDQUFDO0FBQUEsV0FBSSxDQUFDLENBQUMsV0FBRixPQUFvQixRQUF4QjtBQUFBLEdBRGUsQ0FBbEI7O0FBR0EsTUFBRyxTQUFILEVBQWM7QUFDWixVQUFNLElBQUksVUFBSixDQUNKLCtDQUNBLFFBQVEsQ0FBQyxPQUFULENBQWlCLE1BRGpCLEdBQzBCLGlCQUZ0QixDQUFOO0FBR0Q7O0FBRUQsU0FBTyxNQUFNLENBQUMsTUFBUCxDQUFjO0FBQUMsSUFBQSxNQUFNLEVBQUUsUUFBUSxDQUFDLE9BQVQsQ0FBaUI7QUFBMUIsR0FBZCxFQUFpRCxPQUFqRCxDQUFQO0FBQ0QsQ0FYRDtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLGVBQUosR0FBc0IsVUFBQSxNQUFNLEVBQUk7QUFDOUIsTUFBTSxJQUFJLEdBQUcsRUFBYixDQUQ4QixDQUU5Qjs7QUFDQSxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsS0FBUCxDQUFhLGtCQUFiLENBQWhCOztBQUNBLE9BQUksSUFBSSxDQUFDLEdBQUcsQ0FBWixFQUFlLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBM0IsRUFBbUMsRUFBRSxDQUFyQyxFQUF3QztBQUN0QyxRQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVcsS0FBWCxDQUFpQixpQkFBakIsQ0FBWjs7QUFDQSxRQUFHLENBQUMsS0FBSixFQUFXO0FBQ1Q7QUFDRDs7QUFDRCxRQUFNLE1BQU0sR0FBRztBQUFDLE1BQUEsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFEO0FBQWQsS0FBZjtBQUNBLFFBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFELENBQXBCOztBQUNBLFdBQU8sS0FBSyxHQUFHLHdCQUF3QixDQUFDLElBQXpCLENBQThCLE1BQTlCLENBQWYsRUFBdUQ7QUFDckQsTUFBQSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUQsQ0FBTixDQUFOLEdBQW9CLEtBQUssQ0FBQyxDQUFELENBQUwsS0FBYSxTQUFkLEdBQTJCLEtBQUssQ0FBQyxDQUFELENBQWhDLEdBQXNDLEtBQUssQ0FBQyxDQUFELENBQTlEO0FBQ0Q7O0FBQ0QsUUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLEtBQUQsQ0FBTixJQUFpQixFQUE3Qjs7QUFDQSxRQUFHLEtBQUssQ0FBQyxPQUFOLENBQWMsSUFBSSxDQUFDLEdBQUQsQ0FBbEIsQ0FBSCxFQUE2QjtBQUMzQixNQUFBLElBQUksQ0FBQyxHQUFELENBQUosQ0FBVSxJQUFWLENBQWUsTUFBZjtBQUNELEtBRkQsTUFFTyxJQUFHLElBQUksQ0FBQyxjQUFMLENBQW9CLEdBQXBCLENBQUgsRUFBNkI7QUFDbEMsTUFBQSxJQUFJLENBQUMsR0FBRCxDQUFKLEdBQVksQ0FBQyxJQUFJLENBQUMsR0FBRCxDQUFMLEVBQVksTUFBWixDQUFaO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsTUFBQSxJQUFJLENBQUMsR0FBRCxDQUFKLEdBQVksTUFBWjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBTyxJQUFQO0FBQ0QsQ0F4QkQ7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLGlCQUFKLEdBQXdCLFVBQUMsQ0FBRCxFQUFJLE9BQUosRUFBZ0I7QUFDdEMsTUFBRyxLQUFLLENBQUMsUUFBTixDQUFlLENBQWYsQ0FBSCxFQUFzQjtBQUNwQjtBQUNEOztBQUVELE1BQUcsS0FBSyxDQUFDLE9BQU4sQ0FBYyxDQUFkLEtBQW9CLENBQUMsQ0FBQyxLQUFGLENBQVEsVUFBQSxFQUFFO0FBQUEsV0FBSSxLQUFLLENBQUMsUUFBTixDQUFlLEVBQWYsQ0FBSjtBQUFBLEdBQVYsQ0FBdkIsRUFBMEQ7QUFDeEQ7QUFDRDs7QUFDRCxNQUFHLE9BQU8sSUFBSSxLQUFLLENBQUMsUUFBTixDQUFlLENBQWYsQ0FBZCxFQUFpQztBQUMvQixZQUFPLE1BQU0sQ0FBQyxJQUFQLENBQVksQ0FBWixFQUFlLE1BQXRCO0FBQ0UsV0FBSyxDQUFMO0FBQ0U7QUFDQTs7QUFDRixXQUFLLENBQUw7QUFDRTtBQUNBLFlBQUcsY0FBYyxDQUFkLElBQ0QsR0FBRyxDQUFDLE9BQUosQ0FBWSxDQUFDLENBQUMsVUFBRCxDQUFiLEVBQTJCLEtBQTNCLENBQWlDLFVBQUEsRUFBRTtBQUFBLGlCQUFJLEtBQUssQ0FBQyxRQUFOLENBQWUsRUFBZixDQUFKO0FBQUEsU0FBbkMsQ0FERixFQUM4RDtBQUM1RDtBQUNEOztBQVRMO0FBV0Q7O0FBRUQsUUFBTSxJQUFJLFdBQUosQ0FDSixzRUFDQSw0QkFEQSxHQUVBLHNCQUhJLEVBR29CLG9CQUhwQixFQUlKO0FBQUMsSUFBQSxJQUFJLEVBQUUsb0JBQVA7QUFBNkIsSUFBQSxLQUFLLEVBQUU7QUFBcEMsR0FKSSxDQUFOO0FBS0QsQ0EzQkQ7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFdBQUosR0FBa0IsVUFBQyxPQUFELEVBQVUsUUFBVixFQUF1QjtBQUN2QyxNQUFHLE9BQU8sQ0FBQyxjQUFSLENBQXVCLFFBQXZCLENBQUgsRUFBcUM7QUFDbkMsUUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFFBQUQsQ0FBckI7QUFDQSxXQUFRLENBQUMsS0FBSyxDQUFDLE9BQU4sQ0FBYyxLQUFkLENBQUQsSUFBeUIsS0FBSyxDQUFDLE1BQU4sR0FBZSxDQUFoRDtBQUNEOztBQUNELFNBQU8sS0FBUDtBQUNELENBTkQ7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLEdBQUcsQ0FBQyxRQUFKLEdBQWUsVUFBQyxPQUFELEVBQVUsUUFBVixFQUFvQixLQUFwQixFQUE4QjtBQUMzQyxNQUFHLEdBQUcsQ0FBQyxXQUFKLENBQWdCLE9BQWhCLEVBQXlCLFFBQXpCLENBQUgsRUFBdUM7QUFDckMsUUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDLFFBQUQsQ0FBakI7QUFDQSxRQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBWCxDQUFrQixHQUFsQixDQUFmOztBQUNBLFFBQUcsS0FBSyxDQUFDLE9BQU4sQ0FBYyxHQUFkLEtBQXNCLE1BQXpCLEVBQWlDO0FBQy9CLFVBQUcsTUFBSCxFQUFXO0FBQ1QsUUFBQSxHQUFHLEdBQUcsR0FBRyxDQUFDLE9BQUQsQ0FBVDtBQUNEOztBQUNELFdBQUksSUFBSSxDQUFDLEdBQUcsQ0FBWixFQUFlLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBdkIsRUFBK0IsRUFBRSxDQUFqQyxFQUFvQztBQUNsQyxZQUFHLEdBQUcsQ0FBQyxhQUFKLENBQWtCLEtBQWxCLEVBQXlCLEdBQUcsQ0FBQyxDQUFELENBQTVCLENBQUgsRUFBcUM7QUFDbkMsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRixLQVRELE1BU08sSUFBRyxDQUFDLEtBQUssQ0FBQyxPQUFOLENBQWMsS0FBZCxDQUFKLEVBQTBCO0FBQy9CO0FBQ0EsYUFBTyxHQUFHLENBQUMsYUFBSixDQUFrQixLQUFsQixFQUF5QixHQUF6QixDQUFQO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPLEtBQVA7QUFDRCxDQW5CRDtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsUUFBSixHQUFlLFVBQUMsT0FBRCxFQUFVLFFBQVYsRUFBb0IsS0FBcEIsRUFBMkIsT0FBM0IsRUFBdUM7QUFDcEQsRUFBQSxPQUFPLEdBQUcsT0FBTyxJQUFJLEVBQXJCOztBQUNBLE1BQUcsRUFBRSxxQkFBcUIsT0FBdkIsQ0FBSCxFQUFvQztBQUNsQyxJQUFBLE9BQU8sQ0FBQyxlQUFSLEdBQTBCLEtBQTFCO0FBQ0Q7O0FBQ0QsTUFBRyxFQUFFLGtCQUFrQixPQUFwQixDQUFILEVBQWlDO0FBQy9CLElBQUEsT0FBTyxDQUFDLFlBQVIsR0FBdUIsS0FBdkI7QUFDRDs7QUFDRCxNQUFHLEVBQUUsb0JBQW9CLE9BQXRCLENBQUgsRUFBbUM7QUFDakMsSUFBQSxPQUFPLENBQUMsY0FBUixHQUF5QixJQUF6QjtBQUNEOztBQUNELE1BQUcsRUFBRSxrQkFBa0IsT0FBcEIsQ0FBSCxFQUFpQztBQUMvQixJQUFBLE9BQU8sQ0FBQyxZQUFSLEdBQXVCLEtBQXZCO0FBQ0Q7O0FBRUQsTUFBRyxPQUFPLENBQUMsWUFBWCxFQUF5QjtBQUN2QixJQUFBLE9BQU8sQ0FBQyxRQUFELENBQVAsR0FBb0IsS0FBcEI7QUFDRCxHQUZELE1BRU8sSUFBRyxLQUFLLENBQUMsT0FBTixDQUFjLEtBQWQsQ0FBSCxFQUF5QjtBQUM5QixRQUFHLEtBQUssQ0FBQyxNQUFOLEtBQWlCLENBQWpCLElBQXNCLE9BQU8sQ0FBQyxlQUE5QixJQUNELENBQUMsT0FBTyxDQUFDLGNBQVIsQ0FBdUIsUUFBdkIsQ0FESCxFQUNxQztBQUNuQyxNQUFBLE9BQU8sQ0FBQyxRQUFELENBQVAsR0FBb0IsRUFBcEI7QUFDRDs7QUFDRCxRQUFHLE9BQU8sQ0FBQyxZQUFYLEVBQXlCO0FBQ3ZCLE1BQUEsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsT0FBTyxDQUFDLFFBQUQsQ0FBcEIsQ0FBUjtBQUNBLE1BQUEsT0FBTyxDQUFDLFFBQUQsQ0FBUCxHQUFvQixFQUFwQjtBQUNEOztBQUNELFNBQUksSUFBSSxDQUFDLEdBQUcsQ0FBWixFQUFlLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBekIsRUFBaUMsRUFBRSxDQUFuQyxFQUFzQztBQUNwQyxNQUFBLEdBQUcsQ0FBQyxRQUFKLENBQWEsT0FBYixFQUFzQixRQUF0QixFQUFnQyxLQUFLLENBQUMsQ0FBRCxDQUFyQyxFQUEwQyxPQUExQztBQUNEO0FBQ0YsR0FaTSxNQVlBLElBQUcsT0FBTyxDQUFDLGNBQVIsQ0FBdUIsUUFBdkIsQ0FBSCxFQUFxQztBQUMxQztBQUNBLFFBQU0sUUFBUSxHQUFJLENBQUMsT0FBTyxDQUFDLGNBQVQsSUFDaEIsR0FBRyxDQUFDLFFBQUosQ0FBYSxPQUFiLEVBQXNCLFFBQXRCLEVBQWdDLEtBQWhDLENBREYsQ0FGMEMsQ0FLMUM7O0FBQ0EsUUFBRyxDQUFDLEtBQUssQ0FBQyxPQUFOLENBQWMsT0FBTyxDQUFDLFFBQUQsQ0FBckIsQ0FBRCxLQUNBLENBQUMsUUFBRCxJQUFhLE9BQU8sQ0FBQyxlQURyQixDQUFILEVBQzBDO0FBQ3hDLE1BQUEsT0FBTyxDQUFDLFFBQUQsQ0FBUCxHQUFvQixDQUFDLE9BQU8sQ0FBQyxRQUFELENBQVIsQ0FBcEI7QUFDRCxLQVR5QyxDQVcxQzs7O0FBQ0EsUUFBRyxDQUFDLFFBQUosRUFBYztBQUNaLFVBQUcsT0FBTyxDQUFDLFlBQVgsRUFBeUI7QUFDdkIsUUFBQSxPQUFPLENBQUMsUUFBRCxDQUFQLENBQWtCLE9BQWxCLENBQTBCLEtBQTFCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsUUFBQSxPQUFPLENBQUMsUUFBRCxDQUFQLENBQWtCLElBQWxCLENBQXVCLEtBQXZCO0FBQ0Q7QUFDRjtBQUNGLEdBbkJNLE1BbUJBO0FBQ0w7QUFDQSxJQUFBLE9BQU8sQ0FBQyxRQUFELENBQVAsR0FBb0IsT0FBTyxDQUFDLGVBQVIsR0FBMEIsQ0FBQyxLQUFELENBQTFCLEdBQW9DLEtBQXhEO0FBQ0Q7QUFDRixDQXBERDtBQXNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsU0FBSixHQUFnQixVQUFDLE9BQUQsRUFBVSxRQUFWO0FBQUEsU0FBdUIsR0FBRyxNQUFILENBQVUsT0FBTyxDQUFDLFFBQUQsQ0FBUCxJQUFxQixFQUEvQixDQUF2QjtBQUFBLENBQWhCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsY0FBSixHQUFxQixVQUFDLE9BQUQsRUFBVSxRQUFWLEVBQXVCO0FBQzFDLFNBQU8sT0FBTyxDQUFDLFFBQUQsQ0FBZDtBQUNELENBRkQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLFdBQUosR0FBa0IsVUFBQyxPQUFELEVBQVUsUUFBVixFQUFvQixLQUFwQixFQUEyQixPQUEzQixFQUF1QztBQUN2RCxFQUFBLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBckI7O0FBQ0EsTUFBRyxFQUFFLHFCQUFxQixPQUF2QixDQUFILEVBQW9DO0FBQ2xDLElBQUEsT0FBTyxDQUFDLGVBQVIsR0FBMEIsS0FBMUI7QUFDRCxHQUpzRCxDQU12RDs7O0FBQ0EsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLFNBQUosQ0FBYyxPQUFkLEVBQXVCLFFBQXZCLEVBQWlDLE1BQWpDLENBQ2IsVUFBQSxDQUFDO0FBQUEsV0FBSSxDQUFDLEdBQUcsQ0FBQyxhQUFKLENBQWtCLENBQWxCLEVBQXFCLEtBQXJCLENBQUw7QUFBQSxHQURZLENBQWY7O0FBR0EsTUFBRyxNQUFNLENBQUMsTUFBUCxLQUFrQixDQUFyQixFQUF3QjtBQUN0QixJQUFBLEdBQUcsQ0FBQyxjQUFKLENBQW1CLE9BQW5CLEVBQTRCLFFBQTVCO0FBQ0QsR0FGRCxNQUVPLElBQUcsTUFBTSxDQUFDLE1BQVAsS0FBa0IsQ0FBbEIsSUFBdUIsQ0FBQyxPQUFPLENBQUMsZUFBbkMsRUFBb0Q7QUFDekQsSUFBQSxPQUFPLENBQUMsUUFBRCxDQUFQLEdBQW9CLE1BQU0sQ0FBQyxDQUFELENBQTFCO0FBQ0QsR0FGTSxNQUVBO0FBQ0wsSUFBQSxPQUFPLENBQUMsUUFBRCxDQUFQLEdBQW9CLE1BQXBCO0FBQ0Q7QUFDRixDQWpCRDtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLGlCQUFKLEdBQXdCLFVBQUMsS0FBRCxFQUFRLE9BQVIsRUFBb0I7QUFDMUMsRUFBQSxPQUFPLEdBQUcsT0FBTyxJQUFJLEVBQXJCO0FBQ0EsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQVIsSUFBa0IsSUFBSSxnQkFBSixDQUFxQixLQUFyQixDQUFqQztBQUNBLFNBQU8sZ0JBQWdCLENBQUMsTUFBRCxFQUFTLEtBQVQsQ0FBdkI7QUFDRCxDQUpEO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsR0FBRyxDQUFDLGFBQUosR0FBb0IsVUFBQyxFQUFELEVBQUssRUFBTCxFQUFZO0FBQzlCO0FBQ0EsTUFBRyxFQUFFLEtBQUssRUFBVixFQUFjO0FBQ1osV0FBTyxJQUFQO0FBQ0QsR0FKNkIsQ0FNOUI7OztBQUNBLE1BQUcsVUFBVSxDQUFDLE9BQVgsQ0FBbUIsRUFBbkIsS0FBMEIsVUFBVSxDQUFDLE9BQVgsQ0FBbUIsRUFBbkIsQ0FBMUIsSUFDRCxFQUFFLENBQUMsUUFBRCxDQUFGLEtBQWlCLEVBQUUsQ0FBQyxRQUFELENBRGxCLElBRUQsRUFBRSxDQUFDLE9BQUQsQ0FBRixLQUFnQixFQUFFLENBQUMsT0FBRCxDQUZqQixJQUdELEVBQUUsQ0FBQyxXQUFELENBQUYsS0FBb0IsRUFBRSxDQUFDLFdBQUQsQ0FIckIsSUFJRCxFQUFFLENBQUMsUUFBRCxDQUFGLEtBQWlCLEVBQUUsQ0FBQyxRQUFELENBSnJCLEVBSWlDO0FBQy9CLFdBQU8sSUFBUDtBQUNELEdBYjZCLENBZTlCOzs7QUFDQSxNQUFHLEtBQUssQ0FBQyxRQUFOLENBQWUsRUFBZixLQUNBLFNBQVMsRUFEVCxJQUVELEtBQUssQ0FBQyxRQUFOLENBQWUsRUFBZixDQUZDLElBR0EsU0FBUyxFQUhaLEVBR2lCO0FBQ2YsV0FBTyxFQUFFLENBQUMsS0FBRCxDQUFGLEtBQWMsRUFBRSxDQUFDLEtBQUQsQ0FBdkI7QUFDRDs7QUFFRCxTQUFPLEtBQVA7QUFDRCxDQXhCRDtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxHQUFHLENBQUMsb0JBQUosR0FBMkIsVUFBQyxDQUFELEVBQUksQ0FBSixFQUFVO0FBQ25DLE1BQUcsQ0FBQyxDQUFDLE1BQUYsR0FBVyxDQUFDLENBQUMsTUFBaEIsRUFBd0I7QUFDdEIsV0FBTyxDQUFDLENBQVI7QUFDRDs7QUFDRCxNQUFHLENBQUMsQ0FBQyxNQUFGLEdBQVcsQ0FBQyxDQUFDLE1BQWhCLEVBQXdCO0FBQ3RCLFdBQU8sQ0FBUDtBQUNEOztBQUNELE1BQUcsQ0FBQyxLQUFLLENBQVQsRUFBWTtBQUNWLFdBQU8sQ0FBUDtBQUNEOztBQUNELFNBQVEsQ0FBQyxHQUFHLENBQUwsR0FBVSxDQUFDLENBQVgsR0FBZSxDQUF0QjtBQUNELENBWEQ7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLGdCQUFULENBQTBCLE1BQTFCLEVBQWtDLE9BQWxDLEVBQTJDO0FBQ3pDLE1BQUcsS0FBSyxDQUFDLE9BQU4sQ0FBYyxPQUFkLENBQUgsRUFBMkI7QUFDekIsU0FBSSxJQUFJLENBQUMsR0FBRyxDQUFaLEVBQWUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUEzQixFQUFtQyxFQUFFLENBQXJDLEVBQXdDO0FBQ3RDLE1BQUEsT0FBTyxDQUFDLENBQUQsQ0FBUCxHQUFhLGdCQUFnQixDQUFDLE1BQUQsRUFBUyxPQUFPLENBQUMsQ0FBRCxDQUFoQixDQUE3QjtBQUNEO0FBQ0YsR0FKRCxNQUlPLElBQUcsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsT0FBbEIsQ0FBSCxFQUErQjtBQUNwQyxJQUFBLE9BQU8sQ0FBQyxPQUFELENBQVAsR0FBbUIsZ0JBQWdCLENBQUMsTUFBRCxFQUFTLE9BQU8sQ0FBQyxPQUFELENBQWhCLENBQW5DO0FBQ0QsR0FGTSxNQUVBLElBQUcsS0FBSyxDQUFDLFFBQU4sQ0FBZSxPQUFmLENBQUgsRUFBNEI7QUFDakM7QUFDQSxRQUFHLFVBQVUsQ0FBQyxXQUFYLENBQXVCLE9BQXZCLENBQUgsRUFBb0M7QUFDbEMsTUFBQSxPQUFPLENBQUMsS0FBRCxDQUFQLEdBQWlCLE1BQU0sQ0FBQyxLQUFQLENBQWEsT0FBTyxDQUFDLEtBQUQsQ0FBcEIsQ0FBakI7QUFDRCxLQUpnQyxDQU1qQzs7O0FBQ0EsUUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxPQUFaLEVBQXFCLElBQXJCLEVBQWI7O0FBQ0EsU0FBSSxJQUFJLEVBQUUsR0FBRyxDQUFiLEVBQWdCLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBMUIsRUFBa0MsRUFBRSxFQUFwQyxFQUF3QztBQUN0QyxVQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRCxDQUFoQjs7QUFDQSxVQUFHLEdBQUcsS0FBSyxLQUFYLEVBQWtCO0FBQ2hCLFFBQUEsT0FBTyxDQUFDLEdBQUQsQ0FBUCxHQUFlLGdCQUFnQixDQUFDLE1BQUQsRUFBUyxPQUFPLENBQUMsR0FBRCxDQUFoQixDQUEvQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPLE9BQVA7QUFDRDs7O0FDbGNELGEsQ0FFQTs7Ozs7Ozs7QUFDQSxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsU0FBRCxDQUF2Qjs7QUFFQSxJQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsS0FBRCxDQUFsQjtBQUNBLElBQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFELENBQXJCO0FBQ0EsSUFBTSxpQkFBaUIsR0FBRyxNQUFNLENBQUMsa0JBQUQsQ0FBaEM7QUFDQSxJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsWUFBRCxDQUExQjtBQUNBLElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxRQUFELENBQXRCO0FBQ0EsSUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLFNBQUQsQ0FBdEI7QUFDQSxJQUFNLGlCQUFpQixHQUFHLE1BQU0sQ0FBQyxnQkFBRCxDQUFoQztBQUNBLElBQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFELENBQXZCO0FBQ0EsSUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLE9BQUQsQ0FBcEI7QUFDQSxJQUFNLGlCQUFpQixHQUFHLE1BQU0sQ0FBQyxnQkFBRCxDQUFoQzs7QUFFQSxJQUFNLFdBQVcsR0FBRyxTQUFkLFdBQWM7QUFBQSxTQUFNLENBQU47QUFBQSxDQUFwQixDLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0lBQ00sUTtBQUNKLG9CQUFhLE9BQWIsRUFBc0I7QUFBQTtBQUNwQixRQUFJLE9BQU8sT0FBUCxLQUFtQixRQUF2QixFQUNFLE9BQU8sR0FBRztBQUFFLE1BQUEsR0FBRyxFQUFFO0FBQVAsS0FBVjtBQUVGLFFBQUksQ0FBQyxPQUFMLEVBQ0UsT0FBTyxHQUFHLEVBQVY7QUFFRixRQUFJLE9BQU8sQ0FBQyxHQUFSLEtBQWdCLE9BQU8sT0FBTyxDQUFDLEdBQWYsS0FBdUIsUUFBdkIsSUFBbUMsT0FBTyxDQUFDLEdBQVIsR0FBYyxDQUFqRSxDQUFKLEVBQ0UsTUFBTSxJQUFJLFNBQUosQ0FBYyxtQ0FBZCxDQUFOLENBUmtCLENBU3BCOztBQUNBLFFBQU0sR0FBRyxHQUFHLEtBQUssR0FBTCxJQUFZLE9BQU8sQ0FBQyxHQUFSLElBQWUsUUFBdkM7QUFFQSxRQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsTUFBUixJQUFrQixXQUE3QjtBQUNBLFNBQUssaUJBQUwsSUFBMkIsT0FBTyxFQUFQLEtBQWMsVUFBZixHQUE2QixXQUE3QixHQUEyQyxFQUFyRTtBQUNBLFNBQUssV0FBTCxJQUFvQixPQUFPLENBQUMsS0FBUixJQUFpQixLQUFyQztBQUNBLFFBQUksT0FBTyxDQUFDLE1BQVIsSUFBa0IsT0FBTyxPQUFPLENBQUMsTUFBZixLQUEwQixRQUFoRCxFQUNFLE1BQU0sSUFBSSxTQUFKLENBQWMseUJBQWQsQ0FBTjtBQUNGLFNBQUssT0FBTCxJQUFnQixPQUFPLENBQUMsTUFBUixJQUFrQixDQUFsQztBQUNBLFNBQUssT0FBTCxJQUFnQixPQUFPLENBQUMsT0FBeEI7QUFDQSxTQUFLLGlCQUFMLElBQTBCLE9BQU8sQ0FBQyxjQUFSLElBQTBCLEtBQXBEO0FBQ0EsU0FBSyxpQkFBTCxJQUEwQixPQUFPLENBQUMsY0FBUixJQUEwQixLQUFwRDtBQUNBLFNBQUssS0FBTDtBQUNELEcsQ0FFRDs7Ozs7NkJBa0RVLEUsRUFBSSxLLEVBQU87QUFDbkIsTUFBQSxLQUFLLEdBQUcsS0FBSyxJQUFJLElBQWpCOztBQUNBLFdBQUssSUFBSSxNQUFNLEdBQUcsS0FBSyxRQUFMLEVBQWUsSUFBakMsRUFBdUMsTUFBTSxLQUFLLElBQWxELEdBQXlEO0FBQ3ZELFlBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFwQjtBQUNBLFFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTyxFQUFQLEVBQVcsTUFBWCxFQUFtQixLQUFuQixDQUFYO0FBQ0EsUUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNEO0FBQ0Y7Ozs0QkFFUSxFLEVBQUksSyxFQUFPO0FBQ2xCLE1BQUEsS0FBSyxHQUFHLEtBQUssSUFBSSxJQUFqQjs7QUFDQSxXQUFLLElBQUksTUFBTSxHQUFHLEtBQUssUUFBTCxFQUFlLElBQWpDLEVBQXVDLE1BQU0sS0FBSyxJQUFsRCxHQUF5RDtBQUN2RCxZQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBcEI7QUFDQSxRQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU8sRUFBUCxFQUFXLE1BQVgsRUFBbUIsS0FBbkIsQ0FBWDtBQUNBLFFBQUEsTUFBTSxHQUFHLElBQVQ7QUFDRDtBQUNGOzs7MkJBRU87QUFDTixhQUFPLEtBQUssUUFBTCxFQUFlLE9BQWYsR0FBeUIsR0FBekIsQ0FBNkIsVUFBQSxDQUFDO0FBQUEsZUFBSSxDQUFDLENBQUMsR0FBTjtBQUFBLE9BQTlCLENBQVA7QUFDRDs7OzZCQUVTO0FBQ1IsYUFBTyxLQUFLLFFBQUwsRUFBZSxPQUFmLEdBQXlCLEdBQXpCLENBQTZCLFVBQUEsQ0FBQztBQUFBLGVBQUksQ0FBQyxDQUFDLEtBQU47QUFBQSxPQUE5QixDQUFQO0FBQ0Q7Ozs0QkFFUTtBQUFBOztBQUNQLFVBQUksS0FBSyxPQUFMLEtBQ0EsS0FBSyxRQUFMLENBREEsSUFFQSxLQUFLLFFBQUwsRUFBZSxNQUZuQixFQUUyQjtBQUN6QixhQUFLLFFBQUwsRUFBZSxPQUFmLENBQXVCLFVBQUEsR0FBRztBQUFBLGlCQUFJLEtBQUksQ0FBQyxPQUFELENBQUosQ0FBYyxHQUFHLENBQUMsR0FBbEIsRUFBdUIsR0FBRyxDQUFDLEtBQTNCLENBQUo7QUFBQSxTQUExQjtBQUNEOztBQUVELFdBQUssS0FBTCxJQUFjLElBQUksR0FBSixFQUFkLENBUE8sQ0FPaUI7O0FBQ3hCLFdBQUssUUFBTCxJQUFpQixJQUFJLE9BQUosRUFBakIsQ0FSTyxDQVF3Qjs7QUFDL0IsV0FBSyxNQUFMLElBQWUsQ0FBZixDQVRPLENBU1U7QUFDbEI7OzsyQkFFTztBQUFBOztBQUNOLGFBQU8sS0FBSyxRQUFMLEVBQWUsR0FBZixDQUFtQixVQUFBLEdBQUc7QUFBQSxlQUMzQixPQUFPLENBQUMsTUFBRCxFQUFPLEdBQVAsQ0FBUCxHQUFxQixLQUFyQixHQUE2QjtBQUMzQixVQUFBLENBQUMsRUFBRSxHQUFHLENBQUMsR0FEb0I7QUFFM0IsVUFBQSxDQUFDLEVBQUUsR0FBRyxDQUFDLEtBRm9CO0FBRzNCLFVBQUEsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFKLElBQVcsR0FBRyxDQUFDLE1BQUosSUFBYyxDQUF6QjtBQUh3QixTQURGO0FBQUEsT0FBdEIsRUFLRixPQUxFLEdBS1EsTUFMUixDQUtlLFVBQUEsQ0FBQztBQUFBLGVBQUksQ0FBSjtBQUFBLE9BTGhCLENBQVA7QUFNRDs7OzhCQUVVO0FBQ1QsYUFBTyxLQUFLLFFBQUwsQ0FBUDtBQUNEOzs7d0JBRUksRyxFQUFLLEssRUFBTyxNLEVBQVE7QUFDdkIsTUFBQSxNQUFNLEdBQUcsTUFBTSxJQUFJLEtBQUssT0FBTCxDQUFuQjtBQUVBLFVBQUksTUFBTSxJQUFJLE9BQU8sTUFBUCxLQUFrQixRQUFoQyxFQUNFLE1BQU0sSUFBSSxTQUFKLENBQWMseUJBQWQsQ0FBTjtBQUVGLFVBQU0sR0FBRyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBTCxFQUFILEdBQWdCLENBQWxDO0FBQ0EsVUFBTSxHQUFHLEdBQUcsS0FBSyxpQkFBTCxFQUF3QixLQUF4QixFQUErQixHQUEvQixDQUFaOztBQUVBLFVBQUksS0FBSyxLQUFMLEVBQVksR0FBWixDQUFnQixHQUFoQixDQUFKLEVBQTBCO0FBQ3hCLFlBQUksR0FBRyxHQUFHLEtBQUssR0FBTCxDQUFWLEVBQXFCO0FBQ25CLFVBQUEsSUFBRyxDQUFDLElBQUQsRUFBTyxLQUFLLEtBQUwsRUFBWSxHQUFaLENBQWdCLEdBQWhCLENBQVAsQ0FBSDs7QUFDQSxpQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsWUFBTSxJQUFJLEdBQUcsS0FBSyxLQUFMLEVBQVksR0FBWixDQUFnQixHQUFoQixDQUFiO0FBQ0EsWUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQWxCLENBUHdCLENBU3hCO0FBQ0E7O0FBQ0EsWUFBSSxLQUFLLE9BQUwsQ0FBSixFQUFtQjtBQUNqQixjQUFJLENBQUMsS0FBSyxpQkFBTCxDQUFMLEVBQ0UsS0FBSyxPQUFMLEVBQWMsR0FBZCxFQUFtQixJQUFJLENBQUMsS0FBeEI7QUFDSDs7QUFFRCxRQUFBLElBQUksQ0FBQyxHQUFMLEdBQVcsR0FBWDtBQUNBLFFBQUEsSUFBSSxDQUFDLE1BQUwsR0FBYyxNQUFkO0FBQ0EsUUFBQSxJQUFJLENBQUMsS0FBTCxHQUFhLEtBQWI7QUFDQSxhQUFLLE1BQUwsS0FBZ0IsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUEzQjtBQUNBLFFBQUEsSUFBSSxDQUFDLE1BQUwsR0FBYyxHQUFkO0FBQ0EsYUFBSyxHQUFMLENBQVMsR0FBVDtBQUNBLFFBQUEsSUFBSSxDQUFDLElBQUQsQ0FBSjtBQUNBLGVBQU8sSUFBUDtBQUNEOztBQUVELFVBQU0sR0FBRyxHQUFHLElBQUksS0FBSixDQUFVLEdBQVYsRUFBZSxLQUFmLEVBQXNCLEdBQXRCLEVBQTJCLEdBQTNCLEVBQWdDLE1BQWhDLENBQVosQ0FuQ3VCLENBcUN2Qjs7QUFDQSxVQUFJLEdBQUcsQ0FBQyxNQUFKLEdBQWEsS0FBSyxHQUFMLENBQWpCLEVBQTRCO0FBQzFCLFlBQUksS0FBSyxPQUFMLENBQUosRUFDRSxLQUFLLE9BQUwsRUFBYyxHQUFkLEVBQW1CLEtBQW5CO0FBRUYsZUFBTyxLQUFQO0FBQ0Q7O0FBRUQsV0FBSyxNQUFMLEtBQWdCLEdBQUcsQ0FBQyxNQUFwQjtBQUNBLFdBQUssUUFBTCxFQUFlLE9BQWYsQ0FBdUIsR0FBdkI7QUFDQSxXQUFLLEtBQUwsRUFBWSxHQUFaLENBQWdCLEdBQWhCLEVBQXFCLEtBQUssUUFBTCxFQUFlLElBQXBDO0FBQ0EsTUFBQSxJQUFJLENBQUMsSUFBRCxDQUFKO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7Ozt3QkFFSSxHLEVBQUs7QUFDUixVQUFJLENBQUMsS0FBSyxLQUFMLEVBQVksR0FBWixDQUFnQixHQUFoQixDQUFMLEVBQTJCLE9BQU8sS0FBUDtBQUMzQixVQUFNLEdBQUcsR0FBRyxLQUFLLEtBQUwsRUFBWSxHQUFaLENBQWdCLEdBQWhCLEVBQXFCLEtBQWpDO0FBQ0EsYUFBTyxDQUFDLE9BQU8sQ0FBQyxJQUFELEVBQU8sR0FBUCxDQUFmO0FBQ0Q7Ozt3QkFFSSxHLEVBQUs7QUFDUixhQUFPLElBQUcsQ0FBQyxJQUFELEVBQU8sR0FBUCxFQUFZLElBQVosQ0FBVjtBQUNEOzs7eUJBRUssRyxFQUFLO0FBQ1QsYUFBTyxJQUFHLENBQUMsSUFBRCxFQUFPLEdBQVAsRUFBWSxLQUFaLENBQVY7QUFDRDs7OzBCQUVNO0FBQ0wsVUFBTSxJQUFJLEdBQUcsS0FBSyxRQUFMLEVBQWUsSUFBNUI7QUFDQSxVQUFJLENBQUMsSUFBTCxFQUNFLE9BQU8sSUFBUDs7QUFFRixNQUFBLElBQUcsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFIOztBQUNBLGFBQU8sSUFBSSxDQUFDLEtBQVo7QUFDRDs7O3dCQUVJLEcsRUFBSztBQUNSLE1BQUEsSUFBRyxDQUFDLElBQUQsRUFBTyxLQUFLLEtBQUwsRUFBWSxHQUFaLENBQWdCLEdBQWhCLENBQVAsQ0FBSDtBQUNEOzs7eUJBRUssRyxFQUFLO0FBQ1Q7QUFDQSxXQUFLLEtBQUw7QUFFQSxVQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBTCxFQUFaLENBSlMsQ0FLVDs7QUFDQSxXQUFLLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFKLEdBQWEsQ0FBMUIsRUFBNkIsQ0FBQyxJQUFJLENBQWxDLEVBQXFDLENBQUMsRUFBdEMsRUFBMEM7QUFDeEMsWUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUQsQ0FBZjtBQUNBLFlBQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxDQUFKLElBQVMsQ0FBM0I7QUFDQSxZQUFJLFNBQVMsS0FBSyxDQUFsQixFQUNFO0FBQ0EsZUFBSyxHQUFMLENBQVMsR0FBRyxDQUFDLENBQWIsRUFBZ0IsR0FBRyxDQUFDLENBQXBCLEVBRkYsS0FHSztBQUNILGNBQU0sTUFBTSxHQUFHLFNBQVMsR0FBRyxHQUEzQixDQURHLENBRUg7O0FBQ0EsY0FBSSxNQUFNLEdBQUcsQ0FBYixFQUFnQjtBQUNkLGlCQUFLLEdBQUwsQ0FBUyxHQUFHLENBQUMsQ0FBYixFQUFnQixHQUFHLENBQUMsQ0FBcEIsRUFBdUIsTUFBdkI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7OzRCQUVRO0FBQUE7O0FBQ1AsV0FBSyxLQUFMLEVBQVksT0FBWixDQUFvQixVQUFDLEtBQUQsRUFBUSxHQUFSO0FBQUEsZUFBZ0IsSUFBRyxDQUFDLE1BQUQsRUFBTyxHQUFQLEVBQVksS0FBWixDQUFuQjtBQUFBLE9BQXBCO0FBQ0Q7OztzQkEzTVEsRSxFQUFJO0FBQ1gsVUFBSSxPQUFPLEVBQVAsS0FBYyxRQUFkLElBQTBCLEVBQUUsR0FBRyxDQUFuQyxFQUNFLE1BQU0sSUFBSSxTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUVGLFdBQUssR0FBTCxJQUFZLEVBQUUsSUFBSSxRQUFsQjtBQUNBLE1BQUEsSUFBSSxDQUFDLElBQUQsQ0FBSjtBQUNELEs7d0JBQ1U7QUFDVCxhQUFPLEtBQUssR0FBTCxDQUFQO0FBQ0Q7OztzQkFFZSxVLEVBQVk7QUFDMUIsV0FBSyxXQUFMLElBQW9CLENBQUMsQ0FBQyxVQUF0QjtBQUNELEs7d0JBQ2lCO0FBQ2hCLGFBQU8sS0FBSyxXQUFMLENBQVA7QUFDRDs7O3NCQUVXLEUsRUFBSTtBQUNkLFVBQUksT0FBTyxFQUFQLEtBQWMsUUFBbEIsRUFDRSxNQUFNLElBQUksU0FBSixDQUFjLHNDQUFkLENBQU47QUFFRixXQUFLLE9BQUwsSUFBZ0IsRUFBaEI7QUFDQSxNQUFBLElBQUksQ0FBQyxJQUFELENBQUo7QUFDRCxLO3dCQUNhO0FBQ1osYUFBTyxLQUFLLE9BQUwsQ0FBUDtBQUNELEssQ0FFRDs7OztzQkFDc0IsRSxFQUFJO0FBQUE7O0FBQ3hCLFVBQUksT0FBTyxFQUFQLEtBQWMsVUFBbEIsRUFDRSxFQUFFLEdBQUcsV0FBTDs7QUFFRixVQUFJLEVBQUUsS0FBSyxLQUFLLGlCQUFMLENBQVgsRUFBb0M7QUFDbEMsYUFBSyxpQkFBTCxJQUEwQixFQUExQjtBQUNBLGFBQUssTUFBTCxJQUFlLENBQWY7QUFDQSxhQUFLLFFBQUwsRUFBZSxPQUFmLENBQXVCLFVBQUEsR0FBRyxFQUFJO0FBQzVCLFVBQUEsR0FBRyxDQUFDLE1BQUosR0FBYSxNQUFJLENBQUMsaUJBQUQsQ0FBSixDQUF3QixHQUFHLENBQUMsS0FBNUIsRUFBbUMsR0FBRyxDQUFDLEdBQXZDLENBQWI7QUFDQSxVQUFBLE1BQUksQ0FBQyxNQUFELENBQUosSUFBZ0IsR0FBRyxDQUFDLE1BQXBCO0FBQ0QsU0FIRDtBQUlEOztBQUNELE1BQUEsSUFBSSxDQUFDLElBQUQsQ0FBSjtBQUNELEs7d0JBQ3VCO0FBQUUsYUFBTyxLQUFLLGlCQUFMLENBQVA7QUFBZ0M7Ozt3QkFFNUM7QUFBRSxhQUFPLEtBQUssTUFBTCxDQUFQO0FBQXFCOzs7d0JBQ3BCO0FBQUUsYUFBTyxLQUFLLFFBQUwsRUFBZSxNQUF0QjtBQUE4Qjs7Ozs7QUErSm5ELElBQU0sSUFBRyxHQUFHLFNBQU4sSUFBTSxDQUFDLElBQUQsRUFBTyxHQUFQLEVBQVksS0FBWixFQUFzQjtBQUNoQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBRCxDQUFKLENBQVksR0FBWixDQUFnQixHQUFoQixDQUFiOztBQUNBLE1BQUksSUFBSixFQUFVO0FBQ1IsUUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQWpCOztBQUNBLFFBQUksT0FBTyxDQUFDLElBQUQsRUFBTyxHQUFQLENBQVgsRUFBd0I7QUFDdEIsTUFBQSxJQUFHLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBSDs7QUFDQSxVQUFJLENBQUMsSUFBSSxDQUFDLFdBQUQsQ0FBVCxFQUNFLE9BQU8sU0FBUDtBQUNILEtBSkQsTUFJTztBQUNMLFVBQUksS0FBSixFQUFXO0FBQ1QsWUFBSSxJQUFJLENBQUMsaUJBQUQsQ0FBUixFQUNFLElBQUksQ0FBQyxLQUFMLENBQVcsR0FBWCxHQUFpQixJQUFJLENBQUMsR0FBTCxFQUFqQjtBQUNGLFFBQUEsSUFBSSxDQUFDLFFBQUQsQ0FBSixDQUFlLFdBQWYsQ0FBMkIsSUFBM0I7QUFDRDtBQUNGOztBQUNELFdBQU8sR0FBRyxDQUFDLEtBQVg7QUFDRDtBQUNGLENBakJEOztBQW1CQSxJQUFNLE9BQU8sR0FBRyxTQUFWLE9BQVUsQ0FBQyxJQUFELEVBQU8sR0FBUCxFQUFlO0FBQzdCLE1BQUksQ0FBQyxHQUFELElBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTCxJQUFlLENBQUMsSUFBSSxDQUFDLE9BQUQsQ0FBakMsRUFDRSxPQUFPLEtBQVA7QUFFRixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsR0FBTCxLQUFhLEdBQUcsQ0FBQyxHQUE5QjtBQUNBLFNBQU8sR0FBRyxDQUFDLE1BQUosR0FBYSxJQUFJLEdBQUcsR0FBRyxDQUFDLE1BQXhCLEdBQ0gsSUFBSSxDQUFDLE9BQUQsQ0FBSixJQUFrQixJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQUQsQ0FEakM7QUFFRCxDQVBEOztBQVNBLElBQU0sSUFBSSxHQUFHLFNBQVAsSUFBTyxDQUFBLElBQUksRUFBSTtBQUNuQixNQUFJLElBQUksQ0FBQyxNQUFELENBQUosR0FBZSxJQUFJLENBQUMsR0FBRCxDQUF2QixFQUE4QjtBQUM1QixTQUFLLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFELENBQUosQ0FBZSxJQUFqQyxFQUNFLElBQUksQ0FBQyxNQUFELENBQUosR0FBZSxJQUFJLENBQUMsR0FBRCxDQUFuQixJQUE0QixNQUFNLEtBQUssSUFEekMsR0FDZ0Q7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsVUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQXBCOztBQUNBLE1BQUEsSUFBRyxDQUFDLElBQUQsRUFBTyxNQUFQLENBQUg7O0FBQ0EsTUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNEO0FBQ0Y7QUFDRixDQVpEOztBQWNBLElBQU0sSUFBRyxHQUFHLFNBQU4sSUFBTSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWdCO0FBQzFCLE1BQUksSUFBSixFQUFVO0FBQ1IsUUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQWpCO0FBQ0EsUUFBSSxJQUFJLENBQUMsT0FBRCxDQUFSLEVBQ0UsSUFBSSxDQUFDLE9BQUQsQ0FBSixDQUFjLEdBQUcsQ0FBQyxHQUFsQixFQUF1QixHQUFHLENBQUMsS0FBM0I7QUFFRixJQUFBLElBQUksQ0FBQyxNQUFELENBQUosSUFBZ0IsR0FBRyxDQUFDLE1BQXBCO0FBQ0EsSUFBQSxJQUFJLENBQUMsS0FBRCxDQUFKLFdBQW1CLEdBQUcsQ0FBQyxHQUF2QjtBQUNBLElBQUEsSUFBSSxDQUFDLFFBQUQsQ0FBSixDQUFlLFVBQWYsQ0FBMEIsSUFBMUI7QUFDRDtBQUNGLENBVkQ7O0lBWU0sSyxHQUNKLGVBQWEsR0FBYixFQUFrQixLQUFsQixFQUF5QixNQUF6QixFQUFpQyxHQUFqQyxFQUFzQyxNQUF0QyxFQUE4QztBQUFBO0FBQzVDLE9BQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxPQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsT0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLE9BQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxPQUFLLE1BQUwsR0FBYyxNQUFNLElBQUksQ0FBeEI7QUFDRCxDOztBQUdILElBQU0sV0FBVyxHQUFHLFNBQWQsV0FBYyxDQUFDLElBQUQsRUFBTyxFQUFQLEVBQVcsSUFBWCxFQUFpQixLQUFqQixFQUEyQjtBQUM3QyxNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBZjs7QUFDQSxNQUFJLE9BQU8sQ0FBQyxJQUFELEVBQU8sR0FBUCxDQUFYLEVBQXdCO0FBQ3RCLElBQUEsSUFBRyxDQUFDLElBQUQsRUFBTyxJQUFQLENBQUg7O0FBQ0EsUUFBSSxDQUFDLElBQUksQ0FBQyxXQUFELENBQVQsRUFDRSxHQUFHLEdBQUcsU0FBTjtBQUNIOztBQUNELE1BQUksR0FBSixFQUNFLEVBQUUsQ0FBQyxJQUFILENBQVEsS0FBUixFQUFlLEdBQUcsQ0FBQyxLQUFuQixFQUEwQixHQUFHLENBQUMsR0FBOUIsRUFBbUMsSUFBbkM7QUFDSCxDQVREOztBQVdBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFFBQWpCOzs7QUM3VUE7O0FBQ0EsSUFBSSxlQUFlLEdBQUksVUFBUSxTQUFLLGVBQWQsS0FBbUMsTUFBTSxDQUFDLE1BQVAsR0FBaUIsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsRUFBbEIsRUFBc0I7QUFDNUYsTUFBSSxFQUFFLEtBQUssU0FBWCxFQUFzQixFQUFFLEdBQUcsQ0FBTDtBQUN0QixFQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLENBQXRCLEVBQXlCLEVBQXpCLEVBQTZCO0FBQUUsSUFBQSxVQUFVLEVBQUUsSUFBZDtBQUFvQixJQUFBLEdBQUcsRUFBRSxlQUFXO0FBQUUsYUFBTyxDQUFDLENBQUMsQ0FBRCxDQUFSO0FBQWM7QUFBcEQsR0FBN0I7QUFDSCxDQUh3RCxHQUduRCxVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixFQUFsQixFQUFzQjtBQUN4QixNQUFJLEVBQUUsS0FBSyxTQUFYLEVBQXNCLEVBQUUsR0FBRyxDQUFMO0FBQ3RCLEVBQUEsQ0FBQyxDQUFDLEVBQUQsQ0FBRCxHQUFRLENBQUMsQ0FBQyxDQUFELENBQVQ7QUFDSCxDQU5xQixDQUF0Qjs7QUFPQSxJQUFJLFlBQVksR0FBSSxVQUFRLFNBQUssWUFBZCxJQUErQixVQUFTLENBQVQsRUFBWSxPQUFaLEVBQXFCO0FBQ25FLE9BQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixRQUFJLENBQUMsS0FBSyxTQUFOLElBQW1CLENBQUMsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsY0FBakIsQ0FBZ0MsSUFBaEMsQ0FBcUMsT0FBckMsRUFBOEMsQ0FBOUMsQ0FBeEIsRUFBMEUsZUFBZSxDQUFDLE9BQUQsRUFBVSxDQUFWLEVBQWEsQ0FBYixDQUFmO0FBQTNGO0FBQ0gsQ0FGRDs7QUFHQSxNQUFNLENBQUMsY0FBUCxDQUFzQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFLEVBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQyw0Q0FBRCxDQUFSLEVBQXdELE9BQXhELENBQVo7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQyxrREFBRCxDQUFSLEVBQThELE9BQTlELENBQVo7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQyxpREFBRCxDQUFSLEVBQTZELE9BQTdELENBQVo7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQywrQ0FBRCxDQUFSLEVBQTJELE9BQTNELENBQVo7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQyw4Q0FBRCxDQUFSLEVBQTBELE9BQTFELENBQVo7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQywwQkFBRCxDQUFSLEVBQXNDLE9BQXRDLENBQVo7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQyxrQkFBRCxDQUFSLEVBQThCLE9BQTlCLENBQVo7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQyxzQkFBRCxDQUFSLEVBQWtDLE9BQWxDLENBQVo7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQywwQkFBRCxDQUFSLEVBQXNDLE9BQXRDLENBQVo7O0FBQ0EsWUFBWSxDQUFDLE9BQU8sQ0FBQyxZQUFELENBQVIsRUFBd0IsT0FBeEIsQ0FBWjs7O0FDckJBOztBQUNBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUUsRUFBQSxLQUFLLEVBQUU7QUFBVCxDQUE3Qzs7O0FDREE7O0FBQ0EsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRSxFQUFBLEtBQUssRUFBRTtBQUFULENBQTdDOzs7QUNEQTs7QUFDQSxNQUFNLENBQUMsY0FBUCxDQUFzQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFLEVBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7OztBQ0RBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUUsRUFBQSxLQUFLLEVBQUU7QUFBVCxDQUE3QztBQUNBLE9BQU8sQ0FBQyxrQkFBUixHQUE2QixLQUFLLENBQWxDOztBQUNBLElBQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFELENBQXhCOztBQUNBLElBQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxhQUFELENBQTdCOztBQUNBLElBQU0sNEJBQTRCLEdBQUcsT0FBTyxDQUFDLDhDQUFELENBQTVDOztBQUNBLElBQU0sMkJBQTJCLEdBQUcsT0FBTyxDQUFDLDZDQUFELENBQTNDOztBQUNBLElBQU0seUJBQXlCLEdBQUcsT0FBTyxDQUFDLDJDQUFELENBQXpDOztBQUNBLElBQU0sd0JBQXdCLEdBQUcsT0FBTyxDQUFDLDBDQUFELENBQXhDOztBQUNBLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFELENBQXRCOztBQUNBLElBQU0sc0JBQXNCLEdBQUcsT0FBTyxDQUFDLCtCQUFELENBQXRDO0FBQ0E7QUFDQTtBQUNBOzs7SUFDTSxrQjs7Ozs7QUFDRiw4QkFBWSxPQUFaLEVBQXFCO0FBQUE7O0FBQUE7QUFDakIsOEJBQU07QUFBRSxNQUFBLGtCQUFrQixFQUFFO0FBQXRCLEtBQU4sRUFEaUIsQ0FFakI7O0FBQ0EsVUFBSyxjQUFMLEdBQXNCLEVBQXRCO0FBQ0EsVUFBSyxlQUFMLEdBQXVCLEVBQXZCLENBSmlCLENBS2pCOztBQUNBLFVBQUssb0JBQUwsR0FBNEIsS0FBNUI7QUFDQSxVQUFLLHFCQUFMLEdBQTZCLEVBQTdCO0FBQ0EsVUFBSyw2QkFBTCxHQUFxQyxFQUFyQyxDQVJpQixDQVNqQjs7QUFDQSxVQUFLLDhCQUFMLEdBQXNDLEVBQXRDO0FBQ0EsSUFBQSxPQUFPLEdBQUcsT0FBTyxJQUFJLEVBQXJCO0FBQ0EsVUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLFVBQUssSUFBTCxHQUFZLElBQUksTUFBTSxDQUFDLElBQVgsQ0FBZ0IsT0FBTyxDQUFDLFdBQXhCLEVBQXFDLE9BQU8sQ0FBQyxPQUE3QyxDQUFaO0FBQ0EsVUFBSyxZQUFMLEdBQW9CLE9BQU8sQ0FBQyxZQUFSLElBQXdCLE1BQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsWUFBdEIsRUFBNUM7QUFDQSxVQUFLLGlCQUFMLEdBQXlCLE9BQU8sQ0FBQyxpQkFBakM7QUFDQSxVQUFLLGFBQUwsR0FBcUIsT0FBTyxDQUFDLGFBQVIsSUFBeUIsc0JBQTlDO0FBQ0EsVUFBSyxNQUFMLEdBQWMsTUFBSyxnQkFBTCxDQUFzQixDQUFDLENBQUMsT0FBTyxDQUFDLE9BQWhDLENBQWQ7QUFqQmlCO0FBa0JwQjtBQUNEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7Ozs7OzRCQUNXLE0sRUFBUTtBQUNYLFVBQU0sTUFBTSxHQUFHLElBQUksUUFBUSxDQUFDLFdBQWIsQ0FBeUI7QUFBRSxRQUFBLGtCQUFrQixFQUFFO0FBQXRCLE9BQXpCLENBQWY7QUFDQSxNQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsT0FBVixFQUFtQixVQUFDLEtBQUQ7QUFBQSxlQUFXLE1BQU0sQ0FBQyxJQUFQLENBQVksT0FBWixFQUFxQixLQUFyQixDQUFYO0FBQUEsT0FBbkI7QUFDQSxNQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsTUFBVixFQUFrQixVQUFDLElBQUQ7QUFBQSxlQUFVLE1BQU0sQ0FBQyxJQUFQLENBQVksSUFBWixDQUFWO0FBQUEsT0FBbEI7QUFDQSxNQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsS0FBVixFQUFpQjtBQUFBLGVBQU0sTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFaLENBQU47QUFBQSxPQUFqQjtBQUNBLFVBQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksSUFBSSxrQkFBSixDQUF1QixLQUFLLE9BQTVCLENBQVosQ0FBZjtBQUNBLGFBQU8sTUFBUDtBQUNIOzs7K0JBQ1UsSyxFQUFPLFEsRUFBVSxRLEVBQVU7QUFDbEMsV0FBSyxNQUFMLENBQVksS0FBWixDQUFrQixLQUFsQjtBQUNBLE1BQUEsUUFBUTtBQUNYOzs7MkJBQ00sUSxFQUFVO0FBQ2IsV0FBSyxNQUFMLENBQVksR0FBWjtBQUNBLE1BQUEsUUFBUTtBQUNYO0FBQ0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7OztpQ0FDaUIsTSxFQUFRO0FBQ2pCLFVBQUksVUFBVSxHQUFHLEtBQUssY0FBTCxDQUFvQixNQUFwQixJQUE4QixNQUFNLEdBQUcsQ0FBSCxHQUFPLENBQTNDLENBQWpCOztBQUNBLGFBQU8sVUFBVSxHQUFHLENBQWIsSUFBa0IsQ0FBQyxLQUFLLGNBQUwsQ0FBb0IsVUFBcEIsQ0FBMUIsRUFBMkQ7QUFDdkQsUUFBQSxVQUFVO0FBQ2I7O0FBQ0QsYUFBTyxLQUFLLGNBQUwsQ0FBb0IsVUFBcEIsQ0FBUDtBQUNIO0FBQ0Q7QUFDSjtBQUNBOzs7OytCQUNlO0FBQ1AsYUFBTyxLQUFLLGNBQUwsQ0FBb0IsTUFBM0I7QUFDSDs7OzhCQUNTLEksRUFBTSxVLEVBQVk7QUFDeEIsVUFBSSxDQUFDLEtBQUssb0JBQVYsRUFBZ0M7QUFDNUI7QUFDQSxZQUFJLFFBQVEsVUFBWixFQUF3QjtBQUNwQixjQUFNLEVBQUUsR0FBRyxVQUFVLENBQUMsRUFBdEI7QUFDQSxlQUFLLDhCQUFMLENBQW9DLEVBQXBDLElBQTBDO0FBQ3RDLFlBQUEsTUFBTSxFQUFFLEVBRDhCO0FBRXRDLFlBQUEsT0FBTyxFQUFFLENBRjZCO0FBR3RDLFlBQUEsR0FBRyxFQUFFO0FBSGlDLFdBQTFDO0FBS0gsU0FUMkIsQ0FVNUI7OztBQUNBLDBDQUFxQixNQUFNLENBQUMsTUFBUCxDQUFjLEtBQUssOEJBQW5CLENBQXJCLG9DQUF5RTtBQUFwRSxjQUFNLE1BQU0scUJBQVo7QUFDRCxVQUFBLE1BQU0sQ0FBQyxPQUFQO0FBQ0EsVUFBQSxNQUFNLENBQUMsTUFBUCxDQUFjLElBQWQsQ0FBbUI7QUFBRSxZQUFBLElBQUksRUFBRSxNQUFSO0FBQWdCLFlBQUEsSUFBSSxFQUFKLElBQWhCO0FBQXNCLFlBQUEsVUFBVSxFQUFWO0FBQXRCLFdBQW5CO0FBQ0g7QUFDSixPQWhCdUIsQ0FpQnhCO0FBQ0E7OztBQUNBLFdBQUssZUFBTCxDQUFxQixJQUFyQixDQUEwQixTQUExQixFQW5Cd0IsQ0FvQnhCO0FBQ0E7O0FBQ0EsVUFBSSxTQUFKOztBQUNBLFVBQUksZUFBZSxVQUFuQixFQUErQjtBQUMzQjtBQUNBLFlBQUksT0FBSjs7QUFDQSxZQUFJLEtBQUssc0NBQVQsRUFBaUQ7QUFDN0MsVUFBQSxPQUFPLEdBQUcsS0FBSyxzQ0FBTCxFQUFWO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsVUFBQSxPQUFPLEdBQUcsWUFBWSxVQUFaLElBQTBCLEtBQUssSUFBTCxDQUFVLGFBQVYsQ0FBd0IsVUFBVSxDQUFDLE1BQW5DLENBQTFCLElBQ04sS0FBSyxJQUFMLENBQVUsV0FBVixDQUFzQixTQUF0QixFQURKLENBREMsQ0FHRDs7QUFDQSw4Q0FBcUIsTUFBTSxDQUFDLE1BQVAsQ0FBYyxLQUFLLDhCQUFuQixDQUFyQix1Q0FBeUU7QUFBcEUsZ0JBQU0sT0FBTSx1QkFBWjs7QUFDRCxZQUFBLE9BQU0sQ0FBQyxHQUFQLENBQVcsSUFBWCxDQUFnQixPQUFoQjtBQUNIO0FBQ0o7O0FBQ0QsUUFBQSxTQUFTLEdBQUc7QUFBRSxVQUFBLE9BQU8sRUFBUDtBQUFGLFNBQVosQ0FkMkIsQ0FlM0I7O0FBQ0EsWUFBSSxLQUFLLG9CQUFULEVBQStCO0FBQzNCLFVBQUEsU0FBUyxDQUFDLGFBQVYsR0FBMEIsSUFBMUI7QUFDSCxTQWxCMEIsQ0FtQjNCOzs7QUFDQSxZQUFNLGVBQWUsR0FBRyxLQUFLLFlBQUwsRUFBeEI7O0FBQ0EsWUFBSSxlQUFlLElBQUksZUFBZSxDQUFDLEtBQXZDLEVBQThDO0FBQzFDLFVBQUEsU0FBUyxDQUFDLEtBQVYsR0FBa0IsZUFBZSxDQUFDLEtBQWxDO0FBQ0gsU0F2QjBCLENBd0IzQjs7O0FBQ0EsYUFBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLFNBQXpCO0FBQ0gsT0ExQkQsTUEyQks7QUFDRDtBQUNBLFFBQUEsU0FBUyxHQUFHLEtBQUssWUFBTCxFQUFaLENBRkMsQ0FHRDtBQUNBOztBQUNBLGFBQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixTQUF6QjtBQUNILE9BeER1QixDQXlEeEI7OztBQUNBLFVBQUksU0FBSixFQUFlO0FBQ1g7QUFDQSxZQUFJLGNBQWMsVUFBbEIsRUFBOEI7QUFBQSxxREFDUCxLQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLFVBQVUsQ0FBQyxRQUFyQyxFQUErQyxTQUEvQyxFQUEwRCxLQUExRCxDQURPO0FBQUE7O0FBQUE7QUFDMUIsZ0VBQXFGO0FBQUEsa0JBQTFFLElBQTBFOztBQUNqRjtBQUNBLGtCQUFJLENBQUMsU0FBUyxDQUFDLEtBQWYsRUFBc0I7QUFDbEI7QUFDQSxnQkFBQSxTQUFTLENBQUMsS0FBVixHQUFrQixLQUFLLElBQUwsQ0FBVSxXQUFWLENBQXNCLElBQUksQ0FBQyxLQUEzQixFQUFrQyxLQUFLLGFBQXZDLENBQWxCO0FBQ0gsZUFMZ0YsQ0FNakY7OztBQUNBLGtCQUFJLENBQUMsU0FBUyxDQUFDLGFBQWYsRUFBOEI7QUFDMUIscUJBQUssVUFBTCxDQUFnQixTQUFTLENBQUMsT0FBMUIsRUFBbUMsS0FBSyxJQUFMLENBQVUsV0FBVixDQUFzQixTQUF0QixXQUFtQyxNQUFNLENBQUMsSUFBUCxDQUFZLEdBQS9DLFVBQW5DLEVBQThGLElBQTlGO0FBQ0g7QUFDSjtBQVh5QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWTdCLFNBZFUsQ0FlWDs7O0FBQ0EsWUFBSSxVQUFVLFVBQWQsRUFBMEI7QUFDdEIsVUFBQSxTQUFTLENBQUMsUUFBVixHQUFxQixVQUFVLENBQUMsSUFBaEM7QUFDSDs7QUFDRCxZQUFJLGNBQWMsVUFBbEIsRUFBOEI7QUFDMUIsVUFBQSxTQUFTLENBQUMsUUFBVixHQUFxQixVQUFVLENBQUMsVUFBRCxDQUEvQjtBQUNILFNBckJVLENBc0JYOzs7QUFDQSxZQUFJLGVBQWUsVUFBbkIsRUFBK0I7QUFDM0I7QUFDQSxjQUFJLENBQUMsS0FBSyxvQkFBTixJQUE4QixhQUFhLFVBQS9DLEVBQTJEO0FBQUEsd0RBQy9CLFVBQVUsQ0FBQyxPQUFYLENBQW1CLEtBQW5CLENBQXlCLHNFQUF6QixDQUQrQjtBQUFBOztBQUFBO0FBQ3ZELHFFQUEwRDtBQUFBLG9CQUEvQyxTQUErQzs7QUFDdEQsb0JBQUksRUFBRSxTQUFTLElBQUksS0FBSyxxQkFBcEIsQ0FBSixFQUFnRDtBQUM1Qyx1QkFBSyxxQkFBTCxDQUEyQixTQUEzQixJQUF3QyxFQUF4QztBQUNIOztBQUNELHFCQUFLLHFCQUFMLENBQTJCLFNBQTNCLEVBQXNDLElBQXRDLENBQTJDLFNBQTNDO0FBQ0EscUJBQUssbUJBQUwsQ0FBeUIsU0FBekIsRUFBb0MsU0FBcEM7QUFDSDtBQVBzRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUTFEO0FBQ0o7QUFDSixPQTdGdUIsQ0E4RnhCOzs7QUFDQSxVQUFJLGNBQWMsVUFBbEIsRUFBOEI7QUFDMUIsYUFBSyxvQkFBTCxDQUEwQixVQUFVLENBQUMsUUFBckMsRUFBK0MsS0FBL0MsRUFBc0QsU0FBdEQsRUFBaUUsSUFBakUsRUFBdUUsVUFBdkU7QUFDSCxPQWpHdUIsQ0FrR3hCO0FBQ0E7OztBQUNBLFVBQUksc0JBQXNCLFVBQTFCLEVBQXNDO0FBQ2xDLGFBQUssb0JBQUwsQ0FBMEIsVUFBVSxDQUFDLGtCQUFELENBQXBDLEVBQTBELElBQTFELEVBQWdFLFNBQWhFLEVBQTJFLElBQTNFLEVBQWlGLFVBQWpGO0FBQ0g7QUFDSjs7OzJCQUNNLEksRUFBTTtBQUNUO0FBQ0EsVUFBSSxDQUFDLEtBQUssb0JBQVYsRUFBZ0M7QUFDNUIsNENBQXFCLE1BQU0sQ0FBQyxNQUFQLENBQWMsS0FBSyw4QkFBbkIsQ0FBckIsdUNBQXlFO0FBQXBFLGNBQU0sTUFBTSx1QkFBWjtBQUNELFVBQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLENBQW1CO0FBQUUsWUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixZQUFBLElBQUksRUFBSjtBQUFoQixXQUFuQjtBQUNIO0FBQ0osT0FOUSxDQU9UOzs7QUFQUyxrREFRZ0IsS0FBSyxlQVJyQjtBQUFBOztBQUFBO0FBUVQsK0RBQStDO0FBQUEsY0FBcEMsVUFBb0M7O0FBQzNDLGNBQUksVUFBSixFQUFnQjtBQUNaLFlBQUEsVUFBVSxDQUFDLElBQVgsQ0FBZ0IsSUFBaEI7QUFDSDtBQUNKO0FBWlE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWFaOzs7aUNBQ1k7QUFDVDtBQUNBLFVBQUksQ0FBQyxLQUFLLG9CQUFWLEVBQWdDO0FBQzVCLDRDQUFrQyxNQUFNLENBQUMsT0FBUCxDQUFlLEtBQUssOEJBQXBCLENBQWxDLHVDQUF1RjtBQUFBO0FBQUEsY0FBM0UsU0FBMkU7QUFBQSxjQUFoRSxNQUFnRTs7QUFDbkYsVUFBQSxNQUFNLENBQUMsT0FBUDtBQUNBLFVBQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLENBQW1CO0FBQUUsWUFBQSxJQUFJLEVBQUU7QUFBUixXQUFuQixFQUZtRixDQUduRjs7QUFDQSxjQUFJLE1BQU0sQ0FBQyxPQUFQLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3RCLGlCQUFLLDZCQUFMLENBQW1DLFNBQW5DLElBQWdELE1BQWhEO0FBQ0EsbUJBQU8sS0FBSyw4QkFBTCxDQUFvQyxTQUFwQyxDQUFQLENBRnNCLENBR3RCOztBQUNBLGlCQUFLLG1CQUFMLENBQXlCLFNBQXpCO0FBQ0g7QUFDSjtBQUNKLE9BZFEsQ0FlVDs7O0FBQ0EsVUFBTSxTQUFTLEdBQUcsS0FBSyxZQUFMLENBQWtCLElBQWxCLENBQWxCOztBQUNBLFVBQUksU0FBSixFQUFlO0FBQ1gsWUFBTSxLQUFLLEdBQUcsS0FBSyxRQUFMLEVBQWQ7O0FBQ0EsWUFBSSxTQUFTLENBQUMsVUFBVixJQUF3QixLQUFLLElBQUksU0FBUyxDQUFDLFVBQS9DLEVBQTJEO0FBQ3ZELCtDQUF5QyxNQUFNLENBQUMsT0FBUCxDQUFlLFNBQVMsQ0FBQyxVQUFWLENBQXFCLEtBQXJCLENBQWYsQ0FBekMsd0NBQXNGO0FBQUE7QUFBQSxnQkFBMUUsWUFBMEU7QUFBQSxnQkFBNUQsVUFBNEQ7O0FBQ2xGO0FBQ0E7QUFDQSxnQkFBTSxNQUFNLEdBQUcsS0FBSyxJQUFMLENBQVUsYUFBVixDQUF3QixLQUFLLGVBQUwsQ0FBcUIsS0FBckIsRUFBNEIsSUFBNUIsQ0FBaUMsRUFBakMsQ0FBeEIsRUFBOEQsU0FBOUQsQ0FBZjtBQUNBLGlCQUFLLG9CQUFMLENBQTBCLFNBQTFCLEVBQXFDLFVBQXJDLEVBQWlELE1BQWpELEVBQXlELFlBQVksS0FBSyxTQUExRTtBQUNBLG1CQUFPLFNBQVMsQ0FBQyxVQUFWLENBQXFCLEtBQXJCLEVBQTRCLFlBQTVCLENBQVA7QUFDSDtBQUNKO0FBQ0osT0E1QlEsQ0E2QlQ7OztBQUNBLFdBQUssY0FBTCxDQUFvQixHQUFwQjtBQUNBLFdBQUssZUFBTCxDQUFxQixHQUFyQjtBQUNIOzs7NEJBQ08sQ0FDSjtBQUNIO0FBQ0Q7QUFDSjtBQUNBO0FBQ0E7Ozs7cUNBQ3FCLE8sRUFBUztBQUFBOztBQUN0QixhQUFPLElBQUksYUFBYSxDQUFDLE1BQWxCLENBQXlCO0FBQzVCLFFBQUEsVUFBVSxFQUFFLHNCQUFNO0FBQ2QsY0FBSTtBQUNBLFlBQUEsTUFBSSxDQUFDLFVBQUw7O0FBQ0EsZ0JBQUksTUFBSSxDQUFDLGlCQUFULEVBQTRCO0FBQ3hCLGNBQUEsTUFBSSxDQUFDLGlCQUFMLENBQXVCLFVBQXZCO0FBQ0g7QUFDSixXQUxELENBTUEsT0FBTyxLQUFQLEVBQWM7QUFDVixZQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixFQUFtQixLQUFuQjtBQUNIO0FBQ0osU0FYMkI7QUFZNUIsUUFBQSxLQUFLLEVBQUUsaUJBQU07QUFDVCxjQUFJO0FBQ0EsWUFBQSxNQUFJLENBQUMsS0FBTDs7QUFDQSxnQkFBSSxNQUFJLENBQUMsaUJBQVQsRUFBNEI7QUFDeEIsY0FBQSxNQUFJLENBQUMsaUJBQUwsQ0FBdUIsS0FBdkI7QUFDSDtBQUNKLFdBTEQsQ0FNQSxPQUFPLEtBQVAsRUFBYztBQUNWLFlBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLEVBQW1CLEtBQW5CO0FBQ0g7QUFDSixTQXRCMkI7QUF1QjVCLFFBQUEsU0FBUyxFQUFFLG1CQUFDLElBQUQsRUFBTyxVQUFQLEVBQXNCO0FBQzdCLGNBQUk7QUFDQSxZQUFBLE1BQUksQ0FBQyxTQUFMLENBQWUsSUFBZixFQUFxQixVQUFyQjs7QUFDQSxnQkFBSSxNQUFJLENBQUMsaUJBQVQsRUFBNEI7QUFDeEIsY0FBQSxNQUFJLENBQUMsaUJBQUwsQ0FBdUIsU0FBdkIsQ0FBaUMsSUFBakMsRUFBdUMsVUFBdkM7QUFDSDtBQUNKLFdBTEQsQ0FNQSxPQUFPLEtBQVAsRUFBYztBQUNWLFlBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLEVBQW1CLEtBQW5CO0FBQ0g7QUFDSixTQWpDMkI7QUFrQzVCLFFBQUEsTUFBTSxFQUFFLGdCQUFDLElBQUQsRUFBVTtBQUNkLGNBQUk7QUFDQSxZQUFBLE1BQUksQ0FBQyxNQUFMLENBQVksSUFBWjs7QUFDQSxnQkFBSSxNQUFJLENBQUMsaUJBQVQsRUFBNEI7QUFDeEIsY0FBQSxNQUFJLENBQUMsaUJBQUwsQ0FBdUIsTUFBdkIsQ0FBOEIsSUFBOUI7QUFDSDtBQUNKLFdBTEQsQ0FNQSxPQUFPLEtBQVAsRUFBYztBQUNWLFlBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLEVBQW1CLEtBQW5CO0FBQ0g7QUFDSjtBQTVDMkIsT0FBekIsRUE2Q0o7QUFDQyxRQUFBLGNBQWMsRUFBRSxJQURqQjtBQUVDLFFBQUEsb0JBQW9CLEVBQUUsSUFGdkI7QUFHQyxRQUFBLE9BQU8sRUFBUDtBQUhELE9BN0NJLENBQVA7QUFrREg7QUFDRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3lDQUN5QixhLEVBQWUsTyxFQUFTLFMsRUFBVyxPLEVBQVMsYSxFQUFlO0FBQzVFLFVBQU0sZUFBZSxHQUFHLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF4Qjs7QUFDQSxVQUFJLGVBQUosRUFBcUI7QUFDakI7QUFDQSxZQUFNLEtBQUssR0FBRyxLQUFLLFFBQUwsRUFBZDtBQUNBLFlBQU0sVUFBVSxHQUFHLEtBQUssSUFBTCxDQUFVLGVBQVYsQ0FBMEIsYUFBMUIsRUFBeUMsZUFBekMsRUFBMEQsSUFBMUQsQ0FBbkI7O0FBQ0EsWUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFyQixFQUFpQztBQUM3QixVQUFBLGVBQWUsQ0FBQyxVQUFoQixHQUE2QixFQUE3QjtBQUNIOztBQUNELFlBQUksQ0FBQyxlQUFlLENBQUMsVUFBaEIsQ0FBMkIsS0FBM0IsQ0FBTCxFQUF3QztBQUNwQyxVQUFBLGVBQWUsQ0FBQyxVQUFoQixDQUEyQixLQUEzQixJQUFvQyxFQUFwQztBQUNIOztBQUNELFlBQU0sYUFBYSxHQUFHLE9BQU8sR0FBRyxTQUFILEdBQWUsU0FBNUM7QUFDQSxRQUFBLGVBQWUsQ0FBQyxVQUFoQixDQUEyQixLQUEzQixFQUFrQyxhQUFsQyxJQUFtRCxVQUFuRCxDQVhpQixDQVlqQjs7QUFaaUIsb0RBYXFCLEtBQUssSUFBTCxDQUFVLDBCQUFWLENBQXFDLGFBQXJDLEVBQW9ELGVBQXBELEVBQXFFLEtBQUssYUFBMUUsQ0FickI7QUFBQTs7QUFBQTtBQWFqQixpRUFBZ0k7QUFBQSxnQkFBckgsdUJBQXFIO0FBQzVILFlBQUEsVUFBVSxDQUFDLElBQVgsQ0FBZ0IsdUJBQWhCO0FBQ0gsV0FmZ0IsQ0FnQmpCO0FBQ0E7O0FBakJpQjtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWtCakIsWUFBSSxTQUFTLElBQUksZUFBZSxhQUFoQyxFQUErQztBQUMzQyxlQUFLLG9CQUFMLENBQTBCLGVBQTFCLEVBQTJDLFVBQTNDLEVBQXVELFNBQVMsQ0FBQyxPQUFqRSxFQUEwRSxPQUExRSxFQUQyQyxDQUUzQzs7QUFDQSxpQkFBTyxlQUFlLENBQUMsVUFBaEIsQ0FBMkIsS0FBM0IsRUFBa0MsYUFBbEMsQ0FBUDtBQUNILFNBSkQsTUFLSztBQUFBLHNEQUNxQixrQkFBa0IsQ0FBQyxzQkFEeEM7QUFBQTs7QUFBQTtBQUNELG1FQUFpRTtBQUFBLGtCQUF0RCxPQUFzRDs7QUFDN0Qsa0JBQUksT0FBTyxDQUFDLFNBQVIsQ0FBa0IsT0FBbEIsRUFBMkIsYUFBM0IsQ0FBSixFQUErQztBQUMzQyxvQkFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFNBQVIsQ0FBa0IsYUFBbEIsRUFBaUMsS0FBSyxJQUF0QyxFQUE0QyxlQUE1QyxDQUFmO0FBQ0EscUJBQUssb0JBQUwsQ0FBMEIsZUFBMUIsRUFBMkMsVUFBM0MsRUFBdUQsTUFBdkQsRUFBK0QsT0FBL0QsRUFGMkMsQ0FHM0M7O0FBQ0EsdUJBQU8sZUFBZSxDQUFDLFVBQWhCLENBQTJCLEtBQTNCLEVBQWtDLGFBQWxDLENBQVA7QUFDSDtBQUNKO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVNKLFNBaENnQixDQWlDakI7OztBQUNBLFlBQUksZUFBZSxDQUFDLFVBQWhCLENBQTJCLEtBQTNCLEVBQWtDLGFBQWxDLENBQUosRUFBc0Q7QUFDbEQsZUFBSyxlQUFMLENBQXFCLEtBQXJCLElBQThCLEVBQTlCO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7eUNBQ3lCLFMsRUFBVyxVLEVBQVksTSxFQUFRLE8sRUFBUztBQUN6RCxVQUFJLENBQUMsU0FBUyxDQUFDLGFBQWYsRUFBOEI7QUFBQSxvREFDRixVQURFO0FBQUE7O0FBQUE7QUFDMUIsaUVBQW9DO0FBQUEsZ0JBQXpCLFNBQXlCOztBQUNoQyxnQkFBSSxPQUFKLEVBQWE7QUFDVDtBQUNBLGtCQUFJLE1BQU0sQ0FBQyxRQUFQLEtBQW9CLFNBQXhCLEVBQW1DO0FBQy9CLHFCQUFLLFVBQUwsQ0FBZ0IsTUFBaEIsRUFBd0IsU0FBeEIsRUFBbUMsU0FBUyxDQUFDLE9BQTdDO0FBQ0g7QUFDSixhQUxELE1BTUs7QUFDRCxtQkFBSyxVQUFMLENBQWdCLFNBQVMsQ0FBQyxPQUExQixFQUFtQyxTQUFuQyxFQUE4QyxNQUE5QztBQUNIO0FBQ0o7QUFYeUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVk3QjtBQUNKO0FBQ0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OytCQUNlLE8sRUFBUyxTLEVBQVcsTSxFQUFRO0FBQ25DLFdBQUssSUFBTCxDQUFVLEtBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsSUFBdEIsQ0FBMkIsT0FBM0IsRUFBb0MsU0FBcEMsRUFBK0MsTUFBL0MsRUFBdUQsS0FBSyxZQUE1RCxDQUFWO0FBQ0g7QUFDRDtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7O3dDQUN3QixTLEVBQVcsZSxFQUFpQjtBQUFBOztBQUM1QyxVQUFNLEtBQUssR0FBRyxLQUFLLDZCQUFMLENBQW1DLFNBQW5DLENBQWQ7O0FBQ0EsVUFBSSxLQUFKLEVBQVc7QUFDUDtBQUNBLFlBQUksb0JBQUo7O0FBQ0EsWUFBSSxlQUFKLEVBQXFCO0FBQ2pCLFVBQUEsb0JBQW9CLEdBQUcsQ0FBQyxlQUFELENBQXZCLENBRGlCLENBRWpCO0FBQ0E7O0FBQ0EsY0FBTSxvQkFBb0IsR0FBRyxLQUFLLHFCQUFMLENBQTJCLFNBQTNCLEVBQXNDLE9BQXRDLENBQThDLGVBQTlDLENBQTdCO0FBQ0EsZUFBSyxxQkFBTCxDQUEyQixTQUEzQixFQUFzQyxNQUF0QyxDQUE2QyxvQkFBN0MsRUFBbUUsQ0FBbkU7QUFDSCxTQU5ELE1BT0s7QUFDRCxVQUFBLG9CQUFvQixHQUFHLEtBQUsscUJBQUwsQ0FBMkIsU0FBM0IsQ0FBdkIsQ0FEQyxDQUVEOztBQUNBLGlCQUFPLEtBQUsscUJBQUwsQ0FBMkIsU0FBM0IsQ0FBUDtBQUNIOztBQUNELFlBQUksb0JBQUosRUFBMEI7QUFDdEI7QUFDQSxjQUFNLGlCQUFpQixHQUFHLEtBQUssY0FBL0I7QUFDQSxjQUFNLGtCQUFrQixHQUFHLEtBQUssZUFBaEM7QUFDQSxlQUFLLG9CQUFMLEdBQTRCLElBQTVCLENBSnNCLENBS3RCOztBQUxzQixzREFNRSxvQkFORjtBQUFBOztBQUFBO0FBQUE7QUFBQSxrQkFNWCxTQU5XO0FBT2xCLGNBQUEsTUFBSSxDQUFDLGNBQUwsR0FBc0IsQ0FBQyxTQUFELENBQXRCO0FBQ0EsY0FBQSxNQUFJLENBQUMsZUFBTCxHQUF1QixDQUFDLFNBQUQsQ0FBdkI7QUFDQSxrQkFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLEdBQU4sQ0FBVSxLQUFWLEVBQW5COztBQUNBLGNBQUEsTUFBSSxDQUFDLHNDQUFMLEdBQThDO0FBQUEsdUJBQU0sVUFBVSxDQUFDLEtBQVgsRUFBTjtBQUFBLGVBQTlDOztBQVZrQiwwREFXRSxLQUFLLENBQUMsTUFYUjtBQUFBOztBQUFBO0FBV2xCLHVFQUFrQztBQUFBLHNCQUF2QixLQUF1Qjs7QUFDOUIsMEJBQVEsS0FBSyxDQUFDLElBQWQ7QUFDSSx5QkFBSyxNQUFMO0FBQ0ksc0JBQUEsTUFBSSxDQUFDLFNBQUwsQ0FBZSxLQUFLLENBQUMsSUFBckIsRUFBMkIsS0FBSyxDQUFDLFVBQWpDOztBQUNBOztBQUNKLHlCQUFLLE1BQUw7QUFDSSxzQkFBQSxNQUFJLENBQUMsTUFBTCxDQUFZLEtBQUssQ0FBQyxJQUFsQjs7QUFDQTs7QUFDSix5QkFBSyxPQUFMO0FBQ0ksc0JBQUEsTUFBSSxDQUFDLFVBQUw7O0FBQ0E7QUFUUjtBQVdIO0FBdkJpQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTXRCLG1FQUE4QztBQUFBO0FBa0I3QyxhQXhCcUIsQ0F5QnRCOztBQXpCc0I7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEwQnRCLGVBQUssc0NBQUwsR0FBOEMsU0FBOUM7QUFDQSxlQUFLLGNBQUwsR0FBc0IsaUJBQXRCO0FBQ0EsZUFBSyxlQUFMLEdBQXVCLGtCQUF2QjtBQUNBLGVBQUssb0JBQUwsR0FBNEIsS0FBNUI7QUFDSDtBQUNKO0FBQ0o7OztFQW5aNEIsUUFBUSxDQUFDLFM7O0FBcVoxQyxPQUFPLENBQUMsa0JBQVIsR0FBNkIsa0JBQTdCO0FBQ0Esa0JBQWtCLENBQUMsc0JBQW5CLEdBQTRDLENBQ3hDLElBQUksNEJBQTRCLENBQUMsMEJBQWpDLEVBRHdDLEVBRXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELEdBQXBELEVBQXlELE1BQXpELENBRndDLEVBR3hDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE1BQXBELEVBQTRELE1BQTVELENBSHdDLEVBSXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE9BQXBELEVBQTZELEtBQTdELENBSndDLEVBS3hDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE9BQXBELEVBQTZELEtBQTdELENBTHdDLEVBTXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELFFBQXBELEVBQThELEtBQTlELENBTndDLEVBT3hDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELEtBQXBELEVBQTJELEtBQTNELENBUHdDLEVBUXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE1BQXBELEVBQTRELE1BQTVELENBUndDLEVBU3hDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELFFBQXBELEVBQThELE1BQTlELENBVHdDLEVBVXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELFFBQXBELEVBQThELEtBQTlELENBVndDLEVBV3hDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE9BQXBELEVBQTZELEtBQTdELENBWHdDLEVBWXhDLElBQUksd0JBQXdCLENBQUMsc0JBQTdCLENBQW9ELE9BQXBELEVBQTZELEtBQTdELENBWndDLEVBYXhDLElBQUksMkJBQTJCLENBQUMseUJBQWhDLENBQTBELE1BQTFELEVBQWtFLE9BQWxFLENBYndDLEVBY3hDLElBQUksMkJBQTJCLENBQUMseUJBQWhDLENBQTBELE9BQTFELEVBQW1FLE9BQW5FLENBZHdDLEVBZXhDLElBQUkseUJBQXlCLENBQUMsdUJBQTlCLEVBZndDLENBQTVDOzs7QUNwYUE7Ozs7Ozs7Ozs7QUFDQSxNQUFNLENBQUMsY0FBUCxDQUFzQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFLEVBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7QUFDQSxPQUFPLENBQUMsSUFBUixHQUFlLEtBQUssQ0FBcEI7O0FBQ0EsSUFBTSxrQkFBa0IsR0FBRyxPQUFP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TUFBTCxDQUFZLEVBQXZCLENBQWQ7QUFDSCxPQUZELE1BRU87QUFDSCxRQUFBLFdBQVcsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQUwsQ0FBWSxFQUFiLEVBQWlCLEtBQWpCLEVBQXdCLE1BQXhCLEVBQWdDLE1BQWhDLENBQXRCO0FBQ0g7O0FBQ0QsVUFBSSxXQUFXLElBQUksV0FBVyxDQUFDLFFBQVosR0FBdUIsTUFBdkIsR0FBZ0MsQ0FBbkQsRUFBc0Q7QUFDbEQsUUFBQSxVQUFVLENBQUMsSUFBWCxPQUFBLFVBQVUsc0NBQVMsV0FBVyxDQUFDLFFBQVosRUFBVCxFQUFWO0FBQ0g7QUFDSjtBQWxCd0M7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFtQnpDLE1BQU0sVUFBVSxHQUFHLElBQUksS0FBSixFQUFuQjs7QUFuQnlDLDhDQW9CdEIsVUFwQnNCO0FBQUE7O0FBQUE7QUFvQnpDLDJEQUErQjtBQUFBLFVBQXBCLEtBQW9CO0FBQzNCLE1BQUEsVUFBVSxDQUFDLE9BQVgsQ0FBbUIsS0FBbkI7QUFDSDtBQXRCd0M7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF1QnpDLFNBQU8sVUFBUDtBQUNIOztBQUdELE1BQU0sQ0FBQyxPQUFQLEdBQWlCO0FBQ2IsRUFBQSxTQUFTLEVBQUUsU0FERTtBQUViLEVBQUEsUUFBUSxFQUFFLFFBRkc7QUFHYixFQUFBLFFBQVEsRUFBRSxRQUhHO0FBSWIsRUFBQSxhQUFhLEVBQUU7QUFKRixDQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBJbnZhbGlkRGF0YUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZERhdGFFcnJvclwiO1xuICAgIH1cbn1cblxuY2xhc3MgU2hleFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlNoZXhWYWxpZGF0aW9uRXJyb3JcIjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEludmFsaWREYXRhRXJyb3I6IEludmFsaWREYXRhRXJyb3IsXG4gICAgU2hleFZhbGlkYXRpb25FcnJvcjogU2hleFZhbGlkYXRpb25FcnJvcixcbn0iLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0XCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsImZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlRnVuY3Rpb247IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgPSByZXF1aXJlKFwiLi9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCIpO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzOyIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3RcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9BcnJheTsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2ZcIik7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlRnVuY3Rpb25cIik7XG5cbnZhciBjb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3RcIik7XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFpc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlcjsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAodXRpbHMuaXNCbG9iKHJlcXVlc3REYXRhKSB8fCB1dGlscy5pc0ZpbGUocmVxdWVzdERhdGEpKSAmJlxuICAgICAgcmVxdWVzdERhdGEudHlwZVxuICAgICkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKHRpbWVvdXRFcnJvck1lc3NhZ2UsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICB2YXIgdmFsdWVGcm9tQ29uZmlnMktleXMgPSBbJ3VybCcsICdtZXRob2QnLCAnZGF0YSddO1xuICB2YXIgbWVyZ2VEZWVwUHJvcGVydGllc0tleXMgPSBbJ2hlYWRlcnMnLCAnYXV0aCcsICdwcm94eScsICdwYXJhbXMnXTtcbiAgdmFyIGRlZmF1bHRUb0NvbmZpZzJLZXlzID0gW1xuICAgICdiYXNlVVJMJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAndGltZW91dE1lc3NhZ2UnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLCAnZGVjb21wcmVzcycsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnLCAnbWF4Qm9keUxlbmd0aCcsICdtYXhSZWRpcmVjdHMnLCAndHJhbnNwb3J0JywgJ2h0dHBBZ2VudCcsXG4gICAgJ2h0dHBzQWdlbnQnLCAnY2FuY2VsVG9rZW4nLCAnc29ja2V0UGF0aCcsICdyZXNwb25zZUVuY29kaW5nJ1xuICBdO1xuICB2YXIgZGlyZWN0TWVyZ2VLZXlzID0gWyd2YWxpZGF0ZVN0YXR1cyddO1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdXRpbHMuZm9yRWFjaCh2YWx1ZUZyb21Db25maWcyS2V5cywgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHV0aWxzLmZvckVhY2goZGVmYXVsdFRvQ29uZmlnMktleXMsIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKGRpcmVjdE1lcmdlS2V5cywgZnVuY3Rpb24gbWVyZ2UocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGF4aW9zS2V5cyA9IHZhbHVlRnJvbUNvbmZpZzJLZXlzXG4gICAgLmNvbmNhdChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cylcbiAgICAuY29uY2F0KGRlZmF1bHRUb0NvbmZpZzJLZXlzKVxuICAgIC5jb25jYXQoZGlyZWN0TWVyZ2VLZXlzKTtcblxuICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0XG4gICAgLmtleXMoY29uZmlnMSlcbiAgICAuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQXhpb3NLZXlzKGtleSkge1xuICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYlhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYlhYMD0iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLyoganNoaW50IGVzdmVyc2lvbjogNiAqL1xuLyoganNsaW50IG5vZGU6IHRydWUgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiBzZXJpYWxpemUob2JqZWN0KTtcblxuICBmdW5jdGlvbiBzZXJpYWxpemUgKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcgfHwgb2JqZWN0LnRvSlNPTiAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBvYmplY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1tdJztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBvYmplY3QubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gJ1snICsgc2VyaWFsaXplKG9iamVjdFswXSkgKyAnXSc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmplY3QucmVkdWNlKCh0LCBjdiwgY2kpID0+IHtcbiAgICAgICAgdCA9IChjaSA9PT0gMSA/IHNlcmlhbGl6ZSh0KSA6IHQpO1xuICAgICAgICByZXR1cm4gdCArICcsJyArIHNlcmlhbGl6ZShjdik7XG4gICAgICB9KSArICddJztcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ3t9JztcbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gJ3snICsgc2VyaWFsaXplKGtleXNbMF0pICsgJzonICsgc2VyaWFsaXplKG9iamVjdFtrZXlzWzBdXSkgKyAnfSc7XG4gICAgfVxuICAgIHJldHVybiAneycgKyBrZXlzLnNvcnQoKS5yZWR1Y2UoKHQsIGN2LCBjaSkgPT4ge1xuICAgICAgdCA9IChjaSA9PT0gMSA/IHNlcmlhbGl6ZSh0KSArICc6JyArIHNlcmlhbGl6ZShvYmplY3RbdF0pIDogdCk7XG4gICAgICByZXR1cm4gdCArICcsJyArIHNlcmlhbGl6ZShjdikgKyAnOicgKyBzZXJpYWxpemUob2JqZWN0W2N2XSk7XG4gICAgfSkgKyAnfSc7XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXR0cmlidXRlTmFtZXMgPSBleHBvcnRzLmVsZW1lbnROYW1lcyA9IHZvaWQgMDtcbmV4cG9ydHMuZWxlbWVudE5hbWVzID0gbmV3IE1hcChbXG4gICAgW1wiYWx0Z2x5cGhcIiwgXCJhbHRHbHlwaFwiXSxcbiAgICBbXCJhbHRnbHlwaGRlZlwiLCBcImFsdEdseXBoRGVmXCJdLFxuICAgIFtcImFsdGdseXBoaXRlbVwiLCBcImFsdEdseXBoSXRlbVwiXSxcbiAgICBbXCJhbmltYXRlY29sb3JcIiwgXCJhbmltYXRlQ29sb3JcIl0sXG4gICAgW1wiYW5pbWF0ZW1vdGlvblwiLCBcImFuaW1hdGVNb3Rpb25cIl0sXG4gICAgW1wiYW5pbWF0ZXRyYW5zZm9ybVwiLCBcImFuaW1hdGVUcmFuc2Zvcm1cIl0sXG4gICAgW1wiY2xpcHBhdGhcIiwgXCJjbGlwUGF0aFwiXSxcbiAgICBbXCJmZWJsZW5kXCIsIFwiZmVCbGVuZFwiXSxcbiAgICBbXCJmZWNvbG9ybWF0cml4XCIsIFwiZmVDb2xvck1hdHJpeFwiXSxcbiAgICBbXCJmZWNvbXBvbmVudHRyYW5zZmVyXCIsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiXSxcbiAgICBbXCJmZWNvbXBvc2l0ZVwiLCBcImZlQ29tcG9zaXRlXCJdLFxuICAgIFtcImZlY29udm9sdmVtYXRyaXhcIiwgXCJmZUNvbnZvbHZlTWF0cml4XCJdLFxuICAgIFtcImZlZGlmZnVzZWxpZ2h0aW5nXCIsIFwiZmVEaWZmdXNlTGlnaHRpbmdcIl0sXG4gICAgW1wiZmVkaXNwbGFjZW1lbnRtYXBcIiwgXCJmZURpc3BsYWNlbWVudE1hcFwiXSxcbiAgICBbXCJmZWRpc3RhbnRsaWdodFwiLCBcImZlRGlzdGFudExpZ2h0XCJdLFxuICAgIFtcImZlZHJvcHNoYWRvd1wiLCBcImZlRHJvcFNoYWRvd1wiXSxcbiAgICBbXCJmZWZsb29kXCIsIFwiZmVGbG9vZFwiXSxcbiAgICBbXCJmZWZ1bmNhXCIsIFwiZmVGdW5jQVwiXSxcbiAgICBbXCJmZWZ1bmNiXCIsIFwiZmVGdW5jQlwiXSxcbiAgICBbXCJmZWZ1bmNnXCIsIFwiZmVGdW5jR1wiXSxcbiAgICBbXCJmZWZ1bmNyXCIsIFwiZmVGdW5jUlwiXSxcbiAgICBbXCJmZWdhdXNzaWFuYmx1clwiLCBcImZlR2F1c3NpYW5CbHVyXCJdLFxuICAgIFtcImZlaW1hZ2VcIiwgXCJmZUltYWdlXCJdLFxuICAgIFtcImZlbWVyZ2VcIiwgXCJmZU1lcmdlXCJdLFxuICAgIFtcImZlbWVyZ2Vub2RlXCIsIFwiZmVNZXJnZU5vZGVcIl0sXG4gICAgW1wiZmVtb3JwaG9sb2d5XCIsIFwiZmVNb3JwaG9sb2d5XCJdLFxuICAgIFtcImZlb2Zmc2V0XCIsIFwiZmVPZmZzZXRcIl0sXG4gICAgW1wiZmVwb2ludGxpZ2h0XCIsIFwiZmVQb2ludExpZ2h0XCJdLFxuICAgIFtcImZlc3BlY3VsYXJsaWdodGluZ1wiLCBcImZlU3BlY3VsYXJMaWdodGluZ1wiXSxcbiAgICBbXCJmZXNwb3RsaWdodFwiLCBcImZlU3BvdExpZ2h0XCJdLFxuICAgIFtcImZldGlsZVwiLCBcImZlVGlsZVwiXSxcbiAgICBbXCJmZXR1cmJ1bGVuY2VcIiwgXCJmZVR1cmJ1bGVuY2VcIl0sXG4gICAgW1wiZm9yZWlnbm9iamVjdFwiLCBcImZvcmVpZ25PYmplY3RcIl0sXG4gICAgW1wiZ2x5cGhyZWZcIiwgXCJnbHlwaFJlZlwiXSxcbiAgICBbXCJsaW5lYXJncmFkaWVudFwiLCBcImxpbmVhckdyYWRpZW50XCJdLFxuICAgIFtcInJhZGlhbGdyYWRpZW50XCIsIFwicmFkaWFsR3JhZGllbnRcIl0sXG4gICAgW1widGV4dHBhdGhcIiwgXCJ0ZXh0UGF0aFwiXSxcbl0pO1xuZXhwb3J0cy5hdHRyaWJ1dGVOYW1lcyA9IG5ldyBNYXAoW1xuICAgIFtcImRlZmluaXRpb251cmxcIiwgXCJkZWZpbml0aW9uVVJMXCJdLFxuICAgIFtcImF0dHJpYnV0ZW5hbWVcIiwgXCJhdHRyaWJ1dGVOYW1lXCJdLFxuICAgIFtcImF0dHJpYnV0ZXR5cGVcIiwgXCJhdHRyaWJ1dGVUeXBlXCJdLFxuICAgIFtcImJhc2VmcmVxdWVuY3lcIiwgXCJiYXNlRnJlcXVlbmN5XCJdLFxuICAgIFtcImJhc2Vwcm9maWxlXCIsIFwiYmFzZVByb2ZpbGVcIl0sXG4gICAgW1wiY2FsY21vZGVcIiwgXCJjYWxjTW9kZVwiXSxcbiAgICBbXCJjbGlwcGF0aHVuaXRzXCIsIFwiY2xpcFBhdGhVbml0c1wiXSxcbiAgICBbXCJkaWZmdXNlY29uc3RhbnRcIiwgXCJkaWZmdXNlQ29uc3RhbnRcIl0sXG4gICAgW1wiZWRnZW1vZGVcIiwgXCJlZGdlTW9kZVwiXSxcbiAgICBbXCJmaWx0ZXJ1bml0c1wiLCBcImZpbHRlclVuaXRzXCJdLFxuICAgIFtcImdseXBocmVmXCIsIFwiZ2x5cGhSZWZcIl0sXG4gICAgW1wiZ3JhZGllbnR0cmFuc2Zvcm1cIiwgXCJncmFkaWVudFRyYW5zZm9ybVwiXSxcbiAgICBbXCJncmFkaWVudHVuaXRzXCIsIFwiZ3JhZGllbnRVbml0c1wiXSxcbiAgICBbXCJrZXJuZWxtYXRyaXhcIiwgXCJrZXJuZWxNYXRyaXhcIl0sXG4gICAgW1wia2VybmVsdW5pdGxlbmd0aFwiLCBcImtlcm5lbFVuaXRMZW5ndGhcIl0sXG4gICAgW1wia2V5cG9pbnRzXCIsIFwia2V5UG9pbnRzXCJdLFxuICAgIFtcImtleXNwbGluZXNcIiwgXCJrZXlTcGxpbmVzXCJdLFxuICAgIFtcImtleXRpbWVzXCIsIFwia2V5VGltZXNcIl0sXG4gICAgW1wibGVuZ3RoYWRqdXN0XCIsIFwibGVuZ3RoQWRqdXN0XCJdLFxuICAgIFtcImxpbWl0aW5nY29uZWFuZ2xlXCIsIFwibGltaXRpbmdDb25lQW5nbGVcIl0sXG4gICAgW1wibWFya2VyaGVpZ2h0XCIsIFwibWFya2VySGVpZ2h0XCJdLFxuICAgIFtcIm1hcmtlcnVuaXRzXCIsIFwibWFya2VyVW5pdHNcIl0sXG4gICAgW1wibWFya2Vyd2lkdGhcIiwgXCJtYXJrZXJXaWR0aFwiXSxcbiAgICBbXCJtYXNrY29udGVudHVuaXRzXCIsIFwibWFza0NvbnRlbnRVbml0c1wiXSxcbiAgICBbXCJtYXNrdW5pdHNcIiwgXCJtYXNrVW5pdHNcIl0sXG4gICAgW1wibnVtb2N0YXZlc1wiLCBcIm51bU9jdGF2ZXNcIl0sXG4gICAgW1wicGF0aGxlbmd0aFwiLCBcInBhdGhMZW5ndGhcIl0sXG4gICAgW1wicGF0dGVybmNvbnRlbnR1bml0c1wiLCBcInBhdHRlcm5Db250ZW50VW5pdHNcIl0sXG4gICAgW1wicGF0dGVybnRyYW5zZm9ybVwiLCBcInBhdHRlcm5UcmFuc2Zvcm1cIl0sXG4gICAgW1wicGF0dGVybnVuaXRzXCIsIFwicGF0dGVyblVuaXRzXCJdLFxuICAgIFtcInBvaW50c2F0eFwiLCBcInBvaW50c0F0WFwiXSxcbiAgICBbXCJwb2ludHNhdHlcIiwgXCJwb2ludHNBdFlcIl0sXG4gICAgW1wicG9pbnRzYXR6XCIsIFwicG9pbnRzQXRaXCJdLFxuICAgIFtcInByZXNlcnZlYWxwaGFcIiwgXCJwcmVzZXJ2ZUFscGhhXCJdLFxuICAgIFtcInByZXNlcnZlYXNwZWN0cmF0aW9cIiwgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCJdLFxuICAgIFtcInByaW1pdGl2ZXVuaXRzXCIsIFwicHJpbWl0aXZlVW5pdHNcIl0sXG4gICAgW1wicmVmeFwiLCBcInJlZlhcIl0sXG4gICAgW1wicmVmeVwiLCBcInJlZllcIl0sXG4gICAgW1wicmVwZWF0Y291bnRcIiwgXCJyZXBlYXRDb3VudFwiXSxcbiAgICBbXCJyZXBlYXRkdXJcIiwgXCJyZXBlYXREdXJcIl0sXG4gICAgW1wicmVxdWlyZWRleHRlbnNpb25zXCIsIFwicmVxdWlyZWRFeHRlbnNpb25zXCJdLFxuICAgIFtcInJlcXVpcmVkZmVhdHVyZXNcIiwgXCJyZXF1aXJlZEZlYXR1cmVzXCJdLFxuICAgIFtcInNwZWN1bGFyY29uc3RhbnRcIiwgXCJzcGVjdWxhckNvbnN0YW50XCJdLFxuICAgIFtcInNwZWN1bGFyZXhwb25lbnRcIiwgXCJzcGVjdWxhckV4cG9uZW50XCJdLFxuICAgIFtcInNwcmVhZG1ldGhvZFwiLCBcInNwcmVhZE1ldGhvZFwiXSxcbiAgICBbXCJzdGFydG9mZnNldFwiLCBcInN0YXJ0T2Zmc2V0XCJdLFxuICAgIFtcInN0ZGRldmlhdGlvblwiLCBcInN0ZERldmlhdGlvblwiXSxcbiAgICBbXCJzdGl0Y2h0aWxlc1wiLCBcInN0aXRjaFRpbGVzXCJdLFxuICAgIFtcInN1cmZhY2VzY2FsZVwiLCBcInN1cmZhY2VTY2FsZVwiXSxcbiAgICBbXCJzeXN0ZW1sYW5ndWFnZVwiLCBcInN5c3RlbUxhbmd1YWdlXCJdLFxuICAgIFtcInRhYmxldmFsdWVzXCIsIFwidGFibGVWYWx1ZXNcIl0sXG4gICAgW1widGFyZ2V0eFwiLCBcInRhcmdldFhcIl0sXG4gICAgW1widGFyZ2V0eVwiLCBcInRhcmdldFlcIl0sXG4gICAgW1widGV4dGxlbmd0aFwiLCBcInRleHRMZW5ndGhcIl0sXG4gICAgW1widmlld2JveFwiLCBcInZpZXdCb3hcIl0sXG4gICAgW1widmlld3RhcmdldFwiLCBcInZpZXdUYXJnZXRcIl0sXG4gICAgW1wieGNoYW5uZWxzZWxlY3RvclwiLCBcInhDaGFubmVsU2VsZWN0b3JcIl0sXG4gICAgW1wieWNoYW5uZWxzZWxlY3RvclwiLCBcInlDaGFubmVsU2VsZWN0b3JcIl0sXG4gICAgW1wiem9vbWFuZHBhblwiLCBcInpvb21BbmRQYW5cIl0sXG5dKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xudmFyIEVsZW1lbnRUeXBlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKSk7XG52YXIgZW50aXRpZXNfMSA9IHJlcXVpcmUoXCJlbnRpdGllc1wiKTtcbi8qXG4gKiBNaXhlZC1jYXNlIFNWRyBhbmQgTWF0aE1MIHRhZ3MgJiBhdHRyaWJ1dGVzXG4gKiByZWNvZ25pemVkIGJ5IHRoZSBIVE1MIHBhcnNlciwgc2VlXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjcGFyc2luZy1tYWluLWluZm9yZWlnblxuICovXG52YXIgZm9yZWlnbk5hbWVzXzEgPSByZXF1aXJlKFwiLi9mb3JlaWduTmFtZXNcIik7XG52YXIgdW5lbmNvZGVkRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICBcInN0eWxlXCIsXG4gICAgXCJzY3JpcHRcIixcbiAgICBcInhtcFwiLFxuICAgIFwiaWZyYW1lXCIsXG4gICAgXCJub2VtYmVkXCIsXG4gICAgXCJub2ZyYW1lc1wiLFxuICAgIFwicGxhaW50ZXh0XCIsXG4gICAgXCJub3NjcmlwdFwiLFxuXSk7XG4vKipcbiAqIEZvcm1hdCBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEF0dHJpYnV0ZXMoYXR0cmlidXRlcywgb3B0cykge1xuICAgIGlmICghYXR0cmlidXRlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIHZhbHVlID0gKF9hID0gYXR0cmlidXRlc1trZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBpZiAob3B0cy54bWxNb2RlID09PSBcImZvcmVpZ25cIikge1xuICAgICAgICAgICAgLyogRml4IHVwIG1peGVkLWNhc2UgYXR0cmlidXRlIG5hbWVzICovXG4gICAgICAgICAgICBrZXkgPSAoX2IgPSBmb3JlaWduTmFtZXNfMS5hdHRyaWJ1dGVOYW1lcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cy5lbXB0eUF0dHJzICYmICFvcHRzLnhtbE1vZGUgJiYgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleSArIFwiPVxcXCJcIiArIChvcHRzLmRlY29kZUVudGl0aWVzID8gZW50aXRpZXNfMS5lbmNvZGVYTUwodmFsdWUpIDogdmFsdWUucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikpICsgXCJcXFwiXCI7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xufVxuLyoqXG4gKiBTZWxmLWVuY2xvc2luZyB0YWdzXG4gKi9cbnZhciBzaW5nbGVUYWcgPSBuZXcgU2V0KFtcbiAgICBcImFyZWFcIixcbiAgICBcImJhc2VcIixcbiAgICBcImJhc2Vmb250XCIsXG4gICAgXCJiclwiLFxuICAgIFwiY29sXCIsXG4gICAgXCJjb21tYW5kXCIsXG4gICAgXCJlbWJlZFwiLFxuICAgIFwiZnJhbWVcIixcbiAgICBcImhyXCIsXG4gICAgXCJpbWdcIixcbiAgICBcImlucHV0XCIsXG4gICAgXCJpc2luZGV4XCIsXG4gICAgXCJrZXlnZW5cIixcbiAgICBcImxpbmtcIixcbiAgICBcIm1ldGFcIixcbiAgICBcInBhcmFtXCIsXG4gICAgXCJzb3VyY2VcIixcbiAgICBcInRyYWNrXCIsXG4gICAgXCJ3YnJcIixcbl0pO1xuLyoqXG4gKiBSZW5kZXJzIGEgRE9NIG5vZGUgb3IgYW4gYXJyYXkgb2YgRE9NIG5vZGVzIHRvIGEgc3RyaW5nLlxuICpcbiAqIENhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSBlcXVpdmFsZW50IG9mIHRoZSBgb3V0ZXJIVE1MYCBvZiB0aGUgcGFzc2VkIG5vZGUocykuXG4gKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSBvcHRpb25zIENoYW5nZXMgc2VyaWFsaXphdGlvbiBiZWhhdmlvclxuICovXG5mdW5jdGlvbiByZW5kZXIobm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgLy8gVE9ETzogVGhpcyBpcyBhIGJpdCBoYWNreS5cbiAgICB2YXIgbm9kZXMgPSBBcnJheS5pc0FycmF5KG5vZGUpIHx8IG5vZGUuY2hlZXJpbyA/IG5vZGUgOiBbbm9kZV07XG4gICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRwdXQgKz0gcmVuZGVyTm9kZShub2Rlc1tpXSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLmRlZmF1bHQgPSByZW5kZXI7XG5mdW5jdGlvbiByZW5kZXJOb2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwicm9vdFwiOlxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcihub2RlLmNoaWxkcmVuLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZS5EaXJlY3RpdmU6XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyRGlyZWN0aXZlKG5vZGUpO1xuICAgICAgICBjYXNlIEVsZW1lbnRUeXBlLkNvbW1lbnQ6XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyQ29tbWVudChub2RlKTtcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZS5DREFUQTpcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJDZGF0YShub2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50VHlwZS5pc1RhZyhub2RlKVxuICAgICAgICAgICAgICAgID8gcmVuZGVyVGFnKG5vZGUsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiByZW5kZXJUZXh0KG5vZGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cbnZhciBmb3JlaWduTW9kZUludGVncmF0aW9uUG9pbnRzID0gbmV3IFNldChbXG4gICAgXCJtaVwiLFxuICAgIFwibW9cIixcbiAgICBcIm1uXCIsXG4gICAgXCJtc1wiLFxuICAgIFwibXRleHRcIixcbiAgICBcImFubm90YXRpb24teG1sXCIsXG4gICAgXCJmb3JlaWduT2JqZWN0XCIsXG4gICAgXCJkZXNjXCIsXG4gICAgXCJ0aXRsZVwiLFxuXSk7XG52YXIgZm9yZWlnbkVsZW1lbnRzID0gbmV3IFNldChbXCJzdmdcIiwgXCJtYXRoXCJdKTtcbmZ1bmN0aW9uIHJlbmRlclRhZyhlbGVtLCBvcHRzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIEhhbmRsZSBTVkcgLyBNYXRoTUwgaW4gSFRNTFxuICAgIGlmIChvcHRzLnhtbE1vZGUgPT09IFwiZm9yZWlnblwiKSB7XG4gICAgICAgIC8qIEZpeCB1cCBtaXhlZC1jYXNlIGVsZW1lbnQgbmFtZXMgKi9cbiAgICAgICAgZWxlbS5uYW1lID0gKF9hID0gZm9yZWlnbk5hbWVzXzEuZWxlbWVudE5hbWVzLmdldChlbGVtLm5hbWUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlbGVtLm5hbWU7XG4gICAgICAgIC8qIEV4aXQgZm9yZWlnbiBtb2RlIGF0IGludGVncmF0aW9uIHBvaW50cyAqL1xuICAgICAgICBpZiAoZWxlbS5wYXJlbnQgJiZcbiAgICAgICAgICAgIGZvcmVpZ25Nb2RlSW50ZWdyYXRpb25Qb2ludHMuaGFzKGVsZW0ucGFyZW50Lm5hbWUpKSB7XG4gICAgICAgICAgICBvcHRzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdHMpLCB7IHhtbE1vZGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0cy54bWxNb2RlICYmIGZvcmVpZ25FbGVtZW50cy5oYXMoZWxlbS5uYW1lKSkge1xuICAgICAgICBvcHRzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdHMpLCB7IHhtbE1vZGU6IFwiZm9yZWlnblwiIH0pO1xuICAgIH1cbiAgICB2YXIgdGFnID0gXCI8XCIgKyBlbGVtLm5hbWU7XG4gICAgdmFyIGF0dHJpYnMgPSBmb3JtYXRBdHRyaWJ1dGVzKGVsZW0uYXR0cmlicywgb3B0cyk7XG4gICAgaWYgKGF0dHJpYnMpIHtcbiAgICAgICAgdGFnICs9IFwiIFwiICsgYXR0cmlicztcbiAgICB9XG4gICAgaWYgKGVsZW0uY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmXG4gICAgICAgIChvcHRzLnhtbE1vZGVcbiAgICAgICAgICAgID8gLy8gSW4gWE1MIG1vZGUgb3IgZm9yZWlnbiBtb2RlLCBhbmQgdXNlciBoYXNuJ3QgZXhwbGljaXRseSB0dXJuZWQgb2ZmIHNlbGYtY2xvc2luZyB0YWdzXG4gICAgICAgICAgICAgICAgb3B0cy5zZWxmQ2xvc2luZ1RhZ3MgIT09IGZhbHNlXG4gICAgICAgICAgICA6IC8vIFVzZXIgZXhwbGljaXRseSBhc2tlZCBmb3Igc2VsZi1jbG9zaW5nIHRhZ3MsIGV2ZW4gaW4gSFRNTCBtb2RlXG4gICAgICAgICAgICAgICAgb3B0cy5zZWxmQ2xvc2luZ1RhZ3MgJiYgc2luZ2xlVGFnLmhhcyhlbGVtLm5hbWUpKSkge1xuICAgICAgICBpZiAoIW9wdHMueG1sTW9kZSlcbiAgICAgICAgICAgIHRhZyArPSBcIiBcIjtcbiAgICAgICAgdGFnICs9IFwiLz5cIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhZyArPSBcIj5cIjtcbiAgICAgICAgaWYgKGVsZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGFnICs9IHJlbmRlcihlbGVtLmNoaWxkcmVuLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy54bWxNb2RlIHx8ICFzaW5nbGVUYWcuaGFzKGVsZW0ubmFtZSkpIHtcbiAgICAgICAgICAgIHRhZyArPSBcIjwvXCIgKyBlbGVtLm5hbWUgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFnO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlyZWN0aXZlKGVsZW0pIHtcbiAgICByZXR1cm4gXCI8XCIgKyBlbGVtLmRhdGEgKyBcIj5cIjtcbn1cbmZ1bmN0aW9uIHJlbmRlclRleHQoZWxlbSwgb3B0cykge1xuICAgIHZhciBkYXRhID0gZWxlbS5kYXRhIHx8IFwiXCI7XG4gICAgLy8gSWYgZW50aXRpZXMgd2VyZW4ndCBkZWNvZGVkLCBubyBuZWVkIHRvIGVuY29kZSB0aGVtIGJhY2tcbiAgICBpZiAob3B0cy5kZWNvZGVFbnRpdGllcyAmJlxuICAgICAgICAhKGVsZW0ucGFyZW50ICYmIHVuZW5jb2RlZEVsZW1lbnRzLmhhcyhlbGVtLnBhcmVudC5uYW1lKSkpIHtcbiAgICAgICAgZGF0YSA9IGVudGl0aWVzXzEuZW5jb2RlWE1MKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNkYXRhKGVsZW0pIHtcbiAgICByZXR1cm4gXCI8IVtDREFUQVtcIiArIGVsZW0uY2hpbGRyZW5bMF0uZGF0YSArIFwiXV0+XCI7XG59XG5mdW5jdGlvbiByZW5kZXJDb21tZW50KGVsZW0pIHtcbiAgICByZXR1cm4gXCI8IS0tXCIgKyBlbGVtLmRhdGEgKyBcIi0tPlwiO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRvY3R5cGUgPSBleHBvcnRzLkNEQVRBID0gZXhwb3J0cy5UYWcgPSBleHBvcnRzLlN0eWxlID0gZXhwb3J0cy5TY3JpcHQgPSBleHBvcnRzLkNvbW1lbnQgPSBleHBvcnRzLkRpcmVjdGl2ZSA9IGV4cG9ydHMuVGV4dCA9IGV4cG9ydHMuaXNUYWcgPSB2b2lkIDA7XG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhIHRhZyBvciBub3QuXG4gKlxuICogQHBhcmFtIGVsZW0gRWxlbWVudCB0byB0ZXN0XG4gKi9cbmZ1bmN0aW9uIGlzVGFnKGVsZW0pIHtcbiAgICByZXR1cm4gKGVsZW0udHlwZSA9PT0gXCJ0YWdcIiAvKiBUYWcgKi8gfHxcbiAgICAgICAgZWxlbS50eXBlID09PSBcInNjcmlwdFwiIC8qIFNjcmlwdCAqLyB8fFxuICAgICAgICBlbGVtLnR5cGUgPT09IFwic3R5bGVcIiAvKiBTdHlsZSAqLyk7XG59XG5leHBvcnRzLmlzVGFnID0gaXNUYWc7XG4vLyBFeHBvcnRzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuLyoqIFR5cGUgZm9yIFRleHQgKi9cbmV4cG9ydHMuVGV4dCA9IFwidGV4dFwiIC8qIFRleHQgKi87XG4vKiogVHlwZSBmb3IgPD8gLi4uID8+ICovXG5leHBvcnRzLkRpcmVjdGl2ZSA9IFwiZGlyZWN0aXZlXCIgLyogRGlyZWN0aXZlICovO1xuLyoqIFR5cGUgZm9yIDwhLS0gLi4uIC0tPiAqL1xuZXhwb3J0cy5Db21tZW50ID0gXCJjb21tZW50XCIgLyogQ29tbWVudCAqLztcbi8qKiBUeXBlIGZvciA8c2NyaXB0PiB0YWdzICovXG5leHBvcnRzLlNjcmlwdCA9IFwic2NyaXB0XCIgLyogU2NyaXB0ICovO1xuLyoqIFR5cGUgZm9yIDxzdHlsZT4gdGFncyAqL1xuZXhwb3J0cy5TdHlsZSA9IFwic3R5bGVcIiAvKiBTdHlsZSAqLztcbi8qKiBUeXBlIGZvciBBbnkgdGFnICovXG5leHBvcnRzLlRhZyA9IFwidGFnXCIgLyogVGFnICovO1xuLyoqIFR5cGUgZm9yIDwhW0NEQVRBWyAuLi4gXV0+ICovXG5leHBvcnRzLkNEQVRBID0gXCJjZGF0YVwiIC8qIENEQVRBICovO1xuLyoqIFR5cGUgZm9yIDwhZG9jdHlwZSAuLi4+ICovXG5leHBvcnRzLkRvY3R5cGUgPSBcImRvY3R5cGVcIiAvKiBEb2N0eXBlICovO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRG9tSGFuZGxlciA9IHZvaWQgMDtcbnZhciBub2RlXzEgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25vZGVcIiksIGV4cG9ydHMpO1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMrL2c7XG4vLyBEZWZhdWx0IG9wdGlvbnNcbnZhciBkZWZhdWx0T3B0cyA9IHtcbiAgICBub3JtYWxpemVXaGl0ZXNwYWNlOiBmYWxzZSxcbiAgICB3aXRoU3RhcnRJbmRpY2VzOiBmYWxzZSxcbiAgICB3aXRoRW5kSW5kaWNlczogZmFsc2UsXG59O1xudmFyIERvbUhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxlZCBvbmNlIHBhcnNpbmcgaGFzIGNvbXBsZXRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBTZXR0aW5ncyBmb3IgdGhlIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIGVsZW1lbnRDQiBDYWxsYmFjayB3aGVuZXZlciBhIHRhZyBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRG9tSGFuZGxlcihjYWxsYmFjaywgb3B0aW9ucywgZWxlbWVudENCKSB7XG4gICAgICAgIC8qKiBUaGUgY29uc3RydWN0ZWQgRE9NICovXG4gICAgICAgIHRoaXMuZG9tID0gW107XG4gICAgICAgIC8qKiBJbmRpY2F0ZWQgd2hldGhlciBwYXJzaW5nIGhhcyBiZWVuIGNvbXBsZXRlZC4gKi9cbiAgICAgICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgICAgICAvKiogU3RhY2sgb2Ygb3BlbiB0YWdzLiAqL1xuICAgICAgICB0aGlzLl90YWdTdGFjayA9IFtdO1xuICAgICAgICAvKiogQSBkYXRhIG5vZGUgdGhhdCBpcyBzdGlsbCBiZWluZyB3cml0dGVuIHRvLiAqL1xuICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHBhcnNlciBpbnN0YW5jZS4gVXNlZCBmb3IgbG9jYXRpb24gaW5mb3JtYXRpb24uICovXG4gICAgICAgIHRoaXMuX3BhcnNlciA9IG51bGw7XG4gICAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gc2tpcCBhcmd1bWVudHMsIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWxlbWVudENCID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrICE9PSBudWxsICYmIGNhbGxiYWNrICE9PSB2b2lkIDAgPyBjYWxsYmFjayA6IG51bGw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiBkZWZhdWx0T3B0cztcbiAgICAgICAgdGhpcy5fZWxlbWVudENCID0gZWxlbWVudENCICE9PSBudWxsICYmIGVsZW1lbnRDQiAhPT0gdm9pZCAwID8gZWxlbWVudENCIDogbnVsbDtcbiAgICB9XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25wYXJzZXJpbml0ID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBwYXJzZXI7XG4gICAgfTtcbiAgICAvLyBSZXNldHMgdGhlIGhhbmRsZXIgYmFjayB0byBzdGFydGluZyBzdGF0ZVxuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9ucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5kb20gPSBbXTtcbiAgICAgICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90YWdTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IChfYSA9IHRoaXMuX3BhcnNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9O1xuICAgIC8vIFNpZ25hbHMgdGhlIGhhbmRsZXIgdGhhdCBwYXJzaW5nIGlzIGRvbmVcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZUNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLmhhbmRsZUNhbGxiYWNrKGVycm9yKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY2xvc2V0YWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gbnVsbDtcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLl90YWdTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFlbGVtIHx8ICF0aGlzLl9wYXJzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy53aXRoRW5kSW5kaWNlcykge1xuICAgICAgICAgICAgZWxlbS5lbmRJbmRleCA9IHRoaXMuX3BhcnNlci5lbmRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZWxlbWVudENCKVxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudENCKGVsZW0pO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25vcGVudGFnID0gZnVuY3Rpb24gKG5hbWUsIGF0dHJpYnMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBuZXcgbm9kZV8xLkVsZW1lbnQobmFtZSwgYXR0cmlicyk7XG4gICAgICAgIHRoaXMuYWRkTm9kZShlbGVtZW50KTtcbiAgICAgICAgdGhpcy5fdGFnU3RhY2sucHVzaChlbGVtZW50KTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9udGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBub3JtYWxpemUgPSB0aGlzLl9vcHRpb25zLm5vcm1hbGl6ZVdoaXRlc3BhY2U7XG4gICAgICAgIHZhciBfbGFzdE5vZGUgPSB0aGlzLl9sYXN0Tm9kZTtcbiAgICAgICAgaWYgKF9sYXN0Tm9kZSAmJiBfbGFzdE5vZGUudHlwZSA9PT0gXCJ0ZXh0XCIgLyogVGV4dCAqLykge1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIF9sYXN0Tm9kZS5kYXRhID0gKF9sYXN0Tm9kZS5kYXRhICsgZGF0YSkucmVwbGFjZShyZVdoaXRlc3BhY2UsIFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9sYXN0Tm9kZS5kYXRhICs9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZShyZVdoaXRlc3BhY2UsIFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IG5vZGVfMS5UZXh0KGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5hZGROb2RlKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbmNvbW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdE5vZGUgJiYgdGhpcy5fbGFzdE5vZGUudHlwZSA9PT0gXCJjb21tZW50XCIgLyogQ29tbWVudCAqLykge1xuICAgICAgICAgICAgdGhpcy5fbGFzdE5vZGUuZGF0YSArPSBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gbmV3IG5vZGVfMS5Db21tZW50KGRhdGEpO1xuICAgICAgICB0aGlzLmFkZE5vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gbm9kZTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY29tbWVudGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSBudWxsO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25jZGF0YXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGV4dCA9IG5ldyBub2RlXzEuVGV4dChcIlwiKTtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgbm9kZV8xLk5vZGVXaXRoQ2hpbGRyZW4oXCJjZGF0YVwiIC8qIENEQVRBICovLCBbdGV4dF0pO1xuICAgICAgICB0aGlzLmFkZE5vZGUobm9kZSk7XG4gICAgICAgIHRleHQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSB0ZXh0O1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25jZGF0YWVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSBudWxsO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBub2RlXzEuUHJvY2Vzc2luZ0luc3RydWN0aW9uKG5hbWUsIGRhdGEpO1xuICAgICAgICB0aGlzLmFkZE5vZGUobm9kZSk7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrKGVycm9yLCB0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5hZGROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3RhZ1N0YWNrW3RoaXMuX3RhZ1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgc2libGluZ3MgPSBwYXJlbnQgPyBwYXJlbnQuY2hpbGRyZW4gOiB0aGlzLmRvbTtcbiAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5fcGFyc2VyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy53aXRoU3RhcnRJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGFydEluZGV4ID0gdGhpcy5fcGFyc2VyLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy53aXRoRW5kSW5kaWNlcykge1xuICAgICAgICAgICAgICAgIG5vZGUuZW5kSW5kZXggPSB0aGlzLl9wYXJzZXIuZW5kSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZ3MucHVzaChub2RlKTtcbiAgICAgICAgaWYgKHByZXZpb3VzU2libGluZykge1xuICAgICAgICAgICAgbm9kZS5wcmV2ID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLm5leHQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gbnVsbDtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLmFkZERhdGFOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5hZGROb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IG5vZGU7XG4gICAgfTtcbiAgICByZXR1cm4gRG9tSGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLkRvbUhhbmRsZXIgPSBEb21IYW5kbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gRG9tSGFuZGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNsb25lTm9kZSA9IGV4cG9ydHMuRWxlbWVudCA9IGV4cG9ydHMuTm9kZVdpdGhDaGlsZHJlbiA9IGV4cG9ydHMuUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gZXhwb3J0cy5Db21tZW50ID0gZXhwb3J0cy5UZXh0ID0gZXhwb3J0cy5EYXRhTm9kZSA9IGV4cG9ydHMuTm9kZSA9IHZvaWQgMDtcbnZhciBub2RlVHlwZXMgPSBuZXcgTWFwKFtcbiAgICBbXCJ0YWdcIiAvKiBUYWcgKi8sIDFdLFxuICAgIFtcInNjcmlwdFwiIC8qIFNjcmlwdCAqLywgMV0sXG4gICAgW1wic3R5bGVcIiAvKiBTdHlsZSAqLywgMV0sXG4gICAgW1wiZGlyZWN0aXZlXCIgLyogRGlyZWN0aXZlICovLCAxXSxcbiAgICBbXCJ0ZXh0XCIgLyogVGV4dCAqLywgM10sXG4gICAgW1wiY2RhdGFcIiAvKiBDREFUQSAqLywgNF0sXG4gICAgW1wiY29tbWVudFwiIC8qIENvbW1lbnQgKi8sIDhdLFxuXSk7XG4vKipcbiAqIFRoaXMgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyB0aGUgcHJvdG90eXBlIGZvciBOb2RlcyB3aGVuIGNyZWF0aW5nIGFcbiAqIERPTS1MZXZlbC0xLWNvbXBsaWFudCBzdHJ1Y3R1cmUuXG4gKi9cbnZhciBOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9kZSh0eXBlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8qKiBQYXJlbnQgb2YgdGhlIG5vZGUgKi9cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAvKiogUHJldmlvdXMgc2libGluZyAqL1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICAvKiogTmV4dCBzaWJsaW5nICovXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIG5vZGUuIFJlcXVpcmVzIGB3aXRoU3RhcnRJbmRpY2VzYCBvbiB0aGUgaGFuZGxlciB0byBiZSBgdHJ1ZS4gKi9cbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBlbmQgaW5kZXggb2YgdGhlIG5vZGUuIFJlcXVpcmVzIGB3aXRoRW5kSW5kaWNlc2Agb24gdGhlIGhhbmRsZXIgdG8gYmUgYHRydWUuICovXG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIFwibm9kZVR5cGVcIiwge1xuICAgICAgICAvLyBSZWFkLW9ubHkgYWxpYXNlc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBub2RlVHlwZXMuZ2V0KHRoaXMudHlwZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIFwicGFyZW50Tm9kZVwiLCB7XG4gICAgICAgIC8vIFJlYWQtd3JpdGUgYWxpYXNlcyBmb3IgcHJvcGVydGllc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgXCJwcmV2aW91c1NpYmxpbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXY7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIFwibmV4dFNpYmxpbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGlzIG5vZGUsIGFuZCBvcHRpb25hbGx5IGl0cyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWN1cnNpdmUgQ2xvbmUgY2hpbGQgbm9kZXMgYXMgd2VsbC5cbiAgICAgKiBAcmV0dXJucyBBIGNsb25lIG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIE5vZGUucHJvdG90eXBlLmNsb25lTm9kZSA9IGZ1bmN0aW9uIChyZWN1cnNpdmUpIHtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBjbG9uZU5vZGUodGhpcywgcmVjdXJzaXZlKTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG52YXIgRGF0YU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGFOb2RlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBub2RlXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGNvbnRlbnQgb2YgdGhlIGRhdGEgbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFOb2RlKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlLnByb3RvdHlwZSwgXCJub2RlVmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRGF0YU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRGF0YU5vZGUgPSBEYXRhTm9kZTtcbnZhciBUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHQoZGF0YSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJ0ZXh0XCIgLyogVGV4dCAqLywgZGF0YSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRleHQ7XG59KERhdGFOb2RlKSk7XG5leHBvcnRzLlRleHQgPSBUZXh0O1xudmFyIENvbW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbW1lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tbWVudChkYXRhKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImNvbW1lbnRcIiAvKiBDb21tZW50ICovLCBkYXRhKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tbWVudDtcbn0oRGF0YU5vZGUpKTtcbmV4cG9ydHMuQ29tbWVudCA9IENvbW1lbnQ7XG52YXIgUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvY2Vzc2luZ0luc3RydWN0aW9uKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJkaXJlY3RpdmVcIiAvKiBEaXJlY3RpdmUgKi8sIGRhdGEpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb247XG59KERhdGFOb2RlKSk7XG5leHBvcnRzLlByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IFByb2Nlc3NpbmdJbnN0cnVjdGlvbjtcbnZhciBOb2RlV2l0aENoaWxkcmVuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb2RlV2l0aENoaWxkcmVuLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgVHlwZSBvZiB0aGUgbm9kZS5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIG5vZGUuIE9ubHkgY2VydGFpbiBub2RlIHR5cGVzIGNhbiBoYXZlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vZGVXaXRoQ2hpbGRyZW4odHlwZSwgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZVdpdGhDaGlsZHJlbi5wcm90b3R5cGUsIFwiZmlyc3RDaGlsZFwiLCB7XG4gICAgICAgIC8vIEFsaWFzZXNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jaGlsZHJlblswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlV2l0aENoaWxkcmVuLnByb3RvdHlwZSwgXCJsYXN0Q2hpbGRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlV2l0aENoaWxkcmVuLnByb3RvdHlwZSwgXCJjaGlsZE5vZGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBOb2RlV2l0aENoaWxkcmVuO1xufShOb2RlKSk7XG5leHBvcnRzLk5vZGVXaXRoQ2hpbGRyZW4gPSBOb2RlV2l0aENoaWxkcmVuO1xudmFyIEVsZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdGFnLCBlZy4gYGRpdmAsIGBzcGFuYC5cbiAgICAgKiBAcGFyYW0gYXR0cmlicyBPYmplY3QgbWFwcGluZyBhdHRyaWJ1dGUgbmFtZXMgdG8gYXR0cmlidXRlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRWxlbWVudChuYW1lLCBhdHRyaWJzLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkgeyBjaGlsZHJlbiA9IFtdOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUgPT09IFwic2NyaXB0XCJcbiAgICAgICAgICAgID8gXCJzY3JpcHRcIiAvKiBTY3JpcHQgKi9cbiAgICAgICAgICAgIDogbmFtZSA9PT0gXCJzdHlsZVwiXG4gICAgICAgICAgICAgICAgPyBcInN0eWxlXCIgLyogU3R5bGUgKi9cbiAgICAgICAgICAgICAgICA6IFwidGFnXCIgLyogVGFnICovLCBjaGlsZHJlbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmF0dHJpYnMgPSBhdHRyaWJzO1xuICAgICAgICBfdGhpcy5hdHRyaWJzID0gYXR0cmlicztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudC5wcm90b3R5cGUsIFwidGFnTmFtZVwiLCB7XG4gICAgICAgIC8vIERPTSBMZXZlbCAxIGFsaWFzZXNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVsZW1lbnQucHJvdG90eXBlLCBcImF0dHJpYnV0ZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hdHRyaWJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuYXR0cmlic1tuYW1lXSxcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBFbGVtZW50O1xufShOb2RlV2l0aENoaWxkcmVuKSk7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuLyoqXG4gKiBDbG9uZSBhIG5vZGUsIGFuZCBvcHRpb25hbGx5IGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gcmVjdXJzaXZlIENsb25lIGNoaWxkIG5vZGVzIGFzIHdlbGwuXG4gKiBAcmV0dXJucyBBIGNsb25lIG9mIHRoZSBub2RlLlxuICovXG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSwgcmVjdXJzaXZlKSB7XG4gICAgaWYgKHJlY3Vyc2l2ZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2l2ZSA9IGZhbHNlOyB9XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHRcIiAvKiBUZXh0ICovOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0KG5vZGUuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJkaXJlY3RpdmVcIiAvKiBEaXJlY3RpdmUgKi86IHtcbiAgICAgICAgICAgIHZhciBpbnN0ciA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb2Nlc3NpbmdJbnN0cnVjdGlvbihpbnN0ci5uYW1lLCBpbnN0ci5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiY29tbWVudFwiIC8qIENvbW1lbnQgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbW1lbnQobm9kZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcInRhZ1wiIC8qIFRhZyAqLzpcbiAgICAgICAgY2FzZSBcInNjcmlwdFwiIC8qIFNjcmlwdCAqLzpcbiAgICAgICAgY2FzZSBcInN0eWxlXCIgLyogU3R5bGUgKi86IHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gbm9kZTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHJlY3Vyc2l2ZSA/IGNsb25lQ2hpbGRyZW4oZWxlbS5jaGlsZHJlbikgOiBbXTtcbiAgICAgICAgICAgIHZhciBjbG9uZV8xID0gbmV3IEVsZW1lbnQoZWxlbS5uYW1lLCBfX2Fzc2lnbih7fSwgZWxlbS5hdHRyaWJzKSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIChjaGlsZC5wYXJlbnQgPSBjbG9uZV8xKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVfMTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiY2RhdGFcIiAvKiBDREFUQSAqLzoge1xuICAgICAgICAgICAgdmFyIGNkYXRhID0gbm9kZTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHJlY3Vyc2l2ZSA/IGNsb25lQ2hpbGRyZW4oY2RhdGEuY2hpbGRyZW4pIDogW107XG4gICAgICAgICAgICB2YXIgY2xvbmVfMiA9IG5ldyBOb2RlV2l0aENoaWxkcmVuKFwiY2RhdGFcIiAvKiBDREFUQSAqLywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIChjaGlsZC5wYXJlbnQgPSBjbG9uZV8yKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVfMjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZG9jdHlwZVwiIC8qIERvY3R5cGUgKi86IHtcbiAgICAgICAgICAgIC8vIFRoaXMgdHlwZSBpc24ndCB1c2VkIHlldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCB5ZXQ6IEVsZW1lbnRUeXBlLkRvY3R5cGUgY2FzZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2xvbmVOb2RlID0gY2xvbmVOb2RlO1xuZnVuY3Rpb24gY2xvbmVDaGlsZHJlbihjaGlsZHMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBjaGlsZHMubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2xvbmVOb2RlKGNoaWxkLCB0cnVlKTsgfSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZHJlbltpXS5wcmV2ID0gY2hpbGRyZW5baSAtIDFdO1xuICAgICAgICBjaGlsZHJlbltpIC0gMV0ubmV4dCA9IGNoaWxkcmVuW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5pcXVlU29ydCA9IGV4cG9ydHMuY29tcGFyZURvY3VtZW50UG9zaXRpb24gPSBleHBvcnRzLnJlbW92ZVN1YnNldHMgPSB2b2lkIDA7XG52YXIgdGFndHlwZXNfMSA9IHJlcXVpcmUoXCIuL3RhZ3R5cGVzXCIpO1xuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBub2RlcywgcmVtb3ZlIGFueSBtZW1iZXIgdGhhdCBpcyBjb250YWluZWQgYnkgYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0gbm9kZXMgTm9kZXMgdG8gZmlsdGVyLlxuICogQHJldHVybnMgUmVtYWluaW5nIG5vZGVzIHRoYXQgYXJlbid0IHN1YnRyZWVzIG9mIGVhY2ggb3RoZXIuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVN1YnNldHMobm9kZXMpIHtcbiAgICB2YXIgaWR4ID0gbm9kZXMubGVuZ3RoO1xuICAgIC8qXG4gICAgICogQ2hlY2sgaWYgZWFjaCBub2RlIChvciBvbmUgb2YgaXRzIGFuY2VzdG9ycykgaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlXG4gICAgICogYXJyYXkuXG4gICAgICovXG4gICAgd2hpbGUgKC0taWR4ID49IDApIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpZHhdO1xuICAgICAgICAvKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIG5vZGUgaWYgaXQgaXMgbm90IHVuaXF1ZS5cbiAgICAgICAgICogV2UgYXJlIGdvaW5nIHRocm91Z2ggdGhlIGFycmF5IGZyb20gdGhlIGVuZCwgc28gd2Ugb25seVxuICAgICAgICAgKiBoYXZlIHRvIGNoZWNrIG5vZGVzIHRoYXQgcHJlY2VlZCB0aGUgbm9kZSB1bmRlciBjb25zaWRlcmF0aW9uIGluIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpZHggPiAwICYmIG5vZGVzLmxhc3RJbmRleE9mKG5vZGUsIGlkeCAtIDEpID49IDApIHtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgYW5jZXN0b3IgPSBub2RlLnBhcmVudDsgYW5jZXN0b3I7IGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5jbHVkZXMoYW5jZXN0b3IpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZXhwb3J0cy5yZW1vdmVTdWJzZXRzID0gcmVtb3ZlU3Vic2V0cztcbi8qKlxuICogQ29tcGFyZSB0aGUgcG9zaXRpb24gb2Ygb25lIG5vZGUgYWdhaW5zdCBhbm90aGVyIG5vZGUgaW4gYW55IG90aGVyIGRvY3VtZW50LlxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhIGJpdG1hc2sgd2l0aCB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqXG4gKiBEb2N1bWVudCBvcmRlcjpcbiAqID4gVGhlcmUgaXMgYW4gb3JkZXJpbmcsIGRvY3VtZW50IG9yZGVyLCBkZWZpbmVkIG9uIGFsbCB0aGUgbm9kZXMgaW4gdGhlXG4gKiA+IGRvY3VtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gKiA+IFhNTCByZXByZXNlbnRhdGlvbiBvZiBlYWNoIG5vZGUgb2NjdXJzIGluIHRoZSBYTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gKiA+IGRvY3VtZW50IGFmdGVyIGV4cGFuc2lvbiBvZiBnZW5lcmFsIGVudGl0aWVzLiBUaHVzLCB0aGUgZG9jdW1lbnQgZWxlbWVudFxuICogPiBub2RlIHdpbGwgYmUgdGhlIGZpcnN0IG5vZGUuIEVsZW1lbnQgbm9kZXMgb2NjdXIgYmVmb3JlIHRoZWlyIGNoaWxkcmVuLlxuICogPiBUaHVzLCBkb2N1bWVudCBvcmRlciBvcmRlcnMgZWxlbWVudCBub2RlcyBpbiBvcmRlciBvZiB0aGUgb2NjdXJyZW5jZSBvZlxuICogPiB0aGVpciBzdGFydC10YWcgaW4gdGhlIFhNTCAoYWZ0ZXIgZXhwYW5zaW9uIG9mIGVudGl0aWVzKS4gVGhlIGF0dHJpYnV0ZVxuICogPiBub2RlcyBvZiBhbiBlbGVtZW50IG9jY3VyIGFmdGVyIHRoZSBlbGVtZW50IGFuZCBiZWZvcmUgaXRzIGNoaWxkcmVuLiBUaGVcbiAqID4gcmVsYXRpdmUgb3JkZXIgb2YgYXR0cmlidXRlIG5vZGVzIGlzIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudC4vXG4gKlxuICogU291cmNlOlxuICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9nbG9zc2FyeS5odG1sI2R0LWRvY3VtZW50LW9yZGVyXG4gKlxuICogQHBhcmFtIG5vZGVBIFRoZSBmaXJzdCBub2RlIHRvIHVzZSBpbiB0aGUgY29tcGFyaXNvblxuICogQHBhcmFtIG5vZGVCIFRoZSBzZWNvbmQgbm9kZSB0byB1c2UgaW4gdGhlIGNvbXBhcmlzb25cbiAqIEByZXR1cm5zIEEgYml0bWFzayBkZXNjcmliaW5nIHRoZSBpbnB1dCBub2RlcycgcmVsYXRpdmUgcG9zaXRpb24uXG4gKlxuICogU2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tbm9kZS1jb21wYXJlZG9jdW1lbnRwb3NpdGlvbiBmb3JcbiAqIGEgZGVzY3JpcHRpb24gb2YgdGhlc2UgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlQSwgbm9kZUIpIHtcbiAgICB2YXIgYVBhcmVudHMgPSBbXTtcbiAgICB2YXIgYlBhcmVudHMgPSBbXTtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgY3VycmVudCA9IHRhZ3R5cGVzXzEuaGFzQ2hpbGRyZW4obm9kZUEpID8gbm9kZUEgOiBub2RlQS5wYXJlbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgYVBhcmVudHMudW5zaGlmdChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICBjdXJyZW50ID0gdGFndHlwZXNfMS5oYXNDaGlsZHJlbihub2RlQikgPyBub2RlQiA6IG5vZGVCLnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBiUGFyZW50cy51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHZhciBtYXhJZHggPSBNYXRoLm1pbihhUGFyZW50cy5sZW5ndGgsIGJQYXJlbnRzLmxlbmd0aCk7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IG1heElkeCAmJiBhUGFyZW50c1tpZHhdID09PSBiUGFyZW50c1tpZHhdKSB7XG4gICAgICAgIGlkeCsrO1xuICAgIH1cbiAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxIC8qIERJU0NPTk5FQ1RFRCAqLztcbiAgICB9XG4gICAgdmFyIHNoYXJlZFBhcmVudCA9IGFQYXJlbnRzW2lkeCAtIDFdO1xuICAgIHZhciBzaWJsaW5ncyA9IHNoYXJlZFBhcmVudC5jaGlsZHJlbjtcbiAgICB2YXIgYVNpYmxpbmcgPSBhUGFyZW50c1tpZHhdO1xuICAgIHZhciBiU2libGluZyA9IGJQYXJlbnRzW2lkeF07XG4gICAgaWYgKHNpYmxpbmdzLmluZGV4T2YoYVNpYmxpbmcpID4gc2libGluZ3MuaW5kZXhPZihiU2libGluZykpIHtcbiAgICAgICAgaWYgKHNoYXJlZFBhcmVudCA9PT0gbm9kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiA0IC8qIEZPTExPV0lORyAqLyB8IDE2IC8qIENPTlRBSU5FRF9CWSAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gNCAvKiBGT0xMT1dJTkcgKi87XG4gICAgfVxuICAgIGlmIChzaGFyZWRQYXJlbnQgPT09IG5vZGVBKSB7XG4gICAgICAgIHJldHVybiAyIC8qIFBSRUNFRElORyAqLyB8IDggLyogQ09OVEFJTlMgKi87XG4gICAgfVxuICAgIHJldHVybiAyIC8qIFBSRUNFRElORyAqLztcbn1cbmV4cG9ydHMuY29tcGFyZURvY3VtZW50UG9zaXRpb24gPSBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcbi8qKlxuICogU29ydCBhbiBhcnJheSBvZiBub2RlcyBiYXNlZCBvbiB0aGVpciByZWxhdGl2ZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQgYW5kXG4gKiByZW1vdmUgYW55IGR1cGxpY2F0ZSBub2Rlcy4gSWYgdGhlIGFycmF5IGNvbnRhaW5zIG5vZGVzIHRoYXQgZG8gbm90IGJlbG9uZ1xuICogdG8gdGhlIHNhbWUgZG9jdW1lbnQsIHNvcnQgb3JkZXIgaXMgdW5zcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIERPTSBub2Rlcy5cbiAqIEByZXR1cm5zIENvbGxlY3Rpb24gb2YgdW5pcXVlIG5vZGVzLCBzb3J0ZWQgaW4gZG9jdW1lbnQgb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZVNvcnQobm9kZXMpIHtcbiAgICBub2RlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSwgaSwgYXJyKSB7IHJldHVybiAhYXJyLmluY2x1ZGVzKG5vZGUsIGkgKyAxKTsgfSk7XG4gICAgbm9kZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhLCBiKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlICYgMiAvKiBQUkVDRURJTkcgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWxhdGl2ZSAmIDQgLyogRk9MTE9XSU5HICovKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXM7XG59XG5leHBvcnRzLnVuaXF1ZVNvcnQgPSB1bmlxdWVTb3J0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHJpbmdpZnlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYXZlcnNhbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWFuaXB1bGF0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9xdWVyeWluZ1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGVnYWN5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90YWd0eXBlc1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ1R5cGUgPSBleHBvcnRzLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gZXhwb3J0cy5nZXRFbGVtZW50QnlJZCA9IGV4cG9ydHMuZ2V0RWxlbWVudHMgPSBleHBvcnRzLnRlc3RFbGVtZW50ID0gdm9pZCAwO1xudmFyIHF1ZXJ5aW5nXzEgPSByZXF1aXJlKFwiLi9xdWVyeWluZ1wiKTtcbnZhciB0YWd0eXBlc18xID0gcmVxdWlyZShcIi4vdGFndHlwZXNcIik7XG52YXIgQ2hlY2tzID0ge1xuICAgIHRhZ19uYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB0YWd0eXBlc18xLmlzVGFnKGVsZW0pICYmIG5hbWUoZWxlbS5uYW1lKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSBcIipcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB0YWd0eXBlc18xLmlzVGFnKGVsZW0pICYmIGVsZW0ubmFtZSA9PT0gbmFtZTsgfTtcbiAgICB9LFxuICAgIHRhZ190eXBlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB0eXBlKGVsZW0udHlwZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnR5cGUgPT09IHR5cGU7IH07XG4gICAgfSxcbiAgICB0YWdfY29udGFpbnM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHRhZ3R5cGVzXzEuaXNUZXh0KGVsZW0pICYmIGRhdGEoZWxlbS5kYXRhKTsgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHRhZ3R5cGVzXzEuaXNUZXh0KGVsZW0pICYmIGVsZW0uZGF0YSA9PT0gZGF0YTsgfTtcbiAgICB9LFxufTtcbi8qKlxuICogQHBhcmFtIGF0dHJpYiBBdHRyaWJ1dGUgdG8gY2hlY2suXG4gKiBAcGFyYW0gdmFsdWUgQXR0cmlidXRlIHZhbHVlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0byBjaGVjayB3aGV0aGVyIHRoZSBhIG5vZGUgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgcGFydGljdWxhciB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmliQ2hlY2soYXR0cmliLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWcoZWxlbSkgJiYgdmFsdWUoZWxlbS5hdHRyaWJzW2F0dHJpYl0pOyB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWcoZWxlbSkgJiYgZWxlbS5hdHRyaWJzW2F0dHJpYl0gPT09IHZhbHVlOyB9O1xufVxuLyoqXG4gKiBAcGFyYW0gYSBGaXJzdCBmdW5jdGlvbiB0byBjb21iaW5lLlxuICogQHBhcmFtIGIgU2Vjb25kIGZ1bmN0aW9uIHRvIGNvbWJpbmUuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRha2luZyBhIG5vZGUgYW5kIHJldHVybmluZyBgdHJ1ZWAgaWYgZWl0aGVyXG4gKiBvZiB0aGUgaW5wdXQgZnVuY3Rpb25zIHJldHVybnMgYHRydWVgIGZvciB0aGUgbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29tYmluZUZ1bmNzKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGEoZWxlbSkgfHwgYihlbGVtKTsgfTtcbn1cbi8qKlxuICogQHBhcmFtIG9wdGlvbnMgQW4gb2JqZWN0IGRlc2NyaWJpbmcgbm9kZXMgdG8gbG9vayBmb3IuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIGV4ZWN1dGluZyBhbGwgY2hlY2tzIGluIGBvcHRpb25zYCBhbmQgcmV0dXJuaW5nIGB0cnVlYFxuICogaWYgYW55IG9mIHRoZW0gbWF0Y2ggYSBub2RlLlxuICovXG5mdW5jdGlvbiBjb21waWxlVGVzdChvcHRpb25zKSB7XG4gICAgdmFyIGZ1bmNzID0gT2JqZWN0LmtleXMob3B0aW9ucykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgICByZXR1cm4ga2V5IGluIENoZWNrc1xuICAgICAgICAgICAgPyBDaGVja3Nba2V5XSh2YWx1ZSlcbiAgICAgICAgICAgIDogZ2V0QXR0cmliQ2hlY2soa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmNzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBmdW5jcy5yZWR1Y2UoY29tYmluZUZ1bmNzKTtcbn1cbi8qKlxuICogQHBhcmFtIG9wdGlvbnMgQW4gb2JqZWN0IGRlc2NyaWJpbmcgbm9kZXMgdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0gbm9kZSBUaGUgZWxlbWVudCB0byB0ZXN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZWxlbWVudCBtYXRjaGVzIHRoZSBkZXNjcmlwdGlvbiBpbiBgb3B0aW9uc2AuXG4gKi9cbmZ1bmN0aW9uIHRlc3RFbGVtZW50KG9wdGlvbnMsIG5vZGUpIHtcbiAgICB2YXIgdGVzdCA9IGNvbXBpbGVUZXN0KG9wdGlvbnMpO1xuICAgIHJldHVybiB0ZXN0ID8gdGVzdChub2RlKSA6IHRydWU7XG59XG5leHBvcnRzLnRlc3RFbGVtZW50ID0gdGVzdEVsZW1lbnQ7XG4vKipcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCBkZXNjcmliaW5nIG5vZGVzIHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIG5vZGVzIE5vZGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBBbGwgbm9kZXMgdGhhdCBtYXRjaCBgb3B0aW9uc2AuXG4gKi9cbmZ1bmN0aW9uIGdldEVsZW1lbnRzKG9wdGlvbnMsIG5vZGVzLCByZWN1cnNlLCBsaW1pdCkge1xuICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gSW5maW5pdHk7IH1cbiAgICB2YXIgdGVzdCA9IGNvbXBpbGVUZXN0KG9wdGlvbnMpO1xuICAgIHJldHVybiB0ZXN0ID8gcXVlcnlpbmdfMS5maWx0ZXIodGVzdCwgbm9kZXMsIHJlY3Vyc2UsIGxpbWl0KSA6IFtdO1xufVxuZXhwb3J0cy5nZXRFbGVtZW50cyA9IGdldEVsZW1lbnRzO1xuLyoqXG4gKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBJRCBhdHRyaWJ1dGUgdmFsdWUgdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0gbm9kZXMgTm9kZXMgdG8gc2VhcmNoIHRocm91Z2guXG4gKiBAcGFyYW0gcmVjdXJzZSBBbHNvIGNvbnNpZGVyIGNoaWxkIG5vZGVzLlxuICogQHJldHVybnMgVGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldEVsZW1lbnRCeUlkKGlkLCBub2RlcywgcmVjdXJzZSkge1xuICAgIGlmIChyZWN1cnNlID09PSB2b2lkIDApIHsgcmVjdXJzZSA9IHRydWU7IH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKVxuICAgICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgcmV0dXJuIHF1ZXJ5aW5nXzEuZmluZE9uZShnZXRBdHRyaWJDaGVjayhcImlkXCIsIGlkKSwgbm9kZXMsIHJlY3Vyc2UpO1xufVxuZXhwb3J0cy5nZXRFbGVtZW50QnlJZCA9IGdldEVsZW1lbnRCeUlkO1xuLyoqXG4gKiBAcGFyYW0gdGFnTmFtZSBUYWcgbmFtZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIG5vZGVzIE5vZGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHJlY3Vyc2UgQWxzbyBjb25zaWRlciBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSBsaW1pdCBNYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBBbGwgbm9kZXMgd2l0aCB0aGUgc3VwcGxpZWQgYHRhZ05hbWVgLlxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lLCBub2RlcywgcmVjdXJzZSwgbGltaXQpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIHJldHVybiBxdWVyeWluZ18xLmZpbHRlcihDaGVja3MudGFnX25hbWUodGFnTmFtZSksIG5vZGVzLCByZWN1cnNlLCBsaW1pdCk7XG59XG5leHBvcnRzLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gZ2V0RWxlbWVudHNCeVRhZ05hbWU7XG4vKipcbiAqIEBwYXJhbSB0eXBlIEVsZW1lbnQgdHlwZSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSBub2RlcyBOb2RlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0gbGltaXQgTWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgQWxsIG5vZGVzIHdpdGggdGhlIHN1cHBsaWVkIGB0eXBlYC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVRhZ1R5cGUodHlwZSwgbm9kZXMsIHJlY3Vyc2UsIGxpbWl0KSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gSW5maW5pdHk7IH1cbiAgICByZXR1cm4gcXVlcnlpbmdfMS5maWx0ZXIoQ2hlY2tzLnRhZ190eXBlKHR5cGUpLCBub2RlcywgcmVjdXJzZSwgbGltaXQpO1xufVxuZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnVHlwZSA9IGdldEVsZW1lbnRzQnlUYWdUeXBlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByZXBlbmQgPSBleHBvcnRzLnByZXBlbmRDaGlsZCA9IGV4cG9ydHMuYXBwZW5kID0gZXhwb3J0cy5hcHBlbmRDaGlsZCA9IGV4cG9ydHMucmVwbGFjZUVsZW1lbnQgPSBleHBvcnRzLnJlbW92ZUVsZW1lbnQgPSB2b2lkIDA7XG4vKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIGRvbVxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGJlIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtKSB7XG4gICAgaWYgKGVsZW0ucHJldilcbiAgICAgICAgZWxlbS5wcmV2Lm5leHQgPSBlbGVtLm5leHQ7XG4gICAgaWYgKGVsZW0ubmV4dClcbiAgICAgICAgZWxlbS5uZXh0LnByZXYgPSBlbGVtLnByZXY7XG4gICAgaWYgKGVsZW0ucGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZHMgPSBlbGVtLnBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY2hpbGRzLnNwbGljZShjaGlsZHMubGFzdEluZGV4T2YoZWxlbSksIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVtb3ZlRWxlbWVudCA9IHJlbW92ZUVsZW1lbnQ7XG4vKipcbiAqIFJlcGxhY2UgYW4gZWxlbWVudCBpbiB0aGUgZG9tXG4gKlxuICogQHBhcmFtIGVsZW0gVGhlIGVsZW1lbnQgdG8gYmUgcmVwbGFjZWRcbiAqIEBwYXJhbSByZXBsYWNlbWVudCBUaGUgZWxlbWVudCB0byBiZSBhZGRlZFxuICovXG5mdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtLCByZXBsYWNlbWVudCkge1xuICAgIHZhciBwcmV2ID0gKHJlcGxhY2VtZW50LnByZXYgPSBlbGVtLnByZXYpO1xuICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHByZXYubmV4dCA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IChyZXBsYWNlbWVudC5uZXh0ID0gZWxlbS5uZXh0KTtcbiAgICBpZiAobmV4dCkge1xuICAgICAgICBuZXh0LnByZXYgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IChyZXBsYWNlbWVudC5wYXJlbnQgPSBlbGVtLnBhcmVudCk7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGRzID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjaGlsZHNbY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pXSA9IHJlcGxhY2VtZW50O1xuICAgIH1cbn1cbmV4cG9ydHMucmVwbGFjZUVsZW1lbnQgPSByZXBsYWNlRWxlbWVudDtcbi8qKlxuICogQXBwZW5kIGEgY2hpbGQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0gY2hpbGQgVGhlIGVsZW1lbnQgdG8gYmUgYWRkZWQgYXMgYSBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ2hpbGQoZWxlbSwgY2hpbGQpIHtcbiAgICByZW1vdmVFbGVtZW50KGNoaWxkKTtcbiAgICBjaGlsZC5uZXh0ID0gbnVsbDtcbiAgICBjaGlsZC5wYXJlbnQgPSBlbGVtO1xuICAgIGlmIChlbGVtLmNoaWxkcmVuLnB1c2goY2hpbGQpID4gMSkge1xuICAgICAgICB2YXIgc2libGluZyA9IGVsZW0uY2hpbGRyZW5bZWxlbS5jaGlsZHJlbi5sZW5ndGggLSAyXTtcbiAgICAgICAgc2libGluZy5uZXh0ID0gY2hpbGQ7XG4gICAgICAgIGNoaWxkLnByZXYgPSBzaWJsaW5nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQucHJldiA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5hcHBlbmRDaGlsZCA9IGFwcGVuZENoaWxkO1xuLyoqXG4gKiBBcHBlbmQgYW4gZWxlbWVudCBhZnRlciBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIGFwcGVuZCBhZnRlci5cbiAqIEBwYXJhbSBuZXh0IFRoZSBlbGVtZW50IGJlIGFkZGVkLlxuICovXG5mdW5jdGlvbiBhcHBlbmQoZWxlbSwgbmV4dCkge1xuICAgIHJlbW92ZUVsZW1lbnQobmV4dCk7XG4gICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50O1xuICAgIHZhciBjdXJyTmV4dCA9IGVsZW0ubmV4dDtcbiAgICBuZXh0Lm5leHQgPSBjdXJyTmV4dDtcbiAgICBuZXh0LnByZXYgPSBlbGVtO1xuICAgIGVsZW0ubmV4dCA9IG5leHQ7XG4gICAgbmV4dC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgaWYgKGN1cnJOZXh0KSB7XG4gICAgICAgIGN1cnJOZXh0LnByZXYgPSBuZXh0O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRzID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgY2hpbGRzLnNwbGljZShjaGlsZHMubGFzdEluZGV4T2YoY3Vyck5leHQpLCAwLCBuZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobmV4dCk7XG4gICAgfVxufVxuZXhwb3J0cy5hcHBlbmQgPSBhcHBlbmQ7XG4vKipcbiAqIFByZXBlbmQgYSBjaGlsZCB0byBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIHByZXBlbmQgYmVmb3JlLlxuICogQHBhcmFtIGNoaWxkIFRoZSBlbGVtZW50IHRvIGJlIGFkZGVkIGFzIGEgY2hpbGQuXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRDaGlsZChlbGVtLCBjaGlsZCkge1xuICAgIHJlbW92ZUVsZW1lbnQoY2hpbGQpO1xuICAgIGNoaWxkLnBhcmVudCA9IGVsZW07XG4gICAgY2hpbGQucHJldiA9IG51bGw7XG4gICAgaWYgKGVsZW0uY2hpbGRyZW4udW5zaGlmdChjaGlsZCkgIT09IDEpIHtcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBlbGVtLmNoaWxkcmVuWzFdO1xuICAgICAgICBzaWJsaW5nLnByZXYgPSBjaGlsZDtcbiAgICAgICAgY2hpbGQubmV4dCA9IHNpYmxpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZC5uZXh0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLnByZXBlbmRDaGlsZCA9IHByZXBlbmRDaGlsZDtcbi8qKlxuICogUHJlcGVuZCBhbiBlbGVtZW50IGJlZm9yZSBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSBlbGVtIFRoZSBlbGVtZW50IHRvIHByZXBlbmQgYmVmb3JlLlxuICogQHBhcmFtIHByZXYgVGhlIGVsZW1lbnQgYmUgYWRkZWQuXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmQoZWxlbSwgcHJldikge1xuICAgIHJlbW92ZUVsZW1lbnQocHJldik7XG4gICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50O1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkcyA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY2hpbGRzLnNwbGljZShjaGlsZHMuaW5kZXhPZihlbGVtKSwgMCwgcHJldik7XG4gICAgfVxuICAgIGlmIChlbGVtLnByZXYpIHtcbiAgICAgICAgZWxlbS5wcmV2Lm5leHQgPSBwcmV2O1xuICAgIH1cbiAgICBwcmV2LnBhcmVudCA9IHBhcmVudDtcbiAgICBwcmV2LnByZXYgPSBlbGVtLnByZXY7XG4gICAgcHJldi5uZXh0ID0gZWxlbTtcbiAgICBlbGVtLnByZXYgPSBwcmV2O1xufVxuZXhwb3J0cy5wcmVwZW5kID0gcHJlcGVuZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5maW5kQWxsID0gZXhwb3J0cy5leGlzdHNPbmUgPSBleHBvcnRzLmZpbmRPbmUgPSBleHBvcnRzLmZpbmRPbmVDaGlsZCA9IGV4cG9ydHMuZmluZCA9IGV4cG9ydHMuZmlsdGVyID0gdm9pZCAwO1xudmFyIHRhZ3R5cGVzXzEgPSByZXF1aXJlKFwiLi90YWd0eXBlc1wiKTtcbi8qKlxuICogU2VhcmNoIGEgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIGZvciBub2RlcyBwYXNzaW5nIGEgdGVzdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBzZWFyY2guIFdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBzZXQgaWYgaXQgbWF0Y2hlcy5cbiAqIEBwYXJhbSByZWN1cnNlIEFsc28gY29uc2lkZXIgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0gbGltaXQgTWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gcmV0dXJuLlxuICogQHJldHVybnMgQWxsIG5vZGVzIHBhc3NpbmcgYHRlc3RgLlxuICovXG5mdW5jdGlvbiBmaWx0ZXIodGVzdCwgbm9kZSwgcmVjdXJzZSwgbGltaXQpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlKSlcbiAgICAgICAgbm9kZSA9IFtub2RlXTtcbiAgICByZXR1cm4gZmluZCh0ZXN0LCBub2RlLCByZWN1cnNlLCBsaW1pdCk7XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbi8qKlxuICogU2VhcmNoIGFuIGFycmF5IG9mIG5vZGUgYW5kIGl0cyBjaGlsZHJlbiBmb3Igbm9kZXMgcGFzc2luZyBhIHRlc3QgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHRlc3QgRnVuY3Rpb24gdG8gdGVzdCBub2RlcyBvbi5cbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0byBzZWFyY2guXG4gKiBAcGFyYW0gcmVjdXJzZSBBbHNvIGNvbnNpZGVyIGNoaWxkIG5vZGVzLlxuICogQHBhcmFtIGxpbWl0IE1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIHJldHVybi5cbiAqIEByZXR1cm5zIEFsbCBub2RlcyBwYXNzaW5nIGB0ZXN0YC5cbiAqL1xuZnVuY3Rpb24gZmluZCh0ZXN0LCBub2RlcywgcmVjdXJzZSwgbGltaXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBub2Rlc18xID0gbm9kZXM7IF9pIDwgbm9kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVsZW0gPSBub2Rlc18xW19pXTtcbiAgICAgICAgaWYgKHRlc3QoZWxlbSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgaWYgKC0tbGltaXQgPD0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzZSAmJiB0YWd0eXBlc18xLmhhc0NoaWxkcmVuKGVsZW0pICYmIGVsZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZmluZCh0ZXN0LCBlbGVtLmNoaWxkcmVuLCByZWN1cnNlLCBsaW1pdCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGxpbWl0IC09IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgZWxlbWVudCBpbnNpZGUgb2YgYW4gYXJyYXkgdGhhdCBtYXRjaGVzIGEgdGVzdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBub2RlIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyBgdGVzdGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmRPbmVDaGlsZCh0ZXN0LCBub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5maW5kKHRlc3QpO1xufVxuZXhwb3J0cy5maW5kT25lQ2hpbGQgPSBmaW5kT25lQ2hpbGQ7XG4vKipcbiAqIEZpbmRzIG9uZSBlbGVtZW50IGluIGEgdHJlZSB0aGF0IHBhc3NlcyBhIHRlc3QuXG4gKlxuICogQHBhcmFtIHRlc3QgRnVuY3Rpb24gdG8gdGVzdCBub2RlcyBvbi5cbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0byBzZWFyY2guXG4gKiBAcGFyYW0gcmVjdXJzZSBBbHNvIGNvbnNpZGVyIGNoaWxkIG5vZGVzLlxuICogQHJldHVybnMgVGhlIGZpcnN0IGNoaWxkIG5vZGUgdGhhdCBwYXNzZXMgYHRlc3RgLlxuICovXG5mdW5jdGlvbiBmaW5kT25lKHRlc3QsIG5vZGVzLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIHZhciBlbGVtID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aCAmJiAhZWxlbTsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VkID0gbm9kZXNbaV07XG4gICAgICAgIGlmICghdGFndHlwZXNfMS5pc1RhZyhjaGVja2VkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGVzdChjaGVja2VkKSkge1xuICAgICAgICAgICAgZWxlbSA9IGNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVjdXJzZSAmJiBjaGVja2VkLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVsZW0gPSBmaW5kT25lKHRlc3QsIGNoZWNrZWQuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtO1xufVxuZXhwb3J0cy5maW5kT25lID0gZmluZE9uZTtcbi8qKlxuICogQHBhcmFtIHRlc3QgRnVuY3Rpb24gdG8gdGVzdCBub2RlcyBvbi5cbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0byBzZWFyY2guXG4gKiBAcmV0dXJucyBXaGV0aGVyIGEgdHJlZSBvZiBub2RlcyBjb250YWlucyBhdCBsZWFzdCBvbmUgbm9kZSBwYXNzaW5nIGEgdGVzdC5cbiAqL1xuZnVuY3Rpb24gZXhpc3RzT25lKHRlc3QsIG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLnNvbWUoZnVuY3Rpb24gKGNoZWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWcoY2hlY2tlZCkgJiZcbiAgICAgICAgICAgICh0ZXN0KGNoZWNrZWQpIHx8XG4gICAgICAgICAgICAgICAgKGNoZWNrZWQuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBleGlzdHNPbmUodGVzdCwgY2hlY2tlZC5jaGlsZHJlbikpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZXhpc3RzT25lID0gZXhpc3RzT25lO1xuLyoqXG4gKiBTZWFyY2ggYW5kIGFycmF5IG9mIG5vZGVzIGFuZCBpdHMgY2hpbGRyZW4gZm9yIG5vZGVzIHBhc3NpbmcgYSB0ZXN0IGZ1bmN0aW9uLlxuICpcbiAqIFNhbWUgYXMgYGZpbmRgLCBvbmx5IHdpdGggbGVzcyBvcHRpb25zLCBsZWFkaW5nIHRvIHJlZHVjZWQgY29tcGxleGl0eS5cbiAqXG4gKiBAcGFyYW0gdGVzdCBGdW5jdGlvbiB0byB0ZXN0IG5vZGVzIG9uLlxuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIEFsbCBub2RlcyBwYXNzaW5nIGB0ZXN0YC5cbiAqL1xuZnVuY3Rpb24gZmluZEFsbCh0ZXN0LCBub2Rlcykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHN0YWNrID0gbm9kZXMuZmlsdGVyKHRhZ3R5cGVzXzEuaXNUYWcpO1xuICAgIHZhciBlbGVtO1xuICAgIHdoaWxlICgoZWxlbSA9IHN0YWNrLnNoaWZ0KCkpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IChfYSA9IGVsZW0uY2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIodGFndHlwZXNfMS5pc1RhZyk7XG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGFjay51bnNoaWZ0LmFwcGx5KHN0YWNrLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlc3QoZWxlbSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZmluZEFsbCA9IGZpbmRBbGw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0VGV4dCA9IGV4cG9ydHMuZ2V0SW5uZXJIVE1MID0gZXhwb3J0cy5nZXRPdXRlckhUTUwgPSB2b2lkIDA7XG52YXIgdGFndHlwZXNfMSA9IHJlcXVpcmUoXCIuL3RhZ3R5cGVzXCIpO1xudmFyIGRvbV9zZXJpYWxpemVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRvbS1zZXJpYWxpemVyXCIpKTtcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBnZXQgdGhlIG91dGVyIEhUTUwgb2YuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBzZXJpYWxpemF0aW9uLlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgZG9tLXNlcmlhbGl6ZXJgIG1vZHVsZSBkaXJlY3RseS5cbiAqIEByZXR1cm5zIGBub2RlYCdzIG91dGVyIEhUTUwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTChub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvbV9zZXJpYWxpemVyXzEuZGVmYXVsdChub2RlLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2V0T3V0ZXJIVE1MID0gZ2V0T3V0ZXJIVE1MO1xuLyoqXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGdldCB0aGUgaW5uZXIgSFRNTCBvZi5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHNlcmlhbGl6YXRpb24uXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBkb20tc2VyaWFsaXplcmAgbW9kdWxlIGRpcmVjdGx5LlxuICogQHJldHVybnMgYG5vZGVgJ3MgaW5uZXIgSFRNTC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5uZXJIVE1MKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGFndHlwZXNfMS5oYXNDaGlsZHJlbihub2RlKVxuICAgICAgICA/IG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBnZXRPdXRlckhUTUwobm9kZSwgb3B0aW9ucyk7IH0pLmpvaW4oXCJcIilcbiAgICAgICAgOiBcIlwiO1xufVxuZXhwb3J0cy5nZXRJbm5lckhUTUwgPSBnZXRJbm5lckhUTUw7XG4vKipcbiAqIEdldCBhIG5vZGUncyBpbm5lciB0ZXh0LlxuICpcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gZ2V0IHRoZSBpbm5lciB0ZXh0IG9mLlxuICogQHJldHVybnMgYG5vZGVgJ3MgaW5uZXIgdGV4dC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dChub2RlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlLm1hcChnZXRUZXh0KS5qb2luKFwiXCIpO1xuICAgIGlmICh0YWd0eXBlc18xLmlzVGFnKG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5uYW1lID09PSBcImJyXCIgPyBcIlxcblwiIDogZ2V0VGV4dChub2RlLmNoaWxkcmVuKTtcbiAgICBpZiAodGFndHlwZXNfMS5pc0NEQVRBKG5vZGUpKVxuICAgICAgICByZXR1cm4gZ2V0VGV4dChub2RlLmNoaWxkcmVuKTtcbiAgICBpZiAodGFndHlwZXNfMS5pc1RleHQobm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlLmRhdGE7XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnRzLmdldFRleHQgPSBnZXRUZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc0NoaWxkcmVuID0gZXhwb3J0cy5pc0NvbW1lbnQgPSBleHBvcnRzLmlzVGV4dCA9IGV4cG9ydHMuaXNDREFUQSA9IGV4cG9ydHMuaXNUYWcgPSB2b2lkIDA7XG52YXIgZG9tZWxlbWVudHR5cGVfMSA9IHJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKTtcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbm9kZSBpcyBhIGBFbGVtZW50YCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVGFnKG5vZGUpIHtcbiAgICByZXR1cm4gZG9tZWxlbWVudHR5cGVfMS5pc1RhZyhub2RlKTtcbn1cbmV4cG9ydHMuaXNUYWcgPSBpc1RhZztcbi8qKlxuICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbm9kZSBpcyBhIGBOb2RlV2l0aENoaWxkcmVuYCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzQ0RBVEEobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiY2RhdGFcIiAvKiBDREFUQSAqLztcbn1cbmV4cG9ydHMuaXNDREFUQSA9IGlzQ0RBVEE7XG4vKipcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG5vZGUgaXMgYSBgRGF0YU5vZGVgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInRleHRcIiAvKiBUZXh0ICovO1xufVxuZXhwb3J0cy5pc1RleHQgPSBpc1RleHQ7XG4vKipcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG5vZGUgaXMgYSBgRGF0YU5vZGVgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNDb21tZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImNvbW1lbnRcIiAvKiBDb21tZW50ICovO1xufVxuZXhwb3J0cy5pc0NvbW1lbnQgPSBpc0NvbW1lbnQ7XG4vKipcbiAqIEBwYXJhbSBub2RlIE5vZGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG5vZGUgaXMgYSBgTm9kZVdpdGhDaGlsZHJlbmAgKGhhcyBjaGlsZHJlbiksIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBoYXNDaGlsZHJlbihub2RlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBcImNoaWxkcmVuXCIpO1xufVxuZXhwb3J0cy5oYXNDaGlsZHJlbiA9IGhhc0NoaWxkcmVuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5leHRFbGVtZW50U2libGluZyA9IGV4cG9ydHMuZ2V0TmFtZSA9IGV4cG9ydHMuaGFzQXR0cmliID0gZXhwb3J0cy5nZXRBdHRyaWJ1dGVWYWx1ZSA9IGV4cG9ydHMuZ2V0U2libGluZ3MgPSBleHBvcnRzLmdldFBhcmVudCA9IGV4cG9ydHMuZ2V0Q2hpbGRyZW4gPSB2b2lkIDA7XG52YXIgdGFndHlwZXNfMSA9IHJlcXVpcmUoXCIuL3RhZ3R5cGVzXCIpO1xudmFyIGVtcHR5QXJyYXkgPSBbXTtcbi8qKlxuICogR2V0IGEgbm9kZSdzIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSBlbGVtIE5vZGUgdG8gZ2V0IHRoZSBjaGlsZHJlbiBvZi5cbiAqIEByZXR1cm5zIGBlbGVtYCdzIGNoaWxkcmVuLCBvciBhbiBlbXB0eSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oZWxlbSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gZWxlbS5jaGlsZHJlbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZW1wdHlBcnJheTtcbn1cbmV4cG9ydHMuZ2V0Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbjtcbi8qKlxuICogR2V0IGEgbm9kZSdzIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0gZWxlbSBOb2RlIHRvIGdldCB0aGUgcGFyZW50IG9mLlxuICogQHJldHVybnMgYGVsZW1gJ3MgcGFyZW50IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0ucGFyZW50IHx8IG51bGw7XG59XG5leHBvcnRzLmdldFBhcmVudCA9IGdldFBhcmVudDtcbi8qKlxuICogR2V0cyBhbiBlbGVtZW50cyBzaWJsaW5ncywgaW5jbHVkaW5nIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBBdHRlbXB0cyB0byBnZXQgdGhlIGNoaWxkcmVuIHRocm91Z2ggdGhlIGVsZW1lbnQncyBwYXJlbnQgZmlyc3QuXG4gKiBJZiB3ZSBkb24ndCBoYXZlIGEgcGFyZW50ICh0aGUgZWxlbWVudCBpcyBhIHJvb3Qgbm9kZSksXG4gKiB3ZSB3YWxrIHRoZSBlbGVtZW50J3MgYHByZXZgICYgYG5leHRgIHRvIGdldCBhbGwgcmVtYWluaW5nIG5vZGVzLlxuICpcbiAqIEBwYXJhbSBlbGVtIEVsZW1lbnQgdG8gZ2V0IHRoZSBzaWJsaW5ncyBvZi5cbiAqIEByZXR1cm5zIGBlbGVtYCdzIHNpYmxpbmdzLlxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5ncyhlbGVtKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KGVsZW0pO1xuICAgIGlmIChwYXJlbnQgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHBhcmVudCk7XG4gICAgdmFyIHNpYmxpbmdzID0gW2VsZW1dO1xuICAgIHZhciBwcmV2ID0gZWxlbS5wcmV2LCBuZXh0ID0gZWxlbS5uZXh0O1xuICAgIHdoaWxlIChwcmV2ICE9IG51bGwpIHtcbiAgICAgICAgc2libGluZ3MudW5zaGlmdChwcmV2KTtcbiAgICAgICAgKF9hID0gcHJldiwgcHJldiA9IF9hLnByZXYpO1xuICAgIH1cbiAgICB3aGlsZSAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNpYmxpbmdzLnB1c2gobmV4dCk7XG4gICAgICAgIChfYiA9IG5leHQsIG5leHQgPSBfYi5uZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpYmxpbmdzO1xufVxuZXhwb3J0cy5nZXRTaWJsaW5ncyA9IGdldFNpYmxpbmdzO1xuLyoqXG4gKiBHZXRzIGFuIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIGVsZW0gRWxlbWVudCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIEF0dHJpYnV0ZSBuYW1lIHRvIHJldHJpZXZlLlxuICogQHJldHVybnMgVGhlIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWUsIG9yIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBlbGVtLmF0dHJpYnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtuYW1lXTtcbn1cbmV4cG9ydHMuZ2V0QXR0cmlidXRlVmFsdWUgPSBnZXRBdHRyaWJ1dGVWYWx1ZTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBoYXMgYW4gYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSBlbGVtIEVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcGFyYW0gbmFtZSBBdHRyaWJ1dGUgbmFtZSB0byBsb29rIGZvci5cbiAqIEByZXR1cm5zIFJldHVybnMgd2hldGhlciBgZWxlbWAgaGFzIHRoZSBhdHRyaWJ1dGUgYG5hbWVgLlxuICovXG5mdW5jdGlvbiBoYXNBdHRyaWIoZWxlbSwgbmFtZSkge1xuICAgIHJldHVybiAoZWxlbS5hdHRyaWJzICE9IG51bGwgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW0uYXR0cmlicywgbmFtZSkgJiZcbiAgICAgICAgZWxlbS5hdHRyaWJzW25hbWVdICE9IG51bGwpO1xufVxuZXhwb3J0cy5oYXNBdHRyaWIgPSBoYXNBdHRyaWI7XG4vKipcbiAqIEdldCB0aGUgdGFnIG5hbWUgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIG5hbWUgZm9yLlxuICogQHJldHVybnMgVGhlIHRhZyBuYW1lIG9mIGBlbGVtYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZShlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0ubmFtZTtcbn1cbmV4cG9ydHMuZ2V0TmFtZSA9IGdldE5hbWU7XG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgZWxlbWVudCBzaWJsaW5nIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0gZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIG5leHQgc2libGluZyBvZi5cbiAqIEByZXR1cm5zIGBlbGVtYCdzIG5leHQgc2libGluZyB0aGF0IGlzIGEgdGFnLlxuICovXG5mdW5jdGlvbiBuZXh0RWxlbWVudFNpYmxpbmcoZWxlbSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgbmV4dCA9IGVsZW0ubmV4dDtcbiAgICB3aGlsZSAobmV4dCAhPT0gbnVsbCAmJiAhdGFndHlwZXNfMS5pc1RhZyhuZXh0KSlcbiAgICAgICAgKF9hID0gbmV4dCwgbmV4dCA9IF9hLm5leHQpO1xuICAgIHJldHVybiBuZXh0O1xufVxuZXhwb3J0cy5uZXh0RWxlbWVudFNpYmxpbmcgPSBuZXh0RWxlbWVudFNpYmxpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlSFRNTCA9IGV4cG9ydHMuZGVjb2RlSFRNTFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlWE1MID0gdm9pZCAwO1xudmFyIGVudGl0aWVzX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL2VudGl0aWVzLmpzb25cIikpO1xudmFyIGxlZ2FjeV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy9sZWdhY3kuanNvblwiKSk7XG52YXIgeG1sX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL3htbC5qc29uXCIpKTtcbnZhciBkZWNvZGVfY29kZXBvaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZGVjb2RlX2NvZGVwb2ludFwiKSk7XG5leHBvcnRzLmRlY29kZVhNTCA9IGdldFN0cmljdERlY29kZXIoeG1sX2pzb25fMS5kZWZhdWx0KTtcbmV4cG9ydHMuZGVjb2RlSFRNTFN0cmljdCA9IGdldFN0cmljdERlY29kZXIoZW50aXRpZXNfanNvbl8xLmRlZmF1bHQpO1xuZnVuY3Rpb24gZ2V0U3RyaWN0RGVjb2RlcihtYXApIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1hcCkuam9pbihcInxcIik7XG4gICAgdmFyIHJlcGxhY2UgPSBnZXRSZXBsYWNlcihtYXApO1xuICAgIGtleXMgKz0gXCJ8I1t4WF1bXFxcXGRhLWZBLUZdK3wjXFxcXGQrXCI7XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIiYoPzpcIiArIGtleXMgKyBcIik7XCIsIFwiZ1wiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShyZSwgcmVwbGFjZSk7IH07XG59XG52YXIgc29ydGVyID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhIDwgYiA/IDEgOiAtMSk7IH07XG5leHBvcnRzLmRlY29kZUhUTUwgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZWdhY3kgPSBPYmplY3Qua2V5cyhsZWdhY3lfanNvbl8xLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVudGl0aWVzX2pzb25fMS5kZWZhdWx0KS5zb3J0KHNvcnRlcik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGVnYWN5W2pdID09PSBrZXlzW2ldKSB7XG4gICAgICAgICAgICBrZXlzW2ldICs9IFwiOz9cIjtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleXNbaV0gKz0gXCI7XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIiYoPzpcIiArIGtleXMuam9pbihcInxcIikgKyBcInwjW3hYXVtcXFxcZGEtZkEtRl0rOz98I1xcXFxkKzs/KVwiLCBcImdcIik7XG4gICAgdmFyIHJlcGxhY2UgPSBnZXRSZXBsYWNlcihlbnRpdGllc19qc29uXzEuZGVmYXVsdCk7XG4gICAgZnVuY3Rpb24gcmVwbGFjZXIoc3RyKSB7XG4gICAgICAgIGlmIChzdHIuc3Vic3RyKC0xKSAhPT0gXCI7XCIpXG4gICAgICAgICAgICBzdHIgKz0gXCI7XCI7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHN0cik7XG4gICAgfVxuICAgIC8vIFRPRE8gY29uc2lkZXIgY3JlYXRpbmcgYSBtZXJnZWQgbWFwXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUsIHJlcGxhY2VyKTsgfTtcbn0pKCk7XG5mdW5jdGlvbiBnZXRSZXBsYWNlcihtYXApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMSkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgc2Vjb25kQ2hhciA9IHN0ci5jaGFyQXQoMik7XG4gICAgICAgICAgICBpZiAoc2Vjb25kQ2hhciA9PT0gXCJYXCIgfHwgc2Vjb25kQ2hhciA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlX2NvZGVwb2ludF8xLmRlZmF1bHQocGFyc2VJbnQoc3RyLnN1YnN0cigzKSwgMTYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVfY29kZXBvaW50XzEuZGVmYXVsdChwYXJzZUludChzdHIuc3Vic3RyKDIpLCAxMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBbc3RyLnNsaWNlKDEsIC0xKV07XG4gICAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlY29kZV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy9kZWNvZGUuanNvblwiKSk7XG4vLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL2hlL2Jsb2IvbWFzdGVyL3NyYy9oZS5qcyNMOTQtTDExOVxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuICAgIGlmICgoY29kZVBvaW50ID49IDB4ZDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhkZmZmKSB8fCBjb2RlUG9pbnQgPiAweDEwZmZmZikge1xuICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgaW4gZGVjb2RlX2pzb25fMS5kZWZhdWx0KSB7XG4gICAgICAgIGNvZGVQb2ludCA9IGRlY29kZV9qc29uXzEuZGVmYXVsdFtjb2RlUG9pbnRdO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICBpZiAoY29kZVBvaW50ID4gMHhmZmZmKSB7XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKTtcbiAgICAgICAgY29kZVBvaW50ID0gMHhkYzAwIHwgKGNvZGVQb2ludCAmIDB4M2ZmKTtcbiAgICB9XG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICByZXR1cm4gb3V0cHV0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVjb2RlQ29kZVBvaW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVzY2FwZSA9IGV4cG9ydHMuZW5jb2RlSFRNTCA9IGV4cG9ydHMuZW5jb2RlWE1MID0gdm9pZCAwO1xudmFyIHhtbF9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy94bWwuanNvblwiKSk7XG52YXIgaW52ZXJzZVhNTCA9IGdldEludmVyc2VPYmooeG1sX2pzb25fMS5kZWZhdWx0KTtcbnZhciB4bWxSZXBsYWNlciA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlWE1MKTtcbmV4cG9ydHMuZW5jb2RlWE1MID0gZ2V0SW52ZXJzZShpbnZlcnNlWE1MLCB4bWxSZXBsYWNlcik7XG52YXIgZW50aXRpZXNfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hcHMvZW50aXRpZXMuanNvblwiKSk7XG52YXIgaW52ZXJzZUhUTUwgPSBnZXRJbnZlcnNlT2JqKGVudGl0aWVzX2pzb25fMS5kZWZhdWx0KTtcbnZhciBodG1sUmVwbGFjZXIgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZUhUTUwpO1xuZXhwb3J0cy5lbmNvZGVIVE1MID0gZ2V0SW52ZXJzZShpbnZlcnNlSFRNTCwgaHRtbFJlcGxhY2VyKTtcbmZ1bmN0aW9uIGdldEludmVyc2VPYmoob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChpbnZlcnNlLCBuYW1lKSB7XG4gICAgICAgIGludmVyc2Vbb2JqW25hbWVdXSA9IFwiJlwiICsgbmFtZSArIFwiO1wiO1xuICAgICAgICByZXR1cm4gaW52ZXJzZTtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZSkge1xuICAgIHZhciBzaW5nbGUgPSBbXTtcbiAgICB2YXIgbXVsdGlwbGUgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMoaW52ZXJzZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICBpZiAoay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZSB0byBzaW5nbGUgYXJyYXlcbiAgICAgICAgICAgIHNpbmdsZS5wdXNoKFwiXFxcXFwiICsgayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgdmFsdWUgdG8gbXVsdGlwbGUgYXJyYXlcbiAgICAgICAgICAgIG11bHRpcGxlLnB1c2goayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIHJhbmdlcyB0byBzaW5nbGUgY2hhcmFjdGVycy5cbiAgICBzaW5nbGUuc29ydCgpO1xuICAgIGZvciAodmFyIHN0YXJ0ID0gMDsgc3RhcnQgPCBzaW5nbGUubGVuZ3RoIC0gMTsgc3RhcnQrKykge1xuICAgICAgICAvLyBGaW5kIHRoZSBlbmQgb2YgYSBydW4gb2YgY2hhcmFjdGVyc1xuICAgICAgICB2YXIgZW5kID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlIChlbmQgPCBzaW5nbGUubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgc2luZ2xlW2VuZF0uY2hhckNvZGVBdCgxKSArIDEgPT09IHNpbmdsZVtlbmQgKyAxXS5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgICAgICBlbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY291bnQgPSAxICsgZW5kIC0gc3RhcnQ7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcmVwbGFjZSBhdCBsZWFzdCB0aHJlZSBjaGFyYWN0ZXJzXG4gICAgICAgIGlmIChjb3VudCA8IDMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc2luZ2xlLnNwbGljZShzdGFydCwgY291bnQsIHNpbmdsZVtzdGFydF0gKyBcIi1cIiArIHNpbmdsZVtlbmRdKTtcbiAgICB9XG4gICAgbXVsdGlwbGUudW5zaGlmdChcIltcIiArIHNpbmdsZS5qb2luKFwiXCIpICsgXCJdXCIpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKG11bHRpcGxlLmpvaW4oXCJ8XCIpLCBcImdcIik7XG59XG52YXIgcmVOb25BU0NJSSA9IC8oPzpbXFx4ODAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvZztcbmZ1bmN0aW9uIHNpbmdsZUNoYXJSZXBsYWNlcihjKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICByZXR1cm4gXCImI3hcIiArIGMuY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIjtcIjtcbn1cbmZ1bmN0aW9uIGdldEludmVyc2UoaW52ZXJzZSwgcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gaW52ZXJzZVtuYW1lXTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlTm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG4gICAgfTtcbn1cbnZhciByZVhtbENoYXJzID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VYTUwpO1xuZnVuY3Rpb24gZXNjYXBlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YVxuICAgICAgICAucmVwbGFjZShyZVhtbENoYXJzLCBzaW5nbGVDaGFyUmVwbGFjZXIpXG4gICAgICAgIC5yZXBsYWNlKHJlTm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG59XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVYTUxTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw1U3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDUgPSBleHBvcnRzLmRlY29kZUhUTUw0ID0gZXhwb3J0cy5kZWNvZGVIVE1MU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MID0gZXhwb3J0cy5kZWNvZGVYTUwgPSBleHBvcnRzLmVuY29kZUhUTUw1ID0gZXhwb3J0cy5lbmNvZGVIVE1MNCA9IGV4cG9ydHMuZXNjYXBlID0gZXhwb3J0cy5lbmNvZGVIVE1MID0gZXhwb3J0cy5lbmNvZGVYTUwgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG52YXIgZGVjb2RlXzEgPSByZXF1aXJlKFwiLi9kZWNvZGVcIik7XG52YXIgZW5jb2RlXzEgPSByZXF1aXJlKFwiLi9lbmNvZGVcIik7XG4vKipcbiAqIERlY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZGVjb2RlLlxuICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGRlY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGRhdGEsIGxldmVsKSB7XG4gICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGRlY29kZV8xLmRlY29kZVhNTCA6IGRlY29kZV8xLmRlY29kZUhUTUwpKGRhdGEpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIERlY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy4gRG9lcyBub3QgYWxsb3cgbWlzc2luZyB0cmFpbGluZyBzZW1pY29sb25zIGZvciBlbnRpdGllcy5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZGVjb2RlLlxuICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGRlY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlU3RyaWN0KGRhdGEsIGxldmVsKSB7XG4gICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGRlY29kZV8xLmRlY29kZVhNTCA6IGRlY29kZV8xLmRlY29kZUhUTUxTdHJpY3QpKGRhdGEpO1xufVxuZXhwb3J0cy5kZWNvZGVTdHJpY3QgPSBkZWNvZGVTdHJpY3Q7XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGVuY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEsIGxldmVsKSB7XG4gICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGVuY29kZV8xLmVuY29kZVhNTCA6IGVuY29kZV8xLmVuY29kZUhUTUwpKGRhdGEpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG52YXIgZW5jb2RlXzIgPSByZXF1aXJlKFwiLi9lbmNvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVYTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZVhNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlc2NhcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVzY2FwZTsgfSB9KTtcbi8vIExlZ2FjeSBhbGlhc2VzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUw1XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVIVE1MOyB9IH0pO1xudmFyIGRlY29kZV8yID0gcmVxdWlyZShcIi4vZGVjb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlWE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVYTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTFN0cmljdDsgfSB9KTtcbi8vIExlZ2FjeSBhbGlhc2VzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDRTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNVN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTFN0cmljdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVhNTFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlWE1MOyB9IH0pO1xuIiwibW9kdWxlLmV4cG9ydHM9e1wiMFwiOjY1NTMzLFwiMTI4XCI6ODM2NCxcIjEzMFwiOjgyMTgsXCIxMzFcIjo0MDIsXCIxMzJcIjo4MjIyLFwiMTMzXCI6ODIzMCxcIjEzNFwiOjgyMjQsXCIxMzVcIjo4MjI1LFwiMTM2XCI6NzEwLFwiMTM3XCI6ODI0MCxcIjEzOFwiOjM1MixcIjEzOVwiOjgyNDksXCIxNDBcIjozMzgsXCIxNDJcIjozODEsXCIxNDVcIjo4MjE2LFwiMTQ2XCI6ODIxNyxcIjE0N1wiOjgyMjAsXCIxNDhcIjo4MjIxLFwiMTQ5XCI6ODIyNixcIjE1MFwiOjgyMTEsXCIxNTFcIjo4MjEyLFwiMTUyXCI6NzMyLFwiMTUzXCI6ODQ4MixcIjE1NFwiOjM1MyxcIjE1NVwiOjgyNTAsXCIxNTZcIjozMzksXCIxNThcIjozODIsXCIxNTlcIjozNzZ9XG4iLCJtb2R1bGUuZXhwb3J0cz17XCJBYWN1dGVcIjpcIsOBXCIsXCJhYWN1dGVcIjpcIsOhXCIsXCJBYnJldmVcIjpcIsSCXCIsXCJhYnJldmVcIjpcIsSDXCIsXCJhY1wiOlwi4oi+XCIsXCJhY2RcIjpcIuKIv1wiLFwiYWNFXCI6XCLiiL7Ms1wiLFwiQWNpcmNcIjpcIsOCXCIsXCJhY2lyY1wiOlwiw6JcIixcImFjdXRlXCI6XCLCtFwiLFwiQWN5XCI6XCLQkFwiLFwiYWN5XCI6XCLQsFwiLFwiQUVsaWdcIjpcIsOGXCIsXCJhZWxpZ1wiOlwiw6ZcIixcImFmXCI6XCLigaFcIixcIkFmclwiOlwi8J2UhFwiLFwiYWZyXCI6XCLwnZSeXCIsXCJBZ3JhdmVcIjpcIsOAXCIsXCJhZ3JhdmVcIjpcIsOgXCIsXCJhbGVmc3ltXCI6XCLihLVcIixcImFsZXBoXCI6XCLihLVcIixcIkFscGhhXCI6XCLOkVwiLFwiYWxwaGFcIjpcIs6xXCIsXCJBbWFjclwiOlwixIBcIixcImFtYWNyXCI6XCLEgVwiLFwiYW1hbGdcIjpcIuKov1wiLFwiYW1wXCI6XCImXCIsXCJBTVBcIjpcIiZcIixcImFuZGFuZFwiOlwi4qmVXCIsXCJBbmRcIjpcIuKpk1wiLFwiYW5kXCI6XCLiiKdcIixcImFuZGRcIjpcIuKpnFwiLFwiYW5kc2xvcGVcIjpcIuKpmFwiLFwiYW5kdlwiOlwi4qmaXCIsXCJhbmdcIjpcIuKIoFwiLFwiYW5nZVwiOlwi4qakXCIsXCJhbmdsZVwiOlwi4oigXCIsXCJhbmdtc2RhYVwiOlwi4qaoXCIsXCJhbmdtc2RhYlwiOlwi4qapXCIsXCJhbmdtc2RhY1wiOlwi4qaqXCIsXCJhbmdtc2RhZFwiOlwi4qarXCIsXCJhbmdtc2RhZVwiOlwi4qasXCIsXCJhbmdtc2RhZlwiOlwi4qatXCIsXCJhbmdtc2RhZ1wiOlwi4qauXCIsXCJhbmdtc2RhaFwiOlwi4qavXCIsXCJhbmdtc2RcIjpcIuKIoVwiLFwiYW5ncnRcIjpcIuKIn1wiLFwiYW5ncnR2YlwiOlwi4oq+XCIsXCJhbmdydHZiZFwiOlwi4qadXCIsXCJhbmdzcGhcIjpcIuKIolwiLFwiYW5nc3RcIjpcIsOFXCIsXCJhbmd6YXJyXCI6XCLijbxcIixcIkFvZ29uXCI6XCLEhFwiLFwiYW9nb25cIjpcIsSFXCIsXCJBb3BmXCI6XCLwnZS4XCIsXCJhb3BmXCI6XCLwnZWSXCIsXCJhcGFjaXJcIjpcIuKpr1wiLFwiYXBcIjpcIuKJiFwiLFwiYXBFXCI6XCLiqbBcIixcImFwZVwiOlwi4omKXCIsXCJhcGlkXCI6XCLiiYtcIixcImFwb3NcIjpcIidcIixcIkFwcGx5RnVuY3Rpb25cIjpcIuKBoVwiLFwiYXBwcm94XCI6XCLiiYhcIixcImFwcHJveGVxXCI6XCLiiYpcIixcIkFyaW5nXCI6XCLDhVwiLFwiYXJpbmdcIjpcIsOlXCIsXCJBc2NyXCI6XCLwnZKcXCIsXCJhc2NyXCI6XCLwnZK2XCIsXCJBc3NpZ25cIjpcIuKJlFwiLFwiYXN0XCI6XCIqXCIsXCJhc3ltcFwiOlwi4omIXCIsXCJhc3ltcGVxXCI6XCLiiY1cIixcIkF0aWxkZVwiOlwiw4NcIixcImF0aWxkZVwiOlwiw6NcIixcIkF1bWxcIjpcIsOEXCIsXCJhdW1sXCI6XCLDpFwiLFwiYXdjb25pbnRcIjpcIuKIs1wiLFwiYXdpbnRcIjpcIuKokVwiLFwiYmFja2NvbmdcIjpcIuKJjFwiLFwiYmFja2Vwc2lsb25cIjpcIs+2XCIsXCJiYWNrcHJpbWVcIjpcIuKAtVwiLFwiYmFja3NpbVwiOlwi4oi9XCIsXCJiYWNrc2ltZXFcIjpcIuKLjVwiLFwiQmFja3NsYXNoXCI6XCLiiJZcIixcIkJhcnZcIjpcIuKrp1wiLFwiYmFydmVlXCI6XCLiir1cIixcImJhcndlZFwiOlwi4oyFXCIsXCJCYXJ3ZWRcIjpcIuKMhlwiLFwiYmFyd2VkZ2VcIjpcIuKMhVwiLFwiYmJya1wiOlwi4o61XCIsXCJiYnJrdGJya1wiOlwi4o62XCIsXCJiY29uZ1wiOlwi4omMXCIsXCJCY3lcIjpcItCRXCIsXCJiY3lcIjpcItCxXCIsXCJiZHF1b1wiOlwi4oCeXCIsXCJiZWNhdXNcIjpcIuKItVwiLFwiYmVjYXVzZVwiOlwi4oi1XCIsXCJCZWNhdXNlXCI6XCLiiLVcIixcImJlbXB0eXZcIjpcIuKmsFwiLFwiYmVwc2lcIjpcIs+2XCIsXCJiZXJub3VcIjpcIuKErFwiLFwiQmVybm91bGxpc1wiOlwi4oSsXCIsXCJCZXRhXCI6XCLOklwiLFwiYmV0YVwiOlwizrJcIixcImJldGhcIjpcIuKEtlwiLFwiYmV0d2VlblwiOlwi4omsXCIsXCJCZnJcIjpcIvCdlIVcIixcImJmclwiOlwi8J2Un1wiLFwiYmlnY2FwXCI6XCLii4JcIixcImJpZ2NpcmNcIjpcIuKXr1wiLFwiYmlnY3VwXCI6XCLii4NcIixcImJpZ29kb3RcIjpcIuKogFwiLFwiYmlnb3BsdXNcIjpcIuKogVwiLFwiYmlnb3RpbWVzXCI6XCLiqIJcIixcImJpZ3NxY3VwXCI6XCLiqIZcIixcImJpZ3N0YXJcIjpcIuKYhVwiLFwiYmlndHJpYW5nbGVkb3duXCI6XCLilr1cIixcImJpZ3RyaWFuZ2xldXBcIjpcIuKWs1wiLFwiYmlndXBsdXNcIjpcIuKohFwiLFwiYmlndmVlXCI6XCLii4FcIixcImJpZ3dlZGdlXCI6XCLii4BcIixcImJrYXJvd1wiOlwi4qSNXCIsXCJibGFja2xvemVuZ2VcIjpcIuKnq1wiLFwiYmxhY2tzcXVhcmVcIjpcIuKWqlwiLFwiYmxhY2t0cmlhbmdsZVwiOlwi4pa0XCIsXCJibGFja3RyaWFuZ2xlZG93blwiOlwi4pa+XCIsXCJibGFja3RyaWFuZ2xlbGVmdFwiOlwi4peCXCIsXCJibGFja3RyaWFuZ2xlcmlnaHRcIjpcIuKWuFwiLFwiYmxhbmtcIjpcIuKQo1wiLFwiYmxrMTJcIjpcIuKWklwiLFwiYmxrMTRcIjpcIuKWkVwiLFwiYmxrMzRcIjpcIuKWk1wiLFwiYmxvY2tcIjpcIuKWiFwiLFwiYm5lXCI6XCI94oOlXCIsXCJibmVxdWl2XCI6XCLiiaHig6VcIixcImJOb3RcIjpcIuKrrVwiLFwiYm5vdFwiOlwi4oyQXCIsXCJCb3BmXCI6XCLwnZS5XCIsXCJib3BmXCI6XCLwnZWTXCIsXCJib3RcIjpcIuKKpVwiLFwiYm90dG9tXCI6XCLiiqVcIixcImJvd3RpZVwiOlwi4ouIXCIsXCJib3hib3hcIjpcIuKniVwiLFwiYm94ZGxcIjpcIuKUkFwiLFwiYm94ZExcIjpcIuKVlVwiLFwiYm94RGxcIjpcIuKVllwiLFwiYm94RExcIjpcIuKVl1wiLFwiYm94ZHJcIjpcIuKUjFwiLFwiYm94ZFJcIjpcIuKVklwiLFwiYm94RHJcIjpcIuKVk1wiLFwiYm94RFJcIjpcIuKVlFwiLFwiYm94aFwiOlwi4pSAXCIsXCJib3hIXCI6XCLilZBcIixcImJveGhkXCI6XCLilKxcIixcImJveEhkXCI6XCLilaRcIixcImJveGhEXCI6XCLilaVcIixcImJveEhEXCI6XCLilaZcIixcImJveGh1XCI6XCLilLRcIixcImJveEh1XCI6XCLiladcIixcImJveGhVXCI6XCLilahcIixcImJveEhVXCI6XCLilalcIixcImJveG1pbnVzXCI6XCLiip9cIixcImJveHBsdXNcIjpcIuKKnlwiLFwiYm94dGltZXNcIjpcIuKKoFwiLFwiYm94dWxcIjpcIuKUmFwiLFwiYm94dUxcIjpcIuKVm1wiLFwiYm94VWxcIjpcIuKVnFwiLFwiYm94VUxcIjpcIuKVnVwiLFwiYm94dXJcIjpcIuKUlFwiLFwiYm94dVJcIjpcIuKVmFwiLFwiYm94VXJcIjpcIuKVmVwiLFwiYm94VVJcIjpcIuKVmlwiLFwiYm94dlwiOlwi4pSCXCIsXCJib3hWXCI6XCLilZFcIixcImJveHZoXCI6XCLilLxcIixcImJveHZIXCI6XCLilapcIixcImJveFZoXCI6XCLilatcIixcImJveFZIXCI6XCLilaxcIixcImJveHZsXCI6XCLilKRcIixcImJveHZMXCI6XCLilaFcIixcImJveFZsXCI6XCLilaJcIixcImJveFZMXCI6XCLilaNcIixcImJveHZyXCI6XCLilJxcIixcImJveHZSXCI6XCLilZ5cIixcImJveFZyXCI6XCLilZ9cIixcImJveFZSXCI6XCLilaBcIixcImJwcmltZVwiOlwi4oC1XCIsXCJicmV2ZVwiOlwiy5hcIixcIkJyZXZlXCI6XCLLmFwiLFwiYnJ2YmFyXCI6XCLCplwiLFwiYnNjclwiOlwi8J2St1wiLFwiQnNjclwiOlwi4oSsXCIsXCJic2VtaVwiOlwi4oGPXCIsXCJic2ltXCI6XCLiiL1cIixcImJzaW1lXCI6XCLii41cIixcImJzb2xiXCI6XCLip4VcIixcImJzb2xcIjpcIlxcXFxcIixcImJzb2xoc3ViXCI6XCLin4hcIixcImJ1bGxcIjpcIuKAolwiLFwiYnVsbGV0XCI6XCLigKJcIixcImJ1bXBcIjpcIuKJjlwiLFwiYnVtcEVcIjpcIuKqrlwiLFwiYnVtcGVcIjpcIuKJj1wiLFwiQnVtcGVxXCI6XCLiiY5cIixcImJ1bXBlcVwiOlwi4omPXCIsXCJDYWN1dGVcIjpcIsSGXCIsXCJjYWN1dGVcIjpcIsSHXCIsXCJjYXBhbmRcIjpcIuKphFwiLFwiY2FwYnJjdXBcIjpcIuKpiVwiLFwiY2FwY2FwXCI6XCLiqYtcIixcImNhcFwiOlwi4oipXCIsXCJDYXBcIjpcIuKLklwiLFwiY2FwY3VwXCI6XCLiqYdcIixcImNhcGRvdFwiOlwi4qmAXCIsXCJDYXBpdGFsRGlmZmVyZW50aWFsRFwiOlwi4oWFXCIsXCJjYXBzXCI6XCLiiKnvuIBcIixcImNhcmV0XCI6XCLigYFcIixcImNhcm9uXCI6XCLLh1wiLFwiQ2F5bGV5c1wiOlwi4oStXCIsXCJjY2Fwc1wiOlwi4qmNXCIsXCJDY2Fyb25cIjpcIsSMXCIsXCJjY2Fyb25cIjpcIsSNXCIsXCJDY2VkaWxcIjpcIsOHXCIsXCJjY2VkaWxcIjpcIsOnXCIsXCJDY2lyY1wiOlwixIhcIixcImNjaXJjXCI6XCLEiVwiLFwiQ2NvbmludFwiOlwi4oiwXCIsXCJjY3Vwc1wiOlwi4qmMXCIsXCJjY3Vwc3NtXCI6XCLiqZBcIixcIkNkb3RcIjpcIsSKXCIsXCJjZG90XCI6XCLEi1wiLFwiY2VkaWxcIjpcIsK4XCIsXCJDZWRpbGxhXCI6XCLCuFwiLFwiY2VtcHR5dlwiOlwi4qayXCIsXCJjZW50XCI6XCLColwiLFwiY2VudGVyZG90XCI6XCLCt1wiLFwiQ2VudGVyRG90XCI6XCLCt1wiLFwiY2ZyXCI6XCLwnZSgXCIsXCJDZnJcIjpcIuKErVwiLFwiQ0hjeVwiOlwi0KdcIixcImNoY3lcIjpcItGHXCIsXCJjaGVja1wiOlwi4pyTXCIsXCJjaGVja21hcmtcIjpcIuKck1wiLFwiQ2hpXCI6XCLOp1wiLFwiY2hpXCI6XCLPh1wiLFwiY2lyY1wiOlwiy4ZcIixcImNpcmNlcVwiOlwi4omXXCIsXCJjaXJjbGVhcnJvd2xlZnRcIjpcIuKGulwiLFwiY2lyY2xlYXJyb3dyaWdodFwiOlwi4oa7XCIsXCJjaXJjbGVkYXN0XCI6XCLiiptcIixcImNpcmNsZWRjaXJjXCI6XCLiippcIixcImNpcmNsZWRkYXNoXCI6XCLiip1cIixcIkNpcmNsZURvdFwiOlwi4oqZXCIsXCJjaXJjbGVkUlwiOlwiwq5cIixcImNpcmNsZWRTXCI6XCLik4hcIixcIkNpcmNsZU1pbnVzXCI6XCLiipZcIixcIkNpcmNsZVBsdXNcIjpcIuKKlVwiLFwiQ2lyY2xlVGltZXNcIjpcIuKKl1wiLFwiY2lyXCI6XCLil4tcIixcImNpckVcIjpcIuKng1wiLFwiY2lyZVwiOlwi4omXXCIsXCJjaXJmbmludFwiOlwi4qiQXCIsXCJjaXJtaWRcIjpcIuKrr1wiLFwiY2lyc2NpclwiOlwi4qeCXCIsXCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIuKIslwiLFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6XCLigJ1cIixcIkNsb3NlQ3VybHlRdW90ZVwiOlwi4oCZXCIsXCJjbHVic1wiOlwi4pmjXCIsXCJjbHVic3VpdFwiOlwi4pmjXCIsXCJjb2xvblwiOlwiOlwiLFwiQ29sb25cIjpcIuKIt1wiLFwiQ29sb25lXCI6XCLiqbRcIixcImNvbG9uZVwiOlwi4omUXCIsXCJjb2xvbmVxXCI6XCLiiZRcIixcImNvbW1hXCI6XCIsXCIsXCJjb21tYXRcIjpcIkBcIixcImNvbXBcIjpcIuKIgVwiLFwiY29tcGZuXCI6XCLiiJhcIixcImNvbXBsZW1lbnRcIjpcIuKIgVwiLFwiY29tcGxleGVzXCI6XCLihIJcIixcImNvbmdcIjpcIuKJhVwiLFwiY29uZ2RvdFwiOlwi4qmtXCIsXCJDb25ncnVlbnRcIjpcIuKJoVwiLFwiY29uaW50XCI6XCLiiK5cIixcIkNvbmludFwiOlwi4oivXCIsXCJDb250b3VySW50ZWdyYWxcIjpcIuKIrlwiLFwiY29wZlwiOlwi8J2VlFwiLFwiQ29wZlwiOlwi4oSCXCIsXCJjb3Byb2RcIjpcIuKIkFwiLFwiQ29wcm9kdWN0XCI6XCLiiJBcIixcImNvcHlcIjpcIsKpXCIsXCJDT1BZXCI6XCLCqVwiLFwiY29weXNyXCI6XCLihJdcIixcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIuKIs1wiLFwiY3JhcnJcIjpcIuKGtVwiLFwiY3Jvc3NcIjpcIuKcl1wiLFwiQ3Jvc3NcIjpcIuKor1wiLFwiQ3NjclwiOlwi8J2SnlwiLFwiY3NjclwiOlwi8J2SuFwiLFwiY3N1YlwiOlwi4quPXCIsXCJjc3ViZVwiOlwi4quRXCIsXCJjc3VwXCI6XCLiq5BcIixcImNzdXBlXCI6XCLiq5JcIixcImN0ZG90XCI6XCLii69cIixcImN1ZGFycmxcIjpcIuKkuFwiLFwiY3VkYXJyclwiOlwi4qS1XCIsXCJjdWVwclwiOlwi4oueXCIsXCJjdWVzY1wiOlwi4oufXCIsXCJjdWxhcnJcIjpcIuKGtlwiLFwiY3VsYXJycFwiOlwi4qS9XCIsXCJjdXBicmNhcFwiOlwi4qmIXCIsXCJjdXBjYXBcIjpcIuKphlwiLFwiQ3VwQ2FwXCI6XCLiiY1cIixcImN1cFwiOlwi4oiqXCIsXCJDdXBcIjpcIuKLk1wiLFwiY3VwY3VwXCI6XCLiqYpcIixcImN1cGRvdFwiOlwi4oqNXCIsXCJjdXBvclwiOlwi4qmFXCIsXCJjdXBzXCI6XCLiiKrvuIBcIixcImN1cmFyclwiOlwi4oa3XCIsXCJjdXJhcnJtXCI6XCLipLxcIixcImN1cmx5ZXFwcmVjXCI6XCLii55cIixcImN1cmx5ZXFzdWNjXCI6XCLii59cIixcImN1cmx5dmVlXCI6XCLii45cIixcImN1cmx5d2VkZ2VcIjpcIuKLj1wiLFwiY3VycmVuXCI6XCLCpFwiLFwiY3VydmVhcnJvd2xlZnRcIjpcIuKGtlwiLFwiY3VydmVhcnJvd3JpZ2h0XCI6XCLihrdcIixcImN1dmVlXCI6XCLii45cIixcImN1d2VkXCI6XCLii49cIixcImN3Y29uaW50XCI6XCLiiLJcIixcImN3aW50XCI6XCLiiLFcIixcImN5bGN0eVwiOlwi4oytXCIsXCJkYWdnZXJcIjpcIuKAoFwiLFwiRGFnZ2VyXCI6XCLigKFcIixcImRhbGV0aFwiOlwi4oS4XCIsXCJkYXJyXCI6XCLihpNcIixcIkRhcnJcIjpcIuKGoVwiLFwiZEFyclwiOlwi4oeTXCIsXCJkYXNoXCI6XCLigJBcIixcIkRhc2h2XCI6XCLiq6RcIixcImRhc2h2XCI6XCLiiqNcIixcImRia2Fyb3dcIjpcIuKkj1wiLFwiZGJsYWNcIjpcIsudXCIsXCJEY2Fyb25cIjpcIsSOXCIsXCJkY2Fyb25cIjpcIsSPXCIsXCJEY3lcIjpcItCUXCIsXCJkY3lcIjpcItC0XCIsXCJkZGFnZ2VyXCI6XCLigKFcIixcImRkYXJyXCI6XCLih4pcIixcIkREXCI6XCLihYVcIixcImRkXCI6XCLihYZcIixcIkREb3RyYWhkXCI6XCLipJFcIixcImRkb3RzZXFcIjpcIuKpt1wiLFwiZGVnXCI6XCLCsFwiLFwiRGVsXCI6XCLiiIdcIixcIkRlbHRhXCI6XCLOlFwiLFwiZGVsdGFcIjpcIs60XCIsXCJkZW1wdHl2XCI6XCLiprFcIixcImRmaXNodFwiOlwi4qW/XCIsXCJEZnJcIjpcIvCdlIdcIixcImRmclwiOlwi8J2UoVwiLFwiZEhhclwiOlwi4qWlXCIsXCJkaGFybFwiOlwi4oeDXCIsXCJkaGFyclwiOlwi4oeCXCIsXCJEaWFjcml0aWNhbEFjdXRlXCI6XCLCtFwiLFwiRGlhY3JpdGljYWxEb3RcIjpcIsuZXCIsXCJEaWFjcml0aWNhbERvdWJsZUFjdXRlXCI6XCLLnVwiLFwiRGlhY3JpdGljYWxHcmF2ZVwiOlwiYFwiLFwiRGlhY3JpdGljYWxUaWxkZVwiOlwiy5xcIixcImRpYW1cIjpcIuKLhFwiLFwiZGlhbW9uZFwiOlwi4ouEXCIsXCJEaWFtb25kXCI6XCLii4RcIixcImRpYW1vbmRzdWl0XCI6XCLimaZcIixcImRpYW1zXCI6XCLimaZcIixcImRpZVwiOlwiwqhcIixcIkRpZmZlcmVudGlhbERcIjpcIuKFhlwiLFwiZGlnYW1tYVwiOlwiz51cIixcImRpc2luXCI6XCLii7JcIixcImRpdlwiOlwiw7dcIixcImRpdmlkZVwiOlwiw7dcIixcImRpdmlkZW9udGltZXNcIjpcIuKLh1wiLFwiZGl2b254XCI6XCLii4dcIixcIkRKY3lcIjpcItCCXCIsXCJkamN5XCI6XCLRklwiLFwiZGxjb3JuXCI6XCLijJ5cIixcImRsY3JvcFwiOlwi4oyNXCIsXCJkb2xsYXJcIjpcIiRcIixcIkRvcGZcIjpcIvCdlLtcIixcImRvcGZcIjpcIvCdlZVcIixcIkRvdFwiOlwiwqhcIixcImRvdFwiOlwiy5lcIixcIkRvdERvdFwiOlwi4oOcXCIsXCJkb3RlcVwiOlwi4omQXCIsXCJkb3RlcWRvdFwiOlwi4omRXCIsXCJEb3RFcXVhbFwiOlwi4omQXCIsXCJkb3RtaW51c1wiOlwi4oi4XCIsXCJkb3RwbHVzXCI6XCLiiJRcIixcImRvdHNxdWFyZVwiOlwi4oqhXCIsXCJkb3VibGViYXJ3ZWRnZVwiOlwi4oyGXCIsXCJEb3VibGVDb250b3VySW50ZWdyYWxcIjpcIuKIr1wiLFwiRG91YmxlRG90XCI6XCLCqFwiLFwiRG91YmxlRG93bkFycm93XCI6XCLih5NcIixcIkRvdWJsZUxlZnRBcnJvd1wiOlwi4oeQXCIsXCJEb3VibGVMZWZ0UmlnaHRBcnJvd1wiOlwi4oeUXCIsXCJEb3VibGVMZWZ0VGVlXCI6XCLiq6RcIixcIkRvdWJsZUxvbmdMZWZ0QXJyb3dcIjpcIuKfuFwiLFwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93XCI6XCLin7pcIixcIkRvdWJsZUxvbmdSaWdodEFycm93XCI6XCLin7lcIixcIkRvdWJsZVJpZ2h0QXJyb3dcIjpcIuKHklwiLFwiRG91YmxlUmlnaHRUZWVcIjpcIuKKqFwiLFwiRG91YmxlVXBBcnJvd1wiOlwi4oeRXCIsXCJEb3VibGVVcERvd25BcnJvd1wiOlwi4oeVXCIsXCJEb3VibGVWZXJ0aWNhbEJhclwiOlwi4oilXCIsXCJEb3duQXJyb3dCYXJcIjpcIuKkk1wiLFwiZG93bmFycm93XCI6XCLihpNcIixcIkRvd25BcnJvd1wiOlwi4oaTXCIsXCJEb3duYXJyb3dcIjpcIuKHk1wiLFwiRG93bkFycm93VXBBcnJvd1wiOlwi4oe1XCIsXCJEb3duQnJldmVcIjpcIsyRXCIsXCJkb3duZG93bmFycm93c1wiOlwi4oeKXCIsXCJkb3duaGFycG9vbmxlZnRcIjpcIuKHg1wiLFwiZG93bmhhcnBvb25yaWdodFwiOlwi4oeCXCIsXCJEb3duTGVmdFJpZ2h0VmVjdG9yXCI6XCLipZBcIixcIkRvd25MZWZ0VGVlVmVjdG9yXCI6XCLipZ5cIixcIkRvd25MZWZ0VmVjdG9yQmFyXCI6XCLipZZcIixcIkRvd25MZWZ0VmVjdG9yXCI6XCLihr1cIixcIkRvd25SaWdodFRlZVZlY3RvclwiOlwi4qWfXCIsXCJEb3duUmlnaHRWZWN0b3JCYXJcIjpcIuKll1wiLFwiRG93blJpZ2h0VmVjdG9yXCI6XCLih4FcIixcIkRvd25UZWVBcnJvd1wiOlwi4oanXCIsXCJEb3duVGVlXCI6XCLiiqRcIixcImRyYmthcm93XCI6XCLipJBcIixcImRyY29yblwiOlwi4oyfXCIsXCJkcmNyb3BcIjpcIuKMjFwiLFwiRHNjclwiOlwi8J2Sn1wiLFwiZHNjclwiOlwi8J2SuVwiLFwiRFNjeVwiOlwi0IVcIixcImRzY3lcIjpcItGVXCIsXCJkc29sXCI6XCLip7ZcIixcIkRzdHJva1wiOlwixJBcIixcImRzdHJva1wiOlwixJFcIixcImR0ZG90XCI6XCLii7FcIixcImR0cmlcIjpcIuKWv1wiLFwiZHRyaWZcIjpcIuKWvlwiLFwiZHVhcnJcIjpcIuKHtVwiLFwiZHVoYXJcIjpcIuKlr1wiLFwiZHdhbmdsZVwiOlwi4qamXCIsXCJEWmN5XCI6XCLQj1wiLFwiZHpjeVwiOlwi0Z9cIixcImR6aWdyYXJyXCI6XCLin79cIixcIkVhY3V0ZVwiOlwiw4lcIixcImVhY3V0ZVwiOlwiw6lcIixcImVhc3RlclwiOlwi4qmuXCIsXCJFY2Fyb25cIjpcIsSaXCIsXCJlY2Fyb25cIjpcIsSbXCIsXCJFY2lyY1wiOlwiw4pcIixcImVjaXJjXCI6XCLDqlwiLFwiZWNpclwiOlwi4omWXCIsXCJlY29sb25cIjpcIuKJlVwiLFwiRWN5XCI6XCLQrVwiLFwiZWN5XCI6XCLRjVwiLFwiZUREb3RcIjpcIuKpt1wiLFwiRWRvdFwiOlwixJZcIixcImVkb3RcIjpcIsSXXCIsXCJlRG90XCI6XCLiiZFcIixcImVlXCI6XCLihYdcIixcImVmRG90XCI6XCLiiZJcIixcIkVmclwiOlwi8J2UiFwiLFwiZWZyXCI6XCLwnZSiXCIsXCJlZ1wiOlwi4qqaXCIsXCJFZ3JhdmVcIjpcIsOIXCIsXCJlZ3JhdmVcIjpcIsOoXCIsXCJlZ3NcIjpcIuKqllwiLFwiZWdzZG90XCI6XCLiqphcIixcImVsXCI6XCLiqplcIixcIkVsZW1lbnRcIjpcIuKIiFwiLFwiZWxpbnRlcnNcIjpcIuKPp1wiLFwiZWxsXCI6XCLihJNcIixcImVsc1wiOlwi4qqVXCIsXCJlbHNkb3RcIjpcIuKql1wiLFwiRW1hY3JcIjpcIsSSXCIsXCJlbWFjclwiOlwixJNcIixcImVtcHR5XCI6XCLiiIVcIixcImVtcHR5c2V0XCI6XCLiiIVcIixcIkVtcHR5U21hbGxTcXVhcmVcIjpcIuKXu1wiLFwiZW1wdHl2XCI6XCLiiIVcIixcIkVtcHR5VmVyeVNtYWxsU3F1YXJlXCI6XCLilqtcIixcImVtc3AxM1wiOlwi4oCEXCIsXCJlbXNwMTRcIjpcIuKAhVwiLFwiZW1zcFwiOlwi4oCDXCIsXCJFTkdcIjpcIsWKXCIsXCJlbmdcIjpcIsWLXCIsXCJlbnNwXCI6XCLigIJcIixcIkVvZ29uXCI6XCLEmFwiLFwiZW9nb25cIjpcIsSZXCIsXCJFb3BmXCI6XCLwnZS8XCIsXCJlb3BmXCI6XCLwnZWWXCIsXCJlcGFyXCI6XCLii5VcIixcImVwYXJzbFwiOlwi4qejXCIsXCJlcGx1c1wiOlwi4qmxXCIsXCJlcHNpXCI6XCLOtVwiLFwiRXBzaWxvblwiOlwizpVcIixcImVwc2lsb25cIjpcIs61XCIsXCJlcHNpdlwiOlwiz7VcIixcImVxY2lyY1wiOlwi4omWXCIsXCJlcWNvbG9uXCI6XCLiiZVcIixcImVxc2ltXCI6XCLiiYJcIixcImVxc2xhbnRndHJcIjpcIuKqllwiLFwiZXFzbGFudGxlc3NcIjpcIuKqlVwiLFwiRXF1YWxcIjpcIuKptVwiLFwiZXF1YWxzXCI6XCI9XCIsXCJFcXVhbFRpbGRlXCI6XCLiiYJcIixcImVxdWVzdFwiOlwi4omfXCIsXCJFcXVpbGlicml1bVwiOlwi4oeMXCIsXCJlcXVpdlwiOlwi4omhXCIsXCJlcXVpdkREXCI6XCLiqbhcIixcImVxdnBhcnNsXCI6XCLip6VcIixcImVyYXJyXCI6XCLipbFcIixcImVyRG90XCI6XCLiiZNcIixcImVzY3JcIjpcIuKEr1wiLFwiRXNjclwiOlwi4oSwXCIsXCJlc2RvdFwiOlwi4omQXCIsXCJFc2ltXCI6XCLiqbNcIixcImVzaW1cIjpcIuKJglwiLFwiRXRhXCI6XCLOl1wiLFwiZXRhXCI6XCLOt1wiLFwiRVRIXCI6XCLDkFwiLFwiZXRoXCI6XCLDsFwiLFwiRXVtbFwiOlwiw4tcIixcImV1bWxcIjpcIsOrXCIsXCJldXJvXCI6XCLigqxcIixcImV4Y2xcIjpcIiFcIixcImV4aXN0XCI6XCLiiINcIixcIkV4aXN0c1wiOlwi4oiDXCIsXCJleHBlY3RhdGlvblwiOlwi4oSwXCIsXCJleHBvbmVudGlhbGVcIjpcIuKFh1wiLFwiRXhwb25lbnRpYWxFXCI6XCLihYdcIixcImZhbGxpbmdkb3RzZXFcIjpcIuKJklwiLFwiRmN5XCI6XCLQpFwiLFwiZmN5XCI6XCLRhFwiLFwiZmVtYWxlXCI6XCLimYBcIixcImZmaWxpZ1wiOlwi76yDXCIsXCJmZmxpZ1wiOlwi76yAXCIsXCJmZmxsaWdcIjpcIu+shFwiLFwiRmZyXCI6XCLwnZSJXCIsXCJmZnJcIjpcIvCdlKNcIixcImZpbGlnXCI6XCLvrIFcIixcIkZpbGxlZFNtYWxsU3F1YXJlXCI6XCLil7xcIixcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZVwiOlwi4paqXCIsXCJmamxpZ1wiOlwiZmpcIixcImZsYXRcIjpcIuKZrVwiLFwiZmxsaWdcIjpcIu+sglwiLFwiZmx0bnNcIjpcIuKWsVwiLFwiZm5vZlwiOlwixpJcIixcIkZvcGZcIjpcIvCdlL1cIixcImZvcGZcIjpcIvCdlZdcIixcImZvcmFsbFwiOlwi4oiAXCIsXCJGb3JBbGxcIjpcIuKIgFwiLFwiZm9ya1wiOlwi4ouUXCIsXCJmb3JrdlwiOlwi4quZXCIsXCJGb3VyaWVydHJmXCI6XCLihLFcIixcImZwYXJ0aW50XCI6XCLiqI1cIixcImZyYWMxMlwiOlwiwr1cIixcImZyYWMxM1wiOlwi4oWTXCIsXCJmcmFjMTRcIjpcIsK8XCIsXCJmcmFjMTVcIjpcIuKFlVwiLFwiZnJhYzE2XCI6XCLihZlcIixcImZyYWMxOFwiOlwi4oWbXCIsXCJmcmFjMjNcIjpcIuKFlFwiLFwiZnJhYzI1XCI6XCLihZZcIixcImZyYWMzNFwiOlwiwr5cIixcImZyYWMzNVwiOlwi4oWXXCIsXCJmcmFjMzhcIjpcIuKFnFwiLFwiZnJhYzQ1XCI6XCLihZhcIixcImZyYWM1NlwiOlwi4oWaXCIsXCJmcmFjNThcIjpcIuKFnVwiLFwiZnJhYzc4XCI6XCLihZ5cIixcImZyYXNsXCI6XCLigYRcIixcImZyb3duXCI6XCLijKJcIixcImZzY3JcIjpcIvCdkrtcIixcIkZzY3JcIjpcIuKEsVwiLFwiZ2FjdXRlXCI6XCLHtVwiLFwiR2FtbWFcIjpcIs6TXCIsXCJnYW1tYVwiOlwizrNcIixcIkdhbW1hZFwiOlwiz5xcIixcImdhbW1hZFwiOlwiz51cIixcImdhcFwiOlwi4qqGXCIsXCJHYnJldmVcIjpcIsSeXCIsXCJnYnJldmVcIjpcIsSfXCIsXCJHY2VkaWxcIjpcIsSiXCIsXCJHY2lyY1wiOlwixJxcIixcImdjaXJjXCI6XCLEnVwiLFwiR2N5XCI6XCLQk1wiLFwiZ2N5XCI6XCLQs1wiLFwiR2RvdFwiOlwixKBcIixcImdkb3RcIjpcIsShXCIsXCJnZVwiOlwi4omlXCIsXCJnRVwiOlwi4omnXCIsXCJnRWxcIjpcIuKqjFwiLFwiZ2VsXCI6XCLii5tcIixcImdlcVwiOlwi4omlXCIsXCJnZXFxXCI6XCLiiadcIixcImdlcXNsYW50XCI6XCLiqb5cIixcImdlc2NjXCI6XCLiqqlcIixcImdlc1wiOlwi4qm+XCIsXCJnZXNkb3RcIjpcIuKqgFwiLFwiZ2VzZG90b1wiOlwi4qqCXCIsXCJnZXNkb3RvbFwiOlwi4qqEXCIsXCJnZXNsXCI6XCLii5vvuIBcIixcImdlc2xlc1wiOlwi4qqUXCIsXCJHZnJcIjpcIvCdlIpcIixcImdmclwiOlwi8J2UpFwiLFwiZ2dcIjpcIuKJq1wiLFwiR2dcIjpcIuKLmVwiLFwiZ2dnXCI6XCLii5lcIixcImdpbWVsXCI6XCLihLdcIixcIkdKY3lcIjpcItCDXCIsXCJnamN5XCI6XCLRk1wiLFwiZ2xhXCI6XCLiqqVcIixcImdsXCI6XCLiibdcIixcImdsRVwiOlwi4qqSXCIsXCJnbGpcIjpcIuKqpFwiLFwiZ25hcFwiOlwi4qqKXCIsXCJnbmFwcHJveFwiOlwi4qqKXCIsXCJnbmVcIjpcIuKqiFwiLFwiZ25FXCI6XCLiialcIixcImduZXFcIjpcIuKqiFwiLFwiZ25lcXFcIjpcIuKJqVwiLFwiZ25zaW1cIjpcIuKLp1wiLFwiR29wZlwiOlwi8J2UvlwiLFwiZ29wZlwiOlwi8J2VmFwiLFwiZ3JhdmVcIjpcImBcIixcIkdyZWF0ZXJFcXVhbFwiOlwi4omlXCIsXCJHcmVhdGVyRXF1YWxMZXNzXCI6XCLii5tcIixcIkdyZWF0ZXJGdWxsRXF1YWxcIjpcIuKJp1wiLFwiR3JlYXRlckdyZWF0ZXJcIjpcIuKqolwiLFwiR3JlYXRlckxlc3NcIjpcIuKJt1wiLFwiR3JlYXRlclNsYW50RXF1YWxcIjpcIuKpvlwiLFwiR3JlYXRlclRpbGRlXCI6XCLiibNcIixcIkdzY3JcIjpcIvCdkqJcIixcImdzY3JcIjpcIuKEilwiLFwiZ3NpbVwiOlwi4omzXCIsXCJnc2ltZVwiOlwi4qqOXCIsXCJnc2ltbFwiOlwi4qqQXCIsXCJndGNjXCI6XCLiqqdcIixcImd0Y2lyXCI6XCLiqbpcIixcImd0XCI6XCI+XCIsXCJHVFwiOlwiPlwiLFwiR3RcIjpcIuKJq1wiLFwiZ3Rkb3RcIjpcIuKLl1wiLFwiZ3RsUGFyXCI6XCLippVcIixcImd0cXVlc3RcIjpcIuKpvFwiLFwiZ3RyYXBwcm94XCI6XCLiqoZcIixcImd0cmFyclwiOlwi4qW4XCIsXCJndHJkb3RcIjpcIuKLl1wiLFwiZ3RyZXFsZXNzXCI6XCLii5tcIixcImd0cmVxcWxlc3NcIjpcIuKqjFwiLFwiZ3RybGVzc1wiOlwi4om3XCIsXCJndHJzaW1cIjpcIuKJs1wiLFwiZ3ZlcnRuZXFxXCI6XCLiianvuIBcIixcImd2bkVcIjpcIuKJqe+4gFwiLFwiSGFjZWtcIjpcIsuHXCIsXCJoYWlyc3BcIjpcIuKAilwiLFwiaGFsZlwiOlwiwr1cIixcImhhbWlsdFwiOlwi4oSLXCIsXCJIQVJEY3lcIjpcItCqXCIsXCJoYXJkY3lcIjpcItGKXCIsXCJoYXJyY2lyXCI6XCLipYhcIixcImhhcnJcIjpcIuKGlFwiLFwiaEFyclwiOlwi4oeUXCIsXCJoYXJyd1wiOlwi4oatXCIsXCJIYXRcIjpcIl5cIixcImhiYXJcIjpcIuKEj1wiLFwiSGNpcmNcIjpcIsSkXCIsXCJoY2lyY1wiOlwixKVcIixcImhlYXJ0c1wiOlwi4pmlXCIsXCJoZWFydHN1aXRcIjpcIuKZpVwiLFwiaGVsbGlwXCI6XCLigKZcIixcImhlcmNvblwiOlwi4oq5XCIsXCJoZnJcIjpcIvCdlKVcIixcIkhmclwiOlwi4oSMXCIsXCJIaWxiZXJ0U3BhY2VcIjpcIuKEi1wiLFwiaGtzZWFyb3dcIjpcIuKkpVwiLFwiaGtzd2Fyb3dcIjpcIuKkplwiLFwiaG9hcnJcIjpcIuKHv1wiLFwiaG9tdGh0XCI6XCLiiLtcIixcImhvb2tsZWZ0YXJyb3dcIjpcIuKGqVwiLFwiaG9va3JpZ2h0YXJyb3dcIjpcIuKGqlwiLFwiaG9wZlwiOlwi8J2VmVwiLFwiSG9wZlwiOlwi4oSNXCIsXCJob3JiYXJcIjpcIuKAlVwiLFwiSG9yaXpvbnRhbExpbmVcIjpcIuKUgFwiLFwiaHNjclwiOlwi8J2SvVwiLFwiSHNjclwiOlwi4oSLXCIsXCJoc2xhc2hcIjpcIuKEj1wiLFwiSHN0cm9rXCI6XCLEplwiLFwiaHN0cm9rXCI6XCLEp1wiLFwiSHVtcERvd25IdW1wXCI6XCLiiY5cIixcIkh1bXBFcXVhbFwiOlwi4omPXCIsXCJoeWJ1bGxcIjpcIuKBg1wiLFwiaHlwaGVuXCI6XCLigJBcIixcIklhY3V0ZVwiOlwiw41cIixcImlhY3V0ZVwiOlwiw61cIixcImljXCI6XCLigaNcIixcIkljaXJjXCI6XCLDjlwiLFwiaWNpcmNcIjpcIsOuXCIsXCJJY3lcIjpcItCYXCIsXCJpY3lcIjpcItC4XCIsXCJJZG90XCI6XCLEsFwiLFwiSUVjeVwiOlwi0JVcIixcImllY3lcIjpcItC1XCIsXCJpZXhjbFwiOlwiwqFcIixcImlmZlwiOlwi4oeUXCIsXCJpZnJcIjpcIvCdlKZcIixcIklmclwiOlwi4oSRXCIsXCJJZ3JhdmVcIjpcIsOMXCIsXCJpZ3JhdmVcIjpcIsOsXCIsXCJpaVwiOlwi4oWIXCIsXCJpaWlpbnRcIjpcIuKojFwiLFwiaWlpbnRcIjpcIuKIrVwiLFwiaWluZmluXCI6XCLip5xcIixcImlpb3RhXCI6XCLihKlcIixcIklKbGlnXCI6XCLEslwiLFwiaWpsaWdcIjpcIsSzXCIsXCJJbWFjclwiOlwixKpcIixcImltYWNyXCI6XCLEq1wiLFwiaW1hZ2VcIjpcIuKEkVwiLFwiSW1hZ2luYXJ5SVwiOlwi4oWIXCIsXCJpbWFnbGluZVwiOlwi4oSQXCIsXCJpbWFncGFydFwiOlwi4oSRXCIsXCJpbWF0aFwiOlwixLFcIixcIkltXCI6XCLihJFcIixcImltb2ZcIjpcIuKKt1wiLFwiaW1wZWRcIjpcIsa1XCIsXCJJbXBsaWVzXCI6XCLih5JcIixcImluY2FyZVwiOlwi4oSFXCIsXCJpblwiOlwi4oiIXCIsXCJpbmZpblwiOlwi4oieXCIsXCJpbmZpbnRpZVwiOlwi4qedXCIsXCJpbm9kb3RcIjpcIsSxXCIsXCJpbnRjYWxcIjpcIuKKulwiLFwiaW50XCI6XCLiiKtcIixcIkludFwiOlwi4oisXCIsXCJpbnRlZ2Vyc1wiOlwi4oSkXCIsXCJJbnRlZ3JhbFwiOlwi4oirXCIsXCJpbnRlcmNhbFwiOlwi4oq6XCIsXCJJbnRlcnNlY3Rpb25cIjpcIuKLglwiLFwiaW50bGFyaGtcIjpcIuKol1wiLFwiaW50cHJvZFwiOlwi4qi8XCIsXCJJbnZpc2libGVDb21tYVwiOlwi4oGjXCIsXCJJbnZpc2libGVUaW1lc1wiOlwi4oGiXCIsXCJJT2N5XCI6XCLQgVwiLFwiaW9jeVwiOlwi0ZFcIixcIklvZ29uXCI6XCLErlwiLFwiaW9nb25cIjpcIsSvXCIsXCJJb3BmXCI6XCLwnZWAXCIsXCJpb3BmXCI6XCLwnZWaXCIsXCJJb3RhXCI6XCLOmVwiLFwiaW90YVwiOlwizrlcIixcImlwcm9kXCI6XCLiqLxcIixcImlxdWVzdFwiOlwiwr9cIixcImlzY3JcIjpcIvCdkr5cIixcIklzY3JcIjpcIuKEkFwiLFwiaXNpblwiOlwi4oiIXCIsXCJpc2luZG90XCI6XCLii7VcIixcImlzaW5FXCI6XCLii7lcIixcImlzaW5zXCI6XCLii7RcIixcImlzaW5zdlwiOlwi4ouzXCIsXCJpc2ludlwiOlwi4oiIXCIsXCJpdFwiOlwi4oGiXCIsXCJJdGlsZGVcIjpcIsSoXCIsXCJpdGlsZGVcIjpcIsSpXCIsXCJJdWtjeVwiOlwi0IZcIixcIml1a2N5XCI6XCLRllwiLFwiSXVtbFwiOlwiw49cIixcIml1bWxcIjpcIsOvXCIsXCJKY2lyY1wiOlwixLRcIixcImpjaXJjXCI6XCLEtVwiLFwiSmN5XCI6XCLQmVwiLFwiamN5XCI6XCLQuVwiLFwiSmZyXCI6XCLwnZSNXCIsXCJqZnJcIjpcIvCdlKdcIixcImptYXRoXCI6XCLIt1wiLFwiSm9wZlwiOlwi8J2VgVwiLFwiam9wZlwiOlwi8J2Vm1wiLFwiSnNjclwiOlwi8J2SpVwiLFwianNjclwiOlwi8J2Sv1wiLFwiSnNlcmN5XCI6XCLQiFwiLFwianNlcmN5XCI6XCLRmFwiLFwiSnVrY3lcIjpcItCEXCIsXCJqdWtjeVwiOlwi0ZRcIixcIkthcHBhXCI6XCLOmlwiLFwia2FwcGFcIjpcIs66XCIsXCJrYXBwYXZcIjpcIs+wXCIsXCJLY2VkaWxcIjpcIsS2XCIsXCJrY2VkaWxcIjpcIsS3XCIsXCJLY3lcIjpcItCaXCIsXCJrY3lcIjpcItC6XCIsXCJLZnJcIjpcIvCdlI5cIixcImtmclwiOlwi8J2UqFwiLFwia2dyZWVuXCI6XCLEuFwiLFwiS0hjeVwiOlwi0KVcIixcImtoY3lcIjpcItGFXCIsXCJLSmN5XCI6XCLQjFwiLFwia2pjeVwiOlwi0ZxcIixcIktvcGZcIjpcIvCdlYJcIixcImtvcGZcIjpcIvCdlZxcIixcIktzY3JcIjpcIvCdkqZcIixcImtzY3JcIjpcIvCdk4BcIixcImxBYXJyXCI6XCLih5pcIixcIkxhY3V0ZVwiOlwixLlcIixcImxhY3V0ZVwiOlwixLpcIixcImxhZW1wdHl2XCI6XCLiprRcIixcImxhZ3JhblwiOlwi4oSSXCIsXCJMYW1iZGFcIjpcIs6bXCIsXCJsYW1iZGFcIjpcIs67XCIsXCJsYW5nXCI6XCLin6hcIixcIkxhbmdcIjpcIuKfqlwiLFwibGFuZ2RcIjpcIuKmkVwiLFwibGFuZ2xlXCI6XCLin6hcIixcImxhcFwiOlwi4qqFXCIsXCJMYXBsYWNldHJmXCI6XCLihJJcIixcImxhcXVvXCI6XCLCq1wiLFwibGFycmJcIjpcIuKHpFwiLFwibGFycmJmc1wiOlwi4qSfXCIsXCJsYXJyXCI6XCLihpBcIixcIkxhcnJcIjpcIuKGnlwiLFwibEFyclwiOlwi4oeQXCIsXCJsYXJyZnNcIjpcIuKknVwiLFwibGFycmhrXCI6XCLihqlcIixcImxhcnJscFwiOlwi4oarXCIsXCJsYXJycGxcIjpcIuKkuVwiLFwibGFycnNpbVwiOlwi4qWzXCIsXCJsYXJydGxcIjpcIuKGolwiLFwibGF0YWlsXCI6XCLipJlcIixcImxBdGFpbFwiOlwi4qSbXCIsXCJsYXRcIjpcIuKqq1wiLFwibGF0ZVwiOlwi4qqtXCIsXCJsYXRlc1wiOlwi4qqt77iAXCIsXCJsYmFyclwiOlwi4qSMXCIsXCJsQmFyclwiOlwi4qSOXCIsXCJsYmJya1wiOlwi4p2yXCIsXCJsYnJhY2VcIjpcIntcIixcImxicmFja1wiOlwiW1wiLFwibGJya2VcIjpcIuKmi1wiLFwibGJya3NsZFwiOlwi4qaPXCIsXCJsYnJrc2x1XCI6XCLipo1cIixcIkxjYXJvblwiOlwixL1cIixcImxjYXJvblwiOlwixL5cIixcIkxjZWRpbFwiOlwixLtcIixcImxjZWRpbFwiOlwixLxcIixcImxjZWlsXCI6XCLijIhcIixcImxjdWJcIjpcIntcIixcIkxjeVwiOlwi0JtcIixcImxjeVwiOlwi0LtcIixcImxkY2FcIjpcIuKktlwiLFwibGRxdW9cIjpcIuKAnFwiLFwibGRxdW9yXCI6XCLigJ5cIixcImxkcmRoYXJcIjpcIuKlp1wiLFwibGRydXNoYXJcIjpcIuKli1wiLFwibGRzaFwiOlwi4oayXCIsXCJsZVwiOlwi4omkXCIsXCJsRVwiOlwi4ommXCIsXCJMZWZ0QW5nbGVCcmFja2V0XCI6XCLin6hcIixcIkxlZnRBcnJvd0JhclwiOlwi4oekXCIsXCJsZWZ0YXJyb3dcIjpcIuKGkFwiLFwiTGVmdEFycm93XCI6XCLihpBcIixcIkxlZnRhcnJvd1wiOlwi4oeQXCIsXCJMZWZ0QXJyb3dSaWdodEFycm93XCI6XCLih4ZcIixcImxlZnRhcnJvd3RhaWxcIjpcIuKGolwiLFwiTGVmdENlaWxpbmdcIjpcIuKMiFwiLFwiTGVmdERvdWJsZUJyYWNrZXRcIjpcIuKfplwiLFwiTGVmdERvd25UZWVWZWN0b3JcIjpcIuKloVwiLFwiTGVmdERvd25WZWN0b3JCYXJcIjpcIuKlmVwiLFwiTGVmdERvd25WZWN0b3JcIjpcIuKHg1wiLFwiTGVmdEZsb29yXCI6XCLijIpcIixcImxlZnRoYXJwb29uZG93blwiOlwi4oa9XCIsXCJsZWZ0aGFycG9vbnVwXCI6XCLihrxcIixcImxlZnRsZWZ0YXJyb3dzXCI6XCLih4dcIixcImxlZnRyaWdodGFycm93XCI6XCLihpRcIixcIkxlZnRSaWdodEFycm93XCI6XCLihpRcIixcIkxlZnRyaWdodGFycm93XCI6XCLih5RcIixcImxlZnRyaWdodGFycm93c1wiOlwi4oeGXCIsXCJsZWZ0cmlnaHRoYXJwb29uc1wiOlwi4oeLXCIsXCJsZWZ0cmlnaHRzcXVpZ2Fycm93XCI6XCLihq1cIixcIkxlZnRSaWdodFZlY3RvclwiOlwi4qWOXCIsXCJMZWZ0VGVlQXJyb3dcIjpcIuKGpFwiLFwiTGVmdFRlZVwiOlwi4oqjXCIsXCJMZWZ0VGVlVmVjdG9yXCI6XCLipZpcIixcImxlZnR0aHJlZXRpbWVzXCI6XCLii4tcIixcIkxlZnRUcmlhbmdsZUJhclwiOlwi4qePXCIsXCJMZWZ0VHJpYW5nbGVcIjpcIuKKslwiLFwiTGVmdFRyaWFuZ2xlRXF1YWxcIjpcIuKKtFwiLFwiTGVmdFVwRG93blZlY3RvclwiOlwi4qWRXCIsXCJMZWZ0VXBUZWVWZWN0b3JcIjpcIuKloFwiLFwiTGVmdFVwVmVjdG9yQmFyXCI6XCLipZhcIixcIkxlZnRVcFZlY3RvclwiOlwi4oa/XCIsXCJMZWZ0VmVjdG9yQmFyXCI6XCLipZJcIixcIkxlZnRWZWN0b3JcIjpcIuKGvFwiLFwibEVnXCI6XCLiqotcIixcImxlZ1wiOlwi4ouaXCIsXCJsZXFcIjpcIuKJpFwiLFwibGVxcVwiOlwi4ommXCIsXCJsZXFzbGFudFwiOlwi4qm9XCIsXCJsZXNjY1wiOlwi4qqoXCIsXCJsZXNcIjpcIuKpvVwiLFwibGVzZG90XCI6XCLiqb9cIixcImxlc2RvdG9cIjpcIuKqgVwiLFwibGVzZG90b3JcIjpcIuKqg1wiLFwibGVzZ1wiOlwi4oua77iAXCIsXCJsZXNnZXNcIjpcIuKqk1wiLFwibGVzc2FwcHJveFwiOlwi4qqFXCIsXCJsZXNzZG90XCI6XCLii5ZcIixcImxlc3NlcWd0clwiOlwi4ouaXCIsXCJsZXNzZXFxZ3RyXCI6XCLiqotcIixcIkxlc3NFcXVhbEdyZWF0ZXJcIjpcIuKLmlwiLFwiTGVzc0Z1bGxFcXVhbFwiOlwi4ommXCIsXCJMZXNzR3JlYXRlclwiOlwi4om2XCIsXCJsZXNzZ3RyXCI6XCLiibZcIixcIkxlc3NMZXNzXCI6XCLiqqFcIixcImxlc3NzaW1cIjpcIuKJslwiLFwiTGVzc1NsYW50RXF1YWxcIjpcIuKpvVwiLFwiTGVzc1RpbGRlXCI6XCLiibJcIixcImxmaXNodFwiOlwi4qW8XCIsXCJsZmxvb3JcIjpcIuKMilwiLFwiTGZyXCI6XCLwnZSPXCIsXCJsZnJcIjpcIvCdlKlcIixcImxnXCI6XCLiibZcIixcImxnRVwiOlwi4qqRXCIsXCJsSGFyXCI6XCLipaJcIixcImxoYXJkXCI6XCLihr1cIixcImxoYXJ1XCI6XCLihrxcIixcImxoYXJ1bFwiOlwi4qWqXCIsXCJsaGJsa1wiOlwi4paEXCIsXCJMSmN5XCI6XCLQiVwiLFwibGpjeVwiOlwi0ZlcIixcImxsYXJyXCI6XCLih4dcIixcImxsXCI6XCLiiapcIixcIkxsXCI6XCLii5hcIixcImxsY29ybmVyXCI6XCLijJ5cIixcIkxsZWZ0YXJyb3dcIjpcIuKHmlwiLFwibGxoYXJkXCI6XCLipatcIixcImxsdHJpXCI6XCLil7pcIixcIkxtaWRvdFwiOlwixL9cIixcImxtaWRvdFwiOlwixYBcIixcImxtb3VzdGFjaGVcIjpcIuKOsFwiLFwibG1vdXN0XCI6XCLijrBcIixcImxuYXBcIjpcIuKqiVwiLFwibG5hcHByb3hcIjpcIuKqiVwiLFwibG5lXCI6XCLiqodcIixcImxuRVwiOlwi4omoXCIsXCJsbmVxXCI6XCLiqodcIixcImxuZXFxXCI6XCLiiahcIixcImxuc2ltXCI6XCLii6ZcIixcImxvYW5nXCI6XCLin6xcIixcImxvYXJyXCI6XCLih71cIixcImxvYnJrXCI6XCLin6ZcIixcImxvbmdsZWZ0YXJyb3dcIjpcIuKftVwiLFwiTG9uZ0xlZnRBcnJvd1wiOlwi4p+1XCIsXCJMb25nbGVmdGFycm93XCI6XCLin7hcIixcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwi4p+3XCIsXCJMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIuKft1wiLFwiTG9uZ2xlZnRyaWdodGFycm93XCI6XCLin7pcIixcImxvbmdtYXBzdG9cIjpcIuKfvFwiLFwibG9uZ3JpZ2h0YXJyb3dcIjpcIuKftlwiLFwiTG9uZ1JpZ2h0QXJyb3dcIjpcIuKftlwiLFwiTG9uZ3JpZ2h0YXJyb3dcIjpcIuKfuVwiLFwibG9vcGFycm93bGVmdFwiOlwi4oarXCIsXCJsb29wYXJyb3dyaWdodFwiOlwi4oasXCIsXCJsb3BhclwiOlwi4qaFXCIsXCJMb3BmXCI6XCLwnZWDXCIsXCJsb3BmXCI6XCLwnZWdXCIsXCJsb3BsdXNcIjpcIuKorVwiLFwibG90aW1lc1wiOlwi4qi0XCIsXCJsb3dhc3RcIjpcIuKIl1wiLFwibG93YmFyXCI6XCJfXCIsXCJMb3dlckxlZnRBcnJvd1wiOlwi4oaZXCIsXCJMb3dlclJpZ2h0QXJyb3dcIjpcIuKGmFwiLFwibG96XCI6XCLil4pcIixcImxvemVuZ2VcIjpcIuKXilwiLFwibG96ZlwiOlwi4qerXCIsXCJscGFyXCI6XCIoXCIsXCJscGFybHRcIjpcIuKmk1wiLFwibHJhcnJcIjpcIuKHhlwiLFwibHJjb3JuZXJcIjpcIuKMn1wiLFwibHJoYXJcIjpcIuKHi1wiLFwibHJoYXJkXCI6XCLipa1cIixcImxybVwiOlwi4oCOXCIsXCJscnRyaVwiOlwi4oq/XCIsXCJsc2FxdW9cIjpcIuKAuVwiLFwibHNjclwiOlwi8J2TgVwiLFwiTHNjclwiOlwi4oSSXCIsXCJsc2hcIjpcIuKGsFwiLFwiTHNoXCI6XCLihrBcIixcImxzaW1cIjpcIuKJslwiLFwibHNpbWVcIjpcIuKqjVwiLFwibHNpbWdcIjpcIuKqj1wiLFwibHNxYlwiOlwiW1wiLFwibHNxdW9cIjpcIuKAmFwiLFwibHNxdW9yXCI6XCLigJpcIixcIkxzdHJva1wiOlwixYFcIixcImxzdHJva1wiOlwixYJcIixcImx0Y2NcIjpcIuKqplwiLFwibHRjaXJcIjpcIuKpuVwiLFwibHRcIjpcIjxcIixcIkxUXCI6XCI8XCIsXCJMdFwiOlwi4omqXCIsXCJsdGRvdFwiOlwi4ouWXCIsXCJsdGhyZWVcIjpcIuKLi1wiLFwibHRpbWVzXCI6XCLii4lcIixcImx0bGFyclwiOlwi4qW2XCIsXCJsdHF1ZXN0XCI6XCLiqbtcIixcImx0cmlcIjpcIuKXg1wiLFwibHRyaWVcIjpcIuKKtFwiLFwibHRyaWZcIjpcIuKXglwiLFwibHRyUGFyXCI6XCLippZcIixcImx1cmRzaGFyXCI6XCLipYpcIixcImx1cnVoYXJcIjpcIuKlplwiLFwibHZlcnRuZXFxXCI6XCLiiajvuIBcIixcImx2bkVcIjpcIuKJqO+4gFwiLFwibWFjclwiOlwiwq9cIixcIm1hbGVcIjpcIuKZglwiLFwibWFsdFwiOlwi4pygXCIsXCJtYWx0ZXNlXCI6XCLinKBcIixcIk1hcFwiOlwi4qSFXCIsXCJtYXBcIjpcIuKGplwiLFwibWFwc3RvXCI6XCLihqZcIixcIm1hcHN0b2Rvd25cIjpcIuKGp1wiLFwibWFwc3RvbGVmdFwiOlwi4oakXCIsXCJtYXBzdG91cFwiOlwi4oalXCIsXCJtYXJrZXJcIjpcIuKWrlwiLFwibWNvbW1hXCI6XCLiqKlcIixcIk1jeVwiOlwi0JxcIixcIm1jeVwiOlwi0LxcIixcIm1kYXNoXCI6XCLigJRcIixcIm1ERG90XCI6XCLiiLpcIixcIm1lYXN1cmVkYW5nbGVcIjpcIuKIoVwiLFwiTWVkaXVtU3BhY2VcIjpcIuKBn1wiLFwiTWVsbGludHJmXCI6XCLihLNcIixcIk1mclwiOlwi8J2UkFwiLFwibWZyXCI6XCLwnZSqXCIsXCJtaG9cIjpcIuKEp1wiLFwibWljcm9cIjpcIsK1XCIsXCJtaWRhc3RcIjpcIipcIixcIm1pZGNpclwiOlwi4quwXCIsXCJtaWRcIjpcIuKIo1wiLFwibWlkZG90XCI6XCLCt1wiLFwibWludXNiXCI6XCLiip9cIixcIm1pbnVzXCI6XCLiiJJcIixcIm1pbnVzZFwiOlwi4oi4XCIsXCJtaW51c2R1XCI6XCLiqKpcIixcIk1pbnVzUGx1c1wiOlwi4oiTXCIsXCJtbGNwXCI6XCLiq5tcIixcIm1sZHJcIjpcIuKAplwiLFwibW5wbHVzXCI6XCLiiJNcIixcIm1vZGVsc1wiOlwi4oqnXCIsXCJNb3BmXCI6XCLwnZWEXCIsXCJtb3BmXCI6XCLwnZWeXCIsXCJtcFwiOlwi4oiTXCIsXCJtc2NyXCI6XCLwnZOCXCIsXCJNc2NyXCI6XCLihLNcIixcIm1zdHBvc1wiOlwi4oi+XCIsXCJNdVwiOlwizpxcIixcIm11XCI6XCLOvFwiLFwibXVsdGltYXBcIjpcIuKKuFwiLFwibXVtYXBcIjpcIuKKuFwiLFwibmFibGFcIjpcIuKIh1wiLFwiTmFjdXRlXCI6XCLFg1wiLFwibmFjdXRlXCI6XCLFhFwiLFwibmFuZ1wiOlwi4oig4oOSXCIsXCJuYXBcIjpcIuKJiVwiLFwibmFwRVwiOlwi4qmwzLhcIixcIm5hcGlkXCI6XCLiiYvMuFwiLFwibmFwb3NcIjpcIsWJXCIsXCJuYXBwcm94XCI6XCLiiYlcIixcIm5hdHVyYWxcIjpcIuKZrlwiLFwibmF0dXJhbHNcIjpcIuKElVwiLFwibmF0dXJcIjpcIuKZrlwiLFwibmJzcFwiOlwiwqBcIixcIm5idW1wXCI6XCLiiY7MuFwiLFwibmJ1bXBlXCI6XCLiiY/MuFwiLFwibmNhcFwiOlwi4qmDXCIsXCJOY2Fyb25cIjpcIsWHXCIsXCJuY2Fyb25cIjpcIsWIXCIsXCJOY2VkaWxcIjpcIsWFXCIsXCJuY2VkaWxcIjpcIsWGXCIsXCJuY29uZ1wiOlwi4omHXCIsXCJuY29uZ2RvdFwiOlwi4qmtzLhcIixcIm5jdXBcIjpcIuKpglwiLFwiTmN5XCI6XCLQnVwiLFwibmN5XCI6XCLQvVwiLFwibmRhc2hcIjpcIuKAk1wiLFwibmVhcmhrXCI6XCLipKRcIixcIm5lYXJyXCI6XCLihpdcIixcIm5lQXJyXCI6XCLih5dcIixcIm5lYXJyb3dcIjpcIuKGl1wiLFwibmVcIjpcIuKJoFwiLFwibmVkb3RcIjpcIuKJkMy4XCIsXCJOZWdhdGl2ZU1lZGl1bVNwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVGhpY2tTcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVRoaW5TcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVZlcnlUaGluU3BhY2VcIjpcIuKAi1wiLFwibmVxdWl2XCI6XCLiiaJcIixcIm5lc2VhclwiOlwi4qSoXCIsXCJuZXNpbVwiOlwi4omCzLhcIixcIk5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCLiiatcIixcIk5lc3RlZExlc3NMZXNzXCI6XCLiiapcIixcIk5ld0xpbmVcIjpcIlxcblwiLFwibmV4aXN0XCI6XCLiiIRcIixcIm5leGlzdHNcIjpcIuKIhFwiLFwiTmZyXCI6XCLwnZSRXCIsXCJuZnJcIjpcIvCdlKtcIixcIm5nRVwiOlwi4omnzLhcIixcIm5nZVwiOlwi4omxXCIsXCJuZ2VxXCI6XCLiibFcIixcIm5nZXFxXCI6XCLiiafMuFwiLFwibmdlcXNsYW50XCI6XCLiqb7MuFwiLFwibmdlc1wiOlwi4qm+zLhcIixcIm5HZ1wiOlwi4ouZzLhcIixcIm5nc2ltXCI6XCLiibVcIixcIm5HdFwiOlwi4omr4oOSXCIsXCJuZ3RcIjpcIuKJr1wiLFwibmd0clwiOlwi4omvXCIsXCJuR3R2XCI6XCLiiavMuFwiLFwibmhhcnJcIjpcIuKGrlwiLFwibmhBcnJcIjpcIuKHjlwiLFwibmhwYXJcIjpcIuKrslwiLFwibmlcIjpcIuKIi1wiLFwibmlzXCI6XCLii7xcIixcIm5pc2RcIjpcIuKLulwiLFwibml2XCI6XCLiiItcIixcIk5KY3lcIjpcItCKXCIsXCJuamN5XCI6XCLRmlwiLFwibmxhcnJcIjpcIuKGmlwiLFwibmxBcnJcIjpcIuKHjVwiLFwibmxkclwiOlwi4oClXCIsXCJubEVcIjpcIuKJpsy4XCIsXCJubGVcIjpcIuKJsFwiLFwibmxlZnRhcnJvd1wiOlwi4oaaXCIsXCJuTGVmdGFycm93XCI6XCLih41cIixcIm5sZWZ0cmlnaHRhcnJvd1wiOlwi4oauXCIsXCJuTGVmdHJpZ2h0YXJyb3dcIjpcIuKHjlwiLFwibmxlcVwiOlwi4omwXCIsXCJubGVxcVwiOlwi4ommzLhcIixcIm5sZXFzbGFudFwiOlwi4qm9zLhcIixcIm5sZXNcIjpcIuKpvcy4XCIsXCJubGVzc1wiOlwi4omuXCIsXCJuTGxcIjpcIuKLmMy4XCIsXCJubHNpbVwiOlwi4om0XCIsXCJuTHRcIjpcIuKJquKDklwiLFwibmx0XCI6XCLiia5cIixcIm5sdHJpXCI6XCLii6pcIixcIm5sdHJpZVwiOlwi4ousXCIsXCJuTHR2XCI6XCLiiarMuFwiLFwibm1pZFwiOlwi4oikXCIsXCJOb0JyZWFrXCI6XCLigaBcIixcIk5vbkJyZWFraW5nU3BhY2VcIjpcIsKgXCIsXCJub3BmXCI6XCLwnZWfXCIsXCJOb3BmXCI6XCLihJVcIixcIk5vdFwiOlwi4qusXCIsXCJub3RcIjpcIsKsXCIsXCJOb3RDb25ncnVlbnRcIjpcIuKJolwiLFwiTm90Q3VwQ2FwXCI6XCLiia1cIixcIk5vdERvdWJsZVZlcnRpY2FsQmFyXCI6XCLiiKZcIixcIk5vdEVsZW1lbnRcIjpcIuKIiVwiLFwiTm90RXF1YWxcIjpcIuKJoFwiLFwiTm90RXF1YWxUaWxkZVwiOlwi4omCzLhcIixcIk5vdEV4aXN0c1wiOlwi4oiEXCIsXCJOb3RHcmVhdGVyXCI6XCLiia9cIixcIk5vdEdyZWF0ZXJFcXVhbFwiOlwi4omxXCIsXCJOb3RHcmVhdGVyRnVsbEVxdWFsXCI6XCLiiafMuFwiLFwiTm90R3JlYXRlckdyZWF0ZXJcIjpcIuKJq8y4XCIsXCJOb3RHcmVhdGVyTGVzc1wiOlwi4om5XCIsXCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOlwi4qm+zLhcIixcIk5vdEdyZWF0ZXJUaWxkZVwiOlwi4om1XCIsXCJOb3RIdW1wRG93bkh1bXBcIjpcIuKJjsy4XCIsXCJOb3RIdW1wRXF1YWxcIjpcIuKJj8y4XCIsXCJub3RpblwiOlwi4oiJXCIsXCJub3RpbmRvdFwiOlwi4ou1zLhcIixcIm5vdGluRVwiOlwi4ou5zLhcIixcIm5vdGludmFcIjpcIuKIiVwiLFwibm90aW52YlwiOlwi4ou3XCIsXCJub3RpbnZjXCI6XCLii7ZcIixcIk5vdExlZnRUcmlhbmdsZUJhclwiOlwi4qePzLhcIixcIk5vdExlZnRUcmlhbmdsZVwiOlwi4ouqXCIsXCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOlwi4ousXCIsXCJOb3RMZXNzXCI6XCLiia5cIixcIk5vdExlc3NFcXVhbFwiOlwi4omwXCIsXCJOb3RMZXNzR3JlYXRlclwiOlwi4om4XCIsXCJOb3RMZXNzTGVzc1wiOlwi4omqzLhcIixcIk5vdExlc3NTbGFudEVxdWFsXCI6XCLiqb3MuFwiLFwiTm90TGVzc1RpbGRlXCI6XCLiibRcIixcIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCLiqqLMuFwiLFwiTm90TmVzdGVkTGVzc0xlc3NcIjpcIuKqocy4XCIsXCJub3RuaVwiOlwi4oiMXCIsXCJub3RuaXZhXCI6XCLiiIxcIixcIm5vdG5pdmJcIjpcIuKLvlwiLFwibm90bml2Y1wiOlwi4ou9XCIsXCJOb3RQcmVjZWRlc1wiOlwi4oqAXCIsXCJOb3RQcmVjZWRlc0VxdWFsXCI6XCLiqq/MuFwiLFwiTm90UHJlY2VkZXNTbGFudEVxdWFsXCI6XCLii6BcIixcIk5vdFJldmVyc2VFbGVtZW50XCI6XCLiiIxcIixcIk5vdFJpZ2h0VHJpYW5nbGVCYXJcIjpcIuKnkMy4XCIsXCJOb3RSaWdodFRyaWFuZ2xlXCI6XCLii6tcIixcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwi4outXCIsXCJOb3RTcXVhcmVTdWJzZXRcIjpcIuKKj8y4XCIsXCJOb3RTcXVhcmVTdWJzZXRFcXVhbFwiOlwi4ouiXCIsXCJOb3RTcXVhcmVTdXBlcnNldFwiOlwi4oqQzLhcIixcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIuKLo1wiLFwiTm90U3Vic2V0XCI6XCLiioLig5JcIixcIk5vdFN1YnNldEVxdWFsXCI6XCLiiohcIixcIk5vdFN1Y2NlZWRzXCI6XCLiioFcIixcIk5vdFN1Y2NlZWRzRXF1YWxcIjpcIuKqsMy4XCIsXCJOb3RTdWNjZWVkc1NsYW50RXF1YWxcIjpcIuKLoVwiLFwiTm90U3VjY2VlZHNUaWxkZVwiOlwi4om/zLhcIixcIk5vdFN1cGVyc2V0XCI6XCLiioPig5JcIixcIk5vdFN1cGVyc2V0RXF1YWxcIjpcIuKKiVwiLFwiTm90VGlsZGVcIjpcIuKJgVwiLFwiTm90VGlsZGVFcXVhbFwiOlwi4omEXCIsXCJOb3RUaWxkZUZ1bGxFcXVhbFwiOlwi4omHXCIsXCJOb3RUaWxkZVRpbGRlXCI6XCLiiYlcIixcIk5vdFZlcnRpY2FsQmFyXCI6XCLiiKRcIixcIm5wYXJhbGxlbFwiOlwi4oimXCIsXCJucGFyXCI6XCLiiKZcIixcIm5wYXJzbFwiOlwi4qu94oOlXCIsXCJucGFydFwiOlwi4oiCzLhcIixcIm5wb2xpbnRcIjpcIuKolFwiLFwibnByXCI6XCLiioBcIixcIm5wcmN1ZVwiOlwi4ougXCIsXCJucHJlY1wiOlwi4oqAXCIsXCJucHJlY2VxXCI6XCLiqq/MuFwiLFwibnByZVwiOlwi4qqvzLhcIixcIm5yYXJyY1wiOlwi4qSzzLhcIixcIm5yYXJyXCI6XCLihptcIixcIm5yQXJyXCI6XCLih49cIixcIm5yYXJyd1wiOlwi4oadzLhcIixcIm5yaWdodGFycm93XCI6XCLihptcIixcIm5SaWdodGFycm93XCI6XCLih49cIixcIm5ydHJpXCI6XCLii6tcIixcIm5ydHJpZVwiOlwi4outXCIsXCJuc2NcIjpcIuKKgVwiLFwibnNjY3VlXCI6XCLii6FcIixcIm5zY2VcIjpcIuKqsMy4XCIsXCJOc2NyXCI6XCLwnZKpXCIsXCJuc2NyXCI6XCLwnZODXCIsXCJuc2hvcnRtaWRcIjpcIuKIpFwiLFwibnNob3J0cGFyYWxsZWxcIjpcIuKIplwiLFwibnNpbVwiOlwi4omBXCIsXCJuc2ltZVwiOlwi4omEXCIsXCJuc2ltZXFcIjpcIuKJhFwiLFwibnNtaWRcIjpcIuKIpFwiLFwibnNwYXJcIjpcIuKIplwiLFwibnNxc3ViZVwiOlwi4ouiXCIsXCJuc3FzdXBlXCI6XCLii6NcIixcIm5zdWJcIjpcIuKKhFwiLFwibnN1YkVcIjpcIuKrhcy4XCIsXCJuc3ViZVwiOlwi4oqIXCIsXCJuc3Vic2V0XCI6XCLiioLig5JcIixcIm5zdWJzZXRlcVwiOlwi4oqIXCIsXCJuc3Vic2V0ZXFxXCI6XCLiq4XMuFwiLFwibnN1Y2NcIjpcIuKKgVwiLFwibnN1Y2NlcVwiOlwi4qqwzLhcIixcIm5zdXBcIjpcIuKKhVwiLFwibnN1cEVcIjpcIuKrhsy4XCIsXCJuc3VwZVwiOlwi4oqJXCIsXCJuc3Vwc2V0XCI6XCLiioPig5JcIixcIm5zdXBzZXRlcVwiOlwi4oqJXCIsXCJuc3Vwc2V0ZXFxXCI6XCLiq4bMuFwiLFwibnRnbFwiOlwi4om5XCIsXCJOdGlsZGVcIjpcIsORXCIsXCJudGlsZGVcIjpcIsOxXCIsXCJudGxnXCI6XCLiibhcIixcIm50cmlhbmdsZWxlZnRcIjpcIuKLqlwiLFwibnRyaWFuZ2xlbGVmdGVxXCI6XCLii6xcIixcIm50cmlhbmdsZXJpZ2h0XCI6XCLii6tcIixcIm50cmlhbmdsZXJpZ2h0ZXFcIjpcIuKLrVwiLFwiTnVcIjpcIs6dXCIsXCJudVwiOlwizr1cIixcIm51bVwiOlwiI1wiLFwibnVtZXJvXCI6XCLihJZcIixcIm51bXNwXCI6XCLigIdcIixcIm52YXBcIjpcIuKJjeKDklwiLFwibnZkYXNoXCI6XCLiiqxcIixcIm52RGFzaFwiOlwi4oqtXCIsXCJuVmRhc2hcIjpcIuKKrlwiLFwiblZEYXNoXCI6XCLiiq9cIixcIm52Z2VcIjpcIuKJpeKDklwiLFwibnZndFwiOlwiPuKDklwiLFwibnZIYXJyXCI6XCLipIRcIixcIm52aW5maW5cIjpcIuKnnlwiLFwibnZsQXJyXCI6XCLipIJcIixcIm52bGVcIjpcIuKJpOKDklwiLFwibnZsdFwiOlwiPOKDklwiLFwibnZsdHJpZVwiOlwi4oq04oOSXCIsXCJudnJBcnJcIjpcIuKkg1wiLFwibnZydHJpZVwiOlwi4oq14oOSXCIsXCJudnNpbVwiOlwi4oi84oOSXCIsXCJud2FyaGtcIjpcIuKko1wiLFwibndhcnJcIjpcIuKGllwiLFwibndBcnJcIjpcIuKHllwiLFwibndhcnJvd1wiOlwi4oaWXCIsXCJud25lYXJcIjpcIuKkp1wiLFwiT2FjdXRlXCI6XCLDk1wiLFwib2FjdXRlXCI6XCLDs1wiLFwib2FzdFwiOlwi4oqbXCIsXCJPY2lyY1wiOlwiw5RcIixcIm9jaXJjXCI6XCLDtFwiLFwib2NpclwiOlwi4oqaXCIsXCJPY3lcIjpcItCeXCIsXCJvY3lcIjpcItC+XCIsXCJvZGFzaFwiOlwi4oqdXCIsXCJPZGJsYWNcIjpcIsWQXCIsXCJvZGJsYWNcIjpcIsWRXCIsXCJvZGl2XCI6XCLiqLhcIixcIm9kb3RcIjpcIuKKmVwiLFwib2Rzb2xkXCI6XCLiprxcIixcIk9FbGlnXCI6XCLFklwiLFwib2VsaWdcIjpcIsWTXCIsXCJvZmNpclwiOlwi4qa/XCIsXCJPZnJcIjpcIvCdlJJcIixcIm9mclwiOlwi8J2UrFwiLFwib2dvblwiOlwiy5tcIixcIk9ncmF2ZVwiOlwiw5JcIixcIm9ncmF2ZVwiOlwiw7JcIixcIm9ndFwiOlwi4qeBXCIsXCJvaGJhclwiOlwi4qa1XCIsXCJvaG1cIjpcIs6pXCIsXCJvaW50XCI6XCLiiK5cIixcIm9sYXJyXCI6XCLihrpcIixcIm9sY2lyXCI6XCLipr5cIixcIm9sY3Jvc3NcIjpcIuKmu1wiLFwib2xpbmVcIjpcIuKAvlwiLFwib2x0XCI6XCLip4BcIixcIk9tYWNyXCI6XCLFjFwiLFwib21hY3JcIjpcIsWNXCIsXCJPbWVnYVwiOlwizqlcIixcIm9tZWdhXCI6XCLPiVwiLFwiT21pY3JvblwiOlwizp9cIixcIm9taWNyb25cIjpcIs6/XCIsXCJvbWlkXCI6XCLiprZcIixcIm9taW51c1wiOlwi4oqWXCIsXCJPb3BmXCI6XCLwnZWGXCIsXCJvb3BmXCI6XCLwnZWgXCIsXCJvcGFyXCI6XCLiprdcIixcIk9wZW5DdXJseURvdWJsZVF1b3RlXCI6XCLigJxcIixcIk9wZW5DdXJseVF1b3RlXCI6XCLigJhcIixcIm9wZXJwXCI6XCLiprlcIixcIm9wbHVzXCI6XCLiipVcIixcIm9yYXJyXCI6XCLihrtcIixcIk9yXCI6XCLiqZRcIixcIm9yXCI6XCLiiKhcIixcIm9yZFwiOlwi4qmdXCIsXCJvcmRlclwiOlwi4oS0XCIsXCJvcmRlcm9mXCI6XCLihLRcIixcIm9yZGZcIjpcIsKqXCIsXCJvcmRtXCI6XCLCulwiLFwib3JpZ29mXCI6XCLiirZcIixcIm9yb3JcIjpcIuKpllwiLFwib3JzbG9wZVwiOlwi4qmXXCIsXCJvcnZcIjpcIuKpm1wiLFwib1NcIjpcIuKTiFwiLFwiT3NjclwiOlwi8J2SqlwiLFwib3NjclwiOlwi4oS0XCIsXCJPc2xhc2hcIjpcIsOYXCIsXCJvc2xhc2hcIjpcIsO4XCIsXCJvc29sXCI6XCLiiphcIixcIk90aWxkZVwiOlwiw5VcIixcIm90aWxkZVwiOlwiw7VcIixcIm90aW1lc2FzXCI6XCLiqLZcIixcIk90aW1lc1wiOlwi4qi3XCIsXCJvdGltZXNcIjpcIuKKl1wiLFwiT3VtbFwiOlwiw5ZcIixcIm91bWxcIjpcIsO2XCIsXCJvdmJhclwiOlwi4oy9XCIsXCJPdmVyQmFyXCI6XCLigL5cIixcIk92ZXJCcmFjZVwiOlwi4o+eXCIsXCJPdmVyQnJhY2tldFwiOlwi4o60XCIsXCJPdmVyUGFyZW50aGVzaXNcIjpcIuKPnFwiLFwicGFyYVwiOlwiwrZcIixcInBhcmFsbGVsXCI6XCLiiKVcIixcInBhclwiOlwi4oilXCIsXCJwYXJzaW1cIjpcIuKrs1wiLFwicGFyc2xcIjpcIuKrvVwiLFwicGFydFwiOlwi4oiCXCIsXCJQYXJ0aWFsRFwiOlwi4oiCXCIsXCJQY3lcIjpcItCfXCIsXCJwY3lcIjpcItC/XCIsXCJwZXJjbnRcIjpcIiVcIixcInBlcmlvZFwiOlwiLlwiLFwicGVybWlsXCI6XCLigLBcIixcInBlcnBcIjpcIuKKpVwiLFwicGVydGVua1wiOlwi4oCxXCIsXCJQZnJcIjpcIvCdlJNcIixcInBmclwiOlwi8J2UrVwiLFwiUGhpXCI6XCLOplwiLFwicGhpXCI6XCLPhlwiLFwicGhpdlwiOlwiz5VcIixcInBobW1hdFwiOlwi4oSzXCIsXCJwaG9uZVwiOlwi4piOXCIsXCJQaVwiOlwizqBcIixcInBpXCI6XCLPgFwiLFwicGl0Y2hmb3JrXCI6XCLii5RcIixcInBpdlwiOlwiz5ZcIixcInBsYW5ja1wiOlwi4oSPXCIsXCJwbGFuY2toXCI6XCLihI5cIixcInBsYW5rdlwiOlwi4oSPXCIsXCJwbHVzYWNpclwiOlwi4qijXCIsXCJwbHVzYlwiOlwi4oqeXCIsXCJwbHVzY2lyXCI6XCLiqKJcIixcInBsdXNcIjpcIitcIixcInBsdXNkb1wiOlwi4oiUXCIsXCJwbHVzZHVcIjpcIuKopVwiLFwicGx1c2VcIjpcIuKpslwiLFwiUGx1c01pbnVzXCI6XCLCsVwiLFwicGx1c21uXCI6XCLCsVwiLFwicGx1c3NpbVwiOlwi4qimXCIsXCJwbHVzdHdvXCI6XCLiqKdcIixcInBtXCI6XCLCsVwiLFwiUG9pbmNhcmVwbGFuZVwiOlwi4oSMXCIsXCJwb2ludGludFwiOlwi4qiVXCIsXCJwb3BmXCI6XCLwnZWhXCIsXCJQb3BmXCI6XCLihJlcIixcInBvdW5kXCI6XCLCo1wiLFwicHJhcFwiOlwi4qq3XCIsXCJQclwiOlwi4qq7XCIsXCJwclwiOlwi4om6XCIsXCJwcmN1ZVwiOlwi4om8XCIsXCJwcmVjYXBwcm94XCI6XCLiqrdcIixcInByZWNcIjpcIuKJulwiLFwicHJlY2N1cmx5ZXFcIjpcIuKJvFwiLFwiUHJlY2VkZXNcIjpcIuKJulwiLFwiUHJlY2VkZXNFcXVhbFwiOlwi4qqvXCIsXCJQcmVjZWRlc1NsYW50RXF1YWxcIjpcIuKJvFwiLFwiUHJlY2VkZXNUaWxkZVwiOlwi4om+XCIsXCJwcmVjZXFcIjpcIuKqr1wiLFwicHJlY25hcHByb3hcIjpcIuKquVwiLFwicHJlY25lcXFcIjpcIuKqtVwiLFwicHJlY25zaW1cIjpcIuKLqFwiLFwicHJlXCI6XCLiqq9cIixcInByRVwiOlwi4qqzXCIsXCJwcmVjc2ltXCI6XCLiib5cIixcInByaW1lXCI6XCLigLJcIixcIlByaW1lXCI6XCLigLNcIixcInByaW1lc1wiOlwi4oSZXCIsXCJwcm5hcFwiOlwi4qq5XCIsXCJwcm5FXCI6XCLiqrVcIixcInBybnNpbVwiOlwi4ouoXCIsXCJwcm9kXCI6XCLiiI9cIixcIlByb2R1Y3RcIjpcIuKIj1wiLFwicHJvZmFsYXJcIjpcIuKMrlwiLFwicHJvZmxpbmVcIjpcIuKMklwiLFwicHJvZnN1cmZcIjpcIuKMk1wiLFwicHJvcFwiOlwi4oidXCIsXCJQcm9wb3J0aW9uYWxcIjpcIuKInVwiLFwiUHJvcG9ydGlvblwiOlwi4oi3XCIsXCJwcm9wdG9cIjpcIuKInVwiLFwicHJzaW1cIjpcIuKJvlwiLFwicHJ1cmVsXCI6XCLiirBcIixcIlBzY3JcIjpcIvCdkqtcIixcInBzY3JcIjpcIvCdk4VcIixcIlBzaVwiOlwizqhcIixcInBzaVwiOlwiz4hcIixcInB1bmNzcFwiOlwi4oCIXCIsXCJRZnJcIjpcIvCdlJRcIixcInFmclwiOlwi8J2UrlwiLFwicWludFwiOlwi4qiMXCIsXCJxb3BmXCI6XCLwnZWiXCIsXCJRb3BmXCI6XCLihJpcIixcInFwcmltZVwiOlwi4oGXXCIsXCJRc2NyXCI6XCLwnZKsXCIsXCJxc2NyXCI6XCLwnZOGXCIsXCJxdWF0ZXJuaW9uc1wiOlwi4oSNXCIsXCJxdWF0aW50XCI6XCLiqJZcIixcInF1ZXN0XCI6XCI/XCIsXCJxdWVzdGVxXCI6XCLiiZ9cIixcInF1b3RcIjpcIlxcXCJcIixcIlFVT1RcIjpcIlxcXCJcIixcInJBYXJyXCI6XCLih5tcIixcInJhY2VcIjpcIuKIvcyxXCIsXCJSYWN1dGVcIjpcIsWUXCIsXCJyYWN1dGVcIjpcIsWVXCIsXCJyYWRpY1wiOlwi4oiaXCIsXCJyYWVtcHR5dlwiOlwi4qazXCIsXCJyYW5nXCI6XCLin6lcIixcIlJhbmdcIjpcIuKfq1wiLFwicmFuZ2RcIjpcIuKmklwiLFwicmFuZ2VcIjpcIuKmpVwiLFwicmFuZ2xlXCI6XCLin6lcIixcInJhcXVvXCI6XCLCu1wiLFwicmFycmFwXCI6XCLipbVcIixcInJhcnJiXCI6XCLih6VcIixcInJhcnJiZnNcIjpcIuKkoFwiLFwicmFycmNcIjpcIuKks1wiLFwicmFyclwiOlwi4oaSXCIsXCJSYXJyXCI6XCLihqBcIixcInJBcnJcIjpcIuKHklwiLFwicmFycmZzXCI6XCLipJ5cIixcInJhcnJoa1wiOlwi4oaqXCIsXCJyYXJybHBcIjpcIuKGrFwiLFwicmFycnBsXCI6XCLipYVcIixcInJhcnJzaW1cIjpcIuKltFwiLFwiUmFycnRsXCI6XCLipJZcIixcInJhcnJ0bFwiOlwi4oajXCIsXCJyYXJyd1wiOlwi4oadXCIsXCJyYXRhaWxcIjpcIuKkmlwiLFwickF0YWlsXCI6XCLipJxcIixcInJhdGlvXCI6XCLiiLZcIixcInJhdGlvbmFsc1wiOlwi4oSaXCIsXCJyYmFyclwiOlwi4qSNXCIsXCJyQmFyclwiOlwi4qSPXCIsXCJSQmFyclwiOlwi4qSQXCIsXCJyYmJya1wiOlwi4p2zXCIsXCJyYnJhY2VcIjpcIn1cIixcInJicmFja1wiOlwiXVwiLFwicmJya2VcIjpcIuKmjFwiLFwicmJya3NsZFwiOlwi4qaOXCIsXCJyYnJrc2x1XCI6XCLippBcIixcIlJjYXJvblwiOlwixZhcIixcInJjYXJvblwiOlwixZlcIixcIlJjZWRpbFwiOlwixZZcIixcInJjZWRpbFwiOlwixZdcIixcInJjZWlsXCI6XCLijIlcIixcInJjdWJcIjpcIn1cIixcIlJjeVwiOlwi0KBcIixcInJjeVwiOlwi0YBcIixcInJkY2FcIjpcIuKkt1wiLFwicmRsZGhhclwiOlwi4qWpXCIsXCJyZHF1b1wiOlwi4oCdXCIsXCJyZHF1b3JcIjpcIuKAnVwiLFwicmRzaFwiOlwi4oazXCIsXCJyZWFsXCI6XCLihJxcIixcInJlYWxpbmVcIjpcIuKEm1wiLFwicmVhbHBhcnRcIjpcIuKEnFwiLFwicmVhbHNcIjpcIuKEnVwiLFwiUmVcIjpcIuKEnFwiLFwicmVjdFwiOlwi4patXCIsXCJyZWdcIjpcIsKuXCIsXCJSRUdcIjpcIsKuXCIsXCJSZXZlcnNlRWxlbWVudFwiOlwi4oiLXCIsXCJSZXZlcnNlRXF1aWxpYnJpdW1cIjpcIuKHi1wiLFwiUmV2ZXJzZVVwRXF1aWxpYnJpdW1cIjpcIuKlr1wiLFwicmZpc2h0XCI6XCLipb1cIixcInJmbG9vclwiOlwi4oyLXCIsXCJyZnJcIjpcIvCdlK9cIixcIlJmclwiOlwi4oScXCIsXCJySGFyXCI6XCLipaRcIixcInJoYXJkXCI6XCLih4FcIixcInJoYXJ1XCI6XCLih4BcIixcInJoYXJ1bFwiOlwi4qWsXCIsXCJSaG9cIjpcIs6hXCIsXCJyaG9cIjpcIs+BXCIsXCJyaG92XCI6XCLPsVwiLFwiUmlnaHRBbmdsZUJyYWNrZXRcIjpcIuKfqVwiLFwiUmlnaHRBcnJvd0JhclwiOlwi4oelXCIsXCJyaWdodGFycm93XCI6XCLihpJcIixcIlJpZ2h0QXJyb3dcIjpcIuKGklwiLFwiUmlnaHRhcnJvd1wiOlwi4oeSXCIsXCJSaWdodEFycm93TGVmdEFycm93XCI6XCLih4RcIixcInJpZ2h0YXJyb3d0YWlsXCI6XCLihqNcIixcIlJpZ2h0Q2VpbGluZ1wiOlwi4oyJXCIsXCJSaWdodERvdWJsZUJyYWNrZXRcIjpcIuKfp1wiLFwiUmlnaHREb3duVGVlVmVjdG9yXCI6XCLipZ1cIixcIlJpZ2h0RG93blZlY3RvckJhclwiOlwi4qWVXCIsXCJSaWdodERvd25WZWN0b3JcIjpcIuKHglwiLFwiUmlnaHRGbG9vclwiOlwi4oyLXCIsXCJyaWdodGhhcnBvb25kb3duXCI6XCLih4FcIixcInJpZ2h0aGFycG9vbnVwXCI6XCLih4BcIixcInJpZ2h0bGVmdGFycm93c1wiOlwi4oeEXCIsXCJyaWdodGxlZnRoYXJwb29uc1wiOlwi4oeMXCIsXCJyaWdodHJpZ2h0YXJyb3dzXCI6XCLih4lcIixcInJpZ2h0c3F1aWdhcnJvd1wiOlwi4oadXCIsXCJSaWdodFRlZUFycm93XCI6XCLihqZcIixcIlJpZ2h0VGVlXCI6XCLiiqJcIixcIlJpZ2h0VGVlVmVjdG9yXCI6XCLipZtcIixcInJpZ2h0dGhyZWV0aW1lc1wiOlwi4ouMXCIsXCJSaWdodFRyaWFuZ2xlQmFyXCI6XCLip5BcIixcIlJpZ2h0VHJpYW5nbGVcIjpcIuKKs1wiLFwiUmlnaHRUcmlhbmdsZUVxdWFsXCI6XCLiirVcIixcIlJpZ2h0VXBEb3duVmVjdG9yXCI6XCLipY9cIixcIlJpZ2h0VXBUZWVWZWN0b3JcIjpcIuKlnFwiLFwiUmlnaHRVcFZlY3RvckJhclwiOlwi4qWUXCIsXCJSaWdodFVwVmVjdG9yXCI6XCLihr5cIixcIlJpZ2h0VmVjdG9yQmFyXCI6XCLipZNcIixcIlJpZ2h0VmVjdG9yXCI6XCLih4BcIixcInJpbmdcIjpcIsuaXCIsXCJyaXNpbmdkb3RzZXFcIjpcIuKJk1wiLFwicmxhcnJcIjpcIuKHhFwiLFwicmxoYXJcIjpcIuKHjFwiLFwicmxtXCI6XCLigI9cIixcInJtb3VzdGFjaGVcIjpcIuKOsVwiLFwicm1vdXN0XCI6XCLijrFcIixcInJubWlkXCI6XCLiq65cIixcInJvYW5nXCI6XCLin61cIixcInJvYXJyXCI6XCLih75cIixcInJvYnJrXCI6XCLin6dcIixcInJvcGFyXCI6XCLipoZcIixcInJvcGZcIjpcIvCdlaNcIixcIlJvcGZcIjpcIuKEnVwiLFwicm9wbHVzXCI6XCLiqK5cIixcInJvdGltZXNcIjpcIuKotVwiLFwiUm91bmRJbXBsaWVzXCI6XCLipbBcIixcInJwYXJcIjpcIilcIixcInJwYXJndFwiOlwi4qaUXCIsXCJycHBvbGludFwiOlwi4qiSXCIsXCJycmFyclwiOlwi4oeJXCIsXCJScmlnaHRhcnJvd1wiOlwi4oebXCIsXCJyc2FxdW9cIjpcIuKAulwiLFwicnNjclwiOlwi8J2Th1wiLFwiUnNjclwiOlwi4oSbXCIsXCJyc2hcIjpcIuKGsVwiLFwiUnNoXCI6XCLihrFcIixcInJzcWJcIjpcIl1cIixcInJzcXVvXCI6XCLigJlcIixcInJzcXVvclwiOlwi4oCZXCIsXCJydGhyZWVcIjpcIuKLjFwiLFwicnRpbWVzXCI6XCLii4pcIixcInJ0cmlcIjpcIuKWuVwiLFwicnRyaWVcIjpcIuKKtVwiLFwicnRyaWZcIjpcIuKWuFwiLFwicnRyaWx0cmlcIjpcIuKnjlwiLFwiUnVsZURlbGF5ZWRcIjpcIuKntFwiLFwicnVsdWhhclwiOlwi4qWoXCIsXCJyeFwiOlwi4oSeXCIsXCJTYWN1dGVcIjpcIsWaXCIsXCJzYWN1dGVcIjpcIsWbXCIsXCJzYnF1b1wiOlwi4oCaXCIsXCJzY2FwXCI6XCLiqrhcIixcIlNjYXJvblwiOlwixaBcIixcInNjYXJvblwiOlwixaFcIixcIlNjXCI6XCLiqrxcIixcInNjXCI6XCLiibtcIixcInNjY3VlXCI6XCLiib1cIixcInNjZVwiOlwi4qqwXCIsXCJzY0VcIjpcIuKqtFwiLFwiU2NlZGlsXCI6XCLFnlwiLFwic2NlZGlsXCI6XCLFn1wiLFwiU2NpcmNcIjpcIsWcXCIsXCJzY2lyY1wiOlwixZ1cIixcInNjbmFwXCI6XCLiqrpcIixcInNjbkVcIjpcIuKqtlwiLFwic2Nuc2ltXCI6XCLii6lcIixcInNjcG9saW50XCI6XCLiqJNcIixcInNjc2ltXCI6XCLiib9cIixcIlNjeVwiOlwi0KFcIixcInNjeVwiOlwi0YFcIixcInNkb3RiXCI6XCLiiqFcIixcInNkb3RcIjpcIuKLhVwiLFwic2RvdGVcIjpcIuKpplwiLFwic2VhcmhrXCI6XCLipKVcIixcInNlYXJyXCI6XCLihphcIixcInNlQXJyXCI6XCLih5hcIixcInNlYXJyb3dcIjpcIuKGmFwiLFwic2VjdFwiOlwiwqdcIixcInNlbWlcIjpcIjtcIixcInNlc3dhclwiOlwi4qSpXCIsXCJzZXRtaW51c1wiOlwi4oiWXCIsXCJzZXRtblwiOlwi4oiWXCIsXCJzZXh0XCI6XCLinLZcIixcIlNmclwiOlwi8J2UllwiLFwic2ZyXCI6XCLwnZSwXCIsXCJzZnJvd25cIjpcIuKMolwiLFwic2hhcnBcIjpcIuKZr1wiLFwiU0hDSGN5XCI6XCLQqVwiLFwic2hjaGN5XCI6XCLRiVwiLFwiU0hjeVwiOlwi0KhcIixcInNoY3lcIjpcItGIXCIsXCJTaG9ydERvd25BcnJvd1wiOlwi4oaTXCIsXCJTaG9ydExlZnRBcnJvd1wiOlwi4oaQXCIsXCJzaG9ydG1pZFwiOlwi4oijXCIsXCJzaG9ydHBhcmFsbGVsXCI6XCLiiKVcIixcIlNob3J0UmlnaHRBcnJvd1wiOlwi4oaSXCIsXCJTaG9ydFVwQXJyb3dcIjpcIuKGkVwiLFwic2h5XCI6XCLCrVwiLFwiU2lnbWFcIjpcIs6jXCIsXCJzaWdtYVwiOlwiz4NcIixcInNpZ21hZlwiOlwiz4JcIixcInNpZ21hdlwiOlwiz4JcIixcInNpbVwiOlwi4oi8XCIsXCJzaW1kb3RcIjpcIuKpqlwiLFwic2ltZVwiOlwi4omDXCIsXCJzaW1lcVwiOlwi4omDXCIsXCJzaW1nXCI6XCLiqp5cIixcInNpbWdFXCI6XCLiqqBcIixcInNpbWxcIjpcIuKqnVwiLFwic2ltbEVcIjpcIuKqn1wiLFwic2ltbmVcIjpcIuKJhlwiLFwic2ltcGx1c1wiOlwi4qikXCIsXCJzaW1yYXJyXCI6XCLipbJcIixcInNsYXJyXCI6XCLihpBcIixcIlNtYWxsQ2lyY2xlXCI6XCLiiJhcIixcInNtYWxsc2V0bWludXNcIjpcIuKIllwiLFwic21hc2hwXCI6XCLiqLNcIixcInNtZXBhcnNsXCI6XCLip6RcIixcInNtaWRcIjpcIuKIo1wiLFwic21pbGVcIjpcIuKMo1wiLFwic210XCI6XCLiqqpcIixcInNtdGVcIjpcIuKqrFwiLFwic210ZXNcIjpcIuKqrO+4gFwiLFwiU09GVGN5XCI6XCLQrFwiLFwic29mdGN5XCI6XCLRjFwiLFwic29sYmFyXCI6XCLijL9cIixcInNvbGJcIjpcIuKnhFwiLFwic29sXCI6XCIvXCIsXCJTb3BmXCI6XCLwnZWKXCIsXCJzb3BmXCI6XCLwnZWkXCIsXCJzcGFkZXNcIjpcIuKZoFwiLFwic3BhZGVzdWl0XCI6XCLimaBcIixcInNwYXJcIjpcIuKIpVwiLFwic3FjYXBcIjpcIuKKk1wiLFwic3FjYXBzXCI6XCLiipPvuIBcIixcInNxY3VwXCI6XCLiipRcIixcInNxY3Vwc1wiOlwi4oqU77iAXCIsXCJTcXJ0XCI6XCLiiJpcIixcInNxc3ViXCI6XCLiio9cIixcInNxc3ViZVwiOlwi4oqRXCIsXCJzcXN1YnNldFwiOlwi4oqPXCIsXCJzcXN1YnNldGVxXCI6XCLiipFcIixcInNxc3VwXCI6XCLiipBcIixcInNxc3VwZVwiOlwi4oqSXCIsXCJzcXN1cHNldFwiOlwi4oqQXCIsXCJzcXN1cHNldGVxXCI6XCLiipJcIixcInNxdWFyZVwiOlwi4pahXCIsXCJTcXVhcmVcIjpcIuKWoVwiLFwiU3F1YXJlSW50ZXJzZWN0aW9uXCI6XCLiipNcIixcIlNxdWFyZVN1YnNldFwiOlwi4oqPXCIsXCJTcXVhcmVTdWJzZXRFcXVhbFwiOlwi4oqRXCIsXCJTcXVhcmVTdXBlcnNldFwiOlwi4oqQXCIsXCJTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCLiipJcIixcIlNxdWFyZVVuaW9uXCI6XCLiipRcIixcInNxdWFyZlwiOlwi4paqXCIsXCJzcXVcIjpcIuKWoVwiLFwic3F1ZlwiOlwi4paqXCIsXCJzcmFyclwiOlwi4oaSXCIsXCJTc2NyXCI6XCLwnZKuXCIsXCJzc2NyXCI6XCLwnZOIXCIsXCJzc2V0bW5cIjpcIuKIllwiLFwic3NtaWxlXCI6XCLijKNcIixcInNzdGFyZlwiOlwi4ouGXCIsXCJTdGFyXCI6XCLii4ZcIixcInN0YXJcIjpcIuKYhlwiLFwic3RhcmZcIjpcIuKYhVwiLFwic3RyYWlnaHRlcHNpbG9uXCI6XCLPtVwiLFwic3RyYWlnaHRwaGlcIjpcIs+VXCIsXCJzdHJuc1wiOlwiwq9cIixcInN1YlwiOlwi4oqCXCIsXCJTdWJcIjpcIuKLkFwiLFwic3ViZG90XCI6XCLiqr1cIixcInN1YkVcIjpcIuKrhVwiLFwic3ViZVwiOlwi4oqGXCIsXCJzdWJlZG90XCI6XCLiq4NcIixcInN1Ym11bHRcIjpcIuKrgVwiLFwic3VibkVcIjpcIuKri1wiLFwic3VibmVcIjpcIuKKilwiLFwic3VicGx1c1wiOlwi4qq/XCIsXCJzdWJyYXJyXCI6XCLipblcIixcInN1YnNldFwiOlwi4oqCXCIsXCJTdWJzZXRcIjpcIuKLkFwiLFwic3Vic2V0ZXFcIjpcIuKKhlwiLFwic3Vic2V0ZXFxXCI6XCLiq4VcIixcIlN1YnNldEVxdWFsXCI6XCLiioZcIixcInN1YnNldG5lcVwiOlwi4oqKXCIsXCJzdWJzZXRuZXFxXCI6XCLiq4tcIixcInN1YnNpbVwiOlwi4quHXCIsXCJzdWJzdWJcIjpcIuKrlVwiLFwic3Vic3VwXCI6XCLiq5NcIixcInN1Y2NhcHByb3hcIjpcIuKquFwiLFwic3VjY1wiOlwi4om7XCIsXCJzdWNjY3VybHllcVwiOlwi4om9XCIsXCJTdWNjZWVkc1wiOlwi4om7XCIsXCJTdWNjZWVkc0VxdWFsXCI6XCLiqrBcIixcIlN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwi4om9XCIsXCJTdWNjZWVkc1RpbGRlXCI6XCLiib9cIixcInN1Y2NlcVwiOlwi4qqwXCIsXCJzdWNjbmFwcHJveFwiOlwi4qq6XCIsXCJzdWNjbmVxcVwiOlwi4qq2XCIsXCJzdWNjbnNpbVwiOlwi4oupXCIsXCJzdWNjc2ltXCI6XCLiib9cIixcIlN1Y2hUaGF0XCI6XCLiiItcIixcInN1bVwiOlwi4oiRXCIsXCJTdW1cIjpcIuKIkVwiLFwic3VuZ1wiOlwi4pmqXCIsXCJzdXAxXCI6XCLCuVwiLFwic3VwMlwiOlwiwrJcIixcInN1cDNcIjpcIsKzXCIsXCJzdXBcIjpcIuKKg1wiLFwiU3VwXCI6XCLii5FcIixcInN1cGRvdFwiOlwi4qq+XCIsXCJzdXBkc3ViXCI6XCLiq5hcIixcInN1cEVcIjpcIuKrhlwiLFwic3VwZVwiOlwi4oqHXCIsXCJzdXBlZG90XCI6XCLiq4RcIixcIlN1cGVyc2V0XCI6XCLiioNcIixcIlN1cGVyc2V0RXF1YWxcIjpcIuKKh1wiLFwic3VwaHNvbFwiOlwi4p+JXCIsXCJzdXBoc3ViXCI6XCLiq5dcIixcInN1cGxhcnJcIjpcIuKlu1wiLFwic3VwbXVsdFwiOlwi4quCXCIsXCJzdXBuRVwiOlwi4quMXCIsXCJzdXBuZVwiOlwi4oqLXCIsXCJzdXBwbHVzXCI6XCLiq4BcIixcInN1cHNldFwiOlwi4oqDXCIsXCJTdXBzZXRcIjpcIuKLkVwiLFwic3Vwc2V0ZXFcIjpcIuKKh1wiLFwic3Vwc2V0ZXFxXCI6XCLiq4ZcIixcInN1cHNldG5lcVwiOlwi4oqLXCIsXCJzdXBzZXRuZXFxXCI6XCLiq4xcIixcInN1cHNpbVwiOlwi4quIXCIsXCJzdXBzdWJcIjpcIuKrlFwiLFwic3Vwc3VwXCI6XCLiq5ZcIixcInN3YXJoa1wiOlwi4qSmXCIsXCJzd2FyclwiOlwi4oaZXCIsXCJzd0FyclwiOlwi4oeZXCIsXCJzd2Fycm93XCI6XCLihplcIixcInN3bndhclwiOlwi4qSqXCIsXCJzemxpZ1wiOlwiw59cIixcIlRhYlwiOlwiXFx0XCIsXCJ0YXJnZXRcIjpcIuKMllwiLFwiVGF1XCI6XCLOpFwiLFwidGF1XCI6XCLPhFwiLFwidGJya1wiOlwi4o60XCIsXCJUY2Fyb25cIjpcIsWkXCIsXCJ0Y2Fyb25cIjpcIsWlXCIsXCJUY2VkaWxcIjpcIsWiXCIsXCJ0Y2VkaWxcIjpcIsWjXCIsXCJUY3lcIjpcItCiXCIsXCJ0Y3lcIjpcItGCXCIsXCJ0ZG90XCI6XCLig5tcIixcInRlbHJlY1wiOlwi4oyVXCIsXCJUZnJcIjpcIvCdlJdcIixcInRmclwiOlwi8J2UsVwiLFwidGhlcmU0XCI6XCLiiLRcIixcInRoZXJlZm9yZVwiOlwi4oi0XCIsXCJUaGVyZWZvcmVcIjpcIuKItFwiLFwiVGhldGFcIjpcIs6YXCIsXCJ0aGV0YVwiOlwizrhcIixcInRoZXRhc3ltXCI6XCLPkVwiLFwidGhldGF2XCI6XCLPkVwiLFwidGhpY2thcHByb3hcIjpcIuKJiFwiLFwidGhpY2tzaW1cIjpcIuKIvFwiLFwiVGhpY2tTcGFjZVwiOlwi4oGf4oCKXCIsXCJUaGluU3BhY2VcIjpcIuKAiVwiLFwidGhpbnNwXCI6XCLigIlcIixcInRoa2FwXCI6XCLiiYhcIixcInRoa3NpbVwiOlwi4oi8XCIsXCJUSE9STlwiOlwiw55cIixcInRob3JuXCI6XCLDvlwiLFwidGlsZGVcIjpcIsucXCIsXCJUaWxkZVwiOlwi4oi8XCIsXCJUaWxkZUVxdWFsXCI6XCLiiYNcIixcIlRpbGRlRnVsbEVxdWFsXCI6XCLiiYVcIixcIlRpbGRlVGlsZGVcIjpcIuKJiFwiLFwidGltZXNiYXJcIjpcIuKosVwiLFwidGltZXNiXCI6XCLiiqBcIixcInRpbWVzXCI6XCLDl1wiLFwidGltZXNkXCI6XCLiqLBcIixcInRpbnRcIjpcIuKIrVwiLFwidG9lYVwiOlwi4qSoXCIsXCJ0b3Bib3RcIjpcIuKMtlwiLFwidG9wY2lyXCI6XCLiq7FcIixcInRvcFwiOlwi4oqkXCIsXCJUb3BmXCI6XCLwnZWLXCIsXCJ0b3BmXCI6XCLwnZWlXCIsXCJ0b3Bmb3JrXCI6XCLiq5pcIixcInRvc2FcIjpcIuKkqVwiLFwidHByaW1lXCI6XCLigLRcIixcInRyYWRlXCI6XCLihKJcIixcIlRSQURFXCI6XCLihKJcIixcInRyaWFuZ2xlXCI6XCLilrVcIixcInRyaWFuZ2xlZG93blwiOlwi4pa/XCIsXCJ0cmlhbmdsZWxlZnRcIjpcIuKXg1wiLFwidHJpYW5nbGVsZWZ0ZXFcIjpcIuKKtFwiLFwidHJpYW5nbGVxXCI6XCLiiZxcIixcInRyaWFuZ2xlcmlnaHRcIjpcIuKWuVwiLFwidHJpYW5nbGVyaWdodGVxXCI6XCLiirVcIixcInRyaWRvdFwiOlwi4pesXCIsXCJ0cmllXCI6XCLiiZxcIixcInRyaW1pbnVzXCI6XCLiqLpcIixcIlRyaXBsZURvdFwiOlwi4oObXCIsXCJ0cmlwbHVzXCI6XCLiqLlcIixcInRyaXNiXCI6XCLip41cIixcInRyaXRpbWVcIjpcIuKou1wiLFwidHJwZXppdW1cIjpcIuKPolwiLFwiVHNjclwiOlwi8J2Sr1wiLFwidHNjclwiOlwi8J2TiVwiLFwiVFNjeVwiOlwi0KZcIixcInRzY3lcIjpcItGGXCIsXCJUU0hjeVwiOlwi0ItcIixcInRzaGN5XCI6XCLRm1wiLFwiVHN0cm9rXCI6XCLFplwiLFwidHN0cm9rXCI6XCLFp1wiLFwidHdpeHRcIjpcIuKJrFwiLFwidHdvaGVhZGxlZnRhcnJvd1wiOlwi4oaeXCIsXCJ0d29oZWFkcmlnaHRhcnJvd1wiOlwi4oagXCIsXCJVYWN1dGVcIjpcIsOaXCIsXCJ1YWN1dGVcIjpcIsO6XCIsXCJ1YXJyXCI6XCLihpFcIixcIlVhcnJcIjpcIuKGn1wiLFwidUFyclwiOlwi4oeRXCIsXCJVYXJyb2NpclwiOlwi4qWJXCIsXCJVYnJjeVwiOlwi0I5cIixcInVicmN5XCI6XCLRnlwiLFwiVWJyZXZlXCI6XCLFrFwiLFwidWJyZXZlXCI6XCLFrVwiLFwiVWNpcmNcIjpcIsObXCIsXCJ1Y2lyY1wiOlwiw7tcIixcIlVjeVwiOlwi0KNcIixcInVjeVwiOlwi0YNcIixcInVkYXJyXCI6XCLih4VcIixcIlVkYmxhY1wiOlwixbBcIixcInVkYmxhY1wiOlwixbFcIixcInVkaGFyXCI6XCLipa5cIixcInVmaXNodFwiOlwi4qW+XCIsXCJVZnJcIjpcIvCdlJhcIixcInVmclwiOlwi8J2UslwiLFwiVWdyYXZlXCI6XCLDmVwiLFwidWdyYXZlXCI6XCLDuVwiLFwidUhhclwiOlwi4qWjXCIsXCJ1aGFybFwiOlwi4oa/XCIsXCJ1aGFyclwiOlwi4oa+XCIsXCJ1aGJsa1wiOlwi4paAXCIsXCJ1bGNvcm5cIjpcIuKMnFwiLFwidWxjb3JuZXJcIjpcIuKMnFwiLFwidWxjcm9wXCI6XCLijI9cIixcInVsdHJpXCI6XCLil7hcIixcIlVtYWNyXCI6XCLFqlwiLFwidW1hY3JcIjpcIsWrXCIsXCJ1bWxcIjpcIsKoXCIsXCJVbmRlckJhclwiOlwiX1wiLFwiVW5kZXJCcmFjZVwiOlwi4o+fXCIsXCJVbmRlckJyYWNrZXRcIjpcIuKOtVwiLFwiVW5kZXJQYXJlbnRoZXNpc1wiOlwi4o+dXCIsXCJVbmlvblwiOlwi4ouDXCIsXCJVbmlvblBsdXNcIjpcIuKKjlwiLFwiVW9nb25cIjpcIsWyXCIsXCJ1b2dvblwiOlwixbNcIixcIlVvcGZcIjpcIvCdlYxcIixcInVvcGZcIjpcIvCdlaZcIixcIlVwQXJyb3dCYXJcIjpcIuKkklwiLFwidXBhcnJvd1wiOlwi4oaRXCIsXCJVcEFycm93XCI6XCLihpFcIixcIlVwYXJyb3dcIjpcIuKHkVwiLFwiVXBBcnJvd0Rvd25BcnJvd1wiOlwi4oeFXCIsXCJ1cGRvd25hcnJvd1wiOlwi4oaVXCIsXCJVcERvd25BcnJvd1wiOlwi4oaVXCIsXCJVcGRvd25hcnJvd1wiOlwi4oeVXCIsXCJVcEVxdWlsaWJyaXVtXCI6XCLipa5cIixcInVwaGFycG9vbmxlZnRcIjpcIuKGv1wiLFwidXBoYXJwb29ucmlnaHRcIjpcIuKGvlwiLFwidXBsdXNcIjpcIuKKjlwiLFwiVXBwZXJMZWZ0QXJyb3dcIjpcIuKGllwiLFwiVXBwZXJSaWdodEFycm93XCI6XCLihpdcIixcInVwc2lcIjpcIs+FXCIsXCJVcHNpXCI6XCLPklwiLFwidXBzaWhcIjpcIs+SXCIsXCJVcHNpbG9uXCI6XCLOpVwiLFwidXBzaWxvblwiOlwiz4VcIixcIlVwVGVlQXJyb3dcIjpcIuKGpVwiLFwiVXBUZWVcIjpcIuKKpVwiLFwidXB1cGFycm93c1wiOlwi4oeIXCIsXCJ1cmNvcm5cIjpcIuKMnVwiLFwidXJjb3JuZXJcIjpcIuKMnVwiLFwidXJjcm9wXCI6XCLijI5cIixcIlVyaW5nXCI6XCLFrlwiLFwidXJpbmdcIjpcIsWvXCIsXCJ1cnRyaVwiOlwi4pe5XCIsXCJVc2NyXCI6XCLwnZKwXCIsXCJ1c2NyXCI6XCLwnZOKXCIsXCJ1dGRvdFwiOlwi4ouwXCIsXCJVdGlsZGVcIjpcIsWoXCIsXCJ1dGlsZGVcIjpcIsWpXCIsXCJ1dHJpXCI6XCLilrVcIixcInV0cmlmXCI6XCLilrRcIixcInV1YXJyXCI6XCLih4hcIixcIlV1bWxcIjpcIsOcXCIsXCJ1dW1sXCI6XCLDvFwiLFwidXdhbmdsZVwiOlwi4qanXCIsXCJ2YW5ncnRcIjpcIuKmnFwiLFwidmFyZXBzaWxvblwiOlwiz7VcIixcInZhcmthcHBhXCI6XCLPsFwiLFwidmFybm90aGluZ1wiOlwi4oiFXCIsXCJ2YXJwaGlcIjpcIs+VXCIsXCJ2YXJwaVwiOlwiz5ZcIixcInZhcnByb3B0b1wiOlwi4oidXCIsXCJ2YXJyXCI6XCLihpVcIixcInZBcnJcIjpcIuKHlVwiLFwidmFycmhvXCI6XCLPsVwiLFwidmFyc2lnbWFcIjpcIs+CXCIsXCJ2YXJzdWJzZXRuZXFcIjpcIuKKiu+4gFwiLFwidmFyc3Vic2V0bmVxcVwiOlwi4quL77iAXCIsXCJ2YXJzdXBzZXRuZXFcIjpcIuKKi++4gFwiLFwidmFyc3Vwc2V0bmVxcVwiOlwi4quM77iAXCIsXCJ2YXJ0aGV0YVwiOlwiz5FcIixcInZhcnRyaWFuZ2xlbGVmdFwiOlwi4oqyXCIsXCJ2YXJ0cmlhbmdsZXJpZ2h0XCI6XCLiirNcIixcInZCYXJcIjpcIuKrqFwiLFwiVmJhclwiOlwi4qurXCIsXCJ2QmFydlwiOlwi4qupXCIsXCJWY3lcIjpcItCSXCIsXCJ2Y3lcIjpcItCyXCIsXCJ2ZGFzaFwiOlwi4oqiXCIsXCJ2RGFzaFwiOlwi4oqoXCIsXCJWZGFzaFwiOlwi4oqpXCIsXCJWRGFzaFwiOlwi4oqrXCIsXCJWZGFzaGxcIjpcIuKrplwiLFwidmVlYmFyXCI6XCLiirtcIixcInZlZVwiOlwi4oioXCIsXCJWZWVcIjpcIuKLgVwiLFwidmVlZXFcIjpcIuKJmlwiLFwidmVsbGlwXCI6XCLii65cIixcInZlcmJhclwiOlwifFwiLFwiVmVyYmFyXCI6XCLigJZcIixcInZlcnRcIjpcInxcIixcIlZlcnRcIjpcIuKAllwiLFwiVmVydGljYWxCYXJcIjpcIuKIo1wiLFwiVmVydGljYWxMaW5lXCI6XCJ8XCIsXCJWZXJ0aWNhbFNlcGFyYXRvclwiOlwi4p2YXCIsXCJWZXJ0aWNhbFRpbGRlXCI6XCLiiYBcIixcIlZlcnlUaGluU3BhY2VcIjpcIuKAilwiLFwiVmZyXCI6XCLwnZSZXCIsXCJ2ZnJcIjpcIvCdlLNcIixcInZsdHJpXCI6XCLiirJcIixcInZuc3ViXCI6XCLiioLig5JcIixcInZuc3VwXCI6XCLiioPig5JcIixcIlZvcGZcIjpcIvCdlY1cIixcInZvcGZcIjpcIvCdladcIixcInZwcm9wXCI6XCLiiJ1cIixcInZydHJpXCI6XCLiirNcIixcIlZzY3JcIjpcIvCdkrFcIixcInZzY3JcIjpcIvCdk4tcIixcInZzdWJuRVwiOlwi4quL77iAXCIsXCJ2c3VibmVcIjpcIuKKiu+4gFwiLFwidnN1cG5FXCI6XCLiq4zvuIBcIixcInZzdXBuZVwiOlwi4oqL77iAXCIsXCJWdmRhc2hcIjpcIuKKqlwiLFwidnppZ3phZ1wiOlwi4qaaXCIsXCJXY2lyY1wiOlwixbRcIixcIndjaXJjXCI6XCLFtVwiLFwid2VkYmFyXCI6XCLiqZ9cIixcIndlZGdlXCI6XCLiiKdcIixcIldlZGdlXCI6XCLii4BcIixcIndlZGdlcVwiOlwi4omZXCIsXCJ3ZWllcnBcIjpcIuKEmFwiLFwiV2ZyXCI6XCLwnZSaXCIsXCJ3ZnJcIjpcIvCdlLRcIixcIldvcGZcIjpcIvCdlY5cIixcIndvcGZcIjpcIvCdlahcIixcIndwXCI6XCLihJhcIixcIndyXCI6XCLiiYBcIixcIndyZWF0aFwiOlwi4omAXCIsXCJXc2NyXCI6XCLwnZKyXCIsXCJ3c2NyXCI6XCLwnZOMXCIsXCJ4Y2FwXCI6XCLii4JcIixcInhjaXJjXCI6XCLil69cIixcInhjdXBcIjpcIuKLg1wiLFwieGR0cmlcIjpcIuKWvVwiLFwiWGZyXCI6XCLwnZSbXCIsXCJ4ZnJcIjpcIvCdlLVcIixcInhoYXJyXCI6XCLin7dcIixcInhoQXJyXCI6XCLin7pcIixcIlhpXCI6XCLOnlwiLFwieGlcIjpcIs6+XCIsXCJ4bGFyclwiOlwi4p+1XCIsXCJ4bEFyclwiOlwi4p+4XCIsXCJ4bWFwXCI6XCLin7xcIixcInhuaXNcIjpcIuKLu1wiLFwieG9kb3RcIjpcIuKogFwiLFwiWG9wZlwiOlwi8J2Vj1wiLFwieG9wZlwiOlwi8J2VqVwiLFwieG9wbHVzXCI6XCLiqIFcIixcInhvdGltZVwiOlwi4qiCXCIsXCJ4cmFyclwiOlwi4p+2XCIsXCJ4ckFyclwiOlwi4p+5XCIsXCJYc2NyXCI6XCLwnZKzXCIsXCJ4c2NyXCI6XCLwnZONXCIsXCJ4c3FjdXBcIjpcIuKohlwiLFwieHVwbHVzXCI6XCLiqIRcIixcInh1dHJpXCI6XCLilrNcIixcInh2ZWVcIjpcIuKLgVwiLFwieHdlZGdlXCI6XCLii4BcIixcIllhY3V0ZVwiOlwiw51cIixcInlhY3V0ZVwiOlwiw71cIixcIllBY3lcIjpcItCvXCIsXCJ5YWN5XCI6XCLRj1wiLFwiWWNpcmNcIjpcIsW2XCIsXCJ5Y2lyY1wiOlwixbdcIixcIlljeVwiOlwi0KtcIixcInljeVwiOlwi0YtcIixcInllblwiOlwiwqVcIixcIllmclwiOlwi8J2UnFwiLFwieWZyXCI6XCLwnZS2XCIsXCJZSWN5XCI6XCLQh1wiLFwieWljeVwiOlwi0ZdcIixcIllvcGZcIjpcIvCdlZBcIixcInlvcGZcIjpcIvCdlapcIixcIllzY3JcIjpcIvCdkrRcIixcInlzY3JcIjpcIvCdk45cIixcIllVY3lcIjpcItCuXCIsXCJ5dWN5XCI6XCLRjlwiLFwieXVtbFwiOlwiw79cIixcIll1bWxcIjpcIsW4XCIsXCJaYWN1dGVcIjpcIsW5XCIsXCJ6YWN1dGVcIjpcIsW6XCIsXCJaY2Fyb25cIjpcIsW9XCIsXCJ6Y2Fyb25cIjpcIsW+XCIsXCJaY3lcIjpcItCXXCIsXCJ6Y3lcIjpcItC3XCIsXCJaZG90XCI6XCLFu1wiLFwiemRvdFwiOlwixbxcIixcInplZXRyZlwiOlwi4oSoXCIsXCJaZXJvV2lkdGhTcGFjZVwiOlwi4oCLXCIsXCJaZXRhXCI6XCLOllwiLFwiemV0YVwiOlwizrZcIixcInpmclwiOlwi8J2Ut1wiLFwiWmZyXCI6XCLihKhcIixcIlpIY3lcIjpcItCWXCIsXCJ6aGN5XCI6XCLQtlwiLFwiemlncmFyclwiOlwi4oedXCIsXCJ6b3BmXCI6XCLwnZWrXCIsXCJab3BmXCI6XCLihKRcIixcIlpzY3JcIjpcIvCdkrVcIixcInpzY3JcIjpcIvCdk49cIixcInp3alwiOlwi4oCNXCIsXCJ6d25qXCI6XCLigIxcIn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcIkFhY3V0ZVwiOlwiw4FcIixcImFhY3V0ZVwiOlwiw6FcIixcIkFjaXJjXCI6XCLDglwiLFwiYWNpcmNcIjpcIsOiXCIsXCJhY3V0ZVwiOlwiwrRcIixcIkFFbGlnXCI6XCLDhlwiLFwiYWVsaWdcIjpcIsOmXCIsXCJBZ3JhdmVcIjpcIsOAXCIsXCJhZ3JhdmVcIjpcIsOgXCIsXCJhbXBcIjpcIiZcIixcIkFNUFwiOlwiJlwiLFwiQXJpbmdcIjpcIsOFXCIsXCJhcmluZ1wiOlwiw6VcIixcIkF0aWxkZVwiOlwiw4NcIixcImF0aWxkZVwiOlwiw6NcIixcIkF1bWxcIjpcIsOEXCIsXCJhdW1sXCI6XCLDpFwiLFwiYnJ2YmFyXCI6XCLCplwiLFwiQ2NlZGlsXCI6XCLDh1wiLFwiY2NlZGlsXCI6XCLDp1wiLFwiY2VkaWxcIjpcIsK4XCIsXCJjZW50XCI6XCLColwiLFwiY29weVwiOlwiwqlcIixcIkNPUFlcIjpcIsKpXCIsXCJjdXJyZW5cIjpcIsKkXCIsXCJkZWdcIjpcIsKwXCIsXCJkaXZpZGVcIjpcIsO3XCIsXCJFYWN1dGVcIjpcIsOJXCIsXCJlYWN1dGVcIjpcIsOpXCIsXCJFY2lyY1wiOlwiw4pcIixcImVjaXJjXCI6XCLDqlwiLFwiRWdyYXZlXCI6XCLDiFwiLFwiZWdyYXZlXCI6XCLDqFwiLFwiRVRIXCI6XCLDkFwiLFwiZXRoXCI6XCLDsFwiLFwiRXVtbFwiOlwiw4tcIixcImV1bWxcIjpcIsOrXCIsXCJmcmFjMTJcIjpcIsK9XCIsXCJmcmFjMTRcIjpcIsK8XCIsXCJmcmFjMzRcIjpcIsK+XCIsXCJndFwiOlwiPlwiLFwiR1RcIjpcIj5cIixcIklhY3V0ZVwiOlwiw41cIixcImlhY3V0ZVwiOlwiw61cIixcIkljaXJjXCI6XCLDjlwiLFwiaWNpcmNcIjpcIsOuXCIsXCJpZXhjbFwiOlwiwqFcIixcIklncmF2ZVwiOlwiw4xcIixcImlncmF2ZVwiOlwiw6xcIixcImlxdWVzdFwiOlwiwr9cIixcIkl1bWxcIjpcIsOPXCIsXCJpdW1sXCI6XCLDr1wiLFwibGFxdW9cIjpcIsKrXCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIm1hY3JcIjpcIsKvXCIsXCJtaWNyb1wiOlwiwrVcIixcIm1pZGRvdFwiOlwiwrdcIixcIm5ic3BcIjpcIsKgXCIsXCJub3RcIjpcIsKsXCIsXCJOdGlsZGVcIjpcIsORXCIsXCJudGlsZGVcIjpcIsOxXCIsXCJPYWN1dGVcIjpcIsOTXCIsXCJvYWN1dGVcIjpcIsOzXCIsXCJPY2lyY1wiOlwiw5RcIixcIm9jaXJjXCI6XCLDtFwiLFwiT2dyYXZlXCI6XCLDklwiLFwib2dyYXZlXCI6XCLDslwiLFwib3JkZlwiOlwiwqpcIixcIm9yZG1cIjpcIsK6XCIsXCJPc2xhc2hcIjpcIsOYXCIsXCJvc2xhc2hcIjpcIsO4XCIsXCJPdGlsZGVcIjpcIsOVXCIsXCJvdGlsZGVcIjpcIsO1XCIsXCJPdW1sXCI6XCLDllwiLFwib3VtbFwiOlwiw7ZcIixcInBhcmFcIjpcIsK2XCIsXCJwbHVzbW5cIjpcIsKxXCIsXCJwb3VuZFwiOlwiwqNcIixcInF1b3RcIjpcIlxcXCJcIixcIlFVT1RcIjpcIlxcXCJcIixcInJhcXVvXCI6XCLCu1wiLFwicmVnXCI6XCLCrlwiLFwiUkVHXCI6XCLCrlwiLFwic2VjdFwiOlwiwqdcIixcInNoeVwiOlwiwq1cIixcInN1cDFcIjpcIsK5XCIsXCJzdXAyXCI6XCLCslwiLFwic3VwM1wiOlwiwrNcIixcInN6bGlnXCI6XCLDn1wiLFwiVEhPUk5cIjpcIsOeXCIsXCJ0aG9yblwiOlwiw75cIixcInRpbWVzXCI6XCLDl1wiLFwiVWFjdXRlXCI6XCLDmlwiLFwidWFjdXRlXCI6XCLDulwiLFwiVWNpcmNcIjpcIsObXCIsXCJ1Y2lyY1wiOlwiw7tcIixcIlVncmF2ZVwiOlwiw5lcIixcInVncmF2ZVwiOlwiw7lcIixcInVtbFwiOlwiwqhcIixcIlV1bWxcIjpcIsOcXCIsXCJ1dW1sXCI6XCLDvFwiLFwiWWFjdXRlXCI6XCLDnVwiLFwieWFjdXRlXCI6XCLDvVwiLFwieWVuXCI6XCLCpVwiLFwieXVtbFwiOlwiw79cIn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcImFtcFwiOlwiJlwiLFwiYXBvc1wiOlwiJ1wiLFwiZ3RcIjpcIj5cIixcImx0XCI6XCI8XCIsXCJxdW90XCI6XCJcXFwiXCJ9XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBldmVudExpc3RlbmVyKCkge1xuICAgICAgaWYgKGVycm9yTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgdmFyIGVycm9yTGlzdGVuZXI7XG5cbiAgICAvLyBBZGRpbmcgYW4gZXJyb3IgbGlzdGVuZXIgaXMgbm90IG9wdGlvbmFsIGJlY2F1c2VcbiAgICAvLyBpZiBhbiBlcnJvciBpcyB0aHJvd24gb24gYW4gZXZlbnQgZW1pdHRlciB3ZSBjYW5ub3RcbiAgICAvLyBndWFyYW50ZWUgdGhhdCB0aGUgYWN0dWFsIGV2ZW50IHdlIGFyZSB3YWl0aW5nIHdpbGxcbiAgICAvLyBiZSBmaXJlZC4gVGhlIHJlc3VsdCBjb3VsZCBiZSBhIHNpbGVudCB3YXkgdG8gY3JlYXRlXG4gICAgLy8gbWVtb3J5IG9yIGZpbGUgZGVzY3JpcHRvciBsZWFrcywgd2hpY2ggaXMgc29tZXRoaW5nXG4gICAgLy8gd2Ugc2hvdWxkIGF2b2lkLlxuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBlcnJvckxpc3RlbmVyID0gZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9O1xuXG4gICAgICBlbWl0dGVyLm9uY2UoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgZW1pdHRlci5vbmNlKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUZlZWQgPSBleHBvcnRzLkZlZWRIYW5kbGVyID0gdm9pZCAwO1xudmFyIGRvbWhhbmRsZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG9taGFuZGxlclwiKSk7XG52YXIgRG9tVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImRvbXV0aWxzXCIpKTtcbnZhciBQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL1BhcnNlclwiKTtcbnZhciBGZWVkSXRlbU1lZGlhTWVkaXVtO1xuKGZ1bmN0aW9uIChGZWVkSXRlbU1lZGlhTWVkaXVtKSB7XG4gICAgRmVlZEl0ZW1NZWRpYU1lZGl1bVtGZWVkSXRlbU1lZGlhTWVkaXVtW1wiaW1hZ2VcIl0gPSAwXSA9IFwiaW1hZ2VcIjtcbiAgICBGZWVkSXRlbU1lZGlhTWVkaXVtW0ZlZWRJdGVtTWVkaWFNZWRpdW1bXCJhdWRpb1wiXSA9IDFdID0gXCJhdWRpb1wiO1xuICAgIEZlZWRJdGVtTWVkaWFNZWRpdW1bRmVlZEl0ZW1NZWRpYU1lZGl1bVtcInZpZGVvXCJdID0gMl0gPSBcInZpZGVvXCI7XG4gICAgRmVlZEl0ZW1NZWRpYU1lZGl1bVtGZWVkSXRlbU1lZGlhTWVkaXVtW1wiZG9jdW1lbnRcIl0gPSAzXSA9IFwiZG9jdW1lbnRcIjtcbiAgICBGZWVkSXRlbU1lZGlhTWVkaXVtW0ZlZWRJdGVtTWVkaWFNZWRpdW1bXCJleGVjdXRhYmxlXCJdID0gNF0gPSBcImV4ZWN1dGFibGVcIjtcbn0pKEZlZWRJdGVtTWVkaWFNZWRpdW0gfHwgKEZlZWRJdGVtTWVkaWFNZWRpdW0gPSB7fSkpO1xudmFyIEZlZWRJdGVtTWVkaWFFeHByZXNzaW9uO1xuKGZ1bmN0aW9uIChGZWVkSXRlbU1lZGlhRXhwcmVzc2lvbikge1xuICAgIEZlZWRJdGVtTWVkaWFFeHByZXNzaW9uW0ZlZWRJdGVtTWVkaWFFeHByZXNzaW9uW1wic2FtcGxlXCJdID0gMF0gPSBcInNhbXBsZVwiO1xuICAgIEZlZWRJdGVtTWVkaWFFeHByZXNzaW9uW0ZlZWRJdGVtTWVkaWFFeHByZXNzaW9uW1wiZnVsbFwiXSA9IDFdID0gXCJmdWxsXCI7XG4gICAgRmVlZEl0ZW1NZWRpYUV4cHJlc3Npb25bRmVlZEl0ZW1NZWRpYUV4cHJlc3Npb25bXCJub25zdG9wXCJdID0gMl0gPSBcIm5vbnN0b3BcIjtcbn0pKEZlZWRJdGVtTWVkaWFFeHByZXNzaW9uIHx8IChGZWVkSXRlbU1lZGlhRXhwcmVzc2lvbiA9IHt9KSk7XG4vLyBUT0RPOiBDb25zdW1lIGRhdGEgYXMgaXQgaXMgY29taW5nIGluXG52YXIgRmVlZEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZlZWRIYW5kbGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGZWVkSGFuZGxlcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGxiYWNrLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZlZWRIYW5kbGVyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGZlZWQgPSB7fTtcbiAgICAgICAgdmFyIGZlZWRSb290ID0gZ2V0T25lRWxlbWVudChpc1ZhbGlkRmVlZCwgdGhpcy5kb20pO1xuICAgICAgICBpZiAoZmVlZFJvb3QpIHtcbiAgICAgICAgICAgIGlmIChmZWVkUm9vdC5uYW1lID09PSBcImZlZWRcIikge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHMgPSBmZWVkUm9vdC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBmZWVkLnR5cGUgPSBcImF0b21cIjtcbiAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiaWRcIiwgXCJpZFwiLCBjaGlsZHMpO1xuICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJ0aXRsZVwiLCBcInRpdGxlXCIsIGNoaWxkcyk7XG4gICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBnZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGdldE9uZUVsZW1lbnQoXCJsaW5rXCIsIGNoaWxkcykpO1xuICAgICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWQubGluayA9IGhyZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJkZXNjcmlwdGlvblwiLCBcInN1YnRpdGxlXCIsIGNoaWxkcyk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSBmZXRjaChcInVwZGF0ZWRcIiwgY2hpbGRzKTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBmZWVkLnVwZGF0ZWQgPSBuZXcgRGF0ZSh1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImF1dGhvclwiLCBcImVtYWlsXCIsIGNoaWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZmVlZC5pdGVtcyA9IGdldEVsZW1lbnRzKFwiZW50cnlcIiwgY2hpbGRzKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGl0ZW0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiaWRcIiwgXCJpZFwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBocmVmID0gZ2V0QXR0cmlidXRlKFwiaHJlZlwiLCBnZXRPbmVFbGVtZW50KFwibGlua1wiLCBjaGlsZHJlbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubGluayA9IGhyZWY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gZmV0Y2goXCJzdW1tYXJ5XCIsIGNoaWxkcmVuKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2goXCJjb250ZW50XCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwdWJEYXRlID0gZmV0Y2goXCJ1cGRhdGVkXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB1YkRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnB1YkRhdGUgPSBuZXcgRGF0ZShwdWJEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5tZWRpYSA9IGdldE1lZGlhRWxlbWVudHMoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRzID0gKF9iID0gKF9hID0gZ2V0T25lRWxlbWVudChcImNoYW5uZWxcIiwgZmVlZFJvb3QuY2hpbGRyZW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGRyZW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICAgICAgICAgIGZlZWQudHlwZSA9IGZlZWRSb290Lm5hbWUuc3Vic3RyKDAsIDMpO1xuICAgICAgICAgICAgICAgIGZlZWQuaWQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJ0aXRsZVwiLCBcInRpdGxlXCIsIGNoaWxkcyk7XG4gICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImxpbmtcIiwgXCJsaW5rXCIsIGNoaWxkcyk7XG4gICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImRlc2NyaXB0aW9uXCIsIFwiZGVzY3JpcHRpb25cIiwgY2hpbGRzKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZCA9IGZldGNoKFwibGFzdEJ1aWxkRGF0ZVwiLCBjaGlsZHMpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWQudXBkYXRlZCA9IG5ldyBEYXRlKHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiYXV0aG9yXCIsIFwibWFuYWdpbmdFZGl0b3JcIiwgY2hpbGRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBmZWVkLml0ZW1zID0gZ2V0RWxlbWVudHMoXCJpdGVtXCIsIGZlZWRSb290LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGl0ZW0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiaWRcIiwgXCJndWlkXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJ0aXRsZVwiLCBcInRpdGxlXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShlbnRyeSwgXCJsaW5rXCIsIFwibGlua1wiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiZGVzY3JpcHRpb25cIiwgXCJkZXNjcmlwdGlvblwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwdWJEYXRlID0gZmV0Y2goXCJwdWJEYXRlXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB1YkRhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5wdWJEYXRlID0gbmV3IERhdGUocHViRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5Lm1lZGlhID0gZ2V0TWVkaWFFbGVtZW50cyhjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZlZWQgPSBmZWVkO1xuICAgICAgICB0aGlzLmhhbmRsZUNhbGxiYWNrKGZlZWRSb290ID8gbnVsbCA6IEVycm9yKFwiY291bGRuJ3QgZmluZCByb290IG9mIGZlZWRcIikpO1xuICAgIH07XG4gICAgcmV0dXJuIEZlZWRIYW5kbGVyO1xufShkb21oYW5kbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5GZWVkSGFuZGxlciA9IEZlZWRIYW5kbGVyO1xuZnVuY3Rpb24gZ2V0TWVkaWFFbGVtZW50cyh3aGVyZSkge1xuICAgIHJldHVybiBnZXRFbGVtZW50cyhcIm1lZGlhOmNvbnRlbnRcIiwgd2hlcmUpLm1hcChmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXIgbWVkaWEgPSB7XG4gICAgICAgICAgICBtZWRpdW06IGVsZW0uYXR0cmlicy5tZWRpdW0sXG4gICAgICAgICAgICBpc0RlZmF1bHQ6ICEhZWxlbS5hdHRyaWJzLmlzRGVmYXVsdCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVsZW0uYXR0cmlicy51cmwpIHtcbiAgICAgICAgICAgIG1lZGlhLnVybCA9IGVsZW0uYXR0cmlicy51cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW0uYXR0cmlicy5maWxlU2l6ZSkge1xuICAgICAgICAgICAgbWVkaWEuZmlsZVNpemUgPSBwYXJzZUludChlbGVtLmF0dHJpYnMuZmlsZVNpemUsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS5hdHRyaWJzLnR5cGUpIHtcbiAgICAgICAgICAgIG1lZGlhLnR5cGUgPSBlbGVtLmF0dHJpYnMudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS5hdHRyaWJzLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIG1lZGlhLmV4cHJlc3Npb24gPSBlbGVtLmF0dHJpYnNcbiAgICAgICAgICAgICAgICAuZXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS5hdHRyaWJzLmJpdHJhdGUpIHtcbiAgICAgICAgICAgIG1lZGlhLmJpdHJhdGUgPSBwYXJzZUludChlbGVtLmF0dHJpYnMuYml0cmF0ZSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLmF0dHJpYnMuZnJhbWVyYXRlKSB7XG4gICAgICAgICAgICBtZWRpYS5mcmFtZXJhdGUgPSBwYXJzZUludChlbGVtLmF0dHJpYnMuZnJhbWVyYXRlLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW0uYXR0cmlicy5zYW1wbGluZ3JhdGUpIHtcbiAgICAgICAgICAgIG1lZGlhLnNhbXBsaW5ncmF0ZSA9IHBhcnNlSW50KGVsZW0uYXR0cmlicy5zYW1wbGluZ3JhdGUsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS5hdHRyaWJzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBtZWRpYS5jaGFubmVscyA9IHBhcnNlSW50KGVsZW0uYXR0cmlicy5jaGFubmVscywgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLmF0dHJpYnMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIG1lZGlhLmR1cmF0aW9uID0gcGFyc2VJbnQoZWxlbS5hdHRyaWJzLmR1cmF0aW9uLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW0uYXR0cmlicy5oZWlnaHQpIHtcbiAgICAgICAgICAgIG1lZGlhLmhlaWdodCA9IHBhcnNlSW50KGVsZW0uYXR0cmlicy5oZWlnaHQsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS5hdHRyaWJzLndpZHRoKSB7XG4gICAgICAgICAgICBtZWRpYS53aWR0aCA9IHBhcnNlSW50KGVsZW0uYXR0cmlicy53aWR0aCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLmF0dHJpYnMubGFuZykge1xuICAgICAgICAgICAgbWVkaWEubGFuZyA9IGVsZW0uYXR0cmlicy5sYW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZWRpYTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRzKHRhZ05hbWUsIHdoZXJlKSB7XG4gICAgcmV0dXJuIERvbVV0aWxzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUsIHdoZXJlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdldE9uZUVsZW1lbnQodGFnTmFtZSwgbm9kZSkge1xuICAgIHJldHVybiBEb21VdGlscy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lLCBub2RlLCB0cnVlLCAxKVswXTtcbn1cbmZ1bmN0aW9uIGZldGNoKHRhZ05hbWUsIHdoZXJlLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gZmFsc2U7IH1cbiAgICByZXR1cm4gRG9tVXRpbHMuZ2V0VGV4dChEb21VdGlscy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lLCB3aGVyZSwgcmVjdXJzZSwgMSkpLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShuYW1lLCBlbGVtKSB7XG4gICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgYXR0cmlicyA9IGVsZW0uYXR0cmlicztcbiAgICByZXR1cm4gYXR0cmlic1tuYW1lXTtcbn1cbmZ1bmN0aW9uIGFkZENvbmRpdGlvbmFsbHkob2JqLCBwcm9wLCB3aGF0LCB3aGVyZSwgcmVjdXJzZSkge1xuICAgIGlmIChyZWN1cnNlID09PSB2b2lkIDApIHsgcmVjdXJzZSA9IGZhbHNlOyB9XG4gICAgdmFyIHRtcCA9IGZldGNoKHdoYXQsIHdoZXJlLCByZWN1cnNlKTtcbiAgICBpZiAodG1wKVxuICAgICAgICBvYmpbcHJvcF0gPSB0bXA7XG59XG5mdW5jdGlvbiBpc1ZhbGlkRmVlZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gXCJyc3NcIiB8fCB2YWx1ZSA9PT0gXCJmZWVkXCIgfHwgdmFsdWUgPT09IFwicmRmOlJERlwiO1xufVxudmFyIGRlZmF1bHRPcHRpb25zID0geyB4bWxNb2RlOiB0cnVlIH07XG4vKipcbiAqIFBhcnNlIGEgZmVlZC5cbiAqXG4gKiBAcGFyYW0gZmVlZCBUaGUgZmVlZCB0aGF0IHNob3VsZCBiZSBwYXJzZWQsIGFzIGEgc3RyaW5nLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWxseSwgb3B0aW9ucyBmb3IgcGFyc2luZy4gV2hlbiB1c2luZyB0aGlzIG9wdGlvbiwgeW91IHByb2JhYmx5IHdhbnQgdG8gc2V0IGB4bWxNb2RlYCB0byBgdHJ1ZWAuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmVlZChmZWVkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7IH1cbiAgICB2YXIgaGFuZGxlciA9IG5ldyBGZWVkSGFuZGxlcihvcHRpb25zKTtcbiAgICBuZXcgUGFyc2VyXzEuUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpLmVuZChmZWVkKTtcbiAgICByZXR1cm4gaGFuZGxlci5mZWVkO1xufVxuZXhwb3J0cy5wYXJzZUZlZWQgPSBwYXJzZUZlZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyc2VyID0gdm9pZCAwO1xudmFyIFRva2VuaXplcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Rva2VuaXplclwiKSk7XG52YXIgZm9ybVRhZ3MgPSBuZXcgU2V0KFtcbiAgICBcImlucHV0XCIsXG4gICAgXCJvcHRpb25cIixcbiAgICBcIm9wdGdyb3VwXCIsXG4gICAgXCJzZWxlY3RcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwiZGF0YWxpc3RcIixcbiAgICBcInRleHRhcmVhXCIsXG5dKTtcbnZhciBwVGFnID0gbmV3IFNldChbXCJwXCJdKTtcbnZhciBvcGVuSW1wbGllc0Nsb3NlID0ge1xuICAgIHRyOiBuZXcgU2V0KFtcInRyXCIsIFwidGhcIiwgXCJ0ZFwiXSksXG4gICAgdGg6IG5ldyBTZXQoW1widGhcIl0pLFxuICAgIHRkOiBuZXcgU2V0KFtcInRoZWFkXCIsIFwidGhcIiwgXCJ0ZFwiXSksXG4gICAgYm9keTogbmV3IFNldChbXCJoZWFkXCIsIFwibGlua1wiLCBcInNjcmlwdFwiXSksXG4gICAgbGk6IG5ldyBTZXQoW1wibGlcIl0pLFxuICAgIHA6IHBUYWcsXG4gICAgaDE6IHBUYWcsXG4gICAgaDI6IHBUYWcsXG4gICAgaDM6IHBUYWcsXG4gICAgaDQ6IHBUYWcsXG4gICAgaDU6IHBUYWcsXG4gICAgaDY6IHBUYWcsXG4gICAgc2VsZWN0OiBmb3JtVGFncyxcbiAgICBpbnB1dDogZm9ybVRhZ3MsXG4gICAgb3V0cHV0OiBmb3JtVGFncyxcbiAgICBidXR0b246IGZvcm1UYWdzLFxuICAgIGRhdGFsaXN0OiBmb3JtVGFncyxcbiAgICB0ZXh0YXJlYTogZm9ybVRhZ3MsXG4gICAgb3B0aW9uOiBuZXcgU2V0KFtcIm9wdGlvblwiXSksXG4gICAgb3B0Z3JvdXA6IG5ldyBTZXQoW1wib3B0Z3JvdXBcIiwgXCJvcHRpb25cIl0pLFxuICAgIGRkOiBuZXcgU2V0KFtcImR0XCIsIFwiZGRcIl0pLFxuICAgIGR0OiBuZXcgU2V0KFtcImR0XCIsIFwiZGRcIl0pLFxuICAgIGFkZHJlc3M6IHBUYWcsXG4gICAgYXJ0aWNsZTogcFRhZyxcbiAgICBhc2lkZTogcFRhZyxcbiAgICBibG9ja3F1b3RlOiBwVGFnLFxuICAgIGRldGFpbHM6IHBUYWcsXG4gICAgZGl2OiBwVGFnLFxuICAgIGRsOiBwVGFnLFxuICAgIGZpZWxkc2V0OiBwVGFnLFxuICAgIGZpZ2NhcHRpb246IHBUYWcsXG4gICAgZmlndXJlOiBwVGFnLFxuICAgIGZvb3RlcjogcFRhZyxcbiAgICBmb3JtOiBwVGFnLFxuICAgIGhlYWRlcjogcFRhZyxcbiAgICBocjogcFRhZyxcbiAgICBtYWluOiBwVGFnLFxuICAgIG5hdjogcFRhZyxcbiAgICBvbDogcFRhZyxcbiAgICBwcmU6IHBUYWcsXG4gICAgc2VjdGlvbjogcFRhZyxcbiAgICB0YWJsZTogcFRhZyxcbiAgICB1bDogcFRhZyxcbiAgICBydDogbmV3IFNldChbXCJydFwiLCBcInJwXCJdKSxcbiAgICBycDogbmV3IFNldChbXCJydFwiLCBcInJwXCJdKSxcbiAgICB0Ym9keTogbmV3IFNldChbXCJ0aGVhZFwiLCBcInRib2R5XCJdKSxcbiAgICB0Zm9vdDogbmV3IFNldChbXCJ0aGVhZFwiLCBcInRib2R5XCJdKSxcbn07XG52YXIgdm9pZEVsZW1lbnRzID0gbmV3IFNldChbXG4gICAgXCJhcmVhXCIsXG4gICAgXCJiYXNlXCIsXG4gICAgXCJiYXNlZm9udFwiLFxuICAgIFwiYnJcIixcbiAgICBcImNvbFwiLFxuICAgIFwiY29tbWFuZFwiLFxuICAgIFwiZW1iZWRcIixcbiAgICBcImZyYW1lXCIsXG4gICAgXCJoclwiLFxuICAgIFwiaW1nXCIsXG4gICAgXCJpbnB1dFwiLFxuICAgIFwiaXNpbmRleFwiLFxuICAgIFwia2V5Z2VuXCIsXG4gICAgXCJsaW5rXCIsXG4gICAgXCJtZXRhXCIsXG4gICAgXCJwYXJhbVwiLFxuICAgIFwic291cmNlXCIsXG4gICAgXCJ0cmFja1wiLFxuICAgIFwid2JyXCIsXG5dKTtcbnZhciBmb3JlaWduQ29udGV4dEVsZW1lbnRzID0gbmV3IFNldChbXCJtYXRoXCIsIFwic3ZnXCJdKTtcbnZhciBodG1sSW50ZWdyYXRpb25FbGVtZW50cyA9IG5ldyBTZXQoW1xuICAgIFwibWlcIixcbiAgICBcIm1vXCIsXG4gICAgXCJtblwiLFxuICAgIFwibXNcIixcbiAgICBcIm10ZXh0XCIsXG4gICAgXCJhbm5vdGF0aW9uLXhtbFwiLFxuICAgIFwiZm9yZWlnbk9iamVjdFwiLFxuICAgIFwiZGVzY1wiLFxuICAgIFwidGl0bGVcIixcbl0pO1xudmFyIHJlTmFtZUVuZCA9IC9cXHN8XFwvLztcbnZhciBQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKGNicywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAvKiogVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBsYXN0IGV2ZW50LiAqL1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAvKiogVGhlIGVuZCBpbmRleCBvZiB0aGUgbGFzdCBldmVudC4gKi9cbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFnbmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlibmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlidmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jYnMgPSBjYnMgIT09IG51bGwgJiYgY2JzICE9PSB2b2lkIDAgPyBjYnMgOiB7fTtcbiAgICAgICAgdGhpcy5sb3dlckNhc2VUYWdOYW1lcyA9IChfYSA9IG9wdGlvbnMubG93ZXJDYXNlVGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogIW9wdGlvbnMueG1sTW9kZTtcbiAgICAgICAgdGhpcy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcyA9IChfYiA9IG9wdGlvbnMubG93ZXJDYXNlQXR0cmlidXRlTmFtZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICFvcHRpb25zLnhtbE1vZGU7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gbmV3ICgoX2MgPSBvcHRpb25zLlRva2VuaXplcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogVG9rZW5pemVyXzEuZGVmYXVsdCkodGhpcy5vcHRpb25zLCB0aGlzKTtcbiAgICAgICAgKF9lID0gKF9kID0gdGhpcy5jYnMpLm9ucGFyc2VyaW5pdCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIHRoaXMpO1xuICAgIH1cbiAgICBQYXJzZXIucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKGluaXRpYWxPZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kSW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuaXplci5zZWN0aW9uU3RhcnQgPD0gaW5pdGlhbE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSB0aGlzLnRva2VuaXplci5zZWN0aW9uU3RhcnQgLSBpbml0aWFsT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gdGhpcy5lbmRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IHRoaXMudG9rZW5pemVyLmdldEFic29sdXRlSW5kZXgoKTtcbiAgICB9O1xuICAgIC8vIFRva2VuaXplciBldmVudCBoYW5kbGVyc1xuICAgIFBhcnNlci5wcm90b3R5cGUub250ZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigxKTtcbiAgICAgICAgdGhpcy5lbmRJbmRleC0tO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZGF0YSk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9ub3BlbnRhZ25hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhZ25hbWUgPSBuYW1lO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy54bWxNb2RlICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3BlbkltcGxpZXNDbG9zZSwgbmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBvcGVuSW1wbGllc0Nsb3NlW25hbWVdLmhhcygoZWwgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0pKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZXRhZyhlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy54bWxNb2RlIHx8ICF2b2lkRWxlbWVudHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2gobmFtZSk7XG4gICAgICAgICAgICBpZiAoZm9yZWlnbkNvbnRleHRFbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmVpZ25Db250ZXh0LnB1c2godHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChodG1sSW50ZWdyYXRpb25FbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmVpZ25Db250ZXh0LnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbm9wZW50YWduYW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbmFtZSk7XG4gICAgICAgIGlmICh0aGlzLmNicy5vbm9wZW50YWcpXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnMgPSB7fTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25vcGVudGFnZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKDEpO1xuICAgICAgICBpZiAodGhpcy5hdHRyaWJzKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25vcGVudGFnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcy50YWduYW1lLCB0aGlzLmF0dHJpYnMpO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy54bWxNb2RlICYmXG4gICAgICAgICAgICB0aGlzLmNicy5vbmNsb3NldGFnICYmXG4gICAgICAgICAgICB2b2lkRWxlbWVudHMuaGFzKHRoaXMudGFnbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY2xvc2V0YWcodGhpcy50YWduYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhZ25hbWUgPSBcIlwiO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmNsb3NldGFnID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigxKTtcbiAgICAgICAgaWYgKHRoaXMubG93ZXJDYXNlVGFnTmFtZXMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcmVpZ25Db250ZXh0RWxlbWVudHMuaGFzKG5hbWUpIHx8XG4gICAgICAgICAgICBodG1sSW50ZWdyYXRpb25FbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHQucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgICAodGhpcy5vcHRpb25zLnhtbE1vZGUgfHwgIXZvaWRFbGVtZW50cy5oYXMobmFtZSkpKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5zdGFjay5sYXN0SW5kZXhPZihuYW1lKTtcbiAgICAgICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2JzLm9uY2xvc2V0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5zdGFjay5sZW5ndGggLSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwb3MtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGUgc3RhY2sgaGFzIHN1ZmZpY2llbnQgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNicy5vbmNsb3NldGFnKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSBcInBcIiAmJiAhdGhpcy5vcHRpb25zLnhtbE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ub3BlbnRhZ25hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUN1cnJlbnRUYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5vcHRpb25zLnhtbE1vZGUgJiYgKG5hbWUgPT09IFwiYnJcIiB8fCBuYW1lID09PSBcInBcIikpIHtcbiAgICAgICAgICAgIHRoaXMub25vcGVudGFnbmFtZShuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDdXJyZW50VGFnKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25zZWxmY2xvc2luZ3RhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy54bWxNb2RlIHx8XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVjb2duaXplU2VsZkNsb3NpbmcgfHxcbiAgICAgICAgICAgIHRoaXMuZm9yZWlnbkNvbnRleHRbdGhpcy5mb3JlaWduQ29udGV4dC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUN1cnJlbnRUYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25vcGVudGFnZW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuY2xvc2VDdXJyZW50VGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGFnbmFtZTtcbiAgICAgICAgdGhpcy5vbm9wZW50YWdlbmQoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogU2VsZi1jbG9zaW5nIHRhZ3Mgd2lsbCBiZSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICAgKiAoY2hlYXBlciBjaGVjayB0aGFuIGluIG9uY2xvc2V0YWcpXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID09PSBuYW1lKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jbG9zZXRhZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYm5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHJpYm5hbWUgPSBuYW1lO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYmRhdGEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ2YWx1ZSArPSB2YWx1ZTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25hdHRyaWJlbmQgPSBmdW5jdGlvbiAocXVvdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uYXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcy5hdHRyaWJuYW1lLCB0aGlzLmF0dHJpYnZhbHVlLCBxdW90ZSk7XG4gICAgICAgIGlmICh0aGlzLmF0dHJpYnMgJiZcbiAgICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJzLCB0aGlzLmF0dHJpYm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnNbdGhpcy5hdHRyaWJuYW1lXSA9IHRoaXMuYXR0cmlidmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRyaWJuYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5hdHRyaWJ2YWx1ZSA9IFwiXCI7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmdldEluc3RydWN0aW9uTmFtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaWR4ID0gdmFsdWUuc2VhcmNoKHJlTmFtZUVuZCk7XG4gICAgICAgIHZhciBuYW1lID0gaWR4IDwgMCA/IHZhbHVlIDogdmFsdWUuc3Vic3RyKDAsIGlkeCk7XG4gICAgICAgIGlmICh0aGlzLmxvd2VyQ2FzZVRhZ05hbWVzKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKFwiIVwiICsgbmFtZV8xLCBcIiFcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzIgPSB0aGlzLmdldEluc3RydWN0aW9uTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmNicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihcIj9cIiArIG5hbWVfMiwgXCI/XCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25jb21tZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbig0KTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9uY29tbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHZhbHVlKTtcbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYnMpLm9uY29tbWVudGVuZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmNkYXRhID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKDEpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnhtbE1vZGUgfHwgdGhpcy5vcHRpb25zLnJlY29nbml6ZUNEQVRBKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNicykub25jZGF0YXN0YXJ0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub250ZXh0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdmFsdWUpO1xuICAgICAgICAgICAgKF9mID0gKF9lID0gdGhpcy5jYnMpLm9uY2RhdGFlbmQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25jb21tZW50KFwiW0NEQVRBW1wiICsgdmFsdWUgKyBcIl1dXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXJyKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmNicy5vbmNsb3NldGFnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zdGFjay5sZW5ndGg7IGkgPiAwOyB0aGlzLmNicy5vbmNsb3NldGFnKHRoaXMuc3RhY2tbLS1pXSkpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2JzKS5vbmVuZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBwYXJzZXIgdG8gYSBibGFuayBzdGF0ZSwgcmVhZHkgdG8gcGFyc2UgYSBuZXcgSFRNTCBkb2N1bWVudFxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYnMpLm9ucmVzZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy50YWduYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5hdHRyaWJuYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5hdHRyaWJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNicykub25wYXJzZXJpbml0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBjb21wbGV0ZSBkb2N1bWVudCBhbmQgcHVzaGVzIGl0IHRvIHRoZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgRG9jdW1lbnQgdG8gcGFyc2UuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbXBsZXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmVuZChkYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNodW5rIG9mIGRhdGEgYW5kIGNhbGxzIHRoZSBjb3JyZXNwb25kaW5nIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaHVuayBDaHVuayB0byBwYXJzZS5cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLndyaXRlKGNodW5rKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZW5kIG9mIHRoZSBidWZmZXIgYW5kIGNsZWFycyB0aGUgc3RhY2ssIGNhbGxzIG9uZW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIE9wdGlvbmFsIGZpbmFsIGNodW5rIHRvIHBhcnNlLlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLmVuZChjaHVuayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXVzZXMgcGFyc2luZy4gVGhlIHBhcnNlciB3b24ndCBlbWl0IGV2ZW50cyB1bnRpbCBgcmVzdW1lYCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIucGF1c2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgcGFyc2luZyBhZnRlciBgcGF1c2VgIHdhcyBjYWxsZWQuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnJlc3VtZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgYHdyaXRlYCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIENodW5rIHRvIHBhcnNlLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMud3JpdGUoY2h1bmspO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgYGVuZGAsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaHVuayBPcHRpb25hbCBmaW5hbCBjaHVuayB0byBwYXJzZS5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmVuZChjaHVuayk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VyO1xufSgpKTtcbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVjb2RlX2NvZGVwb2ludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvZGVjb2RlX2NvZGVwb2ludFwiKSk7XG52YXIgZW50aXRpZXNfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uXCIpKTtcbnZhciBsZWdhY3lfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvbWFwcy9sZWdhY3kuanNvblwiKSk7XG52YXIgeG1sX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZW50aXRpZXMvbGliL21hcHMveG1sLmpzb25cIikpO1xuZnVuY3Rpb24gd2hpdGVzcGFjZShjKSB7XG4gICAgcmV0dXJuIGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHRcIiB8fCBjID09PSBcIlxcZlwiIHx8IGMgPT09IFwiXFxyXCI7XG59XG5mdW5jdGlvbiBpc0FTQ0lJQWxwaGEoYykge1xuICAgIHJldHVybiAoYyA+PSBcImFcIiAmJiBjIDw9IFwielwiKSB8fCAoYyA+PSBcIkFcIiAmJiBjIDw9IFwiWlwiKTtcbn1cbmZ1bmN0aW9uIGlmRWxzZVN0YXRlKHVwcGVyLCBTVUNDRVNTLCBGQUlMVVJFKSB7XG4gICAgdmFyIGxvd2VyID0gdXBwZXIudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodXBwZXIgPT09IGxvd2VyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgYykge1xuICAgICAgICAgICAgaWYgKGMgPT09IGxvd2VyKSB7XG4gICAgICAgICAgICAgICAgdC5fc3RhdGUgPSBTVUNDRVNTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdC5fc3RhdGUgPSBGQUlMVVJFO1xuICAgICAgICAgICAgICAgIHQuX2luZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAodCwgYykge1xuICAgICAgICBpZiAoYyA9PT0gbG93ZXIgfHwgYyA9PT0gdXBwZXIpIHtcbiAgICAgICAgICAgIHQuX3N0YXRlID0gU1VDQ0VTUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHQuX3N0YXRlID0gRkFJTFVSRTtcbiAgICAgICAgICAgIHQuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcih1cHBlciwgTkVYVF9TVEFURSkge1xuICAgIHZhciBsb3dlciA9IHVwcGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBjKSB7XG4gICAgICAgIGlmIChjID09PSBsb3dlciB8fCBjID09PSB1cHBlcikge1xuICAgICAgICAgICAgdC5fc3RhdGUgPSBORVhUX1NUQVRFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdC5fc3RhdGUgPSAzIC8qIEluVGFnTmFtZSAqLztcbiAgICAgICAgICAgIHQuX2luZGV4LS07IC8vIENvbnN1bWUgdGhlIHRva2VuIGFnYWluXG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIHN0YXRlQmVmb3JlQ2RhdGExID0gaWZFbHNlU3RhdGUoXCJDXCIsIDI0IC8qIEJlZm9yZUNkYXRhMiAqLywgMTYgLyogSW5EZWNsYXJhdGlvbiAqLyk7XG52YXIgc3RhdGVCZWZvcmVDZGF0YTIgPSBpZkVsc2VTdGF0ZShcIkRcIiwgMjUgLyogQmVmb3JlQ2RhdGEzICovLCAxNiAvKiBJbkRlY2xhcmF0aW9uICovKTtcbnZhciBzdGF0ZUJlZm9yZUNkYXRhMyA9IGlmRWxzZVN0YXRlKFwiQVwiLCAyNiAvKiBCZWZvcmVDZGF0YTQgKi8sIDE2IC8qIEluRGVjbGFyYXRpb24gKi8pO1xudmFyIHN0YXRlQmVmb3JlQ2RhdGE0ID0gaWZFbHNlU3RhdGUoXCJUXCIsIDI3IC8qIEJlZm9yZUNkYXRhNSAqLywgMTYgLyogSW5EZWNsYXJhdGlvbiAqLyk7XG52YXIgc3RhdGVCZWZvcmVDZGF0YTUgPSBpZkVsc2VTdGF0ZShcIkFcIiwgMjggLyogQmVmb3JlQ2RhdGE2ICovLCAxNiAvKiBJbkRlY2xhcmF0aW9uICovKTtcbnZhciBzdGF0ZUJlZm9yZVNjcmlwdDEgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiUlwiLCAzNSAvKiBCZWZvcmVTY3JpcHQyICovKTtcbnZhciBzdGF0ZUJlZm9yZVNjcmlwdDIgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiSVwiLCAzNiAvKiBCZWZvcmVTY3JpcHQzICovKTtcbnZhciBzdGF0ZUJlZm9yZVNjcmlwdDMgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiUFwiLCAzNyAvKiBCZWZvcmVTY3JpcHQ0ICovKTtcbnZhciBzdGF0ZUJlZm9yZVNjcmlwdDQgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiVFwiLCAzOCAvKiBCZWZvcmVTY3JpcHQ1ICovKTtcbnZhciBzdGF0ZUFmdGVyU2NyaXB0MSA9IGlmRWxzZVN0YXRlKFwiUlwiLCA0MCAvKiBBZnRlclNjcmlwdDIgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVBZnRlclNjcmlwdDIgPSBpZkVsc2VTdGF0ZShcIklcIiwgNDEgLyogQWZ0ZXJTY3JpcHQzICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQWZ0ZXJTY3JpcHQzID0gaWZFbHNlU3RhdGUoXCJQXCIsIDQyIC8qIEFmdGVyU2NyaXB0NCAqLywgMSAvKiBUZXh0ICovKTtcbnZhciBzdGF0ZUFmdGVyU2NyaXB0NCA9IGlmRWxzZVN0YXRlKFwiVFwiLCA0MyAvKiBBZnRlclNjcmlwdDUgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVCZWZvcmVTdHlsZTEgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiWVwiLCA0NSAvKiBCZWZvcmVTdHlsZTIgKi8pO1xudmFyIHN0YXRlQmVmb3JlU3R5bGUyID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIkxcIiwgNDYgLyogQmVmb3JlU3R5bGUzICovKTtcbnZhciBzdGF0ZUJlZm9yZVN0eWxlMyA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJFXCIsIDQ3IC8qIEJlZm9yZVN0eWxlNCAqLyk7XG52YXIgc3RhdGVBZnRlclN0eWxlMSA9IGlmRWxzZVN0YXRlKFwiWVwiLCA0OSAvKiBBZnRlclN0eWxlMiAqLywgMSAvKiBUZXh0ICovKTtcbnZhciBzdGF0ZUFmdGVyU3R5bGUyID0gaWZFbHNlU3RhdGUoXCJMXCIsIDUwIC8qIEFmdGVyU3R5bGUzICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQWZ0ZXJTdHlsZTMgPSBpZkVsc2VTdGF0ZShcIkVcIiwgNTEgLyogQWZ0ZXJTdHlsZTQgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVCZWZvcmVTcGVjaWFsVCA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJJXCIsIDU0IC8qIEJlZm9yZVRpdGxlMSAqLyk7XG52YXIgc3RhdGVCZWZvcmVUaXRsZTEgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiVFwiLCA1NSAvKiBCZWZvcmVUaXRsZTIgKi8pO1xudmFyIHN0YXRlQmVmb3JlVGl0bGUyID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIkxcIiwgNTYgLyogQmVmb3JlVGl0bGUzICovKTtcbnZhciBzdGF0ZUJlZm9yZVRpdGxlMyA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJFXCIsIDU3IC8qIEJlZm9yZVRpdGxlNCAqLyk7XG52YXIgc3RhdGVBZnRlclNwZWNpYWxURW5kID0gaWZFbHNlU3RhdGUoXCJJXCIsIDU4IC8qIEFmdGVyVGl0bGUxICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQWZ0ZXJUaXRsZTEgPSBpZkVsc2VTdGF0ZShcIlRcIiwgNTkgLyogQWZ0ZXJUaXRsZTIgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVBZnRlclRpdGxlMiA9IGlmRWxzZVN0YXRlKFwiTFwiLCA2MCAvKiBBZnRlclRpdGxlMyAqLywgMSAvKiBUZXh0ICovKTtcbnZhciBzdGF0ZUFmdGVyVGl0bGUzID0gaWZFbHNlU3RhdGUoXCJFXCIsIDYxIC8qIEFmdGVyVGl0bGU0ICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQmVmb3JlRW50aXR5ID0gaWZFbHNlU3RhdGUoXCIjXCIsIDYzIC8qIEJlZm9yZU51bWVyaWNFbnRpdHkgKi8sIDY0IC8qIEluTmFtZWRFbnRpdHkgKi8pO1xudmFyIHN0YXRlQmVmb3JlTnVtZXJpY0VudGl0eSA9IGlmRWxzZVN0YXRlKFwiWFwiLCA2NiAvKiBJbkhleEVudGl0eSAqLywgNjUgLyogSW5OdW1lcmljRW50aXR5ICovKTtcbnZhciBUb2tlbml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9rZW5pemVyKG9wdGlvbnMsIGNicykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBzdGF0ZSB0aGUgdG9rZW5pemVyIGlzIGluLiAqL1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgLyoqIFRoZSByZWFkIGJ1ZmZlci4gKi9cbiAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgICAvKiogVGhlIGJlZ2lubmluZyBvZiB0aGUgc2VjdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyByZWFkLiAqL1xuICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IDA7XG4gICAgICAgIC8qKiBUaGUgaW5kZXggd2l0aGluIHRoZSBidWZmZXIgdGhhdCB3ZSBhcmUgY3VycmVudGx5IGxvb2tpbmcgYXQuICovXG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYnVmZmVyIG9jY2FzaW9uYWxseS5cbiAgICAgICAgICogYF9idWZmZXJPZmZzZXRgIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHJlbW92ZWQsIHRvIG1ha2Ugc3VyZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBhY2N1cmF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqIFNvbWUgYmVoYXZpb3IsIGVnLiB3aGVuIGRlY29kaW5nIGVudGl0aWVzLCBpcyBkb25lIHdoaWxlIHdlIGFyZSBpbiBhbm90aGVyIHN0YXRlLiBUaGlzIGtlZXBzIHRyYWNrIG9mIHRoZSBvdGhlciBzdGF0ZSB0eXBlLiAqL1xuICAgICAgICB0aGlzLmJhc2VTdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgLyoqIEZvciBzcGVjaWFsIHBhcnNpbmcgYmVoYXZpb3IgaW5zaWRlIG9mIHNjcmlwdCBhbmQgc3R5bGUgdGFncy4gKi9cbiAgICAgICAgdGhpcy5zcGVjaWFsID0gMSAvKiBOb25lICovO1xuICAgICAgICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRva2VuaXplciBoYXMgYmVlbiBwYXVzZWQuICovXG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIC8qKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdG9rZW5pemVyIGhhcyBmaW5pc2hlZCBydW5uaW5nIC8gYC5lbmRgIGhhcyBiZWVuIGNhbGxlZC4gKi9cbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNicyA9IGNicztcbiAgICAgICAgdGhpcy54bWxNb2RlID0gISEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnhtbE1vZGUpO1xuICAgICAgICB0aGlzLmRlY29kZUVudGl0aWVzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlY29kZUVudGl0aWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgIH1cbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IDA7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmJhc2VTdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgdGhpcy5zcGVjaWFsID0gMSAvKiBOb25lICovO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgICAgdGhpcy5jYnMub25lcnJvcihFcnJvcihcIi53cml0ZSgpIGFmdGVyIGRvbmUhXCIpKTtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gY2h1bms7XG4gICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgICAgdGhpcy5jYnMub25lcnJvcihFcnJvcihcIi5lbmQoKSBhZnRlciBkb25lIVwiKSk7XG4gICAgICAgIGlmIChjaHVuaylcbiAgICAgICAgICAgIHRoaXMud3JpdGUoY2h1bmspO1xuICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgaW5kZXggd2l0aGluIGFsbCBvZiB0aGUgd3JpdHRlbiBkYXRhLlxuICAgICAqL1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZ2V0QWJzb2x1dGVJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyT2Zmc2V0ICsgdGhpcy5faW5kZXg7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlVGV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIjxcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID4gdGhpcy5zZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5nZXRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAyIC8qIEJlZm9yZVRhZ05hbWUgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVjb2RlRW50aXRpZXMgJiZcbiAgICAgICAgICAgIGMgPT09IFwiJlwiICYmXG4gICAgICAgICAgICAodGhpcy5zcGVjaWFsID09PSAxIC8qIE5vbmUgKi8gfHwgdGhpcy5zcGVjaWFsID09PSA0IC8qIFRpdGxlICovKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID4gdGhpcy5zZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5nZXRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYXNlU3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDYyIC8qIEJlZm9yZUVudGl0eSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVUYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDUgLyogQmVmb3JlQ2xvc2luZ1RhZ05hbWUgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLmdldFNlY3Rpb24oKSk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPlwiIHx8XG4gICAgICAgICAgICB0aGlzLnNwZWNpYWwgIT09IDEgLyogTm9uZSAqLyB8fFxuICAgICAgICAgICAgd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIhXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTUgLyogQmVmb3JlRGVjbGFyYXRpb24gKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBcIj9cIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxNyAvKiBJblByb2Nlc3NpbmdJbnN0cnVjdGlvbiAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0FTQ0lJQWxwaGEoYykpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPVxuICAgICAgICAgICAgICAgICF0aGlzLnhtbE1vZGUgJiYgKGMgPT09IFwic1wiIHx8IGMgPT09IFwiU1wiKVxuICAgICAgICAgICAgICAgICAgICA/IDMyIC8qIEJlZm9yZVNwZWNpYWxTICovXG4gICAgICAgICAgICAgICAgICAgIDogIXRoaXMueG1sTW9kZSAmJiAoYyA9PT0gXCJ0XCIgfHwgYyA9PT0gXCJUXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDUyIC8qIEJlZm9yZVNwZWNpYWxUICovXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDMgLyogSW5UYWdOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluVGFnTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIi9cIiB8fCBjID09PSBcIj5cIiB8fCB3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRUb2tlbihcIm9ub3BlbnRhZ25hbWVcIik7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDggLyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVDbG9zaW5nVGFnTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zcGVjaWFsICE9PSAxIC8qIE5vbmUgKi8pIHtcbiAgICAgICAgICAgIGlmIChjID09PSBcInNcIiB8fCBjID09PSBcIlNcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMzMgLyogQmVmb3JlU3BlY2lhbFNFbmQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSBcInRcIiB8fCBjID09PSBcIlRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNTMgLyogQmVmb3JlU3BlY2lhbFRFbmQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0FTQ0lJQWxwaGEoYykpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMjAgLyogSW5TcGVjaWFsQ29tbWVudCAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDYgLyogSW5DbG9zaW5nVGFnTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkNsb3NpbmdUYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFRva2VuKFwib25jbG9zZXRhZ1wiKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNyAvKiBBZnRlckNsb3NpbmdUYWdOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBTa2lwIGV2ZXJ5dGhpbmcgdW50aWwgXCI+XCJcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgdGhpcy5jYnMub25vcGVudGFnZW5kKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDQgLyogSW5TZWxmQ2xvc2luZ1RhZyAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA5IC8qIEluQXR0cmlidXRlTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJblNlbGZDbG9zaW5nVGFnID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbnNlbGZjbG9zaW5ndGFnKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICAgICAgdGhpcy5zcGVjaWFsID0gMSAvKiBOb25lICovOyAvLyBSZXNldCBzcGVjaWFsIHN0YXRlLCBpbiBjYXNlIG9mIHNlbGYtY2xvc2luZyBzcGVjaWFsIHRhZ3NcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA4IC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5BdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPVwiIHx8IGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmlibmFtZSh0aGlzLmdldFNlY3Rpb24oKSk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxMCAvKiBBZnRlckF0dHJpYnV0ZU5hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDExIC8qIEJlZm9yZUF0dHJpYnV0ZVZhbHVlICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA4IC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA5IC8qIEluQXR0cmlidXRlTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEyIC8qIEluQXR0cmlidXRlVmFsdWVEcSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEzIC8qIEluQXR0cmlidXRlVmFsdWVTcSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDE0IC8qIEluQXR0cmlidXRlVmFsdWVOcSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tOyAvLyBSZWNvbnN1bWUgdG9rZW5cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5oYW5kbGVJbkF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKGMsIHF1b3RlKSB7XG4gICAgICAgIGlmIChjID09PSBxdW90ZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZChxdW90ZSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDggLyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlY29kZUVudGl0aWVzICYmIGMgPT09IFwiJlwiKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZVN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDYyIC8qIEJlZm9yZUVudGl0eSAqLztcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVJbkF0dHJpYnV0ZVZhbHVlKGMsICdcIicpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluQXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZXMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLmhhbmRsZUluQXR0cmlidXRlVmFsdWUoYywgXCInXCIpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3RlcyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlKGMpIHx8IGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA4IC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO1xuICAgICAgICAgICAgdGhpcy5iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNjIgLyogQmVmb3JlRW50aXR5ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPVxuICAgICAgICAgICAgYyA9PT0gXCJbXCJcbiAgICAgICAgICAgICAgICA/IDIzIC8qIEJlZm9yZUNkYXRhMSAqL1xuICAgICAgICAgICAgICAgIDogYyA9PT0gXCItXCJcbiAgICAgICAgICAgICAgICAgICAgPyAxOCAvKiBCZWZvcmVDb21tZW50ICovXG4gICAgICAgICAgICAgICAgICAgIDogMTYgLyogSW5EZWNsYXJhdGlvbiAqLztcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLmNicy5vbmRlY2xhcmF0aW9uKHRoaXMuZ2V0U2VjdGlvbigpKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJblByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgdGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24odGhpcy5nZXRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUJlZm9yZUNvbW1lbnQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTkgLyogSW5Db21tZW50ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDE2IC8qIEluRGVjbGFyYXRpb24gKi87XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkNvbW1lbnQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCItXCIpXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDIxIC8qIEFmdGVyQ29tbWVudDEgKi87XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlSW5TcGVjaWFsQ29tbWVudCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgdGhpcy5jYnMub25jb21tZW50KHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5faW5kZXgpKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVBZnRlckNvbW1lbnQxID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDIyIC8qIEFmdGVyQ29tbWVudDIgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDE5IC8qIEluQ29tbWVudCAqLztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUFmdGVyQ29tbWVudDIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSAyIHRyYWlsaW5nIGNoYXJzXG4gICAgICAgICAgICB0aGlzLmNicy5vbmNvbW1lbnQodGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLl9pbmRleCAtIDIpKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTkgLyogSW5Db21tZW50ICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2U6IHN0YXkgaW4gQUZURVJfQ09NTUVOVF8yIChgLS0tPmApXG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlQ2RhdGE2ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDI5IC8qIEluQ2RhdGEgKi87XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTYgLyogSW5EZWNsYXJhdGlvbiAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkNkYXRhID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiXVwiKVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAzMCAvKiBBZnRlckNkYXRhMSAqLztcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVBZnRlckNkYXRhMSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIl1cIilcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMzEgLyogQWZ0ZXJDZGF0YTIgKi87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMjkgLyogSW5DZGF0YSAqLztcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVBZnRlckNkYXRhMiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIDIgdHJhaWxpbmcgY2hhcnNcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY2RhdGEodGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLl9pbmRleCAtIDIpKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gXCJdXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMjkgLyogSW5DZGF0YSAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlOiBzdGF5IGluIEFGVEVSX0NEQVRBXzIgKGBdXV0+YClcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVTcGVjaWFsUyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcImNcIiB8fCBjID09PSBcIkNcIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAzNCAvKiBCZWZvcmVTY3JpcHQxICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFwidFwiIHx8IGMgPT09IFwiVFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDQ0IC8qIEJlZm9yZVN0eWxlMSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMyAvKiBJblRhZ05hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tOyAvLyBDb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQmVmb3JlU3BlY2lhbFNFbmQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5zcGVjaWFsID09PSAyIC8qIFNjcmlwdCAqLyAmJiAoYyA9PT0gXCJjXCIgfHwgYyA9PT0gXCJDXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDM5IC8qIEFmdGVyU2NyaXB0MSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNwZWNpYWwgPT09IDMgLyogU3R5bGUgKi8gJiYgKGMgPT09IFwidFwiIHx8IGMgPT09IFwiVFwiKSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA0OCAvKiBBZnRlclN0eWxlMSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVCZWZvcmVTcGVjaWFsTGFzdCA9IGZ1bmN0aW9uIChjLCBzcGVjaWFsKSB7XG4gICAgICAgIGlmIChjID09PSBcIi9cIiB8fCBjID09PSBcIj5cIiB8fCB3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWNpYWwgPSBzcGVjaWFsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlID0gMyAvKiBJblRhZ05hbWUgKi87XG4gICAgICAgIHRoaXMuX2luZGV4LS07IC8vIENvbnN1bWUgdGhlIHRva2VuIGFnYWluXG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnN0YXRlQWZ0ZXJTcGVjaWFsTGFzdCA9IGZ1bmN0aW9uIChjLCBzZWN0aW9uU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY2lhbCA9IDEgLyogTm9uZSAqLztcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNiAvKiBJbkNsb3NpbmdUYWdOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCAtIHNlY3Rpb25TdGFydE9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07IC8vIFJlY29uc3VtZSB0aGUgdG9rZW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICB9O1xuICAgIC8vIEZvciBlbnRpdGllcyB0ZXJtaW5hdGVkIHdpdGggYSBzZW1pY29sb25cbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnBhcnNlRml4ZWRFbnRpdHkgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGlmIChtYXAgPT09IHZvaWQgMCkgeyBtYXAgPSB0aGlzLnhtbE1vZGUgPyB4bWxfanNvbl8xLmRlZmF1bHQgOiBlbnRpdGllc19qc29uXzEuZGVmYXVsdDsgfVxuICAgICAgICAvLyBPZmZzZXQgPSAxXG4gICAgICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCArIDEgPCB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnNlY3Rpb25TdGFydCArIDEsIHRoaXMuX2luZGV4KTtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBlbnRpdHkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UGFydGlhbChtYXBbZW50aXR5XSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFBhcnNlcyBsZWdhY3kgZW50aXRpZXMgKHdpdGhvdXQgdHJhaWxpbmcgc2VtaWNvbG9uKVxuICAgIFRva2VuaXplci5wcm90b3R5cGUucGFyc2VMZWdhY3lFbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2VjdGlvblN0YXJ0ICsgMTtcbiAgICAgICAgLy8gVGhlIG1heCBsZW5ndGggb2YgbGVnYWN5IGVudGl0aWVzIGlzIDZcbiAgICAgICAgdmFyIGxpbWl0ID0gTWF0aC5taW4odGhpcy5faW5kZXggLSBzdGFydCwgNik7XG4gICAgICAgIHdoaWxlIChsaW1pdCA+PSAyKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWluIGxlbmd0aCBvZiBsZWdhY3kgZW50aXRpZXMgaXMgMlxuICAgICAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuYnVmZmVyLnN1YnN0cihzdGFydCwgbGltaXQpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsZWdhY3lfanNvbl8xLmRlZmF1bHQsIGVudGl0eSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRQYXJ0aWFsKGxlZ2FjeV9qc29uXzEuZGVmYXVsdFtlbnRpdHldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCArPSBsaW1pdCArIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluTmFtZWRFbnRpdHkgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VGaXhlZEVudGl0eSgpO1xuICAgICAgICAgICAgLy8gUmV0cnkgYXMgbGVnYWN5IGVudGl0eSBpZiBlbnRpdHkgd2Fzbid0IHBhcnNlZFxuICAgICAgICAgICAgaWYgKHRoaXMuYmFzZVN0YXRlID09PSAxIC8qIFRleHQgKi8gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCArIDEgPCB0aGlzLl9pbmRleCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnhtbE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTGVnYWN5RW50aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjIDwgXCIwXCIgfHwgYyA+IFwiOVwiKSAmJiAhaXNBU0NJSUFscGhhKGMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy54bWxNb2RlIHx8IHRoaXMuc2VjdGlvblN0YXJ0ICsgMSA9PT0gdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYmFzZVN0YXRlICE9PSAxIC8qIFRleHQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoYyAhPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYXMgbGVnYWN5IGVudGl0eSwgd2l0aG91dCBhbGxvd2luZyBhZGRpdGlvbmFsIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VGaXhlZEVudGl0eShsZWdhY3lfanNvbl8xLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VMZWdhY3lFbnRpdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5iYXNlU3RhdGU7XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmRlY29kZU51bWVyaWNFbnRpdHkgPSBmdW5jdGlvbiAob2Zmc2V0LCBiYXNlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIHNlY3Rpb25TdGFydCA9IHRoaXMuc2VjdGlvblN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICBpZiAoc2VjdGlvblN0YXJ0ICE9PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgZW50aXR5XG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHNlY3Rpb25TdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KGVudGl0eSwgYmFzZSk7XG4gICAgICAgICAgICB0aGlzLmVtaXRQYXJ0aWFsKGRlY29kZV9jb2RlcG9pbnRfMS5kZWZhdWx0KHBhcnNlZCkpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSBzdHJpY3QgPyB0aGlzLl9pbmRleCArIDEgOiB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5zdGF0ZUluTnVtZXJpY0VudGl0eSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIjtcIikge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVOdW1lcmljRW50aXR5KDIsIDEwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgXCIwXCIgfHwgYyA+IFwiOVwiKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMueG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlTnVtZXJpY0VudGl0eSgyLCAxMCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLmJhc2VTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuc3RhdGVJbkhleEVudGl0eSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIjtcIikge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVOdW1lcmljRW50aXR5KDMsIDE2LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyA8IFwiYVwiIHx8IGMgPiBcImZcIikgJiZcbiAgICAgICAgICAgIChjIDwgXCJBXCIgfHwgYyA+IFwiRlwiKSAmJlxuICAgICAgICAgICAgKGMgPCBcIjBcIiB8fCBjID4gXCI5XCIpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMueG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlTnVtZXJpY0VudGl0eSgzLCAxNiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLmJhc2VTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDEgLyogVGV4dCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCAhPT0gdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnNlY3Rpb25TdGFydCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPT09IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlY3Rpb24ganVzdCBzdGFydGVkXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ICs9IHRoaXMuX2luZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJzdHIodGhpcy5zZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4IC09IHRoaXMuc2VjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyT2Zmc2V0ICs9IHRoaXMuc2VjdGlvblN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBidWZmZXIsIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBTdGF0ZXMgdGhhdCBhcmUgbW9yZSBsaWtlbHkgdG8gYmUgaGl0IGFyZSBoaWdoZXIgdXAsIGFzIGEgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuXG4gICAgICovXG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2luZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoICYmIHRoaXMucnVubmluZykge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmJ1ZmZlci5jaGFyQXQodGhpcy5faW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAxIC8qIFRleHQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVGV4dChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxMiAvKiBJbkF0dHJpYnV0ZVZhbHVlRHEgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlcyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA5IC8qIEluQXR0cmlidXRlTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTkgLyogSW5Db21tZW50ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQ29tbWVudChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAyMCAvKiBJblNwZWNpYWxDb21tZW50ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluU3BlY2lhbENvbW1lbnQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gOCAvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMyAvKiBJblRhZ05hbWUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDYgLyogSW5DbG9zaW5nVGFnTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbkNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDIgLyogQmVmb3JlVGFnTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVUYWdOYW1lKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDEwIC8qIEFmdGVyQXR0cmlidXRlTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVBZnRlckF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTMgLyogSW5BdHRyaWJ1dGVWYWx1ZVNxICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZXMoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTEgLyogQmVmb3JlQXR0cmlidXRlVmFsdWUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0cmlidXRlVmFsdWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNSAvKiBCZWZvcmVDbG9zaW5nVGFnTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVDbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA3IC8qIEFmdGVyQ2xvc2luZ1RhZ05hbWUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJDbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzMiAvKiBCZWZvcmVTcGVjaWFsUyAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVTcGVjaWFsUyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAyMSAvKiBBZnRlckNvbW1lbnQxICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ29tbWVudDEoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTQgLyogSW5BdHRyaWJ1dGVWYWx1ZU5xICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3RlcyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0IC8qIEluU2VsZkNsb3NpbmdUYWcgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5TZWxmQ2xvc2luZ1RhZyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxNiAvKiBJbkRlY2xhcmF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluRGVjbGFyYXRpb24oYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTUgLyogQmVmb3JlRGVjbGFyYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlRGVjbGFyYXRpb24oYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjIgLyogQWZ0ZXJDb21tZW50MiAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVBZnRlckNvbW1lbnQyKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDE4IC8qIEJlZm9yZUNvbW1lbnQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQ29tbWVudChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzMyAvKiBCZWZvcmVTcGVjaWFsU0VuZCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVTcGVjaWFsU0VuZChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1MyAvKiBCZWZvcmVTcGVjaWFsVEVuZCAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJTcGVjaWFsVEVuZCh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzOSAvKiBBZnRlclNjcmlwdDEgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyU2NyaXB0MSh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0MCAvKiBBZnRlclNjcmlwdDIgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyU2NyaXB0Mih0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0MSAvKiBBZnRlclNjcmlwdDMgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyU2NyaXB0Myh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzNCAvKiBCZWZvcmVTY3JpcHQxICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVTY3JpcHQxKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDM1IC8qIEJlZm9yZVNjcmlwdDIgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVNjcmlwdDIodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMzYgLyogQmVmb3JlU2NyaXB0MyAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlU2NyaXB0Myh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzNyAvKiBCZWZvcmVTY3JpcHQ0ICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVTY3JpcHQ0KHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDM4IC8qIEJlZm9yZVNjcmlwdDUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3BlY2lhbExhc3QoYywgMiAvKiBTY3JpcHQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQyIC8qIEFmdGVyU2NyaXB0NCAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJTY3JpcHQ0KHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQzIC8qIEFmdGVyU2NyaXB0NSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVBZnRlclNwZWNpYWxMYXN0KGMsIDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQ0IC8qIEJlZm9yZVN0eWxlMSAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlU3R5bGUxKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDI5IC8qIEluQ2RhdGEgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5DZGF0YShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0NSAvKiBCZWZvcmVTdHlsZTIgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVN0eWxlMih0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0NiAvKiBCZWZvcmVTdHlsZTMgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVN0eWxlMyh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0NyAvKiBCZWZvcmVTdHlsZTQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3BlY2lhbExhc3QoYywgMyAvKiBTdHlsZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNDggLyogQWZ0ZXJTdHlsZTEgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyU3R5bGUxKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQ5IC8qIEFmdGVyU3R5bGUyICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVBZnRlclN0eWxlMih0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1MCAvKiBBZnRlclN0eWxlMyAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJTdHlsZTModGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTEgLyogQWZ0ZXJTdHlsZTQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJTcGVjaWFsTGFzdChjLCA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1MiAvKiBCZWZvcmVTcGVjaWFsVCAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlU3BlY2lhbFQodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTQgLyogQmVmb3JlVGl0bGUxICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVUaXRsZTEodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTUgLyogQmVmb3JlVGl0bGUyICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVUaXRsZTIodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTYgLyogQmVmb3JlVGl0bGUzICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVUaXRsZTModGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTcgLyogQmVmb3JlVGl0bGU0ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVNwZWNpYWxMYXN0KGMsIDQgLyogVGl0bGUgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDU4IC8qIEFmdGVyVGl0bGUxICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVBZnRlclRpdGxlMSh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1OSAvKiBBZnRlclRpdGxlMiAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJUaXRsZTIodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjAgLyogQWZ0ZXJUaXRsZTMgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyVGl0bGUzKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDYxIC8qIEFmdGVyVGl0bGU0ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyU3BlY2lhbExhc3QoYywgNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTcgLyogSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjQgLyogSW5OYW1lZEVudGl0eSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVJbk5hbWVkRW50aXR5KGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDIzIC8qIEJlZm9yZUNkYXRhMSAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlQ2RhdGExKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDYyIC8qIEJlZm9yZUVudGl0eSAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlRW50aXR5KHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDI0IC8qIEJlZm9yZUNkYXRhMiAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlQ2RhdGEyKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDI1IC8qIEJlZm9yZUNkYXRhMyAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlQ2RhdGEzKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDMwIC8qIEFmdGVyQ2RhdGExICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ2RhdGExKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDMxIC8qIEFmdGVyQ2RhdGEyICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ2RhdGEyKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDI2IC8qIEJlZm9yZUNkYXRhNCAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlQ2RhdGE0KHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDI3IC8qIEJlZm9yZUNkYXRhNSAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlQ2RhdGE1KHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDI4IC8qIEJlZm9yZUNkYXRhNiAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVDZGF0YTYoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjYgLyogSW5IZXhFbnRpdHkgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSW5IZXhFbnRpdHkoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjUgLyogSW5OdW1lcmljRW50aXR5ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZUluTnVtZXJpY0VudGl0eShjKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDYzIC8qIEJlZm9yZU51bWVyaWNFbnRpdHkgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZU51bWVyaWNFbnRpdHkodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNicy5vbmVycm9yKEVycm9yKFwidW5rbm93biBfc3RhdGVcIiksIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgcmVtYWluaW5nIGRhdGEsIGVtaXQgaXQgaW4gYSByZWFzb25hYmxlIHdheVxuICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGluZ0RhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNicy5vbmVuZCgpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5oYW5kbGVUcmFpbGluZ0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMuc2VjdGlvblN0YXJ0KTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAyOSAvKiBJbkNkYXRhICovIHx8XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gMzAgLyogQWZ0ZXJDZGF0YTEgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID09PSAzMSAvKiBBZnRlckNkYXRhMiAqLykge1xuICAgICAgICAgICAgdGhpcy5jYnMub25jZGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTkgLyogSW5Db21tZW50ICovIHx8XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gMjEgLyogQWZ0ZXJDb21tZW50MSAqLyB8fFxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPT09IDIyIC8qIEFmdGVyQ29tbWVudDIgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2JzLm9uY29tbWVudChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjQgLyogSW5OYW1lZEVudGl0eSAqLyAmJiAhdGhpcy54bWxNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlTGVnYWN5RW50aXR5KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uU3RhcnQgPCB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5iYXNlU3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGluZ0RhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNjUgLyogSW5OdW1lcmljRW50aXR5ICovICYmICF0aGlzLnhtbE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlTnVtZXJpY0VudGl0eSgyLCAxMCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0IDwgdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhaWxpbmdEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDY2IC8qIEluSGV4RW50aXR5ICovICYmICF0aGlzLnhtbE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlTnVtZXJpY0VudGl0eSgzLCAxNiwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0IDwgdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuYmFzZVN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhaWxpbmdEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IDMgLyogSW5UYWdOYW1lICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gOCAvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gMTEgLyogQmVmb3JlQXR0cmlidXRlVmFsdWUgKi8gJiZcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlICE9PSAxMCAvKiBBZnRlckF0dHJpYnV0ZU5hbWUgKi8gJiZcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlICE9PSA5IC8qIEluQXR0cmlidXRlTmFtZSAqLyAmJlxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgIT09IDEzIC8qIEluQXR0cmlidXRlVmFsdWVTcSAqLyAmJlxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgIT09IDEyIC8qIEluQXR0cmlidXRlVmFsdWVEcSAqLyAmJlxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgIT09IDE0IC8qIEluQXR0cmlidXRlVmFsdWVOcSAqLyAmJlxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgIT09IDYgLyogSW5DbG9zaW5nVGFnTmFtZSAqLykge1xuICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIEVsc2UsIGlnbm9yZSByZW1haW5pbmcgZGF0YVxuICAgICAgICAgKiBUT0RPIGFkZCBhIHdheSB0byByZW1vdmUgY3VycmVudCB0YWdcbiAgICAgICAgICovXG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmdldFNlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZW1pdFRva2VuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5jYnNbbmFtZV0odGhpcy5nZXRTZWN0aW9uKCkpO1xuICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5lbWl0UGFydGlhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5iYXNlU3RhdGUgIT09IDEgLyogVGV4dCAqLykge1xuICAgICAgICAgICAgdGhpcy5jYnMub25hdHRyaWJkYXRhKHZhbHVlKTsgLy8gVE9ETyBpbXBsZW1lbnQgdGhlIG5ldyBldmVudFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYnMub250ZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRva2VuaXplcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlbml6ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUnNzSGFuZGxlciA9IGV4cG9ydHMuRGVmYXVsdEhhbmRsZXIgPSBleHBvcnRzLkRvbVV0aWxzID0gZXhwb3J0cy5FbGVtZW50VHlwZSA9IGV4cG9ydHMuVG9rZW5pemVyID0gZXhwb3J0cy5jcmVhdGVEb21TdHJlYW0gPSBleHBvcnRzLnBhcnNlRE9NID0gZXhwb3J0cy5Eb21IYW5kbGVyID0gZXhwb3J0cy5QYXJzZXIgPSB2b2lkIDA7XG52YXIgUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9QYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJzZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBhcnNlcl8xLlBhcnNlcjsgfSB9KTtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvbUhhbmRsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVmYXVsdEhhbmRsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyOyB9IH0pO1xuLy8gSGVscGVyIG1ldGhvZHNcbi8qKlxuICogUGFyc2VzIGRhdGEsIHJldHVybnMgdGhlIHJlc3VsdGluZyBET00uXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGJ1aWxkZXIuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRE9NKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGFuZGxlciA9IG5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcih2b2lkIDAsIG9wdGlvbnMpO1xuICAgIG5ldyBQYXJzZXJfMS5QYXJzZXIoaGFuZGxlciwgb3B0aW9ucykuZW5kKGRhdGEpO1xuICAgIHJldHVybiBoYW5kbGVyLmRvbTtcbn1cbmV4cG9ydHMucGFyc2VET00gPSBwYXJzZURPTTtcbi8qKlxuICogQ3JlYXRlcyBhIHBhcnNlciBpbnN0YW5jZSwgd2l0aCBhbiBhdHRhY2hlZCBET00gaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0gY2IgQSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgcGFyc2luZyBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciB0aGUgcGFyc2VyIGFuZCBET00gYnVpbGRlci5cbiAqIEBwYXJhbSBlbGVtZW50Q2IgQW4gb3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBldmVyeSB0aW1lIGEgdGFnIGhhcyBiZWVuIGNvbXBsZXRlZCBpbnNpZGUgb2YgdGhlIERPTS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRG9tU3RyZWFtKGNiLCBvcHRpb25zLCBlbGVtZW50Q2IpIHtcbiAgICB2YXIgaGFuZGxlciA9IG5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcihjYiwgb3B0aW9ucywgZWxlbWVudENiKTtcbiAgICByZXR1cm4gbmV3IFBhcnNlcl8xLlBhcnNlcihoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlRG9tU3RyZWFtID0gY3JlYXRlRG9tU3RyZWFtO1xudmFyIFRva2VuaXplcl8xID0gcmVxdWlyZShcIi4vVG9rZW5pemVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG9rZW5pemVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQoVG9rZW5pemVyXzEpLmRlZmF1bHQ7IH0gfSk7XG52YXIgRWxlbWVudFR5cGUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImRvbWVsZW1lbnR0eXBlXCIpKTtcbmV4cG9ydHMuRWxlbWVudFR5cGUgPSBFbGVtZW50VHlwZTtcbi8qXG4gKiBBbGwgb2YgdGhlIGZvbGxvd2luZyBleHBvcnRzIGV4aXN0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqIFRoZXkgc2hvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWQgZXZlbnR1YWxseS5cbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0ZlZWRIYW5kbGVyXCIpLCBleHBvcnRzKTtcbmV4cG9ydHMuRG9tVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImRvbXV0aWxzXCIpKTtcbnZhciBGZWVkSGFuZGxlcl8xID0gcmVxdWlyZShcIi4vRmVlZEhhbmRsZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSc3NIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBGZWVkSGFuZGxlcl8xLkZlZWRIYW5kbGVyOyB9IH0pO1xuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG4gIGlzQXJyYXk6IF9pc0FycmF5LFxuICBpc09iamVjdDogX2lzT2JqZWN0LFxuICBpc1N0cmluZzogX2lzU3RyaW5nLFxufSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHtcbiAgYXNBcnJheTogX2FzQXJyYXlcbn0gPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IHtwcmVwZW5kQmFzZX0gPSByZXF1aXJlKCcuL3VybCcpO1xuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5jb25zdCBSZXNvbHZlZENvbnRleHQgPSByZXF1aXJlKCcuL1Jlc29sdmVkQ29udGV4dCcpO1xuXG5jb25zdCBNQVhfQ09OVEVYVF9VUkxTID0gMTA7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29udGV4dFJlc29sdmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBDb250ZXh0UmVzb2x2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBzaGFyZWRDYWNoZSBhIHNoYXJlZCBMUlUgY2FjaGUgd2l0aCBgZ2V0YCBhbmQgYHNldGAgQVBJcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtzaGFyZWRDYWNoZX0pIHtcbiAgICB0aGlzLnBlck9wQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5zaGFyZWRDYWNoZSA9IHNoYXJlZENhY2hlO1xuICB9XG5cbiAgYXN5bmMgcmVzb2x2ZSh7XG4gICAgYWN0aXZlQ3R4LCBjb250ZXh0LCBkb2N1bWVudExvYWRlciwgYmFzZSwgY3ljbGVzID0gbmV3IFNldCgpXG4gIH0pIHtcbiAgICAvLyBwcm9jZXNzIGBAY29udGV4dGBcbiAgICBpZihjb250ZXh0ICYmIF9pc09iamVjdChjb250ZXh0KSAmJiBjb250ZXh0WydAY29udGV4dCddKSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dFsnQGNvbnRleHQnXTtcbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IGlzIG9uZSBvciBtb3JlIGNvbnRleHRzXG4gICAgY29udGV4dCA9IF9hc0FycmF5KGNvbnRleHQpO1xuXG4gICAgLy8gcmVzb2x2ZSBlYWNoIGNvbnRleHQgaW4gdGhlIGFycmF5XG4gICAgY29uc3QgYWxsUmVzb2x2ZWQgPSBbXTtcbiAgICBmb3IoY29uc3QgY3R4IG9mIGNvbnRleHQpIHtcbiAgICAgIGlmKF9pc1N0cmluZyhjdHgpKSB7XG4gICAgICAgIC8vIHNlZSBpZiBgY3R4YCBoYXMgYmVlbiByZXNvbHZlZCBiZWZvcmUuLi5cbiAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5fZ2V0KGN0eCk7XG4gICAgICAgIGlmKCFyZXNvbHZlZCkge1xuICAgICAgICAgIC8vIG5vdCByZXNvbHZlZCB5ZXQsIHJlc29sdmVcbiAgICAgICAgICByZXNvbHZlZCA9IGF3YWl0IHRoaXMuX3Jlc29sdmVSZW1vdGVDb250ZXh0KFxuICAgICAgICAgICAge2FjdGl2ZUN0eCwgdXJsOiBjdHgsIGRvY3VtZW50TG9hZGVyLCBiYXNlLCBjeWNsZXN9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byBvdXRwdXQgYW5kIGNvbnRpbnVlXG4gICAgICAgIGlmKF9pc0FycmF5KHJlc29sdmVkKSkge1xuICAgICAgICAgIGFsbFJlc29sdmVkLnB1c2goLi4ucmVzb2x2ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbFJlc29sdmVkLnB1c2gocmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYoY3R4ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGhhbmRsZSBgbnVsbGAgY29udGV4dCwgbm90aGluZyB0byBjYWNoZVxuICAgICAgICBhbGxSZXNvbHZlZC5wdXNoKG5ldyBSZXNvbHZlZENvbnRleHQoe2RvY3VtZW50OiBudWxsfSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKCFfaXNPYmplY3QoY3R4KSkge1xuICAgICAgICBfdGhyb3dJbnZhbGlkTG9jYWxDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgLy8gY29udGV4dCBpcyBhbiBvYmplY3QsIGdldC9jcmVhdGUgYFJlc29sdmVkQ29udGV4dGAgZm9yIGl0XG4gICAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShjdHgpO1xuICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5fZ2V0KGtleSk7XG4gICAgICBpZighcmVzb2x2ZWQpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHN0YXRpYyBgUmVzb2x2ZWRDb250ZXh0YCBhbmQgY2FjaGUgaXRcbiAgICAgICAgcmVzb2x2ZWQgPSBuZXcgUmVzb2x2ZWRDb250ZXh0KHtkb2N1bWVudDogY3R4fSk7XG4gICAgICAgIHRoaXMuX2NhY2hlUmVzb2x2ZWRDb250ZXh0KHtrZXksIHJlc29sdmVkLCB0YWc6ICdzdGF0aWMnfSk7XG4gICAgICB9XG4gICAgICBhbGxSZXNvbHZlZC5wdXNoKHJlc29sdmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxsUmVzb2x2ZWQ7XG4gIH1cblxuICBfZ2V0KGtleSkge1xuICAgIC8vIGdldCBrZXkgZnJvbSBwZXIgb3BlcmF0aW9uIGNhY2hlOyBubyBgdGFnYCBpcyB1c2VkIHdpdGggdGhpcyBjYWNoZSBzb1xuICAgIC8vIGFueSByZXRyaWV2ZWQgY29udGV4dCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBkdXJpbmcgYSBzaW5nbGUgb3BlcmF0aW9uXG4gICAgbGV0IHJlc29sdmVkID0gdGhpcy5wZXJPcENhY2hlLmdldChrZXkpO1xuICAgIGlmKCFyZXNvbHZlZCkge1xuICAgICAgLy8gc2VlIGlmIHRoZSBzaGFyZWQgY2FjaGUgaGFzIGEgYHN0YXRpY2AgZW50cnkgZm9yIHRoaXMgVVJMXG4gICAgICBjb25zdCB0YWdNYXAgPSB0aGlzLnNoYXJlZENhY2hlLmdldChrZXkpO1xuICAgICAgaWYodGFnTWFwKSB7XG4gICAgICAgIHJlc29sdmVkID0gdGFnTWFwLmdldCgnc3RhdGljJyk7XG4gICAgICAgIGlmKHJlc29sdmVkKSB7XG4gICAgICAgICAgdGhpcy5wZXJPcENhY2hlLnNldChrZXksIHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cblxuICBfY2FjaGVSZXNvbHZlZENvbnRleHQoe2tleSwgcmVzb2x2ZWQsIHRhZ30pIHtcbiAgICB0aGlzLnBlck9wQ2FjaGUuc2V0KGtleSwgcmVzb2x2ZWQpO1xuICAgIGlmKHRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgdGFnTWFwID0gdGhpcy5zaGFyZWRDYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmKCF0YWdNYXApIHtcbiAgICAgICAgdGFnTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNoYXJlZENhY2hlLnNldChrZXksIHRhZ01hcCk7XG4gICAgICB9XG4gICAgICB0YWdNYXAuc2V0KHRhZywgcmVzb2x2ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cblxuICBhc3luYyBfcmVzb2x2ZVJlbW90ZUNvbnRleHQoe2FjdGl2ZUN0eCwgdXJsLCBkb2N1bWVudExvYWRlciwgYmFzZSwgY3ljbGVzfSkge1xuICAgIC8vIHJlc29sdmUgcmVsYXRpdmUgVVJMIGFuZCBmZXRjaCBjb250ZXh0XG4gICAgdXJsID0gcHJlcGVuZEJhc2UoYmFzZSwgdXJsKTtcbiAgICBjb25zdCB7Y29udGV4dCwgcmVtb3RlRG9jfSA9IGF3YWl0IHRoaXMuX2ZldGNoQ29udGV4dChcbiAgICAgIHthY3RpdmVDdHgsIHVybCwgZG9jdW1lbnRMb2FkZXIsIGN5Y2xlc30pO1xuXG4gICAgLy8gdXBkYXRlIGJhc2UgYWNjb3JkaW5nIHRvIHJlbW90ZSBkb2N1bWVudCBhbmQgcmVzb2x2ZSBhbnkgcmVsYXRpdmUgVVJMc1xuICAgIGJhc2UgPSByZW1vdGVEb2MuZG9jdW1lbnRVcmwgfHwgdXJsO1xuICAgIF9yZXNvbHZlQ29udGV4dFVybHMoe2NvbnRleHQsIGJhc2V9KTtcblxuICAgIC8vIHJlc29sdmUsIGNhY2hlLCBhbmQgcmV0dXJuIGNvbnRleHRcbiAgICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IHRoaXMucmVzb2x2ZShcbiAgICAgIHthY3RpdmVDdHgsIGNvbnRleHQsIGRvY3VtZW50TG9hZGVyLCBiYXNlLCBjeWNsZXN9KTtcbiAgICB0aGlzLl9jYWNoZVJlc29sdmVkQ29udGV4dCh7a2V5OiB1cmwsIHJlc29sdmVkLCB0YWc6IHJlbW90ZURvYy50YWd9KTtcbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cblxuICBhc3luYyBfZmV0Y2hDb250ZXh0KHthY3RpdmVDdHgsIHVybCwgZG9jdW1lbnRMb2FkZXIsIGN5Y2xlc30pIHtcbiAgICAvLyBjaGVjayBmb3IgbWF4IGNvbnRleHQgVVJMcyBmZXRjaGVkIGR1cmluZyBhIHJlc29sdmUgb3BlcmF0aW9uXG4gICAgaWYoY3ljbGVzLnNpemUgPiBNQVhfQ09OVEVYVF9VUkxTKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdNYXhpbXVtIG51bWJlciBvZiBAY29udGV4dCBVUkxzIGV4Y2VlZGVkLicsXG4gICAgICAgICdqc29ubGQuQ29udGV4dFVybEVycm9yJyxcbiAgICAgICAge1xuICAgICAgICAgIGNvZGU6IGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSA9PT0gJ2pzb24tbGQtMS4wJyA/XG4gICAgICAgICAgICAnbG9hZGluZyByZW1vdGUgY29udGV4dCBmYWlsZWQnIDpcbiAgICAgICAgICAgICdjb250ZXh0IG92ZXJmbG93JyxcbiAgICAgICAgICBtYXg6IE1BWF9DT05URVhUX1VSTFNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGNvbnRleHQgVVJMIGN5Y2xlXG4gICAgLy8gc2hvcnRjdXQgdG8gYXZvaWQgZXh0cmEgd29yayB0aGF0IHdvdWxkIGV2ZW50dWFsbHkgaGl0IHRoZSBtYXggYWJvdmVcbiAgICBpZihjeWNsZXMuaGFzKHVybCkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0N5Y2xpY2FsIEBjb250ZXh0IFVSTHMgZGV0ZWN0ZWQuJyxcbiAgICAgICAgJ2pzb25sZC5Db250ZXh0VXJsRXJyb3InLFxuICAgICAgICB7XG4gICAgICAgICAgY29kZTogYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlID09PSAnanNvbi1sZC0xLjAnID9cbiAgICAgICAgICAgICdyZWN1cnNpdmUgY29udGV4dCBpbmNsdXNpb24nIDpcbiAgICAgICAgICAgICdjb250ZXh0IG92ZXJmbG93JyxcbiAgICAgICAgICB1cmxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdHJhY2sgY3ljbGVzXG4gICAgY3ljbGVzLmFkZCh1cmwpO1xuXG4gICAgbGV0IGNvbnRleHQ7XG4gICAgbGV0IHJlbW90ZURvYztcblxuICAgIHRyeSB7XG4gICAgICByZW1vdGVEb2MgPSBhd2FpdCBkb2N1bWVudExvYWRlcih1cmwpO1xuICAgICAgY29udGV4dCA9IHJlbW90ZURvYy5kb2N1bWVudCB8fCBudWxsO1xuICAgICAgLy8gcGFyc2Ugc3RyaW5nIGNvbnRleHQgYXMgSlNPTlxuICAgICAgaWYoX2lzU3RyaW5nKGNvbnRleHQpKSB7XG4gICAgICAgIGNvbnRleHQgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnRGVyZWZlcmVuY2luZyBhIFVSTCBkaWQgbm90IHJlc3VsdCBpbiBhIHZhbGlkIEpTT04tTEQgb2JqZWN0LiAnICtcbiAgICAgICAgJ1Bvc3NpYmxlIGNhdXNlcyBhcmUgYW4gaW5hY2Nlc3NpYmxlIFVSTCBwZXJoYXBzIGR1ZSB0byAnICtcbiAgICAgICAgJ2Egc2FtZS1vcmlnaW4gcG9saWN5IChlbnN1cmUgdGhlIHNlcnZlciB1c2VzIENPUlMgaWYgeW91IGFyZSAnICtcbiAgICAgICAgJ3VzaW5nIGNsaWVudC1zaWRlIEphdmFTY3JpcHQpLCB0b28gbWFueSByZWRpcmVjdHMsIGEgJyArXG4gICAgICAgICdub24tSlNPTiByZXNwb25zZSwgb3IgbW9yZSB0aGFuIG9uZSBIVFRQIExpbmsgSGVhZGVyIHdhcyAnICtcbiAgICAgICAgJ3Byb3ZpZGVkIGZvciBhIHJlbW90ZSBjb250ZXh0LicsXG4gICAgICAgICdqc29ubGQuSW52YWxpZFVybCcsXG4gICAgICAgIHtjb2RlOiAnbG9hZGluZyByZW1vdGUgY29udGV4dCBmYWlsZWQnLCB1cmwsIGNhdXNlOiBlfSk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGN0eCBpcyBhbiBvYmplY3RcbiAgICBpZighX2lzT2JqZWN0KGNvbnRleHQpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdEZXJlZmVyZW5jaW5nIGEgVVJMIGRpZCBub3QgcmVzdWx0IGluIGEgSlNPTiBvYmplY3QuIFRoZSAnICtcbiAgICAgICAgJ3Jlc3BvbnNlIHdhcyB2YWxpZCBKU09OLCBidXQgaXQgd2FzIG5vdCBhIEpTT04gb2JqZWN0LicsXG4gICAgICAgICdqc29ubGQuSW52YWxpZFVybCcsIHtjb2RlOiAnaW52YWxpZCByZW1vdGUgY29udGV4dCcsIHVybH0pO1xuICAgIH1cblxuICAgIC8vIHVzZSBlbXB0eSBjb250ZXh0IGlmIG5vIEBjb250ZXh0IGtleSBpcyBwcmVzZW50XG4gICAgaWYoISgnQGNvbnRleHQnIGluIGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0ID0geydAY29udGV4dCc6IHt9fTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHsnQGNvbnRleHQnOiBjb250ZXh0WydAY29udGV4dCddfTtcbiAgICB9XG5cbiAgICAvLyBhcHBlbmQgQGNvbnRleHQgVVJMIHRvIGNvbnRleHQgaWYgZ2l2ZW5cbiAgICBpZihyZW1vdGVEb2MuY29udGV4dFVybCkge1xuICAgICAgaWYoIV9pc0FycmF5KGNvbnRleHRbJ0Bjb250ZXh0J10pKSB7XG4gICAgICAgIGNvbnRleHRbJ0Bjb250ZXh0J10gPSBbY29udGV4dFsnQGNvbnRleHQnXV07XG4gICAgICB9XG4gICAgICBjb250ZXh0WydAY29udGV4dCddLnB1c2gocmVtb3RlRG9jLmNvbnRleHRVcmwpO1xuICAgIH1cblxuICAgIHJldHVybiB7Y29udGV4dCwgcmVtb3RlRG9jfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX3Rocm93SW52YWxpZExvY2FsQ29udGV4dChjdHgpIHtcbiAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBtdXN0IGJlIGFuIG9iamVjdC4nLFxuICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7XG4gICAgICBjb2RlOiAnaW52YWxpZCBsb2NhbCBjb250ZXh0JywgY29udGV4dDogY3R4XG4gICAgfSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbGwgcmVsYXRpdmUgYEBjb250ZXh0YCBVUkxzIGluIHRoZSBnaXZlbiBjb250ZXh0IGJ5IGlubGluZVxuICogcmVwbGFjaW5nIHRoZW0gd2l0aCBhYnNvbHV0ZSBVUkxzLlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IHRoZSBjb250ZXh0LlxuICogQHBhcmFtIGJhc2UgdGhlIGJhc2UgSVJJIHRvIHVzZSB0byByZXNvbHZlIHJlbGF0aXZlIElSSXMuXG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlQ29udGV4dFVybHMoe2NvbnRleHQsIGJhc2V9KSB7XG4gIGlmKCFjb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY3R4ID0gY29udGV4dFsnQGNvbnRleHQnXTtcblxuICBpZihfaXNTdHJpbmcoY3R4KSkge1xuICAgIGNvbnRleHRbJ0Bjb250ZXh0J10gPSBwcmVwZW5kQmFzZShiYXNlLCBjdHgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKF9pc0FycmF5KGN0eCkpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgY3R4Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gY3R4W2ldO1xuICAgICAgaWYoX2lzU3RyaW5nKGVsZW1lbnQpKSB7XG4gICAgICAgIGN0eFtpXSA9IHByZXBlbmRCYXNlKGJhc2UsIGVsZW1lbnQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKF9pc09iamVjdChlbGVtZW50KSkge1xuICAgICAgICBfcmVzb2x2ZUNvbnRleHRVcmxzKHtjb250ZXh0OiB7J0Bjb250ZXh0JzogZWxlbWVudH0sIGJhc2V9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYoIV9pc09iamVjdChjdHgpKSB7XG4gICAgLy8gbm8gQGNvbnRleHQgVVJMcyBjYW4gYmUgZm91bmQgaW4gbm9uLW9iamVjdFxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGN0eCBpcyBhbiBvYmplY3QsIHJlc29sdmUgYW55IGNvbnRleHQgVVJMcyBpbiB0ZXJtc1xuICBmb3IoY29uc3QgdGVybSBpbiBjdHgpIHtcbiAgICBfcmVzb2x2ZUNvbnRleHRVcmxzKHtjb250ZXh0OiBjdHhbdGVybV0sIGJhc2V9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSnNvbkxkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgSlNPTi1MRCBFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIHR5cGUgdGhlIGVycm9yIHR5cGUuXG4gICAqIEBwYXJhbSBkZXRhaWxzIHRoZSBlcnJvciBkZXRhaWxzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZSA9ICdBbiB1bnNwZWNpZmllZCBKU09OLUxEIGVycm9yIG9jY3VycmVkLicsXG4gICAgbmFtZSA9ICdqc29ubGQuRXJyb3InLFxuICAgIGRldGFpbHMgPSB7fSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbmxkID0+IHtcbiAgY2xhc3MgSnNvbkxkUHJvY2Vzc29yIHtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnW29iamVjdCBKc29uTGRQcm9jZXNzb3JdJztcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEpzb25MZFByb2Nlc3NvciwgJ3Byb3RvdHlwZScsIHtcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKc29uTGRQcm9jZXNzb3IucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBKc29uTGRQcm9jZXNzb3JcbiAgfSk7XG5cbiAgLy8gVGhlIFdlYiBJREwgdGVzdCBoYXJuZXNzIHdpbGwgY2hlY2sgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGRlZmluZWQgaW5cbiAgLy8gdGhlIGZ1bmN0aW9ucyBiZWxvdy4gVGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIG11c3QgZXhhY3RseSBtYXRjaCB0aGVcbiAgLy8gcmVxdWlyZWQgKG5vbi1vcHRpb25hbCkgcGFyYW1ldGVycyBvZiB0aGUgSnNvbkxkUHJvY2Vzc29yIGludGVyZmFjZSBhc1xuICAvLyBkZWZpbmVkIGhlcmU6XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9qc29uLWxkLWFwaS8jdGhlLWpzb25sZHByb2Nlc3Nvci1pbnRlcmZhY2VcblxuICBKc29uTGRQcm9jZXNzb3IuY29tcGFjdCA9IGZ1bmN0aW9uKGlucHV0LCBjdHgpIHtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgY29tcGFjdCwgdG9vIGZldyBhcmd1bWVudHMuJykpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbmxkLmNvbXBhY3QoaW5wdXQsIGN0eCk7XG4gIH07XG4gIEpzb25MZFByb2Nlc3Nvci5leHBhbmQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBleHBhbmQsIHRvbyBmZXcgYXJndW1lbnRzLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25sZC5leHBhbmQoaW5wdXQpO1xuICB9O1xuICBKc29uTGRQcm9jZXNzb3IuZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGZsYXR0ZW4sIHRvbyBmZXcgYXJndW1lbnRzLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25sZC5mbGF0dGVuKGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gSnNvbkxkUHJvY2Vzc29yO1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOiBtb3ZlIGBOUXVhZHNgIHRvIGl0cyBvd24gcGFja2FnZVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdyZGYtY2Fub25pemUnKS5OUXVhZHM7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbi8qIGdsb2JhbCBOb2RlLCBYTUxTZXJpYWxpemVyICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgUkRGX0xBTkdTVFJJTkcsXG4gIFJERl9QTEFJTl9MSVRFUkFMLFxuICBSREZfT0JKRUNULFxuICBSREZfWE1MX0xJVEVSQUwsXG4gIFhTRF9TVFJJTkcsXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxubGV0IF9Ob2RlO1xuaWYodHlwZW9mIE5vZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIF9Ob2RlID0gTm9kZTtcbn0gZWxzZSB7XG4gIF9Ob2RlID0ge1xuICAgIEVMRU1FTlRfTk9ERTogMSxcbiAgICBBVFRSSUJVVEVfTk9ERTogMixcbiAgICBURVhUX05PREU6IDMsXG4gICAgQ0RBVEFfU0VDVElPTl9OT0RFOiA0LFxuICAgIEVOVElUWV9SRUZFUkVOQ0VfTk9ERTogNSxcbiAgICBFTlRJVFlfTk9ERTogNixcbiAgICBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU6IDcsXG4gICAgQ09NTUVOVF9OT0RFOiA4LFxuICAgIERPQ1VNRU5UX05PREU6IDksXG4gICAgRE9DVU1FTlRfVFlQRV9OT0RFOiAxMCxcbiAgICBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOiAxMSxcbiAgICBOT1RBVElPTl9OT0RFOiAxMlxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFJkZmEge1xuICAvKipcbiAgICogUGFyc2VzIHRoZSBSREYgZGF0YXNldCBmb3VuZCB2aWEgdGhlIGRhdGEgb2JqZWN0IGZyb20gdGhlIFJERmEgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgUkRGYSBBUEkgZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIFJERiBkYXRhc2V0LlxuICAgKi9cbiAgcGFyc2UoZGF0YSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB7fTtcbiAgICBkYXRhc2V0WydAZGVmYXVsdCddID0gW107XG5cbiAgICBjb25zdCBzdWJqZWN0cyA9IGRhdGEuZ2V0U3ViamVjdHMoKTtcbiAgICBmb3IobGV0IHNpID0gMDsgc2kgPCBzdWJqZWN0cy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgIGNvbnN0IHN1YmplY3QgPSBzdWJqZWN0c1tzaV07XG4gICAgICBpZihzdWJqZWN0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgYWxsIHJlbGF0ZWQgdHJpcGxlc1xuICAgICAgY29uc3QgdHJpcGxlcyA9IGRhdGEuZ2V0U3ViamVjdFRyaXBsZXMoc3ViamVjdCk7XG4gICAgICBpZih0cmlwbGVzID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJlZGljYXRlcyA9IHRyaXBsZXMucHJlZGljYXRlcztcbiAgICAgIGZvcihjb25zdCBwcmVkaWNhdGUgaW4gcHJlZGljYXRlcykge1xuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgb2JqZWN0c1xuICAgICAgICBjb25zdCBvYmplY3RzID0gcHJlZGljYXRlc1twcmVkaWNhdGVdLm9iamVjdHM7XG4gICAgICAgIGZvcihsZXQgb2kgPSAwOyBvaSA8IG9iamVjdHMubGVuZ3RoOyArK29pKSB7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0ID0gb2JqZWN0c1tvaV07XG5cbiAgICAgICAgICAvLyBjcmVhdGUgUkRGIHRyaXBsZVxuICAgICAgICAgIGNvbnN0IHRyaXBsZSA9IHt9O1xuXG4gICAgICAgICAgLy8gYWRkIHN1YmplY3RcbiAgICAgICAgICBpZihzdWJqZWN0LmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgICAgICAgIHRyaXBsZS5zdWJqZWN0ID0ge3R5cGU6ICdibGFuayBub2RlJywgdmFsdWU6IHN1YmplY3R9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmlwbGUuc3ViamVjdCA9IHt0eXBlOiAnSVJJJywgdmFsdWU6IHN1YmplY3R9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCBwcmVkaWNhdGVcbiAgICAgICAgICBpZihwcmVkaWNhdGUuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgICAgICAgdHJpcGxlLnByZWRpY2F0ZSA9IHt0eXBlOiAnYmxhbmsgbm9kZScsIHZhbHVlOiBwcmVkaWNhdGV9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmlwbGUucHJlZGljYXRlID0ge3R5cGU6ICdJUkknLCB2YWx1ZTogcHJlZGljYXRlfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzZXJpYWxpemUgWE1MIGxpdGVyYWxcbiAgICAgICAgICBsZXQgdmFsdWUgPSBvYmplY3QudmFsdWU7XG4gICAgICAgICAgaWYob2JqZWN0LnR5cGUgPT09IFJERl9YTUxfTElURVJBTCkge1xuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBYTUxTZXJpYWxpemVyXG4gICAgICAgICAgICBjb25zdCBYTUxTZXJpYWxpemVyID0gZ2V0WE1MU2VyaWFsaXplckNsYXNzKCk7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgb2JqZWN0LnZhbHVlLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgIGlmKG9iamVjdC52YWx1ZVt4XS5ub2RlVHlwZSA9PT0gX05vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhvYmplY3QudmFsdWVbeF0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYob2JqZWN0LnZhbHVlW3hdLm5vZGVUeXBlID09PSBfTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBvYmplY3QudmFsdWVbeF0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIG9iamVjdFxuICAgICAgICAgIHRyaXBsZS5vYmplY3QgPSB7fTtcblxuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBJUklcbiAgICAgICAgICBpZihvYmplY3QudHlwZSA9PT0gUkRGX09CSkVDVCkge1xuICAgICAgICAgICAgaWYob2JqZWN0LnZhbHVlLmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgICAgICAgICAgdHJpcGxlLm9iamVjdC50eXBlID0gJ2JsYW5rIG5vZGUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJpcGxlLm9iamVjdC50eXBlID0gJ0lSSSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBhIGxpdGVyYWxcbiAgICAgICAgICAgIHRyaXBsZS5vYmplY3QudHlwZSA9ICdsaXRlcmFsJztcbiAgICAgICAgICAgIGlmKG9iamVjdC50eXBlID09PSBSREZfUExBSU5fTElURVJBTCkge1xuICAgICAgICAgICAgICBpZihvYmplY3QubGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICB0cmlwbGUub2JqZWN0LmRhdGF0eXBlID0gUkRGX0xBTkdTVFJJTkc7XG4gICAgICAgICAgICAgICAgdHJpcGxlLm9iamVjdC5sYW5ndWFnZSA9IG9iamVjdC5sYW5ndWFnZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmlwbGUub2JqZWN0LmRhdGF0eXBlID0gWFNEX1NUUklORztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJpcGxlLm9iamVjdC5kYXRhdHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cmlwbGUub2JqZWN0LnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAvLyBhZGQgdHJpcGxlIHRvIGRhdGFzZXQgaW4gZGVmYXVsdCBncmFwaFxuICAgICAgICAgIGRhdGFzZXRbJ0BkZWZhdWx0J10ucHVzaCh0cmlwbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFzZXQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFhNTFNlcmlhbGl6ZXJDbGFzcygpIHtcbiAgaWYodHlwZW9mIFhNTFNlcmlhbGl6ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ3htbGRvbScpLlhNTFNlcmlhbGl6ZXI7XG4gIH1cbiAgcmV0dXJuIFhNTFNlcmlhbGl6ZXI7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMTkgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFJlcXVlc3RRdWV1ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2ltcGxlIHF1ZXVlIGZvciByZXF1ZXN0aW5nIGRvY3VtZW50cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3RzID0ge307XG4gIH1cblxuICB3cmFwTG9hZGVyKGxvYWRlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuX2xvYWRlciA9IGxvYWRlcjtcbiAgICByZXR1cm4gZnVuY3Rpb24oLyogdXJsICovKSB7XG4gICAgICByZXR1cm4gc2VsZi5hZGQuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgYWRkKHVybCkge1xuICAgIGxldCBwcm9taXNlID0gdGhpcy5fcmVxdWVzdHNbdXJsXTtcbiAgICBpZihwcm9taXNlKSB7XG4gICAgICAvLyBVUkwgYWxyZWFkeSBxdWV1ZWQsIHdhaXQgZm9yIGl0IHRvIGxvYWRcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvbWlzZSk7XG4gICAgfVxuXG4gICAgLy8gcXVldWUgVVJMIGFuZCBsb2FkIGl0XG4gICAgcHJvbWlzZSA9IHRoaXMuX3JlcXVlc3RzW3VybF0gPSB0aGlzLl9sb2FkZXIodXJsKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIHRoaXMuX3JlcXVlc3RzW3VybF07XG4gICAgfVxuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpO1xuXG5jb25zdCBNQVhfQUNUSVZFX0NPTlRFWFRTID0gMTA7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmVzb2x2ZWRDb250ZXh0IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZXNvbHZlZENvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSBkb2N1bWVudCB0aGUgY29udGV4dCBkb2N1bWVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtkb2N1bWVudH0pIHtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgLy8gVE9ETzogZW5hYmxlIGN1c3RvbWl6YXRpb24gb2YgcHJvY2Vzc2VkIGNvbnRleHQgY2FjaGVcbiAgICAvLyBUT0RPOiBsaW1pdCBiYXNlZCBvbiBzaXplIG9mIHByb2Nlc3NlZCBjb250ZXh0cyB2cy4gbnVtYmVyIG9mIHRoZW1cbiAgICB0aGlzLmNhY2hlID0gbmV3IExSVSh7bWF4OiBNQVhfQUNUSVZFX0NPTlRFWFRTfSk7XG4gIH1cblxuICBnZXRQcm9jZXNzZWQoYWN0aXZlQ3R4KSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGFjdGl2ZUN0eCk7XG4gIH1cblxuICBzZXRQcm9jZXNzZWQoYWN0aXZlQ3R4LCBwcm9jZXNzZWRDdHgpIHtcbiAgICB0aGlzLmNhY2hlLnNldChhY3RpdmVDdHgsIHByb2Nlc3NlZEN0eCk7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5cbmNvbnN0IHtcbiAgaXNBcnJheTogX2lzQXJyYXksXG4gIGlzT2JqZWN0OiBfaXNPYmplY3QsXG4gIGlzU3RyaW5nOiBfaXNTdHJpbmcsXG4gIGlzVW5kZWZpbmVkOiBfaXNVbmRlZmluZWRcbn0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IHtcbiAgaXNMaXN0OiBfaXNMaXN0LFxuICBpc1ZhbHVlOiBfaXNWYWx1ZSxcbiAgaXNHcmFwaDogX2lzR3JhcGgsXG4gIGlzU2ltcGxlR3JhcGg6IF9pc1NpbXBsZUdyYXBoLFxuICBpc1N1YmplY3RSZWZlcmVuY2U6IF9pc1N1YmplY3RSZWZlcmVuY2Vcbn0gPSByZXF1aXJlKCcuL2dyYXBoVHlwZXMnKTtcblxuY29uc3Qge1xuICBleHBhbmRJcmk6IF9leHBhbmRJcmksXG4gIGdldENvbnRleHRWYWx1ZTogX2dldENvbnRleHRWYWx1ZSxcbiAgaXNLZXl3b3JkOiBfaXNLZXl3b3JkLFxuICBwcm9jZXNzOiBfcHJvY2Vzc0NvbnRleHQsXG4gIHByb2Nlc3NpbmdNb2RlOiBfcHJvY2Vzc2luZ01vZGVcbn0gPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcblxuY29uc3Qge1xuICByZW1vdmVCYXNlOiBfcmVtb3ZlQmFzZSxcbiAgcHJlcGVuZEJhc2U6IF9wcmVwZW5kQmFzZVxufSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbmNvbnN0IHtcbiAgYWRkVmFsdWU6IF9hZGRWYWx1ZSxcbiAgYXNBcnJheTogX2FzQXJyYXksXG4gIGNvbXBhcmVTaG9ydGVzdExlYXN0OiBfY29tcGFyZVNob3J0ZXN0TGVhc3Rcbn0gPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBjb21wYWN0cyBhbiBlbGVtZW50IHVzaW5nIHRoZSBnaXZlbiBhY3RpdmUgY29udGV4dC4gQWxsIHZhbHVlc1xuICogbXVzdCBiZSBpbiBleHBhbmRlZCBmb3JtIGJlZm9yZSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgYWN0aXZlIGNvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIGFjdGl2ZVByb3BlcnR5IHRoZSBjb21wYWN0ZWQgcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiAgICAgICAgICB0byBjb21wYWN0LCBudWxsIGZvciBub25lLlxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gY29tcGFjdC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBjb21wYWN0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gY29tcGFjdGlvbk1hcCB0aGUgY29tcGFjdGlvbiBtYXAgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNvbXBhY3RlZCB2YWx1ZS5cbiAqL1xuYXBpLmNvbXBhY3QgPSBhc3luYyAoe1xuICBhY3RpdmVDdHgsXG4gIGFjdGl2ZVByb3BlcnR5ID0gbnVsbCxcbiAgZWxlbWVudCxcbiAgb3B0aW9ucyA9IHt9LFxuICBjb21wYWN0aW9uTWFwID0gKCkgPT4gdW5kZWZpbmVkXG59KSA9PiB7XG4gIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhY3QgYXJyYXlcbiAgaWYoX2lzQXJyYXkoZWxlbWVudCkpIHtcbiAgICBsZXQgcnZhbCA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbGVtZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyBjb21wYWN0LCBkcm9wcGluZyBhbnkgbnVsbCB2YWx1ZXMgdW5sZXNzIGN1c3RvbSBtYXBwZWRcbiAgICAgIGxldCBjb21wYWN0ZWQgPSBhd2FpdCBhcGkuY29tcGFjdCh7XG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRbaV0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNvbXBhY3Rpb25NYXBcbiAgICAgIH0pO1xuICAgICAgaWYoY29tcGFjdGVkID09PSBudWxsKSB7XG4gICAgICAgIGNvbXBhY3RlZCA9IGF3YWl0IGNvbXBhY3Rpb25NYXAoe1xuICAgICAgICAgIHVubWFwcGVkVmFsdWU6IGVsZW1lbnRbaV0sXG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICAgIHBhcmVudDogZWxlbWVudCxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBpZihjb21wYWN0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBydmFsLnB1c2goY29tcGFjdGVkKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy5jb21wYWN0QXJyYXlzICYmIHJ2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyB1c2Ugc2luZ2xlIGVsZW1lbnQgaWYgbm8gY29udGFpbmVyIGlzIHNwZWNpZmllZFxuICAgICAgY29uc3QgY29udGFpbmVyID0gX2dldENvbnRleHRWYWx1ZShcbiAgICAgICAgYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0Bjb250YWluZXInKSB8fCBbXTtcbiAgICAgIGlmKGNvbnRhaW5lci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcnZhbCA9IHJ2YWxbMF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsO1xuICB9XG5cbiAgLy8gdXNlIGFueSBzY29wZWQgY29udGV4dCBvbiBhY3RpdmVQcm9wZXJ0eVxuICBjb25zdCBjdHggPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAY29udGV4dCcpO1xuICBpZighX2lzVW5kZWZpbmVkKGN0eCkpIHtcbiAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgYWN0aXZlQ3R4LFxuICAgICAgbG9jYWxDdHg6IGN0eCxcbiAgICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICAgIG92ZXJyaWRlUHJvdGVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgLy8gcmVjdXJzaXZlbHkgY29tcGFjdCBvYmplY3RcbiAgaWYoX2lzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgaWYob3B0aW9ucy5saW5rICYmICdAaWQnIGluIGVsZW1lbnQgJiZcbiAgICAgIG9wdGlvbnMubGluay5oYXNPd25Qcm9wZXJ0eShlbGVtZW50WydAaWQnXSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciBhIGxpbmtlZCBlbGVtZW50IHRvIHJldXNlXG4gICAgICBjb25zdCBsaW5rZWQgPSBvcHRpb25zLmxpbmtbZWxlbWVudFsnQGlkJ11dO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxpbmtlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZihsaW5rZWRbaV0uZXhwYW5kZWQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gbGlua2VkW2ldLmNvbXBhY3RlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRvIHZhbHVlIGNvbXBhY3Rpb24gb24gQHZhbHVlcyBhbmQgc3ViamVjdCByZWZlcmVuY2VzXG4gICAgaWYoX2lzVmFsdWUoZWxlbWVudCkgfHwgX2lzU3ViamVjdFJlZmVyZW5jZShlbGVtZW50KSkge1xuICAgICAgY29uc3QgcnZhbCA9XG4gICAgICAgIGFwaS5jb21wYWN0VmFsdWUoe2FjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHZhbHVlOiBlbGVtZW50LCBvcHRpb25zfSk7XG4gICAgICBpZihvcHRpb25zLmxpbmsgJiYgX2lzU3ViamVjdFJlZmVyZW5jZShlbGVtZW50KSkge1xuICAgICAgICAvLyBzdG9yZSBsaW5rZWQgZWxlbWVudFxuICAgICAgICBpZighKG9wdGlvbnMubGluay5oYXNPd25Qcm9wZXJ0eShlbGVtZW50WydAaWQnXSkpKSB7XG4gICAgICAgICAgb3B0aW9ucy5saW5rW2VsZW1lbnRbJ0BpZCddXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMubGlua1tlbGVtZW50WydAaWQnXV0ucHVzaCh7ZXhwYW5kZWQ6IGVsZW1lbnQsIGNvbXBhY3RlZDogcnZhbH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuXG4gICAgLy8gaWYgZXhwYW5kZWQgcHJvcGVydHkgaXMgQGxpc3QgYW5kIHdlJ3JlIGNvbnRhaW5lZCB3aXRoaW4gYSBsaXN0XG4gICAgLy8gY29udGFpbmVyLCByZWN1cnNpdmVseSBjb21wYWN0IHRoaXMgaXRlbSB0byBhbiBhcnJheVxuICAgIGlmKF9pc0xpc3QoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRDb250ZXh0VmFsdWUoXG4gICAgICAgIGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAY29udGFpbmVyJykgfHwgW107XG4gICAgICBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BsaXN0JykpIHtcbiAgICAgICAgcmV0dXJuIGFwaS5jb21wYWN0KHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudFsnQGxpc3QnXSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGNvbXBhY3Rpb25NYXBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IGF2b2lkIG1pc3VzZSBvZiBhY3RpdmUgcHJvcGVydHkgYXMgYW4gZXhwYW5kZWQgcHJvcGVydHk/XG4gICAgY29uc3QgaW5zaWRlUmV2ZXJzZSA9IChhY3RpdmVQcm9wZXJ0eSA9PT0gJ0ByZXZlcnNlJyk7XG5cbiAgICBjb25zdCBydmFsID0ge307XG5cbiAgICAvLyBvcmlnaW5hbCBjb250ZXh0IGJlZm9yZSBhcHBseWluZyBwcm9wZXJ0eS1zY29wZWQgYW5kIGxvY2FsIGNvbnRleHRzXG4gICAgY29uc3QgaW5wdXRDdHggPSBhY3RpdmVDdHg7XG5cbiAgICAvLyByZXZlcnQgdG8gcHJldmlvdXMgY29udGV4dCwgaWYgdGhlcmUgaXMgb25lLFxuICAgIC8vIGFuZCBlbGVtZW50IGlzIG5vdCBhIHZhbHVlIG9iamVjdCBvciBhIG5vZGUgcmVmZXJlbmNlXG4gICAgaWYoIV9pc1ZhbHVlKGVsZW1lbnQpICYmICFfaXNTdWJqZWN0UmVmZXJlbmNlKGVsZW1lbnQpKSB7XG4gICAgICBhY3RpdmVDdHggPSBhY3RpdmVDdHgucmV2ZXJ0VG9QcmV2aW91c0NvbnRleHQoKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBwcm9wZXJ0eS1zY29wZWQgY29udGV4dCBhZnRlciByZXZlcnRpbmcgdGVybS1zY29wZWQgY29udGV4dFxuICAgIGNvbnN0IHByb3BlcnR5U2NvcGVkQ3R4ID1cbiAgICAgIF9nZXRDb250ZXh0VmFsdWUoaW5wdXRDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRleHQnKTtcbiAgICBpZighX2lzVW5kZWZpbmVkKHByb3BlcnR5U2NvcGVkQ3R4KSkge1xuICAgICAgYWN0aXZlQ3R4ID0gYXdhaXQgX3Byb2Nlc3NDb250ZXh0KHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBsb2NhbEN0eDogcHJvcGVydHlTY29wZWRDdHgsXG4gICAgICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICAgICAgb3ZlcnJpZGVQcm90ZWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmKG9wdGlvbnMubGluayAmJiAnQGlkJyBpbiBlbGVtZW50KSB7XG4gICAgICAvLyBzdG9yZSBsaW5rZWQgZWxlbWVudFxuICAgICAgaWYoIW9wdGlvbnMubGluay5oYXNPd25Qcm9wZXJ0eShlbGVtZW50WydAaWQnXSkpIHtcbiAgICAgICAgb3B0aW9ucy5saW5rW2VsZW1lbnRbJ0BpZCddXSA9IFtdO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5saW5rW2VsZW1lbnRbJ0BpZCddXS5wdXNoKHtleHBhbmRlZDogZWxlbWVudCwgY29tcGFjdGVkOiBydmFsfSk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGNvbnRleHQgZGVmaW5lZCBvbiBhbiBhbGlhcyBvZiBAdHlwZVxuICAgIC8vIGlmIGtleSBpcyBAdHlwZSBhbmQgYW55IGNvbXBhY3RlZCB2YWx1ZSBpcyBhIHRlcm0gaGF2aW5nIGEgbG9jYWxcbiAgICAvLyBjb250ZXh0LCBvdmVybGF5IHRoYXQgY29udGV4dFxuICAgIGxldCB0eXBlcyA9IGVsZW1lbnRbJ0B0eXBlJ10gfHwgW107XG4gICAgaWYodHlwZXMubGVuZ3RoID4gMSkge1xuICAgICAgdHlwZXMgPSBBcnJheS5mcm9tKHR5cGVzKS5zb3J0KCk7XG4gICAgfVxuICAgIC8vIGZpbmQgYWxsIHR5cGUtc2NvcGVkIGNvbnRleHRzIGJhc2VkIG9uIGN1cnJlbnQgY29udGV4dCwgcHJpb3IgdG9cbiAgICAvLyB1cGRhdGluZyBpdFxuICAgIGNvbnN0IHR5cGVDb250ZXh0ID0gYWN0aXZlQ3R4O1xuICAgIGZvcihjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICBjb25zdCBjb21wYWN0ZWRUeXBlID0gYXBpLmNvbXBhY3RJcmkoXG4gICAgICAgIHthY3RpdmVDdHg6IHR5cGVDb250ZXh0LCBpcmk6IHR5cGUsIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX19KTtcblxuICAgICAgLy8gVXNlIGFueSB0eXBlLXNjb3BlZCBjb250ZXh0IGRlZmluZWQgb24gdGhpcyB2YWx1ZVxuICAgICAgY29uc3QgY3R4ID0gX2dldENvbnRleHRWYWx1ZShpbnB1dEN0eCwgY29tcGFjdGVkVHlwZSwgJ0Bjb250ZXh0Jyk7XG4gICAgICBpZighX2lzVW5kZWZpbmVkKGN0eCkpIHtcbiAgICAgICAgYWN0aXZlQ3R4ID0gYXdhaXQgX3Byb2Nlc3NDb250ZXh0KHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgbG9jYWxDdHg6IGN0eCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIHByb3BhZ2F0ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJvY2VzcyBlbGVtZW50IGtleXMgaW4gb3JkZXJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudCkuc29ydCgpO1xuICAgIGZvcihjb25zdCBleHBhbmRlZFByb3BlcnR5IG9mIGtleXMpIHtcbiAgICAgIGNvbnN0IGV4cGFuZGVkVmFsdWUgPSBlbGVtZW50W2V4cGFuZGVkUHJvcGVydHldO1xuXG4gICAgICAvLyBjb21wYWN0IEBpZFxuICAgICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BpZCcpIHtcbiAgICAgICAgbGV0IGNvbXBhY3RlZFZhbHVlID0gX2FzQXJyYXkoZXhwYW5kZWRWYWx1ZSkubWFwKFxuICAgICAgICAgIGV4cGFuZGVkSXJpID0+IGFwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICAgIGlyaTogZXhwYW5kZWRJcmksXG4gICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IGZhbHNlfSxcbiAgICAgICAgICAgIGJhc2U6IG9wdGlvbnMuYmFzZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgaWYoY29tcGFjdGVkVmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY29tcGFjdGVkVmFsdWUgPSBjb21wYWN0ZWRWYWx1ZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZSBrZXl3b3JkIGFsaWFzIGFuZCBhZGQgdmFsdWVcbiAgICAgICAgY29uc3QgYWxpYXMgPSBhcGkuY29tcGFjdElyaShcbiAgICAgICAgICB7YWN0aXZlQ3R4LCBpcmk6ICdAaWQnLCByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9fSk7XG5cbiAgICAgICAgcnZhbFthbGlhc10gPSBjb21wYWN0ZWRWYWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBhY3QgQHR5cGUocylcbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAdHlwZScpIHtcbiAgICAgICAgLy8gcmVzb2x2ZSB0eXBlIHZhbHVlcyBhZ2FpbnN0IHByZXZpb3VzIGNvbnRleHRcbiAgICAgICAgbGV0IGNvbXBhY3RlZFZhbHVlID0gX2FzQXJyYXkoZXhwYW5kZWRWYWx1ZSkubWFwKFxuICAgICAgICAgIGV4cGFuZGVkSXJpID0+IGFwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICAgIGFjdGl2ZUN0eDogaW5wdXRDdHgsXG4gICAgICAgICAgICBpcmk6IGV4cGFuZGVkSXJpLFxuICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgaWYoY29tcGFjdGVkVmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY29tcGFjdGVkVmFsdWUgPSBjb21wYWN0ZWRWYWx1ZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZSBrZXl3b3JkIGFsaWFzIGFuZCBhZGQgdmFsdWVcbiAgICAgICAgY29uc3QgYWxpYXMgPSBhcGkuY29tcGFjdElyaShcbiAgICAgICAgICB7YWN0aXZlQ3R4LCBpcmk6ICdAdHlwZScsIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX19KTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gX2dldENvbnRleHRWYWx1ZShcbiAgICAgICAgICBhY3RpdmVDdHgsIGFsaWFzLCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuXG4gICAgICAgIC8vIHRyZWF0IGFzIGFycmF5IGZvciBAdHlwZSBpZiBAY29udGFpbmVyIGluY2x1ZGVzIEBzZXRcbiAgICAgICAgY29uc3QgdHlwZUFzU2V0ID1cbiAgICAgICAgICBjb250YWluZXIuaW5jbHVkZXMoJ0BzZXQnKSAmJlxuICAgICAgICAgIF9wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSk7XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPVxuICAgICAgICAgIHR5cGVBc1NldCB8fCAoX2lzQXJyYXkoY29tcGFjdGVkVmFsdWUpICYmIGV4cGFuZGVkVmFsdWUubGVuZ3RoID09PSAwKTtcbiAgICAgICAgX2FkZFZhbHVlKHJ2YWwsIGFsaWFzLCBjb21wYWN0ZWRWYWx1ZSwge3Byb3BlcnR5SXNBcnJheTogaXNBcnJheX0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIEByZXZlcnNlXG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQHJldmVyc2UnKSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhY3QgZXhwYW5kZWQgdmFsdWVcbiAgICAgICAgY29uc3QgY29tcGFjdGVkVmFsdWUgPSBhd2FpdCBhcGkuY29tcGFjdCh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGFjdGl2ZVByb3BlcnR5OiAnQHJldmVyc2UnLFxuICAgICAgICAgIGVsZW1lbnQ6IGV4cGFuZGVkVmFsdWUsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBjb21wYWN0aW9uTWFwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBkb3VibGUtcmV2ZXJzZWQgcHJvcGVydGllc1xuICAgICAgICBmb3IoY29uc3QgY29tcGFjdGVkUHJvcGVydHkgaW4gY29tcGFjdGVkVmFsdWUpIHtcbiAgICAgICAgICBpZihhY3RpdmVDdHgubWFwcGluZ3MuaGFzKGNvbXBhY3RlZFByb3BlcnR5KSAmJlxuICAgICAgICAgICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldChjb21wYWN0ZWRQcm9wZXJ0eSkucmV2ZXJzZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb21wYWN0ZWRWYWx1ZVtjb21wYWN0ZWRQcm9wZXJ0eV07XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICAgICAgICBhY3RpdmVDdHgsIGNvbXBhY3RlZFByb3BlcnR5LCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuICAgICAgICAgICAgY29uc3QgdXNlQXJyYXkgPSAoXG4gICAgICAgICAgICAgIGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpIHx8ICFvcHRpb25zLmNvbXBhY3RBcnJheXMpO1xuICAgICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgICBydmFsLCBjb21wYWN0ZWRQcm9wZXJ0eSwgdmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IHVzZUFycmF5fSk7XG4gICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkVmFsdWVbY29tcGFjdGVkUHJvcGVydHldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKE9iamVjdC5rZXlzKGNvbXBhY3RlZFZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gdXNlIGtleXdvcmQgYWxpYXMgYW5kIGFkZCB2YWx1ZVxuICAgICAgICAgIGNvbnN0IGFsaWFzID0gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgaXJpOiBleHBhbmRlZFByb3BlcnR5LFxuICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF9hZGRWYWx1ZShydmFsLCBhbGlhcywgY29tcGFjdGVkVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAcHJlc2VydmUnKSB7XG4gICAgICAgIC8vIGNvbXBhY3QgdXNpbmcgYWN0aXZlUHJvcGVydHlcbiAgICAgICAgY29uc3QgY29tcGFjdGVkVmFsdWUgPSBhd2FpdCBhcGkuY29tcGFjdCh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICAgIGVsZW1lbnQ6IGV4cGFuZGVkVmFsdWUsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBjb21wYWN0aW9uTWFwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCEoX2lzQXJyYXkoY29tcGFjdGVkVmFsdWUpICYmIGNvbXBhY3RlZFZhbHVlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICBfYWRkVmFsdWUocnZhbCwgZXhwYW5kZWRQcm9wZXJ0eSwgY29tcGFjdGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgQGluZGV4IHByb3BlcnR5XG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGluZGV4Jykge1xuICAgICAgICAvLyBkcm9wIEBpbmRleCBpZiBpbnNpZGUgYW4gQGluZGV4IGNvbnRhaW5lclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICAgIGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAY29udGFpbmVyJykgfHwgW107XG4gICAgICAgIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGluZGV4JykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZSBrZXl3b3JkIGFsaWFzIGFuZCBhZGQgdmFsdWVcbiAgICAgICAgY29uc3QgYWxpYXMgPSBhcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGlyaTogZXhwYW5kZWRQcm9wZXJ0eSxcbiAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgIH0pO1xuICAgICAgICBfYWRkVmFsdWUocnZhbCwgYWxpYXMsIGV4cGFuZGVkVmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc2tpcCBhcnJheSBwcm9jZXNzaW5nIGZvciBrZXl3b3JkcyB0aGF0IGFyZW4ndFxuICAgICAgLy8gQGdyYXBoLCBAbGlzdCwgb3IgQGluY2x1ZGVkXG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ICE9PSAnQGdyYXBoJyAmJiBleHBhbmRlZFByb3BlcnR5ICE9PSAnQGxpc3QnICYmXG4gICAgICAgIGV4cGFuZGVkUHJvcGVydHkgIT09ICdAaW5jbHVkZWQnICYmXG4gICAgICAgIF9pc0tleXdvcmQoZXhwYW5kZWRQcm9wZXJ0eSkpIHtcbiAgICAgICAgLy8gdXNlIGtleXdvcmQgYWxpYXMgYW5kIGFkZCB2YWx1ZSBhcyBpc1xuICAgICAgICBjb25zdCBhbGlhcyA9IGFwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgaXJpOiBleHBhbmRlZFByb3BlcnR5LFxuICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgICAgfSk7XG4gICAgICAgIF9hZGRWYWx1ZShydmFsLCBhbGlhcywgZXhwYW5kZWRWYWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3RlOiBleHBhbmRlZCB2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IGR1ZSB0byBleHBhbnNpb24gYWxnb3JpdGhtLlxuICAgICAgaWYoIV9pc0FycmF5KGV4cGFuZGVkVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSlNPTi1MRCBleHBhbnNpb24gZXJyb3I7IGV4cGFuZGVkIHZhbHVlIG11c3QgYmUgYW4gYXJyYXkuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXNlcnZlIGVtcHR5IGFycmF5c1xuICAgICAgaWYoZXhwYW5kZWRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgaXRlbUFjdGl2ZVByb3BlcnR5ID0gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICBpcmk6IGV4cGFuZGVkUHJvcGVydHksXG4gICAgICAgICAgdmFsdWU6IGV4cGFuZGVkVmFsdWUsXG4gICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfSxcbiAgICAgICAgICByZXZlcnNlOiBpbnNpZGVSZXZlcnNlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBuZXN0UHJvcGVydHkgPSBhY3RpdmVDdHgubWFwcGluZ3MuaGFzKGl0ZW1BY3RpdmVQcm9wZXJ0eSkgP1xuICAgICAgICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQoaXRlbUFjdGl2ZVByb3BlcnR5KVsnQG5lc3QnXSA6IG51bGw7XG4gICAgICAgIGxldCBuZXN0UmVzdWx0ID0gcnZhbDtcbiAgICAgICAgaWYobmVzdFByb3BlcnR5KSB7XG4gICAgICAgICAgX2NoZWNrTmVzdFByb3BlcnR5KGFjdGl2ZUN0eCwgbmVzdFByb3BlcnR5LCBvcHRpb25zKTtcbiAgICAgICAgICBpZighX2lzT2JqZWN0KHJ2YWxbbmVzdFByb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIHJ2YWxbbmVzdFByb3BlcnR5XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXN0UmVzdWx0ID0gcnZhbFtuZXN0UHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgICBuZXN0UmVzdWx0LCBpdGVtQWN0aXZlUHJvcGVydHksIGV4cGFuZGVkVmFsdWUsIHtcbiAgICAgICAgICAgIHByb3BlcnR5SXNBcnJheTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZWN1c2l2ZWx5IHByb2Nlc3MgYXJyYXkgdmFsdWVzXG4gICAgICBmb3IoY29uc3QgZXhwYW5kZWRJdGVtIG9mIGV4cGFuZGVkVmFsdWUpIHtcbiAgICAgICAgLy8gY29tcGFjdCBwcm9wZXJ0eSBhbmQgZ2V0IGNvbnRhaW5lciB0eXBlXG4gICAgICAgIGNvbnN0IGl0ZW1BY3RpdmVQcm9wZXJ0eSA9IGFwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgaXJpOiBleHBhbmRlZFByb3BlcnR5LFxuICAgICAgICAgIHZhbHVlOiBleHBhbmRlZEl0ZW0sXG4gICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfSxcbiAgICAgICAgICByZXZlcnNlOiBpbnNpZGVSZXZlcnNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGl0ZW1BY3RpdmVQcm9wZXJ0eSBpcyBhIEBuZXN0IHByb3BlcnR5LCBhZGQgdmFsdWVzIHRvIG5lc3RSZXN1bHQsXG4gICAgICAgIC8vIG90aGVyd2lzZSBydmFsXG4gICAgICAgIGNvbnN0IG5lc3RQcm9wZXJ0eSA9IGFjdGl2ZUN0eC5tYXBwaW5ncy5oYXMoaXRlbUFjdGl2ZVByb3BlcnR5KSA/XG4gICAgICAgICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldChpdGVtQWN0aXZlUHJvcGVydHkpWydAbmVzdCddIDogbnVsbDtcbiAgICAgICAgbGV0IG5lc3RSZXN1bHQgPSBydmFsO1xuICAgICAgICBpZihuZXN0UHJvcGVydHkpIHtcbiAgICAgICAgICBfY2hlY2tOZXN0UHJvcGVydHkoYWN0aXZlQ3R4LCBuZXN0UHJvcGVydHksIG9wdGlvbnMpO1xuICAgICAgICAgIGlmKCFfaXNPYmplY3QocnZhbFtuZXN0UHJvcGVydHldKSkge1xuICAgICAgICAgICAgcnZhbFtuZXN0UHJvcGVydHldID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lc3RSZXN1bHQgPSBydmFsW25lc3RQcm9wZXJ0eV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICAgIGFjdGl2ZUN0eCwgaXRlbUFjdGl2ZVByb3BlcnR5LCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuXG4gICAgICAgIC8vIGdldCBzaW1wbGUgQGdyYXBoIG9yIEBsaXN0IHZhbHVlIGlmIGFwcHJvcHJpYXRlXG4gICAgICAgIGNvbnN0IGlzR3JhcGggPSBfaXNHcmFwaChleHBhbmRlZEl0ZW0pO1xuICAgICAgICBjb25zdCBpc0xpc3QgPSBfaXNMaXN0KGV4cGFuZGVkSXRlbSk7XG4gICAgICAgIGxldCBpbm5lcjtcbiAgICAgICAgaWYoaXNMaXN0KSB7XG4gICAgICAgICAgaW5uZXIgPSBleHBhbmRlZEl0ZW1bJ0BsaXN0J107XG4gICAgICAgIH0gZWxzZSBpZihpc0dyYXBoKSB7XG4gICAgICAgICAgaW5uZXIgPSBleHBhbmRlZEl0ZW1bJ0BncmFwaCddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgY29tcGFjdCBleHBhbmRlZCBpdGVtXG4gICAgICAgIGxldCBjb21wYWN0ZWRJdGVtID0gYXdhaXQgYXBpLmNvbXBhY3Qoe1xuICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICBhY3RpdmVQcm9wZXJ0eTogaXRlbUFjdGl2ZVByb3BlcnR5LFxuICAgICAgICAgIGVsZW1lbnQ6IChpc0xpc3QgfHwgaXNHcmFwaCkgPyBpbm5lciA6IGV4cGFuZGVkSXRlbSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGNvbXBhY3Rpb25NYXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaGFuZGxlIEBsaXN0XG4gICAgICAgIGlmKGlzTGlzdCkge1xuICAgICAgICAgIC8vIGVuc3VyZSBAbGlzdCB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgICAgIGlmKCFfaXNBcnJheShjb21wYWN0ZWRJdGVtKSkge1xuICAgICAgICAgICAgY29tcGFjdGVkSXRlbSA9IFtjb21wYWN0ZWRJdGVtXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZighY29udGFpbmVyLmluY2x1ZGVzKCdAbGlzdCcpKSB7XG4gICAgICAgICAgICAvLyB3cmFwIHVzaW5nIEBsaXN0IGFsaWFzXG4gICAgICAgICAgICBjb21wYWN0ZWRJdGVtID0ge1xuICAgICAgICAgICAgICBbYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICAgICAgICBpcmk6ICdAbGlzdCcsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgICAgICB9KV06IGNvbXBhY3RlZEl0ZW1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGluY2x1ZGUgQGluZGV4IGZyb20gZXhwYW5kZWQgQGxpc3QsIGlmIGFueVxuICAgICAgICAgICAgaWYoJ0BpbmRleCcgaW4gZXhwYW5kZWRJdGVtKSB7XG4gICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW1bYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICAgICAgICBpcmk6ICdAaW5kZXgnLFxuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgICAgICAgICAgfSldID0gZXhwYW5kZWRJdGVtWydAaW5kZXgnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2FkZFZhbHVlKG5lc3RSZXN1bHQsIGl0ZW1BY3RpdmVQcm9wZXJ0eSwgY29tcGFjdGVkSXRlbSwge1xuICAgICAgICAgICAgICB2YWx1ZUlzQXJyYXk6IHRydWUsXG4gICAgICAgICAgICAgIGFsbG93RHVwbGljYXRlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdyYXBoIG9iamVjdCBjb21wYWN0aW9uIGNhc2VzXG4gICAgICAgIGlmKGlzR3JhcGgpIHtcbiAgICAgICAgICBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BncmFwaCcpICYmIChjb250YWluZXIuaW5jbHVkZXMoJ0BpZCcpIHx8XG4gICAgICAgICAgICBjb250YWluZXIuaW5jbHVkZXMoJ0BpbmRleCcpICYmIF9pc1NpbXBsZUdyYXBoKGV4cGFuZGVkSXRlbSkpKSB7XG4gICAgICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHRoZSBtYXAgb2JqZWN0XG4gICAgICAgICAgICBsZXQgbWFwT2JqZWN0O1xuICAgICAgICAgICAgaWYobmVzdFJlc3VsdC5oYXNPd25Qcm9wZXJ0eShpdGVtQWN0aXZlUHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgIG1hcE9iamVjdCA9IG5lc3RSZXN1bHRbaXRlbUFjdGl2ZVByb3BlcnR5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lc3RSZXN1bHRbaXRlbUFjdGl2ZVByb3BlcnR5XSA9IG1hcE9iamVjdCA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmRleCBvbiBAaWQgb3IgQGluZGV4IG9yIGFsaWFzIG9mIEBub25lXG4gICAgICAgICAgICBjb25zdCBrZXkgPSAoY29udGFpbmVyLmluY2x1ZGVzKCdAaWQnKSA/XG4gICAgICAgICAgICAgIGV4cGFuZGVkSXRlbVsnQGlkJ10gOiBleHBhbmRlZEl0ZW1bJ0BpbmRleCddKSB8fFxuICAgICAgICAgICAgICBhcGkuY29tcGFjdElyaSh7YWN0aXZlQ3R4LCBpcmk6ICdAbm9uZScsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuICAgICAgICAgICAgLy8gYWRkIGNvbXBhY3RlZEl0ZW0gdG8gbWFwLCB1c2luZyB2YWx1ZSBvZiBgQGlkYCBvciBhIG5ldyBibGFua1xuICAgICAgICAgICAgLy8gbm9kZSBpZGVudGlmaWVyXG5cbiAgICAgICAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgICAgICAgbWFwT2JqZWN0LCBrZXksIGNvbXBhY3RlZEl0ZW0sIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUlzQXJyYXk6XG4gICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuY29tcGFjdEFycmF5cyB8fCBjb250YWluZXIuaW5jbHVkZXMoJ0BzZXQnKSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGdyYXBoJykgJiZcbiAgICAgICAgICAgIF9pc1NpbXBsZUdyYXBoKGV4cGFuZGVkSXRlbSkpIHtcbiAgICAgICAgICAgIC8vIGNvbnRhaW5lciBpbmNsdWRlcyBAZ3JhcGggYnV0IG5vdCBAaWQgb3IgQGluZGV4IGFuZCB2YWx1ZSBpcyBhXG4gICAgICAgICAgICAvLyBzaW1wbGUgZ3JhcGggb2JqZWN0IGFkZCBjb21wYWN0IHZhbHVlXG4gICAgICAgICAgICAvLyBpZiBjb21wYWN0ZWRJdGVtIGNvbnRhaW5zIG11bHRpcGxlIHZhbHVlcywgaXQgaXMgd3JhcHBlZCBpblxuICAgICAgICAgICAgLy8gYEBpbmNsdWRlZGBcbiAgICAgICAgICAgIGlmKF9pc0FycmF5KGNvbXBhY3RlZEl0ZW0pICYmIGNvbXBhY3RlZEl0ZW0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtID0geydAaW5jbHVkZWQnOiBjb21wYWN0ZWRJdGVtfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgICAgICAgbmVzdFJlc3VsdCwgaXRlbUFjdGl2ZVByb3BlcnR5LCBjb21wYWN0ZWRJdGVtLCB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlJc0FycmF5OlxuICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmNvbXBhY3RBcnJheXMgfHwgY29udGFpbmVyLmluY2x1ZGVzKCdAc2V0JykpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3cmFwIHVzaW5nIEBncmFwaCBhbGlhcywgcmVtb3ZlIGFycmF5IGlmIG9ubHkgb25lIGl0ZW0gYW5kXG4gICAgICAgICAgICAvLyBjb21wYWN0QXJyYXlzIG5vdCBzZXRcbiAgICAgICAgICAgIGlmKF9pc0FycmF5KGNvbXBhY3RlZEl0ZW0pICYmIGNvbXBhY3RlZEl0ZW0ubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tcGFjdEFycmF5cykge1xuICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtID0gY29tcGFjdGVkSXRlbVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW0gPSB7XG4gICAgICAgICAgICAgIFthcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICAgIGlyaTogJ0BncmFwaCcsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgICAgICB9KV06IGNvbXBhY3RlZEl0ZW1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGluY2x1ZGUgQGlkIGZyb20gZXhwYW5kZWQgZ3JhcGgsIGlmIGFueVxuICAgICAgICAgICAgaWYoJ0BpZCcgaW4gZXhwYW5kZWRJdGVtKSB7XG4gICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW1bYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICAgICAgICBpcmk6ICdAaWQnLFxuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgICAgICAgICAgfSldID0gZXhwYW5kZWRJdGVtWydAaWQnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5jbHVkZSBAaW5kZXggZnJvbSBleHBhbmRlZCBncmFwaCwgaWYgYW55XG4gICAgICAgICAgICBpZignQGluZGV4JyBpbiBleHBhbmRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbVthcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICAgIGlyaTogJ0BpbmRleCcsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgICAgICB9KV0gPSBleHBhbmRlZEl0ZW1bJ0BpbmRleCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgICBuZXN0UmVzdWx0LCBpdGVtQWN0aXZlUHJvcGVydHksIGNvbXBhY3RlZEl0ZW0sIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUlzQXJyYXk6XG4gICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuY29tcGFjdEFycmF5cyB8fCBjb250YWluZXIuaW5jbHVkZXMoJ0BzZXQnKSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAbGFuZ3VhZ2UnKSB8fFxuICAgICAgICAgIGNvbnRhaW5lci5pbmNsdWRlcygnQGluZGV4JykgfHwgY29udGFpbmVyLmluY2x1ZGVzKCdAaWQnKSB8fFxuICAgICAgICAgIGNvbnRhaW5lci5pbmNsdWRlcygnQHR5cGUnKSkge1xuICAgICAgICAgIC8vIGhhbmRsZSBsYW5ndWFnZSBhbmQgaW5kZXggbWFwc1xuICAgICAgICAgIC8vIGdldCBvciBjcmVhdGUgdGhlIG1hcCBvYmplY3RcbiAgICAgICAgICBsZXQgbWFwT2JqZWN0O1xuICAgICAgICAgIGlmKG5lc3RSZXN1bHQuaGFzT3duUHJvcGVydHkoaXRlbUFjdGl2ZVByb3BlcnR5KSkge1xuICAgICAgICAgICAgbWFwT2JqZWN0ID0gbmVzdFJlc3VsdFtpdGVtQWN0aXZlUHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXN0UmVzdWx0W2l0ZW1BY3RpdmVQcm9wZXJ0eV0gPSBtYXBPYmplY3QgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGxhbmd1YWdlJykpIHtcbiAgICAgICAgICAvLyBpZiBjb250YWluZXIgaXMgYSBsYW5ndWFnZSBtYXAsIHNpbXBsaWZ5IGNvbXBhY3RlZCB2YWx1ZSB0b1xuICAgICAgICAgIC8vIGEgc2ltcGxlIHN0cmluZ1xuICAgICAgICAgICAgaWYoX2lzVmFsdWUoY29tcGFjdGVkSXRlbSkpIHtcbiAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbSA9IGNvbXBhY3RlZEl0ZW1bJ0B2YWx1ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gZXhwYW5kZWRJdGVtWydAbGFuZ3VhZ2UnXTtcbiAgICAgICAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAaW5kZXgnKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhLZXkgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICAgICAgICBhY3RpdmVDdHgsIGl0ZW1BY3RpdmVQcm9wZXJ0eSwgJ0BpbmRleCcpIHx8ICdAaW5kZXgnO1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyS2V5ID0gYXBpLmNvbXBhY3RJcmkoXG4gICAgICAgICAgICAgIHthY3RpdmVDdHgsIGlyaTogaW5kZXhLZXksIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX19KTtcbiAgICAgICAgICAgIGlmKGluZGV4S2V5ID09PSAnQGluZGV4Jykge1xuICAgICAgICAgICAgICBrZXkgPSBleHBhbmRlZEl0ZW1bJ0BpbmRleCddO1xuICAgICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkSXRlbVtjb250YWluZXJLZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IG90aGVycztcbiAgICAgICAgICAgICAgW2tleSwgLi4ub3RoZXJzXSA9IF9hc0FycmF5KGNvbXBhY3RlZEl0ZW1baW5kZXhLZXldIHx8IFtdKTtcbiAgICAgICAgICAgICAgaWYoIV9pc1N0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2lsbCB1c2UgQG5vbmUgaWYgaXQgaXNuJ3QgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2gob3RoZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkSXRlbVtpbmRleEtleV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtW2luZGV4S2V5XSA9IG90aGVyc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtW2luZGV4S2V5XSA9IG90aGVycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGlkJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkS2V5ID0gYXBpLmNvbXBhY3RJcmkoe2FjdGl2ZUN0eCwgaXJpOiAnQGlkJyxcbiAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuICAgICAgICAgICAga2V5ID0gY29tcGFjdGVkSXRlbVtpZEtleV07XG4gICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkSXRlbVtpZEtleV07XG4gICAgICAgICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQHR5cGUnKSkge1xuICAgICAgICAgICAgY29uc3QgdHlwZUtleSA9IGFwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICBpcmk6ICdAdHlwZScsXG4gICAgICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHR5cGVzO1xuICAgICAgICAgICAgW2tleSwgLi4udHlwZXNdID0gX2FzQXJyYXkoY29tcGFjdGVkSXRlbVt0eXBlS2V5XSB8fCBbXSk7XG4gICAgICAgICAgICBzd2l0Y2godHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkSXRlbVt0eXBlS2V5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW1bdHlwZUtleV0gPSB0eXBlc1swXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtW3R5cGVLZXldID0gdHlwZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGNvbXBhY3RlZEl0ZW0gY29udGFpbnMgYSBzaW5nbGUgZW50cnlcbiAgICAgICAgICAgIC8vIHdob3NlIGtleSBtYXBzIHRvIEBpZCwgcmVjb21wYWN0IHdpdGhvdXQgQHR5cGVcbiAgICAgICAgICAgIGlmKE9iamVjdC5rZXlzKGNvbXBhY3RlZEl0ZW0pLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAnQGlkJyBpbiBleHBhbmRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbSA9IGF3YWl0IGFwaS5jb21wYWN0KHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgICAgICAgYWN0aXZlUHJvcGVydHk6IGl0ZW1BY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB7J0BpZCc6IGV4cGFuZGVkSXRlbVsnQGlkJ119LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29tcGFjdGlvbk1hcFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBjb21wYWN0aW5nIHRoaXMgdmFsdWUgd2hpY2ggaGFzIG5vIGtleSwgaW5kZXggb24gQG5vbmVcbiAgICAgICAgICBpZigha2V5KSB7XG4gICAgICAgICAgICBrZXkgPSBhcGkuY29tcGFjdElyaSh7YWN0aXZlQ3R4LCBpcmk6ICdAbm9uZScsXG4gICAgICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX19KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYWRkIGNvbXBhY3QgdmFsdWUgdG8gbWFwIG9iamVjdCB1c2luZyBrZXkgZnJvbSBleHBhbmRlZCB2YWx1ZVxuICAgICAgICAgIC8vIGJhc2VkIG9uIHRoZSBjb250YWluZXIgdHlwZVxuICAgICAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgICAgIG1hcE9iamVjdCwga2V5LCBjb21wYWN0ZWRJdGVtLCB7XG4gICAgICAgICAgICAgIHByb3BlcnR5SXNBcnJheTogY29udGFpbmVyLmluY2x1ZGVzKCdAc2V0JylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBhbiBhcnJheSBpZjogY29tcGFjdEFycmF5cyBmbGFnIGlzIGZhbHNlLFxuICAgICAgICAgIC8vIEBjb250YWluZXIgaXMgQHNldCBvciBAbGlzdCAsIHZhbHVlIGlzIGFuIGVtcHR5XG4gICAgICAgICAgLy8gYXJyYXksIG9yIGtleSBpcyBAZ3JhcGhcbiAgICAgICAgICBjb25zdCBpc0FycmF5ID0gKCFvcHRpb25zLmNvbXBhY3RBcnJheXMgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpIHx8IGNvbnRhaW5lci5pbmNsdWRlcygnQGxpc3QnKSB8fFxuICAgICAgICAgICAgKF9pc0FycmF5KGNvbXBhY3RlZEl0ZW0pICYmIGNvbXBhY3RlZEl0ZW0ubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BsaXN0JyB8fCBleHBhbmRlZFByb3BlcnR5ID09PSAnQGdyYXBoJyk7XG5cbiAgICAgICAgICAvLyBhZGQgY29tcGFjdCB2YWx1ZVxuICAgICAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgICAgIG5lc3RSZXN1bHQsIGl0ZW1BY3RpdmVQcm9wZXJ0eSwgY29tcGFjdGVkSXRlbSxcbiAgICAgICAgICAgIHtwcm9wZXJ0eUlzQXJyYXk6IGlzQXJyYXl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBydmFsO1xuICB9XG5cbiAgLy8gb25seSBwcmltaXRpdmVzIHJlbWFpbiB3aGljaCBhcmUgYWxyZWFkeSBjb21wYWN0XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyBhbiBJUkkgb3Iga2V5d29yZCBpbnRvIGEgdGVybSBvciBwcmVmaXggaWYgaXQgY2FuIGJlLiBJZiB0aGVcbiAqIElSSSBoYXMgYW4gYXNzb2NpYXRlZCB2YWx1ZSBpdCBtYXkgYmUgcGFzc2VkLlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGFjdGl2ZSBjb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSBpcmkgdGhlIElSSSB0byBjb21wYWN0LlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBjaGVjayBvciBudWxsLlxuICogQHBhcmFtIHJlbGF0aXZlVG8gb3B0aW9ucyBmb3IgaG93IHRvIGNvbXBhY3QgSVJJczpcbiAqICAgICAgICAgIHZvY2FiOiB0cnVlIHRvIHNwbGl0IGFmdGVyIEB2b2NhYiwgZmFsc2Ugbm90IHRvLlxuICogQHBhcmFtIHJldmVyc2UgdHJ1ZSBpZiBhIHJldmVyc2UgcHJvcGVydHkgaXMgYmVpbmcgY29tcGFjdGVkLCBmYWxzZSBpZiBub3QuXG4gKiBAcGFyYW0gYmFzZSB0aGUgYWJzb2x1dGUgVVJMIHRvIHVzZSBmb3IgY29tcGFjdGluZyBkb2N1bWVudC1yZWxhdGl2ZSBJUklzLlxuICpcbiAqIEByZXR1cm4gdGhlIGNvbXBhY3RlZCB0ZXJtLCBwcmVmaXgsIGtleXdvcmQgYWxpYXMsIG9yIHRoZSBvcmlnaW5hbCBJUkkuXG4gKi9cbmFwaS5jb21wYWN0SXJpID0gKHtcbiAgYWN0aXZlQ3R4LFxuICBpcmksXG4gIHZhbHVlID0gbnVsbCxcbiAgcmVsYXRpdmVUbyA9IHt2b2NhYjogZmFsc2V9LFxuICByZXZlcnNlID0gZmFsc2UsXG4gIGJhc2UgPSBudWxsXG59KSA9PiB7XG4gIC8vIGNhbid0IGNvbXBhY3QgbnVsbFxuICBpZihpcmkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gaXJpO1xuICB9XG5cbiAgLy8gaWYgY29udGV4dCBpcyBmcm9tIGEgcHJvcGVydHkgdGVybSBzY29wZWQgY29udGV4dCBjb21wb3NlZCB3aXRoIGFcbiAgLy8gdHlwZS1zY29wZWQgY29udGV4dCwgdGhlbiB1c2UgdGhlIHByZXZpb3VzIGNvbnRleHQgaW5zdGVhZFxuICBpZihhY3RpdmVDdHguaXNQcm9wZXJ0eVRlcm1TY29wZWQgJiYgYWN0aXZlQ3R4LnByZXZpb3VzQ29udGV4dCkge1xuICAgIGFjdGl2ZUN0eCA9IGFjdGl2ZUN0eC5wcmV2aW91c0NvbnRleHQ7XG4gIH1cblxuICBjb25zdCBpbnZlcnNlQ3R4ID0gYWN0aXZlQ3R4LmdldEludmVyc2UoKTtcblxuICAvLyBpZiB0ZXJtIGlzIGEga2V5d29yZCwgaXQgbWF5IGJlIGNvbXBhY3RlZCB0byBhIHNpbXBsZSBhbGlhc1xuICBpZihfaXNLZXl3b3JkKGlyaSkgJiZcbiAgICBpcmkgaW4gaW52ZXJzZUN0eCAmJlxuICAgICdAbm9uZScgaW4gaW52ZXJzZUN0eFtpcmldICYmXG4gICAgJ0B0eXBlJyBpbiBpbnZlcnNlQ3R4W2lyaV1bJ0Bub25lJ10gJiZcbiAgICAnQG5vbmUnIGluIGludmVyc2VDdHhbaXJpXVsnQG5vbmUnXVsnQHR5cGUnXSkge1xuICAgIHJldHVybiBpbnZlcnNlQ3R4W2lyaV1bJ0Bub25lJ11bJ0B0eXBlJ11bJ0Bub25lJ107XG4gIH1cblxuICAvLyB1c2UgaW52ZXJzZSBjb250ZXh0IHRvIHBpY2sgYSB0ZXJtIGlmIGlyaSBpcyByZWxhdGl2ZSB0byB2b2NhYlxuICBpZihyZWxhdGl2ZVRvLnZvY2FiICYmIGlyaSBpbiBpbnZlcnNlQ3R4KSB7XG4gICAgY29uc3QgZGVmYXVsdExhbmd1YWdlID0gYWN0aXZlQ3R4WydAbGFuZ3VhZ2UnXSB8fCAnQG5vbmUnO1xuXG4gICAgLy8gcHJlZmVyIEBpbmRleCBpZiBhdmFpbGFibGUgaW4gdmFsdWVcbiAgICBjb25zdCBjb250YWluZXJzID0gW107XG4gICAgaWYoX2lzT2JqZWN0KHZhbHVlKSAmJiAnQGluZGV4JyBpbiB2YWx1ZSAmJiAhKCdAZ3JhcGgnIGluIHZhbHVlKSkge1xuICAgICAgY29udGFpbmVycy5wdXNoKCdAaW5kZXgnLCAnQGluZGV4QHNldCcpO1xuICAgIH1cblxuICAgIC8vIGlmIHZhbHVlIGlzIGEgcHJlc2VydmUgb2JqZWN0LCB1c2UgaXRzIHZhbHVlXG4gICAgaWYoX2lzT2JqZWN0KHZhbHVlKSAmJiAnQHByZXNlcnZlJyBpbiB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVsnQHByZXNlcnZlJ11bMF07XG4gICAgfVxuXG4gICAgLy8gcHJlZmVyIG1vc3Qgc3BlY2lmaWMgY29udGFpbmVyIGluY2x1ZGluZyBAZ3JhcGgsIHByZWZlcmluZyBAc2V0XG4gICAgLy8gdmFyaWF0aW9uc1xuICAgIGlmKF9pc0dyYXBoKHZhbHVlKSkge1xuICAgICAgLy8gZmF2b3IgaW5kZXhtYXAgaWYgdGhlIGdyYXBoIGlzIGluZGV4ZWRcbiAgICAgIGlmKCdAaW5kZXgnIGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnRhaW5lcnMucHVzaChcbiAgICAgICAgICAnQGdyYXBoQGluZGV4JywgJ0BncmFwaEBpbmRleEBzZXQnLCAnQGluZGV4JywgJ0BpbmRleEBzZXQnKTtcbiAgICAgIH1cbiAgICAgIC8vIGZhdm9yIGlkbWFwIGlmIHRoZSBncmFwaCBpcyBoYXMgYW4gQGlkXG4gICAgICBpZignQGlkJyBpbiB2YWx1ZSkge1xuICAgICAgICBjb250YWluZXJzLnB1c2goXG4gICAgICAgICAgJ0BncmFwaEBpZCcsICdAZ3JhcGhAaWRAc2V0Jyk7XG4gICAgICB9XG4gICAgICBjb250YWluZXJzLnB1c2goJ0BncmFwaCcsICdAZ3JhcGhAc2V0JywgJ0BzZXQnKTtcbiAgICAgIC8vIGFsbG93IGluZGV4bWFwIGlmIHRoZSBncmFwaCBpcyBub3QgaW5kZXhlZFxuICAgICAgaWYoISgnQGluZGV4JyBpbiB2YWx1ZSkpIHtcbiAgICAgICAgY29udGFpbmVycy5wdXNoKFxuICAgICAgICAgICdAZ3JhcGhAaW5kZXgnLCAnQGdyYXBoQGluZGV4QHNldCcsICdAaW5kZXgnLCAnQGluZGV4QHNldCcpO1xuICAgICAgfVxuICAgICAgLy8gYWxsb3cgaWRtYXAgaWYgdGhlIGdyYXBoIGRvZXMgbm90IGhhdmUgYW4gQGlkXG4gICAgICBpZighKCdAaWQnIGluIHZhbHVlKSkge1xuICAgICAgICBjb250YWluZXJzLnB1c2goJ0BncmFwaEBpZCcsICdAZ3JhcGhAaWRAc2V0Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKF9pc09iamVjdCh2YWx1ZSkgJiYgIV9pc1ZhbHVlKHZhbHVlKSkge1xuICAgICAgY29udGFpbmVycy5wdXNoKCdAaWQnLCAnQGlkQHNldCcsICdAdHlwZScsICdAc2V0QHR5cGUnKTtcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0cyBmb3IgdGVybSBzZWxlY3Rpb24gYmFzZWQgb24gdHlwZS9sYW5ndWFnZVxuICAgIGxldCB0eXBlT3JMYW5ndWFnZSA9ICdAbGFuZ3VhZ2UnO1xuICAgIGxldCB0eXBlT3JMYW5ndWFnZVZhbHVlID0gJ0BudWxsJztcblxuICAgIGlmKHJldmVyc2UpIHtcbiAgICAgIHR5cGVPckxhbmd1YWdlID0gJ0B0eXBlJztcbiAgICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSAnQHJldmVyc2UnO1xuICAgICAgY29udGFpbmVycy5wdXNoKCdAc2V0Jyk7XG4gICAgfSBlbHNlIGlmKF9pc0xpc3QodmFsdWUpKSB7XG4gICAgICAvLyBjaG9vc2UgdGhlIG1vc3Qgc3BlY2lmaWMgdGVybSB0aGF0IHdvcmtzIGZvciBhbGwgZWxlbWVudHMgaW4gQGxpc3RcbiAgICAgIC8vIG9ubHkgc2VsZWN0IEBsaXN0IGNvbnRhaW5lcnMgaWYgQGluZGV4IGlzIE5PVCBpbiB2YWx1ZVxuICAgICAgaWYoISgnQGluZGV4JyBpbiB2YWx1ZSkpIHtcbiAgICAgICAgY29udGFpbmVycy5wdXNoKCdAbGlzdCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdCA9IHZhbHVlWydAbGlzdCddO1xuICAgICAgaWYobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gYW55IGVtcHR5IGxpc3QgY2FuIGJlIG1hdGNoZWQgYWdhaW5zdCBhbnkgdGVybSB0aGF0IHVzZXMgdGhlXG4gICAgICAgIC8vIEBsaXN0IGNvbnRhaW5lciByZWdhcmRsZXNzIG9mIEB0eXBlIG9yIEBsYW5ndWFnZVxuICAgICAgICB0eXBlT3JMYW5ndWFnZSA9ICdAYW55JztcbiAgICAgICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9ICdAbm9uZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY29tbW9uTGFuZ3VhZ2UgPSAobGlzdC5sZW5ndGggPT09IDApID8gZGVmYXVsdExhbmd1YWdlIDogbnVsbDtcbiAgICAgICAgbGV0IGNvbW1vblR5cGUgPSBudWxsO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgIGxldCBpdGVtTGFuZ3VhZ2UgPSAnQG5vbmUnO1xuICAgICAgICAgIGxldCBpdGVtVHlwZSA9ICdAbm9uZSc7XG4gICAgICAgICAgaWYoX2lzVmFsdWUoaXRlbSkpIHtcbiAgICAgICAgICAgIGlmKCdAZGlyZWN0aW9uJyBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhbmcgPSAoaXRlbVsnQGxhbmd1YWdlJ10gfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRpciA9IGl0ZW1bJ0BkaXJlY3Rpb24nXTtcbiAgICAgICAgICAgICAgaXRlbUxhbmd1YWdlID0gYCR7bGFuZ31fJHtkaXJ9YDtcbiAgICAgICAgICAgIH0gZWxzZSBpZignQGxhbmd1YWdlJyBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgIGl0ZW1MYW5ndWFnZSA9IGl0ZW1bJ0BsYW5ndWFnZSddLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoJ0B0eXBlJyBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgIGl0ZW1UeXBlID0gaXRlbVsnQHR5cGUnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHBsYWluIGxpdGVyYWxcbiAgICAgICAgICAgICAgaXRlbUxhbmd1YWdlID0gJ0BudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbVR5cGUgPSAnQGlkJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoY29tbW9uTGFuZ3VhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1vbkxhbmd1YWdlID0gaXRlbUxhbmd1YWdlO1xuICAgICAgICAgIH0gZWxzZSBpZihpdGVtTGFuZ3VhZ2UgIT09IGNvbW1vbkxhbmd1YWdlICYmIF9pc1ZhbHVlKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb21tb25MYW5ndWFnZSA9ICdAbm9uZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGNvbW1vblR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1vblR5cGUgPSBpdGVtVHlwZTtcbiAgICAgICAgICB9IGVsc2UgaWYoaXRlbVR5cGUgIT09IGNvbW1vblR5cGUpIHtcbiAgICAgICAgICAgIGNvbW1vblR5cGUgPSAnQG5vbmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB0aGVyZSBhcmUgZGlmZmVyZW50IGxhbmd1YWdlcyBhbmQgdHlwZXMgaW4gdGhlIGxpc3QsIHNvIGNob29zZVxuICAgICAgICAgIC8vIHRoZSBtb3N0IGdlbmVyaWMgdGVybSwgbm8gbmVlZCB0byBrZWVwIGl0ZXJhdGluZyB0aGUgbGlzdFxuICAgICAgICAgIGlmKGNvbW1vbkxhbmd1YWdlID09PSAnQG5vbmUnICYmIGNvbW1vblR5cGUgPT09ICdAbm9uZScpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb21tb25MYW5ndWFnZSA9IGNvbW1vbkxhbmd1YWdlIHx8ICdAbm9uZSc7XG4gICAgICAgIGNvbW1vblR5cGUgPSBjb21tb25UeXBlIHx8ICdAbm9uZSc7XG4gICAgICAgIGlmKGNvbW1vblR5cGUgIT09ICdAbm9uZScpIHtcbiAgICAgICAgICB0eXBlT3JMYW5ndWFnZSA9ICdAdHlwZSc7XG4gICAgICAgICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9IGNvbW1vblR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9IGNvbW1vbkxhbmd1YWdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKF9pc1ZhbHVlKHZhbHVlKSkge1xuICAgICAgICBpZignQGxhbmd1YWdlJyBpbiB2YWx1ZSAmJiAhKCdAaW5kZXgnIGluIHZhbHVlKSkge1xuICAgICAgICAgIGNvbnRhaW5lcnMucHVzaCgnQGxhbmd1YWdlJywgJ0BsYW5ndWFnZUBzZXQnKTtcbiAgICAgICAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gdmFsdWVbJ0BsYW5ndWFnZSddO1xuICAgICAgICAgIGNvbnN0IGRpciA9IHZhbHVlWydAZGlyZWN0aW9uJ107XG4gICAgICAgICAgaWYoZGlyKSB7XG4gICAgICAgICAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gYCR7dHlwZU9yTGFuZ3VhZ2VWYWx1ZX1fJHtkaXJ9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZignQGRpcmVjdGlvbicgaW4gdmFsdWUgJiYgISgnQGluZGV4JyBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gYF8ke3ZhbHVlWydAZGlyZWN0aW9uJ119YDtcbiAgICAgICAgfSBlbHNlIGlmKCdAdHlwZScgaW4gdmFsdWUpIHtcbiAgICAgICAgICB0eXBlT3JMYW5ndWFnZSA9ICdAdHlwZSc7XG4gICAgICAgICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9IHZhbHVlWydAdHlwZSddO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlT3JMYW5ndWFnZSA9ICdAdHlwZSc7XG4gICAgICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSAnQGlkJztcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lcnMucHVzaCgnQHNldCcpO1xuICAgIH1cblxuICAgIC8vIGRvIHRlcm0gc2VsZWN0aW9uXG4gICAgY29udGFpbmVycy5wdXNoKCdAbm9uZScpO1xuXG4gICAgLy8gYW4gaW5kZXggbWFwIGNhbiBiZSB1c2VkIHRvIGluZGV4IHZhbHVlcyB1c2luZyBAbm9uZSwgc28gYWRkIGFzIGEgbG93XG4gICAgLy8gcHJpb3JpdHlcbiAgICBpZihfaXNPYmplY3QodmFsdWUpICYmICEoJ0BpbmRleCcgaW4gdmFsdWUpKSB7XG4gICAgICAvLyBhbGxvdyBpbmRleGluZyBldmVuIGlmIG5vIEBpbmRleCBwcmVzZW50XG4gICAgICBjb250YWluZXJzLnB1c2goJ0BpbmRleCcsICdAaW5kZXhAc2V0Jyk7XG4gICAgfVxuXG4gICAgLy8gdmFsdWVzIHdpdGhvdXQgdHlwZSBvciBsYW5ndWFnZSBjYW4gdXNlIEBsYW5ndWFnZSBtYXBcbiAgICBpZihfaXNWYWx1ZSh2YWx1ZSkgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gYWxsb3cgaW5kZXhpbmcgZXZlbiBpZiBubyBAaW5kZXggcHJlc2VudFxuICAgICAgY29udGFpbmVycy5wdXNoKCdAbGFuZ3VhZ2UnLCAnQGxhbmd1YWdlQHNldCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHRlcm0gPSBfc2VsZWN0VGVybShcbiAgICAgIGFjdGl2ZUN0eCwgaXJpLCB2YWx1ZSwgY29udGFpbmVycywgdHlwZU9yTGFuZ3VhZ2UsIHR5cGVPckxhbmd1YWdlVmFsdWUpO1xuICAgIGlmKHRlcm0gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0ZXJtO1xuICAgIH1cbiAgfVxuXG4gIC8vIG5vIHRlcm0gbWF0Y2gsIHVzZSBAdm9jYWIgaWYgYXZhaWxhYmxlXG4gIGlmKHJlbGF0aXZlVG8udm9jYWIpIHtcbiAgICBpZignQHZvY2FiJyBpbiBhY3RpdmVDdHgpIHtcbiAgICAgIC8vIGRldGVybWluZSBpZiB2b2NhYiBpcyBhIHByZWZpeCBvZiB0aGUgaXJpXG4gICAgICBjb25zdCB2b2NhYiA9IGFjdGl2ZUN0eFsnQHZvY2FiJ107XG4gICAgICBpZihpcmkuaW5kZXhPZih2b2NhYikgPT09IDAgJiYgaXJpICE9PSB2b2NhYikge1xuICAgICAgICAvLyB1c2Ugc3VmZml4IGFzIHJlbGF0aXZlIGlyaSBpZiBpdCBpcyBub3QgYSB0ZXJtIGluIHRoZSBhY3RpdmUgY29udGV4dFxuICAgICAgICBjb25zdCBzdWZmaXggPSBpcmkuc3Vic3RyKHZvY2FiLmxlbmd0aCk7XG4gICAgICAgIGlmKCFhY3RpdmVDdHgubWFwcGluZ3MuaGFzKHN1ZmZpeCkpIHtcbiAgICAgICAgICByZXR1cm4gc3VmZml4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm8gdGVybSBvciBAdm9jYWIgbWF0Y2gsIGNoZWNrIGZvciBwb3NzaWJsZSBDVVJJRXNcbiAgbGV0IGNob2ljZSA9IG51bGw7XG4gIC8vIFRPRE86IG1ha2UgRmFzdEN1cmllTWFwIGEgY2xhc3Mgd2l0aCBhIG1ldGhvZCB0byBkbyB0aGlzIGxvb2t1cFxuICBjb25zdCBwYXJ0aWFsTWF0Y2hlcyA9IFtdO1xuICBsZXQgaXJpTWFwID0gYWN0aXZlQ3R4LmZhc3RDdXJpZU1hcDtcbiAgLy8gY2hlY2sgZm9yIHBhcnRpYWwgbWF0Y2hlcyBvZiBhZ2FpbnN0IGBpcmlgLCB3aGljaCBtZWFucyBsb29rIHVudGlsXG4gIC8vIGlyaS5sZW5ndGggLSAxLCBub3QgZnVsbCBsZW5ndGhcbiAgY29uc3QgbWF4UGFydGlhbExlbmd0aCA9IGlyaS5sZW5ndGggLSAxO1xuICBmb3IobGV0IGkgPSAwOyBpIDwgbWF4UGFydGlhbExlbmd0aCAmJiBpcmlbaV0gaW4gaXJpTWFwOyArK2kpIHtcbiAgICBpcmlNYXAgPSBpcmlNYXBbaXJpW2ldXTtcbiAgICBpZignJyBpbiBpcmlNYXApIHtcbiAgICAgIHBhcnRpYWxNYXRjaGVzLnB1c2goaXJpTWFwWycnXVswXSk7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIHBhcnRpYWwgbWF0Y2hlcyBpbiByZXZlcnNlIG9yZGVyIHRvIHByZWZlciBsb25nZXN0IG9uZXMgZmlyc3RcbiAgZm9yKGxldCBpID0gcGFydGlhbE1hdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBjb25zdCBlbnRyeSA9IHBhcnRpYWxNYXRjaGVzW2ldO1xuICAgIGNvbnN0IHRlcm1zID0gZW50cnkudGVybXM7XG4gICAgZm9yKGNvbnN0IHRlcm0gb2YgdGVybXMpIHtcbiAgICAgIC8vIGEgQ1VSSUUgaXMgdXNhYmxlIGlmOlxuICAgICAgLy8gMS4gaXQgaGFzIG5vIG1hcHBpbmcsIE9SXG4gICAgICAvLyAyLiB2YWx1ZSBpcyBudWxsLCB3aGljaCBtZWFucyB3ZSdyZSBub3QgY29tcGFjdGluZyBhbiBAdmFsdWUsIEFORFxuICAgICAgLy8gICB0aGUgbWFwcGluZyBtYXRjaGVzIHRoZSBJUklcbiAgICAgIGNvbnN0IGN1cmllID0gdGVybSArICc6JyArIGlyaS5zdWJzdHIoZW50cnkuaXJpLmxlbmd0aCk7XG4gICAgICBjb25zdCBpc1VzYWJsZUN1cmllID0gKGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQodGVybSkuX3ByZWZpeCAmJlxuICAgICAgICAoIWFjdGl2ZUN0eC5tYXBwaW5ncy5oYXMoY3VyaWUpIHx8XG4gICAgICAgICh2YWx1ZSA9PT0gbnVsbCAmJiBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KGN1cmllKVsnQGlkJ10gPT09IGlyaSkpKTtcblxuICAgICAgLy8gc2VsZWN0IGN1cmllIGlmIGl0IGlzIHNob3J0ZXIgb3IgdGhlIHNhbWUgbGVuZ3RoIGJ1dCBsZXhpY29ncmFwaGljYWxseVxuICAgICAgLy8gbGVzcyB0aGFuIHRoZSBjdXJyZW50IGNob2ljZVxuICAgICAgaWYoaXNVc2FibGVDdXJpZSAmJiAoY2hvaWNlID09PSBudWxsIHx8XG4gICAgICAgIF9jb21wYXJlU2hvcnRlc3RMZWFzdChjdXJpZSwgY2hvaWNlKSA8IDApKSB7XG4gICAgICAgIGNob2ljZSA9IGN1cmllO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJldHVybiBjaG9zZW4gY3VyaWVcbiAgaWYoY2hvaWNlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNob2ljZTtcbiAgfVxuXG4gIC8vIElmIGlyaSBjb3VsZCBiZSBjb25mdXNlZCB3aXRoIGEgY29tcGFjdCBJUkkgdXNpbmcgYSB0ZXJtIGluIHRoaXMgY29udGV4dCxcbiAgLy8gc2lnbmFsIGFuIGVycm9yXG4gIGZvcihjb25zdCBbdGVybSwgdGRdIG9mIGFjdGl2ZUN0eC5tYXBwaW5ncykge1xuICAgIGlmKHRkICYmIHRkLl9wcmVmaXggJiYgaXJpLnN0YXJ0c1dpdGgodGVybSArICc6JykpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgYEFic29sdXRlIElSSSBcIiR7aXJpfVwiIGNvbmZ1c2VkIHdpdGggcHJlZml4IFwiJHt0ZXJtfVwiLmAsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ0lSSSBjb25mdXNlZCB3aXRoIHByZWZpeCcsIGNvbnRleHQ6IGFjdGl2ZUN0eH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbXBhY3QgSVJJIHJlbGF0aXZlIHRvIGJhc2VcbiAgaWYoIXJlbGF0aXZlVG8udm9jYWIpIHtcbiAgICBpZignQGJhc2UnIGluIGFjdGl2ZUN0eCkge1xuICAgICAgaWYoIWFjdGl2ZUN0eFsnQGJhc2UnXSkge1xuICAgICAgICAvLyBUaGUgTm9uZSBjYXNlIHByZXNlcnZlcyBydmFsIGFzIHBvdGVudGlhbGx5IHJlbGF0aXZlXG4gICAgICAgIHJldHVybiBpcmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3JlbW92ZUJhc2UoX3ByZXBlbmRCYXNlKGJhc2UsIGFjdGl2ZUN0eFsnQGJhc2UnXSksIGlyaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlQmFzZShiYXNlLCBpcmkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJldHVybiBJUkkgYXMgaXNcbiAgcmV0dXJuIGlyaTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgdmFsdWUgY29tcGFjdGlvbiBvbiBhbiBvYmplY3Qgd2l0aCAnQHZhbHVlJyBvciAnQGlkJyBhcyB0aGUgb25seVxuICogcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0gYWN0aXZlUHJvcGVydHkgdGhlIGFjdGl2ZSBwcm9wZXJ0eSB0aGF0IHBvaW50cyB0byB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGNvbXBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcHJvY2Vzc2luZyBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIGNvbXBhY3Rpb24gcmVzdWx0LlxuICovXG5hcGkuY29tcGFjdFZhbHVlID0gKHthY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCB2YWx1ZSwgb3B0aW9uc30pID0+IHtcbiAgLy8gdmFsdWUgaXMgYSBAdmFsdWVcbiAgaWYoX2lzVmFsdWUodmFsdWUpKSB7XG4gICAgLy8gZ2V0IGNvbnRleHQgcnVsZXNcbiAgICBjb25zdCB0eXBlID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQHR5cGUnKTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0BsYW5ndWFnZScpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0BkaXJlY3Rpb24nKTtcbiAgICBjb25zdCBjb250YWluZXIgPVxuICAgICAgX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuXG4gICAgLy8gd2hldGhlciBvciBub3QgdGhlIHZhbHVlIGhhcyBhbiBAaW5kZXggdGhhdCBtdXN0IGJlIHByZXNlcnZlZFxuICAgIGNvbnN0IHByZXNlcnZlSW5kZXggPSAnQGluZGV4JyBpbiB2YWx1ZSAmJiAhY29udGFpbmVyLmluY2x1ZGVzKCdAaW5kZXgnKTtcblxuICAgIC8vIGlmIHRoZXJlJ3Mgbm8gQGluZGV4IHRvIHByZXNlcnZlIC4uLlxuICAgIGlmKCFwcmVzZXJ2ZUluZGV4ICYmIHR5cGUgIT09ICdAbm9uZScpIHtcbiAgICAgIC8vIG1hdGNoaW5nIEB0eXBlIG9yIEBsYW5ndWFnZSBzcGVjaWZpZWQgaW4gY29udGV4dCwgY29tcGFjdCB2YWx1ZVxuICAgICAgaWYodmFsdWVbJ0B0eXBlJ10gPT09IHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWydAdmFsdWUnXTtcbiAgICAgIH1cbiAgICAgIGlmKCdAbGFuZ3VhZ2UnIGluIHZhbHVlICYmIHZhbHVlWydAbGFuZ3VhZ2UnXSA9PT0gbGFuZ3VhZ2UgJiZcbiAgICAgICAgICdAZGlyZWN0aW9uJyBpbiB2YWx1ZSAmJiB2YWx1ZVsnQGRpcmVjdGlvbiddID09PSBkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWydAdmFsdWUnXTtcbiAgICAgIH1cbiAgICAgIGlmKCdAbGFuZ3VhZ2UnIGluIHZhbHVlICYmIHZhbHVlWydAbGFuZ3VhZ2UnXSA9PT0gbGFuZ3VhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWydAdmFsdWUnXTtcbiAgICAgIH1cbiAgICAgIGlmKCdAZGlyZWN0aW9uJyBpbiB2YWx1ZSAmJiB2YWx1ZVsnQGRpcmVjdGlvbiddID09PSBkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWydAdmFsdWUnXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4ganVzdCB0aGUgdmFsdWUgb2YgQHZhbHVlIGlmIGFsbCBhcmUgdHJ1ZTpcbiAgICAvLyAxLiBAdmFsdWUgaXMgdGhlIG9ubHkga2V5IG9yIEBpbmRleCBpc24ndCBiZWluZyBwcmVzZXJ2ZWRcbiAgICAvLyAyLiB0aGVyZSBpcyBubyBkZWZhdWx0IGxhbmd1YWdlIG9yIEB2YWx1ZSBpcyBub3QgYSBzdHJpbmcgb3JcbiAgICAvLyAgIHRoZSBrZXkgaGFzIGEgbWFwcGluZyB3aXRoIGEgbnVsbCBAbGFuZ3VhZ2VcbiAgICBjb25zdCBrZXlDb3VudCA9IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgY29uc3QgaXNWYWx1ZU9ubHlLZXkgPSAoa2V5Q291bnQgPT09IDEgfHxcbiAgICAgIChrZXlDb3VudCA9PT0gMiAmJiAnQGluZGV4JyBpbiB2YWx1ZSAmJiAhcHJlc2VydmVJbmRleCkpO1xuICAgIGNvbnN0IGhhc0RlZmF1bHRMYW5ndWFnZSA9ICgnQGxhbmd1YWdlJyBpbiBhY3RpdmVDdHgpO1xuICAgIGNvbnN0IGlzVmFsdWVTdHJpbmcgPSBfaXNTdHJpbmcodmFsdWVbJ0B2YWx1ZSddKTtcbiAgICBjb25zdCBoYXNOdWxsTWFwcGluZyA9IChhY3RpdmVDdHgubWFwcGluZ3MuaGFzKGFjdGl2ZVByb3BlcnR5KSAmJlxuICAgICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldChhY3RpdmVQcm9wZXJ0eSlbJ0BsYW5ndWFnZSddID09PSBudWxsKTtcbiAgICBpZihpc1ZhbHVlT25seUtleSAmJlxuICAgICAgdHlwZSAhPT0gJ0Bub25lJyAmJlxuICAgICAgKCFoYXNEZWZhdWx0TGFuZ3VhZ2UgfHwgIWlzVmFsdWVTdHJpbmcgfHwgaGFzTnVsbE1hcHBpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsdWVbJ0B2YWx1ZSddO1xuICAgIH1cblxuICAgIGNvbnN0IHJ2YWwgPSB7fTtcblxuICAgIC8vIHByZXNlcnZlIEBpbmRleFxuICAgIGlmKHByZXNlcnZlSW5kZXgpIHtcbiAgICAgIHJ2YWxbYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGlyaTogJ0BpbmRleCcsXG4gICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgIH0pXSA9IHZhbHVlWydAaW5kZXgnXTtcbiAgICB9XG5cbiAgICBpZignQHR5cGUnIGluIHZhbHVlKSB7XG4gICAgICAvLyBjb21wYWN0IEB0eXBlIElSSVxuICAgICAgcnZhbFthcGkuY29tcGFjdElyaSh7XG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgaXJpOiAnQHR5cGUnLFxuICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICB9KV0gPSBhcGkuY29tcGFjdElyaShcbiAgICAgICAge2FjdGl2ZUN0eCwgaXJpOiB2YWx1ZVsnQHR5cGUnXSwgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuICAgIH0gZWxzZSBpZignQGxhbmd1YWdlJyBpbiB2YWx1ZSkge1xuICAgICAgLy8gYWxpYXMgQGxhbmd1YWdlXG4gICAgICBydmFsW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBpcmk6ICdAbGFuZ3VhZ2UnLFxuICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICB9KV0gPSB2YWx1ZVsnQGxhbmd1YWdlJ107XG4gICAgfVxuXG4gICAgaWYoJ0BkaXJlY3Rpb24nIGluIHZhbHVlKSB7XG4gICAgICAvLyBhbGlhcyBAZGlyZWN0aW9uXG4gICAgICBydmFsW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBpcmk6ICdAZGlyZWN0aW9uJyxcbiAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgfSldID0gdmFsdWVbJ0BkaXJlY3Rpb24nXTtcbiAgICB9XG5cbiAgICAvLyBhbGlhcyBAdmFsdWVcbiAgICBydmFsW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgIGFjdGl2ZUN0eCxcbiAgICAgIGlyaTogJ0B2YWx1ZScsXG4gICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgfSldID0gdmFsdWVbJ0B2YWx1ZSddO1xuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cblxuICAvLyB2YWx1ZSBpcyBhIHN1YmplY3QgcmVmZXJlbmNlXG4gIGNvbnN0IGV4cGFuZGVkUHJvcGVydHkgPSBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHt2b2NhYjogdHJ1ZX0sXG4gICAgb3B0aW9ucyk7XG4gIGNvbnN0IHR5cGUgPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAdHlwZScpO1xuICBjb25zdCBjb21wYWN0ZWQgPSBhcGkuY29tcGFjdElyaSh7XG4gICAgYWN0aXZlQ3R4LFxuICAgIGlyaTogdmFsdWVbJ0BpZCddLFxuICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHlwZSA9PT0gJ0B2b2NhYid9LFxuICAgIGJhc2U6IG9wdGlvbnMuYmFzZX0pO1xuXG4gIC8vIGNvbXBhY3QgdG8gc2NhbGFyXG4gIGlmKHR5cGUgPT09ICdAaWQnIHx8IHR5cGUgPT09ICdAdm9jYWInIHx8IGV4cGFuZGVkUHJvcGVydHkgPT09ICdAZ3JhcGgnKSB7XG4gICAgcmV0dXJuIGNvbXBhY3RlZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgIGFjdGl2ZUN0eCxcbiAgICAgIGlyaTogJ0BpZCcsXG4gICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgfSldOiBjb21wYWN0ZWRcbiAgfTtcbn07XG5cbi8qKlxuICogUGlja3MgdGhlIHByZWZlcnJlZCBjb21wYWN0aW9uIHRlcm0gZnJvbSB0aGUgZ2l2ZW4gaW52ZXJzZSBjb250ZXh0IGVudHJ5LlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGFjdGl2ZSBjb250ZXh0LlxuICogQHBhcmFtIGlyaSB0aGUgSVJJIHRvIHBpY2sgdGhlIHRlcm0gZm9yLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBwaWNrIHRoZSB0ZXJtIGZvci5cbiAqIEBwYXJhbSBjb250YWluZXJzIHRoZSBwcmVmZXJyZWQgY29udGFpbmVycy5cbiAqIEBwYXJhbSB0eXBlT3JMYW5ndWFnZSBlaXRoZXIgJ0B0eXBlJyBvciAnQGxhbmd1YWdlJy5cbiAqIEBwYXJhbSB0eXBlT3JMYW5ndWFnZVZhbHVlIHRoZSBwcmVmZXJyZWQgdmFsdWUgZm9yICdAdHlwZScgb3IgJ0BsYW5ndWFnZScuXG4gKlxuICogQHJldHVybiB0aGUgcHJlZmVycmVkIHRlcm0uXG4gKi9cbmZ1bmN0aW9uIF9zZWxlY3RUZXJtKFxuICBhY3RpdmVDdHgsIGlyaSwgdmFsdWUsIGNvbnRhaW5lcnMsIHR5cGVPckxhbmd1YWdlLCB0eXBlT3JMYW5ndWFnZVZhbHVlKSB7XG4gIGlmKHR5cGVPckxhbmd1YWdlVmFsdWUgPT09IG51bGwpIHtcbiAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gJ0BudWxsJztcbiAgfVxuXG4gIC8vIHByZWZlcmVuY2VzIGZvciB0aGUgdmFsdWUgb2YgQHR5cGUgb3IgQGxhbmd1YWdlXG4gIGNvbnN0IHByZWZzID0gW107XG5cbiAgLy8gZGV0ZXJtaW5lIHByZWZzIGZvciBAaWQgYmFzZWQgb24gd2hldGhlciBvciBub3QgdmFsdWUgY29tcGFjdHMgdG8gYSB0ZXJtXG4gIGlmKCh0eXBlT3JMYW5ndWFnZVZhbHVlID09PSAnQGlkJyB8fCB0eXBlT3JMYW5ndWFnZVZhbHVlID09PSAnQHJldmVyc2UnKSAmJlxuICAgIF9pc09iamVjdCh2YWx1ZSkgJiYgJ0BpZCcgaW4gdmFsdWUpIHtcbiAgICAvLyBwcmVmZXIgQHJldmVyc2UgZmlyc3RcbiAgICBpZih0eXBlT3JMYW5ndWFnZVZhbHVlID09PSAnQHJldmVyc2UnKSB7XG4gICAgICBwcmVmcy5wdXNoKCdAcmV2ZXJzZScpO1xuICAgIH1cbiAgICAvLyB0cnkgdG8gY29tcGFjdCB2YWx1ZSB0byBhIHRlcm1cbiAgICBjb25zdCB0ZXJtID0gYXBpLmNvbXBhY3RJcmkoXG4gICAgICB7YWN0aXZlQ3R4LCBpcmk6IHZhbHVlWydAaWQnXSwgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuICAgIGlmKGFjdGl2ZUN0eC5tYXBwaW5ncy5oYXModGVybSkgJiZcbiAgICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQodGVybSkgJiZcbiAgICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQodGVybSlbJ0BpZCddID09PSB2YWx1ZVsnQGlkJ10pIHtcbiAgICAgIC8vIHByZWZlciBAdm9jYWJcbiAgICAgIHByZWZzLnB1c2guYXBwbHkocHJlZnMsIFsnQHZvY2FiJywgJ0BpZCddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJlZmVyIEBpZFxuICAgICAgcHJlZnMucHVzaC5hcHBseShwcmVmcywgWydAaWQnLCAnQHZvY2FiJ10pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcmVmcy5wdXNoKHR5cGVPckxhbmd1YWdlVmFsdWUpO1xuXG4gICAgLy8gY29uc2lkZXIgZGlyZWN0aW9uIG9ubHlcbiAgICBjb25zdCBsYW5nRGlyID0gcHJlZnMuZmluZChlbCA9PiBlbC5pbmNsdWRlcygnXycpKTtcbiAgICBpZihsYW5nRGlyKSB7XG4gICAgICAvLyBjb25zaWRlciBfZGlyIHBvcnRpb25cbiAgICAgIHByZWZzLnB1c2gobGFuZ0Rpci5yZXBsYWNlKC9eW15fXStfLywgJ18nKSk7XG4gICAgfVxuICB9XG4gIHByZWZzLnB1c2goJ0Bub25lJyk7XG5cbiAgY29uc3QgY29udGFpbmVyTWFwID0gYWN0aXZlQ3R4LmludmVyc2VbaXJpXTtcbiAgZm9yKGNvbnN0IGNvbnRhaW5lciBvZiBjb250YWluZXJzKSB7XG4gICAgLy8gaWYgY29udGFpbmVyIG5vdCBhdmFpbGFibGUgaW4gdGhlIG1hcCwgY29udGludWVcbiAgICBpZighKGNvbnRhaW5lciBpbiBjb250YWluZXJNYXApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlT3JMYW5ndWFnZVZhbHVlTWFwID0gY29udGFpbmVyTWFwW2NvbnRhaW5lcl1bdHlwZU9yTGFuZ3VhZ2VdO1xuICAgIGZvcihjb25zdCBwcmVmIG9mIHByZWZzKSB7XG4gICAgICAvLyBpZiB0eXBlL2xhbmd1YWdlIG9wdGlvbiBub3QgYXZhaWxhYmxlIGluIHRoZSBtYXAsIGNvbnRpbnVlXG4gICAgICBpZighKHByZWYgaW4gdHlwZU9yTGFuZ3VhZ2VWYWx1ZU1hcCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHNlbGVjdCB0ZXJtXG4gICAgICByZXR1cm4gdHlwZU9yTGFuZ3VhZ2VWYWx1ZU1hcFtwcmVmXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGUgdmFsdWUgb2YgYEBuZXN0YCBpbiB0aGUgdGVybSBkZWZpbml0aW9uIG11c3QgZWl0aGVyIGJlIGBAbmVzdGAsIG9yIGEgdGVybVxuICogd2hpY2ggcmVzb2x2ZXMgdG8gYEBuZXN0YC5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSBuZXN0UHJvcGVydHkgYSB0ZXJtIGluIHRoZSBhY3RpdmUgY29udGV4dCBvciBgQG5lc3RgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHByb2Nlc3Npbmcgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gX2NoZWNrTmVzdFByb3BlcnR5KGFjdGl2ZUN0eCwgbmVzdFByb3BlcnR5LCBvcHRpb25zKSB7XG4gIGlmKF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBuZXN0UHJvcGVydHksIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpICE9PSAnQG5lc3QnKSB7XG4gICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgJ0pTT04tTEQgY29tcGFjdCBlcnJvcjsgbmVzdGVkIHByb3BlcnR5IG11c3QgaGF2ZSBhbiBAbmVzdCB2YWx1ZSAnICtcbiAgICAgICdyZXNvbHZpbmcgdG8gQG5lc3QuJyxcbiAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQG5lc3QgdmFsdWUnfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSREYgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc7XG5jb25zdCBYU0QgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjJztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFRPRE86IERlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBsYXRlci4gVXNlIExJTktfSEVBREVSX0NPTlRFWFQuXG4gIExJTktfSEVBREVSX1JFTDogJ2h0dHA6Ly93d3cudzMub3JnL25zL2pzb24tbGQjY29udGV4dCcsXG5cbiAgTElOS19IRUFERVJfQ09OVEVYVDogJ2h0dHA6Ly93d3cudzMub3JnL25zL2pzb24tbGQjY29udGV4dCcsXG5cbiAgUkRGLFxuICBSREZfTElTVDogUkRGICsgJ0xpc3QnLFxuICBSREZfRklSU1Q6IFJERiArICdmaXJzdCcsXG4gIFJERl9SRVNUOiBSREYgKyAncmVzdCcsXG4gIFJERl9OSUw6IFJERiArICduaWwnLFxuICBSREZfVFlQRTogUkRGICsgJ3R5cGUnLFxuICBSREZfUExBSU5fTElURVJBTDogUkRGICsgJ1BsYWluTGl0ZXJhbCcsXG4gIFJERl9YTUxfTElURVJBTDogUkRGICsgJ1hNTExpdGVyYWwnLFxuICBSREZfSlNPTl9MSVRFUkFMOiBSREYgKyAnSlNPTicsXG4gIFJERl9PQkpFQ1Q6IFJERiArICdvYmplY3QnLFxuICBSREZfTEFOR1NUUklORzogUkRGICsgJ2xhbmdTdHJpbmcnLFxuXG4gIFhTRCxcbiAgWFNEX0JPT0xFQU46IFhTRCArICdib29sZWFuJyxcbiAgWFNEX0RPVUJMRTogWFNEICsgJ2RvdWJsZScsXG4gIFhTRF9JTlRFR0VSOiBYU0QgKyAnaW50ZWdlcicsXG4gIFhTRF9TVFJJTkc6IFhTRCArICdzdHJpbmcnLFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOSBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IEpzb25MZEVycm9yID0gcmVxdWlyZSgnLi9Kc29uTGRFcnJvcicpO1xuXG5jb25zdCB7XG4gIGlzQXJyYXk6IF9pc0FycmF5LFxuICBpc09iamVjdDogX2lzT2JqZWN0LFxuICBpc1N0cmluZzogX2lzU3RyaW5nLFxuICBpc1VuZGVmaW5lZDogX2lzVW5kZWZpbmVkXG59ID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5jb25zdCB7XG4gIGlzQWJzb2x1dGU6IF9pc0Fic29sdXRlSXJpLFxuICBpc1JlbGF0aXZlOiBfaXNSZWxhdGl2ZUlyaSxcbiAgcHJlcGVuZEJhc2UsXG4gIHBhcnNlOiBwYXJzZVVybFxufSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbmNvbnN0IHtcbiAgYXNBcnJheTogX2FzQXJyYXksXG4gIGNvbXBhcmVTaG9ydGVzdExlYXN0OiBfY29tcGFyZVNob3J0ZXN0TGVhc3Rcbn0gPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuY29uc3QgSU5JVElBTF9DT05URVhUX0NBQ0hFID0gbmV3IE1hcCgpO1xuY29uc3QgSU5JVElBTF9DT05URVhUX0NBQ0hFX01BWF9TSVpFID0gMTAwMDA7XG5jb25zdCBLRVlXT1JEX1BBVFRFUk4gPSAvXkBbYS16QS1aXSskLztcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgYSBsb2NhbCBjb250ZXh0IGFuZCByZXR1cm5zIGEgbmV3IGFjdGl2ZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGN1cnJlbnQgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0gbG9jYWxDdHggdGhlIGxvY2FsIGNvbnRleHQgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBjb250ZXh0IHByb2Nlc3Npbmcgb3B0aW9ucy5cbiAqIEBwYXJhbSBwcm9wYWdhdGUgYHRydWVgIGlmIGBmYWxzZWAsIHJldGFpbnMgYW55IHByZXZpb3VzbHkgZGVmaW5lZCB0ZXJtLFxuICogICB3aGljaCBjYW4gYmUgcm9sbGVkIGJhY2sgd2hlbiB0aGUgZGVzY2VuZGluZyBpbnRvIGEgbmV3IG5vZGUgb2JqZWN0LlxuICogQHBhcmFtIG92ZXJyaWRlUHJvdGVjdGVkIGBmYWxzZWAgYWxsb3dzIHByb3RlY3RlZCB0ZXJtcyB0byBiZSBtb2RpZmllZC5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgYWN0aXZlIGNvbnRleHQuXG4gKi9cbmFwaS5wcm9jZXNzID0gYXN5bmMgKHtcbiAgYWN0aXZlQ3R4LCBsb2NhbEN0eCwgb3B0aW9ucyxcbiAgcHJvcGFnYXRlID0gdHJ1ZSxcbiAgb3ZlcnJpZGVQcm90ZWN0ZWQgPSBmYWxzZSxcbiAgY3ljbGVzID0gbmV3IFNldCgpXG59KSA9PiB7XG4gIC8vIG5vcm1hbGl6ZSBsb2NhbCBjb250ZXh0IHRvIGFuIGFycmF5IG9mIEBjb250ZXh0IG9iamVjdHNcbiAgaWYoX2lzT2JqZWN0KGxvY2FsQ3R4KSAmJiAnQGNvbnRleHQnIGluIGxvY2FsQ3R4ICYmXG4gICAgX2lzQXJyYXkobG9jYWxDdHhbJ0Bjb250ZXh0J10pKSB7XG4gICAgbG9jYWxDdHggPSBsb2NhbEN0eFsnQGNvbnRleHQnXTtcbiAgfVxuICBjb25zdCBjdHhzID0gX2FzQXJyYXkobG9jYWxDdHgpO1xuXG4gIC8vIG5vIGNvbnRleHRzIGluIGFycmF5LCByZXR1cm4gY3VycmVudCBhY3RpdmUgY29udGV4dCB3L28gY2hhbmdlc1xuICBpZihjdHhzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBhY3RpdmVDdHg7XG4gIH1cblxuICAvLyByZXNvbHZlIGNvbnRleHRzXG4gIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgb3B0aW9ucy5jb250ZXh0UmVzb2x2ZXIucmVzb2x2ZSh7XG4gICAgYWN0aXZlQ3R4LFxuICAgIGNvbnRleHQ6IGxvY2FsQ3R4LFxuICAgIGRvY3VtZW50TG9hZGVyOiBvcHRpb25zLmRvY3VtZW50TG9hZGVyLFxuICAgIGJhc2U6IG9wdGlvbnMuYmFzZVxuICB9KTtcblxuICAvLyBvdmVycmlkZSBwcm9wYWdhdGUgaWYgZmlyc3QgcmVzb2x2ZWQgY29udGV4dCBoYXMgYEBwcm9wYWdhdGVgXG4gIGlmKF9pc09iamVjdChyZXNvbHZlZFswXS5kb2N1bWVudCkgJiZcbiAgICB0eXBlb2YgcmVzb2x2ZWRbMF0uZG9jdW1lbnRbJ0Bwcm9wYWdhdGUnXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gcmV0cmlldmUgZWFybHksIGVycm9yIGNoZWNraW5nIGRvbmUgbGF0ZXJcbiAgICBwcm9wYWdhdGUgPSByZXNvbHZlZFswXS5kb2N1bWVudFsnQHByb3BhZ2F0ZSddO1xuICB9XG5cbiAgLy8gcHJvY2VzcyBlYWNoIGNvbnRleHQgaW4gb3JkZXIsIHVwZGF0ZSBhY3RpdmUgY29udGV4dFxuICAvLyBvbiBlYWNoIGl0ZXJhdGlvbiB0byBlbnN1cmUgcHJvcGVyIGNhY2hpbmdcbiAgbGV0IHJ2YWwgPSBhY3RpdmVDdHg7XG5cbiAgLy8gdHJhY2sgdGhlIHByZXZpb3VzIGNvbnRleHRcbiAgLy8gaWYgbm90IHByb3BhZ2F0aW5nLCBtYWtlIHN1cmUgcnZhbCBoYXMgYSBwcmV2aW91cyBjb250ZXh0XG4gIGlmKCFwcm9wYWdhdGUgJiYgIXJ2YWwucHJldmlvdXNDb250ZXh0KSB7XG4gICAgLy8gY2xvbmUgYHJ2YWxgIGNvbnRleHQgYmVmb3JlIHVwZGF0aW5nXG4gICAgcnZhbCA9IHJ2YWwuY2xvbmUoKTtcbiAgICBydmFsLnByZXZpb3VzQ29udGV4dCA9IGFjdGl2ZUN0eDtcbiAgfVxuXG4gIGZvcihjb25zdCByZXNvbHZlZENvbnRleHQgb2YgcmVzb2x2ZWQpIHtcbiAgICBsZXQge2RvY3VtZW50OiBjdHh9ID0gcmVzb2x2ZWRDb250ZXh0O1xuXG4gICAgLy8gdXBkYXRlIGFjdGl2ZSBjb250ZXh0IHRvIG9uZSBjb21wdXRlZCBmcm9tIGxhc3QgaXRlcmF0aW9uXG4gICAgYWN0aXZlQ3R4ID0gcnZhbDtcblxuICAgIC8vIHJlc2V0IHRvIGluaXRpYWwgY29udGV4dFxuICAgIGlmKGN0eCA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UgY2FuJ3QgbnVsbGlmeSBpZiB0aGVyZSBhcmUgcHJvdGVjdGVkIHRlcm1zIGFuZCB3ZSdyZVxuICAgICAgLy8gbm90IGFsbG93aW5nIG92ZXJyaWRlcyAoZS5nLiBwcm9jZXNzaW5nIGEgcHJvcGVydHkgdGVybSBzY29wZWQgY29udGV4dClcbiAgICAgIGlmKCFvdmVycmlkZVByb3RlY3RlZCAmJlxuICAgICAgICBPYmplY3Qua2V5cyhhY3RpdmVDdHgucHJvdGVjdGVkKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgcHJvdGVjdGVkTW9kZSA9IChvcHRpb25zICYmIG9wdGlvbnMucHJvdGVjdGVkTW9kZSkgfHwgJ2Vycm9yJztcbiAgICAgICAgaWYocHJvdGVjdGVkTW9kZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICdUcmllZCB0byBudWxsaWZ5IGEgY29udGV4dCB3aXRoIHByb3RlY3RlZCB0ZXJtcyBvdXRzaWRlIG9mICcgK1xuICAgICAgICAgICAgJ2EgdGVybSBkZWZpbml0aW9uLicsXG4gICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBjb250ZXh0IG51bGxpZmljYXRpb24nfSk7XG4gICAgICAgIH0gZWxzZSBpZihwcm90ZWN0ZWRNb2RlID09PSAnd2FybicpIHtcbiAgICAgICAgICAvLyBGSVhNRTogcmVtb3ZlIGxvZ2dpbmcgYW5kIHVzZSBhIGhhbmRsZXJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGludmFsaWQgY29udGV4dCBudWxsaWZpY2F0aW9uJyk7XG5cbiAgICAgICAgICAvLyBnZXQgcHJvY2Vzc2VkIGNvbnRleHQgZnJvbSBjYWNoZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSByZXNvbHZlZENvbnRleHQuZ2V0UHJvY2Vzc2VkKGFjdGl2ZUN0eCk7XG4gICAgICAgICAgaWYocHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBydmFsID0gYWN0aXZlQ3R4ID0gcHJvY2Vzc2VkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgb2xkQWN0aXZlQ3R4ID0gYWN0aXZlQ3R4O1xuICAgICAgICAgIC8vIGNvcHkgYWxsIHByb3RlY3RlZCB0ZXJtIGRlZmluaXRpb25zIHRvIGZyZXNoIGluaXRpYWwgY29udGV4dFxuICAgICAgICAgIHJ2YWwgPSBhY3RpdmVDdHggPSBhcGkuZ2V0SW5pdGlhbENvbnRleHQob3B0aW9ucykuY2xvbmUoKTtcbiAgICAgICAgICBmb3IoY29uc3QgW3Rlcm0sIF9wcm90ZWN0ZWRdIG9mXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhvbGRBY3RpdmVDdHgucHJvdGVjdGVkKSkge1xuICAgICAgICAgICAgaWYoX3Byb3RlY3RlZCkge1xuICAgICAgICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3NbdGVybV0gPVxuICAgICAgICAgICAgICAgIHV0aWwuY2xvbmUob2xkQWN0aXZlQ3R4Lm1hcHBpbmdzW3Rlcm1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlQ3R4LnByb3RlY3RlZCA9IHV0aWwuY2xvbmUob2xkQWN0aXZlQ3R4LnByb3RlY3RlZCk7XG5cbiAgICAgICAgICAvLyBjYWNoZSBwcm9jZXNzZWQgcmVzdWx0XG4gICAgICAgICAgcmVzb2x2ZWRDb250ZXh0LnNldFByb2Nlc3NlZChvbGRBY3RpdmVDdHgsIHJ2YWwpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBwcm90ZWN0ZWRNb2RlLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIHByb3RlY3RlZCBtb2RlJywgY29udGV4dDogbG9jYWxDdHgsIHByb3RlY3RlZE1vZGV9KTtcbiAgICAgIH1cbiAgICAgIHJ2YWwgPSBhY3RpdmVDdHggPSBhcGkuZ2V0SW5pdGlhbENvbnRleHQob3B0aW9ucykuY2xvbmUoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGdldCBwcm9jZXNzZWQgY29udGV4dCBmcm9tIGNhY2hlIGlmIGF2YWlsYWJsZVxuICAgIGNvbnN0IHByb2Nlc3NlZCA9IHJlc29sdmVkQ29udGV4dC5nZXRQcm9jZXNzZWQoYWN0aXZlQ3R4KTtcbiAgICBpZihwcm9jZXNzZWQpIHtcbiAgICAgIHJ2YWwgPSBhY3RpdmVDdHggPSBwcm9jZXNzZWQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZXJlZmVyZW5jZSBAY29udGV4dCBrZXkgaWYgcHJlc2VudFxuICAgIGlmKF9pc09iamVjdChjdHgpICYmICdAY29udGV4dCcgaW4gY3R4KSB7XG4gICAgICBjdHggPSBjdHhbJ0Bjb250ZXh0J107XG4gICAgfVxuXG4gICAgLy8gY29udGV4dCBtdXN0IGJlIGFuIG9iamVjdCBieSBub3csIGFsbCBVUkxzIHJldHJpZXZlZCBiZWZvcmUgdGhpcyBjYWxsXG4gICAgaWYoIV9pc09iamVjdChjdHgpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBtdXN0IGJlIGFuIG9iamVjdC4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIGxvY2FsIGNvbnRleHQnLCBjb250ZXh0OiBjdHh9KTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGVyZSBpcyBsaWtlbHkgYSBgcHJldmlvdXNDb250ZXh0YCBjbG9uaW5nIG9wdGltaXphdGlvbiB0aGF0XG4gICAgLy8gY291bGQgYmUgYXBwbGllZCBoZXJlIChubyBuZWVkIHRvIGNvcHkgaXQgdW5kZXIgY2VydGFpbiBjb25kaXRpb25zKVxuXG4gICAgLy8gY2xvbmUgY29udGV4dCBiZWZvcmUgdXBkYXRpbmcgaXRcbiAgICBydmFsID0gcnZhbC5jbG9uZSgpO1xuXG4gICAgLy8gZGVmaW5lIGNvbnRleHQgbWFwcGluZ3MgZm9yIGtleXMgaW4gbG9jYWwgY29udGV4dFxuICAgIGNvbnN0IGRlZmluZWQgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBoYW5kbGUgQHZlcnNpb25cbiAgICBpZignQHZlcnNpb24nIGluIGN0eCkge1xuICAgICAgaWYoY3R4WydAdmVyc2lvbiddICE9PSAxLjEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdVbnN1cHBvcnRlZCBKU09OLUxEIHZlcnNpb246ICcgKyBjdHhbJ0B2ZXJzaW9uJ10sXG4gICAgICAgICAgJ2pzb25sZC5VbnN1cHBvcnRlZFZlcnNpb24nLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBAdmVyc2lvbiB2YWx1ZScsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfVxuICAgICAgaWYoYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlICYmXG4gICAgICAgIGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSA9PT0gJ2pzb24tbGQtMS4wJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0B2ZXJzaW9uOiAnICsgY3R4WydAdmVyc2lvbiddICsgJyBub3QgY29tcGF0aWJsZSB3aXRoICcgK1xuICAgICAgICAgIGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSxcbiAgICAgICAgICAnanNvbmxkLlByb2Nlc3NpbmdNb2RlQ29uZmxpY3QnLFxuICAgICAgICAgIHtjb2RlOiAncHJvY2Vzc2luZyBtb2RlIGNvbmZsaWN0JywgY29udGV4dDogY3R4fSk7XG4gICAgICB9XG4gICAgICBydmFsLnByb2Nlc3NpbmdNb2RlID0gJ2pzb24tbGQtMS4xJztcbiAgICAgIHJ2YWxbJ0B2ZXJzaW9uJ10gPSBjdHhbJ0B2ZXJzaW9uJ107XG4gICAgICBkZWZpbmVkLnNldCgnQHZlcnNpb24nLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBpZiBub3Qgc2V0IGV4cGxpY2l0bHksIHNldCBwcm9jZXNzaW5nTW9kZSB0byBcImpzb24tbGQtMS4xXCJcbiAgICBydmFsLnByb2Nlc3NpbmdNb2RlID1cbiAgICAgIHJ2YWwucHJvY2Vzc2luZ01vZGUgfHwgYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlO1xuXG4gICAgLy8gaGFuZGxlIEBiYXNlXG4gICAgaWYoJ0BiYXNlJyBpbiBjdHgpIHtcbiAgICAgIGxldCBiYXNlID0gY3R4WydAYmFzZSddO1xuXG4gICAgICBpZihiYXNlID09PSBudWxsIHx8IF9pc0Fic29sdXRlSXJpKGJhc2UpKSB7XG4gICAgICAgIC8vIG5vIGFjdGlvblxuICAgICAgfSBlbHNlIGlmKF9pc1JlbGF0aXZlSXJpKGJhc2UpKSB7XG4gICAgICAgIGJhc2UgPSBwcmVwZW5kQmFzZShydmFsWydAYmFzZSddLCBiYXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgdGhlIHZhbHVlIG9mIFwiQGJhc2VcIiBpbiBhICcgK1xuICAgICAgICAgICdAY29udGV4dCBtdXN0IGJlIGFuIGFic29sdXRlIElSSSwgYSByZWxhdGl2ZSBJUkksIG9yIG51bGwuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIGJhc2UgSVJJJywgY29udGV4dDogY3R4fSk7XG4gICAgICB9XG5cbiAgICAgIHJ2YWxbJ0BiYXNlJ10gPSBiYXNlO1xuICAgICAgZGVmaW5lZC5zZXQoJ0BiYXNlJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIEB2b2NhYlxuICAgIGlmKCdAdm9jYWInIGluIGN0eCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjdHhbJ0B2b2NhYiddO1xuICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHJ2YWxbJ0B2b2NhYiddO1xuICAgICAgfSBlbHNlIGlmKCFfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgdGhlIHZhbHVlIG9mIFwiQHZvY2FiXCIgaW4gYSAnICtcbiAgICAgICAgICAnQGNvbnRleHQgbXVzdCBiZSBhIHN0cmluZyBvciBudWxsLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCB2b2NhYiBtYXBwaW5nJywgY29udGV4dDogY3R4fSk7XG4gICAgICB9IGVsc2UgaWYoIV9pc0Fic29sdXRlSXJpKHZhbHVlKSAmJiBhcGkucHJvY2Vzc2luZ01vZGUocnZhbCwgMS4wKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IHRoZSB2YWx1ZSBvZiBcIkB2b2NhYlwiIGluIGEgJyArXG4gICAgICAgICAgJ0Bjb250ZXh0IG11c3QgYmUgYW4gYWJzb2x1dGUgSVJJLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCB2b2NhYiBtYXBwaW5nJywgY29udGV4dDogY3R4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsWydAdm9jYWInXSA9IF9leHBhbmRJcmkocnZhbCwgdmFsdWUsIHt2b2NhYjogdHJ1ZSwgYmFzZTogdHJ1ZX0sXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZGVmaW5lZC5zZXQoJ0B2b2NhYicsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBAbGFuZ3VhZ2VcbiAgICBpZignQGxhbmd1YWdlJyBpbiBjdHgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3R4WydAbGFuZ3VhZ2UnXTtcbiAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBydmFsWydAbGFuZ3VhZ2UnXTtcbiAgICAgIH0gZWxzZSBpZighX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IHRoZSB2YWx1ZSBvZiBcIkBsYW5ndWFnZVwiIGluIGEgJyArXG4gICAgICAgICAgJ0Bjb250ZXh0IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBkZWZhdWx0IGxhbmd1YWdlJywgY29udGV4dDogY3R4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsWydAbGFuZ3VhZ2UnXSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBkZWZpbmVkLnNldCgnQGxhbmd1YWdlJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIEBkaXJlY3Rpb25cbiAgICBpZignQGRpcmVjdGlvbicgaW4gY3R4KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN0eFsnQGRpcmVjdGlvbiddO1xuICAgICAgaWYoYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlID09PSAnanNvbi1sZC0xLjAnKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGRpcmVjdGlvbiBub3QgY29tcGF0aWJsZSB3aXRoICcgK1xuICAgICAgICAgIGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgY29udGV4dCBtZW1iZXInLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH1cbiAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBydmFsWydAZGlyZWN0aW9uJ107XG4gICAgICB9IGVsc2UgaWYodmFsdWUgIT09ICdsdHInICYmIHZhbHVlICE9PSAncnRsJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IHRoZSB2YWx1ZSBvZiBcIkBkaXJlY3Rpb25cIiBpbiBhICcgK1xuICAgICAgICAgICdAY29udGV4dCBtdXN0IGJlIG51bGwsIFwibHRyXCIsIG9yIFwicnRsXCIuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgYmFzZSBkaXJlY3Rpb24nLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWxbJ0BkaXJlY3Rpb24nXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgZGVmaW5lZC5zZXQoJ0BkaXJlY3Rpb24nLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgQHByb3BhZ2F0ZVxuICAgIC8vIG5vdGU6IHdlJ3ZlIGFscmVhZHkgZXh0cmFjdGVkIGl0LCBoZXJlIHdlIGp1c3QgZG8gZXJyb3IgY2hlY2tpbmdcbiAgICBpZignQHByb3BhZ2F0ZScgaW4gY3R4KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN0eFsnQHByb3BhZ2F0ZSddO1xuICAgICAgaWYoYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlID09PSAnanNvbi1sZC0xLjAnKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQHByb3BhZ2F0ZSBub3QgY29tcGF0aWJsZSB3aXRoICcgK1xuICAgICAgICAgIGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgY29udGV4dCBlbnRyeScsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfVxuICAgICAgaWYodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAcHJvcGFnYXRlIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIEBwcm9wYWdhdGUgdmFsdWUnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuICAgICAgZGVmaW5lZC5zZXQoJ0Bwcm9wYWdhdGUnLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgQGltcG9ydFxuICAgIGlmKCdAaW1wb3J0JyBpbiBjdHgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3R4WydAaW1wb3J0J107XG4gICAgICBpZihhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgPT09ICdqc29uLWxkLTEuMCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAaW1wb3J0IG5vdCBjb21wYXRpYmxlIHdpdGggJyArXG4gICAgICAgICAgYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBjb250ZXh0IGVudHJ5JywgY29udGV4dDogY3R4fSk7XG4gICAgICB9XG4gICAgICBpZighX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBpbXBvcnQgbXVzdCBiZSBhIHN0cmluZy4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBAaW1wb3J0IHZhbHVlJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzb2x2ZSBjb250ZXh0c1xuICAgICAgY29uc3QgcmVzb2x2ZWRJbXBvcnQgPSBhd2FpdCBvcHRpb25zLmNvbnRleHRSZXNvbHZlci5yZXNvbHZlKHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBjb250ZXh0OiB2YWx1ZSxcbiAgICAgICAgZG9jdW1lbnRMb2FkZXI6IG9wdGlvbnMuZG9jdW1lbnRMb2FkZXIsXG4gICAgICAgIGJhc2U6IG9wdGlvbnMuYmFzZVxuICAgICAgfSk7XG4gICAgICBpZihyZXNvbHZlZEltcG9ydC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAaW1wb3J0IG11c3QgcmVmZXJlbmNlIGEgc2luZ2xlIGNvbnRleHQuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgcmVtb3RlIGNvbnRleHQnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvY2Vzc2VkSW1wb3J0ID0gcmVzb2x2ZWRJbXBvcnRbMF0uZ2V0UHJvY2Vzc2VkKGFjdGl2ZUN0eCk7XG4gICAgICBpZihwcm9jZXNzZWRJbXBvcnQpIHtcbiAgICAgICAgLy8gTm90ZTogaWYgdGhlIHNhbWUgY29udGV4dCB3ZXJlIHVzZWQgaW4gdGhpcyBhY3RpdmUgY29udGV4dFxuICAgICAgICAvLyBhcyBhIHJlZmVyZW5jZSBjb250ZXh0LCB0aGVuIHByb2Nlc3NlZF9pbnB1dCBtaWdodCBub3RcbiAgICAgICAgLy8gYmUgYSBkaWN0LlxuICAgICAgICBjdHggPSBwcm9jZXNzZWRJbXBvcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbXBvcnRDdHggPSByZXNvbHZlZEltcG9ydFswXS5kb2N1bWVudDtcbiAgICAgICAgaWYoJ0BpbXBvcnQnIGluIGltcG9ydEN0eCkge1xuICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OiAnICtcbiAgICAgICAgICAgICdpbXBvcnRlZCBjb250ZXh0IG11c3Qgbm90IGluY2x1ZGUgQGltcG9ydC4nLFxuICAgICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgY29udGV4dCBlbnRyeScsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtZXJnZSBjdHggaW50byBpbXBvcnRDdHggYW5kIHJlcGxhY2UgcnZhbCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBpbXBvcnRDdHgpIHtcbiAgICAgICAgICBpZighY3R4Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGN0eFtrZXldID0gaW1wb3J0Q3R4W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90ZTogdGhpcyBjb3VsZCBwb3RlbmlhbGx5IGNvbmZsaWN0IGlmIHRoZSBpbXBvcnRcbiAgICAgICAgLy8gd2VyZSB1c2VkIGluIHRoZSBzYW1lIGFjdGl2ZSBjb250ZXh0IGFzIGEgcmVmZXJlbmNlZFxuICAgICAgICAvLyBjb250ZXh0IGFuZCBhbiBpbXBvcnQuIEluIHRoaXMgY2FzZSwgd2VcbiAgICAgICAgLy8gY291bGQgb3ZlcnJpZGUgdGhlIGNhY2hlZCByZXN1bHQsIGJ1dCBzZWVtcyB1bmxpa2VseS5cbiAgICAgICAgcmVzb2x2ZWRJbXBvcnRbMF0uc2V0UHJvY2Vzc2VkKGFjdGl2ZUN0eCwgY3R4KTtcbiAgICAgIH1cblxuICAgICAgZGVmaW5lZC5zZXQoJ0BpbXBvcnQnLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgQHByb3RlY3RlZDsgZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBzdWItY29udGV4dCBpcyBkZWNsYXJpbmdcbiAgICAvLyBhbGwgaXRzIHRlcm1zIHRvIGJlIFwicHJvdGVjdGVkXCIgKGV4Y2VwdGlvbnMgY2FuIGJlIG1hZGUgb24gYVxuICAgIC8vIHBlci1kZWZpbml0aW9uIGJhc2lzKVxuICAgIGRlZmluZWQuc2V0KCdAcHJvdGVjdGVkJywgY3R4WydAcHJvdGVjdGVkJ10gfHwgZmFsc2UpO1xuXG4gICAgLy8gcHJvY2VzcyBhbGwgb3RoZXIga2V5c1xuICAgIGZvcihjb25zdCBrZXkgaW4gY3R4KSB7XG4gICAgICBhcGkuY3JlYXRlVGVybURlZmluaXRpb24oe1xuICAgICAgICBhY3RpdmVDdHg6IHJ2YWwsXG4gICAgICAgIGxvY2FsQ3R4OiBjdHgsXG4gICAgICAgIHRlcm06IGtleSxcbiAgICAgICAgZGVmaW5lZCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgb3ZlcnJpZGVQcm90ZWN0ZWRcbiAgICAgIH0pO1xuXG4gICAgICBpZihfaXNPYmplY3QoY3R4W2tleV0pICYmICdAY29udGV4dCcgaW4gY3R4W2tleV0pIHtcbiAgICAgICAgY29uc3Qga2V5Q3R4ID0gY3R4W2tleV1bJ0Bjb250ZXh0J107XG4gICAgICAgIGxldCBwcm9jZXNzID0gdHJ1ZTtcbiAgICAgICAgaWYoX2lzU3RyaW5nKGtleUN0eCkpIHtcbiAgICAgICAgICBjb25zdCB1cmwgPSBwcmVwZW5kQmFzZShvcHRpb25zLmJhc2UsIGtleUN0eCk7XG4gICAgICAgICAgLy8gdHJhY2sgcHJvY2Vzc2VkIGNvbnRleHRzIHRvIGF2b2lkIHNjb3BlZCBjb250ZXh0IHJlY3Vyc2lvblxuICAgICAgICAgIGlmKGN5Y2xlcy5oYXModXJsKSkge1xuICAgICAgICAgICAgcHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeWNsZXMuYWRkKHVybCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnNlIGNvbnRleHQgdG8gdmFsaWRhdGVcbiAgICAgICAgaWYocHJvY2Vzcykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBhcGkucHJvY2Vzcyh7XG4gICAgICAgICAgICAgIGFjdGl2ZUN0eDogcnZhbC5jbG9uZSgpLFxuICAgICAgICAgICAgICBsb2NhbEN0eDogY3R4W2tleV1bJ0Bjb250ZXh0J10sXG4gICAgICAgICAgICAgIG92ZXJyaWRlUHJvdGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICBjeWNsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgaW52YWxpZCBzY29wZWQgY29udGV4dC4nLFxuICAgICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdpbnZhbGlkIHNjb3BlZCBjb250ZXh0JyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjdHhba2V5XVsnQGNvbnRleHQnXSxcbiAgICAgICAgICAgICAgICB0ZXJtOiBrZXlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FjaGUgcHJvY2Vzc2VkIHJlc3VsdFxuICAgIHJlc29sdmVkQ29udGV4dC5zZXRQcm9jZXNzZWQoYWN0aXZlQ3R4LCBydmFsKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGVybSBkZWZpbml0aW9uIGR1cmluZyBjb250ZXh0IHByb2Nlc3NpbmcuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY3VycmVudCBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSBsb2NhbEN0eCB0aGUgbG9jYWwgY29udGV4dCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0gdGVybSB0aGUgdGVybSBpbiB0aGUgbG9jYWwgY29udGV4dCB0byBkZWZpbmUgdGhlIG1hcHBpbmcgZm9yLlxuICogQHBhcmFtIGRlZmluZWQgYSBtYXAgb2YgZGVmaW5pbmcvZGVmaW5lZCBrZXlzIHRvIGRldGVjdCBjeWNsZXMgYW5kIHByZXZlbnRcbiAqICAgICAgICAgIGRvdWJsZSBkZWZpbml0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBjcmVhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3RlY3RlZE1vZGU9XCJlcnJvclwiXSAtIFwiZXJyb3JcIiB0byB0aHJvdyBlcnJvclxuICogICBvbiBgQHByb3RlY3RlZGAgY29uc3RyYWludCB2aW9sYXRpb24sIFwid2FyblwiIHRvIGFsbG93IHZpb2xhdGlvbnMgYW5kXG4gKiAgIHNpZ25hbCBhIHdhcm5pbmcuXG4gKiBAcGFyYW0gb3ZlcnJpZGVQcm90ZWN0ZWQgYGZhbHNlYCBhbGxvd3MgcHJvdGVjdGVkIHRlcm1zIHRvIGJlIG1vZGlmaWVkLlxuICovXG5hcGkuY3JlYXRlVGVybURlZmluaXRpb24gPSAoe1xuICBhY3RpdmVDdHgsXG4gIGxvY2FsQ3R4LFxuICB0ZXJtLFxuICBkZWZpbmVkLFxuICBvcHRpb25zLFxuICBvdmVycmlkZVByb3RlY3RlZCA9IGZhbHNlLFxufSkgPT4ge1xuICBpZihkZWZpbmVkLmhhcyh0ZXJtKSkge1xuICAgIC8vIHRlcm0gYWxyZWFkeSBkZWZpbmVkXG4gICAgaWYoZGVmaW5lZC5nZXQodGVybSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY3ljbGUgZGV0ZWN0ZWRcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnQ3ljbGljYWwgY29udGV4dCBkZWZpbml0aW9uIGRldGVjdGVkLicsXG4gICAgICAnanNvbmxkLkN5Y2xpY2FsQ29udGV4dCcsXG4gICAgICB7Y29kZTogJ2N5Y2xpYyBJUkkgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4LCB0ZXJtfSk7XG4gIH1cblxuICAvLyBub3cgZGVmaW5pbmcgdGVybVxuICBkZWZpbmVkLnNldCh0ZXJtLCBmYWxzZSk7XG5cbiAgLy8gZ2V0IGNvbnRleHQgdGVybSB2YWx1ZVxuICBsZXQgdmFsdWU7XG4gIGlmKGxvY2FsQ3R4Lmhhc093blByb3BlcnR5KHRlcm0pKSB7XG4gICAgdmFsdWUgPSBsb2NhbEN0eFt0ZXJtXTtcbiAgfVxuXG4gIGlmKHRlcm0gPT09ICdAdHlwZScgJiZcbiAgICAgX2lzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAodmFsdWVbJ0Bjb250YWluZXInXSB8fCAnQHNldCcpID09PSAnQHNldCcgJiZcbiAgICAgYXBpLnByb2Nlc3NpbmdNb2RlKGFjdGl2ZUN0eCwgMS4xKSkge1xuXG4gICAgY29uc3QgdmFsaWRLZXlzID0gWydAY29udGFpbmVyJywgJ0BpZCcsICdAcHJvdGVjdGVkJ107XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICBpZihrZXlzLmxlbmd0aCA9PT0gMCB8fCBrZXlzLnNvbWUoayA9PiAhdmFsaWRLZXlzLmluY2x1ZGVzKGspKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsga2V5d29yZHMgY2Fubm90IGJlIG92ZXJyaWRkZW4uJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAna2V5d29yZCByZWRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eCwgdGVybX0pO1xuICAgIH1cbiAgfSBlbHNlIGlmKGFwaS5pc0tleXdvcmQodGVybSkpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsga2V5d29yZHMgY2Fubm90IGJlIG92ZXJyaWRkZW4uJyxcbiAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAge2NvZGU6ICdrZXl3b3JkIHJlZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4LCB0ZXJtfSk7XG4gIH0gZWxzZSBpZih0ZXJtLm1hdGNoKEtFWVdPUkRfUEFUVEVSTikpIHtcbiAgICAvLyBGSVhNRTogcmVtb3ZlIGxvZ2dpbmcgYW5kIHVzZSBhIGhhbmRsZXJcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IHRlcm1zIGJlZ2lubmluZyB3aXRoIFwiQFwiIGFyZSByZXNlcnZlZCcgK1xuICAgICAgJyBmb3IgZnV0dXJlIHVzZSBhbmQgaWdub3JlZCcsIHt0ZXJtfSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYodGVybSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYSB0ZXJtIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuJyxcbiAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAge2NvZGU6ICdpbnZhbGlkIHRlcm0gZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gIH1cblxuICAvLyBrZWVwIHJlZmVyZW5jZSB0byBwcmV2aW91cyBtYXBwaW5nIGZvciBwb3RlbnRpYWwgYEBwcm90ZWN0ZWRgIGNoZWNrXG4gIGNvbnN0IHByZXZpb3VzTWFwcGluZyA9IGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQodGVybSk7XG5cbiAgLy8gcmVtb3ZlIG9sZCBtYXBwaW5nXG4gIGlmKGFjdGl2ZUN0eC5tYXBwaW5ncy5oYXModGVybSkpIHtcbiAgICBhY3RpdmVDdHgubWFwcGluZ3MuZGVsZXRlKHRlcm0pO1xuICB9XG5cbiAgLy8gY29udmVydCBzaG9ydC1oYW5kIHZhbHVlIHRvIG9iamVjdCB3L0BpZFxuICBsZXQgc2ltcGxlVGVybSA9IGZhbHNlO1xuICBpZihfaXNTdHJpbmcodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgc2ltcGxlVGVybSA9IHRydWU7XG4gICAgdmFsdWUgPSB7J0BpZCc6IHZhbHVlfTtcbiAgfVxuXG4gIGlmKCFfaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBjb250ZXh0IHRlcm0gdmFsdWVzIG11c3QgYmUgJyArXG4gICAgICAnc3RyaW5ncyBvciBvYmplY3RzLicsXG4gICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgIHtjb2RlOiAnaW52YWxpZCB0ZXJtIGRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICB9XG5cbiAgLy8gY3JlYXRlIG5ldyBtYXBwaW5nXG4gIGNvbnN0IG1hcHBpbmcgPSB7fTtcbiAgYWN0aXZlQ3R4Lm1hcHBpbmdzLnNldCh0ZXJtLCBtYXBwaW5nKTtcbiAgbWFwcGluZy5yZXZlcnNlID0gZmFsc2U7XG5cbiAgLy8gbWFrZSBzdXJlIHRlcm0gZGVmaW5pdGlvbiBvbmx5IGhhcyBleHBlY3RlZCBrZXl3b3Jkc1xuICBjb25zdCB2YWxpZEtleXMgPSBbJ0Bjb250YWluZXInLCAnQGlkJywgJ0BsYW5ndWFnZScsICdAcmV2ZXJzZScsICdAdHlwZSddO1xuXG4gIC8vIEpTT04tTEQgMS4xIHN1cHBvcnRcbiAgaWYoYXBpLnByb2Nlc3NpbmdNb2RlKGFjdGl2ZUN0eCwgMS4xKSkge1xuICAgIHZhbGlkS2V5cy5wdXNoKFxuICAgICAgJ0Bjb250ZXh0JywgJ0BkaXJlY3Rpb24nLCAnQGluZGV4JywgJ0BuZXN0JywgJ0BwcmVmaXgnLCAnQHByb3RlY3RlZCcpO1xuICB9XG5cbiAgZm9yKGNvbnN0IGt3IGluIHZhbHVlKSB7XG4gICAgaWYoIXZhbGlkS2V5cy5pbmNsdWRlcyhrdykpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEgdGVybSBkZWZpbml0aW9uIG11c3Qgbm90IGNvbnRhaW4gJyArIGt3LFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHRlcm0gZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWx3YXlzIGNvbXB1dGUgd2hldGhlciB0ZXJtIGhhcyBhIGNvbG9uIGFzIGFuIG9wdGltaXphdGlvbiBmb3JcbiAgLy8gX2NvbXBhY3RJcmlcbiAgY29uc3QgY29sb24gPSB0ZXJtLmluZGV4T2YoJzonKTtcbiAgbWFwcGluZy5fdGVybUhhc0NvbG9uID0gKGNvbG9uID4gMCk7XG5cbiAgaWYoJ0ByZXZlcnNlJyBpbiB2YWx1ZSkge1xuICAgIGlmKCdAaWQnIGluIHZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIEByZXZlcnNlIHRlcm0gZGVmaW5pdGlvbiBtdXN0IG5vdCAnICtcbiAgICAgICAgJ2NvbnRhaW4gQGlkLicsICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgcmV2ZXJzZSBwcm9wZXJ0eScsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuICAgIGlmKCdAbmVzdCcgaW4gdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEgQHJldmVyc2UgdGVybSBkZWZpbml0aW9uIG11c3Qgbm90ICcgK1xuICAgICAgICAnY29udGFpbiBAbmVzdC4nLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHJldmVyc2UgcHJvcGVydHknLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBjb25zdCByZXZlcnNlID0gdmFsdWVbJ0ByZXZlcnNlJ107XG4gICAgaWYoIV9pc1N0cmluZyhyZXZlcnNlKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYSBAY29udGV4dCBAcmV2ZXJzZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgSVJJIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cblxuICAgIGlmKCFhcGkuaXNLZXl3b3JkKHJldmVyc2UpICYmIHJldmVyc2UubWF0Y2goS0VZV09SRF9QQVRURVJOKSkge1xuICAgICAgLy8gRklYTUU6IHJlbW92ZSBsb2dnaW5nIGFuZCB1c2UgYSBoYW5kbGVyXG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IHZhbHVlcyBiZWdpbm5pbmcgd2l0aCBcIkBcIiBhcmUgcmVzZXJ2ZWQnICtcbiAgICAgICAgJyBmb3IgZnV0dXJlIHVzZSBhbmQgaWdub3JlZCcsIHtyZXZlcnNlfSk7XG4gICAgICBpZihwcmV2aW91c01hcHBpbmcpIHtcbiAgICAgICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLnNldCh0ZXJtLCBwcmV2aW91c01hcHBpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLmRlbGV0ZSh0ZXJtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBleHBhbmQgYW5kIGFkZCBAaWQgbWFwcGluZ1xuICAgIGNvbnN0IGlkID0gX2V4cGFuZElyaShcbiAgICAgIGFjdGl2ZUN0eCwgcmV2ZXJzZSwge3ZvY2FiOiB0cnVlLCBiYXNlOiBmYWxzZX0sIGxvY2FsQ3R4LCBkZWZpbmVkLFxuICAgICAgb3B0aW9ucyk7XG4gICAgaWYoIV9pc0Fic29sdXRlSXJpKGlkKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYSBAY29udGV4dCBAcmV2ZXJzZSB2YWx1ZSBtdXN0IGJlIGFuICcgK1xuICAgICAgICAnYWJzb2x1dGUgSVJJIG9yIGEgYmxhbmsgbm9kZSBpZGVudGlmaWVyLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgSVJJIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cblxuICAgIG1hcHBpbmdbJ0BpZCddID0gaWQ7XG4gICAgbWFwcGluZy5yZXZlcnNlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmKCdAaWQnIGluIHZhbHVlKSB7XG4gICAgbGV0IGlkID0gdmFsdWVbJ0BpZCddO1xuICAgIGlmKGlkICYmICFfaXNTdHJpbmcoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIEBjb250ZXh0IEBpZCB2YWx1ZSBtdXN0IGJlIGFuIGFycmF5ICcgK1xuICAgICAgICAnb2Ygc3RyaW5ncyBvciBhIHN0cmluZy4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIElSSSBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gICAgaWYoaWQgPT09IG51bGwpIHtcbiAgICAgIC8vIHJlc2VydmUgYSBudWxsIHRlcm0sIHdoaWNoIG1heSBiZSBwcm90ZWN0ZWRcbiAgICAgIG1hcHBpbmdbJ0BpZCddID0gbnVsbDtcbiAgICB9IGVsc2UgaWYoIWFwaS5pc0tleXdvcmQoaWQpICYmIGlkLm1hdGNoKEtFWVdPUkRfUEFUVEVSTikpIHtcbiAgICAgIC8vIEZJWE1FOiByZW1vdmUgbG9nZ2luZyBhbmQgdXNlIGEgaGFuZGxlclxuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiB2YWx1ZXMgYmVnaW5uaW5nIHdpdGggXCJAXCIgYXJlIHJlc2VydmVkJyArXG4gICAgICAgICcgZm9yIGZ1dHVyZSB1c2UgYW5kIGlnbm9yZWQnLCB7aWR9KTtcbiAgICAgIGlmKHByZXZpb3VzTWFwcGluZykge1xuICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3Muc2V0KHRlcm0sIHByZXZpb3VzTWFwcGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3MuZGVsZXRlKHRlcm0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZihpZCAhPT0gdGVybSkge1xuICAgICAgLy8gZXhwYW5kIGFuZCBhZGQgQGlkIG1hcHBpbmdcbiAgICAgIGlkID0gX2V4cGFuZElyaShcbiAgICAgICAgYWN0aXZlQ3R4LCBpZCwge3ZvY2FiOiB0cnVlLCBiYXNlOiBmYWxzZX0sIGxvY2FsQ3R4LCBkZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgIGlmKCFfaXNBYnNvbHV0ZUlyaShpZCkgJiYgIWFwaS5pc0tleXdvcmQoaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYSBAY29udGV4dCBAaWQgdmFsdWUgbXVzdCBiZSBhbiAnICtcbiAgICAgICAgICAnYWJzb2x1dGUgSVJJLCBhIGJsYW5rIG5vZGUgaWRlbnRpZmllciwgb3IgYSBrZXl3b3JkLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIElSSSBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGVybSBoYXMgdGhlIGZvcm0gb2YgYW4gSVJJIGl0IG11c3QgbWFwIHRoZSBzYW1lXG4gICAgICBpZih0ZXJtLm1hdGNoKC8oPzo6W146XSl8XFwvLykpIHtcbiAgICAgICAgY29uc3QgdGVybURlZmluZWQgPSBuZXcgTWFwKGRlZmluZWQpLnNldCh0ZXJtLCB0cnVlKTtcbiAgICAgICAgY29uc3QgdGVybUlyaSA9IF9leHBhbmRJcmkoXG4gICAgICAgICAgYWN0aXZlQ3R4LCB0ZXJtLCB7dm9jYWI6IHRydWUsIGJhc2U6IGZhbHNlfSxcbiAgICAgICAgICBsb2NhbEN0eCwgdGVybURlZmluZWQsIG9wdGlvbnMpO1xuICAgICAgICBpZih0ZXJtSXJpICE9PSBpZCkge1xuICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyB0ZXJtIGluIGZvcm0gb2YgSVJJIG11c3QgJyArXG4gICAgICAgICAgICAnZXhwYW5kIHRvIGRlZmluaXRpb24uJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIElSSSBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXBwaW5nWydAaWQnXSA9IGlkO1xuICAgICAgLy8gaW5kaWNhdGUgaWYgdGhpcyB0ZXJtIG1heSBiZSB1c2VkIGFzIGEgY29tcGFjdCBJUkkgcHJlZml4XG4gICAgICBtYXBwaW5nLl9wcmVmaXggPSAoc2ltcGxlVGVybSAmJlxuICAgICAgICAhbWFwcGluZy5fdGVybUhhc0NvbG9uICYmXG4gICAgICAgIGlkLm1hdGNoKC9bOlxcL1xcPyNcXFtcXF1AXSQvKSk7XG4gICAgfVxuICB9XG5cbiAgaWYoISgnQGlkJyBpbiBtYXBwaW5nKSkge1xuICAgIC8vIHNlZSBpZiB0aGUgdGVybSBoYXMgYSBwcmVmaXhcbiAgICBpZihtYXBwaW5nLl90ZXJtSGFzQ29sb24pIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHRlcm0uc3Vic3RyKDAsIGNvbG9uKTtcbiAgICAgIGlmKGxvY2FsQ3R4Lmhhc093blByb3BlcnR5KHByZWZpeCkpIHtcbiAgICAgICAgLy8gZGVmaW5lIHBhcmVudCBwcmVmaXhcbiAgICAgICAgYXBpLmNyZWF0ZVRlcm1EZWZpbml0aW9uKHtcbiAgICAgICAgICBhY3RpdmVDdHgsIGxvY2FsQ3R4LCB0ZXJtOiBwcmVmaXgsIGRlZmluZWQsIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGFjdGl2ZUN0eC5tYXBwaW5ncy5oYXMocHJlZml4KSkge1xuICAgICAgICAvLyBzZXQgQGlkIGJhc2VkIG9uIHByZWZpeCBwYXJlbnRcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdGVybS5zdWJzdHIoY29sb24gKyAxKTtcbiAgICAgICAgbWFwcGluZ1snQGlkJ10gPSBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KHByZWZpeClbJ0BpZCddICsgc3VmZml4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGVybSBpcyBhbiBhYnNvbHV0ZSBJUklcbiAgICAgICAgbWFwcGluZ1snQGlkJ10gPSB0ZXJtO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih0ZXJtID09PSAnQHR5cGUnKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UsIHdlcmUgd2UndmUgcHJldmlvdXNseSBkZXRlcm1pbmVkIHRoYXQgY29udGFpbmVyIGlzIEBzZXRcbiAgICAgIG1hcHBpbmdbJ0BpZCddID0gdGVybTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9uLUlSSXMgKm11c3QqIGRlZmluZSBAaWRzIGlmIEB2b2NhYiBpcyBub3QgYXZhaWxhYmxlXG4gICAgICBpZighKCdAdm9jYWInIGluIGFjdGl2ZUN0eCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCB0ZXJtcyBtdXN0IGRlZmluZSBhbiBAaWQuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgSVJJIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eCwgdGVybX0pO1xuICAgICAgfVxuICAgICAgLy8gcHJlcGVuZCB2b2NhYiB0byB0ZXJtXG4gICAgICBtYXBwaW5nWydAaWQnXSA9IGFjdGl2ZUN0eFsnQHZvY2FiJ10gKyB0ZXJtO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSB0ZXJtIHByb3RlY3Rpb25cbiAgaWYodmFsdWVbJ0Bwcm90ZWN0ZWQnXSA9PT0gdHJ1ZSB8fFxuICAgIChkZWZpbmVkLmdldCgnQHByb3RlY3RlZCcpID09PSB0cnVlICYmIHZhbHVlWydAcHJvdGVjdGVkJ10gIT09IGZhbHNlKSkge1xuICAgIGFjdGl2ZUN0eC5wcm90ZWN0ZWRbdGVybV0gPSB0cnVlO1xuICAgIG1hcHBpbmcucHJvdGVjdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIElSSSBtYXBwaW5nIG5vdyBkZWZpbmVkXG4gIGRlZmluZWQuc2V0KHRlcm0sIHRydWUpO1xuXG4gIGlmKCdAdHlwZScgaW4gdmFsdWUpIHtcbiAgICBsZXQgdHlwZSA9IHZhbHVlWydAdHlwZSddO1xuICAgIGlmKCFfaXNTdHJpbmcodHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGFuIEBjb250ZXh0IEB0eXBlIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB0eXBlIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cblxuICAgIGlmKCh0eXBlID09PSAnQGpzb24nIHx8IHR5cGUgPT09ICdAbm9uZScpKSB7XG4gICAgICBpZihhcGkucHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjApKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYW4gQGNvbnRleHQgQHR5cGUgdmFsdWUgbXVzdCBub3QgYmUgJyArXG4gICAgICAgICAgYFwiJHt0eXBlfVwiIGluIEpTT04tTEQgMS4wIG1vZGUuYCxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgdHlwZSBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYodHlwZSAhPT0gJ0BpZCcgJiYgdHlwZSAhPT0gJ0B2b2NhYicpIHtcbiAgICAgIC8vIGV4cGFuZCBAdHlwZSB0byBmdWxsIElSSVxuICAgICAgdHlwZSA9IF9leHBhbmRJcmkoXG4gICAgICAgIGFjdGl2ZUN0eCwgdHlwZSwge3ZvY2FiOiB0cnVlLCBiYXNlOiBmYWxzZX0sIGxvY2FsQ3R4LCBkZWZpbmVkLFxuICAgICAgICBvcHRpb25zKTtcbiAgICAgIGlmKCFfaXNBYnNvbHV0ZUlyaSh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGFuIEBjb250ZXh0IEB0eXBlIHZhbHVlIG11c3QgYmUgYW4gJyArXG4gICAgICAgICAgJ2Fic29sdXRlIElSSS4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCB0eXBlIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuICAgICAgaWYodHlwZS5pbmRleE9mKCdfOicpID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYW4gQGNvbnRleHQgQHR5cGUgdmFsdWUgbXVzdCBiZSBhbiBJUkksICcgK1xuICAgICAgICAgICdub3QgYSBibGFuayBub2RlIGlkZW50aWZpZXIuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgdHlwZSBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgQHR5cGUgdG8gbWFwcGluZ1xuICAgIG1hcHBpbmdbJ0B0eXBlJ10gPSB0eXBlO1xuICB9XG5cbiAgaWYoJ0Bjb250YWluZXInIGluIHZhbHVlKSB7XG4gICAgLy8gbm9ybWFsaXplIGNvbnRhaW5lciB0byBhbiBhcnJheSBmb3JtXG4gICAgY29uc3QgY29udGFpbmVyID0gX2lzU3RyaW5nKHZhbHVlWydAY29udGFpbmVyJ10pID9cbiAgICAgIFt2YWx1ZVsnQGNvbnRhaW5lciddXSA6ICh2YWx1ZVsnQGNvbnRhaW5lciddIHx8IFtdKTtcbiAgICBjb25zdCB2YWxpZENvbnRhaW5lcnMgPSBbJ0BsaXN0JywgJ0BzZXQnLCAnQGluZGV4JywgJ0BsYW5ndWFnZSddO1xuICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcbiAgICBjb25zdCBoYXNTZXQgPSBjb250YWluZXIuaW5jbHVkZXMoJ0BzZXQnKTtcblxuICAgIC8vIEpTT04tTEQgMS4xIHN1cHBvcnRcbiAgICBpZihhcGkucHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpKSB7XG4gICAgICB2YWxpZENvbnRhaW5lcnMucHVzaCgnQGdyYXBoJywgJ0BpZCcsICdAdHlwZScpO1xuXG4gICAgICAvLyBjaGVjayBjb250YWluZXIgbGVuZ3RoXG4gICAgICBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BsaXN0JykpIHtcbiAgICAgICAgaWYoY29udGFpbmVyLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBAY29udGFpbmVyIHdpdGggQGxpc3QgbXVzdCAnICtcbiAgICAgICAgICAgICdoYXZlIG5vIG90aGVyIHZhbHVlcycsXG4gICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBjb250YWluZXIgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BncmFwaCcpKSB7XG4gICAgICAgIGlmKGNvbnRhaW5lci5zb21lKGtleSA9PlxuICAgICAgICAgIGtleSAhPT0gJ0BncmFwaCcgJiYga2V5ICE9PSAnQGlkJyAmJiBrZXkgIT09ICdAaW5kZXgnICYmXG4gICAgICAgICAga2V5ICE9PSAnQHNldCcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBjb250ZXh0IEBjb250YWluZXIgd2l0aCBAZ3JhcGggbXVzdCAnICtcbiAgICAgICAgICAgICdoYXZlIG5vIG90aGVyIHZhbHVlcyBvdGhlciB0aGFuIEBpZCwgQGluZGV4LCBhbmQgQHNldCcsXG4gICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBjb250YWluZXIgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSwgY29udGFpbmVyIG1heSBhbHNvIGluY2x1ZGUgQHNldFxuICAgICAgICBpc1ZhbGlkICY9IGNvbnRhaW5lci5sZW5ndGggPD0gKGhhc1NldCA/IDIgOiAxKTtcbiAgICAgIH1cblxuICAgICAgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAdHlwZScpKSB7XG4gICAgICAgIC8vIElmIG1hcHBpbmcgZG9lcyBub3QgaGF2ZSBhbiBAdHlwZSxcbiAgICAgICAgLy8gc2V0IGl0IHRvIEBpZFxuICAgICAgICBtYXBwaW5nWydAdHlwZSddID0gbWFwcGluZ1snQHR5cGUnXSB8fCAnQGlkJztcblxuICAgICAgICAvLyB0eXBlIG1hcHBpbmcgbXVzdCBiZSBlaXRoZXIgQGlkIG9yIEB2b2NhYlxuICAgICAgICBpZighWydAaWQnLCAnQHZvY2FiJ10uaW5jbHVkZXMobWFwcGluZ1snQHR5cGUnXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgY29udGFpbmVyOiBAdHlwZSByZXF1aXJlcyBAdHlwZSB0byBiZSAnICtcbiAgICAgICAgICAgICdAaWQgb3IgQHZvY2FiLicsXG4gICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCB0eXBlIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIEpTT04tTEQgMS4wLCBjb250YWluZXIgbXVzdCBub3QgYmUgYW4gYXJyYXkgKGl0IG11c3QgYmUgYSBzdHJpbmcsXG4gICAgICAvLyB3aGljaCBpcyBvbmUgb2YgdGhlIHZhbGlkQ29udGFpbmVycylcbiAgICAgIGlzVmFsaWQgJj0gIV9pc0FycmF5KHZhbHVlWydAY29udGFpbmVyJ10pO1xuXG4gICAgICAvLyBjaGVjayBjb250YWluZXIgbGVuZ3RoXG4gICAgICBpc1ZhbGlkICY9IGNvbnRhaW5lci5sZW5ndGggPD0gMTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBhZ2FpbnN0IHZhbGlkIGNvbnRhaW5lcnNcbiAgICBpc1ZhbGlkICY9IGNvbnRhaW5lci5ldmVyeShjID0+IHZhbGlkQ29udGFpbmVycy5pbmNsdWRlcyhjKSk7XG5cbiAgICAvLyBAc2V0IG5vdCBhbGxvd2VkIHdpdGggQGxpc3RcbiAgICBpc1ZhbGlkICY9ICEoaGFzU2V0ICYmIGNvbnRhaW5lci5pbmNsdWRlcygnQGxpc3QnKSk7XG5cbiAgICBpZighaXNWYWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgQGNvbnRhaW5lciB2YWx1ZSBtdXN0IGJlICcgK1xuICAgICAgICAnb25lIG9mIHRoZSBmb2xsb3dpbmc6ICcgKyB2YWxpZENvbnRhaW5lcnMuam9pbignLCAnKSxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCBjb250YWluZXIgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuXG4gICAgaWYobWFwcGluZy5yZXZlcnNlICYmXG4gICAgICAhY29udGFpbmVyLmV2ZXJ5KGMgPT4gWydAaW5kZXgnLCAnQHNldCddLmluY2x1ZGVzKGMpKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgQGNvbnRhaW5lciB2YWx1ZSBmb3IgYSBAcmV2ZXJzZSAnICtcbiAgICAgICAgJ3R5cGUgZGVmaW5pdGlvbiBtdXN0IGJlIEBpbmRleCBvciBAc2V0LicsICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgcmV2ZXJzZSBwcm9wZXJ0eScsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIEBjb250YWluZXIgdG8gbWFwcGluZ1xuICAgIG1hcHBpbmdbJ0Bjb250YWluZXInXSA9IGNvbnRhaW5lcjtcbiAgfVxuXG4gIC8vIHByb3BlcnR5IGluZGV4aW5nXG4gIGlmKCdAaW5kZXgnIGluIHZhbHVlKSB7XG4gICAgaWYoISgnQGNvbnRhaW5lcicgaW4gdmFsdWUpIHx8ICFtYXBwaW5nWydAY29udGFpbmVyJ10uaW5jbHVkZXMoJ0BpbmRleCcpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAaW5kZXggd2l0aG91dCBAaW5kZXggaW4gQGNvbnRhaW5lcjogJyArXG4gICAgICAgIGBcIiR7dmFsdWVbJ0BpbmRleCddfVwiIG9uIHRlcm0gXCIke3Rlcm19XCIuYCwgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB0ZXJtIGRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBpZighX2lzU3RyaW5nKHZhbHVlWydAaW5kZXgnXSkgfHwgdmFsdWVbJ0BpbmRleCddLmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGluZGV4IG11c3QgZXhwYW5kIHRvIGFuIElSSTogJyArXG4gICAgICAgIGBcIiR7dmFsdWVbJ0BpbmRleCddfVwiIG9uIHRlcm0gXCIke3Rlcm19XCIuYCwgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB0ZXJtIGRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBtYXBwaW5nWydAaW5kZXgnXSA9IHZhbHVlWydAaW5kZXgnXTtcbiAgfVxuXG4gIC8vIHNjb3BlZCBjb250ZXh0c1xuICBpZignQGNvbnRleHQnIGluIHZhbHVlKSB7XG4gICAgbWFwcGluZ1snQGNvbnRleHQnXSA9IHZhbHVlWydAY29udGV4dCddO1xuICB9XG5cbiAgaWYoJ0BsYW5ndWFnZScgaW4gdmFsdWUgJiYgISgnQHR5cGUnIGluIHZhbHVlKSkge1xuICAgIGxldCBsYW5ndWFnZSA9IHZhbHVlWydAbGFuZ3VhZ2UnXTtcbiAgICBpZihsYW5ndWFnZSAhPT0gbnVsbCAmJiAhX2lzU3RyaW5nKGxhbmd1YWdlKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgQGxhbmd1YWdlIHZhbHVlIG11c3QgYmUgJyArXG4gICAgICAgICdhIHN0cmluZyBvciBudWxsLicsICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgbGFuZ3VhZ2UgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIEBsYW5ndWFnZSB0byBtYXBwaW5nXG4gICAgaWYobGFuZ3VhZ2UgIT09IG51bGwpIHtcbiAgICAgIGxhbmd1YWdlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgbWFwcGluZ1snQGxhbmd1YWdlJ10gPSBsYW5ndWFnZTtcbiAgfVxuXG4gIC8vIHRlcm0gbWF5IGJlIHVzZWQgYXMgYSBwcmVmaXhcbiAgaWYoJ0BwcmVmaXgnIGluIHZhbHVlKSB7XG4gICAgaWYodGVybS5tYXRjaCgvOnxcXC8vKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgQHByZWZpeCB1c2VkIG9uIGEgY29tcGFjdCBJUkkgdGVybScsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgdGVybSBkZWZpbml0aW9uJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gICAgaWYoYXBpLmlzS2V5d29yZChtYXBwaW5nWydAaWQnXSkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGtleXdvcmRzIG1heSBub3QgYmUgdXNlZCBhcyBwcmVmaXhlcycsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgdGVybSBkZWZpbml0aW9uJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gICAgaWYodHlwZW9mIHZhbHVlWydAcHJlZml4J10gPT09ICdib29sZWFuJykge1xuICAgICAgbWFwcGluZy5fcHJlZml4ID0gdmFsdWVbJ0BwcmVmaXgnXSA9PT0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgdmFsdWUgZm9yIEBwcmVmaXggbXVzdCBiZSBib29sZWFuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCBAcHJlZml4IHZhbHVlJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gIH1cblxuICBpZignQGRpcmVjdGlvbicgaW4gdmFsdWUpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB2YWx1ZVsnQGRpcmVjdGlvbiddO1xuICAgIGlmKGRpcmVjdGlvbiAhPT0gbnVsbCAmJiBkaXJlY3Rpb24gIT09ICdsdHInICYmIGRpcmVjdGlvbiAhPT0gJ3J0bCcpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBkaXJlY3Rpb24gdmFsdWUgbXVzdCBiZSAnICtcbiAgICAgICAgJ251bGwsIFwibHRyXCIsIG9yIFwicnRsXCIuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCBiYXNlIGRpcmVjdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuICAgIG1hcHBpbmdbJ0BkaXJlY3Rpb24nXSA9IGRpcmVjdGlvbjtcbiAgfVxuXG4gIGlmKCdAbmVzdCcgaW4gdmFsdWUpIHtcbiAgICBjb25zdCBuZXN0ID0gdmFsdWVbJ0BuZXN0J107XG4gICAgaWYoIV9pc1N0cmluZyhuZXN0KSB8fCAobmVzdCAhPT0gJ0BuZXN0JyAmJiBuZXN0LmluZGV4T2YoJ0AnKSA9PT0gMCkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBjb250ZXh0IEBuZXN0IHZhbHVlIG11c3QgYmUgJyArXG4gICAgICAgICdhIHN0cmluZyB3aGljaCBpcyBub3QgYSBrZXl3b3JkIG90aGVyIHRoYW4gQG5lc3QuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCBAbmVzdCB2YWx1ZScsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuICAgIG1hcHBpbmdbJ0BuZXN0J10gPSBuZXN0O1xuICB9XG5cbiAgLy8gZGlzYWxsb3cgYWxpYXNpbmcgQGNvbnRleHQgYW5kIEBwcmVzZXJ2ZVxuICBjb25zdCBpZCA9IG1hcHBpbmdbJ0BpZCddO1xuICBpZihpZCA9PT0gJ0Bjb250ZXh0JyB8fCBpZCA9PT0gJ0BwcmVzZXJ2ZScpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgYW5kIEBwcmVzZXJ2ZSBjYW5ub3QgYmUgYWxpYXNlZC4nLFxuICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBrZXl3b3JkIGFsaWFzJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBvdmVycmlkaW5nIHByb3RlY3RlZCB0ZXJtc1xuICBpZihwcmV2aW91c01hcHBpbmcgJiYgcHJldmlvdXNNYXBwaW5nLnByb3RlY3RlZCAmJiAhb3ZlcnJpZGVQcm90ZWN0ZWQpIHtcbiAgICAvLyBmb3JjZSBuZXcgdGVybSB0byBjb250aW51ZSB0byBiZSBwcm90ZWN0ZWQgYW5kIHNlZSBpZiB0aGUgbWFwcGluZ3Mgd291bGRcbiAgICAvLyBiZSBlcXVhbFxuICAgIGFjdGl2ZUN0eC5wcm90ZWN0ZWRbdGVybV0gPSB0cnVlO1xuICAgIG1hcHBpbmcucHJvdGVjdGVkID0gdHJ1ZTtcbiAgICBpZighX2RlZXBDb21wYXJlKHByZXZpb3VzTWFwcGluZywgbWFwcGluZykpIHtcbiAgICAgIGNvbnN0IHByb3RlY3RlZE1vZGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnByb3RlY3RlZE1vZGUpIHx8ICdlcnJvcic7XG4gICAgICBpZihwcm90ZWN0ZWRNb2RlID09PSAnZXJyb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgdHJpZWQgdG8gcmVkZWZpbmUgYSBwcm90ZWN0ZWQgdGVybS4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAncHJvdGVjdGVkIHRlcm0gcmVkZWZpbml0aW9uJywgY29udGV4dDogbG9jYWxDdHgsIHRlcm19KTtcbiAgICAgIH0gZWxzZSBpZihwcm90ZWN0ZWRNb2RlID09PSAnd2FybicpIHtcbiAgICAgICAgLy8gRklYTUU6IHJlbW92ZSBsb2dnaW5nIGFuZCB1c2UgYSBoYW5kbGVyXG4gICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogcHJvdGVjdGVkIHRlcm0gcmVkZWZpbml0aW9uJywge3Rlcm19KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBwcm90ZWN0ZWRNb2RlLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgcHJvdGVjdGVkIG1vZGUnLCBjb250ZXh0OiBsb2NhbEN0eCwgdGVybSxcbiAgICAgICAgICBwcm90ZWN0ZWRNb2RlfSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV4cGFuZHMgYSBzdHJpbmcgdG8gYSBmdWxsIElSSS4gVGhlIHN0cmluZyBtYXkgYmUgYSB0ZXJtLCBhIHByZWZpeCwgYVxuICogcmVsYXRpdmUgSVJJLCBvciBhbiBhYnNvbHV0ZSBJUkkuIFRoZSBhc3NvY2lhdGVkIGFic29sdXRlIElSSSB3aWxsIGJlXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBjdXJyZW50IGFjdGl2ZSBjb250ZXh0LlxuICogQHBhcmFtIHZhbHVlIHRoZSBzdHJpbmcgdG8gZXhwYW5kLlxuICogQHBhcmFtIHJlbGF0aXZlVG8gb3B0aW9ucyBmb3IgaG93IHRvIHJlc29sdmUgcmVsYXRpdmUgSVJJczpcbiAqICAgICAgICAgIGJhc2U6IHRydWUgdG8gcmVzb2x2ZSBhZ2FpbnN0IHRoZSBiYXNlIElSSSwgZmFsc2Ugbm90IHRvLlxuICogICAgICAgICAgdm9jYWI6IHRydWUgdG8gY29uY2F0ZW5hdGUgYWZ0ZXIgQHZvY2FiLCBmYWxzZSBub3QgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcHJvY2Vzc2luZyBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIHZhbHVlLlxuICovXG5hcGkuZXhwYW5kSXJpID0gKGFjdGl2ZUN0eCwgdmFsdWUsIHJlbGF0aXZlVG8sIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIF9leHBhbmRJcmkoYWN0aXZlQ3R4LCB2YWx1ZSwgcmVsYXRpdmVUbywgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG4gICAgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4cGFuZHMgYSBzdHJpbmcgdG8gYSBmdWxsIElSSS4gVGhlIHN0cmluZyBtYXkgYmUgYSB0ZXJtLCBhIHByZWZpeCwgYVxuICogcmVsYXRpdmUgSVJJLCBvciBhbiBhYnNvbHV0ZSBJUkkuIFRoZSBhc3NvY2lhdGVkIGFic29sdXRlIElSSSB3aWxsIGJlXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBjdXJyZW50IGFjdGl2ZSBjb250ZXh0LlxuICogQHBhcmFtIHZhbHVlIHRoZSBzdHJpbmcgdG8gZXhwYW5kLlxuICogQHBhcmFtIHJlbGF0aXZlVG8gb3B0aW9ucyBmb3IgaG93IHRvIHJlc29sdmUgcmVsYXRpdmUgSVJJczpcbiAqICAgICAgICAgIGJhc2U6IHRydWUgdG8gcmVzb2x2ZSBhZ2FpbnN0IHRoZSBiYXNlIElSSSwgZmFsc2Ugbm90IHRvLlxuICogICAgICAgICAgdm9jYWI6IHRydWUgdG8gY29uY2F0ZW5hdGUgYWZ0ZXIgQHZvY2FiLCBmYWxzZSBub3QgdG8uXG4gKiBAcGFyYW0gbG9jYWxDdHggdGhlIGxvY2FsIGNvbnRleHQgYmVpbmcgcHJvY2Vzc2VkIChvbmx5IGdpdmVuIGlmIGNhbGxlZFxuICogICAgICAgICAgZHVyaW5nIGNvbnRleHQgcHJvY2Vzc2luZykuXG4gKiBAcGFyYW0gZGVmaW5lZCBhIG1hcCBmb3IgdHJhY2tpbmcgY3ljbGVzIGluIGNvbnRleHQgZGVmaW5pdGlvbnMgKG9ubHkgZ2l2ZW5cbiAqICAgICAgICAgIGlmIGNhbGxlZCBkdXJpbmcgY29udGV4dCBwcm9jZXNzaW5nKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBwcm9jZXNzaW5nIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB0aGUgZXhwYW5kZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRJcmkoYWN0aXZlQ3R4LCB2YWx1ZSwgcmVsYXRpdmVUbywgbG9jYWxDdHgsIGRlZmluZWQsIG9wdGlvbnMpIHtcbiAgLy8gYWxyZWFkeSBleHBhbmRlZFxuICBpZih2YWx1ZSA9PT0gbnVsbCB8fCAhX2lzU3RyaW5nKHZhbHVlKSB8fCBhcGkuaXNLZXl3b3JkKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vIGlnbm9yZSBub24ta2V5d29yZCB0aGluZ3MgdGhhdCBsb29rIGxpa2UgYSBrZXl3b3JkXG4gIGlmKHZhbHVlLm1hdGNoKEtFWVdPUkRfUEFUVEVSTikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGRlZmluZSB0ZXJtIGRlcGVuZGVuY3kgaWYgbm90IGRlZmluZWRcbiAgaWYobG9jYWxDdHggJiYgbG9jYWxDdHguaGFzT3duUHJvcGVydHkodmFsdWUpICYmXG4gICAgZGVmaW5lZC5nZXQodmFsdWUpICE9PSB0cnVlKSB7XG4gICAgYXBpLmNyZWF0ZVRlcm1EZWZpbml0aW9uKHtcbiAgICAgIGFjdGl2ZUN0eCwgbG9jYWxDdHgsIHRlcm06IHZhbHVlLCBkZWZpbmVkLCBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICByZWxhdGl2ZVRvID0gcmVsYXRpdmVUbyB8fCB7fTtcbiAgaWYocmVsYXRpdmVUby52b2NhYikge1xuICAgIGNvbnN0IG1hcHBpbmcgPSBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KHZhbHVlKTtcblxuICAgIC8vIHZhbHVlIGlzIGV4cGxpY2l0bHkgaWdub3JlZCB3aXRoIGEgbnVsbCBtYXBwaW5nXG4gICAgaWYobWFwcGluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYoX2lzT2JqZWN0KG1hcHBpbmcpICYmICdAaWQnIGluIG1hcHBpbmcpIHtcbiAgICAgIC8vIHZhbHVlIGlzIGEgdGVybVxuICAgICAgcmV0dXJuIG1hcHBpbmdbJ0BpZCddO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNwbGl0IHZhbHVlIGludG8gcHJlZml4OnN1ZmZpeFxuICBjb25zdCBjb2xvbiA9IHZhbHVlLmluZGV4T2YoJzonKTtcbiAgaWYoY29sb24gPiAwKSB7XG4gICAgY29uc3QgcHJlZml4ID0gdmFsdWUuc3Vic3RyKDAsIGNvbG9uKTtcbiAgICBjb25zdCBzdWZmaXggPSB2YWx1ZS5zdWJzdHIoY29sb24gKyAxKTtcblxuICAgIC8vIGRvIG5vdCBleHBhbmQgYmxhbmsgbm9kZXMgKHByZWZpeCBvZiAnXycpIG9yIGFscmVhZHktYWJzb2x1dGVcbiAgICAvLyBJUklzIChzdWZmaXggb2YgJy8vJylcbiAgICBpZihwcmVmaXggPT09ICdfJyB8fCBzdWZmaXguaW5kZXhPZignLy8nKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIHByZWZpeCBkZXBlbmRlbmN5IG5vdCBkZWZpbmVkLCBkZWZpbmUgaXRcbiAgICBpZihsb2NhbEN0eCAmJiBsb2NhbEN0eC5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpKSB7XG4gICAgICBhcGkuY3JlYXRlVGVybURlZmluaXRpb24oe1xuICAgICAgICBhY3RpdmVDdHgsIGxvY2FsQ3R4LCB0ZXJtOiBwcmVmaXgsIGRlZmluZWQsIG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVzZSBtYXBwaW5nIGlmIHByZWZpeCBpcyBkZWZpbmVkXG4gICAgY29uc3QgbWFwcGluZyA9IGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQocHJlZml4KTtcbiAgICBpZihtYXBwaW5nICYmIG1hcHBpbmcuX3ByZWZpeCkge1xuICAgICAgcmV0dXJuIG1hcHBpbmdbJ0BpZCddICsgc3VmZml4O1xuICAgIH1cblxuICAgIC8vIGFscmVhZHkgYWJzb2x1dGUgSVJJXG4gICAgaWYoX2lzQWJzb2x1dGVJcmkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJlcGVuZCB2b2NhYlxuICBpZihyZWxhdGl2ZVRvLnZvY2FiICYmICdAdm9jYWInIGluIGFjdGl2ZUN0eCkge1xuICAgIHJldHVybiBhY3RpdmVDdHhbJ0B2b2NhYiddICsgdmFsdWU7XG4gIH1cblxuICAvLyBwcmVwZW5kIGJhc2VcbiAgaWYocmVsYXRpdmVUby5iYXNlICYmICdAYmFzZScgaW4gYWN0aXZlQ3R4KSB7XG4gICAgaWYoYWN0aXZlQ3R4WydAYmFzZSddKSB7XG4gICAgICAvLyBUaGUgbnVsbCBjYXNlIHByZXNlcnZlcyB2YWx1ZSBhcyBwb3RlbnRpYWxseSByZWxhdGl2ZVxuICAgICAgcmV0dXJuIHByZXBlbmRCYXNlKHByZXBlbmRCYXNlKG9wdGlvbnMuYmFzZSwgYWN0aXZlQ3R4WydAYmFzZSddKSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmKHJlbGF0aXZlVG8uYmFzZSkge1xuICAgIHJldHVybiBwcmVwZW5kQmFzZShvcHRpb25zLmJhc2UsIHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbml0aWFsIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBkb2N1bWVudCBiYXNlIElSSS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbml0aWFsIGNvbnRleHQuXG4gKi9cbmFwaS5nZXRJbml0aWFsQ29udGV4dCA9IG9wdGlvbnMgPT4ge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeSh7cHJvY2Vzc2luZ01vZGU6IG9wdGlvbnMucHJvY2Vzc2luZ01vZGV9KTtcbiAgY29uc3QgY2FjaGVkID0gSU5JVElBTF9DT05URVhUX0NBQ0hFLmdldChrZXkpO1xuICBpZihjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG5cbiAgY29uc3QgaW5pdGlhbENvbnRleHQgPSB7XG4gICAgcHJvY2Vzc2luZ01vZGU6IG9wdGlvbnMucHJvY2Vzc2luZ01vZGUsXG4gICAgbWFwcGluZ3M6IG5ldyBNYXAoKSxcbiAgICBpbnZlcnNlOiBudWxsLFxuICAgIGdldEludmVyc2U6IF9jcmVhdGVJbnZlcnNlQ29udGV4dCxcbiAgICBjbG9uZTogX2Nsb25lQWN0aXZlQ29udGV4dCxcbiAgICByZXZlcnRUb1ByZXZpb3VzQ29udGV4dDogX3JldmVydFRvUHJldmlvdXNDb250ZXh0LFxuICAgIHByb3RlY3RlZDoge31cbiAgfTtcbiAgLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgTFJVIGNhY2hlIGluc3RlYWRcbiAgaWYoSU5JVElBTF9DT05URVhUX0NBQ0hFLnNpemUgPT09IElOSVRJQUxfQ09OVEVYVF9DQUNIRV9NQVhfU0laRSkge1xuICAgIC8vIGNsZWFyIHdob2xlIGNhY2hlIC0tIGFzc3VtZXMgc2NlbmFyaW8gd2hlcmUgdGhlIGNhY2hlIGZpbGxzIG1lYW5zXG4gICAgLy8gdGhlIGNhY2hlIGlzbid0IGJlaW5nIHVzZWQgdmVyeSBlZmZpY2llbnRseSBhbnl3YXlcbiAgICBJTklUSUFMX0NPTlRFWFRfQ0FDSEUuY2xlYXIoKTtcbiAgfVxuICBJTklUSUFMX0NPTlRFWFRfQ0FDSEUuc2V0KGtleSwgaW5pdGlhbENvbnRleHQpO1xuICByZXR1cm4gaW5pdGlhbENvbnRleHQ7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBpbnZlcnNlIGNvbnRleHQgZm9yIHVzZSBpbiB0aGUgY29tcGFjdGlvbiBhbGdvcml0aG0sIGlmXG4gICAqIG5vdCBhbHJlYWR5IGdlbmVyYXRlZCBmb3IgdGhlIGdpdmVuIGFjdGl2ZSBjb250ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBpbnZlcnNlIGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBfY3JlYXRlSW52ZXJzZUNvbnRleHQoKSB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gdGhpcztcblxuICAgIC8vIGxhemlseSBjcmVhdGUgaW52ZXJzZVxuICAgIGlmKGFjdGl2ZUN0eC5pbnZlcnNlKSB7XG4gICAgICByZXR1cm4gYWN0aXZlQ3R4LmludmVyc2U7XG4gICAgfVxuICAgIGNvbnN0IGludmVyc2UgPSBhY3RpdmVDdHguaW52ZXJzZSA9IHt9O1xuXG4gICAgLy8gdmFyaWFibGVzIGZvciBidWlsZGluZyBmYXN0IENVUklFIG1hcFxuICAgIGNvbnN0IGZhc3RDdXJpZU1hcCA9IGFjdGl2ZUN0eC5mYXN0Q3VyaWVNYXAgPSB7fTtcbiAgICBjb25zdCBpcmlzVG9UZXJtcyA9IHt9O1xuXG4gICAgLy8gaGFuZGxlIGRlZmF1bHQgbGFuZ3VhZ2VcbiAgICBjb25zdCBkZWZhdWx0TGFuZ3VhZ2UgPSAoYWN0aXZlQ3R4WydAbGFuZ3VhZ2UnXSB8fCAnQG5vbmUnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gaGFuZGxlIGRlZmF1bHQgZGlyZWN0aW9uXG4gICAgY29uc3QgZGVmYXVsdERpcmVjdGlvbiA9IGFjdGl2ZUN0eFsnQGRpcmVjdGlvbiddO1xuXG4gICAgLy8gY3JlYXRlIHRlcm0gc2VsZWN0aW9ucyBmb3IgZWFjaCBtYXBwaW5nIGluIHRoZSBjb250ZXh0LCBvcmRlcmVkIGJ5XG4gICAgLy8gc2hvcnRlc3QgYW5kIHRoZW4gbGV4aWNvZ3JhcGhpY2FsbHkgbGVhc3RcbiAgICBjb25zdCBtYXBwaW5ncyA9IGFjdGl2ZUN0eC5tYXBwaW5ncztcbiAgICBjb25zdCB0ZXJtcyA9IFsuLi5tYXBwaW5ncy5rZXlzKCldLnNvcnQoX2NvbXBhcmVTaG9ydGVzdExlYXN0KTtcbiAgICBmb3IoY29uc3QgdGVybSBvZiB0ZXJtcykge1xuICAgICAgY29uc3QgbWFwcGluZyA9IG1hcHBpbmdzLmdldCh0ZXJtKTtcbiAgICAgIGlmKG1hcHBpbmcgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBjb250YWluZXIgPSBtYXBwaW5nWydAY29udGFpbmVyJ10gfHwgJ0Bub25lJztcbiAgICAgIGNvbnRhaW5lciA9IFtdLmNvbmNhdChjb250YWluZXIpLnNvcnQoKS5qb2luKCcnKTtcblxuICAgICAgaWYobWFwcGluZ1snQGlkJ10gPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBpdGVyYXRlIG92ZXIgZXZlcnkgSVJJIGluIHRoZSBtYXBwaW5nXG4gICAgICBjb25zdCBpZHMgPSBfYXNBcnJheShtYXBwaW5nWydAaWQnXSk7XG4gICAgICBmb3IoY29uc3QgaXJpIG9mIGlkcykge1xuICAgICAgICBsZXQgZW50cnkgPSBpbnZlcnNlW2lyaV07XG4gICAgICAgIGNvbnN0IGlzS2V5d29yZCA9IGFwaS5pc0tleXdvcmQoaXJpKTtcblxuICAgICAgICBpZighZW50cnkpIHtcbiAgICAgICAgICAvLyBpbml0aWFsaXplIGVudHJ5XG4gICAgICAgICAgaW52ZXJzZVtpcmldID0gZW50cnkgPSB7fTtcblxuICAgICAgICAgIGlmKCFpc0tleXdvcmQgJiYgIW1hcHBpbmcuX3Rlcm1IYXNDb2xvbikge1xuICAgICAgICAgICAgLy8gaW5pdCBJUkkgdG8gdGVybSBtYXAgYW5kIGZhc3QgQ1VSSUUgcHJlZml4ZXNcbiAgICAgICAgICAgIGlyaXNUb1Rlcm1zW2lyaV0gPSBbdGVybV07XG4gICAgICAgICAgICBjb25zdCBmYXN0Q3VyaWVFbnRyeSA9IHtpcmksIHRlcm1zOiBpcmlzVG9UZXJtc1tpcmldfTtcbiAgICAgICAgICAgIGlmKGlyaVswXSBpbiBmYXN0Q3VyaWVNYXApIHtcbiAgICAgICAgICAgICAgZmFzdEN1cmllTWFwW2lyaVswXV0ucHVzaChmYXN0Q3VyaWVFbnRyeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmYXN0Q3VyaWVNYXBbaXJpWzBdXSA9IFtmYXN0Q3VyaWVFbnRyeV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIWlzS2V5d29yZCAmJiAhbWFwcGluZy5fdGVybUhhc0NvbG9uKSB7XG4gICAgICAgICAgLy8gYWRkIElSSSB0byB0ZXJtIG1hdGNoXG4gICAgICAgICAgaXJpc1RvVGVybXNbaXJpXS5wdXNoKHRlcm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIG5ldyBlbnRyeVxuICAgICAgICBpZighZW50cnlbY29udGFpbmVyXSkge1xuICAgICAgICAgIGVudHJ5W2NvbnRhaW5lcl0gPSB7XG4gICAgICAgICAgICAnQGxhbmd1YWdlJzoge30sXG4gICAgICAgICAgICAnQHR5cGUnOiB7fSxcbiAgICAgICAgICAgICdAYW55Jzoge31cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5ID0gZW50cnlbY29udGFpbmVyXTtcbiAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BhbnknXSwgJ0Bub25lJyk7XG5cbiAgICAgICAgaWYobWFwcGluZy5yZXZlcnNlKSB7XG4gICAgICAgICAgLy8gdGVybSBpcyBwcmVmZXJyZWQgZm9yIHZhbHVlcyB1c2luZyBAcmV2ZXJzZVxuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAdHlwZSddLCAnQHJldmVyc2UnKTtcbiAgICAgICAgfSBlbHNlIGlmKG1hcHBpbmdbJ0B0eXBlJ10gPT09ICdAbm9uZScpIHtcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGFueSddLCAnQG5vbmUnKTtcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sICdAbm9uZScpO1xuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAdHlwZSddLCAnQG5vbmUnKTtcbiAgICAgICAgfSBlbHNlIGlmKCdAdHlwZScgaW4gbWFwcGluZykge1xuICAgICAgICAgIC8vIHRlcm0gaXMgcHJlZmVycmVkIGZvciB2YWx1ZXMgdXNpbmcgc3BlY2lmaWMgdHlwZVxuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAdHlwZSddLCBtYXBwaW5nWydAdHlwZSddKTtcbiAgICAgICAgfSBlbHNlIGlmKCdAbGFuZ3VhZ2UnIGluIG1hcHBpbmcgJiYgJ0BkaXJlY3Rpb24nIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAvLyB0ZXJtIGlzIHByZWZlcnJlZCBmb3IgdmFsdWVzIHVzaW5nIHNwZWNpZmljIGxhbmd1YWdlIGFuZCBkaXJlY3Rpb25cbiAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IG1hcHBpbmdbJ0BsYW5ndWFnZSddO1xuICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG1hcHBpbmdbJ0BkaXJlY3Rpb24nXTtcbiAgICAgICAgICBpZihsYW5ndWFnZSAmJiBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSxcbiAgICAgICAgICAgICAgYCR7bGFuZ3VhZ2V9XyR7ZGlyZWN0aW9ufWAudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sIGxhbmd1YWdlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSBpZihkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSwgYF8ke2RpcmVjdGlvbn1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLCAnQG51bGwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZignQGxhbmd1YWdlJyBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLFxuICAgICAgICAgICAgKG1hcHBpbmdbJ0BsYW5ndWFnZSddIHx8ICdAbnVsbCcpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9IGVsc2UgaWYoJ0BkaXJlY3Rpb24nIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICBpZihtYXBwaW5nWydAZGlyZWN0aW9uJ10pIHtcbiAgICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSxcbiAgICAgICAgICAgICAgYF8ke21hcHBpbmdbJ0BkaXJlY3Rpb24nXX1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLCAnQG5vbmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihkZWZhdWx0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLCBgXyR7ZGVmYXVsdERpcmVjdGlvbn1gKTtcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sICdAbm9uZScpO1xuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAdHlwZSddLCAnQG5vbmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgZW50cmllcyBmb3Igbm8gdHlwZSBhbmQgbm8gbGFuZ3VhZ2VcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sIGRlZmF1bHRMYW5ndWFnZSk7XG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLCAnQG5vbmUnKTtcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQHR5cGUnXSwgJ0Bub25lJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBidWlsZCBmYXN0IENVUklFIG1hcFxuICAgIGZvcihjb25zdCBrZXkgaW4gZmFzdEN1cmllTWFwKSB7XG4gICAgICBfYnVpbGRJcmlNYXAoZmFzdEN1cmllTWFwLCBrZXksIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnZlcnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSByZWN1cnNpdmUgYWxnb3JpdGhtIHRvIGJ1aWxkIGEgbG9va3VwIG1hcCBmb3IgcXVpY2tseSBmaW5kaW5nXG4gICAqIHBvdGVudGlhbCBDVVJJRXMuXG4gICAqXG4gICAqIEBwYXJhbSBpcmlNYXAgdGhlIG1hcCB0byBidWlsZC5cbiAgICogQHBhcmFtIGtleSB0aGUgY3VycmVudCBrZXkgaW4gdGhlIG1hcCB0byB3b3JrIG9uLlxuICAgKiBAcGFyYW0gaWR4IHRoZSBpbmRleCBpbnRvIHRoZSBJUkkgdG8gY29tcGFyZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9idWlsZElyaU1hcChpcmlNYXAsIGtleSwgaWR4KSB7XG4gICAgY29uc3QgZW50cmllcyA9IGlyaU1hcFtrZXldO1xuICAgIGNvbnN0IG5leHQgPSBpcmlNYXBba2V5XSA9IHt9O1xuXG4gICAgbGV0IGlyaTtcbiAgICBsZXQgbGV0dGVyO1xuICAgIGZvcihjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICBpcmkgPSBlbnRyeS5pcmk7XG4gICAgICBpZihpZHggPj0gaXJpLmxlbmd0aCkge1xuICAgICAgICBsZXR0ZXIgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldHRlciA9IGlyaVtpZHhdO1xuICAgICAgfVxuICAgICAgaWYobGV0dGVyIGluIG5leHQpIHtcbiAgICAgICAgbmV4dFtsZXR0ZXJdLnB1c2goZW50cnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFtsZXR0ZXJdID0gW2VudHJ5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICAgIGlmKGtleSA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBfYnVpbGRJcmlNYXAobmV4dCwga2V5LCBpZHggKyAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgdGVybSBmb3IgdGhlIGdpdmVuIGVudHJ5IGlmIG5vdCBhbHJlYWR5IGFkZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gdGVybSB0aGUgdGVybSB0byBhZGQuXG4gICAqIEBwYXJhbSBlbnRyeSB0aGUgaW52ZXJzZSBjb250ZXh0IHR5cGVPckxhbmd1YWdlIGVudHJ5IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHR5cGVPckxhbmd1YWdlVmFsdWUgdGhlIGtleSBpbiB0aGUgZW50cnkgdG8gYWRkIHRvLlxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnksIHR5cGVPckxhbmd1YWdlVmFsdWUpIHtcbiAgICBpZighZW50cnkuaGFzT3duUHJvcGVydHkodHlwZU9yTGFuZ3VhZ2VWYWx1ZSkpIHtcbiAgICAgIGVudHJ5W3R5cGVPckxhbmd1YWdlVmFsdWVdID0gdGVybTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIGFuIGFjdGl2ZSBjb250ZXh0LCBjcmVhdGluZyBhIGNoaWxkIGFjdGl2ZSBjb250ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJuIGEgY2xvbmUgKGNoaWxkKSBvZiB0aGUgYWN0aXZlIGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBfY2xvbmVBY3RpdmVDb250ZXh0KCkge1xuICAgIGNvbnN0IGNoaWxkID0ge307XG4gICAgY2hpbGQubWFwcGluZ3MgPSB1dGlsLmNsb25lKHRoaXMubWFwcGluZ3MpO1xuICAgIGNoaWxkLmNsb25lID0gdGhpcy5jbG9uZTtcbiAgICBjaGlsZC5pbnZlcnNlID0gbnVsbDtcbiAgICBjaGlsZC5nZXRJbnZlcnNlID0gdGhpcy5nZXRJbnZlcnNlO1xuICAgIGNoaWxkLnByb3RlY3RlZCA9IHV0aWwuY2xvbmUodGhpcy5wcm90ZWN0ZWQpO1xuICAgIGlmKHRoaXMucHJldmlvdXNDb250ZXh0KSB7XG4gICAgICBjaGlsZC5wcmV2aW91c0NvbnRleHQgPSB0aGlzLnByZXZpb3VzQ29udGV4dC5jbG9uZSgpO1xuICAgIH1cbiAgICBjaGlsZC5yZXZlcnRUb1ByZXZpb3VzQ29udGV4dCA9IHRoaXMucmV2ZXJ0VG9QcmV2aW91c0NvbnRleHQ7XG4gICAgaWYoJ0BiYXNlJyBpbiB0aGlzKSB7XG4gICAgICBjaGlsZFsnQGJhc2UnXSA9IHRoaXNbJ0BiYXNlJ107XG4gICAgfVxuICAgIGlmKCdAbGFuZ3VhZ2UnIGluIHRoaXMpIHtcbiAgICAgIGNoaWxkWydAbGFuZ3VhZ2UnXSA9IHRoaXNbJ0BsYW5ndWFnZSddO1xuICAgIH1cbiAgICBpZignQHZvY2FiJyBpbiB0aGlzKSB7XG4gICAgICBjaGlsZFsnQHZvY2FiJ10gPSB0aGlzWydAdm9jYWInXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldmVydHMgYW55IHR5cGUtc2NvcGVkIGNvbnRleHQgaW4gdGhpcyBhY3RpdmUgY29udGV4dCB0byB0aGUgcHJldmlvdXNcbiAgICogY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXZlcnRUb1ByZXZpb3VzQ29udGV4dCgpIHtcbiAgICBpZighdGhpcy5wcmV2aW91c0NvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmV2aW91c0NvbnRleHQuY2xvbmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGFjdGl2ZSBjb250ZXh0IGtleSBhbmQgdHlwZSwgbnVsbCBpZiBub25lIGlzXG4gKiBzZXQgb3IgdW5kZWZpbmVkIGlmIG5vbmUgaXMgc2V0IGFuZCB0eXBlIGlzICdAY29udGV4dCcuXG4gKlxuICogQHBhcmFtIGN0eCB0aGUgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0ga2V5IHRoZSBjb250ZXh0IGtleS5cbiAqIEBwYXJhbSBbdHlwZV0gdGhlIHR5cGUgb2YgdmFsdWUgdG8gZ2V0IChlZzogJ0BpZCcsICdAdHlwZScpLCBpZiBub3RcbiAqICAgICAgICAgIHNwZWNpZmllZCBnZXRzIHRoZSBlbnRpcmUgZW50cnkgZm9yIGEga2V5LCBudWxsIGlmIG5vdCBmb3VuZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB2YWx1ZSwgbnVsbCwgb3IgdW5kZWZpbmVkLlxuICovXG5hcGkuZ2V0Q29udGV4dFZhbHVlID0gKGN0eCwga2V5LCB0eXBlKSA9PiB7XG4gIC8vIGludmFsaWQga2V5XG4gIGlmKGtleSA9PT0gbnVsbCkge1xuICAgIGlmKHR5cGUgPT09ICdAY29udGV4dCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gZ2V0IHNwZWNpZmljIGVudHJ5IGluZm9ybWF0aW9uXG4gIGlmKGN0eC5tYXBwaW5ncy5oYXMoa2V5KSkge1xuICAgIGNvbnN0IGVudHJ5ID0gY3R4Lm1hcHBpbmdzLmdldChrZXkpO1xuXG4gICAgaWYoX2lzVW5kZWZpbmVkKHR5cGUpKSB7XG4gICAgICAvLyByZXR1cm4gd2hvbGUgZW50cnlcbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gICAgaWYoZW50cnkuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgIC8vIHJldHVybiBlbnRyeSB2YWx1ZSBmb3IgdHlwZVxuICAgICAgcmV0dXJuIGVudHJ5W3R5cGVdO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdldCBkZWZhdWx0IGxhbmd1YWdlXG4gIGlmKHR5cGUgPT09ICdAbGFuZ3VhZ2UnICYmIHR5cGUgaW4gY3R4KSB7XG4gICAgcmV0dXJuIGN0eFt0eXBlXTtcbiAgfVxuXG4gIC8vIGdldCBkZWZhdWx0IGRpcmVjdGlvblxuICBpZih0eXBlID09PSAnQGRpcmVjdGlvbicgJiYgdHlwZSBpbiBjdHgpIHtcbiAgICByZXR1cm4gY3R4W3R5cGVdO1xuICB9XG5cbiAgaWYodHlwZSA9PT0gJ0Bjb250ZXh0Jykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFByb2Nlc3NpbmcgTW9kZSBjaGVjay5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBjdXJyZW50IGFjdGl2ZSBjb250ZXh0LlxuICogQHBhcmFtIHZlcnNpb24gdGhlIHN0cmluZyBvciBudW1lcmljIHZlcnNpb24gdG8gY2hlY2suXG4gKlxuICogQHJldHVybiBib29sZWFuLlxuICovXG5hcGkucHJvY2Vzc2luZ01vZGUgPSAoYWN0aXZlQ3R4LCB2ZXJzaW9uKSA9PiB7XG4gIGlmKHZlcnNpb24udG9TdHJpbmcoKSA+PSAnMS4xJykge1xuICAgIHJldHVybiAhYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlIHx8XG4gICAgICBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgPj0gJ2pzb24tbGQtJyArIHZlcnNpb24udG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlID09PSAnanNvbi1sZC0xLjAnO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIHZhbHVlIGlzIGEga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGtleXdvcmQsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzS2V5d29yZCA9IHYgPT4ge1xuICBpZighX2lzU3RyaW5nKHYpIHx8IHZbMF0gIT09ICdAJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2godikge1xuICAgIGNhc2UgJ0BiYXNlJzpcbiAgICBjYXNlICdAY29udGFpbmVyJzpcbiAgICBjYXNlICdAY29udGV4dCc6XG4gICAgY2FzZSAnQGRlZmF1bHQnOlxuICAgIGNhc2UgJ0BkaXJlY3Rpb24nOlxuICAgIGNhc2UgJ0BlbWJlZCc6XG4gICAgY2FzZSAnQGV4cGxpY2l0JzpcbiAgICBjYXNlICdAZ3JhcGgnOlxuICAgIGNhc2UgJ0BpZCc6XG4gICAgY2FzZSAnQGluY2x1ZGVkJzpcbiAgICBjYXNlICdAaW5kZXgnOlxuICAgIGNhc2UgJ0Bqc29uJzpcbiAgICBjYXNlICdAbGFuZ3VhZ2UnOlxuICAgIGNhc2UgJ0BsaXN0JzpcbiAgICBjYXNlICdAbmVzdCc6XG4gICAgY2FzZSAnQG5vbmUnOlxuICAgIGNhc2UgJ0BvbWl0RGVmYXVsdCc6XG4gICAgY2FzZSAnQHByZWZpeCc6XG4gICAgY2FzZSAnQHByZXNlcnZlJzpcbiAgICBjYXNlICdAcHJvdGVjdGVkJzpcbiAgICBjYXNlICdAcmVxdWlyZUFsbCc6XG4gICAgY2FzZSAnQHJldmVyc2UnOlxuICAgIGNhc2UgJ0BzZXQnOlxuICAgIGNhc2UgJ0B0eXBlJzpcbiAgICBjYXNlICdAdmFsdWUnOlxuICAgIGNhc2UgJ0B2ZXJzaW9uJzpcbiAgICBjYXNlICdAdm9jYWInOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gX2RlZXBDb21wYXJlKHgxLCB4Mikge1xuICAvLyBjb21wYXJlIGBudWxsYCBvciBwcmltaXRpdmUgdHlwZXMgZGlyZWN0bHlcbiAgaWYoKCEoeDEgJiYgdHlwZW9mIHgxID09PSAnb2JqZWN0JykpIHx8XG4gICAgICghKHgyICYmIHR5cGVvZiB4MiA9PT0gJ29iamVjdCcpKSkge1xuICAgIHJldHVybiB4MSA9PT0geDI7XG4gIH1cbiAgLy8geDEgYW5kIHgyIGFyZSBvYmplY3RzIChhbHNvIHBvdGVudGlhbGx5IGFycmF5cylcbiAgY29uc3QgeDFBcnJheSA9IEFycmF5LmlzQXJyYXkoeDEpO1xuICBpZih4MUFycmF5ICE9PSBBcnJheS5pc0FycmF5KHgyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZih4MUFycmF5KSB7XG4gICAgaWYoeDEubGVuZ3RoICE9PSB4Mi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHgxLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZighX2RlZXBDb21wYXJlKHgxW2ldLCB4MltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyB4MSBhbmQgeDIgYXJlIG5vbi1hcnJheSBvYmplY3RzXG4gIGNvbnN0IGsxcyA9IE9iamVjdC5rZXlzKHgxKTtcbiAgY29uc3QgazJzID0gT2JqZWN0LmtleXMoeDIpO1xuICBpZihrMXMubGVuZ3RoICE9PSBrMnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvcihjb25zdCBrMSBpbiB4MSkge1xuICAgIGxldCB2MSA9IHgxW2sxXTtcbiAgICBsZXQgdjIgPSB4MltrMV07XG4gICAgLy8gc3BlY2lhbCBjYXNlOiBgQGNvbnRhaW5lcmAgY2FuIGJlIGluIGFueSBvcmRlclxuICAgIGlmKGsxID09PSAnQGNvbnRhaW5lcicpIHtcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkodjEpICYmIEFycmF5LmlzQXJyYXkodjIpKSB7XG4gICAgICAgIHYxID0gdjEuc2xpY2UoKS5zb3J0KCk7XG4gICAgICAgIHYyID0gdjIuc2xpY2UoKS5zb3J0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKCFfZGVlcENvbXBhcmUodjEsIHYyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7cGFyc2VMaW5rSGVhZGVyLCBidWlsZEhlYWRlcnN9ID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3Qge0xJTktfSEVBREVSX0NPTlRFWFR9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4uL0pzb25MZEVycm9yJyk7XG5jb25zdCBSZXF1ZXN0UXVldWUgPSByZXF1aXJlKCcuLi9SZXF1ZXN0UXVldWUnKTtcbmNvbnN0IHtwcmVwZW5kQmFzZX0gPSByZXF1aXJlKCcuLi91cmwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYnVpbHQtaW4gbm9kZSBkb2N1bWVudCBsb2FkZXIuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgc2VjdXJlOiByZXF1aXJlIGFsbCBVUkxzIHRvIHVzZSBIVFRQUy5cbiAqICAgICAgICAgIHN0cmljdFNTTDogdHJ1ZSB0byByZXF1aXJlIFNTTCBjZXJ0aWZpY2F0ZXMgdG8gYmUgdmFsaWQsXG4gKiAgICAgICAgICAgIGZhbHNlIG5vdCB0byAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBtYXhSZWRpcmVjdHM6IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHMgdG8gcGVybWl0LCBub25lIGJ5XG4gKiAgICAgICAgICAgIGRlZmF1bHQuXG4gKiAgICAgICAgICByZXF1ZXN0OiB0aGUgb2JqZWN0IHdoaWNoIHdpbGwgbWFrZSB0aGUgcmVxdWVzdCwgZGVmYXVsdCBpc1xuICogICAgICAgICAgICBwcm92aWRlZCBieSBgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVxdWVzdGAuXG4gKiAgICAgICAgICBoZWFkZXJzOiBhbiBvYmplY3QgKG1hcCkgb2YgaGVhZGVycyB3aGljaCB3aWxsIGJlIHBhc3NlZCBhcyByZXF1ZXN0XG4gKiAgICAgICAgICAgIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgZG9jdW1lbnQuIEFjY2VwdCBpcyBub3QgYWxsb3dlZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBub2RlIGRvY3VtZW50IGxvYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoe1xuICBzZWN1cmUsXG4gIHN0cmljdFNTTCA9IHRydWUsXG4gIG1heFJlZGlyZWN0cyA9IC0xLFxuICByZXF1ZXN0LFxuICBoZWFkZXJzID0ge31cbn0gPSB7c3RyaWN0U1NMOiB0cnVlLCBtYXhSZWRpcmVjdHM6IC0xLCBoZWFkZXJzOiB7fX0pID0+IHtcbiAgaGVhZGVycyA9IGJ1aWxkSGVhZGVycyhoZWFkZXJzKTtcbiAgLy8gVE9ETzogdXNlIGBheGlvc2BcbiAgcmVxdWVzdCA9IHJlcXVlc3QgfHwgcmVxdWlyZSgncmVxdWVzdCcpO1xuICBjb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuXG4gIGNvbnN0IHF1ZXVlID0gbmV3IFJlcXVlc3RRdWV1ZSgpO1xuICByZXR1cm4gcXVldWUud3JhcExvYWRlcihmdW5jdGlvbih1cmwpIHtcbiAgICByZXR1cm4gbG9hZERvY3VtZW50KHVybCwgW10pO1xuICB9KTtcblxuICBhc3luYyBmdW5jdGlvbiBsb2FkRG9jdW1lbnQodXJsLCByZWRpcmVjdHMpIHtcbiAgICBpZih1cmwuaW5kZXhPZignaHR0cDonKSAhPT0gMCAmJiB1cmwuaW5kZXhPZignaHR0cHM6JykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkOyBvbmx5IFwiaHR0cFwiIGFuZCBcImh0dHBzXCIgVVJMcyBhcmUgJyArXG4gICAgICAgICdzdXBwb3J0ZWQuJyxcbiAgICAgICAgJ2pzb25sZC5JbnZhbGlkVXJsJywge2NvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsIHVybH0pO1xuICAgIH1cbiAgICBpZihzZWN1cmUgJiYgdXJsLmluZGV4T2YoJ2h0dHBzJykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkOyBzZWN1cmUgbW9kZSBpcyBlbmFibGVkIGFuZCAnICtcbiAgICAgICAgJ3RoZSBVUkxcXCdzIHNjaGVtZSBpcyBub3QgXCJodHRwc1wiLicsXG4gICAgICAgICdqc29ubGQuSW52YWxpZFVybCcsIHtjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLCB1cmx9KTtcbiAgICB9XG4gICAgLy8gVE9ETzogZGlzYWJsZSBjYWNoZSB1bnRpbCBIVFRQIGNhY2hpbmcgaW1wbGVtZW50ZWRcbiAgICBsZXQgZG9jID0gbnVsbDsvL2NhY2hlLmdldCh1cmwpO1xuICAgIGlmKGRvYyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBhbHRlcm5hdGUgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBfcmVxdWVzdChyZXF1ZXN0LCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc3RyaWN0U1NMLFxuICAgICAgICBmb2xsb3dSZWRpcmVjdDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQsIGFuIGVycm9yIG9jY3VycmVkLicsXG4gICAgICAgICdqc29ubGQuTG9hZERvY3VtZW50RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2xvYWRpbmcgZG9jdW1lbnQgZmFpbGVkJywgdXJsLCBjYXVzZTogZX0pO1xuICAgIH1cblxuICAgIGNvbnN0IHtyZXMsIGJvZHl9ID0gcmVzdWx0O1xuXG4gICAgZG9jID0ge2NvbnRleHRVcmw6IG51bGwsIGRvY3VtZW50VXJsOiB1cmwsIGRvY3VtZW50OiBib2R5IHx8IG51bGx9O1xuXG4gICAgLy8gaGFuZGxlIGVycm9yXG4gICAgY29uc3Qgc3RhdHVzVGV4dCA9IGh0dHAuU1RBVFVTX0NPREVTW3Jlcy5zdGF0dXNDb2RlXTtcbiAgICBpZihyZXMuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgYFVSTCBcIiR7dXJsfVwiIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQ6ICR7c3RhdHVzVGV4dH1gLFxuICAgICAgICAnanNvbmxkLkludmFsaWRVcmwnLCB7XG4gICAgICAgICAgY29kZTogJ2xvYWRpbmcgZG9jdW1lbnQgZmFpbGVkJyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgaHR0cFN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBMaW5rIEhlYWRlclxuICAgIGlmKHJlcy5oZWFkZXJzLmxpbmsgJiZcbiAgICAgIHJlcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSAhPT0gJ2FwcGxpY2F0aW9uL2xkK2pzb24nKSB7XG4gICAgICAvLyBvbmx5IDEgcmVsYXRlZCBsaW5rIGhlYWRlciBwZXJtaXR0ZWRcbiAgICAgIGNvbnN0IGxpbmtIZWFkZXJzID0gcGFyc2VMaW5rSGVhZGVyKHJlcy5oZWFkZXJzLmxpbmspO1xuICAgICAgY29uc3QgbGlua2VkQ29udGV4dCA9IGxpbmtIZWFkZXJzW0xJTktfSEVBREVSX0NPTlRFWFRdO1xuICAgICAgaWYoQXJyYXkuaXNBcnJheShsaW5rZWRDb250ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkLCBpdCBoYXMgbW9yZSB0aGFuIG9uZSBhc3NvY2lhdGVkICcgK1xuICAgICAgICAgICdIVFRQIExpbmsgSGVhZGVyLicsXG4gICAgICAgICAgJ2pzb25sZC5JbnZhbGlkVXJsJyxcbiAgICAgICAgICB7Y29kZTogJ211bHRpcGxlIGNvbnRleHQgbGluayBoZWFkZXJzJywgdXJsfSk7XG4gICAgICB9XG4gICAgICBpZihsaW5rZWRDb250ZXh0KSB7XG4gICAgICAgIGRvYy5jb250ZXh0VXJsID0gbGlua2VkQ29udGV4dC50YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiYWx0ZXJuYXRlXCIgbGluayBoZWFkZXIgaXMgYSByZWRpcmVjdFxuICAgICAgYWx0ZXJuYXRlID0gbGlua0hlYWRlcnNbJ2FsdGVybmF0ZSddO1xuICAgICAgaWYoYWx0ZXJuYXRlICYmXG4gICAgICAgIGFsdGVybmF0ZS50eXBlID09ICdhcHBsaWNhdGlvbi9sZCtqc29uJyAmJlxuICAgICAgICAhKHJlcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnJylcbiAgICAgICAgICAubWF0Y2goL15hcHBsaWNhdGlvblxcLyhcXHcqXFwrKT9qc29uJC8pKSB7XG4gICAgICAgIHJlcy5oZWFkZXJzLmxvY2F0aW9uID0gcHJlcGVuZEJhc2UodXJsLCBhbHRlcm5hdGUudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcmVkaXJlY3RcbiAgICBpZigoYWx0ZXJuYXRlIHx8XG4gICAgICByZXMuc3RhdHVzQ29kZSA+PSAzMDAgJiYgcmVzLnN0YXR1c0NvZGUgPCA0MDApICYmIHJlcy5oZWFkZXJzLmxvY2F0aW9uKSB7XG4gICAgICBpZihyZWRpcmVjdHMubGVuZ3RoID09PSBtYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdVUkwgY291bGQgbm90IGJlIGRlcmVmZXJlbmNlZDsgdGhlcmUgd2VyZSB0b28gbWFueSByZWRpcmVjdHMuJyxcbiAgICAgICAgICAnanNvbmxkLlRvb01hbnlSZWRpcmVjdHMnLCB7XG4gICAgICAgICAgICBjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgaHR0cFN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgcmVkaXJlY3RzXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZihyZWRpcmVjdHMuaW5kZXhPZih1cmwpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkOyBpbmZpbml0ZSByZWRpcmVjdGlvbiB3YXMgZGV0ZWN0ZWQuJyxcbiAgICAgICAgICAnanNvbmxkLkluZmluaXRlUmVkaXJlY3REZXRlY3RlZCcsIHtcbiAgICAgICAgICAgIGNvZGU6ICdyZWN1cnNpdmUgY29udGV4dCBpbmNsdXNpb24nLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgaHR0cFN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgcmVkaXJlY3RzXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZWRpcmVjdHMucHVzaCh1cmwpO1xuICAgICAgcmV0dXJuIGxvYWREb2N1bWVudChyZXMuaGVhZGVycy5sb2NhdGlvbiwgcmVkaXJlY3RzKTtcbiAgICB9XG5cbiAgICAvLyBjYWNoZSBmb3IgZWFjaCByZWRpcmVjdGVkIFVSTFxuICAgIHJlZGlyZWN0cy5wdXNoKHVybCk7XG4gICAgLy8gVE9ETzogZGlzYWJsZSBjYWNoZSB1bnRpbCBIVFRQIGNhY2hpbmcgaW1wbGVtZW50ZWRcbiAgICAvKlxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCByZWRpcmVjdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNhY2hlLnNldChcbiAgICAgICAgcmVkaXJlY3RzW2ldLFxuICAgICAgICB7Y29udGV4dFVybDogbnVsbCwgZG9jdW1lbnRVcmw6IHJlZGlyZWN0c1tpXSwgZG9jdW1lbnQ6IGJvZHl9KTtcbiAgICB9XG4gICAgKi9cblxuICAgIHJldHVybiBkb2M7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9yZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXF1ZXN0KG9wdGlvbnMsIChlcnIsIHJlcywgYm9keSkgPT4ge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh7cmVzLCBib2R5fSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtwYXJzZUxpbmtIZWFkZXIsIGJ1aWxkSGVhZGVyc30gPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCB7TElOS19IRUFERVJfQ09OVEVYVH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcbmNvbnN0IEpzb25MZEVycm9yID0gcmVxdWlyZSgnLi4vSnNvbkxkRXJyb3InKTtcbmNvbnN0IFJlcXVlc3RRdWV1ZSA9IHJlcXVpcmUoJy4uL1JlcXVlc3RRdWV1ZScpO1xuY29uc3Qge3ByZXBlbmRCYXNlfSA9IHJlcXVpcmUoJy4uL3VybCcpO1xuXG5jb25zdCBSRUdFWF9MSU5LX0hFQURFUiA9IC8oXnwoXFxyXFxuKSlsaW5rOi9pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBidWlsdC1pbiBYTUxIdHRwUmVxdWVzdCBkb2N1bWVudCBsb2FkZXIuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgc2VjdXJlOiByZXF1aXJlIGFsbCBVUkxzIHRvIHVzZSBIVFRQUy5cbiAqICAgICAgICAgIGhlYWRlcnM6IGFuIG9iamVjdCAobWFwKSBvZiBoZWFkZXJzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGFzIHJlcXVlc3RcbiAqICAgICAgICAgICAgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3RlZCBkb2N1bWVudC4gQWNjZXB0IGlzIG5vdCBhbGxvd2VkLlxuICogICAgICAgICAgW3hocl06IHRoZSBYTUxIdHRwUmVxdWVzdCBBUEkgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIFhNTEh0dHBSZXF1ZXN0IGRvY3VtZW50IGxvYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoe1xuICBzZWN1cmUsXG4gIGhlYWRlcnMgPSB7fSxcbiAgeGhyXG59ID0ge2hlYWRlcnM6IHt9fSkgPT4ge1xuICBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKGhlYWRlcnMpO1xuICBjb25zdCBxdWV1ZSA9IG5ldyBSZXF1ZXN0UXVldWUoKTtcbiAgcmV0dXJuIHF1ZXVlLndyYXBMb2FkZXIobG9hZGVyKTtcblxuICBhc3luYyBmdW5jdGlvbiBsb2FkZXIodXJsKSB7XG4gICAgaWYodXJsLmluZGV4T2YoJ2h0dHA6JykgIT09IDAgJiYgdXJsLmluZGV4T2YoJ2h0dHBzOicpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdVUkwgY291bGQgbm90IGJlIGRlcmVmZXJlbmNlZDsgb25seSBcImh0dHBcIiBhbmQgXCJodHRwc1wiIFVSTHMgYXJlICcgK1xuICAgICAgICAnc3VwcG9ydGVkLicsXG4gICAgICAgICdqc29ubGQuSW52YWxpZFVybCcsIHtjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLCB1cmx9KTtcbiAgICB9XG4gICAgaWYoc2VjdXJlICYmIHVybC5pbmRleE9mKCdodHRwcycpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdVUkwgY291bGQgbm90IGJlIGRlcmVmZXJlbmNlZDsgc2VjdXJlIG1vZGUgaXMgZW5hYmxlZCBhbmQgJyArXG4gICAgICAgICd0aGUgVVJMXFwncyBzY2hlbWUgaXMgbm90IFwiaHR0cHNcIi4nLFxuICAgICAgICAnanNvbmxkLkludmFsaWRVcmwnLCB7Y29kZTogJ2xvYWRpbmcgZG9jdW1lbnQgZmFpbGVkJywgdXJsfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlcTtcbiAgICB0cnkge1xuICAgICAgcmVxID0gYXdhaXQgX2dldCh4aHIsIHVybCwgaGVhZGVycyk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdVUkwgY291bGQgbm90IGJlIGRlcmVmZXJlbmNlZCwgYW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICAgJ2pzb25sZC5Mb2FkRG9jdW1lbnRFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLCB1cmwsIGNhdXNlOiBlfSk7XG4gICAgfVxuXG4gICAgaWYocmVxLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkOiAnICsgcmVxLnN0YXR1c1RleHQsXG4gICAgICAgICdqc29ubGQuTG9hZERvY3VtZW50RXJyb3InLCB7XG4gICAgICAgICAgY29kZTogJ2xvYWRpbmcgZG9jdW1lbnQgZmFpbGVkJyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgaHR0cFN0YXR1c0NvZGU6IHJlcS5zdGF0dXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IGRvYyA9IHtjb250ZXh0VXJsOiBudWxsLCBkb2N1bWVudFVybDogdXJsLCBkb2N1bWVudDogcmVxLnJlc3BvbnNlfTtcbiAgICBsZXQgYWx0ZXJuYXRlID0gbnVsbDtcblxuICAgIC8vIGhhbmRsZSBMaW5rIEhlYWRlciAoYXZvaWQgdW5zYWZlIGhlYWRlciB3YXJuaW5nIGJ5IGV4aXN0ZW5jZSB0ZXN0aW5nKVxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVxLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICBsZXQgbGlua0hlYWRlcjtcbiAgICBpZihSRUdFWF9MSU5LX0hFQURFUi50ZXN0KHJlcS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgIGxpbmtIZWFkZXIgPSByZXEuZ2V0UmVzcG9uc2VIZWFkZXIoJ0xpbmsnKTtcbiAgICB9XG4gICAgaWYobGlua0hlYWRlciAmJiBjb250ZW50VHlwZSAhPT0gJ2FwcGxpY2F0aW9uL2xkK2pzb24nKSB7XG4gICAgICAvLyBvbmx5IDEgcmVsYXRlZCBsaW5rIGhlYWRlciBwZXJtaXR0ZWRcbiAgICAgIGNvbnN0IGxpbmtIZWFkZXJzID0gcGFyc2VMaW5rSGVhZGVyKGxpbmtIZWFkZXIpO1xuICAgICAgY29uc3QgbGlua2VkQ29udGV4dCA9IGxpbmtIZWFkZXJzW0xJTktfSEVBREVSX0NPTlRFWFRdO1xuICAgICAgaWYoQXJyYXkuaXNBcnJheShsaW5rZWRDb250ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkLCBpdCBoYXMgbW9yZSB0aGFuIG9uZSAnICtcbiAgICAgICAgICAnYXNzb2NpYXRlZCBIVFRQIExpbmsgSGVhZGVyLicsXG4gICAgICAgICAgJ2pzb25sZC5JbnZhbGlkVXJsJyxcbiAgICAgICAgICB7Y29kZTogJ211bHRpcGxlIGNvbnRleHQgbGluayBoZWFkZXJzJywgdXJsfSk7XG4gICAgICB9XG4gICAgICBpZihsaW5rZWRDb250ZXh0KSB7XG4gICAgICAgIGRvYy5jb250ZXh0VXJsID0gbGlua2VkQ29udGV4dC50YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiYWx0ZXJuYXRlXCIgbGluayBoZWFkZXIgaXMgYSByZWRpcmVjdFxuICAgICAgYWx0ZXJuYXRlID0gbGlua0hlYWRlcnNbJ2FsdGVybmF0ZSddO1xuICAgICAgaWYoYWx0ZXJuYXRlICYmXG4gICAgICAgIGFsdGVybmF0ZS50eXBlID09ICdhcHBsaWNhdGlvbi9sZCtqc29uJyAmJlxuICAgICAgICAhKGNvbnRlbnRUeXBlIHx8ICcnKS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvKFxcdypcXCspP2pzb24kLykpIHtcbiAgICAgICAgZG9jID0gYXdhaXQgbG9hZGVyKHByZXBlbmRCYXNlKHVybCwgYWx0ZXJuYXRlLnRhcmdldCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkb2M7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9nZXQoeGhyLCB1cmwsIGhlYWRlcnMpIHtcbiAgeGhyID0geGhyIHx8IFhNTEh0dHBSZXF1ZXN0O1xuICBjb25zdCByZXEgPSBuZXcgeGhyKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVxLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVxKTtcbiAgICByZXEub25lcnJvciA9IGVyciA9PiByZWplY3QoZXJyKTtcbiAgICByZXEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICBmb3IoY29uc3QgayBpbiBoZWFkZXJzKSB7XG4gICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihrLCBoZWFkZXJzW2tdKTtcbiAgICB9XG4gICAgcmVxLnNlbmQoKTtcbiAgfSk7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5cbmNvbnN0IHtcbiAgaXNBcnJheTogX2lzQXJyYXksXG4gIGlzT2JqZWN0OiBfaXNPYmplY3QsXG4gIGlzRW1wdHlPYmplY3Q6IF9pc0VtcHR5T2JqZWN0LFxuICBpc1N0cmluZzogX2lzU3RyaW5nLFxuICBpc1VuZGVmaW5lZDogX2lzVW5kZWZpbmVkXG59ID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5jb25zdCB7XG4gIGlzTGlzdDogX2lzTGlzdCxcbiAgaXNWYWx1ZTogX2lzVmFsdWUsXG4gIGlzR3JhcGg6IF9pc0dyYXBoLFxuICBpc1N1YmplY3Q6IF9pc1N1YmplY3Rcbn0gPSByZXF1aXJlKCcuL2dyYXBoVHlwZXMnKTtcblxuY29uc3Qge1xuICBleHBhbmRJcmk6IF9leHBhbmRJcmksXG4gIGdldENvbnRleHRWYWx1ZTogX2dldENvbnRleHRWYWx1ZSxcbiAgaXNLZXl3b3JkOiBfaXNLZXl3b3JkLFxuICBwcm9jZXNzOiBfcHJvY2Vzc0NvbnRleHQsXG4gIHByb2Nlc3NpbmdNb2RlOiBfcHJvY2Vzc2luZ01vZGVcbn0gPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcblxuY29uc3Qge1xuICBpc0Fic29sdXRlOiBfaXNBYnNvbHV0ZUlyaVxufSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbmNvbnN0IHtcbiAgYWRkVmFsdWU6IF9hZGRWYWx1ZSxcbiAgYXNBcnJheTogX2FzQXJyYXksXG4gIGdldFZhbHVlczogX2dldFZhbHVlcyxcbiAgdmFsaWRhdGVUeXBlVmFsdWU6IF92YWxpZGF0ZVR5cGVWYWx1ZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuY29uc3QgUkVHRVhfQkNQNDcgPSAvXlthLXpBLVpdezEsOH0oLVthLXpBLVowLTldezEsOH0pKiQvO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4cGFuZHMgYW4gZWxlbWVudCB1c2luZyB0aGUgZ2l2ZW4gY29udGV4dC4gQW55IGNvbnRleHQgaW5cbiAqIHRoZSBlbGVtZW50IHdpbGwgYmUgcmVtb3ZlZC4gQWxsIGNvbnRleHQgVVJMcyBtdXN0IGhhdmUgYmVlbiByZXRyaWV2ZWRcbiAqIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGNvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIGFjdGl2ZVByb3BlcnR5IHRoZSBwcm9wZXJ0eSBmb3IgdGhlIGVsZW1lbnQsIG51bGwgZm9yIG5vbmUuXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBleHBhbmQuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgZXhwYW5zaW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gaW5zaWRlTGlzdCB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGEgbGlzdCwgZmFsc2UgaWYgbm90LlxuICogQHBhcmFtIGluc2lkZUluZGV4IHRydWUgaWYgdGhlIGVsZW1lbnQgaXMgaW5zaWRlIGFuIGluZGV4IGNvbnRhaW5lcixcbiAqICAgICAgICAgIGZhbHNlIGlmIG5vdC5cbiAqIEBwYXJhbSB0eXBlU2NvcGVkQ29udGV4dCBhbiBvcHRpb25hbCB0eXBlLXNjb3BlZCBhY3RpdmUgY29udGV4dCBmb3JcbiAqICAgICAgICAgIGV4cGFuZGluZyB2YWx1ZXMgb2Ygbm9kZXMgdGhhdCB3ZXJlIGV4cHJlc3NlZCBhY2NvcmRpbmcgdG9cbiAqICAgICAgICAgIGEgdHlwZS1zY29wZWQgY29udGV4dC5cbiAqIEBwYXJhbSBleHBhbnNpb25NYXAoaW5mbykgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGN1c3RvbSBtYXBcbiAqICAgICAgICAgIHVubWFwcGFibGUgdmFsdWVzIChvciB0byB0aHJvdyBhbiBlcnJvciB3aGVuIHRoZXkgYXJlIGRldGVjdGVkKTtcbiAqICAgICAgICAgIGlmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCB0aGVuIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gKiAgICAgICAgICB3aWxsIGJlIHVzZWQuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZXhwYW5kZWQgdmFsdWUuXG4gKi9cbmFwaS5leHBhbmQgPSBhc3luYyAoe1xuICBhY3RpdmVDdHgsXG4gIGFjdGl2ZVByb3BlcnR5ID0gbnVsbCxcbiAgZWxlbWVudCxcbiAgb3B0aW9ucyA9IHt9LFxuICBpbnNpZGVMaXN0ID0gZmFsc2UsXG4gIGluc2lkZUluZGV4ID0gZmFsc2UsXG4gIHR5cGVTY29wZWRDb250ZXh0ID0gbnVsbCxcbiAgZXhwYW5zaW9uTWFwID0gKCkgPT4gdW5kZWZpbmVkXG59KSA9PiB7XG4gIC8vIG5vdGhpbmcgdG8gZXhwYW5kXG4gIGlmKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBkaXNhYmxlIGZyYW1pbmcgaWYgYWN0aXZlUHJvcGVydHkgaXMgQGRlZmF1bHRcbiAgaWYoYWN0aXZlUHJvcGVydHkgPT09ICdAZGVmYXVsdCcpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge2lzRnJhbWU6IGZhbHNlfSk7XG4gIH1cblxuICBpZighX2lzQXJyYXkoZWxlbWVudCkgJiYgIV9pc09iamVjdChlbGVtZW50KSkge1xuICAgIC8vIGRyb3AgZnJlZS1mbG9hdGluZyBzY2FsYXJzIHRoYXQgYXJlIG5vdCBpbiBsaXN0cyB1bmxlc3MgY3VzdG9tIG1hcHBlZFxuICAgIGlmKCFpbnNpZGVMaXN0ICYmIChhY3RpdmVQcm9wZXJ0eSA9PT0gbnVsbCB8fFxuICAgICAgX2V4cGFuZElyaShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCB7dm9jYWI6IHRydWV9LFxuICAgICAgICBvcHRpb25zKSA9PT0gJ0BncmFwaCcpKSB7XG4gICAgICBjb25zdCBtYXBwZWQgPSBhd2FpdCBleHBhbnNpb25NYXAoe1xuICAgICAgICB1bm1hcHBlZFZhbHVlOiBlbGVtZW50LFxuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpbnNpZGVMaXN0XG4gICAgICB9KTtcbiAgICAgIGlmKG1hcHBlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG5cbiAgICAvLyBleHBhbmQgZWxlbWVudCBhY2NvcmRpbmcgdG8gdmFsdWUgZXhwYW5zaW9uIHJ1bGVzXG4gICAgcmV0dXJuIF9leHBhbmRWYWx1ZSh7YWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgdmFsdWU6IGVsZW1lbnQsIG9wdGlvbnN9KTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2l2ZWx5IGV4cGFuZCBhcnJheVxuICBpZihfaXNBcnJheShlbGVtZW50KSkge1xuICAgIGxldCBydmFsID0gW107XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldENvbnRleHRWYWx1ZShcbiAgICAgIGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAY29udGFpbmVyJykgfHwgW107XG4gICAgaW5zaWRlTGlzdCA9IGluc2lkZUxpc3QgfHwgY29udGFpbmVyLmluY2x1ZGVzKCdAbGlzdCcpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbGVtZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyBleHBhbmQgZWxlbWVudFxuICAgICAgbGV0IGUgPSBhd2FpdCBhcGkuZXhwYW5kKHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudFtpXSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZXhwYW5zaW9uTWFwLFxuICAgICAgICBpbnNpZGVJbmRleCxcbiAgICAgICAgdHlwZVNjb3BlZENvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYoaW5zaWRlTGlzdCAmJiBfaXNBcnJheShlKSkge1xuICAgICAgICBlID0geydAbGlzdCc6IGV9O1xuICAgICAgfVxuXG4gICAgICBpZihlID09PSBudWxsKSB7XG4gICAgICAgIGUgPSBhd2FpdCBleHBhbnNpb25NYXAoe1xuICAgICAgICAgIHVubWFwcGVkVmFsdWU6IGVsZW1lbnRbaV0sXG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICAgIHBhcmVudDogZWxlbWVudCxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGV4cGFuZGVkUGFyZW50OiBydmFsLFxuICAgICAgICAgIGluc2lkZUxpc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKF9pc0FycmF5KGUpKSB7XG4gICAgICAgIHJ2YWwgPSBydmFsLmNvbmNhdChlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwucHVzaChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cblxuICAvLyByZWN1cnNpdmVseSBleHBhbmQgb2JqZWN0OlxuXG4gIC8vIGZpcnN0LCBleHBhbmQgdGhlIGFjdGl2ZSBwcm9wZXJ0eVxuICBjb25zdCBleHBhbmRlZEFjdGl2ZVByb3BlcnR5ID0gX2V4cGFuZElyaShcbiAgICBhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCB7dm9jYWI6IHRydWV9LCBvcHRpb25zKTtcblxuICAvLyBHZXQgYW55IHByb3BlcnR5LXNjb3BlZCBjb250ZXh0IGZvciBhY3RpdmVQcm9wZXJ0eVxuICBjb25zdCBwcm9wZXJ0eVNjb3BlZEN0eCA9XG4gICAgX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRleHQnKTtcblxuICAvLyBzZWNvbmQsIGRldGVybWluZSBpZiBhbnkgdHlwZS1zY29wZWQgY29udGV4dCBzaG91bGQgYmUgcmV2ZXJ0ZWQ7IGl0XG4gIC8vIHNob3VsZCBvbmx5IGJlIHJldmVydGVkIHdoZW4gdGhlIGZvbGxvd2luZyBhcmUgYWxsIHRydWU6XG4gIC8vIDEuIGBlbGVtZW50YCBpcyBub3QgYSB2YWx1ZSBvciBzdWJqZWN0IHJlZmVyZW5jZVxuICAvLyAyLiBgaW5zaWRlSW5kZXhgIGlzIGZhbHNlXG4gIHR5cGVTY29wZWRDb250ZXh0ID0gdHlwZVNjb3BlZENvbnRleHQgfHxcbiAgICAoYWN0aXZlQ3R4LnByZXZpb3VzQ29udGV4dCA/IGFjdGl2ZUN0eCA6IG51bGwpO1xuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQpLnNvcnQoKTtcbiAgbGV0IG11c3RSZXZlcnQgPSAhaW5zaWRlSW5kZXg7XG4gIGlmKG11c3RSZXZlcnQgJiYgdHlwZVNjb3BlZENvbnRleHQgJiYga2V5cy5sZW5ndGggPD0gMiAmJlxuICAgICFrZXlzLmluY2x1ZGVzKCdAY29udGV4dCcpKSB7XG4gICAgZm9yKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBleHBhbmRlZFByb3BlcnR5ID0gX2V4cGFuZElyaShcbiAgICAgICAgdHlwZVNjb3BlZENvbnRleHQsIGtleSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQHZhbHVlJykge1xuICAgICAgICAvLyB2YWx1ZSBmb3VuZCwgZW5zdXJlIHR5cGUtc2NvcGVkIGNvbnRleHQgaXMgdXNlZCB0byBleHBhbmQgaXRcbiAgICAgICAgbXVzdFJldmVydCA9IGZhbHNlO1xuICAgICAgICBhY3RpdmVDdHggPSB0eXBlU2NvcGVkQ29udGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGlkJyAmJiBrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBzdWJqZWN0IHJlZmVyZW5jZSBmb3VuZCwgZG8gbm90IHJldmVydFxuICAgICAgICBtdXN0UmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmKG11c3RSZXZlcnQpIHtcbiAgICAvLyByZXZlcnQgdHlwZSBzY29wZWQgY29udGV4dFxuICAgIGFjdGl2ZUN0eCA9IGFjdGl2ZUN0eC5yZXZlcnRUb1ByZXZpb3VzQ29udGV4dCgpO1xuICB9XG5cbiAgLy8gYXBwbHkgcHJvcGVydHktc2NvcGVkIGNvbnRleHQgYWZ0ZXIgcmV2ZXJ0aW5nIHRlcm0tc2NvcGVkIGNvbnRleHRcbiAgaWYoIV9pc1VuZGVmaW5lZChwcm9wZXJ0eVNjb3BlZEN0eCkpIHtcbiAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgYWN0aXZlQ3R4LFxuICAgICAgbG9jYWxDdHg6IHByb3BlcnR5U2NvcGVkQ3R4LFxuICAgICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgICAgb3ZlcnJpZGVQcm90ZWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICAvLyBpZiBlbGVtZW50IGhhcyBhIGNvbnRleHQsIHByb2Nlc3MgaXRcbiAgaWYoJ0Bjb250ZXh0JyBpbiBlbGVtZW50KSB7XG4gICAgYWN0aXZlQ3R4ID0gYXdhaXQgX3Byb2Nlc3NDb250ZXh0KFxuICAgICAge2FjdGl2ZUN0eCwgbG9jYWxDdHg6IGVsZW1lbnRbJ0Bjb250ZXh0J10sIG9wdGlvbnN9KTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgdHlwZS1zY29wZWQgY29udGV4dCB0byB0aGUgY29udGV4dCBvbiBpbnB1dCwgZm9yIHVzZSBsYXRlclxuICB0eXBlU2NvcGVkQ29udGV4dCA9IGFjdGl2ZUN0eDtcblxuICAvLyBSZW1lbWJlciB0aGUgZmlyc3Qga2V5IGZvdW5kIGV4cGFuZGluZyB0byBAdHlwZVxuICBsZXQgdHlwZUtleSA9IG51bGw7XG5cbiAgLy8gbG9vayBmb3Igc2NvcGVkIGNvbnRleHRzIG9uIGBAdHlwZWBcbiAgZm9yKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgZXhwYW5kZWRQcm9wZXJ0eSA9IF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBrZXksIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAdHlwZScpIHtcbiAgICAgIC8vIHNldCBzY29wZWQgY29udGV4dHMgZnJvbSBAdHlwZVxuICAgICAgLy8gYXZvaWQgc29ydGluZyBpZiBwb3NzaWJsZVxuICAgICAgdHlwZUtleSA9IHR5cGVLZXkgfHwga2V5O1xuICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50W2tleV07XG4gICAgICBjb25zdCB0eXBlcyA9XG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID9cbiAgICAgICAgICAodmFsdWUubGVuZ3RoID4gMSA/IHZhbHVlLnNsaWNlKCkuc29ydCgpIDogdmFsdWUpIDogW3ZhbHVlXTtcbiAgICAgIGZvcihjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IF9nZXRDb250ZXh0VmFsdWUodHlwZVNjb3BlZENvbnRleHQsIHR5cGUsICdAY29udGV4dCcpO1xuICAgICAgICBpZighX2lzVW5kZWZpbmVkKGN0eCkpIHtcbiAgICAgICAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgbG9jYWxDdHg6IGN0eCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBwcm9wYWdhdGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwcm9jZXNzIGVhY2gga2V5IGFuZCB2YWx1ZSBpbiBlbGVtZW50LCBpZ25vcmluZyBAbmVzdCBjb250ZW50XG4gIGxldCBydmFsID0ge307XG4gIGF3YWl0IF9leHBhbmRPYmplY3Qoe1xuICAgIGFjdGl2ZUN0eCxcbiAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICBleHBhbmRlZEFjdGl2ZVByb3BlcnR5LFxuICAgIGVsZW1lbnQsXG4gICAgZXhwYW5kZWRQYXJlbnQ6IHJ2YWwsXG4gICAgb3B0aW9ucyxcbiAgICBpbnNpZGVMaXN0LFxuICAgIHR5cGVLZXksXG4gICAgdHlwZVNjb3BlZENvbnRleHQsXG4gICAgZXhwYW5zaW9uTWFwfSk7XG5cbiAgLy8gZ2V0IHByb3BlcnR5IGNvdW50IG9uIGV4cGFuZGVkIG91dHB1dFxuICBrZXlzID0gT2JqZWN0LmtleXMocnZhbCk7XG4gIGxldCBjb3VudCA9IGtleXMubGVuZ3RoO1xuXG4gIGlmKCdAdmFsdWUnIGluIHJ2YWwpIHtcbiAgICAvLyBAdmFsdWUgbXVzdCBvbmx5IGhhdmUgQGxhbmd1YWdlIG9yIEB0eXBlXG4gICAgaWYoJ0B0eXBlJyBpbiBydmFsICYmICgnQGxhbmd1YWdlJyBpbiBydmFsIHx8ICdAZGlyZWN0aW9uJyBpbiBydmFsKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYW4gZWxlbWVudCBjb250YWluaW5nIFwiQHZhbHVlXCIgbWF5IG5vdCAnICtcbiAgICAgICAgJ2NvbnRhaW4gYm90aCBcIkB0eXBlXCIgYW5kIGVpdGhlciBcIkBsYW5ndWFnZVwiIG9yIFwiQGRpcmVjdGlvblwiLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgdmFsdWUgb2JqZWN0JywgZWxlbWVudDogcnZhbH0pO1xuICAgIH1cbiAgICBsZXQgdmFsaWRDb3VudCA9IGNvdW50IC0gMTtcbiAgICBpZignQHR5cGUnIGluIHJ2YWwpIHtcbiAgICAgIHZhbGlkQ291bnQgLT0gMTtcbiAgICB9XG4gICAgaWYoJ0BpbmRleCcgaW4gcnZhbCkge1xuICAgICAgdmFsaWRDb3VudCAtPSAxO1xuICAgIH1cbiAgICBpZignQGxhbmd1YWdlJyBpbiBydmFsKSB7XG4gICAgICB2YWxpZENvdW50IC09IDE7XG4gICAgfVxuICAgIGlmKCdAZGlyZWN0aW9uJyBpbiBydmFsKSB7XG4gICAgICB2YWxpZENvdW50IC09IDE7XG4gICAgfVxuICAgIGlmKHZhbGlkQ291bnQgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGFuIGVsZW1lbnQgY29udGFpbmluZyBcIkB2YWx1ZVwiIG1heSBvbmx5ICcgK1xuICAgICAgICAnaGF2ZSBhbiBcIkBpbmRleFwiIHByb3BlcnR5IGFuZCBlaXRoZXIgXCJAdHlwZVwiICcgK1xuICAgICAgICAnb3IgZWl0aGVyIG9yIGJvdGggXCJAbGFuZ3VhZ2VcIiBvciBcIkBkaXJlY3Rpb25cIi4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIHZhbHVlIG9iamVjdCcsIGVsZW1lbnQ6IHJ2YWx9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gcnZhbFsnQHZhbHVlJ10gPT09IG51bGwgPyBbXSA6IF9hc0FycmF5KHJ2YWxbJ0B2YWx1ZSddKTtcbiAgICBjb25zdCB0eXBlcyA9IF9nZXRWYWx1ZXMocnZhbCwgJ0B0eXBlJyk7XG5cbiAgICAvLyBkcm9wIG51bGwgQHZhbHVlcyB1bmxlc3MgY3VzdG9tIG1hcHBlZFxuICAgIGlmKF9wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSkgJiYgdHlwZXMuaW5jbHVkZXMoJ0Bqc29uJykgJiZcbiAgICAgIHR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQW55IHZhbHVlIG9mIEB2YWx1ZSBpcyBva2F5IGlmIEB0eXBlOiBAanNvblxuICAgIH0gZWxzZSBpZih2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBtYXBwZWQgPSBhd2FpdCBleHBhbnNpb25NYXAoe1xuICAgICAgICB1bm1hcHBlZFZhbHVlOiBydmFsLFxuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpbnNpZGVMaXN0XG4gICAgICB9KTtcbiAgICAgIGlmKG1hcHBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJ2YWwgPSBtYXBwZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoIXZhbHVlcy5ldmVyeSh2ID0+IChfaXNTdHJpbmcodikgfHwgX2lzRW1wdHlPYmplY3QodikpKSAmJlxuICAgICAgJ0BsYW5ndWFnZScgaW4gcnZhbCkge1xuICAgICAgLy8gaWYgQGxhbmd1YWdlIGlzIHByZXNlbnQsIEB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nXG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBvbmx5IHN0cmluZ3MgbWF5IGJlIGxhbmd1YWdlLXRhZ2dlZC4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIGxhbmd1YWdlLXRhZ2dlZCB2YWx1ZScsIGVsZW1lbnQ6IHJ2YWx9KTtcbiAgICB9IGVsc2UgaWYoIXR5cGVzLmV2ZXJ5KHQgPT5cbiAgICAgIChfaXNBYnNvbHV0ZUlyaSh0KSAmJiAhKF9pc1N0cmluZyh0KSAmJiB0LmluZGV4T2YoJ186JykgPT09IDApIHx8XG4gICAgICBfaXNFbXB0eU9iamVjdCh0KSkpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhbiBlbGVtZW50IGNvbnRhaW5pbmcgXCJAdmFsdWVcIiBhbmQgXCJAdHlwZVwiICcgK1xuICAgICAgICAnbXVzdCBoYXZlIGFuIGFic29sdXRlIElSSSBmb3IgdGhlIHZhbHVlIG9mIFwiQHR5cGVcIi4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIHR5cGVkIHZhbHVlJywgZWxlbWVudDogcnZhbH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmKCdAdHlwZScgaW4gcnZhbCAmJiAhX2lzQXJyYXkocnZhbFsnQHR5cGUnXSkpIHtcbiAgICAvLyBjb252ZXJ0IEB0eXBlIHRvIGFuIGFycmF5XG4gICAgcnZhbFsnQHR5cGUnXSA9IFtydmFsWydAdHlwZSddXTtcbiAgfSBlbHNlIGlmKCdAc2V0JyBpbiBydmFsIHx8ICdAbGlzdCcgaW4gcnZhbCkge1xuICAgIC8vIGhhbmRsZSBAc2V0IGFuZCBAbGlzdFxuICAgIGlmKGNvdW50ID4gMSAmJiAhKGNvdW50ID09PSAyICYmICdAaW5kZXgnIGluIHJ2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBpZiBhbiBlbGVtZW50IGhhcyB0aGUgcHJvcGVydHkgXCJAc2V0XCIgJyArXG4gICAgICAgICdvciBcIkBsaXN0XCIsIHRoZW4gaXQgY2FuIGhhdmUgYXQgbW9zdCBvbmUgb3RoZXIgcHJvcGVydHkgdGhhdCBpcyAnICtcbiAgICAgICAgJ1wiQGluZGV4XCIuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCBzZXQgb3IgbGlzdCBvYmplY3QnLCBlbGVtZW50OiBydmFsfSk7XG4gICAgfVxuICAgIC8vIG9wdGltaXplIGF3YXkgQHNldFxuICAgIGlmKCdAc2V0JyBpbiBydmFsKSB7XG4gICAgICBydmFsID0gcnZhbFsnQHNldCddO1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHJ2YWwpO1xuICAgICAgY291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMSAmJiAnQGxhbmd1YWdlJyBpbiBydmFsKSB7XG4gICAgLy8gZHJvcCBvYmplY3RzIHdpdGggb25seSBAbGFuZ3VhZ2UgdW5sZXNzIGN1c3RvbSBtYXBwZWRcbiAgICBjb25zdCBtYXBwZWQgPSBhd2FpdCBleHBhbnNpb25NYXAocnZhbCwge1xuICAgICAgdW5tYXBwZWRWYWx1ZTogcnZhbCxcbiAgICAgIGFjdGl2ZUN0eCxcbiAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgZWxlbWVudCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBpbnNpZGVMaXN0XG4gICAgfSk7XG4gICAgaWYobWFwcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ2YWwgPSBtYXBwZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRyb3AgY2VydGFpbiB0b3AtbGV2ZWwgb2JqZWN0cyB0aGF0IGRvIG5vdCBvY2N1ciBpbiBsaXN0cywgdW5sZXNzIGN1c3RvbVxuICAvLyBtYXBwZWRcbiAgaWYoX2lzT2JqZWN0KHJ2YWwpICYmXG4gICAgIW9wdGlvbnMua2VlcEZyZWVGbG9hdGluZ05vZGVzICYmICFpbnNpZGVMaXN0ICYmXG4gICAgKGFjdGl2ZVByb3BlcnR5ID09PSBudWxsIHx8IGV4cGFuZGVkQWN0aXZlUHJvcGVydHkgPT09ICdAZ3JhcGgnKSkge1xuICAgIC8vIGRyb3AgZW1wdHkgb2JqZWN0LCB0b3AtbGV2ZWwgQHZhbHVlL0BsaXN0LCBvciBvYmplY3Qgd2l0aCBvbmx5IEBpZFxuICAgIGlmKGNvdW50ID09PSAwIHx8ICdAdmFsdWUnIGluIHJ2YWwgfHwgJ0BsaXN0JyBpbiBydmFsIHx8XG4gICAgICAoY291bnQgPT09IDEgJiYgJ0BpZCcgaW4gcnZhbCkpIHtcbiAgICAgIGNvbnN0IG1hcHBlZCA9IGF3YWl0IGV4cGFuc2lvbk1hcCh7XG4gICAgICAgIHVubWFwcGVkVmFsdWU6IHJ2YWwsXG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGluc2lkZUxpc3RcbiAgICAgIH0pO1xuICAgICAgaWYobWFwcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcnZhbCA9IG1hcHBlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBFeHBhbmQgZWFjaCBrZXkgYW5kIHZhbHVlIG9mIGVsZW1lbnQgYWRkaW5nIHRvIHJlc3VsdFxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGNvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIGFjdGl2ZVByb3BlcnR5IHRoZSBwcm9wZXJ0eSBmb3IgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0gZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSB0aGUgZXhwYW5zaW9uIG9mIGFjdGl2ZVByb3BlcnR5XG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBleHBhbmQuXG4gKiBAcGFyYW0gZXhwYW5kZWRQYXJlbnQgdGhlIGV4cGFuZGVkIHJlc3VsdCBpbnRvIHdoaWNoIHRvIGFkZCB2YWx1ZXMuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgZXhwYW5zaW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gaW5zaWRlTGlzdCB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGEgbGlzdCwgZmFsc2UgaWYgbm90LlxuICogQHBhcmFtIHR5cGVLZXkgZmlyc3Qga2V5IGZvdW5kIGV4cGFuZGluZyB0byBAdHlwZS5cbiAqIEBwYXJhbSB0eXBlU2NvcGVkQ29udGV4dCB0aGUgY29udGV4dCBiZWZvcmUgcmV2ZXJ0aW5nLlxuICogQHBhcmFtIGV4cGFuc2lvbk1hcChpbmZvKSBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3VzdG9tIG1hcFxuICogICAgICAgICAgdW5tYXBwYWJsZSB2YWx1ZXMgKG9yIHRvIHRocm93IGFuIGVycm9yIHdoZW4gdGhleSBhcmUgZGV0ZWN0ZWQpO1xuICogICAgICAgICAgaWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIHRoZW4gdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAqICAgICAgICAgIHdpbGwgYmUgdXNlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2V4cGFuZE9iamVjdCh7XG4gIGFjdGl2ZUN0eCxcbiAgYWN0aXZlUHJvcGVydHksXG4gIGV4cGFuZGVkQWN0aXZlUHJvcGVydHksXG4gIGVsZW1lbnQsXG4gIGV4cGFuZGVkUGFyZW50LFxuICBvcHRpb25zID0ge30sXG4gIGluc2lkZUxpc3QsXG4gIHR5cGVLZXksXG4gIHR5cGVTY29wZWRDb250ZXh0LFxuICBleHBhbnNpb25NYXBcbn0pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQpLnNvcnQoKTtcbiAgY29uc3QgbmVzdHMgPSBbXTtcbiAgbGV0IHVuZXhwYW5kZWRWYWx1ZTtcblxuICAvLyBGaWd1cmUgb3V0IGlmIHRoaXMgaXMgdGhlIHR5cGUgZm9yIGEgSlNPTiBsaXRlcmFsXG4gIGNvbnN0IGlzSnNvblR5cGUgPSBlbGVtZW50W3R5cGVLZXldICYmXG4gICAgX2V4cGFuZElyaShhY3RpdmVDdHgsXG4gICAgICAoX2lzQXJyYXkoZWxlbWVudFt0eXBlS2V5XSkgPyBlbGVtZW50W3R5cGVLZXldWzBdIDogZWxlbWVudFt0eXBlS2V5XSksXG4gICAgICB7dm9jYWI6IHRydWV9LCBvcHRpb25zKSA9PT0gJ0Bqc29uJztcblxuICBmb3IoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBsZXQgdmFsdWUgPSBlbGVtZW50W2tleV07XG4gICAgbGV0IGV4cGFuZGVkVmFsdWU7XG5cbiAgICAvLyBza2lwIEBjb250ZXh0XG4gICAgaWYoa2V5ID09PSAnQGNvbnRleHQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBleHBhbmQgcHJvcGVydHlcbiAgICBsZXQgZXhwYW5kZWRQcm9wZXJ0eSA9IF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBrZXksIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgLy8gZHJvcCBub24tYWJzb2x1dGUgSVJJIGtleXMgdGhhdCBhcmVuJ3Qga2V5d29yZHMgdW5sZXNzIGN1c3RvbSBtYXBwZWRcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSBudWxsIHx8XG4gICAgICAhKF9pc0Fic29sdXRlSXJpKGV4cGFuZGVkUHJvcGVydHkpIHx8IF9pc0tleXdvcmQoZXhwYW5kZWRQcm9wZXJ0eSkpKSB7XG4gICAgICAvLyBUT0RPOiB1c2UgYGF3YWl0YCB0byBzdXBwb3J0IGFzeW5jXG4gICAgICBleHBhbmRlZFByb3BlcnR5ID0gZXhwYW5zaW9uTWFwKHtcbiAgICAgICAgdW5tYXBwZWRQcm9wZXJ0eToga2V5LFxuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICBwYXJlbnQ6IGVsZW1lbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGluc2lkZUxpc3QsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBleHBhbmRlZFBhcmVudFxuICAgICAgfSk7XG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoX2lzS2V5d29yZChleHBhbmRlZFByb3BlcnR5KSkge1xuICAgICAgaWYoZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSA9PT0gJ0ByZXZlcnNlJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEga2V5d29yZCBjYW5ub3QgYmUgdXNlZCBhcyBhIEByZXZlcnNlICcgK1xuICAgICAgICAgICdwcm9wZXJ0eS4nLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgcmV2ZXJzZSBwcm9wZXJ0eSBtYXAnLCB2YWx1ZX0pO1xuICAgICAgfVxuICAgICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSBpbiBleHBhbmRlZFBhcmVudCAmJlxuICAgICAgICAgZXhwYW5kZWRQcm9wZXJ0eSAhPT0gJ0BpbmNsdWRlZCcgJiZcbiAgICAgICAgIGV4cGFuZGVkUHJvcGVydHkgIT09ICdAdHlwZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBjb2xsaWRpbmcga2V5d29yZHMgZGV0ZWN0ZWQuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2NvbGxpZGluZyBrZXl3b3JkcycsIGtleXdvcmQ6IGV4cGFuZGVkUHJvcGVydHl9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzeW50YXggZXJyb3IgaWYgQGlkIGlzIG5vdCBhIHN0cmluZ1xuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAaWQnKSB7XG4gICAgICBpZighX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZighb3B0aW9ucy5pc0ZyYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGlkXCIgdmFsdWUgbXVzdCBhIHN0cmluZy4nLFxuICAgICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAaWQgdmFsdWUnLCB2YWx1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmKF9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAvLyBlbXB0eSBvYmplY3QgaXMgYSB3aWxkY2FyZFxuICAgICAgICAgIGlmKCFfaXNFbXB0eU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGlkXCIgdmFsdWUgYW4gZW1wdHkgb2JqZWN0IG9yIGFycmF5ICcgK1xuICAgICAgICAgICAgICAnb2Ygc3RyaW5ncywgaWYgZnJhbWluZycsXG4gICAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQGlkIHZhbHVlJywgdmFsdWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihfaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZighdmFsdWUuZXZlcnkodiA9PiBfaXNTdHJpbmcodikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkBpZFwiIHZhbHVlIGFuIGVtcHR5IG9iamVjdCBvciBhcnJheSAnICtcbiAgICAgICAgICAgICAgJ29mIHN0cmluZ3MsIGlmIGZyYW1pbmcnLFxuICAgICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIEBpZCB2YWx1ZScsIHZhbHVlfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkBpZFwiIHZhbHVlIGFuIGVtcHR5IG9iamVjdCBvciBhcnJheSAnICtcbiAgICAgICAgICAgICdvZiBzdHJpbmdzLCBpZiBmcmFtaW5nJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQGlkIHZhbHVlJywgdmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfYWRkVmFsdWUoXG4gICAgICAgIGV4cGFuZGVkUGFyZW50LCAnQGlkJyxcbiAgICAgICAgX2FzQXJyYXkodmFsdWUpLm1hcCh2ID0+XG4gICAgICAgICAgX2lzU3RyaW5nKHYpID8gX2V4cGFuZElyaShhY3RpdmVDdHgsIHYsIHtiYXNlOiB0cnVlfSwgb3B0aW9ucykgOiB2KSxcbiAgICAgICAge3Byb3BlcnR5SXNBcnJheTogb3B0aW9ucy5pc0ZyYW1lfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQHR5cGUnKSB7XG4gICAgICAvLyBpZiBmcmFtaW5nLCBjYW4gYmUgYSBkZWZhdWx0IG9iamVjdCwgYnV0IG5lZWQgdG8gZXhwYW5kXG4gICAgICAvLyBrZXkgdG8gZGV0ZXJtaW5lIHRoYXRcbiAgICAgIGlmKF9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiBbXG4gICAgICAgICAgX2V4cGFuZElyaSh0eXBlU2NvcGVkQ29udGV4dCwgaywge3ZvY2FiOiB0cnVlfSksXG4gICAgICAgICAgX2FzQXJyYXkodikubWFwKHZ2ID0+XG4gICAgICAgICAgICBfZXhwYW5kSXJpKHR5cGVTY29wZWRDb250ZXh0LCB2diwge2Jhc2U6IHRydWUsIHZvY2FiOiB0cnVlfSlcbiAgICAgICAgICApXG4gICAgICAgIF0pKTtcbiAgICAgIH1cbiAgICAgIF92YWxpZGF0ZVR5cGVWYWx1ZSh2YWx1ZSwgb3B0aW9ucy5pc0ZyYW1lKTtcbiAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgZXhwYW5kZWRQYXJlbnQsICdAdHlwZScsXG4gICAgICAgIF9hc0FycmF5KHZhbHVlKS5tYXAodiA9PlxuICAgICAgICAgIF9pc1N0cmluZyh2KSA/XG4gICAgICAgICAgICBfZXhwYW5kSXJpKHR5cGVTY29wZWRDb250ZXh0LCB2LFxuICAgICAgICAgICAgICB7YmFzZTogdHJ1ZSwgdm9jYWI6IHRydWV9LCBvcHRpb25zKSA6IHYpLFxuICAgICAgICB7cHJvcGVydHlJc0FycmF5OiBvcHRpb25zLmlzRnJhbWV9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEluY2x1ZGVkIGJsb2NrcyBhcmUgdHJlYXRlZCBhcyBhbiBhcnJheSBvZiBzZXBhcmF0ZSBvYmplY3Qgbm9kZXMgc2hhcmluZ1xuICAgIC8vIHRoZSBzYW1lIHJlZmVyZW5jaW5nIGFjdGl2ZV9wcm9wZXJ0eS5cbiAgICAvLyBGb3IgMS4wLCBpdCBpcyBza2lwcGVkIGFzIGFyZSBvdGhlciB1bmtub3duIGtleXdvcmRzXG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BpbmNsdWRlZCcgJiYgX3Byb2Nlc3NpbmdNb2RlKGFjdGl2ZUN0eCwgMS4xKSkge1xuICAgICAgY29uc3QgaW5jbHVkZWRSZXN1bHQgPSBfYXNBcnJheShhd2FpdCBhcGkuZXhwYW5kKHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZWxlbWVudDogdmFsdWUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGV4cGFuc2lvbk1hcFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBFeHBhbmRlZCB2YWx1ZXMgbXVzdCBiZSBub2RlIG9iamVjdHNcbiAgICAgIGlmKCFpbmNsdWRlZFJlc3VsdC5ldmVyeSh2ID0+IF9pc1N1YmplY3QodikpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgJyArXG4gICAgICAgICAgJ3ZhbHVlcyBvZiBAaW5jbHVkZWQgbXVzdCBleHBhbmQgdG8gbm9kZSBvYmplY3RzLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAaW5jbHVkZWQgdmFsdWUnLCB2YWx1ZX0pO1xuICAgICAgfVxuXG4gICAgICBfYWRkVmFsdWUoXG4gICAgICAgIGV4cGFuZGVkUGFyZW50LCAnQGluY2x1ZGVkJywgaW5jbHVkZWRSZXN1bHQsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEBncmFwaCBtdXN0IGJlIGFuIGFycmF5IG9yIGFuIG9iamVjdFxuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAZ3JhcGgnICYmXG4gICAgICAhKF9pc09iamVjdCh2YWx1ZSkgfHwgX2lzQXJyYXkodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAZ3JhcGhcIiB2YWx1ZSBtdXN0IG5vdCBiZSBhbiAnICtcbiAgICAgICAgJ29iamVjdCBvciBhbiBhcnJheS4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIEBncmFwaCB2YWx1ZScsIHZhbHVlfSk7XG4gICAgfVxuXG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0B2YWx1ZScpIHtcbiAgICAgIC8vIGNhcHR1cmUgdmFsdWUgZm9yIGxhdGVyXG4gICAgICAvLyBcImNvbGxpZGluZyBrZXl3b3Jkc1wiIGNoZWNrIHByZXZlbnRzIHRoaXMgZnJvbSBiZWluZyBzZXQgdHdpY2VcbiAgICAgIHVuZXhwYW5kZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgaWYoaXNKc29uVHlwZSAmJiBfcHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpKSB7XG4gICAgICAgIC8vIG5vIGNvZXJjaW9uIHRvIGFycmF5LCBhbmQgcmV0YWluIGFsbCB2YWx1ZXNcbiAgICAgICAgZXhwYW5kZWRQYXJlbnRbJ0B2YWx1ZSddID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkVmFsdWUoXG4gICAgICAgICAgZXhwYW5kZWRQYXJlbnQsICdAdmFsdWUnLCB2YWx1ZSwge3Byb3BlcnR5SXNBcnJheTogb3B0aW9ucy5pc0ZyYW1lfSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBAbGFuZ3VhZ2UgbXVzdCBiZSBhIHN0cmluZ1xuICAgIC8vIGl0IHNob3VsZCBtYXRjaCBCQ1A0N1xuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAbGFuZ3VhZ2UnKSB7XG4gICAgICBpZih2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBkcm9wIG51bGwgQGxhbmd1YWdlIHZhbHVlcywgdGhleSBleHBhbmQgYXMgaWYgdGhleSBkaWRuJ3QgZXhpc3RcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZighX2lzU3RyaW5nKHZhbHVlKSAmJiAhb3B0aW9ucy5pc0ZyYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAbGFuZ3VhZ2VcIiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGxhbmd1YWdlLXRhZ2dlZCBzdHJpbmcnLCB2YWx1ZX0pO1xuICAgICAgfVxuICAgICAgLy8gZW5zdXJlIGxhbmd1YWdlIHZhbHVlIGlzIGxvd2VyY2FzZVxuICAgICAgdmFsdWUgPSBfYXNBcnJheSh2YWx1ZSkubWFwKHYgPT4gX2lzU3RyaW5nKHYpID8gdi50b0xvd2VyQ2FzZSgpIDogdik7XG5cbiAgICAgIC8vIGVuc3VyZSBsYW5ndWFnZSB0YWcgbWF0Y2hlcyBCQ1A0N1xuICAgICAgZm9yKGNvbnN0IGxhbmcgb2YgdmFsdWUpIHtcbiAgICAgICAgaWYoX2lzU3RyaW5nKGxhbmcpICYmICFsYW5nLm1hdGNoKFJFR0VYX0JDUDQ3KSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQGxhbmd1YWdlIG11c3QgYmUgdmFsaWQgQkNQNDc6ICR7bGFuZ31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfYWRkVmFsdWUoXG4gICAgICAgIGV4cGFuZGVkUGFyZW50LCAnQGxhbmd1YWdlJywgdmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IG9wdGlvbnMuaXNGcmFtZX0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQGRpcmVjdGlvbiBtdXN0IGJlIFwibHRyXCIgb3IgXCJydGxcIlxuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAZGlyZWN0aW9uJykge1xuICAgICAgaWYoIV9pc1N0cmluZyh2YWx1ZSkgJiYgIW9wdGlvbnMuaXNGcmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGRpcmVjdGlvblwiIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgYmFzZSBkaXJlY3Rpb24nLCB2YWx1ZX0pO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IF9hc0FycmF5KHZhbHVlKTtcblxuICAgICAgLy8gZW5zdXJlIGRpcmVjdGlvbiBpcyBcImx0clwiIG9yIFwicnRsXCJcbiAgICAgIGZvcihjb25zdCBkaXIgb2YgdmFsdWUpIHtcbiAgICAgICAgaWYoX2lzU3RyaW5nKGRpcikgJiYgZGlyICE9PSAnbHRyJyAmJiBkaXIgIT09ICdydGwnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGRpcmVjdGlvblwiIG11c3QgYmUgXCJsdHJcIiBvciBcInJ0bFwiLicsXG4gICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBiYXNlIGRpcmVjdGlvbicsIHZhbHVlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2FkZFZhbHVlKFxuICAgICAgICBleHBhbmRlZFBhcmVudCwgJ0BkaXJlY3Rpb24nLCB2YWx1ZSxcbiAgICAgICAge3Byb3BlcnR5SXNBcnJheTogb3B0aW9ucy5pc0ZyYW1lfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBAaW5kZXggbXVzdCBiZSBhIHN0cmluZ1xuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAaW5kZXgnKSB7XG4gICAgICBpZighX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGluZGV4XCIgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBAaW5kZXggdmFsdWUnLCB2YWx1ZX0pO1xuICAgICAgfVxuICAgICAgX2FkZFZhbHVlKGV4cGFuZGVkUGFyZW50LCAnQGluZGV4JywgdmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQHJldmVyc2UgbXVzdCBiZSBhbiBvYmplY3RcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQHJldmVyc2UnKSB7XG4gICAgICBpZighX2lzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQHJldmVyc2VcIiB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdC4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQHJldmVyc2UgdmFsdWUnLCB2YWx1ZX0pO1xuICAgICAgfVxuXG4gICAgICBleHBhbmRlZFZhbHVlID0gYXdhaXQgYXBpLmV4cGFuZCh7XG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgYWN0aXZlUHJvcGVydHk6XG4gICAgICAgICdAcmV2ZXJzZScsXG4gICAgICAgIGVsZW1lbnQ6IHZhbHVlLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBleHBhbnNpb25NYXBcbiAgICAgIH0pO1xuICAgICAgLy8gcHJvcGVydGllcyBkb3VibGUtcmV2ZXJzZWRcbiAgICAgIGlmKCdAcmV2ZXJzZScgaW4gZXhwYW5kZWRWYWx1ZSkge1xuICAgICAgICBmb3IoY29uc3QgcHJvcGVydHkgaW4gZXhwYW5kZWRWYWx1ZVsnQHJldmVyc2UnXSkge1xuICAgICAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgICAgIGV4cGFuZGVkUGFyZW50LCBwcm9wZXJ0eSwgZXhwYW5kZWRWYWx1ZVsnQHJldmVyc2UnXVtwcm9wZXJ0eV0sXG4gICAgICAgICAgICB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRklYTUU6IGNhbiB0aGlzIGJlIG1lcmdlZCB3aXRoIGNvZGUgYmVsb3cgdG8gc2ltcGxpZnk/XG4gICAgICAvLyBtZXJnZSBpbiBhbGwgcmV2ZXJzZWQgcHJvcGVydGllc1xuICAgICAgbGV0IHJldmVyc2VNYXAgPSBleHBhbmRlZFBhcmVudFsnQHJldmVyc2UnXSB8fCBudWxsO1xuICAgICAgZm9yKGNvbnN0IHByb3BlcnR5IGluIGV4cGFuZGVkVmFsdWUpIHtcbiAgICAgICAgaWYocHJvcGVydHkgPT09ICdAcmV2ZXJzZScpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihyZXZlcnNlTWFwID09PSBudWxsKSB7XG4gICAgICAgICAgcmV2ZXJzZU1hcCA9IGV4cGFuZGVkUGFyZW50WydAcmV2ZXJzZSddID0ge307XG4gICAgICAgIH1cbiAgICAgICAgX2FkZFZhbHVlKHJldmVyc2VNYXAsIHByb3BlcnR5LCBbXSwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgICAgICBjb25zdCBpdGVtcyA9IGV4cGFuZGVkVmFsdWVbcHJvcGVydHldO1xuICAgICAgICBmb3IobGV0IGlpID0gMDsgaWkgPCBpdGVtcy5sZW5ndGg7ICsraWkpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaWldO1xuICAgICAgICAgIGlmKF9pc1ZhbHVlKGl0ZW0pIHx8IF9pc0xpc3QoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQHJldmVyc2VcIiB2YWx1ZSBtdXN0IG5vdCBiZSBhICcgK1xuICAgICAgICAgICAgICAnQHZhbHVlIG9yIGFuIEBsaXN0LicsICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgcmV2ZXJzZSBwcm9wZXJ0eSB2YWx1ZScsIHZhbHVlOiBleHBhbmRlZFZhbHVlfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9hZGRWYWx1ZShyZXZlcnNlTWFwLCBwcm9wZXJ0eSwgaXRlbSwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIG5lc3RlZCBrZXlzXG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BuZXN0Jykge1xuICAgICAgbmVzdHMucHVzaChrZXkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdXNlIHBvdGVudGlhbCBzY29wZWQgY29udGV4dCBmb3Iga2V5XG4gICAgbGV0IHRlcm1DdHggPSBhY3RpdmVDdHg7XG4gICAgY29uc3QgY3R4ID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGtleSwgJ0Bjb250ZXh0Jyk7XG4gICAgaWYoIV9pc1VuZGVmaW5lZChjdHgpKSB7XG4gICAgICB0ZXJtQ3R4ID0gYXdhaXQgX3Byb2Nlc3NDb250ZXh0KHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBsb2NhbEN0eDogY3R4LFxuICAgICAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgICAgIG92ZXJyaWRlUHJvdGVjdGVkOiB0cnVlLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKHRlcm1DdHgsIGtleSwgJ0Bjb250YWluZXInKSB8fCBbXTtcblxuICAgIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGxhbmd1YWdlJykgJiYgX2lzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gX2dldENvbnRleHRWYWx1ZSh0ZXJtQ3R4LCBrZXksICdAZGlyZWN0aW9uJyk7XG4gICAgICAvLyBoYW5kbGUgbGFuZ3VhZ2UgbWFwIGNvbnRhaW5lciAoc2tpcCBpZiB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0KVxuICAgICAgZXhwYW5kZWRWYWx1ZSA9IF9leHBhbmRMYW5ndWFnZU1hcCh0ZXJtQ3R4LCB2YWx1ZSwgZGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAaW5kZXgnKSAmJiBfaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAvLyBoYW5kbGUgaW5kZXggY29udGFpbmVyIChza2lwIGlmIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QpXG4gICAgICBjb25zdCBhc0dyYXBoID0gY29udGFpbmVyLmluY2x1ZGVzKCdAZ3JhcGgnKTtcbiAgICAgIGNvbnN0IGluZGV4S2V5ID0gX2dldENvbnRleHRWYWx1ZSh0ZXJtQ3R4LCBrZXksICdAaW5kZXgnKSB8fCAnQGluZGV4JztcbiAgICAgIGNvbnN0IHByb3BlcnR5SW5kZXggPSBpbmRleEtleSAhPT0gJ0BpbmRleCcgJiZcbiAgICAgICAgX2V4cGFuZElyaShhY3RpdmVDdHgsIGluZGV4S2V5LCB7dm9jYWI6IHRydWV9LCBvcHRpb25zKTtcblxuICAgICAgZXhwYW5kZWRWYWx1ZSA9IGF3YWl0IF9leHBhbmRJbmRleE1hcCh7XG4gICAgICAgIGFjdGl2ZUN0eDogdGVybUN0eCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgYWN0aXZlUHJvcGVydHk6IGtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGV4cGFuc2lvbk1hcCxcbiAgICAgICAgYXNHcmFwaCxcbiAgICAgICAgaW5kZXhLZXksXG4gICAgICAgIHByb3BlcnR5SW5kZXhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BpZCcpICYmIF9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIC8vIGhhbmRsZSBpZCBjb250YWluZXIgKHNraXAgaWYgdmFsdWUgaXMgbm90IGFuIG9iamVjdClcbiAgICAgIGNvbnN0IGFzR3JhcGggPSBjb250YWluZXIuaW5jbHVkZXMoJ0BncmFwaCcpO1xuICAgICAgZXhwYW5kZWRWYWx1ZSA9IGF3YWl0IF9leHBhbmRJbmRleE1hcCh7XG4gICAgICAgIGFjdGl2ZUN0eDogdGVybUN0eCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgYWN0aXZlUHJvcGVydHk6IGtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGV4cGFuc2lvbk1hcCxcbiAgICAgICAgYXNHcmFwaCxcbiAgICAgICAgaW5kZXhLZXk6ICdAaWQnXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAdHlwZScpICYmIF9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIC8vIGhhbmRsZSB0eXBlIGNvbnRhaW5lciAoc2tpcCBpZiB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0KVxuICAgICAgZXhwYW5kZWRWYWx1ZSA9IGF3YWl0IF9leHBhbmRJbmRleE1hcCh7XG4gICAgICAgIC8vIHNpbmNlIGNvbnRhaW5lciBpcyBgQHR5cGVgLCByZXZlcnQgdHlwZSBzY29wZWQgY29udGV4dCB3aGVuIGV4cGFuZGluZ1xuICAgICAgICBhY3RpdmVDdHg6IHRlcm1DdHgucmV2ZXJ0VG9QcmV2aW91c0NvbnRleHQoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgYWN0aXZlUHJvcGVydHk6IGtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGV4cGFuc2lvbk1hcCxcbiAgICAgICAgYXNHcmFwaDogZmFsc2UsXG4gICAgICAgIGluZGV4S2V5OiAnQHR5cGUnXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVjdXJzZSBpbnRvIEBsaXN0IG9yIEBzZXRcbiAgICAgIGNvbnN0IGlzTGlzdCA9IChleHBhbmRlZFByb3BlcnR5ID09PSAnQGxpc3QnKTtcbiAgICAgIGlmKGlzTGlzdCB8fCBleHBhbmRlZFByb3BlcnR5ID09PSAnQHNldCcpIHtcbiAgICAgICAgbGV0IG5leHRBY3RpdmVQcm9wZXJ0eSA9IGFjdGl2ZVByb3BlcnR5O1xuICAgICAgICBpZihpc0xpc3QgJiYgZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSA9PT0gJ0BncmFwaCcpIHtcbiAgICAgICAgICBuZXh0QWN0aXZlUHJvcGVydHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV4cGFuZGVkVmFsdWUgPSBhd2FpdCBhcGkuZXhwYW5kKHtcbiAgICAgICAgICBhY3RpdmVDdHg6IHRlcm1DdHgsXG4gICAgICAgICAgYWN0aXZlUHJvcGVydHk6IG5leHRBY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgICBlbGVtZW50OiB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGluc2lkZUxpc3Q6IGlzTGlzdCxcbiAgICAgICAgICBleHBhbnNpb25NYXBcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYoXG4gICAgICAgIF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBrZXksICdAdHlwZScpID09PSAnQGpzb24nKSB7XG4gICAgICAgIGV4cGFuZGVkVmFsdWUgPSB7XG4gICAgICAgICAgJ0B0eXBlJzogJ0Bqc29uJyxcbiAgICAgICAgICAnQHZhbHVlJzogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGV4cGFuZCB2YWx1ZSB3aXRoIGtleSBhcyBuZXcgYWN0aXZlIHByb3BlcnR5XG4gICAgICAgIGV4cGFuZGVkVmFsdWUgPSBhd2FpdCBhcGkuZXhwYW5kKHtcbiAgICAgICAgICBhY3RpdmVDdHg6IHRlcm1DdHgsXG4gICAgICAgICAgYWN0aXZlUHJvcGVydHk6IGtleSxcbiAgICAgICAgICBlbGVtZW50OiB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGluc2lkZUxpc3Q6IGZhbHNlLFxuICAgICAgICAgIGV4cGFuc2lvbk1hcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkcm9wIG51bGwgdmFsdWVzIGlmIHByb3BlcnR5IGlzIG5vdCBAdmFsdWVcbiAgICBpZihleHBhbmRlZFZhbHVlID09PSBudWxsICYmIGV4cGFuZGVkUHJvcGVydHkgIT09ICdAdmFsdWUnKSB7XG4gICAgICAvLyBUT0RPOiB1c2UgYGF3YWl0YCB0byBzdXBwb3J0IGFzeW5jXG4gICAgICBleHBhbmRlZFZhbHVlID0gZXhwYW5zaW9uTWFwKHtcbiAgICAgICAgdW5tYXBwZWRWYWx1ZTogdmFsdWUsXG4gICAgICAgIGV4cGFuZGVkUHJvcGVydHksXG4gICAgICAgIGFjdGl2ZUN0eDogdGVybUN0eCxcbiAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgIHBhcmVudDogZWxlbWVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaW5zaWRlTGlzdCxcbiAgICAgICAga2V5LFxuICAgICAgICBleHBhbmRlZFBhcmVudFxuICAgICAgfSk7XG4gICAgICBpZihleHBhbmRlZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBleHBhbmRlZCB2YWx1ZSB0byBAbGlzdCBpZiBjb250YWluZXIgc3BlY2lmaWVzIGl0XG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSAhPT0gJ0BsaXN0JyAmJiAhX2lzTGlzdChleHBhbmRlZFZhbHVlKSAmJlxuICAgICAgY29udGFpbmVyLmluY2x1ZGVzKCdAbGlzdCcpKSB7XG4gICAgICAvLyBlbnN1cmUgZXhwYW5kZWQgdmFsdWUgaW4gQGxpc3QgaXMgYW4gYXJyYXlcbiAgICAgIGV4cGFuZGVkVmFsdWUgPSB7J0BsaXN0JzogX2FzQXJyYXkoZXhwYW5kZWRWYWx1ZSl9O1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZXhwYW5kZWQgdmFsdWUgdG8gQGdyYXBoIGlmIGNvbnRhaW5lciBzcGVjaWZpZXMgaXRcbiAgICAvLyBhbmQgdmFsdWUgaXMgbm90LCBpdHNlbGYsIGEgZ3JhcGhcbiAgICAvLyBpbmRleCBjYXNlcyBoYW5kbGVkIGFib3ZlXG4gICAgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAZ3JhcGgnKSAmJlxuICAgICAgIWNvbnRhaW5lci5zb21lKGtleSA9PiBrZXkgPT09ICdAaWQnIHx8IGtleSA9PT0gJ0BpbmRleCcpKSB7XG4gICAgICAvLyBlbnN1cmUgZXhwYW5kZWQgdmFsdWVzIGFyZSBhcnJheXNcbiAgICAgIGV4cGFuZGVkVmFsdWUgPSBfYXNBcnJheShleHBhbmRlZFZhbHVlKVxuICAgICAgICAubWFwKHYgPT4gKHsnQGdyYXBoJzogX2FzQXJyYXkodil9KSk7XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IGNhbiB0aGlzIGJlIG1lcmdlZCB3aXRoIGNvZGUgYWJvdmUgdG8gc2ltcGxpZnk/XG4gICAgLy8gbWVyZ2UgaW4gcmV2ZXJzZSBwcm9wZXJ0aWVzXG4gICAgaWYodGVybUN0eC5tYXBwaW5ncy5oYXMoa2V5KSAmJiB0ZXJtQ3R4Lm1hcHBpbmdzLmdldChrZXkpLnJldmVyc2UpIHtcbiAgICAgIGNvbnN0IHJldmVyc2VNYXAgPVxuICAgICAgICBleHBhbmRlZFBhcmVudFsnQHJldmVyc2UnXSA9IGV4cGFuZGVkUGFyZW50WydAcmV2ZXJzZSddIHx8IHt9O1xuICAgICAgZXhwYW5kZWRWYWx1ZSA9IF9hc0FycmF5KGV4cGFuZGVkVmFsdWUpO1xuICAgICAgZm9yKGxldCBpaSA9IDA7IGlpIDwgZXhwYW5kZWRWYWx1ZS5sZW5ndGg7ICsraWkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGV4cGFuZGVkVmFsdWVbaWldO1xuICAgICAgICBpZihfaXNWYWx1ZShpdGVtKSB8fCBfaXNMaXN0KGl0ZW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQHJldmVyc2VcIiB2YWx1ZSBtdXN0IG5vdCBiZSBhICcgK1xuICAgICAgICAgICAgJ0B2YWx1ZSBvciBhbiBAbGlzdC4nLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCByZXZlcnNlIHByb3BlcnR5IHZhbHVlJywgdmFsdWU6IGV4cGFuZGVkVmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgICBfYWRkVmFsdWUocmV2ZXJzZU1hcCwgZXhwYW5kZWRQcm9wZXJ0eSwgaXRlbSwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYWRkIHZhbHVlIGZvciBwcm9wZXJ0eVxuICAgIC8vIHNwZWNpYWwga2V5d29yZHMgaGFuZGxlZCBhYm92ZVxuICAgIF9hZGRWYWx1ZShleHBhbmRlZFBhcmVudCwgZXhwYW5kZWRQcm9wZXJ0eSwgZXhwYW5kZWRWYWx1ZSwge1xuICAgICAgcHJvcGVydHlJc0FycmF5OiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvLyBAdmFsdWUgbXVzdCBub3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5ICh1bmxlc3MgZnJhbWluZykgb3IgaWYgQHR5cGUgaXNcbiAgLy8gQGpzb25cbiAgaWYoJ0B2YWx1ZScgaW4gZXhwYW5kZWRQYXJlbnQpIHtcbiAgICBpZihleHBhbmRlZFBhcmVudFsnQHR5cGUnXSA9PT0gJ0Bqc29uJyAmJiBfcHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpKSB7XG4gICAgICAvLyBhbGxvdyBhbnkgdmFsdWUsIHRvIGJlIHZlcmlmaWVkIHdoZW4gdGhlIG9iamVjdCBpcyBmdWxseSBleHBhbmRlZCBhbmRcbiAgICAgIC8vIHRoZSBAdHlwZSBpcyBAanNvbi5cbiAgICB9IGVsc2UgaWYoKF9pc09iamVjdCh1bmV4cGFuZGVkVmFsdWUpIHx8IF9pc0FycmF5KHVuZXhwYW5kZWRWYWx1ZSkpICYmXG4gICAgICAhb3B0aW9ucy5pc0ZyYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkB2YWx1ZVwiIHZhbHVlIG11c3Qgbm90IGJlIGFuICcgK1xuICAgICAgICAnb2JqZWN0IG9yIGFuIGFycmF5LicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICB7Y29kZTogJ2ludmFsaWQgdmFsdWUgb2JqZWN0IHZhbHVlJywgdmFsdWU6IHVuZXhwYW5kZWRWYWx1ZX0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cGFuZCBlYWNoIG5lc3RlZCBrZXlcbiAgZm9yKGNvbnN0IGtleSBvZiBuZXN0cykge1xuICAgIGNvbnN0IG5lc3RlZFZhbHVlcyA9IF9pc0FycmF5KGVsZW1lbnRba2V5XSkgPyBlbGVtZW50W2tleV0gOiBbZWxlbWVudFtrZXldXTtcbiAgICBmb3IoY29uc3QgbnYgb2YgbmVzdGVkVmFsdWVzKSB7XG4gICAgICBpZighX2lzT2JqZWN0KG52KSB8fCBPYmplY3Qua2V5cyhudikuc29tZShrID0+XG4gICAgICAgIF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBrLCB7dm9jYWI6IHRydWV9LCBvcHRpb25zKSA9PT0gJ0B2YWx1ZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgbmVzdGVkIHZhbHVlIG11c3QgYmUgYSBub2RlIG9iamVjdC4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBAbmVzdCB2YWx1ZScsIHZhbHVlOiBudn0pO1xuICAgICAgfVxuICAgICAgYXdhaXQgX2V4cGFuZE9iamVjdCh7XG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgIGV4cGFuZGVkQWN0aXZlUHJvcGVydHksXG4gICAgICAgIGVsZW1lbnQ6IG52LFxuICAgICAgICBleHBhbmRlZFBhcmVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaW5zaWRlTGlzdCxcbiAgICAgICAgdHlwZVNjb3BlZENvbnRleHQsXG4gICAgICAgIHR5cGVLZXksXG4gICAgICAgIGV4cGFuc2lvbk1hcH0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4cGFuZHMgdGhlIGdpdmVuIHZhbHVlIGJ5IHVzaW5nIHRoZSBjb2VyY2lvbiBhbmQga2V5d29yZCBydWxlcyBpbiB0aGVcbiAqIGdpdmVuIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgYWN0aXZlIGNvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIGFjdGl2ZVByb3BlcnR5IHRoZSBhY3RpdmUgcHJvcGVydHkgdGhlIHZhbHVlIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gZXhwYW5kLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHByb2Nlc3Npbmcgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gX2V4cGFuZFZhbHVlKHthY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCB2YWx1ZSwgb3B0aW9uc30pIHtcbiAgLy8gbm90aGluZyB0byBleHBhbmRcbiAgaWYodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gc3BlY2lhbC1jYXNlIGV4cGFuZCBAaWQgYW5kIEB0eXBlIChza2lwcyAnQGlkJyBleHBhbnNpb24pXG4gIGNvbnN0IGV4cGFuZGVkUHJvcGVydHkgPSBfZXhwYW5kSXJpKFxuICAgIGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpO1xuICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGlkJykge1xuICAgIHJldHVybiBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgdmFsdWUsIHtiYXNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQHR5cGUnKSB7XG4gICAgcmV0dXJuIF9leHBhbmRJcmkoYWN0aXZlQ3R4LCB2YWx1ZSwge3ZvY2FiOiB0cnVlLCBiYXNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBnZXQgdHlwZSBkZWZpbml0aW9uIGZyb20gY29udGV4dFxuICBjb25zdCB0eXBlID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQHR5cGUnKTtcblxuICAvLyBkbyBAaWQgZXhwYW5zaW9uIChhdXRvbWF0aWMgZm9yIEBncmFwaClcbiAgaWYoKHR5cGUgPT09ICdAaWQnIHx8IGV4cGFuZGVkUHJvcGVydHkgPT09ICdAZ3JhcGgnKSAmJiBfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHsnQGlkJzogX2V4cGFuZElyaShhY3RpdmVDdHgsIHZhbHVlLCB7YmFzZTogdHJ1ZX0sIG9wdGlvbnMpfTtcbiAgfVxuICAvLyBkbyBAaWQgZXhwYW5zaW9uIHcvdm9jYWJcbiAgaWYodHlwZSA9PT0gJ0B2b2NhYicgJiYgX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiB7XG4gICAgICAnQGlkJzogX2V4cGFuZElyaShhY3RpdmVDdHgsIHZhbHVlLCB7dm9jYWI6IHRydWUsIGJhc2U6IHRydWV9LCBvcHRpb25zKVxuICAgIH07XG4gIH1cblxuICAvLyBkbyBub3QgZXhwYW5kIGtleXdvcmQgdmFsdWVzXG4gIGlmKF9pc0tleXdvcmQoZXhwYW5kZWRQcm9wZXJ0eSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdCBydmFsID0ge307XG5cbiAgaWYodHlwZSAmJiAhWydAaWQnLCAnQHZvY2FiJywgJ0Bub25lJ10uaW5jbHVkZXModHlwZSkpIHtcbiAgICAvLyBvdGhlciB0eXBlXG4gICAgcnZhbFsnQHR5cGUnXSA9IHR5cGU7XG4gIH0gZWxzZSBpZihfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgLy8gY2hlY2sgZm9yIGxhbmd1YWdlIHRhZ2dpbmcgZm9yIHN0cmluZ3NcbiAgICBjb25zdCBsYW5ndWFnZSA9IF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0BsYW5ndWFnZScpO1xuICAgIGlmKGxhbmd1YWdlICE9PSBudWxsKSB7XG4gICAgICBydmFsWydAbGFuZ3VhZ2UnXSA9IGxhbmd1YWdlO1xuICAgIH1cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAZGlyZWN0aW9uJyk7XG4gICAgaWYoZGlyZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBydmFsWydAZGlyZWN0aW9uJ10gPSBkaXJlY3Rpb247XG4gICAgfVxuICB9XG4gIC8vIGRvIGNvbnZlcnNpb24gb2YgdmFsdWVzIHRoYXQgYXJlbid0IGJhc2ljIEpTT04gdHlwZXMgdG8gc3RyaW5nc1xuICBpZighWydib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJ2YWxbJ0B2YWx1ZSddID0gdmFsdWU7XG5cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogRXhwYW5kcyBhIGxhbmd1YWdlIG1hcC5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBhY3RpdmUgY29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0gbGFuZ3VhZ2VNYXAgdGhlIGxhbmd1YWdlIG1hcCB0byBleHBhbmQuXG4gKiBAcGFyYW0gZGlyZWN0aW9uIHRoZSBkaXJlY3Rpb24gdG8gYXBwbHkgdG8gdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHByb2Nlc3Npbmcgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBsYW5ndWFnZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRMYW5ndWFnZU1hcChhY3RpdmVDdHgsIGxhbmd1YWdlTWFwLCBkaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobGFuZ3VhZ2VNYXApLnNvcnQoKTtcbiAgZm9yKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgZXhwYW5kZWRLZXkgPSBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwga2V5LCB7dm9jYWI6IHRydWV9LCBvcHRpb25zKTtcbiAgICBsZXQgdmFsID0gbGFuZ3VhZ2VNYXBba2V5XTtcbiAgICBpZighX2lzQXJyYXkodmFsKSkge1xuICAgICAgdmFsID0gW3ZhbF07XG4gICAgfVxuICAgIGZvcihjb25zdCBpdGVtIG9mIHZhbCkge1xuICAgICAgaWYoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBudWxsIHZhbHVlcyBhcmUgYWxsb3dlZCAoOC41KSBidXQgaWdub3JlZCAoMy4xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKCFfaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBsYW5ndWFnZSBtYXAgdmFsdWVzIG11c3QgYmUgc3RyaW5ncy4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBsYW5ndWFnZSBtYXAgdmFsdWUnLCBsYW5ndWFnZU1hcH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsID0geydAdmFsdWUnOiBpdGVtfTtcbiAgICAgIGlmKGV4cGFuZGVkS2V5ICE9PSAnQG5vbmUnKSB7XG4gICAgICAgIHZhbFsnQGxhbmd1YWdlJ10gPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmKGRpcmVjdGlvbikge1xuICAgICAgICB2YWxbJ0BkaXJlY3Rpb24nXSA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaCh2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX2V4cGFuZEluZGV4TWFwKFxuICB7YWN0aXZlQ3R4LCBvcHRpb25zLCBhY3RpdmVQcm9wZXJ0eSwgdmFsdWUsIGV4cGFuc2lvbk1hcCwgYXNHcmFwaCxcbiAgICBpbmRleEtleSwgcHJvcGVydHlJbmRleH0pIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKTtcbiAgY29uc3QgaXNUeXBlSW5kZXggPSBpbmRleEtleSA9PT0gJ0B0eXBlJztcbiAgZm9yKGxldCBrZXkgb2Yga2V5cykge1xuICAgIC8vIGlmIGluZGV4S2V5IGlzIEB0eXBlLCB0aGVyZSBtYXkgYmUgYSBjb250ZXh0IGRlZmluZWQgZm9yIGl0XG4gICAgaWYoaXNUeXBlSW5kZXgpIHtcbiAgICAgIGNvbnN0IGN0eCA9IF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBrZXksICdAY29udGV4dCcpO1xuICAgICAgaWYoIV9pc1VuZGVmaW5lZChjdHgpKSB7XG4gICAgICAgIGFjdGl2ZUN0eCA9IGF3YWl0IF9wcm9jZXNzQ29udGV4dCh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGxvY2FsQ3R4OiBjdHgsXG4gICAgICAgICAgcHJvcGFnYXRlOiBmYWxzZSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB2YWwgPSB2YWx1ZVtrZXldO1xuICAgIGlmKCFfaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwgPSBbdmFsXTtcbiAgICB9XG5cbiAgICB2YWwgPSBhd2FpdCBhcGkuZXhwYW5kKHtcbiAgICAgIGFjdGl2ZUN0eCxcbiAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgZWxlbWVudDogdmFsLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGluc2lkZUxpc3Q6IGZhbHNlLFxuICAgICAgaW5zaWRlSW5kZXg6IHRydWUsXG4gICAgICBleHBhbnNpb25NYXBcbiAgICB9KTtcblxuICAgIC8vIGV4cGFuZCBmb3IgQHR5cGUsIGJ1dCBhbHNvIGZvciBAbm9uZVxuICAgIGxldCBleHBhbmRlZEtleTtcbiAgICBpZihwcm9wZXJ0eUluZGV4KSB7XG4gICAgICBpZihrZXkgPT09ICdAbm9uZScpIHtcbiAgICAgICAgZXhwYW5kZWRLZXkgPSAnQG5vbmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwYW5kZWRLZXkgPSBfZXhwYW5kVmFsdWUoXG4gICAgICAgICAge2FjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHk6IGluZGV4S2V5LCB2YWx1ZToga2V5LCBvcHRpb25zfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGFuZGVkS2V5ID0gX2V4cGFuZElyaShhY3RpdmVDdHgsIGtleSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYoaW5kZXhLZXkgPT09ICdAaWQnKSB7XG4gICAgICAvLyBleHBhbmQgZG9jdW1lbnQgcmVsYXRpdmVcbiAgICAgIGtleSA9IF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBrZXksIHtiYXNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmKGlzVHlwZUluZGV4KSB7XG4gICAgICBrZXkgPSBleHBhbmRlZEtleTtcbiAgICB9XG5cbiAgICBmb3IobGV0IGl0ZW0gb2YgdmFsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGFsc28gYSBAZ3JhcGggY29udGFpbmVyLCB0dXJuIGl0ZW1zIGludG8gZ3JhcGhzXG4gICAgICBpZihhc0dyYXBoICYmICFfaXNHcmFwaChpdGVtKSkge1xuICAgICAgICBpdGVtID0geydAZ3JhcGgnOiBbaXRlbV19O1xuICAgICAgfVxuICAgICAgaWYoaW5kZXhLZXkgPT09ICdAdHlwZScpIHtcbiAgICAgICAgaWYoZXhwYW5kZWRLZXkgPT09ICdAbm9uZScpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgQG5vbmVcbiAgICAgICAgfSBlbHNlIGlmKGl0ZW1bJ0B0eXBlJ10pIHtcbiAgICAgICAgICBpdGVtWydAdHlwZSddID0gW2tleV0uY29uY2F0KGl0ZW1bJ0B0eXBlJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bJ0B0eXBlJ10gPSBba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKF9pc1ZhbHVlKGl0ZW0pICYmXG4gICAgICAgICFbJ0BsYW5ndWFnZScsICdAdHlwZScsICdAaW5kZXgnXS5pbmNsdWRlcyhpbmRleEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBBdHRlbXB0IHRvIGFkZCBpbGxlZ2FsIGtleSB0byB2YWx1ZSAnICtcbiAgICAgICAgICBgb2JqZWN0OiBcIiR7aW5kZXhLZXl9XCIuYCxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgdmFsdWUgb2JqZWN0JywgdmFsdWU6IGl0ZW19KTtcbiAgICAgIH0gZWxzZSBpZihwcm9wZXJ0eUluZGV4KSB7XG4gICAgICAgIC8vIGluZGV4IGlzIGEgcHJvcGVydHkgdG8gYmUgZXhwYW5kZWQsIGFuZCB2YWx1ZXMgaW50ZXJwcmV0ZWQgZm9yIHRoYXRcbiAgICAgICAgLy8gcHJvcGVydHlcbiAgICAgICAgaWYoZXhwYW5kZWRLZXkgIT09ICdAbm9uZScpIHtcbiAgICAgICAgICAvLyBleHBhbmQga2V5IGFzIGEgdmFsdWVcbiAgICAgICAgICBfYWRkVmFsdWUoaXRlbSwgcHJvcGVydHlJbmRleCwgZXhwYW5kZWRLZXksIHtcbiAgICAgICAgICAgIHByb3BlcnR5SXNBcnJheTogdHJ1ZSxcbiAgICAgICAgICAgIHByZXBlbmRWYWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoZXhwYW5kZWRLZXkgIT09ICdAbm9uZScgJiYgIShpbmRleEtleSBpbiBpdGVtKSkge1xuICAgICAgICBpdGVtW2luZGV4S2V5XSA9IGtleTtcbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuICBpc1N1YmplY3RSZWZlcmVuY2U6IF9pc1N1YmplY3RSZWZlcmVuY2Vcbn0gPSByZXF1aXJlKCcuL2dyYXBoVHlwZXMnKTtcblxuY29uc3Qge1xuICBjcmVhdGVNZXJnZWROb2RlTWFwOiBfY3JlYXRlTWVyZ2VkTm9kZU1hcFxufSA9IHJlcXVpcmUoJy4vbm9kZU1hcCcpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIFBlcmZvcm1zIEpTT04tTEQgZmxhdHRlbmluZy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGV4cGFuZGVkIEpTT04tTEQgdG8gZmxhdHRlbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBmbGF0dGVuZWQgb3V0cHV0LlxuICovXG5hcGkuZmxhdHRlbiA9IGlucHV0ID0+IHtcbiAgY29uc3QgZGVmYXVsdEdyYXBoID0gX2NyZWF0ZU1lcmdlZE5vZGVNYXAoaW5wdXQpO1xuXG4gIC8vIHByb2R1Y2UgZmxhdHRlbmVkIG91dHB1dFxuICBjb25zdCBmbGF0dGVuZWQgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRHcmFwaCkuc29ydCgpO1xuICBmb3IobGV0IGtpID0gMDsga2kgPCBrZXlzLmxlbmd0aDsgKytraSkge1xuICAgIGNvbnN0IG5vZGUgPSBkZWZhdWx0R3JhcGhba2V5c1traV1dO1xuICAgIC8vIG9ubHkgYWRkIGZ1bGwgc3ViamVjdHMgdG8gdG9wLWxldmVsXG4gICAgaWYoIV9pc1N1YmplY3RSZWZlcmVuY2Uobm9kZSkpIHtcbiAgICAgIGZsYXR0ZW5lZC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmxhdHRlbmVkO1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7aXNLZXl3b3JkfSA9IHJlcXVpcmUoJy4vY29udGV4dCcpO1xuY29uc3QgZ3JhcGhUeXBlcyA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5jb25zdCB7XG4gIGNyZWF0ZU5vZGVNYXA6IF9jcmVhdGVOb2RlTWFwLFxuICBtZXJnZU5vZGVNYXBHcmFwaHM6IF9tZXJnZU5vZGVNYXBHcmFwaHNcbn0gPSByZXF1aXJlKCcuL25vZGVNYXAnKTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBQZXJmb3JtcyBKU09OLUxEIGBtZXJnZWRgIGZyYW1pbmcuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBleHBhbmRlZCBKU09OLUxEIHRvIGZyYW1lLlxuICogQHBhcmFtIGZyYW1lIHRoZSBleHBhbmRlZCBKU09OLUxEIGZyYW1lIHRvIHVzZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBmcmFtaW5nIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB0aGUgZnJhbWVkIG91dHB1dC5cbiAqL1xuYXBpLmZyYW1lTWVyZ2VkT3JEZWZhdWx0ID0gKGlucHV0LCBmcmFtZSwgb3B0aW9ucykgPT4ge1xuICAvLyBjcmVhdGUgZnJhbWluZyBzdGF0ZVxuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBvcHRpb25zLFxuICAgIGVtYmVkZGVkOiBmYWxzZSxcbiAgICBncmFwaDogJ0BkZWZhdWx0JyxcbiAgICBncmFwaE1hcDogeydAZGVmYXVsdCc6IHt9fSxcbiAgICBzdWJqZWN0U3RhY2s6IFtdLFxuICAgIGxpbms6IHt9LFxuICAgIGJub2RlTWFwOiB7fVxuICB9O1xuXG4gIC8vIHByb2R1Y2UgYSBtYXAgb2YgYWxsIGdyYXBocyBhbmQgbmFtZSBlYWNoIGJub2RlXG4gIC8vIEZJWE1FOiBjdXJyZW50bHkgdXNlcyBzdWJqZWN0cyBmcm9tIEBtZXJnZWQgZ3JhcGggb25seVxuICBjb25zdCBpc3N1ZXIgPSBuZXcgdXRpbC5JZGVudGlmaWVySXNzdWVyKCdfOmInKTtcbiAgX2NyZWF0ZU5vZGVNYXAoaW5wdXQsIHN0YXRlLmdyYXBoTWFwLCAnQGRlZmF1bHQnLCBpc3N1ZXIpO1xuICBpZihvcHRpb25zLm1lcmdlZCkge1xuICAgIHN0YXRlLmdyYXBoTWFwWydAbWVyZ2VkJ10gPSBfbWVyZ2VOb2RlTWFwR3JhcGhzKHN0YXRlLmdyYXBoTWFwKTtcbiAgICBzdGF0ZS5ncmFwaCA9ICdAbWVyZ2VkJztcbiAgfVxuICBzdGF0ZS5zdWJqZWN0cyA9IHN0YXRlLmdyYXBoTWFwW3N0YXRlLmdyYXBoXTtcblxuICAvLyBmcmFtZSB0aGUgc3ViamVjdHNcbiAgY29uc3QgZnJhbWVkID0gW107XG4gIGFwaS5mcmFtZShzdGF0ZSwgT2JqZWN0LmtleXMoc3RhdGUuc3ViamVjdHMpLnNvcnQoKSwgZnJhbWUsIGZyYW1lZCk7XG5cbiAgLy8gSWYgcHJ1bmluZyBibGFuayBub2RlcywgZmluZCB0aG9zZSB0byBwcnVuZVxuICBpZihvcHRpb25zLnBydW5lQmxhbmtOb2RlSWRlbnRpZmllcnMpIHtcbiAgICAvLyByZW1vdmUgYWxsIGJsYW5rIG5vZGVzIGFwcGVhcmluZyBvbmx5IG9uY2UsIGRvbmUgaW4gY29tcGFjdGlvblxuICAgIG9wdGlvbnMuYm5vZGVzVG9DbGVhciA9XG4gICAgICBPYmplY3Qua2V5cyhzdGF0ZS5ibm9kZU1hcCkuZmlsdGVyKGlkID0+IHN0YXRlLmJub2RlTWFwW2lkXS5sZW5ndGggPT09IDEpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIEBwcmVzZXJ2ZSBmcm9tIHJlc3VsdHNcbiAgb3B0aW9ucy5saW5rID0ge307XG4gIHJldHVybiBfY2xlYW51cFByZXNlcnZlKGZyYW1lZCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEZyYW1lcyBzdWJqZWN0cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGZyYW1lLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSB0aGUgY3VycmVudCBmcmFtaW5nIHN0YXRlLlxuICogQHBhcmFtIHN1YmplY3RzIHRoZSBzdWJqZWN0cyB0byBmaWx0ZXIuXG4gKiBAcGFyYW0gZnJhbWUgdGhlIGZyYW1lLlxuICogQHBhcmFtIHBhcmVudCB0aGUgcGFyZW50IHN1YmplY3Qgb3IgdG9wLWxldmVsIGFycmF5LlxuICogQHBhcmFtIHByb3BlcnR5IHRoZSBwYXJlbnQgcHJvcGVydHksIGluaXRpYWxpemVkIHRvIG51bGwuXG4gKi9cbmFwaS5mcmFtZSA9IChzdGF0ZSwgc3ViamVjdHMsIGZyYW1lLCBwYXJlbnQsIHByb3BlcnR5ID0gbnVsbCkgPT4ge1xuICAvLyB2YWxpZGF0ZSB0aGUgZnJhbWVcbiAgX3ZhbGlkYXRlRnJhbWUoZnJhbWUpO1xuICBmcmFtZSA9IGZyYW1lWzBdO1xuXG4gIC8vIGdldCBmbGFncyBmb3IgY3VycmVudCBmcmFtZVxuICBjb25zdCBvcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgY29uc3QgZmxhZ3MgPSB7XG4gICAgZW1iZWQ6IF9nZXRGcmFtZUZsYWcoZnJhbWUsIG9wdGlvbnMsICdlbWJlZCcpLFxuICAgIGV4cGxpY2l0OiBfZ2V0RnJhbWVGbGFnKGZyYW1lLCBvcHRpb25zLCAnZXhwbGljaXQnKSxcbiAgICByZXF1aXJlQWxsOiBfZ2V0RnJhbWVGbGFnKGZyYW1lLCBvcHRpb25zLCAncmVxdWlyZUFsbCcpXG4gIH07XG5cbiAgLy8gZ2V0IGxpbmsgZm9yIGN1cnJlbnQgZ3JhcGhcbiAgaWYoIXN0YXRlLmxpbmsuaGFzT3duUHJvcGVydHkoc3RhdGUuZ3JhcGgpKSB7XG4gICAgc3RhdGUubGlua1tzdGF0ZS5ncmFwaF0gPSB7fTtcbiAgfVxuICBjb25zdCBsaW5rID0gc3RhdGUubGlua1tzdGF0ZS5ncmFwaF07XG5cbiAgLy8gZmlsdGVyIG91dCBzdWJqZWN0cyB0aGF0IG1hdGNoIHRoZSBmcmFtZVxuICBjb25zdCBtYXRjaGVzID0gX2ZpbHRlclN1YmplY3RzKHN0YXRlLCBzdWJqZWN0cywgZnJhbWUsIGZsYWdzKTtcblxuICAvLyBhZGQgbWF0Y2hlcyB0byBvdXRwdXRcbiAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMobWF0Y2hlcykuc29ydCgpO1xuICBmb3IoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgY29uc3Qgc3ViamVjdCA9IG1hdGNoZXNbaWRdO1xuXG4gICAgLyogTm90ZTogSW4gb3JkZXIgdG8gdHJlYXQgZWFjaCB0b3AtbGV2ZWwgbWF0Y2ggYXMgYSBjb21wYXJ0bWVudGFsaXplZFxuICAgIHJlc3VsdCwgY2xlYXIgdGhlIHVuaXF1ZSBlbWJlZGRlZCBzdWJqZWN0cyBtYXAgd2hlbiB0aGUgcHJvcGVydHkgaXMgbnVsbCxcbiAgICB3aGljaCBvbmx5IG9jY3VycyBhdCB0aGUgdG9wLWxldmVsLiAqL1xuICAgIGlmKHByb3BlcnR5ID09PSBudWxsKSB7XG4gICAgICBzdGF0ZS51bmlxdWVFbWJlZHMgPSB7W3N0YXRlLmdyYXBoXToge319O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS51bmlxdWVFbWJlZHNbc3RhdGUuZ3JhcGhdID0gc3RhdGUudW5pcXVlRW1iZWRzW3N0YXRlLmdyYXBoXSB8fCB7fTtcbiAgICB9XG5cbiAgICBpZihmbGFncy5lbWJlZCA9PT0gJ0BsaW5rJyAmJiBpZCBpbiBsaW5rKSB7XG4gICAgICAvLyBUT0RPOiBtYXkgd2FudCB0byBhbHNvIG1hdGNoIGFuIGV4aXN0aW5nIGxpbmtlZCBzdWJqZWN0IGFnYWluc3RcbiAgICAgIC8vIHRoZSBjdXJyZW50IGZyYW1lIC4uLiBzbyBkaWZmZXJlbnQgZnJhbWVzIGNvdWxkIHByb2R1Y2UgZGlmZmVyZW50XG4gICAgICAvLyBzdWJqZWN0cyB0aGF0IGFyZSBvbmx5IHNoYXJlZCBpbi1tZW1vcnkgd2hlbiB0aGUgZnJhbWVzIGFyZSB0aGUgc2FtZVxuXG4gICAgICAvLyBhZGQgZXhpc3RpbmcgbGlua2VkIHN1YmplY3RcbiAgICAgIF9hZGRGcmFtZU91dHB1dChwYXJlbnQsIHByb3BlcnR5LCBsaW5rW2lkXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydCBvdXRwdXQgZm9yIHN1YmplY3RcbiAgICBjb25zdCBvdXRwdXQgPSB7J0BpZCc6IGlkfTtcbiAgICBpZihpZC5pbmRleE9mKCdfOicpID09PSAwKSB7XG4gICAgICB1dGlsLmFkZFZhbHVlKHN0YXRlLmJub2RlTWFwLCBpZCwgb3V0cHV0LCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgfVxuICAgIGxpbmtbaWRdID0gb3V0cHV0O1xuXG4gICAgLy8gdmFsaWRhdGUgQGVtYmVkXG4gICAgaWYoKGZsYWdzLmVtYmVkID09PSAnQGZpcnN0JyB8fCBmbGFncy5lbWJlZCA9PT0gJ0BsYXN0JykgJiYgc3RhdGUuaXMxMSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgaW52YWxpZCB2YWx1ZSBvZiBAZW1iZWQuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAZW1iZWQgdmFsdWUnLCBmcmFtZX0pO1xuICAgIH1cblxuICAgIGlmKCFzdGF0ZS5lbWJlZGRlZCAmJiBzdGF0ZS51bmlxdWVFbWJlZHNbc3RhdGUuZ3JhcGhdLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgLy8gc2tpcCBhZGRpbmcgdGhpcyBub2RlIG9iamVjdCB0byB0aGUgdG9wIGxldmVsLCBhcyBpdCB3YXNcbiAgICAgIC8vIGFscmVhZHkgaW5jbHVkZWQgaW4gYW5vdGhlciBub2RlIG9iamVjdFxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaWYgZW1iZWQgaXMgQG5ldmVyIG9yIGlmIGEgY2lyY3VsYXIgcmVmZXJlbmNlIHdvdWxkIGJlIGNyZWF0ZWQgYnkgYW5cbiAgICAvLyBlbWJlZCwgdGhlIHN1YmplY3QgY2Fubm90IGJlIGVtYmVkZGVkLCBqdXN0IGFkZCB0aGUgcmVmZXJlbmNlO1xuICAgIC8vIG5vdGUgdGhhdCBhIGNpcmN1bGFyIHJlZmVyZW5jZSB3b24ndCBvY2N1ciB3aGVuIHRoZSBlbWJlZCBmbGFnIGlzXG4gICAgLy8gYEBsaW5rYCBhcyB0aGUgYWJvdmUgY2hlY2sgd2lsbCBzaG9ydC1jaXJjdWl0IGJlZm9yZSByZWFjaGluZyB0aGlzIHBvaW50XG4gICAgaWYoc3RhdGUuZW1iZWRkZWQgJiZcbiAgICAgIChmbGFncy5lbWJlZCA9PT0gJ0BuZXZlcicgfHxcbiAgICAgIF9jcmVhdGVzQ2lyY3VsYXJSZWZlcmVuY2Uoc3ViamVjdCwgc3RhdGUuZ3JhcGgsIHN0YXRlLnN1YmplY3RTdGFjaykpKSB7XG4gICAgICBfYWRkRnJhbWVPdXRwdXQocGFyZW50LCBwcm9wZXJ0eSwgb3V0cHV0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGlmIG9ubHkgdGhlIGZpcnN0IChvciBvbmNlKSBzaG91bGQgYmUgZW1iZWRkZWRcbiAgICBpZihzdGF0ZS5lbWJlZGRlZCAmJlxuICAgICAgIChmbGFncy5lbWJlZCA9PSAnQGZpcnN0JyB8fCBmbGFncy5lbWJlZCA9PSAnQG9uY2UnKSAmJlxuICAgICAgIHN0YXRlLnVuaXF1ZUVtYmVkc1tzdGF0ZS5ncmFwaF0uaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBfYWRkRnJhbWVPdXRwdXQocGFyZW50LCBwcm9wZXJ0eSwgb3V0cHV0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGlmIG9ubHkgdGhlIGxhc3QgbWF0Y2ggc2hvdWxkIGJlIGVtYmVkZGVkXG4gICAgaWYoZmxhZ3MuZW1iZWQgPT09ICdAbGFzdCcpIHtcbiAgICAgIC8vIHJlbW92ZSBhbnkgZXhpc3RpbmcgZW1iZWRcbiAgICAgIGlmKGlkIGluIHN0YXRlLnVuaXF1ZUVtYmVkc1tzdGF0ZS5ncmFwaF0pIHtcbiAgICAgICAgX3JlbW92ZUVtYmVkKHN0YXRlLCBpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUudW5pcXVlRW1iZWRzW3N0YXRlLmdyYXBoXVtpZF0gPSB7cGFyZW50LCBwcm9wZXJ0eX07XG5cbiAgICAvLyBwdXNoIG1hdGNoaW5nIHN1YmplY3Qgb250byBzdGFjayB0byBlbmFibGUgY2lyY3VsYXIgZW1iZWQgY2hlY2tzXG4gICAgc3RhdGUuc3ViamVjdFN0YWNrLnB1c2goe3N1YmplY3QsIGdyYXBoOiBzdGF0ZS5ncmFwaH0pO1xuXG4gICAgLy8gc3ViamVjdCBpcyBhbHNvIHRoZSBuYW1lIG9mIGEgZ3JhcGhcbiAgICBpZihpZCBpbiBzdGF0ZS5ncmFwaE1hcCkge1xuICAgICAgbGV0IHJlY3Vyc2UgPSBmYWxzZTtcbiAgICAgIGxldCBzdWJmcmFtZSA9IG51bGw7XG4gICAgICBpZighKCdAZ3JhcGgnIGluIGZyYW1lKSkge1xuICAgICAgICByZWN1cnNlID0gc3RhdGUuZ3JhcGggIT09ICdAbWVyZ2VkJztcbiAgICAgICAgc3ViZnJhbWUgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YmZyYW1lID0gZnJhbWVbJ0BncmFwaCddWzBdO1xuICAgICAgICByZWN1cnNlID0gIShpZCA9PT0gJ0BtZXJnZWQnIHx8IGlkID09PSAnQGRlZmF1bHQnKTtcbiAgICAgICAgaWYoIXR5cGVzLmlzT2JqZWN0KHN1YmZyYW1lKSkge1xuICAgICAgICAgIHN1YmZyYW1lID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocmVjdXJzZSkge1xuICAgICAgICAvLyByZWN1cnNlIGludG8gZ3JhcGhcbiAgICAgICAgYXBpLmZyYW1lKFxuICAgICAgICAgIHsuLi5zdGF0ZSwgZ3JhcGg6IGlkLCBlbWJlZGRlZDogZmFsc2V9LFxuICAgICAgICAgIE9iamVjdC5rZXlzKHN0YXRlLmdyYXBoTWFwW2lkXSkuc29ydCgpLCBbc3ViZnJhbWVdLCBvdXRwdXQsICdAZ3JhcGgnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBmcmFtZSBoYXMgQGluY2x1ZGVkLCByZWN1cnNlIG92ZXIgaXRzIHN1Yi1mcmFtZVxuICAgIGlmKCdAaW5jbHVkZWQnIGluIGZyYW1lKSB7XG4gICAgICBhcGkuZnJhbWUoXG4gICAgICAgIHsuLi5zdGF0ZSwgZW1iZWRkZWQ6IGZhbHNlfSxcbiAgICAgICAgc3ViamVjdHMsIGZyYW1lWydAaW5jbHVkZWQnXSwgb3V0cHV0LCAnQGluY2x1ZGVkJyk7XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHN1YmplY3QgcHJvcGVydGllc1xuICAgIGZvcihjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKHN1YmplY3QpLnNvcnQoKSkge1xuICAgICAgLy8gY29weSBrZXl3b3JkcyB0byBvdXRwdXRcbiAgICAgIGlmKGlzS2V5d29yZChwcm9wKSkge1xuICAgICAgICBvdXRwdXRbcHJvcF0gPSB1dGlsLmNsb25lKHN1YmplY3RbcHJvcF0pO1xuXG4gICAgICAgIGlmKHByb3AgPT09ICdAdHlwZScpIHtcbiAgICAgICAgICAvLyBjb3VudCBibm9kZSB2YWx1ZXMgb2YgQHR5cGVcbiAgICAgICAgICBmb3IoY29uc3QgdHlwZSBvZiBzdWJqZWN0WydAdHlwZSddKSB7XG4gICAgICAgICAgICBpZih0eXBlLmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgICAgICAgICAgdXRpbC5hZGRWYWx1ZShcbiAgICAgICAgICAgICAgICBzdGF0ZS5ibm9kZU1hcCwgdHlwZSwgb3V0cHV0LCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBleHBsaWNpdCBpcyBvbiBhbmQgcHJvcGVydHkgaXNuJ3QgaW4gdGhlIGZyYW1lLCBza2lwIHByb2Nlc3NpbmdcbiAgICAgIGlmKGZsYWdzLmV4cGxpY2l0ICYmICEocHJvcCBpbiBmcmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBvYmplY3RzXG4gICAgICBmb3IoY29uc3QgbyBvZiBzdWJqZWN0W3Byb3BdKSB7XG4gICAgICAgIGNvbnN0IHN1YmZyYW1lID0gKHByb3AgaW4gZnJhbWUgP1xuICAgICAgICAgIGZyYW1lW3Byb3BdIDogX2NyZWF0ZUltcGxpY2l0RnJhbWUoZmxhZ3MpKTtcblxuICAgICAgICAvLyByZWN1cnNlIGludG8gbGlzdFxuICAgICAgICBpZihncmFwaFR5cGVzLmlzTGlzdChvKSkge1xuICAgICAgICAgIGNvbnN0IHN1YmZyYW1lID1cbiAgICAgICAgICAgIChmcmFtZVtwcm9wXSAmJiBmcmFtZVtwcm9wXVswXSAmJiBmcmFtZVtwcm9wXVswXVsnQGxpc3QnXSkgP1xuICAgICAgICAgICAgICBmcmFtZVtwcm9wXVswXVsnQGxpc3QnXSA6XG4gICAgICAgICAgICAgIF9jcmVhdGVJbXBsaWNpdEZyYW1lKGZsYWdzKTtcblxuICAgICAgICAgIC8vIGFkZCBlbXB0eSBsaXN0XG4gICAgICAgICAgY29uc3QgbGlzdCA9IHsnQGxpc3QnOiBbXX07XG4gICAgICAgICAgX2FkZEZyYW1lT3V0cHV0KG91dHB1dCwgcHJvcCwgbGlzdCk7XG5cbiAgICAgICAgICAvLyBhZGQgbGlzdCBvYmplY3RzXG4gICAgICAgICAgY29uc3Qgc3JjID0gb1snQGxpc3QnXTtcbiAgICAgICAgICBmb3IoY29uc3Qgb28gb2Ygc3JjKSB7XG4gICAgICAgICAgICBpZihncmFwaFR5cGVzLmlzU3ViamVjdFJlZmVyZW5jZShvbykpIHtcbiAgICAgICAgICAgICAgLy8gcmVjdXJzZSBpbnRvIHN1YmplY3QgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIGFwaS5mcmFtZShcbiAgICAgICAgICAgICAgICB7Li4uc3RhdGUsIGVtYmVkZGVkOiB0cnVlfSxcbiAgICAgICAgICAgICAgICBbb29bJ0BpZCddXSwgc3ViZnJhbWUsIGxpc3QsICdAbGlzdCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaW5jbHVkZSBvdGhlciB2YWx1ZXMgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgICBfYWRkRnJhbWVPdXRwdXQobGlzdCwgJ0BsaXN0JywgdXRpbC5jbG9uZShvbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNTdWJqZWN0UmVmZXJlbmNlKG8pKSB7XG4gICAgICAgICAgLy8gcmVjdXJzZSBpbnRvIHN1YmplY3QgcmVmZXJlbmNlXG4gICAgICAgICAgYXBpLmZyYW1lKFxuICAgICAgICAgICAgey4uLnN0YXRlLCBlbWJlZGRlZDogdHJ1ZX0sXG4gICAgICAgICAgICBbb1snQGlkJ11dLCBzdWJmcmFtZSwgb3V0cHV0LCBwcm9wKTtcbiAgICAgICAgfSBlbHNlIGlmKF92YWx1ZU1hdGNoKHN1YmZyYW1lWzBdLCBvKSkge1xuICAgICAgICAgIC8vIGluY2x1ZGUgb3RoZXIgdmFsdWVzLCBpZiB0aGV5IG1hdGNoXG4gICAgICAgICAgX2FkZEZyYW1lT3V0cHV0KG91dHB1dCwgcHJvcCwgdXRpbC5jbG9uZShvKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgZGVmYXVsdHNcbiAgICBmb3IoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhmcmFtZSkuc29ydCgpKSB7XG4gICAgICAvLyBza2lwIGtleXdvcmRzXG4gICAgICBpZihwcm9wID09PSAnQHR5cGUnKSB7XG4gICAgICAgIGlmKCF0eXBlcy5pc09iamVjdChmcmFtZVtwcm9wXVswXSkgfHxcbiAgICAgICAgICAgISgnQGRlZmF1bHQnIGluIGZyYW1lW3Byb3BdWzBdKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IHRocm91Z2ggZGVmYXVsdCB0eXBlc1xuICAgICAgfSBlbHNlIGlmKGlzS2V5d29yZChwcm9wKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgb21pdCBkZWZhdWx0IGlzIG9mZiwgdGhlbiBpbmNsdWRlIGRlZmF1bHQgdmFsdWVzIGZvciBwcm9wZXJ0aWVzXG4gICAgICAvLyB0aGF0IGFwcGVhciBpbiB0aGUgbmV4dCBmcmFtZSBidXQgYXJlIG5vdCBpbiB0aGUgbWF0Y2hpbmcgc3ViamVjdFxuICAgICAgY29uc3QgbmV4dCA9IGZyYW1lW3Byb3BdWzBdIHx8IHt9O1xuICAgICAgY29uc3Qgb21pdERlZmF1bHRPbiA9IF9nZXRGcmFtZUZsYWcobmV4dCwgb3B0aW9ucywgJ29taXREZWZhdWx0Jyk7XG4gICAgICBpZighb21pdERlZmF1bHRPbiAmJiAhKHByb3AgaW4gb3V0cHV0KSkge1xuICAgICAgICBsZXQgcHJlc2VydmUgPSAnQG51bGwnO1xuICAgICAgICBpZignQGRlZmF1bHQnIGluIG5leHQpIHtcbiAgICAgICAgICBwcmVzZXJ2ZSA9IHV0aWwuY2xvbmUobmV4dFsnQGRlZmF1bHQnXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXR5cGVzLmlzQXJyYXkocHJlc2VydmUpKSB7XG4gICAgICAgICAgcHJlc2VydmUgPSBbcHJlc2VydmVdO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFtwcm9wXSA9IFt7J0BwcmVzZXJ2ZSc6IHByZXNlcnZlfV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgZW1iZWQgcmV2ZXJzZSB2YWx1ZXMgYnkgZmluZGluZyBub2RlcyBoYXZpbmcgdGhpcyBzdWJqZWN0IGFzIGEgdmFsdWVcbiAgICAvLyBvZiB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eVxuICAgIGZvcihjb25zdCByZXZlcnNlUHJvcCBvZiBPYmplY3Qua2V5cyhmcmFtZVsnQHJldmVyc2UnXSB8fCB7fSkuc29ydCgpKSB7XG4gICAgICBjb25zdCBzdWJmcmFtZSA9IGZyYW1lWydAcmV2ZXJzZSddW3JldmVyc2VQcm9wXTtcbiAgICAgIGZvcihjb25zdCBzdWJqZWN0IG9mIE9iamVjdC5rZXlzKHN0YXRlLnN1YmplY3RzKSkge1xuICAgICAgICBjb25zdCBub2RlVmFsdWVzID1cbiAgICAgICAgICB1dGlsLmdldFZhbHVlcyhzdGF0ZS5zdWJqZWN0c1tzdWJqZWN0XSwgcmV2ZXJzZVByb3ApO1xuICAgICAgICBpZihub2RlVmFsdWVzLnNvbWUodiA9PiB2WydAaWQnXSA9PT0gaWQpKSB7XG4gICAgICAgICAgLy8gbm9kZSBoYXMgcHJvcGVydHkgcmVmZXJlbmNpbmcgdGhpcyBzdWJqZWN0LCByZWN1cnNlXG4gICAgICAgICAgb3V0cHV0WydAcmV2ZXJzZSddID0gb3V0cHV0WydAcmV2ZXJzZSddIHx8IHt9O1xuICAgICAgICAgIHV0aWwuYWRkVmFsdWUoXG4gICAgICAgICAgICBvdXRwdXRbJ0ByZXZlcnNlJ10sIHJldmVyc2VQcm9wLCBbXSwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgICAgICAgIGFwaS5mcmFtZShcbiAgICAgICAgICAgIHsuLi5zdGF0ZSwgZW1iZWRkZWQ6IHRydWV9LFxuICAgICAgICAgICAgW3N1YmplY3RdLCBzdWJmcmFtZSwgb3V0cHV0WydAcmV2ZXJzZSddW3JldmVyc2VQcm9wXSxcbiAgICAgICAgICAgIHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBvdXRwdXQgdG8gcGFyZW50XG4gICAgX2FkZEZyYW1lT3V0cHV0KHBhcmVudCwgcHJvcGVydHksIG91dHB1dCk7XG5cbiAgICAvLyBwb3AgbWF0Y2hpbmcgc3ViamVjdCBmcm9tIGNpcmN1bGFyIHJlZi1jaGVja2luZyBzdGFja1xuICAgIHN0YXRlLnN1YmplY3RTdGFjay5wb3AoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBsYWNlIGBAbnVsbGAgd2l0aCBgbnVsbGAsIHJlbW92aW5nIGl0IGZyb20gYXJyYXlzLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgZnJhbWVkLCBjb21wYWN0ZWQgb3V0cHV0LlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIGZyYW1pbmcgb3B0aW9ucyB1c2VkLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBvdXRwdXQuXG4gKi9cbmFwaS5jbGVhbnVwTnVsbCA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICAvLyByZWN1cnNlIHRocm91Z2ggYXJyYXlzXG4gIGlmKHR5cGVzLmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgY29uc3Qgbm9OdWxscyA9IGlucHV0Lm1hcCh2ID0+IGFwaS5jbGVhbnVwTnVsbCh2LCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG5vTnVsbHMuZmlsdGVyKHYgPT4gdik7IC8vIHJlbW92ZXMgbnVsbHMgZnJvbSBhcnJheVxuICB9XG5cbiAgaWYoaW5wdXQgPT09ICdAbnVsbCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmKHR5cGVzLmlzT2JqZWN0KGlucHV0KSkge1xuICAgIC8vIGhhbmRsZSBpbi1tZW1vcnkgbGlua2VkIG5vZGVzXG4gICAgaWYoJ0BpZCcgaW4gaW5wdXQpIHtcbiAgICAgIGNvbnN0IGlkID0gaW5wdXRbJ0BpZCddO1xuICAgICAgaWYob3B0aW9ucy5saW5rLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBjb25zdCBpZHggPSBvcHRpb25zLmxpbmtbaWRdLmluZGV4T2YoaW5wdXQpO1xuICAgICAgICBpZihpZHggIT09IC0xKSB7XG4gICAgICAgICAgLy8gYWxyZWFkeSB2aXNpdGVkXG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMubGlua1tpZF1baWR4XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50IGNpcmN1bGFyIHZpc2l0YXRpb25cbiAgICAgICAgb3B0aW9ucy5saW5rW2lkXS5wdXNoKGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHByZXZlbnQgY2lyY3VsYXIgdmlzaXRhdGlvblxuICAgICAgICBvcHRpb25zLmxpbmtbaWRdID0gW2lucHV0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgICBpbnB1dFtrZXldID0gYXBpLmNsZWFudXBOdWxsKGlucHV0W2tleV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW1wbGljaXQgZnJhbWUgd2hlbiByZWN1cnNpbmcgdGhyb3VnaCBzdWJqZWN0IG1hdGNoZXMuIElmXG4gKiBhIGZyYW1lIGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBmcmFtZSBmb3IgYSBwYXJ0aWN1bGFyIHByb3BlcnR5LCB0aGVuXG4gKiBhIHdpbGRjYXJkIGNoaWxkIGZyYW1lIHdpbGwgYmUgY3JlYXRlZCB0aGF0IHVzZXMgdGhlIHNhbWUgZmxhZ3MgdGhhdCB0aGVcbiAqIHBhcmVudCBmcmFtZSB1c2VkLlxuICpcbiAqIEBwYXJhbSBmbGFncyB0aGUgY3VycmVudCBmcmFtaW5nIGZsYWdzLlxuICpcbiAqIEByZXR1cm4gdGhlIGltcGxpY2l0IGZyYW1lLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlSW1wbGljaXRGcmFtZShmbGFncykge1xuICBjb25zdCBmcmFtZSA9IHt9O1xuICBmb3IoY29uc3Qga2V5IGluIGZsYWdzKSB7XG4gICAgaWYoZmxhZ3Nba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcmFtZVsnQCcgKyBrZXldID0gW2ZsYWdzW2tleV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2ZyYW1lXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdGhlIGN1cnJlbnQgc3ViamVjdCBzdGFjayB0byBzZWUgaWYgZW1iZWRkaW5nIHRoZSBnaXZlbiBzdWJqZWN0XG4gKiB3b3VsZCBjYXVzZSBhIGNpcmN1bGFyIHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0gc3ViamVjdFRvRW1iZWQgdGhlIHN1YmplY3QgdG8gZW1iZWQuXG4gKiBAcGFyYW0gZ3JhcGggdGhlIGdyYXBoIHRoZSBzdWJqZWN0IHRvIGVtYmVkIGlzIGluLlxuICogQHBhcmFtIHN1YmplY3RTdGFjayB0aGUgY3VycmVudCBzdGFjayBvZiBzdWJqZWN0cy5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgYSBjaXJjdWxhciByZWZlcmVuY2Ugd291bGQgYmUgY3JlYXRlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfY3JlYXRlc0NpcmN1bGFyUmVmZXJlbmNlKHN1YmplY3RUb0VtYmVkLCBncmFwaCwgc3ViamVjdFN0YWNrKSB7XG4gIGZvcihsZXQgaSA9IHN1YmplY3RTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGNvbnN0IHN1YmplY3QgPSBzdWJqZWN0U3RhY2tbaV07XG4gICAgaWYoc3ViamVjdC5ncmFwaCA9PT0gZ3JhcGggJiZcbiAgICAgIHN1YmplY3Quc3ViamVjdFsnQGlkJ10gPT09IHN1YmplY3RUb0VtYmVkWydAaWQnXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBmcmFtZSBmbGFnIHZhbHVlIGZvciB0aGUgZ2l2ZW4gZmxhZyBuYW1lLlxuICpcbiAqIEBwYXJhbSBmcmFtZSB0aGUgZnJhbWUuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgZnJhbWluZyBvcHRpb25zLlxuICogQHBhcmFtIG5hbWUgdGhlIGZsYWcgbmFtZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBmbGFnIHZhbHVlLlxuICovXG5mdW5jdGlvbiBfZ2V0RnJhbWVGbGFnKGZyYW1lLCBvcHRpb25zLCBuYW1lKSB7XG4gIGNvbnN0IGZsYWcgPSAnQCcgKyBuYW1lO1xuICBsZXQgcnZhbCA9IChmbGFnIGluIGZyYW1lID8gZnJhbWVbZmxhZ11bMF0gOiBvcHRpb25zW25hbWVdKTtcbiAgaWYobmFtZSA9PT0gJ2VtYmVkJykge1xuICAgIC8vIGRlZmF1bHQgaXMgXCJAbGFzdFwiXG4gICAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgc3VwcG9ydCBmb3IgXCJlbWJlZFwiIG1hcHM6XG4gICAgLy8gdHJ1ZSA9PiBcIkBsYXN0XCJcbiAgICAvLyBmYWxzZSA9PiBcIkBuZXZlclwiXG4gICAgaWYocnZhbCA9PT0gdHJ1ZSkge1xuICAgICAgcnZhbCA9ICdAb25jZSc7XG4gICAgfSBlbHNlIGlmKHJ2YWwgPT09IGZhbHNlKSB7XG4gICAgICBydmFsID0gJ0BuZXZlcic7XG4gICAgfSBlbHNlIGlmKHJ2YWwgIT09ICdAYWx3YXlzJyAmJiBydmFsICE9PSAnQG5ldmVyJyAmJiBydmFsICE9PSAnQGxpbmsnICYmXG4gICAgICBydmFsICE9PSAnQGZpcnN0JyAmJiBydmFsICE9PSAnQGxhc3QnICYmIHJ2YWwgIT09ICdAb25jZScpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGludmFsaWQgdmFsdWUgb2YgQGVtYmVkLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQGVtYmVkIHZhbHVlJywgZnJhbWV9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgSlNPTi1MRCBmcmFtZSwgdGhyb3dpbmcgYW4gZXhjZXB0aW9uIGlmIHRoZSBmcmFtZSBpcyBpbnZhbGlkLlxuICpcbiAqIEBwYXJhbSBmcmFtZSB0aGUgZnJhbWUgdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIF92YWxpZGF0ZUZyYW1lKGZyYW1lKSB7XG4gIGlmKCF0eXBlcy5pc0FycmF5KGZyYW1lKSB8fCBmcmFtZS5sZW5ndGggIT09IDEgfHwgIXR5cGVzLmlzT2JqZWN0KGZyYW1lWzBdKSkge1xuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIEpTT04tTEQgZnJhbWUgbXVzdCBiZSBhIHNpbmdsZSBvYmplY3QuJyxcbiAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7ZnJhbWV9KTtcbiAgfVxuXG4gIGlmKCdAaWQnIGluIGZyYW1lWzBdKSB7XG4gICAgZm9yKGNvbnN0IGlkIG9mIHV0aWwuYXNBcnJheShmcmFtZVswXVsnQGlkJ10pKSB7XG4gICAgICAvLyBAaWQgbXVzdCBiZSB3aWxkY2FyZCBvciBhbiBJUklcbiAgICAgIGlmKCEodHlwZXMuaXNPYmplY3QoaWQpIHx8IHVybC5pc0Fic29sdXRlKGlkKSkgfHxcbiAgICAgICAgKHR5cGVzLmlzU3RyaW5nKGlkKSAmJiBpZC5pbmRleE9mKCdfOicpID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGludmFsaWQgQGlkIGluIGZyYW1lLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBmcmFtZScsIGZyYW1lfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYoJ0B0eXBlJyBpbiBmcmFtZVswXSkge1xuICAgIGZvcihjb25zdCB0eXBlIG9mIHV0aWwuYXNBcnJheShmcmFtZVswXVsnQHR5cGUnXSkpIHtcbiAgICAgIC8vIEBpZCBtdXN0IGJlIHdpbGRjYXJkIG9yIGFuIElSSVxuICAgICAgaWYoISh0eXBlcy5pc09iamVjdCh0eXBlKSB8fCB1cmwuaXNBYnNvbHV0ZSh0eXBlKSkgfHxcbiAgICAgICAgKHR5cGVzLmlzU3RyaW5nKHR5cGUpICYmIHR5cGUuaW5kZXhPZignXzonKSA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBpbnZhbGlkIEB0eXBlIGluIGZyYW1lLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBmcmFtZScsIGZyYW1lfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG1hcCBvZiBhbGwgb2YgdGhlIHN1YmplY3RzIHRoYXQgbWF0Y2ggYSBwYXJzZWQgZnJhbWUuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBjdXJyZW50IGZyYW1pbmcgc3RhdGUuXG4gKiBAcGFyYW0gc3ViamVjdHMgdGhlIHNldCBvZiBzdWJqZWN0cyB0byBmaWx0ZXIuXG4gKiBAcGFyYW0gZnJhbWUgdGhlIHBhcnNlZCBmcmFtZS5cbiAqIEBwYXJhbSBmbGFncyB0aGUgZnJhbWUgZmxhZ3MuXG4gKlxuICogQHJldHVybiBhbGwgb2YgdGhlIG1hdGNoZWQgc3ViamVjdHMuXG4gKi9cbmZ1bmN0aW9uIF9maWx0ZXJTdWJqZWN0cyhzdGF0ZSwgc3ViamVjdHMsIGZyYW1lLCBmbGFncykge1xuICAvLyBmaWx0ZXIgc3ViamVjdHMgaW4gQGlkIG9yZGVyXG4gIGNvbnN0IHJ2YWwgPSB7fTtcbiAgZm9yKGNvbnN0IGlkIG9mIHN1YmplY3RzKSB7XG4gICAgY29uc3Qgc3ViamVjdCA9IHN0YXRlLmdyYXBoTWFwW3N0YXRlLmdyYXBoXVtpZF07XG4gICAgaWYoX2ZpbHRlclN1YmplY3Qoc3RhdGUsIHN1YmplY3QsIGZyYW1lLCBmbGFncykpIHtcbiAgICAgIHJ2YWxbaWRdID0gc3ViamVjdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdWJqZWN0IG1hdGNoZXMgdGhlIGdpdmVuIGZyYW1lLlxuICpcbiAqIE1hdGNoZXMgZWl0aGVyIGJhc2VkIG9uIGV4cGxpY2l0IHR5cGUgaW5jbHVzaW9uIHdoZXJlIHRoZSBub2RlIGhhcyBhbnlcbiAqIHR5cGUgbGlzdGVkIGluIHRoZSBmcmFtZS4gSWYgdGhlIGZyYW1lIGhhcyBlbXB0eSB0eXBlcyBkZWZpbmVkIG1hdGNoZXNcbiAqIG5vZGVzIG5vdCBoYXZpbmcgYSBAdHlwZS4gSWYgdGhlIGZyYW1lIGhhcyBhIHR5cGUgb2Yge30gZGVmaW5lZCBtYXRjaGVzXG4gKiBub2RlcyBoYXZpbmcgYW55IHR5cGUgZGVmaW5lZC5cbiAqXG4gKiBPdGhlcndpc2UsIGRvZXMgZHVjayB0eXBpbmcsIHdoZXJlIHRoZSBub2RlIG11c3QgaGF2ZSBhbGwgb2YgdGhlXG4gKiBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSB0aGUgY3VycmVudCBmcmFtaW5nIHN0YXRlLlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gY2hlY2suXG4gKiBAcGFyYW0gZnJhbWUgdGhlIGZyYW1lIHRvIGNoZWNrLlxuICogQHBhcmFtIGZsYWdzIHRoZSBmcmFtZSBmbGFncy5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHN1YmplY3QgbWF0Y2hlcywgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZmlsdGVyU3ViamVjdChzdGF0ZSwgc3ViamVjdCwgZnJhbWUsIGZsYWdzKSB7XG4gIC8vIGNoZWNrIGR1Y2t0eXBlXG4gIGxldCB3aWxkY2FyZCA9IHRydWU7XG4gIGxldCBtYXRjaGVzU29tZSA9IGZhbHNlO1xuXG4gIGZvcihjb25zdCBrZXkgaW4gZnJhbWUpIHtcbiAgICBsZXQgbWF0Y2hUaGlzID0gZmFsc2U7XG4gICAgY29uc3Qgbm9kZVZhbHVlcyA9IHV0aWwuZ2V0VmFsdWVzKHN1YmplY3QsIGtleSk7XG4gICAgY29uc3QgaXNFbXB0eSA9IHV0aWwuZ2V0VmFsdWVzKGZyYW1lLCBrZXkpLmxlbmd0aCA9PT0gMDtcblxuICAgIGlmKGtleSA9PT0gJ0BpZCcpIHtcbiAgICAgIC8vIG1hdGNoIG9uIG5vIEBpZCBvciBhbnkgbWF0Y2hpbmcgQGlkLCBpbmNsdWRpbmcgd2lsZGNhcmRcbiAgICAgIGlmKHR5cGVzLmlzRW1wdHlPYmplY3QoZnJhbWVbJ0BpZCddWzBdIHx8IHt9KSkge1xuICAgICAgICBtYXRjaFRoaXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmKGZyYW1lWydAaWQnXS5sZW5ndGggPj0gMCkge1xuICAgICAgICBtYXRjaFRoaXMgPSBmcmFtZVsnQGlkJ10uaW5jbHVkZXMobm9kZVZhbHVlc1swXSk7XG4gICAgICB9XG4gICAgICBpZighZmxhZ3MucmVxdWlyZUFsbCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hUaGlzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihrZXkgPT09ICdAdHlwZScpIHtcbiAgICAgIC8vIGNoZWNrIEB0eXBlIChvYmplY3QgdmFsdWUgbWVhbnMgJ2FueScgdHlwZSxcbiAgICAgIC8vIGZhbGwgdGhyb3VnaCB0byBkdWNrdHlwaW5nKVxuICAgICAgd2lsZGNhcmQgPSBmYWxzZTtcbiAgICAgIGlmKGlzRW1wdHkpIHtcbiAgICAgICAgaWYobm9kZVZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gZG9uJ3QgbWF0Y2ggb24gbm8gQHR5cGVcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hUaGlzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZihmcmFtZVsnQHR5cGUnXS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgdHlwZXMuaXNFbXB0eU9iamVjdChmcmFtZVsnQHR5cGUnXVswXSkpIHtcbiAgICAgICAgLy8gbWF0Y2ggb24gd2lsZGNhcmQgQHR5cGUgaWYgdGhlcmUgaXMgYSB0eXBlXG4gICAgICAgIG1hdGNoVGhpcyA9IG5vZGVWYWx1ZXMubGVuZ3RoID4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1hdGNoIG9uIGEgc3BlY2lmaWMgQHR5cGVcbiAgICAgICAgZm9yKGNvbnN0IHR5cGUgb2YgZnJhbWVbJ0B0eXBlJ10pIHtcbiAgICAgICAgICBpZih0eXBlcy5pc09iamVjdCh0eXBlKSAmJiAnQGRlZmF1bHQnIGluIHR5cGUpIHtcbiAgICAgICAgICAgIC8vIG1hdGNoIG9uIGRlZmF1bHQgb2JqZWN0XG4gICAgICAgICAgICBtYXRjaFRoaXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaFRoaXMgPSBtYXRjaFRoaXMgfHwgbm9kZVZhbHVlcy5zb21lKHR0ID0+IHR0ID09PSB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKCFmbGFncy5yZXF1aXJlQWxsKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFRoaXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGlzS2V5d29yZChrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yY2UgYSBjb3B5IG9mIHRoaXMgZnJhbWUgZW50cnkgc28gaXQgY2FuIGJlIG1hbmlwdWxhdGVkXG4gICAgICBjb25zdCB0aGlzRnJhbWUgPSB1dGlsLmdldFZhbHVlcyhmcmFtZSwga2V5KVswXTtcbiAgICAgIGxldCBoYXNEZWZhdWx0ID0gZmFsc2U7XG4gICAgICBpZih0aGlzRnJhbWUpIHtcbiAgICAgICAgX3ZhbGlkYXRlRnJhbWUoW3RoaXNGcmFtZV0pO1xuICAgICAgICBoYXNEZWZhdWx0ID0gJ0BkZWZhdWx0JyBpbiB0aGlzRnJhbWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIGxvbmdlciBhIHdpbGRjYXJkIHBhdHRlcm4gaWYgZnJhbWUgaGFzIGFueSBub24ta2V5d29yZCBwcm9wZXJ0aWVzXG4gICAgICB3aWxkY2FyZCA9IGZhbHNlO1xuXG4gICAgICAvLyBza2lwLCBidXQgYWxsb3cgbWF0Y2ggaWYgbm9kZSBoYXMgbm8gdmFsdWUgZm9yIHByb3BlcnR5LCBhbmQgZnJhbWUgaGFzXG4gICAgICAvLyBhIGRlZmF1bHQgdmFsdWVcbiAgICAgIGlmKG5vZGVWYWx1ZXMubGVuZ3RoID09PSAwICYmIGhhc0RlZmF1bHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGZyYW1lIHZhbHVlIGlzIGVtcHR5LCBkb24ndCBtYXRjaCBpZiBzdWJqZWN0IGhhcyBhbnkgdmFsdWVcbiAgICAgIGlmKG5vZGVWYWx1ZXMubGVuZ3RoID4gMCAmJiBpc0VtcHR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYodGhpc0ZyYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbm9kZSBkb2VzIG5vdCBtYXRjaCBpZiB2YWx1ZXMgaXMgbm90IGVtcHR5IGFuZCB0aGUgdmFsdWUgb2YgcHJvcGVydHlcbiAgICAgICAgLy8gaW4gZnJhbWUgaXMgbWF0Y2ggbm9uZS5cbiAgICAgICAgaWYobm9kZVZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoVGhpcyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZihncmFwaFR5cGVzLmlzTGlzdCh0aGlzRnJhbWUpKSB7XG4gICAgICAgICAgY29uc3QgbGlzdFZhbHVlID0gdGhpc0ZyYW1lWydAbGlzdCddWzBdO1xuICAgICAgICAgIGlmKGdyYXBoVHlwZXMuaXNMaXN0KG5vZGVWYWx1ZXNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlTGlzdFZhbHVlcyA9IG5vZGVWYWx1ZXNbMF1bJ0BsaXN0J107XG5cbiAgICAgICAgICAgIGlmKGdyYXBoVHlwZXMuaXNWYWx1ZShsaXN0VmFsdWUpKSB7XG4gICAgICAgICAgICAgIC8vIG1hdGNoIG9uIGFueSBtYXRjaGluZyB2YWx1ZVxuICAgICAgICAgICAgICBtYXRjaFRoaXMgPSBub2RlTGlzdFZhbHVlcy5zb21lKGx2ID0+IF92YWx1ZU1hdGNoKGxpc3RWYWx1ZSwgbHYpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihncmFwaFR5cGVzLmlzU3ViamVjdChsaXN0VmFsdWUpIHx8XG4gICAgICAgICAgICAgIGdyYXBoVHlwZXMuaXNTdWJqZWN0UmVmZXJlbmNlKGxpc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2hUaGlzID0gbm9kZUxpc3RWYWx1ZXMuc29tZShsdiA9PiBfbm9kZU1hdGNoKFxuICAgICAgICAgICAgICAgIHN0YXRlLCBsaXN0VmFsdWUsIGx2LCBmbGFncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNWYWx1ZSh0aGlzRnJhbWUpKSB7XG4gICAgICAgICAgbWF0Y2hUaGlzID0gbm9kZVZhbHVlcy5zb21lKG52ID0+IF92YWx1ZU1hdGNoKHRoaXNGcmFtZSwgbnYpKTtcbiAgICAgICAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNTdWJqZWN0UmVmZXJlbmNlKHRoaXNGcmFtZSkpIHtcbiAgICAgICAgICBtYXRjaFRoaXMgPVxuICAgICAgICAgICAgbm9kZVZhbHVlcy5zb21lKG52ID0+IF9ub2RlTWF0Y2goc3RhdGUsIHRoaXNGcmFtZSwgbnYsIGZsYWdzKSk7XG4gICAgICAgIH0gZWxzZSBpZih0eXBlcy5pc09iamVjdCh0aGlzRnJhbWUpKSB7XG4gICAgICAgICAgbWF0Y2hUaGlzID0gbm9kZVZhbHVlcy5sZW5ndGggPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoVGhpcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxsIG5vbi1kZWZhdWx0ZWQgdmFsdWVzIG11c3QgbWF0Y2ggaWYgcmVxdWlyZUFsbCBpcyBzZXRcbiAgICBpZighbWF0Y2hUaGlzICYmIGZsYWdzLnJlcXVpcmVBbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBtYXRjaGVzU29tZSA9IG1hdGNoZXNTb21lIHx8IG1hdGNoVGhpcztcbiAgfVxuXG4gIC8vIHJldHVybiB0cnVlIGlmIHdpbGRjYXJkIG9yIHN1YmplY3QgbWF0Y2hlcyBzb21lIHByb3BlcnRpZXNcbiAgcmV0dXJuIHdpbGRjYXJkIHx8IG1hdGNoZXNTb21lO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXhpc3RpbmcgZW1iZWQuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBjdXJyZW50IGZyYW1pbmcgc3RhdGUuXG4gKiBAcGFyYW0gaWQgdGhlIEBpZCBvZiB0aGUgZW1iZWQgdG8gcmVtb3ZlLlxuICovXG5mdW5jdGlvbiBfcmVtb3ZlRW1iZWQoc3RhdGUsIGlkKSB7XG4gIC8vIGdldCBleGlzdGluZyBlbWJlZFxuICBjb25zdCBlbWJlZHMgPSBzdGF0ZS51bmlxdWVFbWJlZHNbc3RhdGUuZ3JhcGhdO1xuICBjb25zdCBlbWJlZCA9IGVtYmVkc1tpZF07XG4gIGNvbnN0IHBhcmVudCA9IGVtYmVkLnBhcmVudDtcbiAgY29uc3QgcHJvcGVydHkgPSBlbWJlZC5wcm9wZXJ0eTtcblxuICAvLyBjcmVhdGUgcmVmZXJlbmNlIHRvIHJlcGxhY2UgZW1iZWRcbiAgY29uc3Qgc3ViamVjdCA9IHsnQGlkJzogaWR9O1xuXG4gIC8vIHJlbW92ZSBleGlzdGluZyBlbWJlZFxuICBpZih0eXBlcy5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAvLyByZXBsYWNlIHN1YmplY3Qgd2l0aCByZWZlcmVuY2VcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFyZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZih1dGlsLmNvbXBhcmVWYWx1ZXMocGFyZW50W2ldLCBzdWJqZWN0KSkge1xuICAgICAgICBwYXJlbnRbaV0gPSBzdWJqZWN0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVwbGFjZSBzdWJqZWN0IHdpdGggcmVmZXJlbmNlXG4gICAgY29uc3QgdXNlQXJyYXkgPSB0eXBlcy5pc0FycmF5KHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgIHV0aWwucmVtb3ZlVmFsdWUocGFyZW50LCBwcm9wZXJ0eSwgc3ViamVjdCwge3Byb3BlcnR5SXNBcnJheTogdXNlQXJyYXl9KTtcbiAgICB1dGlsLmFkZFZhbHVlKHBhcmVudCwgcHJvcGVydHksIHN1YmplY3QsIHtwcm9wZXJ0eUlzQXJyYXk6IHVzZUFycmF5fSk7XG4gIH1cblxuICAvLyByZWN1cnNpdmVseSByZW1vdmUgZGVwZW5kZW50IGRhbmdsaW5nIGVtYmVkc1xuICBjb25zdCByZW1vdmVEZXBlbmRlbnRzID0gaWQgPT4ge1xuICAgIC8vIGdldCBlbWJlZCBrZXlzIGFzIGEgc2VwYXJhdGUgYXJyYXkgdG8gZW5hYmxlIGRlbGV0aW5nIGtleXMgaW4gbWFwXG4gICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMoZW1iZWRzKTtcbiAgICBmb3IoY29uc3QgbmV4dCBvZiBpZHMpIHtcbiAgICAgIGlmKG5leHQgaW4gZW1iZWRzICYmIHR5cGVzLmlzT2JqZWN0KGVtYmVkc1tuZXh0XS5wYXJlbnQpICYmXG4gICAgICAgIGVtYmVkc1tuZXh0XS5wYXJlbnRbJ0BpZCddID09PSBpZCkge1xuICAgICAgICBkZWxldGUgZW1iZWRzW25leHRdO1xuICAgICAgICByZW1vdmVEZXBlbmRlbnRzKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmVtb3ZlRGVwZW5kZW50cyhpZCk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgQHByZXNlcnZlIGtleXdvcmRzIGZyb20gZXhwYW5kZWQgcmVzdWx0IG9mIGZyYW1pbmcuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBmcmFtZWQsIGZyYW1lZCBvdXRwdXQuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgZnJhbWluZyBvcHRpb25zIHVzZWQuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gX2NsZWFudXBQcmVzZXJ2ZShpbnB1dCwgb3B0aW9ucykge1xuICAvLyByZWN1cnNlIHRocm91Z2ggYXJyYXlzXG4gIGlmKHR5cGVzLmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0Lm1hcCh2YWx1ZSA9PiBfY2xlYW51cFByZXNlcnZlKHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cblxuICBpZih0eXBlcy5pc09iamVjdChpbnB1dCkpIHtcbiAgICAvLyByZW1vdmUgQHByZXNlcnZlXG4gICAgaWYoJ0BwcmVzZXJ2ZScgaW4gaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dFsnQHByZXNlcnZlJ11bMF07XG4gICAgfVxuXG4gICAgLy8gc2tpcCBAdmFsdWVzXG4gICAgaWYoZ3JhcGhUeXBlcy5pc1ZhbHVlKGlucHV0KSkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIC8vIHJlY3Vyc2UgdGhyb3VnaCBAbGlzdHNcbiAgICBpZihncmFwaFR5cGVzLmlzTGlzdChpbnB1dCkpIHtcbiAgICAgIGlucHV0WydAbGlzdCddID0gX2NsZWFudXBQcmVzZXJ2ZShpbnB1dFsnQGxpc3QnXSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGluLW1lbW9yeSBsaW5rZWQgbm9kZXNcbiAgICBpZignQGlkJyBpbiBpbnB1dCkge1xuICAgICAgY29uc3QgaWQgPSBpbnB1dFsnQGlkJ107XG4gICAgICBpZihvcHRpb25zLmxpbmsuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IG9wdGlvbnMubGlua1tpZF0uaW5kZXhPZihpbnB1dCk7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBhbHJlYWR5IHZpc2l0ZWRcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5saW5rW2lkXVtpZHhdO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgY2lyY3VsYXIgdmlzaXRhdGlvblxuICAgICAgICBvcHRpb25zLmxpbmtbaWRdLnB1c2goaW5wdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHJldmVudCBjaXJjdWxhciB2aXNpdGF0aW9uXG4gICAgICAgIG9wdGlvbnMubGlua1tpZF0gPSBbaW5wdXRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlY3Vyc2UgdGhyb3VnaCBwcm9wZXJ0aWVzXG4gICAgZm9yKGNvbnN0IHByb3AgaW4gaW5wdXQpIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IHJlbW92ZSB0aGUgaWQsIGlmIGl0IGlzIGFuIHVucmVmZXJlbmNlIGJub2RlXG4gICAgICBpZihwcm9wID09PSAnQGlkJyAmJiBvcHRpb25zLmJub2Rlc1RvQ2xlYXIuaW5jbHVkZXMoaW5wdXRbcHJvcF0pKSB7XG4gICAgICAgIGRlbGV0ZSBpbnB1dFsnQGlkJ107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpbnB1dFtwcm9wXSA9IF9jbGVhbnVwUHJlc2VydmUoaW5wdXRbcHJvcF0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogQWRkcyBmcmFtaW5nIG91dHB1dCB0byB0aGUgZ2l2ZW4gcGFyZW50LlxuICpcbiAqIEBwYXJhbSBwYXJlbnQgdGhlIHBhcmVudCB0byBhZGQgdG8uXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHBhcmVudCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIG91dHB1dCB0byBhZGQuXG4gKi9cbmZ1bmN0aW9uIF9hZGRGcmFtZU91dHB1dChwYXJlbnQsIHByb3BlcnR5LCBvdXRwdXQpIHtcbiAgaWYodHlwZXMuaXNPYmplY3QocGFyZW50KSkge1xuICAgIHV0aWwuYWRkVmFsdWUocGFyZW50LCBwcm9wZXJ0eSwgb3V0cHV0LCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LnB1c2gob3V0cHV0KTtcbiAgfVxufVxuXG4vKipcbiAqIE5vZGUgbWF0Y2hlcyBpZiBpdCBpcyBhIG5vZGUsIGFuZCBtYXRjaGVzIHRoZSBwYXR0ZXJuIGFzIGEgZnJhbWUuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBjdXJyZW50IGZyYW1pbmcgc3RhdGUuXG4gKiBAcGFyYW0gcGF0dGVybiB1c2VkIHRvIG1hdGNoIHZhbHVlXG4gKiBAcGFyYW0gdmFsdWUgdG8gY2hlY2tcbiAqIEBwYXJhbSBmbGFncyB0aGUgZnJhbWUgZmxhZ3MuXG4gKi9cbmZ1bmN0aW9uIF9ub2RlTWF0Y2goc3RhdGUsIHBhdHRlcm4sIHZhbHVlLCBmbGFncykge1xuICBpZighKCdAaWQnIGluIHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBub2RlT2JqZWN0ID0gc3RhdGUuc3ViamVjdHNbdmFsdWVbJ0BpZCddXTtcbiAgcmV0dXJuIG5vZGVPYmplY3QgJiYgX2ZpbHRlclN1YmplY3Qoc3RhdGUsIG5vZGVPYmplY3QsIHBhdHRlcm4sIGZsYWdzKTtcbn1cblxuLyoqXG4gKiBWYWx1ZSBtYXRjaGVzIGlmIGl0IGlzIGEgdmFsdWUgYW5kIG1hdGNoZXMgdGhlIHZhbHVlIHBhdHRlcm5cbiAqXG4gKiAqIGBwYXR0ZXJuYCBpcyBlbXB0eVxuICogKiBAdmFsdWVzIGFyZSB0aGUgc2FtZSwgb3IgYHBhdHRlcm5bQHZhbHVlXWAgaXMgYSB3aWxkY2FyZCwgYW5kXG4gKiAqIEB0eXBlcyBhcmUgdGhlIHNhbWUgb3IgYHZhbHVlW0B0eXBlXWAgaXMgbm90IG51bGxcbiAqICAgYW5kIGBwYXR0ZXJuW0B0eXBlXWAgaXMgYHt9YCwgb3IgYHZhbHVlW0B0eXBlXWAgaXMgbnVsbFxuICogICBhbmQgYHBhdHRlcm5bQHR5cGVdYCBpcyBudWxsIG9yIGBbXWAsIGFuZFxuICogKiBAbGFuZ3VhZ2VzIGFyZSB0aGUgc2FtZSBvciBgdmFsdWVbQGxhbmd1YWdlXWAgaXMgbm90IG51bGxcbiAqICAgYW5kIGBwYXR0ZXJuW0BsYW5ndWFnZV1gIGlzIGB7fWAsIG9yIGB2YWx1ZVtAbGFuZ3VhZ2VdYCBpcyBudWxsXG4gKiAgIGFuZCBgcGF0dGVybltAbGFuZ3VhZ2VdYCBpcyBudWxsIG9yIGBbXWAuXG4gKlxuICogQHBhcmFtIHBhdHRlcm4gdXNlZCB0byBtYXRjaCB2YWx1ZVxuICogQHBhcmFtIHZhbHVlIHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIF92YWx1ZU1hdGNoKHBhdHRlcm4sIHZhbHVlKSB7XG4gIGNvbnN0IHYxID0gdmFsdWVbJ0B2YWx1ZSddO1xuICBjb25zdCB0MSA9IHZhbHVlWydAdHlwZSddO1xuICBjb25zdCBsMSA9IHZhbHVlWydAbGFuZ3VhZ2UnXTtcbiAgY29uc3QgdjIgPSBwYXR0ZXJuWydAdmFsdWUnXSA/XG4gICAgKHR5cGVzLmlzQXJyYXkocGF0dGVyblsnQHZhbHVlJ10pID9cbiAgICAgIHBhdHRlcm5bJ0B2YWx1ZSddIDogW3BhdHRlcm5bJ0B2YWx1ZSddXSkgOlxuICAgIFtdO1xuICBjb25zdCB0MiA9IHBhdHRlcm5bJ0B0eXBlJ10gP1xuICAgICh0eXBlcy5pc0FycmF5KHBhdHRlcm5bJ0B0eXBlJ10pID9cbiAgICAgIHBhdHRlcm5bJ0B0eXBlJ10gOiBbcGF0dGVyblsnQHR5cGUnXV0pIDpcbiAgICBbXTtcbiAgY29uc3QgbDIgPSBwYXR0ZXJuWydAbGFuZ3VhZ2UnXSA/XG4gICAgKHR5cGVzLmlzQXJyYXkocGF0dGVyblsnQGxhbmd1YWdlJ10pID9cbiAgICAgIHBhdHRlcm5bJ0BsYW5ndWFnZSddIDogW3BhdHRlcm5bJ0BsYW5ndWFnZSddXSkgOlxuICAgIFtdO1xuXG4gIGlmKHYyLmxlbmd0aCA9PT0gMCAmJiB0Mi5sZW5ndGggPT09IDAgJiYgbDIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYoISh2Mi5pbmNsdWRlcyh2MSkgfHwgdHlwZXMuaXNFbXB0eU9iamVjdCh2MlswXSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmKCEoIXQxICYmIHQyLmxlbmd0aCA9PT0gMCB8fCB0Mi5pbmNsdWRlcyh0MSkgfHwgdDEgJiZcbiAgICB0eXBlcy5pc0VtcHR5T2JqZWN0KHQyWzBdKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYoISghbDEgJiYgbDIubGVuZ3RoID09PSAwIHx8IGwyLmluY2x1ZGVzKGwxKSB8fCBsMSAmJlxuICAgIHR5cGVzLmlzRW1wdHlPYmplY3QobDJbMF0pKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcbmNvbnN0IGdyYXBoVHlwZXMgPSByZXF1aXJlKCcuL2dyYXBoVHlwZXMnKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBjb25zdGFudHNcbmNvbnN0IHtcbiAgLy8gUkRGLFxuICBSREZfTElTVCxcbiAgUkRGX0ZJUlNULFxuICBSREZfUkVTVCxcbiAgUkRGX05JTCxcbiAgUkRGX1RZUEUsXG4gIC8vIFJERl9QTEFJTl9MSVRFUkFMLFxuICAvLyBSREZfWE1MX0xJVEVSQUwsXG4gIFJERl9KU09OX0xJVEVSQUwsXG4gIC8vIFJERl9PQkpFQ1QsXG4gIC8vIFJERl9MQU5HU1RSSU5HLFxuXG4gIC8vIFhTRCxcbiAgWFNEX0JPT0xFQU4sXG4gIFhTRF9ET1VCTEUsXG4gIFhTRF9JTlRFR0VSLFxuICBYU0RfU1RSSU5HLFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IFJFR0VYX0JDUDQ3ID0gL15bYS16QS1aXXsxLDh9KC1bYS16QS1aMC05XXsxLDh9KSokLztcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSREYgZGF0YXNldCB0byBKU09OLUxELlxuICpcbiAqIEBwYXJhbSBkYXRhc2V0IHRoZSBSREYgZGF0YXNldC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBSREYgc2VyaWFsaXphdGlvbiBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIEpTT04tTEQgb3V0cHV0LlxuICovXG5hcGkuZnJvbVJERiA9IGFzeW5jIChcbiAgZGF0YXNldCxcbiAge1xuICAgIHVzZVJkZlR5cGUgPSBmYWxzZSxcbiAgICB1c2VOYXRpdmVUeXBlcyA9IGZhbHNlLFxuICAgIHJkZkRpcmVjdGlvbiA9IG51bGxcbiAgfVxuKSA9PiB7XG4gIGNvbnN0IGRlZmF1bHRHcmFwaCA9IHt9O1xuICBjb25zdCBncmFwaE1hcCA9IHsnQGRlZmF1bHQnOiBkZWZhdWx0R3JhcGh9O1xuICBjb25zdCByZWZlcmVuY2VkT25jZSA9IHt9O1xuXG4gIGZvcihjb25zdCBxdWFkIG9mIGRhdGFzZXQpIHtcbiAgICAvLyBUT0RPOiBjaGFuZ2UgJ25hbWUnIHRvICdncmFwaCdcbiAgICBjb25zdCBuYW1lID0gKHF1YWQuZ3JhcGgudGVybVR5cGUgPT09ICdEZWZhdWx0R3JhcGgnKSA/XG4gICAgICAnQGRlZmF1bHQnIDogcXVhZC5ncmFwaC52YWx1ZTtcbiAgICBpZighKG5hbWUgaW4gZ3JhcGhNYXApKSB7XG4gICAgICBncmFwaE1hcFtuYW1lXSA9IHt9O1xuICAgIH1cbiAgICBpZihuYW1lICE9PSAnQGRlZmF1bHQnICYmICEobmFtZSBpbiBkZWZhdWx0R3JhcGgpKSB7XG4gICAgICBkZWZhdWx0R3JhcGhbbmFtZV0gPSB7J0BpZCc6IG5hbWV9O1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVNYXAgPSBncmFwaE1hcFtuYW1lXTtcblxuICAgIC8vIGdldCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdFxuICAgIGNvbnN0IHMgPSBxdWFkLnN1YmplY3QudmFsdWU7XG4gICAgY29uc3QgcCA9IHF1YWQucHJlZGljYXRlLnZhbHVlO1xuICAgIGNvbnN0IG8gPSBxdWFkLm9iamVjdDtcblxuICAgIGlmKCEocyBpbiBub2RlTWFwKSkge1xuICAgICAgbm9kZU1hcFtzXSA9IHsnQGlkJzogc307XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW3NdO1xuXG4gICAgY29uc3Qgb2JqZWN0SXNOb2RlID0gby50ZXJtVHlwZS5lbmRzV2l0aCgnTm9kZScpO1xuICAgIGlmKG9iamVjdElzTm9kZSAmJiAhKG8udmFsdWUgaW4gbm9kZU1hcCkpIHtcbiAgICAgIG5vZGVNYXBbby52YWx1ZV0gPSB7J0BpZCc6IG8udmFsdWV9O1xuICAgIH1cblxuICAgIGlmKHAgPT09IFJERl9UWVBFICYmICF1c2VSZGZUeXBlICYmIG9iamVjdElzTm9kZSkge1xuICAgICAgdXRpbC5hZGRWYWx1ZShub2RlLCAnQHR5cGUnLCBvLnZhbHVlLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IF9SREZUb09iamVjdChvLCB1c2VOYXRpdmVUeXBlcywgcmRmRGlyZWN0aW9uKTtcbiAgICB1dGlsLmFkZFZhbHVlKG5vZGUsIHAsIHZhbHVlLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG5cbiAgICAvLyBvYmplY3QgbWF5IGJlIGFuIFJERiBsaXN0L3BhcnRpYWwgbGlzdCBub2RlIGJ1dCB3ZSBjYW4ndCBrbm93IGVhc2lseVxuICAgIC8vIHVudGlsIGFsbCB0cmlwbGVzIGFyZSByZWFkXG4gICAgaWYob2JqZWN0SXNOb2RlKSB7XG4gICAgICBpZihvLnZhbHVlID09PSBSREZfTklMKSB7XG4gICAgICAgIC8vIHRyYWNrIHJkZjpuaWwgdW5pcXVlbHkgcGVyIGdyYXBoXG4gICAgICAgIGNvbnN0IG9iamVjdCA9IG5vZGVNYXBbby52YWx1ZV07XG4gICAgICAgIGlmKCEoJ3VzYWdlcycgaW4gb2JqZWN0KSkge1xuICAgICAgICAgIG9iamVjdC51c2FnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QudXNhZ2VzLnB1c2goe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgcHJvcGVydHk6IHAsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYoby52YWx1ZSBpbiByZWZlcmVuY2VkT25jZSkge1xuICAgICAgICAvLyBvYmplY3QgcmVmZXJlbmNlZCBtb3JlIHRoYW4gb25jZVxuICAgICAgICByZWZlcmVuY2VkT25jZVtvLnZhbHVlXSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBzaW5nbGUgcmVmZXJlbmNlXG4gICAgICAgIHJlZmVyZW5jZWRPbmNlW28udmFsdWVdID0ge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgcHJvcGVydHk6IHAsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICBmb3IobGV0IG5hbWUgaW4gZGF0YXNldCkge1xuICAgIGNvbnN0IGdyYXBoID0gZGF0YXNldFtuYW1lXTtcbiAgICBpZighKG5hbWUgaW4gZ3JhcGhNYXApKSB7XG4gICAgICBncmFwaE1hcFtuYW1lXSA9IHt9O1xuICAgIH1cbiAgICBpZihuYW1lICE9PSAnQGRlZmF1bHQnICYmICEobmFtZSBpbiBkZWZhdWx0R3JhcGgpKSB7XG4gICAgICBkZWZhdWx0R3JhcGhbbmFtZV0gPSB7J0BpZCc6IG5hbWV9O1xuICAgIH1cbiAgICBjb25zdCBub2RlTWFwID0gZ3JhcGhNYXBbbmFtZV07XG4gICAgZm9yKGxldCB0aSA9IDA7IHRpIDwgZ3JhcGgubGVuZ3RoOyArK3RpKSB7XG4gICAgICBjb25zdCB0cmlwbGUgPSBncmFwaFt0aV07XG5cbiAgICAgIC8vIGdldCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdFxuICAgICAgY29uc3QgcyA9IHRyaXBsZS5zdWJqZWN0LnZhbHVlO1xuICAgICAgY29uc3QgcCA9IHRyaXBsZS5wcmVkaWNhdGUudmFsdWU7XG4gICAgICBjb25zdCBvID0gdHJpcGxlLm9iamVjdDtcblxuICAgICAgaWYoIShzIGluIG5vZGVNYXApKSB7XG4gICAgICAgIG5vZGVNYXBbc10gPSB7J0BpZCc6IHN9O1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVNYXBbc107XG5cbiAgICAgIGNvbnN0IG9iamVjdElzSWQgPSAoby50eXBlID09PSAnSVJJJyB8fCBvLnR5cGUgPT09ICdibGFuayBub2RlJyk7XG4gICAgICBpZihvYmplY3RJc0lkICYmICEoby52YWx1ZSBpbiBub2RlTWFwKSkge1xuICAgICAgICBub2RlTWFwW28udmFsdWVdID0geydAaWQnOiBvLnZhbHVlfTtcbiAgICAgIH1cblxuICAgICAgaWYocCA9PT0gUkRGX1RZUEUgJiYgIXVzZVJkZlR5cGUgJiYgb2JqZWN0SXNJZCkge1xuICAgICAgICB1dGlsLmFkZFZhbHVlKG5vZGUsICdAdHlwZScsIG8udmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gX1JERlRvT2JqZWN0KG8sIHVzZU5hdGl2ZVR5cGVzKTtcbiAgICAgIHV0aWwuYWRkVmFsdWUobm9kZSwgcCwgdmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcblxuICAgICAgLy8gb2JqZWN0IG1heSBiZSBhbiBSREYgbGlzdC9wYXJ0aWFsIGxpc3Qgbm9kZSBidXQgd2UgY2FuJ3Qga25vdyBlYXNpbHlcbiAgICAgIC8vIHVudGlsIGFsbCB0cmlwbGVzIGFyZSByZWFkXG4gICAgICBpZihvYmplY3RJc0lkKSB7XG4gICAgICAgIGlmKG8udmFsdWUgPT09IFJERl9OSUwpIHtcbiAgICAgICAgICAvLyB0cmFjayByZGY6bmlsIHVuaXF1ZWx5IHBlciBncmFwaFxuICAgICAgICAgIGNvbnN0IG9iamVjdCA9IG5vZGVNYXBbby52YWx1ZV07XG4gICAgICAgICAgaWYoISgndXNhZ2VzJyBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICBvYmplY3QudXNhZ2VzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdC51c2FnZXMucHVzaCh7XG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgcHJvcGVydHk6IHAsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmKG8udmFsdWUgaW4gcmVmZXJlbmNlZE9uY2UpIHtcbiAgICAgICAgICAvLyBvYmplY3QgcmVmZXJlbmNlZCBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgIHJlZmVyZW5jZWRPbmNlW28udmFsdWVdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBzaW5nbGUgcmVmZXJlbmNlXG4gICAgICAgICAgcmVmZXJlbmNlZE9uY2Vbby52YWx1ZV0gPSB7XG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgcHJvcGVydHk6IHAsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9Ki9cblxuICAvLyBjb252ZXJ0IGxpbmtlZCBsaXN0cyB0byBAbGlzdCBhcnJheXNcbiAgZm9yKGNvbnN0IG5hbWUgaW4gZ3JhcGhNYXApIHtcbiAgICBjb25zdCBncmFwaE9iamVjdCA9IGdyYXBoTWFwW25hbWVdO1xuXG4gICAgLy8gbm8gQGxpc3RzIHRvIGJlIGNvbnZlcnRlZCwgY29udGludWVcbiAgICBpZighKFJERl9OSUwgaW4gZ3JhcGhPYmplY3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIGJhY2t3YXJkcyB0aHJvdWdoIGVhY2ggUkRGIGxpc3RcbiAgICBjb25zdCBuaWwgPSBncmFwaE9iamVjdFtSREZfTklMXTtcbiAgICBpZighbmlsLnVzYWdlcykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvcihsZXQgdXNhZ2Ugb2YgbmlsLnVzYWdlcykge1xuICAgICAgbGV0IG5vZGUgPSB1c2FnZS5ub2RlO1xuICAgICAgbGV0IHByb3BlcnR5ID0gdXNhZ2UucHJvcGVydHk7XG4gICAgICBsZXQgaGVhZCA9IHVzYWdlLnZhbHVlO1xuICAgICAgY29uc3QgbGlzdCA9IFtdO1xuICAgICAgY29uc3QgbGlzdE5vZGVzID0gW107XG5cbiAgICAgIC8vIGVuc3VyZSBub2RlIGlzIGEgd2VsbC1mb3JtZWQgbGlzdCBub2RlOyBpdCBtdXN0OlxuICAgICAgLy8gMS4gQmUgcmVmZXJlbmNlZCBvbmx5IG9uY2UuXG4gICAgICAvLyAyLiBIYXZlIGFuIGFycmF5IGZvciByZGY6Zmlyc3QgdGhhdCBoYXMgMSBpdGVtLlxuICAgICAgLy8gMy4gSGF2ZSBhbiBhcnJheSBmb3IgcmRmOnJlc3QgdGhhdCBoYXMgMSBpdGVtLlxuICAgICAgLy8gNC4gSGF2ZSBubyBrZXlzIG90aGVyIHRoYW46IEBpZCwgcmRmOmZpcnN0LCByZGY6cmVzdCwgYW5kLFxuICAgICAgLy8gICBvcHRpb25hbGx5LCBAdHlwZSB3aGVyZSB0aGUgdmFsdWUgaXMgcmRmOkxpc3QuXG4gICAgICBsZXQgbm9kZUtleUNvdW50ID0gT2JqZWN0LmtleXMobm9kZSkubGVuZ3RoO1xuICAgICAgd2hpbGUocHJvcGVydHkgPT09IFJERl9SRVNUICYmXG4gICAgICAgIHR5cGVzLmlzT2JqZWN0KHJlZmVyZW5jZWRPbmNlW25vZGVbJ0BpZCddXSkgJiZcbiAgICAgICAgdHlwZXMuaXNBcnJheShub2RlW1JERl9GSVJTVF0pICYmIG5vZGVbUkRGX0ZJUlNUXS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgdHlwZXMuaXNBcnJheShub2RlW1JERl9SRVNUXSkgJiYgbm9kZVtSREZfUkVTVF0ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIChub2RlS2V5Q291bnQgPT09IDMgfHxcbiAgICAgICAgICAobm9kZUtleUNvdW50ID09PSA0ICYmIHR5cGVzLmlzQXJyYXkobm9kZVsnQHR5cGUnXSkgJiZcbiAgICAgICAgICBub2RlWydAdHlwZSddLmxlbmd0aCA9PT0gMSAmJiBub2RlWydAdHlwZSddWzBdID09PSBSREZfTElTVCkpKSB7XG4gICAgICAgIGxpc3QucHVzaChub2RlW1JERl9GSVJTVF1bMF0pO1xuICAgICAgICBsaXN0Tm9kZXMucHVzaChub2RlWydAaWQnXSk7XG5cbiAgICAgICAgLy8gZ2V0IG5leHQgbm9kZSwgbW92aW5nIGJhY2t3YXJkcyB0aHJvdWdoIGxpc3RcbiAgICAgICAgdXNhZ2UgPSByZWZlcmVuY2VkT25jZVtub2RlWydAaWQnXV07XG4gICAgICAgIG5vZGUgPSB1c2FnZS5ub2RlO1xuICAgICAgICBwcm9wZXJ0eSA9IHVzYWdlLnByb3BlcnR5O1xuICAgICAgICBoZWFkID0gdXNhZ2UudmFsdWU7XG4gICAgICAgIG5vZGVLZXlDb3VudCA9IE9iamVjdC5rZXlzKG5vZGUpLmxlbmd0aDtcblxuICAgICAgICAvLyBpZiBub2RlIGlzIG5vdCBhIGJsYW5rIG5vZGUsIHRoZW4gbGlzdCBoZWFkIGZvdW5kXG4gICAgICAgIGlmKCFncmFwaFR5cGVzLmlzQmxhbmtOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJhbnNmb3JtIGxpc3QgaW50byBAbGlzdCBvYmplY3RcbiAgICAgIGRlbGV0ZSBoZWFkWydAaWQnXTtcbiAgICAgIGhlYWRbJ0BsaXN0J10gPSBsaXN0LnJldmVyc2UoKTtcbiAgICAgIGZvcihjb25zdCBsaXN0Tm9kZSBvZiBsaXN0Tm9kZXMpIHtcbiAgICAgICAgZGVsZXRlIGdyYXBoT2JqZWN0W2xpc3ROb2RlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUgbmlsLnVzYWdlcztcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdWJqZWN0cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRHcmFwaCkuc29ydCgpO1xuICBmb3IoY29uc3Qgc3ViamVjdCBvZiBzdWJqZWN0cykge1xuICAgIGNvbnN0IG5vZGUgPSBkZWZhdWx0R3JhcGhbc3ViamVjdF07XG4gICAgaWYoc3ViamVjdCBpbiBncmFwaE1hcCkge1xuICAgICAgY29uc3QgZ3JhcGggPSBub2RlWydAZ3JhcGgnXSA9IFtdO1xuICAgICAgY29uc3QgZ3JhcGhPYmplY3QgPSBncmFwaE1hcFtzdWJqZWN0XTtcbiAgICAgIGNvbnN0IGdyYXBoU3ViamVjdHMgPSBPYmplY3Qua2V5cyhncmFwaE9iamVjdCkuc29ydCgpO1xuICAgICAgZm9yKGNvbnN0IGdyYXBoU3ViamVjdCBvZiBncmFwaFN1YmplY3RzKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBncmFwaE9iamVjdFtncmFwaFN1YmplY3RdO1xuICAgICAgICAvLyBvbmx5IGFkZCBmdWxsIHN1YmplY3RzIHRvIHRvcC1sZXZlbFxuICAgICAgICBpZighZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2Uobm9kZSkpIHtcbiAgICAgICAgICBncmFwaC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgYWRkIGZ1bGwgc3ViamVjdHMgdG8gdG9wLWxldmVsXG4gICAgaWYoIWdyYXBoVHlwZXMuaXNTdWJqZWN0UmVmZXJlbmNlKG5vZGUpKSB7XG4gICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSREYgdHJpcGxlIG9iamVjdCB0byBhIEpTT04tTEQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvIHRoZSBSREYgdHJpcGxlIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIHVzZU5hdGl2ZVR5cGVzIHRydWUgdG8gb3V0cHV0IG5hdGl2ZSB0eXBlcywgZmFsc2Ugbm90IHRvLlxuICpcbiAqIEByZXR1cm4gdGhlIEpTT04tTEQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBfUkRGVG9PYmplY3QobywgdXNlTmF0aXZlVHlwZXMsIHJkZkRpcmVjdGlvbikge1xuICAvLyBjb252ZXJ0IE5hbWVkTm9kZS9CbGFua05vZGUgb2JqZWN0IHRvIEpTT04tTERcbiAgaWYoby50ZXJtVHlwZS5lbmRzV2l0aCgnTm9kZScpKSB7XG4gICAgcmV0dXJuIHsnQGlkJzogby52YWx1ZX07XG4gIH1cblxuICAvLyBjb252ZXJ0IGxpdGVyYWwgdG8gSlNPTi1MRFxuICBjb25zdCBydmFsID0geydAdmFsdWUnOiBvLnZhbHVlfTtcblxuICAvLyBhZGQgbGFuZ3VhZ2VcbiAgaWYoby5sYW5ndWFnZSkge1xuICAgIHJ2YWxbJ0BsYW5ndWFnZSddID0gby5sYW5ndWFnZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgdHlwZSA9IG8uZGF0YXR5cGUudmFsdWU7XG4gICAgaWYoIXR5cGUpIHtcbiAgICAgIHR5cGUgPSBYU0RfU1RSSU5HO1xuICAgIH1cbiAgICBpZih0eXBlID09PSBSREZfSlNPTl9MSVRFUkFMKSB7XG4gICAgICB0eXBlID0gJ0Bqc29uJztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ2YWxbJ0B2YWx1ZSddID0gSlNPTi5wYXJzZShydmFsWydAdmFsdWUnXSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdKU09OIGxpdGVyYWwgY291bGQgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgICdqc29ubGQuSW52YWxpZEpzb25MaXRlcmFsJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgSlNPTiBsaXRlcmFsJywgdmFsdWU6IHJ2YWxbJ0B2YWx1ZSddLCBjYXVzZTogZX0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2UgbmF0aXZlIHR5cGVzIGZvciBjZXJ0YWluIHhzZCB0eXBlc1xuICAgIGlmKHVzZU5hdGl2ZVR5cGVzKSB7XG4gICAgICBpZih0eXBlID09PSBYU0RfQk9PTEVBTikge1xuICAgICAgICBpZihydmFsWydAdmFsdWUnXSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgcnZhbFsnQHZhbHVlJ10gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYocnZhbFsnQHZhbHVlJ10gPT09ICdmYWxzZScpIHtcbiAgICAgICAgICBydmFsWydAdmFsdWUnXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYodHlwZXMuaXNOdW1lcmljKHJ2YWxbJ0B2YWx1ZSddKSkge1xuICAgICAgICBpZih0eXBlID09PSBYU0RfSU5URUdFUikge1xuICAgICAgICAgIGNvbnN0IGkgPSBwYXJzZUludChydmFsWydAdmFsdWUnXSwgMTApO1xuICAgICAgICAgIGlmKGkudG9GaXhlZCgwKSA9PT0gcnZhbFsnQHZhbHVlJ10pIHtcbiAgICAgICAgICAgIHJ2YWxbJ0B2YWx1ZSddID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0eXBlID09PSBYU0RfRE9VQkxFKSB7XG4gICAgICAgICAgcnZhbFsnQHZhbHVlJ10gPSBwYXJzZUZsb2F0KHJ2YWxbJ0B2YWx1ZSddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZG8gbm90IGFkZCBuYXRpdmUgdHlwZVxuICAgICAgaWYoIVtYU0RfQk9PTEVBTiwgWFNEX0lOVEVHRVIsIFhTRF9ET1VCTEUsIFhTRF9TVFJJTkddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIHJ2YWxbJ0B0eXBlJ10gPSB0eXBlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihyZGZEaXJlY3Rpb24gPT09ICdpMThuLWRhdGF0eXBlJyAmJlxuICAgICAgdHlwZS5zdGFydHNXaXRoKCdodHRwczovL3d3dy53My5vcmcvbnMvaTE4biMnKSkge1xuICAgICAgY29uc3QgWywgbGFuZ3VhZ2UsIGRpcmVjdGlvbl0gPSB0eXBlLnNwbGl0KC9bI19dLyk7XG4gICAgICBpZihsYW5ndWFnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJ2YWxbJ0BsYW5ndWFnZSddID0gbGFuZ3VhZ2U7XG4gICAgICAgIGlmKCFsYW5ndWFnZS5tYXRjaChSRUdFWF9CQ1A0NykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYEBsYW5ndWFnZSBtdXN0IGJlIHZhbGlkIEJDUDQ3OiAke2xhbmd1YWdlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBydmFsWydAZGlyZWN0aW9uJ10gPSBkaXJlY3Rpb247XG4gICAgfSBlbHNlIGlmKHR5cGUgIT09IFhTRF9TVFJJTkcpIHtcbiAgICAgIHJ2YWxbJ0B0eXBlJ10gPSB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdWJqZWN0IHdpdGggcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHN1YmplY3Qgd2l0aCBwcm9wZXJ0aWVzLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc1N1YmplY3QgPSB2ID0+IHtcbiAgLy8gTm90ZTogQSB2YWx1ZSBpcyBhIHN1YmplY3QgaWYgYWxsIG9mIHRoZXNlIGhvbGQgdHJ1ZTpcbiAgLy8gMS4gSXQgaXMgYW4gT2JqZWN0LlxuICAvLyAyLiBJdCBpcyBub3QgYSBAdmFsdWUsIEBzZXQsIG9yIEBsaXN0LlxuICAvLyAzLiBJdCBoYXMgbW9yZSB0aGFuIDEga2V5IE9SIGFueSBleGlzdGluZyBrZXkgaXMgbm90IEBpZC5cbiAgaWYodHlwZXMuaXNPYmplY3QodikgJiZcbiAgICAhKCgnQHZhbHVlJyBpbiB2KSB8fCAoJ0BzZXQnIGluIHYpIHx8ICgnQGxpc3QnIGluIHYpKSkge1xuICAgIGNvbnN0IGtleUNvdW50ID0gT2JqZWN0LmtleXModikubGVuZ3RoO1xuICAgIHJldHVybiAoa2V5Q291bnQgPiAxIHx8ICEoJ0BpZCcgaW4gdikpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN1YmplY3QgcmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgc3ViamVjdCByZWZlcmVuY2UsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzU3ViamVjdFJlZmVyZW5jZSA9IHYgPT5cbiAgLy8gTm90ZTogQSB2YWx1ZSBpcyBhIHN1YmplY3QgcmVmZXJlbmNlIGlmIGFsbCBvZiB0aGVzZSBob2xkIHRydWU6XG4gIC8vIDEuIEl0IGlzIGFuIE9iamVjdC5cbiAgLy8gMi4gSXQgaGFzIGEgc2luZ2xlIGtleTogQGlkLlxuICAodHlwZXMuaXNPYmplY3QodikgJiYgT2JqZWN0LmtleXModikubGVuZ3RoID09PSAxICYmICgnQGlkJyBpbiB2KSk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIEB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIEB2YWx1ZSwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNWYWx1ZSA9IHYgPT5cbiAgLy8gTm90ZTogQSB2YWx1ZSBpcyBhIEB2YWx1ZSBpZiBhbGwgb2YgdGhlc2UgaG9sZCB0cnVlOlxuICAvLyAxLiBJdCBpcyBhbiBPYmplY3QuXG4gIC8vIDIuIEl0IGhhcyB0aGUgQHZhbHVlIHByb3BlcnR5LlxuICB0eXBlcy5pc09iamVjdCh2KSAmJiAoJ0B2YWx1ZScgaW4gdik7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIEBsaXN0LlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgQGxpc3QsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzTGlzdCA9IHYgPT5cbiAgLy8gTm90ZTogQSB2YWx1ZSBpcyBhIEBsaXN0IGlmIGFsbCBvZiB0aGVzZSBob2xkIHRydWU6XG4gIC8vIDEuIEl0IGlzIGFuIE9iamVjdC5cbiAgLy8gMi4gSXQgaGFzIHRoZSBAbGlzdCBwcm9wZXJ0eS5cbiAgdHlwZXMuaXNPYmplY3QodikgJiYgKCdAbGlzdCcgaW4gdik7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIEBncmFwaC5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgQGdyYXBoLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc0dyYXBoID0gdiA9PiB7XG4gIC8vIE5vdGU6IEEgdmFsdWUgaXMgYSBncmFwaCBpZiBhbGwgb2YgdGhlc2UgaG9sZCB0cnVlOlxuICAvLyAxLiBJdCBpcyBhbiBvYmplY3QuXG4gIC8vIDIuIEl0IGhhcyBhbiBgQGdyYXBoYCBrZXkuXG4gIC8vIDMuIEl0IG1heSBoYXZlICdAaWQnIG9yICdAaW5kZXgnXG4gIHJldHVybiB0eXBlcy5pc09iamVjdCh2KSAmJlxuICAgICdAZ3JhcGgnIGluIHYgJiZcbiAgICBPYmplY3Qua2V5cyh2KVxuICAgICAgLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAnQGlkJyAmJiBrZXkgIT09ICdAaW5kZXgnKS5sZW5ndGggPT09IDE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzaW1wbGUgQGdyYXBoLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzaW1wbGUgQGdyYXBoLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc1NpbXBsZUdyYXBoID0gdiA9PiB7XG4gIC8vIE5vdGU6IEEgdmFsdWUgaXMgYSBzaW1wbGUgZ3JhcGggaWYgYWxsIG9mIHRoZXNlIGhvbGQgdHJ1ZTpcbiAgLy8gMS4gSXQgaXMgYW4gb2JqZWN0LlxuICAvLyAyLiBJdCBoYXMgYW4gYEBncmFwaGAga2V5LlxuICAvLyAzLiBJdCBoYXMgb25seSAxIGtleSBvciAyIGtleXMgd2hlcmUgb25lIG9mIHRoZW0gaXMgYEBpbmRleGAuXG4gIHJldHVybiBhcGkuaXNHcmFwaCh2KSAmJiAhKCdAaWQnIGluIHYpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgYmxhbmsgbm9kZS5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGJsYW5rIG5vZGUsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzQmxhbmtOb2RlID0gdiA9PiB7XG4gIC8vIE5vdGU6IEEgdmFsdWUgaXMgYSBibGFuayBub2RlIGlmIGFsbCBvZiB0aGVzZSBob2xkIHRydWU6XG4gIC8vIDEuIEl0IGlzIGFuIE9iamVjdC5cbiAgLy8gMi4gSWYgaXQgaGFzIGFuIEBpZCBrZXkgaXRzIHZhbHVlIGJlZ2lucyB3aXRoICdfOicuXG4gIC8vIDMuIEl0IGhhcyBubyBrZXlzIE9SIGlzIG5vdCBhIEB2YWx1ZSwgQHNldCwgb3IgQGxpc3QuXG4gIGlmKHR5cGVzLmlzT2JqZWN0KHYpKSB7XG4gICAgaWYoJ0BpZCcgaW4gdikge1xuICAgICAgcmV0dXJuICh2WydAaWQnXS5pbmRleE9mKCdfOicpID09PSAwKTtcbiAgICB9XG4gICAgcmV0dXJuIChPYmplY3Qua2V5cyh2KS5sZW5ndGggPT09IDAgfHxcbiAgICAgICEoKCdAdmFsdWUnIGluIHYpIHx8ICgnQHNldCcgaW4gdikgfHwgKCdAbGlzdCcgaW4gdikpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIEpTT04tTEQgQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQGxpY2Vuc2UgQlNEIDMtQ2xhdXNlIExpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE5IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBEaWdpdGFsIEJhemFhciwgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTXG4gKiBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEFcbiAqIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuY29uc3QgY2Fub25pemUgPSByZXF1aXJlKCdyZGYtY2Fub25pemUnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IENvbnRleHRSZXNvbHZlciA9IHJlcXVpcmUoJy4vQ29udGV4dFJlc29sdmVyJyk7XG5jb25zdCBJZGVudGlmaWVySXNzdWVyID0gdXRpbC5JZGVudGlmaWVySXNzdWVyO1xuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5jb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKTtcbmNvbnN0IE5RdWFkcyA9IHJlcXVpcmUoJy4vTlF1YWRzJyk7XG5jb25zdCBSZGZhID0gcmVxdWlyZSgnLi9SZGZhJyk7XG5cbmNvbnN0IHtleHBhbmQ6IF9leHBhbmR9ID0gcmVxdWlyZSgnLi9leHBhbmQnKTtcbmNvbnN0IHtmbGF0dGVuOiBfZmxhdHRlbn0gPSByZXF1aXJlKCcuL2ZsYXR0ZW4nKTtcbmNvbnN0IHtmcm9tUkRGOiBfZnJvbVJERn0gPSByZXF1aXJlKCcuL2Zyb21SZGYnKTtcbmNvbnN0IHt0b1JERjogX3RvUkRGfSA9IHJlcXVpcmUoJy4vdG9SZGYnKTtcblxuY29uc3Qge1xuICBmcmFtZU1lcmdlZE9yRGVmYXVsdDogX2ZyYW1lTWVyZ2VkT3JEZWZhdWx0LFxuICBjbGVhbnVwTnVsbDogX2NsZWFudXBOdWxsXG59ID0gcmVxdWlyZSgnLi9mcmFtZScpO1xuXG5jb25zdCB7XG4gIGlzQXJyYXk6IF9pc0FycmF5LFxuICBpc09iamVjdDogX2lzT2JqZWN0LFxuICBpc1N0cmluZzogX2lzU3RyaW5nXG59ID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5jb25zdCB7XG4gIGlzU3ViamVjdFJlZmVyZW5jZTogX2lzU3ViamVjdFJlZmVyZW5jZSxcbn0gPSByZXF1aXJlKCcuL2dyYXBoVHlwZXMnKTtcblxuY29uc3Qge1xuICBleHBhbmRJcmk6IF9leHBhbmRJcmksXG4gIGdldEluaXRpYWxDb250ZXh0OiBfZ2V0SW5pdGlhbENvbnRleHQsXG4gIHByb2Nlc3M6IF9wcm9jZXNzQ29udGV4dCxcbiAgcHJvY2Vzc2luZ01vZGU6IF9wcm9jZXNzaW5nTW9kZVxufSA9IHJlcXVpcmUoJy4vY29udGV4dCcpO1xuXG5jb25zdCB7XG4gIGNvbXBhY3Q6IF9jb21wYWN0LFxuICBjb21wYWN0SXJpOiBfY29tcGFjdElyaVxufSA9IHJlcXVpcmUoJy4vY29tcGFjdCcpO1xuXG5jb25zdCB7XG4gIGNyZWF0ZU5vZGVNYXA6IF9jcmVhdGVOb2RlTWFwLFxuICBjcmVhdGVNZXJnZWROb2RlTWFwOiBfY3JlYXRlTWVyZ2VkTm9kZU1hcCxcbiAgbWVyZ2VOb2RlTWFwczogX21lcmdlTm9kZU1hcHNcbn0gPSByZXF1aXJlKCcuL25vZGVNYXAnKTtcblxuLy8gZGV0ZXJtaW5lIGlmIGluLWJyb3dzZXIgb3IgdXNpbmcgTm9kZS5qc1xuY29uc3QgX25vZGVqcyA9IChcbiAgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcbmNvbnN0IF9icm93c2VyID0gIV9ub2RlanMgJiZcbiAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuLy8gYXR0YWNoZXMganNvbmxkIEFQSSB0byB0aGUgZ2l2ZW4gb2JqZWN0XG5jb25zdCB3cmFwcGVyID0gZnVuY3Rpb24oanNvbmxkKSB7XG5cbi8qKiBSZWdpc3RlcmVkIFJERiBkYXRhc2V0IHBhcnNlcnMgaGFzaGVkIGJ5IGNvbnRlbnQtdHlwZS4gKi9cbmNvbnN0IF9yZGZQYXJzZXJzID0ge307XG5cbi8vIHJlc29sdmVkIGNvbnRleHQgY2FjaGVcbi8vIFRPRE86IGNvbnNpZGVyIGJhc2luZyBtYXggb24gY29udGV4dCBzaXplIHJhdGhlciB0aGFuIG51bWJlclxuY29uc3QgUkVTT0xWRURfQ09OVEVYVF9DQUNIRV9NQVhfU0laRSA9IDEwMDtcbmNvbnN0IF9yZXNvbHZlZENvbnRleHRDYWNoZSA9IG5ldyBMUlUoe21heDogUkVTT0xWRURfQ09OVEVYVF9DQUNIRV9NQVhfU0laRX0pO1xuXG4vKiBDb3JlIEFQSSAqL1xuXG4vKipcbiAqIFBlcmZvcm1zIEpTT04tTEQgY29tcGFjdGlvbi5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIEpTT04tTEQgaW5wdXQgdG8gY29tcGFjdC5cbiAqIEBwYXJhbSBjdHggdGhlIGNvbnRleHQgdG8gY29tcGFjdCB3aXRoLlxuICogQHBhcmFtIFtvcHRpb25zXSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtiYXNlXSB0aGUgYmFzZSBJUkkgdG8gdXNlLlxuICogICAgICAgICAgW2NvbXBhY3RBcnJheXNdIHRydWUgdG8gY29tcGFjdCBhcnJheXMgdG8gc2luZ2xlIHZhbHVlcyB3aGVuXG4gKiAgICAgICAgICAgIGFwcHJvcHJpYXRlLCBmYWxzZSBub3QgdG8gKGRlZmF1bHQ6IHRydWUpLlxuICogICAgICAgICAgW2NvbXBhY3RUb1JlbGF0aXZlXSB0cnVlIHRvIGNvbXBhY3QgSVJJcyB0byBiZSByZWxhdGl2ZSB0byBkb2N1bWVudFxuICogICAgICAgICAgICBiYXNlLCBmYWxzZSB0byBrZWVwIGFic29sdXRlIChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgW2dyYXBoXSB0cnVlIHRvIGFsd2F5cyBvdXRwdXQgYSB0b3AtbGV2ZWwgZ3JhcGggKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBbc2tpcEV4cGFuc2lvbl0gdHJ1ZSB0byBhc3N1bWUgdGhlIGlucHV0IGlzIGV4cGFuZGVkIGFuZCBza2lwXG4gKiAgICAgICAgICAgIGV4cGFuc2lvbiwgZmFsc2Ugbm90IHRvLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAqICAgICAgICAgIFtkb2N1bWVudExvYWRlcih1cmwsIG9wdGlvbnMpXSB0aGUgZG9jdW1lbnQgbG9hZGVyLlxuICogICAgICAgICAgW2V4cGFuc2lvbk1hcChpbmZvKV0gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGN1c3RvbSBtYXBcbiAqICAgICAgICAgICAgdW5tYXBwYWJsZSB2YWx1ZXMgKG9yIHRvIHRocm93IGFuIGVycm9yIHdoZW4gdGhleSBhcmUgZGV0ZWN0ZWQpO1xuICogICAgICAgICAgICBpZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgdGhlbiB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICogICAgICAgICAgICB3aWxsIGJlIHVzZWQuXG4gKiAgICAgICAgICBbZnJhbWluZ10gdHJ1ZSBpZiBjb21wYWN0aW9uIGlzIG9jY3VyaW5nIGR1cmluZyBhIGZyYW1pbmcgb3BlcmF0aW9uLlxuICogICAgICAgICAgW2NvbXBhY3Rpb25NYXAoaW5mbyldIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjdXN0b20gbWFwXG4gKiAgICAgICAgICAgIHVubWFwcGFibGUgdmFsdWVzIChvciB0byB0aHJvdyBhbiBlcnJvciB3aGVuIHRoZXkgYXJlIGRldGVjdGVkKTtcbiAqICAgICAgICAgICAgaWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIHRoZW4gdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAqICAgICAgICAgICAgd2lsbCBiZSB1c2VkLlxuICogICAgICAgICAgW2NvbnRleHRSZXNvbHZlcl0gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY29tcGFjdGVkIG91dHB1dC5cbiAqL1xuanNvbmxkLmNvbXBhY3QgPSBhc3luYyBmdW5jdGlvbihpbnB1dCwgY3R4LCBvcHRpb25zKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGNvbXBhY3QsIHRvbyBmZXcgYXJndW1lbnRzLicpO1xuICB9XG5cbiAgaWYoY3R4ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgJ1RoZSBjb21wYWN0aW9uIGNvbnRleHQgbXVzdCBub3QgYmUgbnVsbC4nLFxuICAgICAgJ2pzb25sZC5Db21wYWN0RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgbG9jYWwgY29udGV4dCd9KTtcbiAgfVxuXG4gIC8vIG5vdGhpbmcgdG8gY29tcGFjdFxuICBpZihpbnB1dCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBiYXNlOiBfaXNTdHJpbmcoaW5wdXQpID8gaW5wdXQgOiAnJyxcbiAgICBjb21wYWN0QXJyYXlzOiB0cnVlLFxuICAgIGNvbXBhY3RUb1JlbGF0aXZlOiB0cnVlLFxuICAgIGdyYXBoOiBmYWxzZSxcbiAgICBza2lwRXhwYW5zaW9uOiBmYWxzZSxcbiAgICBsaW5rOiBmYWxzZSxcbiAgICBpc3N1ZXI6IG5ldyBJZGVudGlmaWVySXNzdWVyKCdfOmInKSxcbiAgICBjb250ZXh0UmVzb2x2ZXI6IG5ldyBDb250ZXh0UmVzb2x2ZXIoXG4gICAgICB7c2hhcmVkQ2FjaGU6IF9yZXNvbHZlZENvbnRleHRDYWNoZX0pXG4gIH0pO1xuICBpZihvcHRpb25zLmxpbmspIHtcbiAgICAvLyBmb3JjZSBza2lwIGV4cGFuc2lvbiB3aGVuIGxpbmtpbmcsIFwibGlua1wiIGlzIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWNcbiAgICAvLyBBUEksIGl0IHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tIGZyYW1pbmdcbiAgICBvcHRpb25zLnNraXBFeHBhbnNpb24gPSB0cnVlO1xuICB9XG4gIGlmKCFvcHRpb25zLmNvbXBhY3RUb1JlbGF0aXZlKSB7XG4gICAgZGVsZXRlIG9wdGlvbnMuYmFzZTtcbiAgfVxuXG4gIC8vIGV4cGFuZCBpbnB1dFxuICBsZXQgZXhwYW5kZWQ7XG4gIGlmKG9wdGlvbnMuc2tpcEV4cGFuc2lvbikge1xuICAgIGV4cGFuZGVkID0gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgZXhwYW5kZWQgPSBhd2FpdCBqc29ubGQuZXhwYW5kKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIHByb2Nlc3MgY29udGV4dFxuICBjb25zdCBhY3RpdmVDdHggPSBhd2FpdCBqc29ubGQucHJvY2Vzc0NvbnRleHQoXG4gICAgX2dldEluaXRpYWxDb250ZXh0KG9wdGlvbnMpLCBjdHgsIG9wdGlvbnMpO1xuXG4gIC8vIGRvIGNvbXBhY3Rpb25cbiAgbGV0IGNvbXBhY3RlZCA9IGF3YWl0IF9jb21wYWN0KHtcbiAgICBhY3RpdmVDdHgsXG4gICAgZWxlbWVudDogZXhwYW5kZWQsXG4gICAgb3B0aW9ucyxcbiAgICBjb21wYWN0aW9uTWFwOiBvcHRpb25zLmNvbXBhY3Rpb25NYXBcbiAgfSk7XG5cbiAgLy8gcGVyZm9ybSBjbGVhbiB1cFxuICBpZihvcHRpb25zLmNvbXBhY3RBcnJheXMgJiYgIW9wdGlvbnMuZ3JhcGggJiYgX2lzQXJyYXkoY29tcGFjdGVkKSkge1xuICAgIGlmKGNvbXBhY3RlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHNpbXBsaWZ5IHRvIGEgc2luZ2xlIGl0ZW1cbiAgICAgIGNvbXBhY3RlZCA9IGNvbXBhY3RlZFswXTtcbiAgICB9IGVsc2UgaWYoY29tcGFjdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gc2ltcGxpZnkgdG8gYW4gZW1wdHkgb2JqZWN0XG4gICAgICBjb21wYWN0ZWQgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZihvcHRpb25zLmdyYXBoICYmIF9pc09iamVjdChjb21wYWN0ZWQpKSB7XG4gICAgLy8gYWx3YXlzIHVzZSBhcnJheSBpZiBncmFwaCBvcHRpb24gaXMgb25cbiAgICBjb21wYWN0ZWQgPSBbY29tcGFjdGVkXTtcbiAgfVxuXG4gIC8vIGZvbGxvdyBAY29udGV4dCBrZXlcbiAgaWYoX2lzT2JqZWN0KGN0eCkgJiYgJ0Bjb250ZXh0JyBpbiBjdHgpIHtcbiAgICBjdHggPSBjdHhbJ0Bjb250ZXh0J107XG4gIH1cblxuICAvLyBidWlsZCBvdXRwdXQgY29udGV4dFxuICBjdHggPSB1dGlsLmNsb25lKGN0eCk7XG4gIGlmKCFfaXNBcnJheShjdHgpKSB7XG4gICAgY3R4ID0gW2N0eF07XG4gIH1cbiAgLy8gcmVtb3ZlIGVtcHR5IGNvbnRleHRzXG4gIGNvbnN0IHRtcCA9IGN0eDtcbiAgY3R4ID0gW107XG4gIGZvcihsZXQgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICBpZighX2lzT2JqZWN0KHRtcFtpXSkgfHwgT2JqZWN0LmtleXModG1wW2ldKS5sZW5ndGggPiAwKSB7XG4gICAgICBjdHgucHVzaCh0bXBbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSBhcnJheSBpZiBvbmx5IG9uZSBjb250ZXh0XG4gIGNvbnN0IGhhc0NvbnRleHQgPSAoY3R4Lmxlbmd0aCA+IDApO1xuICBpZihjdHgubGVuZ3RoID09PSAxKSB7XG4gICAgY3R4ID0gY3R4WzBdO1xuICB9XG5cbiAgLy8gYWRkIGNvbnRleHQgYW5kL29yIEBncmFwaFxuICBpZihfaXNBcnJheShjb21wYWN0ZWQpKSB7XG4gICAgLy8gdXNlICdAZ3JhcGgnIGtleXdvcmRcbiAgICBjb25zdCBncmFwaEFsaWFzID0gX2NvbXBhY3RJcmkoe1xuICAgICAgYWN0aXZlQ3R4LCBpcmk6ICdAZ3JhcGgnLCByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgfSk7XG4gICAgY29uc3QgZ3JhcGggPSBjb21wYWN0ZWQ7XG4gICAgY29tcGFjdGVkID0ge307XG4gICAgaWYoaGFzQ29udGV4dCkge1xuICAgICAgY29tcGFjdGVkWydAY29udGV4dCddID0gY3R4O1xuICAgIH1cbiAgICBjb21wYWN0ZWRbZ3JhcGhBbGlhc10gPSBncmFwaDtcbiAgfSBlbHNlIGlmKF9pc09iamVjdChjb21wYWN0ZWQpICYmIGhhc0NvbnRleHQpIHtcbiAgICAvLyByZW9yZGVyIGtleXMgc28gQGNvbnRleHQgaXMgZmlyc3RcbiAgICBjb25zdCBncmFwaCA9IGNvbXBhY3RlZDtcbiAgICBjb21wYWN0ZWQgPSB7J0Bjb250ZXh0JzogY3R4fTtcbiAgICBmb3IoY29uc3Qga2V5IGluIGdyYXBoKSB7XG4gICAgICBjb21wYWN0ZWRba2V5XSA9IGdyYXBoW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbXBhY3RlZDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgSlNPTi1MRCBleHBhbnNpb24uXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGlucHV0IHRvIGV4cGFuZC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2tlZXBGcmVlRmxvYXRpbmdOb2Rlc10gdHJ1ZSB0byBrZWVwIGZyZWUtZmxvYXRpbmcgbm9kZXMsXG4gKiAgICAgICAgICAgIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gZmFsc2UuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtleHBhbnNpb25NYXAoaW5mbyldIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjdXN0b20gbWFwXG4gKiAgICAgICAgICAgIHVubWFwcGFibGUgdmFsdWVzIChvciB0byB0aHJvdyBhbiBlcnJvciB3aGVuIHRoZXkgYXJlIGRldGVjdGVkKTtcbiAqICAgICAgICAgICAgaWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIHRoZW4gdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAqICAgICAgICAgICAgd2lsbCBiZSB1c2VkLlxuICogICAgICAgICAgW2NvbnRleHRSZXNvbHZlcl0gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZXhwYW5kZWQgb3V0cHV0LlxuICovXG5qc29ubGQuZXhwYW5kID0gYXN5bmMgZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgZXhwYW5kLCB0b28gZmV3IGFyZ3VtZW50cy4nKTtcbiAgfVxuXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gICAga2VlcEZyZWVGbG9hdGluZ05vZGVzOiBmYWxzZSxcbiAgICBjb250ZXh0UmVzb2x2ZXI6IG5ldyBDb250ZXh0UmVzb2x2ZXIoXG4gICAgICB7c2hhcmVkQ2FjaGU6IF9yZXNvbHZlZENvbnRleHRDYWNoZX0pXG4gIH0pO1xuICBpZihvcHRpb25zLmV4cGFuc2lvbk1hcCA9PT0gZmFsc2UpIHtcbiAgICBvcHRpb25zLmV4cGFuc2lvbk1hcCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIGJ1aWxkIHNldCBvZiBvYmplY3RzIHRoYXQgbWF5IGhhdmUgQGNvbnRleHRzIHRvIHJlc29sdmVcbiAgY29uc3QgdG9SZXNvbHZlID0ge307XG5cbiAgLy8gYnVpbGQgc2V0IG9mIGNvbnRleHRzIHRvIHByb2Nlc3MgcHJpb3IgdG8gZXhwYW5zaW9uXG4gIGNvbnN0IGNvbnRleHRzVG9Qcm9jZXNzID0gW107XG5cbiAgLy8gaWYgYW4gYGV4cGFuZENvbnRleHRgIGhhcyBiZWVuIGdpdmVuIGVuc3VyZSBpdCBnZXRzIHJlc29sdmVkXG4gIGlmKCdleHBhbmRDb250ZXh0JyBpbiBvcHRpb25zKSB7XG4gICAgY29uc3QgZXhwYW5kQ29udGV4dCA9IHV0aWwuY2xvbmUob3B0aW9ucy5leHBhbmRDb250ZXh0KTtcbiAgICBpZihfaXNPYmplY3QoZXhwYW5kQ29udGV4dCkgJiYgJ0Bjb250ZXh0JyBpbiBleHBhbmRDb250ZXh0KSB7XG4gICAgICB0b1Jlc29sdmUuZXhwYW5kQ29udGV4dCA9IGV4cGFuZENvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvUmVzb2x2ZS5leHBhbmRDb250ZXh0ID0geydAY29udGV4dCc6IGV4cGFuZENvbnRleHR9O1xuICAgIH1cbiAgICBjb250ZXh0c1RvUHJvY2Vzcy5wdXNoKHRvUmVzb2x2ZS5leHBhbmRDb250ZXh0KTtcbiAgfVxuXG4gIC8vIGlmIGlucHV0IGlzIGEgc3RyaW5nLCBhdHRlbXB0IHRvIGRlcmVmZXJlbmNlIHJlbW90ZSBkb2N1bWVudFxuICBsZXQgZGVmYXVsdEJhc2U7XG4gIGlmKCFfaXNTdHJpbmcoaW5wdXQpKSB7XG4gICAgLy8gaW5wdXQgaXMgbm90IGEgVVJMLCBkbyBub3QgbmVlZCB0byByZXRyaWV2ZSBpdCBmaXJzdFxuICAgIHRvUmVzb2x2ZS5pbnB1dCA9IHV0aWwuY2xvbmUoaW5wdXQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGxvYWQgcmVtb3RlIGRvY1xuICAgIGNvbnN0IHJlbW90ZURvYyA9IGF3YWl0IGpzb25sZC5nZXQoaW5wdXQsIG9wdGlvbnMpO1xuICAgIGRlZmF1bHRCYXNlID0gcmVtb3RlRG9jLmRvY3VtZW50VXJsO1xuICAgIHRvUmVzb2x2ZS5pbnB1dCA9IHJlbW90ZURvYy5kb2N1bWVudDtcbiAgICBpZihyZW1vdGVEb2MuY29udGV4dFVybCkge1xuICAgICAgLy8gY29udGV4dCBpbmNsdWRlZCBpbiBIVFRQIGxpbmsgaGVhZGVyIGFuZCBtdXN0IGJlIHJlc29sdmVkXG4gICAgICB0b1Jlc29sdmUucmVtb3RlQ29udGV4dCA9IHsnQGNvbnRleHQnOiByZW1vdGVEb2MuY29udGV4dFVybH07XG4gICAgICBjb250ZXh0c1RvUHJvY2Vzcy5wdXNoKHRvUmVzb2x2ZS5yZW1vdGVDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBiYXNlXG4gIGlmKCEoJ2Jhc2UnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5iYXNlID0gZGVmYXVsdEJhc2UgfHwgJyc7XG4gIH1cblxuICAvLyBwcm9jZXNzIGFueSBhZGRpdGlvbmFsIGNvbnRleHRzXG4gIGxldCBhY3RpdmVDdHggPSBfZ2V0SW5pdGlhbENvbnRleHQob3B0aW9ucyk7XG4gIGZvcihjb25zdCBsb2NhbEN0eCBvZiBjb250ZXh0c1RvUHJvY2Vzcykge1xuICAgIGFjdGl2ZUN0eCA9IGF3YWl0IF9wcm9jZXNzQ29udGV4dCh7YWN0aXZlQ3R4LCBsb2NhbEN0eCwgb3B0aW9uc30pO1xuICB9XG5cbiAgLy8gZXhwYW5kIHJlc29sdmVkIGlucHV0XG4gIGxldCBleHBhbmRlZCA9IGF3YWl0IF9leHBhbmQoe1xuICAgIGFjdGl2ZUN0eCxcbiAgICBlbGVtZW50OiB0b1Jlc29sdmUuaW5wdXQsXG4gICAgb3B0aW9ucyxcbiAgICBleHBhbnNpb25NYXA6IG9wdGlvbnMuZXhwYW5zaW9uTWFwXG4gIH0pO1xuXG4gIC8vIG9wdGltaXplIGF3YXkgQGdyYXBoIHdpdGggbm8gb3RoZXIgcHJvcGVydGllc1xuICBpZihfaXNPYmplY3QoZXhwYW5kZWQpICYmICgnQGdyYXBoJyBpbiBleHBhbmRlZCkgJiZcbiAgICBPYmplY3Qua2V5cyhleHBhbmRlZCkubGVuZ3RoID09PSAxKSB7XG4gICAgZXhwYW5kZWQgPSBleHBhbmRlZFsnQGdyYXBoJ107XG4gIH0gZWxzZSBpZihleHBhbmRlZCA9PT0gbnVsbCkge1xuICAgIGV4cGFuZGVkID0gW107XG4gIH1cblxuICAvLyBub3JtYWxpemUgdG8gYW4gYXJyYXlcbiAgaWYoIV9pc0FycmF5KGV4cGFuZGVkKSkge1xuICAgIGV4cGFuZGVkID0gW2V4cGFuZGVkXTtcbiAgfVxuXG4gIHJldHVybiBleHBhbmRlZDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgSlNPTi1MRCBmbGF0dGVuaW5nLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgSlNPTi1MRCB0byBmbGF0dGVuLlxuICogQHBhcmFtIGN0eCB0aGUgY29udGV4dCB0byB1c2UgdG8gY29tcGFjdCB0aGUgZmxhdHRlbmVkIG91dHB1dCwgb3IgbnVsbC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2RvY3VtZW50TG9hZGVyKHVybCwgb3B0aW9ucyldIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmbGF0dGVuZWQgb3V0cHV0LlxuICovXG5qc29ubGQuZmxhdHRlbiA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBjdHgsIG9wdGlvbnMpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGZsYXR0ZW4sIHRvbyBmZXcgYXJndW1lbnRzLicpO1xuICB9XG5cbiAgaWYodHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGN0eCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgY3R4ID0gY3R4IHx8IG51bGw7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG5cbiAgLy8gZXhwYW5kIGlucHV0XG4gIGNvbnN0IGV4cGFuZGVkID0gYXdhaXQganNvbmxkLmV4cGFuZChpbnB1dCwgb3B0aW9ucyk7XG5cbiAgLy8gZG8gZmxhdHRlbmluZ1xuICBjb25zdCBmbGF0dGVuZWQgPSBfZmxhdHRlbihleHBhbmRlZCk7XG5cbiAgaWYoY3R4ID09PSBudWxsKSB7XG4gICAgLy8gbm8gY29tcGFjdGlvbiByZXF1aXJlZFxuICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gIH1cblxuICAvLyBjb21wYWN0IHJlc3VsdCAoZm9yY2UgQGdyYXBoIG9wdGlvbiB0byB0cnVlLCBza2lwIGV4cGFuc2lvbilcbiAgb3B0aW9ucy5ncmFwaCA9IHRydWU7XG4gIG9wdGlvbnMuc2tpcEV4cGFuc2lvbiA9IHRydWU7XG4gIGNvbnN0IGNvbXBhY3RlZCA9IGF3YWl0IGpzb25sZC5jb21wYWN0KGZsYXR0ZW5lZCwgY3R4LCBvcHRpb25zKTtcblxuICByZXR1cm4gY29tcGFjdGVkO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBKU09OLUxEIGZyYW1pbmcuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGlucHV0IHRvIGZyYW1lLlxuICogQHBhcmFtIGZyYW1lIHRoZSBKU09OLUxEIGZyYW1lIHRvIHVzZS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIGZyYW1pbmcgb3B0aW9ucy5cbiAqICAgICAgICAgIFtiYXNlXSB0aGUgYmFzZSBJUkkgdG8gdXNlLlxuICogICAgICAgICAgW2V4cGFuZENvbnRleHRdIGEgY29udGV4dCB0byBleHBhbmQgd2l0aC5cbiAqICAgICAgICAgIFtlbWJlZF0gZGVmYXVsdCBAZW1iZWQgZmxhZzogJ0BsYXN0JywgJ0BhbHdheXMnLCAnQG5ldmVyJywgJ0BsaW5rJ1xuICogICAgICAgICAgICAoZGVmYXVsdDogJ0BsYXN0JykuXG4gKiAgICAgICAgICBbZXhwbGljaXRdIGRlZmF1bHQgQGV4cGxpY2l0IGZsYWcgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICAgIFtyZXF1aXJlQWxsXSBkZWZhdWx0IEByZXF1aXJlQWxsIGZsYWcgKGRlZmF1bHQ6IHRydWUpLlxuICogICAgICAgICAgW29taXREZWZhdWx0XSBkZWZhdWx0IEBvbWl0RGVmYXVsdCBmbGFnIChkZWZhdWx0OiBmYWxzZSkuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZyYW1lZCBvdXRwdXQuXG4gKi9cbmpzb25sZC5mcmFtZSA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBmcmFtZSwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBmcmFtZSwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIGVtYmVkOiAnQG9uY2UnLFxuICAgIGV4cGxpY2l0OiBmYWxzZSxcbiAgICByZXF1aXJlQWxsOiBmYWxzZSxcbiAgICBvbWl0RGVmYXVsdDogZmFsc2UsXG4gICAgYm5vZGVzVG9DbGVhcjogW10sXG4gICAgY29udGV4dFJlc29sdmVyOiBuZXcgQ29udGV4dFJlc29sdmVyKFxuICAgICAge3NoYXJlZENhY2hlOiBfcmVzb2x2ZWRDb250ZXh0Q2FjaGV9KVxuICB9KTtcblxuICAvLyBpZiBmcmFtZSBpcyBhIHN0cmluZywgYXR0ZW1wdCB0byBkZXJlZmVyZW5jZSByZW1vdGUgZG9jdW1lbnRcbiAgaWYoX2lzU3RyaW5nKGZyYW1lKSkge1xuICAgIC8vIGxvYWQgcmVtb3RlIGRvY1xuICAgIGNvbnN0IHJlbW90ZURvYyA9IGF3YWl0IGpzb25sZC5nZXQoZnJhbWUsIG9wdGlvbnMpO1xuICAgIGZyYW1lID0gcmVtb3RlRG9jLmRvY3VtZW50O1xuXG4gICAgaWYocmVtb3RlRG9jLmNvbnRleHRVcmwpIHtcbiAgICAgIC8vIGluamVjdCBsaW5rIGhlYWRlciBAY29udGV4dCBpbnRvIGZyYW1lXG4gICAgICBsZXQgY3R4ID0gZnJhbWVbJ0Bjb250ZXh0J107XG4gICAgICBpZighY3R4KSB7XG4gICAgICAgIGN0eCA9IHJlbW90ZURvYy5jb250ZXh0VXJsO1xuICAgICAgfSBlbHNlIGlmKF9pc0FycmF5KGN0eCkpIHtcbiAgICAgICAgY3R4LnB1c2gocmVtb3RlRG9jLmNvbnRleHRVcmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4ID0gW2N0eCwgcmVtb3RlRG9jLmNvbnRleHRVcmxdO1xuICAgICAgfVxuICAgICAgZnJhbWVbJ0Bjb250ZXh0J10gPSBjdHg7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZnJhbWVDb250ZXh0ID0gZnJhbWUgPyBmcmFtZVsnQGNvbnRleHQnXSB8fCB7fSA6IHt9O1xuXG4gIC8vIHByb2Nlc3MgY29udGV4dFxuICBjb25zdCBhY3RpdmVDdHggPSBhd2FpdCBqc29ubGQucHJvY2Vzc0NvbnRleHQoXG4gICAgX2dldEluaXRpYWxDb250ZXh0KG9wdGlvbnMpLCBmcmFtZUNvbnRleHQsIG9wdGlvbnMpO1xuXG4gIC8vIG1vZGUgc3BlY2lmaWMgZGVmYXVsdHNcbiAgaWYoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ29taXRHcmFwaCcpKSB7XG4gICAgb3B0aW9ucy5vbWl0R3JhcGggPSBfcHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpO1xuICB9XG4gIGlmKCFvcHRpb25zLmhhc093blByb3BlcnR5KCdwcnVuZUJsYW5rTm9kZUlkZW50aWZpZXJzJykpIHtcbiAgICBvcHRpb25zLnBydW5lQmxhbmtOb2RlSWRlbnRpZmllcnMgPSBfcHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpO1xuICB9XG5cbiAgLy8gZXhwYW5kIGlucHV0XG4gIGNvbnN0IGV4cGFuZGVkID0gYXdhaXQganNvbmxkLmV4cGFuZChpbnB1dCwgb3B0aW9ucyk7XG5cbiAgLy8gZXhwYW5kIGZyYW1lXG4gIGNvbnN0IG9wdHMgPSB7Li4ub3B0aW9uc307XG4gIG9wdHMuaXNGcmFtZSA9IHRydWU7XG4gIG9wdHMua2VlcEZyZWVGbG9hdGluZ05vZGVzID0gdHJ1ZTtcbiAgY29uc3QgZXhwYW5kZWRGcmFtZSA9IGF3YWl0IGpzb25sZC5leHBhbmQoZnJhbWUsIG9wdHMpO1xuXG4gIC8vIGlmIHRoZSB1bmV4cGFuZGVkIGZyYW1lIGluY2x1ZGVzIGEga2V5IGV4cGFuZGluZyB0byBAZ3JhcGgsIGZyYW1lIHRoZVxuICAvLyBkZWZhdWx0IGdyYXBoLCBvdGhlcndpc2UsIHRoZSBtZXJnZWQgZ3JhcGhcbiAgY29uc3QgZnJhbWVLZXlzID0gT2JqZWN0LmtleXMoZnJhbWUpXG4gICAgLm1hcChrZXkgPT4gX2V4cGFuZElyaShhY3RpdmVDdHgsIGtleSwge3ZvY2FiOiB0cnVlfSkpO1xuICBvcHRzLm1lcmdlZCA9ICFmcmFtZUtleXMuaW5jbHVkZXMoJ0BncmFwaCcpO1xuICBvcHRzLmlzMTEgPSBfcHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpO1xuXG4gIC8vIGRvIGZyYW1pbmdcbiAgY29uc3QgZnJhbWVkID0gX2ZyYW1lTWVyZ2VkT3JEZWZhdWx0KGV4cGFuZGVkLCBleHBhbmRlZEZyYW1lLCBvcHRzKTtcblxuICBvcHRzLmdyYXBoID0gIW9wdGlvbnMub21pdEdyYXBoO1xuICBvcHRzLnNraXBFeHBhbnNpb24gPSB0cnVlO1xuICBvcHRzLmxpbmsgPSB7fTtcbiAgb3B0cy5mcmFtaW5nID0gdHJ1ZTtcbiAgbGV0IGNvbXBhY3RlZCA9IGF3YWl0IGpzb25sZC5jb21wYWN0KGZyYW1lZCwgZnJhbWVDb250ZXh0LCBvcHRzKTtcblxuICAvLyByZXBsYWNlIEBudWxsIHdpdGggbnVsbCwgY29tcGFjdGluZyBhcnJheXNcbiAgb3B0cy5saW5rID0ge307XG4gIGNvbXBhY3RlZCA9IF9jbGVhbnVwTnVsbChjb21wYWN0ZWQsIG9wdHMpO1xuXG4gIHJldHVybiBjb21wYWN0ZWQ7XG59O1xuXG4vKipcbiAqICoqRXhwZXJpbWVudGFsKipcbiAqXG4gKiBMaW5rcyBhIEpTT04tTEQgZG9jdW1lbnQncyBub2RlcyBpbiBtZW1vcnkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGRvY3VtZW50IHRvIGxpbmsuXG4gKiBAcGFyYW0gW2N0eF0gdGhlIEpTT04tTEQgY29udGV4dCB0byBhcHBseS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2RvY3VtZW50TG9hZGVyKHVybCwgb3B0aW9ucyldIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsaW5rZWQgb3V0cHV0LlxuICovXG5qc29ubGQubGluayA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBjdHgsIG9wdGlvbnMpIHtcbiAgLy8gQVBJIG1hdGNoZXMgcnVubmluZyBmcmFtZSB3aXRoIGEgd2lsZGNhcmQgZnJhbWUgYW5kIGVtYmVkOiAnQGxpbmsnXG4gIC8vIGdldCBhcmd1bWVudHNcbiAgY29uc3QgZnJhbWUgPSB7fTtcbiAgaWYoY3R4KSB7XG4gICAgZnJhbWVbJ0Bjb250ZXh0J10gPSBjdHg7XG4gIH1cbiAgZnJhbWVbJ0BlbWJlZCddID0gJ0BsaW5rJztcbiAgcmV0dXJuIGpzb25sZC5mcmFtZShpbnB1dCwgZnJhbWUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBSREYgZGF0YXNldCBub3JtYWxpemF0aW9uIG9uIHRoZSBnaXZlbiBpbnB1dC4gVGhlIGlucHV0IGlzIEpTT04tTERcbiAqIHVubGVzcyB0aGUgJ2lucHV0Rm9ybWF0JyBvcHRpb24gaXMgdXNlZC4gVGhlIG91dHB1dCBpcyBhbiBSREYgZGF0YXNldFxuICogdW5sZXNzIHRoZSAnZm9ybWF0JyBvcHRpb24gaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGlucHV0IHRvIG5vcm1hbGl6ZSBhcyBKU09OLUxEIG9yIGFzIGEgZm9ybWF0IHNwZWNpZmllZCBieVxuICogICAgICAgICAgdGhlICdpbnB1dEZvcm1hdCcgb3B0aW9uLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYWxnb3JpdGhtXSB0aGUgbm9ybWFsaXphdGlvbiBhbGdvcml0aG0gdG8gdXNlLCBgVVJETkEyMDE1YCBvclxuICogICAgICAgICAgICBgVVJHTkEyMDEyYCAoZGVmYXVsdDogYFVSRE5BMjAxNWApLlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW3NraXBFeHBhbnNpb25dIHRydWUgdG8gYXNzdW1lIHRoZSBpbnB1dCBpcyBleHBhbmRlZCBhbmQgc2tpcFxuICogICAgICAgICAgICBleHBhbnNpb24sIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gZmFsc2UuXG4gKiAgICAgICAgICBbaW5wdXRGb3JtYXRdIHRoZSBmb3JtYXQgaWYgaW5wdXQgaXMgbm90IEpTT04tTEQ6XG4gKiAgICAgICAgICAgICdhcHBsaWNhdGlvbi9uLXF1YWRzJyBmb3IgTi1RdWFkcy5cbiAqICAgICAgICAgIFtmb3JtYXRdIHRoZSBmb3JtYXQgaWYgb3V0cHV0IGlzIGEgc3RyaW5nOlxuICogICAgICAgICAgICAnYXBwbGljYXRpb24vbi1xdWFkcycgZm9yIE4tUXVhZHMuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFt1c2VOYXRpdmVdIHRydWUgdG8gdXNlIGEgbmF0aXZlIGNhbm9uaXplIGFsZ29yaXRobVxuICogICAgICAgICAgW2NvbnRleHRSZXNvbHZlcl0gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbm9ybWFsaXplZCBvdXRwdXQuXG4gKi9cbmpzb25sZC5ub3JtYWxpemUgPSBqc29ubGQuY2Fub25pemUgPSBhc3luYyBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjYW5vbml6ZSwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIGFsZ29yaXRobTogJ1VSRE5BMjAxNScsXG4gICAgc2tpcEV4cGFuc2lvbjogZmFsc2UsXG4gICAgY29udGV4dFJlc29sdmVyOiBuZXcgQ29udGV4dFJlc29sdmVyKFxuICAgICAge3NoYXJlZENhY2hlOiBfcmVzb2x2ZWRDb250ZXh0Q2FjaGV9KVxuICB9KTtcbiAgaWYoJ2lucHV0Rm9ybWF0JyBpbiBvcHRpb25zKSB7XG4gICAgaWYob3B0aW9ucy5pbnB1dEZvcm1hdCAhPT0gJ2FwcGxpY2F0aW9uL24tcXVhZHMnICYmXG4gICAgICBvcHRpb25zLmlucHV0Rm9ybWF0ICE9PSAnYXBwbGljYXRpb24vbnF1YWRzJykge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVW5rbm93biBjYW5vbmljYWxpemF0aW9uIGlucHV0IGZvcm1hdC4nLFxuICAgICAgICAnanNvbmxkLkNhbm9uaXplRXJyb3InKTtcbiAgICB9XG4gICAgLy8gVE9ETzogYGF3YWl0YCBmb3IgYXN5bmMgcGFyc2Vyc1xuICAgIGNvbnN0IHBhcnNlZElucHV0ID0gTlF1YWRzLnBhcnNlKGlucHV0KTtcblxuICAgIC8vIGRvIGNhbm9uaWNhbGl6YXRpb25cbiAgICByZXR1cm4gY2Fub25pemUuY2Fub25pemUocGFyc2VkSW5wdXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gY29udmVydCB0byBSREYgZGF0YXNldCB0aGVuIGRvIG5vcm1hbGl6YXRpb25cbiAgY29uc3Qgb3B0cyA9IHsuLi5vcHRpb25zfTtcbiAgZGVsZXRlIG9wdHMuZm9ybWF0O1xuICBvcHRzLnByb2R1Y2VHZW5lcmFsaXplZFJkZiA9IGZhbHNlO1xuICBjb25zdCBkYXRhc2V0ID0gYXdhaXQganNvbmxkLnRvUkRGKGlucHV0LCBvcHRzKTtcblxuICAvLyBkbyBjYW5vbmljYWxpemF0aW9uXG4gIHJldHVybiBjYW5vbml6ZS5jYW5vbml6ZShkYXRhc2V0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUkRGIGRhdGFzZXQgdG8gSlNPTi1MRC5cbiAqXG4gKiBAcGFyYW0gZGF0YXNldCBhIHNlcmlhbGl6ZWQgc3RyaW5nIG9mIFJERiBpbiBhIGZvcm1hdCBzcGVjaWZpZWQgYnkgdGhlXG4gKiAgICAgICAgICBmb3JtYXQgb3B0aW9uIG9yIGFuIFJERiBkYXRhc2V0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtmb3JtYXRdIHRoZSBmb3JtYXQgaWYgZGF0YXNldCBwYXJhbSBtdXN0IGZpcnN0IGJlIHBhcnNlZDpcbiAqICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL24tcXVhZHMnIGZvciBOLVF1YWRzIChkZWZhdWx0KS5cbiAqICAgICAgICAgIFtyZGZQYXJzZXJdIGEgY3VzdG9tIFJERi1wYXJzZXIgdG8gdXNlIHRvIHBhcnNlIHRoZSBkYXRhc2V0LlxuICogICAgICAgICAgW3VzZVJkZlR5cGVdIHRydWUgdG8gdXNlIHJkZjp0eXBlLCBmYWxzZSB0byB1c2UgQHR5cGVcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICAgIFt1c2VOYXRpdmVUeXBlc10gdHJ1ZSB0byBjb252ZXJ0IFhTRCB0eXBlcyBpbnRvIG5hdGl2ZSB0eXBlc1xuICogICAgICAgICAgICAoYm9vbGVhbiwgaW50ZWdlciwgZG91YmxlKSwgZmFsc2Ugbm90IHRvIChkZWZhdWx0OiBmYWxzZSkuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgSlNPTi1MRCBkb2N1bWVudC5cbiAqL1xuanNvbmxkLmZyb21SREYgPSBhc3luYyBmdW5jdGlvbihkYXRhc2V0LCBvcHRpb25zKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgZnJvbSBSREYsIHRvbyBmZXcgYXJndW1lbnRzLicpO1xuICB9XG5cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBmb3JtYXQ6IF9pc1N0cmluZyhkYXRhc2V0KSA/ICdhcHBsaWNhdGlvbi9uLXF1YWRzJyA6IHVuZGVmaW5lZFxuICB9KTtcblxuICBjb25zdCB7Zm9ybWF0fSA9IG9wdGlvbnM7XG4gIGxldCB7cmRmUGFyc2VyfSA9IG9wdGlvbnM7XG5cbiAgLy8gaGFuZGxlIHNwZWNpYWwgZm9ybWF0XG4gIGlmKGZvcm1hdCkge1xuICAgIC8vIGNoZWNrIHN1cHBvcnRlZCBmb3JtYXRzXG4gICAgcmRmUGFyc2VyID0gcmRmUGFyc2VyIHx8IF9yZGZQYXJzZXJzW2Zvcm1hdF07XG4gICAgaWYoIXJkZlBhcnNlcikge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVW5rbm93biBpbnB1dCBmb3JtYXQuJyxcbiAgICAgICAgJ2pzb25sZC5Vbmtub3duRm9ybWF0Jywge2Zvcm1hdH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBuby1vcCBwYXJzZXIsIGFzc3VtZSBkYXRhc2V0IGFscmVhZHkgcGFyc2VkXG4gICAgcmRmUGFyc2VyID0gKCkgPT4gZGF0YXNldDtcbiAgfVxuXG4gIC8vIHJkZlBhcnNlciBtdXN0IGJlIHN5bmNocm9ub3VzIG9yIHJldHVybiBhIHByb21pc2UsIG5vIGNhbGxiYWNrIHN1cHBvcnRcbiAgY29uc3QgcGFyc2VkRGF0YXNldCA9IGF3YWl0IHJkZlBhcnNlcihkYXRhc2V0KTtcbiAgcmV0dXJuIF9mcm9tUkRGKHBhcnNlZERhdGFzZXQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBPdXRwdXRzIHRoZSBSREYgZGF0YXNldCBmb3VuZCBpbiB0aGUgZ2l2ZW4gSlNPTi1MRCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGlucHV0LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBbc2tpcEV4cGFuc2lvbl0gdHJ1ZSB0byBhc3N1bWUgdGhlIGlucHV0IGlzIGV4cGFuZGVkIGFuZCBza2lwXG4gKiAgICAgICAgICAgIGV4cGFuc2lvbiwgZmFsc2Ugbm90IHRvLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAqICAgICAgICAgIFtmb3JtYXRdIHRoZSBmb3JtYXQgdG8gdXNlIHRvIG91dHB1dCBhIHN0cmluZzpcbiAqICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL24tcXVhZHMnIGZvciBOLVF1YWRzLlxuICogICAgICAgICAgW3Byb2R1Y2VHZW5lcmFsaXplZFJkZl0gdHJ1ZSB0byBvdXRwdXQgZ2VuZXJhbGl6ZWQgUkRGLCBmYWxzZVxuICogICAgICAgICAgICB0byBwcm9kdWNlIG9ubHkgc3RhbmRhcmQgUkRGIChkZWZhdWx0OiBmYWxzZSkuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFJERiBkYXRhc2V0LlxuICovXG5qc29ubGQudG9SREYgPSBhc3luYyBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHRvIFJERiwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIHNraXBFeHBhbnNpb246IGZhbHNlLFxuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG5cbiAgLy8gVE9ETzogc3VwcG9ydCB0b1JERiBjdXN0b20gbWFwP1xuICBsZXQgZXhwYW5kZWQ7XG4gIGlmKG9wdGlvbnMuc2tpcEV4cGFuc2lvbikge1xuICAgIGV4cGFuZGVkID0gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gZXhwYW5kIGlucHV0XG4gICAgZXhwYW5kZWQgPSBhd2FpdCBqc29ubGQuZXhwYW5kKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIG91dHB1dCBSREYgZGF0YXNldFxuICBjb25zdCBkYXRhc2V0ID0gX3RvUkRGKGV4cGFuZGVkLCBvcHRpb25zKTtcbiAgaWYob3B0aW9ucy5mb3JtYXQpIHtcbiAgICBpZihvcHRpb25zLmZvcm1hdCA9PT0gJ2FwcGxpY2F0aW9uL24tcXVhZHMnIHx8XG4gICAgICBvcHRpb25zLmZvcm1hdCA9PT0gJ2FwcGxpY2F0aW9uL25xdWFkcycpIHtcbiAgICAgIHJldHVybiBhd2FpdCBOUXVhZHMuc2VyaWFsaXplKGRhdGFzZXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnVW5rbm93biBvdXRwdXQgZm9ybWF0LicsXG4gICAgICAnanNvbmxkLlVua25vd25Gb3JtYXQnLCB7Zm9ybWF0OiBvcHRpb25zLmZvcm1hdH0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGFzZXQ7XG59O1xuXG4vKipcbiAqICoqRXhwZXJpbWVudGFsKipcbiAqXG4gKiBSZWN1cnNpdmVseSBmbGF0dGVucyB0aGUgbm9kZXMgaW4gdGhlIGdpdmVuIEpTT04tTEQgaW5wdXQgaW50byBhIG1lcmdlZFxuICogbWFwIG9mIG5vZGUgSUQgPT4gbm9kZS4gQWxsIGdyYXBocyB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZSBkZWZhdWx0IGdyYXBoLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgSlNPTi1MRCBpbnB1dC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2lzc3Vlcl0gYSBqc29ubGQuSWRlbnRpZmllcklzc3VlciB0byB1c2UgdG8gbGFiZWwgYmxhbmsgbm9kZXMuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG1lcmdlZCBub2RlIG1hcC5cbiAqL1xuanNvbmxkLmNyZWF0ZU5vZGVNYXAgPSBhc3luYyBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgbm9kZSBtYXAsIHRvbyBmZXcgYXJndW1lbnRzLicpO1xuICB9XG5cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBiYXNlOiBfaXNTdHJpbmcoaW5wdXQpID8gaW5wdXQgOiAnJyxcbiAgICBjb250ZXh0UmVzb2x2ZXI6IG5ldyBDb250ZXh0UmVzb2x2ZXIoXG4gICAgICB7c2hhcmVkQ2FjaGU6IF9yZXNvbHZlZENvbnRleHRDYWNoZX0pXG4gIH0pO1xuXG4gIC8vIGV4cGFuZCBpbnB1dFxuICBjb25zdCBleHBhbmRlZCA9IGF3YWl0IGpzb25sZC5leHBhbmQoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIHJldHVybiBfY3JlYXRlTWVyZ2VkTm9kZU1hcChleHBhbmRlZCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqICoqRXhwZXJpbWVudGFsKipcbiAqXG4gKiBNZXJnZXMgdHdvIG9yIG1vcmUgSlNPTi1MRCBkb2N1bWVudHMgaW50byBhIHNpbmdsZSBmbGF0dGVuZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIGRvY3MgdGhlIEpTT04tTEQgZG9jdW1lbnRzIHRvIG1lcmdlIHRvZ2V0aGVyLlxuICogQHBhcmFtIGN0eCB0aGUgY29udGV4dCB0byB1c2UgdG8gY29tcGFjdCB0aGUgbWVyZ2VkIHJlc3VsdCwgb3IgbnVsbC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2lzc3Vlcl0gYSBqc29ubGQuSWRlbnRpZmllcklzc3VlciB0byB1c2UgdG8gbGFiZWwgYmxhbmsgbm9kZXMuXG4gKiAgICAgICAgICBbbWVyZ2VOb2Rlc10gdHJ1ZSB0byBtZXJnZSBwcm9wZXJ0aWVzIGZvciBub2RlcyB3aXRoIHRoZSBzYW1lIElELFxuICogICAgICAgICAgICBmYWxzZSB0byBpZ25vcmUgbmV3IHByb3BlcnRpZXMgZm9yIG5vZGVzIHdpdGggdGhlIHNhbWUgSUQgb25jZVxuICogICAgICAgICAgICB0aGUgSUQgaGFzIGJlZW4gZGVmaW5lZDsgbm90ZSB0aGF0IHRoaXMgbWF5IG5vdCBwcmV2ZW50IG1lcmdpbmdcbiAqICAgICAgICAgICAgbmV3IHByb3BlcnRpZXMgd2hlcmUgYSBub2RlIGlzIGluIHRoZSBgb2JqZWN0YCBwb3NpdGlvblxuICogICAgICAgICAgICAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG1lcmdlZCBvdXRwdXQuXG4gKi9cbmpzb25sZC5tZXJnZSA9IGFzeW5jIGZ1bmN0aW9uKGRvY3MsIGN0eCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBtZXJnZSwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cbiAgaWYoIV9pc0FycmF5KGRvY3MpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IG1lcmdlLCBcImRvY3NcIiBtdXN0IGJlIGFuIGFycmF5LicpO1xuICB9XG5cbiAgaWYodHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGN0eCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgY3R4ID0gY3R4IHx8IG51bGw7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG5cbiAgLy8gZXhwYW5kIGFsbCBkb2N1bWVudHNcbiAgY29uc3QgZXhwYW5kZWQgPSBhd2FpdCBQcm9taXNlLmFsbChkb2NzLm1hcChkb2MgPT4ge1xuICAgIGNvbnN0IG9wdHMgPSB7Li4ub3B0aW9uc307XG4gICAgcmV0dXJuIGpzb25sZC5leHBhbmQoZG9jLCBvcHRzKTtcbiAgfSkpO1xuXG4gIGxldCBtZXJnZU5vZGVzID0gdHJ1ZTtcbiAgaWYoJ21lcmdlTm9kZXMnIGluIG9wdGlvbnMpIHtcbiAgICBtZXJnZU5vZGVzID0gb3B0aW9ucy5tZXJnZU5vZGVzO1xuICB9XG5cbiAgY29uc3QgaXNzdWVyID0gb3B0aW9ucy5pc3N1ZXIgfHwgbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YicpO1xuICBjb25zdCBncmFwaHMgPSB7J0BkZWZhdWx0Jzoge319O1xuXG4gIGZvcihsZXQgaSA9IDA7IGkgPCBleHBhbmRlZC5sZW5ndGg7ICsraSkge1xuICAgIC8vIHVuaXF1ZWx5IHJlbGFiZWwgYmxhbmsgbm9kZXNcbiAgICBjb25zdCBkb2MgPSB1dGlsLnJlbGFiZWxCbGFua05vZGVzKGV4cGFuZGVkW2ldLCB7XG4gICAgICBpc3N1ZXI6IG5ldyBJZGVudGlmaWVySXNzdWVyKCdfOmInICsgaSArICctJylcbiAgICB9KTtcblxuICAgIC8vIGFkZCBub2RlcyB0byB0aGUgc2hhcmVkIG5vZGUgbWFwIGdyYXBocyBpZiBtZXJnaW5nIG5vZGVzLCB0byBhXG4gICAgLy8gc2VwYXJhdGUgZ3JhcGggc2V0IGlmIG5vdFxuICAgIGNvbnN0IF9ncmFwaHMgPSAobWVyZ2VOb2RlcyB8fCBpID09PSAwKSA/IGdyYXBocyA6IHsnQGRlZmF1bHQnOiB7fX07XG4gICAgX2NyZWF0ZU5vZGVNYXAoZG9jLCBfZ3JhcGhzLCAnQGRlZmF1bHQnLCBpc3N1ZXIpO1xuXG4gICAgaWYoX2dyYXBocyAhPT0gZ3JhcGhzKSB7XG4gICAgICAvLyBtZXJnZSBkb2N1bWVudCBncmFwaHMgYnV0IGRvbid0IG1lcmdlIGV4aXN0aW5nIG5vZGVzXG4gICAgICBmb3IoY29uc3QgZ3JhcGhOYW1lIGluIF9ncmFwaHMpIHtcbiAgICAgICAgY29uc3QgX25vZGVNYXAgPSBfZ3JhcGhzW2dyYXBoTmFtZV07XG4gICAgICAgIGlmKCEoZ3JhcGhOYW1lIGluIGdyYXBocykpIHtcbiAgICAgICAgICBncmFwaHNbZ3JhcGhOYW1lXSA9IF9ub2RlTWFwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBncmFwaHNbZ3JhcGhOYW1lXTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBfbm9kZU1hcCkge1xuICAgICAgICAgIGlmKCEoa2V5IGluIG5vZGVNYXApKSB7XG4gICAgICAgICAgICBub2RlTWFwW2tleV0gPSBfbm9kZU1hcFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBhbGwgbm9uLWRlZmF1bHQgZ3JhcGhzIHRvIGRlZmF1bHQgZ3JhcGhcbiAgY29uc3QgZGVmYXVsdEdyYXBoID0gX21lcmdlTm9kZU1hcHMoZ3JhcGhzKTtcblxuICAvLyBwcm9kdWNlIGZsYXR0ZW5lZCBvdXRwdXRcbiAgY29uc3QgZmxhdHRlbmVkID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0R3JhcGgpLnNvcnQoKTtcbiAgZm9yKGxldCBraSA9IDA7IGtpIDwga2V5cy5sZW5ndGg7ICsra2kpIHtcbiAgICBjb25zdCBub2RlID0gZGVmYXVsdEdyYXBoW2tleXNba2ldXTtcbiAgICAvLyBvbmx5IGFkZCBmdWxsIHN1YmplY3RzIHRvIHRvcC1sZXZlbFxuICAgIGlmKCFfaXNTdWJqZWN0UmVmZXJlbmNlKG5vZGUpKSB7XG4gICAgICBmbGF0dGVuZWQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICBpZihjdHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmxhdHRlbmVkO1xuICB9XG5cbiAgLy8gY29tcGFjdCByZXN1bHQgKGZvcmNlIEBncmFwaCBvcHRpb24gdG8gdHJ1ZSwgc2tpcCBleHBhbnNpb24pXG4gIG9wdGlvbnMuZ3JhcGggPSB0cnVlO1xuICBvcHRpb25zLnNraXBFeHBhbnNpb24gPSB0cnVlO1xuICBjb25zdCBjb21wYWN0ZWQgPSBhd2FpdCBqc29ubGQuY29tcGFjdChmbGF0dGVuZWQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIGNvbXBhY3RlZDtcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZG9jdW1lbnQgbG9hZGVyIGZvciBleHRlcm5hbCBkb2N1bWVudHMuXG4gKlxuICogQHBhcmFtIHVybCB0aGUgVVJMIHRvIGxvYWQuXG4gKlxuICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVtb3RlIGRvY3VtZW50LlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoanNvbmxkLCAnZG9jdW1lbnRMb2FkZXInLCB7XG4gIGdldDogKCkgPT4ganNvbmxkLl9kb2N1bWVudExvYWRlcixcbiAgc2V0OiB2ID0+IGpzb25sZC5fZG9jdW1lbnRMb2FkZXIgPSB2XG59KTtcbi8vIGRlZmF1bHQgZG9jdW1lbnQgbG9hZGVyIG5vdCBpbXBsZW1lbnRlZFxuanNvbmxkLmRvY3VtZW50TG9hZGVyID0gYXN5bmMgdXJsID0+IHtcbiAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICdDb3VsZCBub3QgcmV0cmlldmUgYSBKU09OLUxEIGRvY3VtZW50IGZyb20gdGhlIFVSTC4gVVJMICcgK1xuICAgICdkZXJlZmVyZW5jaW5nIG5vdCBpbXBsZW1lbnRlZC4nLCAnanNvbmxkLkxvYWREb2N1bWVudEVycm9yJyxcbiAgICB7Y29kZTogJ2xvYWRpbmcgZG9jdW1lbnQgZmFpbGVkJywgdXJsfSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSByZW1vdGUgSlNPTi1MRCBkb2N1bWVudCB1c2luZyB0aGUgZGVmYXVsdCBkb2N1bWVudCBsb2FkZXIgb3JcbiAqIG9uZSBnaXZlbiBpbiB0aGUgcGFzc2VkIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHVybCB0aGUgVVJMIHRvIGZldGNoLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXJdIHRoZSBkb2N1bWVudCBsb2FkZXIgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJldHJpZXZlZCByZW1vdGUgZG9jdW1lbnQuXG4gKi9cbmpzb25sZC5nZXQgPSBhc3luYyBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgbGV0IGxvYWQ7XG4gIGlmKHR5cGVvZiBvcHRpb25zLmRvY3VtZW50TG9hZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbG9hZCA9IG9wdGlvbnMuZG9jdW1lbnRMb2FkZXI7XG4gIH0gZWxzZSB7XG4gICAgbG9hZCA9IGpzb25sZC5kb2N1bWVudExvYWRlcjtcbiAgfVxuXG4gIGNvbnN0IHJlbW90ZURvYyA9IGF3YWl0IGxvYWQodXJsKTtcblxuICB0cnkge1xuICAgIGlmKCFyZW1vdGVEb2MuZG9jdW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ05vIHJlbW90ZSBkb2N1bWVudCBmb3VuZCBhdCB0aGUgZ2l2ZW4gVVJMLicsXG4gICAgICAgICdqc29ubGQuTnVsbFJlbW90ZURvY3VtZW50Jyk7XG4gICAgfVxuICAgIGlmKF9pc1N0cmluZyhyZW1vdGVEb2MuZG9jdW1lbnQpKSB7XG4gICAgICByZW1vdGVEb2MuZG9jdW1lbnQgPSBKU09OLnBhcnNlKHJlbW90ZURvYy5kb2N1bWVudCk7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnQ291bGQgbm90IHJldHJpZXZlIGEgSlNPTi1MRCBkb2N1bWVudCBmcm9tIHRoZSBVUkwuJyxcbiAgICAgICdqc29ubGQuTG9hZERvY3VtZW50RXJyb3InLCB7XG4gICAgICAgIGNvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsXG4gICAgICAgIGNhdXNlOiBlLFxuICAgICAgICByZW1vdGVEb2NcbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlbW90ZURvYztcbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIGEgbG9jYWwgY29udGV4dCwgcmVzb2x2aW5nIGFueSBVUkxzIGFzIG5lY2Vzc2FyeSwgYW5kIHJldHVybnMgYVxuICogbmV3IGFjdGl2ZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGN1cnJlbnQgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0gbG9jYWxDdHggdGhlIGxvY2FsIGNvbnRleHQgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2RvY3VtZW50TG9hZGVyKHVybCwgb3B0aW9ucyldIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgYWN0aXZlIGNvbnRleHQuXG4gKi9cbmpzb25sZC5wcm9jZXNzQ29udGV4dCA9IGFzeW5jIGZ1bmN0aW9uKFxuICBhY3RpdmVDdHgsIGxvY2FsQ3R4LCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgYmFzZTogJycsXG4gICAgY29udGV4dFJlc29sdmVyOiBuZXcgQ29udGV4dFJlc29sdmVyKFxuICAgICAge3NoYXJlZENhY2hlOiBfcmVzb2x2ZWRDb250ZXh0Q2FjaGV9KVxuICB9KTtcblxuICAvLyByZXR1cm4gaW5pdGlhbCBjb250ZXh0IGVhcmx5IGZvciBudWxsIGNvbnRleHRcbiAgaWYobG9jYWxDdHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gX2dldEluaXRpYWxDb250ZXh0KG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gZ2V0IFVSTHMgaW4gbG9jYWxDdHhcbiAgbG9jYWxDdHggPSB1dGlsLmNsb25lKGxvY2FsQ3R4KTtcbiAgaWYoIShfaXNPYmplY3QobG9jYWxDdHgpICYmICdAY29udGV4dCcgaW4gbG9jYWxDdHgpKSB7XG4gICAgbG9jYWxDdHggPSB7J0Bjb250ZXh0JzogbG9jYWxDdHh9O1xuICB9XG5cbiAgcmV0dXJuIF9wcm9jZXNzQ29udGV4dCh7YWN0aXZlQ3R4LCBsb2NhbEN0eCwgb3B0aW9uc30pO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmpzb25sZC5nZXRDb250ZXh0VmFsdWUgPSByZXF1aXJlKCcuL2NvbnRleHQnKS5nZXRDb250ZXh0VmFsdWU7XG5cbi8qKlxuICogRG9jdW1lbnQgbG9hZGVycy5cbiAqL1xuanNvbmxkLmRvY3VtZW50TG9hZGVycyA9IHt9O1xuanNvbmxkLmRvY3VtZW50TG9hZGVycy5ub2RlID0gcmVxdWlyZSgnLi9kb2N1bWVudExvYWRlcnMvbm9kZScpO1xuanNvbmxkLmRvY3VtZW50TG9hZGVycy54aHIgPSByZXF1aXJlKCcuL2RvY3VtZW50TG9hZGVycy94aHInKTtcblxuLyoqXG4gKiBBc3NpZ25zIHRoZSBkZWZhdWx0IGRvY3VtZW50IGxvYWRlciBmb3IgZXh0ZXJuYWwgZG9jdW1lbnQgVVJMcyB0byBhIGJ1aWx0LWluXG4gKiBkZWZhdWx0LiBTdXBwb3J0ZWQgdHlwZXMgY3VycmVudGx5IGluY2x1ZGU6ICd4aHInIGFuZCAnbm9kZScuXG4gKlxuICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgdG8gc2V0LlxuICogQHBhcmFtIFtwYXJhbXNdIHRoZSBwYXJhbWV0ZXJzIHJlcXVpcmVkIHRvIHVzZSB0aGUgZG9jdW1lbnQgbG9hZGVyLlxuICovXG5qc29ubGQudXNlRG9jdW1lbnRMb2FkZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmKCEodHlwZSBpbiBqc29ubGQuZG9jdW1lbnRMb2FkZXJzKSkge1xuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdVbmtub3duIGRvY3VtZW50IGxvYWRlciB0eXBlOiBcIicgKyB0eXBlICsgJ1wiJyxcbiAgICAgICdqc29ubGQuVW5rbm93bkRvY3VtZW50TG9hZGVyJyxcbiAgICAgIHt0eXBlfSk7XG4gIH1cblxuICAvLyBzZXQgZG9jdW1lbnQgbG9hZGVyXG4gIGpzb25sZC5kb2N1bWVudExvYWRlciA9IGpzb25sZC5kb2N1bWVudExvYWRlcnNbdHlwZV0uYXBwbHkoXG4gICAganNvbmxkLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIFJERiBkYXRhc2V0IHBhcnNlciBieSBjb250ZW50LXR5cGUsIGZvciB1c2Ugd2l0aFxuICoganNvbmxkLmZyb21SREYuIEFuIFJERiBkYXRhc2V0IHBhcnNlciB3aWxsIGFsd2F5cyBiZSBnaXZlbiBvbmUgcGFyYW1ldGVyLFxuICogYSBzdHJpbmcgb2YgaW5wdXQuIEFuIFJERiBkYXRhc2V0IHBhcnNlciBjYW4gYmUgc3luY2hyb25vdXMgb3JcbiAqIGFzeW5jaHJvbm91cyAoYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSkuXG4gKlxuICogQHBhcmFtIGNvbnRlbnRUeXBlIHRoZSBjb250ZW50LXR5cGUgZm9yIHRoZSBwYXJzZXIuXG4gKiBAcGFyYW0gcGFyc2VyKGlucHV0KSB0aGUgcGFyc2VyIGZ1bmN0aW9uICh0YWtlcyBhIHN0cmluZyBhcyBhIHBhcmFtZXRlclxuICogICAgICAgICAgYW5kIGVpdGhlciByZXR1cm5zIGFuIFJERiBkYXRhc2V0IG9yIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG9uZS5cbiAqL1xuanNvbmxkLnJlZ2lzdGVyUkRGUGFyc2VyID0gZnVuY3Rpb24oY29udGVudFR5cGUsIHBhcnNlcikge1xuICBfcmRmUGFyc2Vyc1tjb250ZW50VHlwZV0gPSBwYXJzZXI7XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGFuIFJERiBkYXRhc2V0IHBhcnNlciBieSBjb250ZW50LXR5cGUuXG4gKlxuICogQHBhcmFtIGNvbnRlbnRUeXBlIHRoZSBjb250ZW50LXR5cGUgZm9yIHRoZSBwYXJzZXIuXG4gKi9cbmpzb25sZC51bnJlZ2lzdGVyUkRGUGFyc2VyID0gZnVuY3Rpb24oY29udGVudFR5cGUpIHtcbiAgZGVsZXRlIF9yZGZQYXJzZXJzW2NvbnRlbnRUeXBlXTtcbn07XG5cbi8vIHJlZ2lzdGVyIHRoZSBOLVF1YWRzIFJERiBwYXJzZXJcbmpzb25sZC5yZWdpc3RlclJERlBhcnNlcignYXBwbGljYXRpb24vbi1xdWFkcycsIE5RdWFkcy5wYXJzZSk7XG5qc29ubGQucmVnaXN0ZXJSREZQYXJzZXIoJ2FwcGxpY2F0aW9uL25xdWFkcycsIE5RdWFkcy5wYXJzZSk7XG5cbi8vIHJlZ2lzdGVyIHRoZSBSREZhIEFQSSBSREYgcGFyc2VyXG5qc29ubGQucmVnaXN0ZXJSREZQYXJzZXIoJ3JkZmEtYXBpJywgUmRmYS5wYXJzZSk7XG5cbi8qIFVSTCBBUEkgKi9cbmpzb25sZC51cmwgPSByZXF1aXJlKCcuL3VybCcpO1xuXG4vKiBVdGlsaXR5IEFQSSAqL1xuanNvbmxkLnV0aWwgPSB1dGlsO1xuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbk9iamVjdC5hc3NpZ24oanNvbmxkLCB1dGlsKTtcblxuLy8gcmVleHBvc2UgQVBJIGFzIGpzb25sZC5wcm9taXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHlcbmpzb25sZC5wcm9taXNlcyA9IGpzb25sZDtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmpzb25sZC5SZXF1ZXN0UXVldWUgPSByZXF1aXJlKCcuL1JlcXVlc3RRdWV1ZScpO1xuXG4vKiBXZWJJREwgQVBJICovXG5qc29ubGQuSnNvbkxkUHJvY2Vzc29yID0gcmVxdWlyZSgnLi9Kc29uTGRQcm9jZXNzb3InKShqc29ubGQpO1xuXG4vLyBzZXR1cCBicm93c2VyIGdsb2JhbCBKc29uTGRQcm9jZXNzb3JcbmlmKF9icm93c2VyICYmIHR5cGVvZiBnbG9iYWwuSnNvbkxkUHJvY2Vzc29yID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCAnSnNvbkxkUHJvY2Vzc29yJywge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZToganNvbmxkLkpzb25MZFByb2Nlc3NvclxuICB9KTtcbn1cblxuLy8gc2V0IHBsYXRmb3JtLXNwZWNpZmljIGRlZmF1bHRzL0FQSXNcbmlmKF9ub2RlanMpIHtcbiAgLy8gdXNlIG5vZGUgZG9jdW1lbnQgbG9hZGVyIGJ5IGRlZmF1bHRcbiAganNvbmxkLnVzZURvY3VtZW50TG9hZGVyKCdub2RlJyk7XG59IGVsc2UgaWYodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAvLyB1c2UgeGhyIGRvY3VtZW50IGxvYWRlciBieSBkZWZhdWx0XG4gIGpzb25sZC51c2VEb2N1bWVudExvYWRlcigneGhyJyk7XG59XG5cbmZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gIGRvY3VtZW50TG9hZGVyID0ganNvbmxkLmRvY3VtZW50TG9hZGVyLFxuICAuLi5kZWZhdWx0c1xufSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwge2RvY3VtZW50TG9hZGVyfSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xufVxuXG4vLyBlbmQgb2YganNvbmxkIEFQSSBgd3JhcHBlcmAgZmFjdG9yeVxucmV0dXJuIGpzb25sZDtcbn07XG5cbi8vIGV4dGVybmFsIEFQSXM6XG5cbi8vIHVzZWQgdG8gZ2VuZXJhdGUgYSBuZXcganNvbmxkIEFQSSBpbnN0YW5jZVxuY29uc3QgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gd3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFjdG9yeSgpO1xuICB9KTtcbn07XG5cbi8vIHdyYXAgdGhlIG1haW4ganNvbmxkIEFQSSBpbnN0YW5jZVxud3JhcHBlcihmYWN0b3J5KTtcbi8vIGV4cG9ydCBBUElcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7aXNLZXl3b3JkfSA9IHJlcXVpcmUoJy4vY29udGV4dCcpO1xuY29uc3QgZ3JhcGhUeXBlcyA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWVyZ2VkIEpTT04tTEQgbm9kZSBtYXAgKG5vZGUgSUQgPT4gbm9kZSkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBleHBhbmRlZCBKU09OLUxEIHRvIGNyZWF0ZSBhIG5vZGUgbWFwIG9mLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbaXNzdWVyXSBhIGpzb25sZC5JZGVudGlmaWVySXNzdWVyIHRvIHVzZSB0byBsYWJlbCBibGFuayBub2Rlcy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBub2RlIG1hcC5cbiAqL1xuYXBpLmNyZWF0ZU1lcmdlZE5vZGVNYXAgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gcHJvZHVjZSBhIG1hcCBvZiBhbGwgc3ViamVjdHMgYW5kIG5hbWUgZWFjaCBibm9kZVxuICBjb25zdCBpc3N1ZXIgPSBvcHRpb25zLmlzc3VlciB8fCBuZXcgdXRpbC5JZGVudGlmaWVySXNzdWVyKCdfOmInKTtcbiAgY29uc3QgZ3JhcGhzID0geydAZGVmYXVsdCc6IHt9fTtcbiAgYXBpLmNyZWF0ZU5vZGVNYXAoaW5wdXQsIGdyYXBocywgJ0BkZWZhdWx0JywgaXNzdWVyKTtcblxuICAvLyBhZGQgYWxsIG5vbi1kZWZhdWx0IGdyYXBocyB0byBkZWZhdWx0IGdyYXBoXG4gIHJldHVybiBhcGkubWVyZ2VOb2RlTWFwcyhncmFwaHMpO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBmbGF0dGVucyB0aGUgc3ViamVjdHMgaW4gdGhlIGdpdmVuIEpTT04tTEQgZXhwYW5kZWQgaW5wdXRcbiAqIGludG8gYSBub2RlIG1hcC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIEpTT04tTEQgZXhwYW5kZWQgaW5wdXQuXG4gKiBAcGFyYW0gZ3JhcGhzIGEgbWFwIG9mIGdyYXBoIG5hbWUgdG8gc3ViamVjdCBtYXAuXG4gKiBAcGFyYW0gZ3JhcGggdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgZ3JhcGguXG4gKiBAcGFyYW0gaXNzdWVyIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgaXNzdWVyLlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgYXNzaWduZWQgdG8gdGhlIGN1cnJlbnQgaW5wdXQgaWYgaXQgaXMgYSBibm9kZS5cbiAqIEBwYXJhbSBsaXN0IHRoZSBsaXN0IHRvIGFwcGVuZCB0bywgbnVsbCBmb3Igbm9uZS5cbiAqL1xuYXBpLmNyZWF0ZU5vZGVNYXAgPSAoaW5wdXQsIGdyYXBocywgZ3JhcGgsIGlzc3VlciwgbmFtZSwgbGlzdCkgPT4ge1xuICAvLyByZWN1cnNlIHRocm91Z2ggYXJyYXlcbiAgaWYodHlwZXMuaXNBcnJheShpbnB1dCkpIHtcbiAgICBmb3IoY29uc3Qgbm9kZSBvZiBpbnB1dCkge1xuICAgICAgYXBpLmNyZWF0ZU5vZGVNYXAobm9kZSwgZ3JhcGhzLCBncmFwaCwgaXNzdWVyLCB1bmRlZmluZWQsIGxpc3QpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhZGQgbm9uLW9iamVjdCB0byBsaXN0XG4gIGlmKCF0eXBlcy5pc09iamVjdChpbnB1dCkpIHtcbiAgICBpZihsaXN0KSB7XG4gICAgICBsaXN0LnB1c2goaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhZGQgdmFsdWVzIHRvIGxpc3RcbiAgaWYoZ3JhcGhUeXBlcy5pc1ZhbHVlKGlucHV0KSkge1xuICAgIGlmKCdAdHlwZScgaW4gaW5wdXQpIHtcbiAgICAgIGxldCB0eXBlID0gaW5wdXRbJ0B0eXBlJ107XG4gICAgICAvLyByZW5hbWUgQHR5cGUgYmxhbmsgbm9kZVxuICAgICAgaWYodHlwZS5pbmRleE9mKCdfOicpID09PSAwKSB7XG4gICAgICAgIGlucHV0WydAdHlwZSddID0gdHlwZSA9IGlzc3Vlci5nZXRJZCh0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYobGlzdCkge1xuICAgICAgbGlzdC5wdXNoKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYobGlzdCAmJiBncmFwaFR5cGVzLmlzTGlzdChpbnB1dCkpIHtcbiAgICBjb25zdCBfbGlzdCA9IFtdO1xuICAgIGFwaS5jcmVhdGVOb2RlTWFwKGlucHV0WydAbGlzdCddLCBncmFwaHMsIGdyYXBoLCBpc3N1ZXIsIG5hbWUsIF9saXN0KTtcbiAgICBsaXN0LnB1c2goeydAbGlzdCc6IF9saXN0fSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm90ZTogQXQgdGhpcyBwb2ludCwgaW5wdXQgbXVzdCBiZSBhIHN1YmplY3QuXG5cbiAgLy8gc3BlYyByZXF1aXJlcyBAdHlwZSB0byBiZSBuYW1lZCBmaXJzdCwgc28gYXNzaWduIG5hbWVzIGVhcmx5XG4gIGlmKCdAdHlwZScgaW4gaW5wdXQpIHtcbiAgICBjb25zdCB0eXBlcyA9IGlucHV0WydAdHlwZSddO1xuICAgIGZvcihjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICBpZih0eXBlLmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgICAgaXNzdWVyLmdldElkKHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGdldCBuYW1lIGZvciBzdWJqZWN0XG4gIGlmKHR5cGVzLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgbmFtZSA9IGdyYXBoVHlwZXMuaXNCbGFua05vZGUoaW5wdXQpID9cbiAgICAgIGlzc3Vlci5nZXRJZChpbnB1dFsnQGlkJ10pIDogaW5wdXRbJ0BpZCddO1xuICB9XG5cbiAgLy8gYWRkIHN1YmplY3QgcmVmZXJlbmNlIHRvIGxpc3RcbiAgaWYobGlzdCkge1xuICAgIGxpc3QucHVzaCh7J0BpZCc6IG5hbWV9KTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBuZXcgc3ViamVjdCBvciBtZXJnZSBpbnRvIGV4aXN0aW5nIG9uZVxuICBjb25zdCBzdWJqZWN0cyA9IGdyYXBoc1tncmFwaF07XG4gIGNvbnN0IHN1YmplY3QgPSBzdWJqZWN0c1tuYW1lXSA9IHN1YmplY3RzW25hbWVdIHx8IHt9O1xuICBzdWJqZWN0WydAaWQnXSA9IG5hbWU7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhpbnB1dCkuc29ydCgpO1xuICBmb3IobGV0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICAvLyBza2lwIEBpZFxuICAgIGlmKHByb3BlcnR5ID09PSAnQGlkJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHJldmVyc2UgcHJvcGVydGllc1xuICAgIGlmKHByb3BlcnR5ID09PSAnQHJldmVyc2UnKSB7XG4gICAgICBjb25zdCByZWZlcmVuY2VkTm9kZSA9IHsnQGlkJzogbmFtZX07XG4gICAgICBjb25zdCByZXZlcnNlTWFwID0gaW5wdXRbJ0ByZXZlcnNlJ107XG4gICAgICBmb3IoY29uc3QgcmV2ZXJzZVByb3BlcnR5IGluIHJldmVyc2VNYXApIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSByZXZlcnNlTWFwW3JldmVyc2VQcm9wZXJ0eV07XG4gICAgICAgIGZvcihjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgbGV0IGl0ZW1OYW1lID0gaXRlbVsnQGlkJ107XG4gICAgICAgICAgaWYoZ3JhcGhUeXBlcy5pc0JsYW5rTm9kZShpdGVtKSkge1xuICAgICAgICAgICAgaXRlbU5hbWUgPSBpc3N1ZXIuZ2V0SWQoaXRlbU5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcGkuY3JlYXRlTm9kZU1hcChpdGVtLCBncmFwaHMsIGdyYXBoLCBpc3N1ZXIsIGl0ZW1OYW1lKTtcbiAgICAgICAgICB1dGlsLmFkZFZhbHVlKFxuICAgICAgICAgICAgc3ViamVjdHNbaXRlbU5hbWVdLCByZXZlcnNlUHJvcGVydHksIHJlZmVyZW5jZWROb2RlLFxuICAgICAgICAgICAge3Byb3BlcnR5SXNBcnJheTogdHJ1ZSwgYWxsb3dEdXBsaWNhdGU6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHJlY3Vyc2UgaW50byBncmFwaFxuICAgIGlmKHByb3BlcnR5ID09PSAnQGdyYXBoJykge1xuICAgICAgLy8gYWRkIGdyYXBoIHN1YmplY3RzIG1hcCBlbnRyeVxuICAgICAgaWYoIShuYW1lIGluIGdyYXBocykpIHtcbiAgICAgICAgZ3JhcGhzW25hbWVdID0ge307XG4gICAgICB9XG4gICAgICBhcGkuY3JlYXRlTm9kZU1hcChpbnB1dFtwcm9wZXJ0eV0sIGdyYXBocywgbmFtZSwgaXNzdWVyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHJlY3Vyc2UgaW50byBpbmNsdWRlZFxuICAgIGlmKHByb3BlcnR5ID09PSAnQGluY2x1ZGVkJykge1xuICAgICAgYXBpLmNyZWF0ZU5vZGVNYXAoaW5wdXRbcHJvcGVydHldLCBncmFwaHMsIGdyYXBoLCBpc3N1ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY29weSBub24tQHR5cGUga2V5d29yZHNcbiAgICBpZihwcm9wZXJ0eSAhPT0gJ0B0eXBlJyAmJiBpc0tleXdvcmQocHJvcGVydHkpKSB7XG4gICAgICBpZihwcm9wZXJ0eSA9PT0gJ0BpbmRleCcgJiYgcHJvcGVydHkgaW4gc3ViamVjdCAmJlxuICAgICAgICAoaW5wdXRbcHJvcGVydHldICE9PSBzdWJqZWN0W3Byb3BlcnR5XSB8fFxuICAgICAgICBpbnB1dFtwcm9wZXJ0eV1bJ0BpZCddICE9PSBzdWJqZWN0W3Byb3BlcnR5XVsnQGlkJ10pKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgY29uZmxpY3RpbmcgQGluZGV4IHByb3BlcnR5IGRldGVjdGVkLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdjb25mbGljdGluZyBpbmRleGVzJywgc3ViamVjdH0pO1xuICAgICAgfVxuICAgICAgc3ViamVjdFtwcm9wZXJ0eV0gPSBpbnB1dFtwcm9wZXJ0eV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgb2JqZWN0c1xuICAgIGNvbnN0IG9iamVjdHMgPSBpbnB1dFtwcm9wZXJ0eV07XG5cbiAgICAvLyBpZiBwcm9wZXJ0eSBpcyBhIGJub2RlLCBhc3NpZ24gaXQgYSBuZXcgaWRcbiAgICBpZihwcm9wZXJ0eS5pbmRleE9mKCdfOicpID09PSAwKSB7XG4gICAgICBwcm9wZXJ0eSA9IGlzc3Vlci5nZXRJZChwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHByb3BlcnR5IGlzIGFkZGVkIGZvciBlbXB0eSBhcnJheXNcbiAgICBpZihvYmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdXRpbC5hZGRWYWx1ZShzdWJqZWN0LCBwcm9wZXJ0eSwgW10sIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IobGV0IG8gb2Ygb2JqZWN0cykge1xuICAgICAgaWYocHJvcGVydHkgPT09ICdAdHlwZScpIHtcbiAgICAgICAgLy8gcmVuYW1lIEB0eXBlIGJsYW5rIG5vZGVzXG4gICAgICAgIG8gPSAoby5pbmRleE9mKCdfOicpID09PSAwKSA/IGlzc3Vlci5nZXRJZChvKSA6IG87XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBlbWJlZGRlZCBzdWJqZWN0IG9yIHN1YmplY3QgcmVmZXJlbmNlXG4gICAgICBpZihncmFwaFR5cGVzLmlzU3ViamVjdChvKSB8fCBncmFwaFR5cGVzLmlzU3ViamVjdFJlZmVyZW5jZShvKSkge1xuICAgICAgICAvLyBza2lwIG51bGwgQGlkXG4gICAgICAgIGlmKCdAaWQnIGluIG8gJiYgIW9bJ0BpZCddKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWxhYmVsIGJsYW5rIG5vZGUgQGlkXG4gICAgICAgIGNvbnN0IGlkID0gZ3JhcGhUeXBlcy5pc0JsYW5rTm9kZShvKSA/XG4gICAgICAgICAgaXNzdWVyLmdldElkKG9bJ0BpZCddKSA6IG9bJ0BpZCddO1xuXG4gICAgICAgIC8vIGFkZCByZWZlcmVuY2UgYW5kIHJlY3Vyc2VcbiAgICAgICAgdXRpbC5hZGRWYWx1ZShcbiAgICAgICAgICBzdWJqZWN0LCBwcm9wZXJ0eSwgeydAaWQnOiBpZH0sXG4gICAgICAgICAge3Byb3BlcnR5SXNBcnJheTogdHJ1ZSwgYWxsb3dEdXBsaWNhdGU6IGZhbHNlfSk7XG4gICAgICAgIGFwaS5jcmVhdGVOb2RlTWFwKG8sIGdyYXBocywgZ3JhcGgsIGlzc3VlciwgaWQpO1xuICAgICAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNWYWx1ZShvKSkge1xuICAgICAgICB1dGlsLmFkZFZhbHVlKFxuICAgICAgICAgIHN1YmplY3QsIHByb3BlcnR5LCBvLFxuICAgICAgICAgIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWUsIGFsbG93RHVwbGljYXRlOiBmYWxzZX0pO1xuICAgICAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNMaXN0KG8pKSB7XG4gICAgICAgIC8vIGhhbmRsZSBAbGlzdFxuICAgICAgICBjb25zdCBfbGlzdCA9IFtdO1xuICAgICAgICBhcGkuY3JlYXRlTm9kZU1hcChvWydAbGlzdCddLCBncmFwaHMsIGdyYXBoLCBpc3N1ZXIsIG5hbWUsIF9saXN0KTtcbiAgICAgICAgbyA9IHsnQGxpc3QnOiBfbGlzdH07XG4gICAgICAgIHV0aWwuYWRkVmFsdWUoXG4gICAgICAgICAgc3ViamVjdCwgcHJvcGVydHksIG8sXG4gICAgICAgICAge3Byb3BlcnR5SXNBcnJheTogdHJ1ZSwgYWxsb3dEdXBsaWNhdGU6IGZhbHNlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgQHZhbHVlXG4gICAgICAgIGFwaS5jcmVhdGVOb2RlTWFwKG8sIGdyYXBocywgZ3JhcGgsIGlzc3VlciwgbmFtZSk7XG4gICAgICAgIHV0aWwuYWRkVmFsdWUoXG4gICAgICAgICAgc3ViamVjdCwgcHJvcGVydHksIG8sIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWUsIGFsbG93RHVwbGljYXRlOiBmYWxzZX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNZXJnZSBzZXBhcmF0ZSBuYW1lZCBncmFwaHMgaW50byBhIHNpbmdsZSBtZXJnZWQgZ3JhcGggaW5jbHVkaW5nXG4gKiBhbGwgbm9kZXMgZnJvbSB0aGUgZGVmYXVsdCBncmFwaCBhbmQgbmFtZWQgZ3JhcGhzLlxuICpcbiAqIEBwYXJhbSBncmFwaHMgYSBtYXAgb2YgZ3JhcGggbmFtZSB0byBzdWJqZWN0IG1hcC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBtZXJnZWQgZ3JhcGggbWFwLlxuICovXG5hcGkubWVyZ2VOb2RlTWFwR3JhcGhzID0gZ3JhcGhzID0+IHtcbiAgY29uc3QgbWVyZ2VkID0ge307XG4gIGZvcihjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGdyYXBocykuc29ydCgpKSB7XG4gICAgZm9yKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKGdyYXBoc1tuYW1lXSkuc29ydCgpKSB7XG4gICAgICBjb25zdCBub2RlID0gZ3JhcGhzW25hbWVdW2lkXTtcbiAgICAgIGlmKCEoaWQgaW4gbWVyZ2VkKSkge1xuICAgICAgICBtZXJnZWRbaWRdID0geydAaWQnOiBpZH07XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWROb2RlID0gbWVyZ2VkW2lkXTtcblxuICAgICAgZm9yKGNvbnN0IHByb3BlcnR5IG9mIE9iamVjdC5rZXlzKG5vZGUpLnNvcnQoKSkge1xuICAgICAgICBpZihpc0tleXdvcmQocHJvcGVydHkpICYmIHByb3BlcnR5ICE9PSAnQHR5cGUnKSB7XG4gICAgICAgICAgLy8gY29weSBrZXl3b3Jkc1xuICAgICAgICAgIG1lcmdlZE5vZGVbcHJvcGVydHldID0gdXRpbC5jbG9uZShub2RlW3Byb3BlcnR5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWVyZ2Ugb2JqZWN0c1xuICAgICAgICAgIGZvcihjb25zdCB2YWx1ZSBvZiBub2RlW3Byb3BlcnR5XSkge1xuICAgICAgICAgICAgdXRpbC5hZGRWYWx1ZShcbiAgICAgICAgICAgICAgbWVyZ2VkTm9kZSwgcHJvcGVydHksIHV0aWwuY2xvbmUodmFsdWUpLFxuICAgICAgICAgICAgICB7cHJvcGVydHlJc0FycmF5OiB0cnVlLCBhbGxvd0R1cGxpY2F0ZTogZmFsc2V9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkO1xufTtcblxuYXBpLm1lcmdlTm9kZU1hcHMgPSBncmFwaHMgPT4ge1xuICAvLyBhZGQgYWxsIG5vbi1kZWZhdWx0IGdyYXBocyB0byBkZWZhdWx0IGdyYXBoXG4gIGNvbnN0IGRlZmF1bHRHcmFwaCA9IGdyYXBoc1snQGRlZmF1bHQnXTtcbiAgY29uc3QgZ3JhcGhOYW1lcyA9IE9iamVjdC5rZXlzKGdyYXBocykuc29ydCgpO1xuICBmb3IoY29uc3QgZ3JhcGhOYW1lIG9mIGdyYXBoTmFtZXMpIHtcbiAgICBpZihncmFwaE5hbWUgPT09ICdAZGVmYXVsdCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBub2RlTWFwID0gZ3JhcGhzW2dyYXBoTmFtZV07XG4gICAgbGV0IHN1YmplY3QgPSBkZWZhdWx0R3JhcGhbZ3JhcGhOYW1lXTtcbiAgICBpZighc3ViamVjdCkge1xuICAgICAgZGVmYXVsdEdyYXBoW2dyYXBoTmFtZV0gPSBzdWJqZWN0ID0ge1xuICAgICAgICAnQGlkJzogZ3JhcGhOYW1lLFxuICAgICAgICAnQGdyYXBoJzogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKCEoJ0BncmFwaCcgaW4gc3ViamVjdCkpIHtcbiAgICAgIHN1YmplY3RbJ0BncmFwaCddID0gW107XG4gICAgfVxuICAgIGNvbnN0IGdyYXBoID0gc3ViamVjdFsnQGdyYXBoJ107XG4gICAgZm9yKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKG5vZGVNYXApLnNvcnQoKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVNYXBbaWRdO1xuICAgICAgLy8gb25seSBhZGQgZnVsbCBzdWJqZWN0c1xuICAgICAgaWYoIWdyYXBoVHlwZXMuaXNTdWJqZWN0UmVmZXJlbmNlKG5vZGUpKSB7XG4gICAgICAgIGdyYXBoLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0R3JhcGg7XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtjcmVhdGVOb2RlTWFwfSA9IHJlcXVpcmUoJy4vbm9kZU1hcCcpO1xuY29uc3Qge2lzS2V5d29yZH0gPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcbmNvbnN0IGdyYXBoVHlwZXMgPSByZXF1aXJlKCcuL2dyYXBoVHlwZXMnKTtcbmNvbnN0IGpzb25DYW5vbmljYWxpemUgPSByZXF1aXJlKCdjYW5vbmljYWxpemUnKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCB7XG4gIC8vIFJERixcbiAgLy8gUkRGX0xJU1QsXG4gIFJERl9GSVJTVCxcbiAgUkRGX1JFU1QsXG4gIFJERl9OSUwsXG4gIFJERl9UWVBFLFxuICAvLyBSREZfUExBSU5fTElURVJBTCxcbiAgLy8gUkRGX1hNTF9MSVRFUkFMLFxuICBSREZfSlNPTl9MSVRFUkFMLFxuICAvLyBSREZfT0JKRUNULFxuICBSREZfTEFOR1NUUklORyxcblxuICAvLyBYU0QsXG4gIFhTRF9CT09MRUFOLFxuICBYU0RfRE9VQkxFLFxuICBYU0RfSU5URUdFUixcbiAgWFNEX1NUUklORyxcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCB7XG4gIGlzQWJzb2x1dGU6IF9pc0Fic29sdXRlSXJpXG59ID0gcmVxdWlyZSgnLi91cmwnKTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBPdXRwdXRzIGFuIFJERiBkYXRhc2V0IGZvciB0aGUgZXhwYW5kZWQgSlNPTi1MRCBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGV4cGFuZGVkIEpTT04tTEQgaW5wdXQuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgUkRGIHNlcmlhbGl6YXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBSREYgZGF0YXNldC5cbiAqL1xuYXBpLnRvUkRGID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIC8vIGNyZWF0ZSBub2RlIG1hcCBmb3IgZGVmYXVsdCBncmFwaCAoYW5kIGFueSBuYW1lZCBncmFwaHMpXG4gIGNvbnN0IGlzc3VlciA9IG5ldyB1dGlsLklkZW50aWZpZXJJc3N1ZXIoJ186YicpO1xuICBjb25zdCBub2RlTWFwID0geydAZGVmYXVsdCc6IHt9fTtcbiAgY3JlYXRlTm9kZU1hcChpbnB1dCwgbm9kZU1hcCwgJ0BkZWZhdWx0JywgaXNzdWVyKTtcblxuICBjb25zdCBkYXRhc2V0ID0gW107XG4gIGNvbnN0IGdyYXBoTmFtZXMgPSBPYmplY3Qua2V5cyhub2RlTWFwKS5zb3J0KCk7XG4gIGZvcihjb25zdCBncmFwaE5hbWUgb2YgZ3JhcGhOYW1lcykge1xuICAgIGxldCBncmFwaFRlcm07XG4gICAgaWYoZ3JhcGhOYW1lID09PSAnQGRlZmF1bHQnKSB7XG4gICAgICBncmFwaFRlcm0gPSB7dGVybVR5cGU6ICdEZWZhdWx0R3JhcGgnLCB2YWx1ZTogJyd9O1xuICAgIH0gZWxzZSBpZihfaXNBYnNvbHV0ZUlyaShncmFwaE5hbWUpKSB7XG4gICAgICBpZihncmFwaE5hbWUuc3RhcnRzV2l0aCgnXzonKSkge1xuICAgICAgICBncmFwaFRlcm0gPSB7dGVybVR5cGU6ICdCbGFua05vZGUnfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyYXBoVGVybSA9IHt0ZXJtVHlwZTogJ05hbWVkTm9kZSd9O1xuICAgICAgfVxuICAgICAgZ3JhcGhUZXJtLnZhbHVlID0gZ3JhcGhOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBza2lwIHJlbGF0aXZlIElSSXMgKG5vdCB2YWxpZCBSREYpXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgX2dyYXBoVG9SREYoZGF0YXNldCwgbm9kZU1hcFtncmFwaE5hbWVdLCBncmFwaFRlcm0sIGlzc3Vlciwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gZGF0YXNldDtcbn07XG5cbi8qKlxuICogQWRkcyBSREYgcXVhZHMgZm9yIGEgcGFydGljdWxhciBncmFwaCB0byB0aGUgZ2l2ZW4gZGF0YXNldC5cbiAqXG4gKiBAcGFyYW0gZGF0YXNldCB0aGUgZGF0YXNldCB0byBhcHBlbmQgUkRGIHF1YWRzIHRvLlxuICogQHBhcmFtIGdyYXBoIHRoZSBncmFwaCB0byBjcmVhdGUgUkRGIHF1YWRzIGZvci5cbiAqIEBwYXJhbSBncmFwaFRlcm0gdGhlIGdyYXBoIHRlcm0gZm9yIGVhY2ggcXVhZC5cbiAqIEBwYXJhbSBpc3N1ZXIgYSBJZGVudGlmaWVySXNzdWVyIGZvciBhc3NpZ25pbmcgYmxhbmsgbm9kZSBuYW1lcy5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBSREYgc2VyaWFsaXphdGlvbiBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIGFycmF5IG9mIFJERiB0cmlwbGVzIGZvciB0aGUgZ2l2ZW4gZ3JhcGguXG4gKi9cbmZ1bmN0aW9uIF9ncmFwaFRvUkRGKGRhdGFzZXQsIGdyYXBoLCBncmFwaFRlcm0sIGlzc3Vlciwgb3B0aW9ucykge1xuICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhncmFwaCkuc29ydCgpO1xuICBmb3IoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgY29uc3Qgbm9kZSA9IGdyYXBoW2lkXTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMobm9kZSkuc29ydCgpO1xuICAgIGZvcihsZXQgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgICAgY29uc3QgaXRlbXMgPSBub2RlW3Byb3BlcnR5XTtcbiAgICAgIGlmKHByb3BlcnR5ID09PSAnQHR5cGUnKSB7XG4gICAgICAgIHByb3BlcnR5ID0gUkRGX1RZUEU7XG4gICAgICB9IGVsc2UgaWYoaXNLZXl3b3JkKHByb3BlcnR5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZm9yKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgLy8gUkRGIHN1YmplY3RcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IHtcbiAgICAgICAgICB0ZXJtVHlwZTogaWQuc3RhcnRzV2l0aCgnXzonKSA/ICdCbGFua05vZGUnIDogJ05hbWVkTm9kZScsXG4gICAgICAgICAgdmFsdWU6IGlkXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2tpcCByZWxhdGl2ZSBJUkkgc3ViamVjdHMgKG5vdCB2YWxpZCBSREYpXG4gICAgICAgIGlmKCFfaXNBYnNvbHV0ZUlyaShpZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJERiBwcmVkaWNhdGVcbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0ge1xuICAgICAgICAgIHRlcm1UeXBlOiBwcm9wZXJ0eS5zdGFydHNXaXRoKCdfOicpID8gJ0JsYW5rTm9kZScgOiAnTmFtZWROb2RlJyxcbiAgICAgICAgICB2YWx1ZTogcHJvcGVydHlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBza2lwIHJlbGF0aXZlIElSSSBwcmVkaWNhdGVzIChub3QgdmFsaWQgUkRGKVxuICAgICAgICBpZighX2lzQWJzb2x1dGVJcmkocHJvcGVydHkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBza2lwIGJsYW5rIG5vZGUgcHJlZGljYXRlcyB1bmxlc3MgcHJvZHVjaW5nIGdlbmVyYWxpemVkIFJERlxuICAgICAgICBpZihwcmVkaWNhdGUudGVybVR5cGUgPT09ICdCbGFua05vZGUnICYmXG4gICAgICAgICAgIW9wdGlvbnMucHJvZHVjZUdlbmVyYWxpemVkUmRmKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IGxpc3QsIHZhbHVlIG9yIG5vZGUgb2JqZWN0IHRvIHRyaXBsZVxuICAgICAgICBjb25zdCBvYmplY3QgPVxuICAgICAgICAgIF9vYmplY3RUb1JERihpdGVtLCBpc3N1ZXIsIGRhdGFzZXQsIGdyYXBoVGVybSwgb3B0aW9ucy5yZGZEaXJlY3Rpb24pO1xuICAgICAgICAvLyBza2lwIG51bGwgb2JqZWN0cyAodGhleSBhcmUgcmVsYXRpdmUgSVJJcylcbiAgICAgICAgaWYob2JqZWN0KSB7XG4gICAgICAgICAgZGF0YXNldC5wdXNoKHtcbiAgICAgICAgICAgIHN1YmplY3QsXG4gICAgICAgICAgICBwcmVkaWNhdGUsXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncmFwaDogZ3JhcGhUZXJtXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEBsaXN0IHZhbHVlIGludG8gbGlua2VkIGxpc3Qgb2YgYmxhbmsgbm9kZSBSREYgcXVhZHNcbiAqIChhbiBSREYgY29sbGVjdGlvbikuXG4gKlxuICogQHBhcmFtIGxpc3QgdGhlIEBsaXN0IHZhbHVlLlxuICogQHBhcmFtIGlzc3VlciBhIElkZW50aWZpZXJJc3N1ZXIgZm9yIGFzc2lnbmluZyBibGFuayBub2RlIG5hbWVzLlxuICogQHBhcmFtIGRhdGFzZXQgdGhlIGFycmF5IG9mIHF1YWRzIHRvIGFwcGVuZCB0by5cbiAqIEBwYXJhbSBncmFwaFRlcm0gdGhlIGdyYXBoIHRlcm0gZm9yIGVhY2ggcXVhZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICovXG5mdW5jdGlvbiBfbGlzdFRvUkRGKGxpc3QsIGlzc3VlciwgZGF0YXNldCwgZ3JhcGhUZXJtLCByZGZEaXJlY3Rpb24pIHtcbiAgY29uc3QgZmlyc3QgPSB7dGVybVR5cGU6ICdOYW1lZE5vZGUnLCB2YWx1ZTogUkRGX0ZJUlNUfTtcbiAgY29uc3QgcmVzdCA9IHt0ZXJtVHlwZTogJ05hbWVkTm9kZScsIHZhbHVlOiBSREZfUkVTVH07XG4gIGNvbnN0IG5pbCA9IHt0ZXJtVHlwZTogJ05hbWVkTm9kZScsIHZhbHVlOiBSREZfTklMfTtcblxuICBjb25zdCBsYXN0ID0gbGlzdC5wb3AoKTtcbiAgLy8gUmVzdWx0IGlzIHRoZSBoZWFkIG9mIHRoZSBsaXN0XG4gIGNvbnN0IHJlc3VsdCA9IGxhc3QgPyB7dGVybVR5cGU6ICdCbGFua05vZGUnLCB2YWx1ZTogaXNzdWVyLmdldElkKCl9IDogbmlsO1xuICBsZXQgc3ViamVjdCA9IHJlc3VsdDtcblxuICBmb3IoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gX29iamVjdFRvUkRGKGl0ZW0sIGlzc3VlciwgZGF0YXNldCwgZ3JhcGhUZXJtLCByZGZEaXJlY3Rpb24pO1xuICAgIGNvbnN0IG5leHQgPSB7dGVybVR5cGU6ICdCbGFua05vZGUnLCB2YWx1ZTogaXNzdWVyLmdldElkKCl9O1xuICAgIGRhdGFzZXQucHVzaCh7XG4gICAgICBzdWJqZWN0LFxuICAgICAgcHJlZGljYXRlOiBmaXJzdCxcbiAgICAgIG9iamVjdCxcbiAgICAgIGdyYXBoOiBncmFwaFRlcm1cbiAgICB9KTtcbiAgICBkYXRhc2V0LnB1c2goe1xuICAgICAgc3ViamVjdCxcbiAgICAgIHByZWRpY2F0ZTogcmVzdCxcbiAgICAgIG9iamVjdDogbmV4dCxcbiAgICAgIGdyYXBoOiBncmFwaFRlcm1cbiAgICB9KTtcbiAgICBzdWJqZWN0ID0gbmV4dDtcbiAgfVxuXG4gIC8vIFRhaWwgb2YgbGlzdFxuICBpZihsYXN0KSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gX29iamVjdFRvUkRGKGxhc3QsIGlzc3VlciwgZGF0YXNldCwgZ3JhcGhUZXJtLCByZGZEaXJlY3Rpb24pO1xuICAgIGRhdGFzZXQucHVzaCh7XG4gICAgICBzdWJqZWN0LFxuICAgICAgcHJlZGljYXRlOiBmaXJzdCxcbiAgICAgIG9iamVjdCxcbiAgICAgIGdyYXBoOiBncmFwaFRlcm1cbiAgICB9KTtcbiAgICBkYXRhc2V0LnB1c2goe1xuICAgICAgc3ViamVjdCxcbiAgICAgIHByZWRpY2F0ZTogcmVzdCxcbiAgICAgIG9iamVjdDogbmlsLFxuICAgICAgZ3JhcGg6IGdyYXBoVGVybVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEpTT04tTEQgdmFsdWUgb2JqZWN0IHRvIGFuIFJERiBsaXRlcmFsIG9yIGEgSlNPTi1MRCBzdHJpbmcsXG4gKiBub2RlIG9iamVjdCB0byBhbiBSREYgcmVzb3VyY2UsIG9yIGFkZHMgYSBsaXN0LlxuICpcbiAqIEBwYXJhbSBpdGVtIHRoZSBKU09OLUxEIHZhbHVlIG9yIG5vZGUgb2JqZWN0LlxuICogQHBhcmFtIGlzc3VlciBhIElkZW50aWZpZXJJc3N1ZXIgZm9yIGFzc2lnbmluZyBibGFuayBub2RlIG5hbWVzLlxuICogQHBhcmFtIGRhdGFzZXQgdGhlIGRhdGFzZXQgdG8gYXBwZW5kIFJERiBxdWFkcyB0by5cbiAqIEBwYXJhbSBncmFwaFRlcm0gdGhlIGdyYXBoIHRlcm0gZm9yIGVhY2ggcXVhZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBSREYgbGl0ZXJhbCBvciBSREYgcmVzb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIF9vYmplY3RUb1JERihpdGVtLCBpc3N1ZXIsIGRhdGFzZXQsIGdyYXBoVGVybSwgcmRmRGlyZWN0aW9uKSB7XG4gIGNvbnN0IG9iamVjdCA9IHt9O1xuXG4gIC8vIGNvbnZlcnQgdmFsdWUgb2JqZWN0IHRvIFJERlxuICBpZihncmFwaFR5cGVzLmlzVmFsdWUoaXRlbSkpIHtcbiAgICBvYmplY3QudGVybVR5cGUgPSAnTGl0ZXJhbCc7XG4gICAgb2JqZWN0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgIG9iamVjdC5kYXRhdHlwZSA9IHtcbiAgICAgIHRlcm1UeXBlOiAnTmFtZWROb2RlJ1xuICAgIH07XG4gICAgbGV0IHZhbHVlID0gaXRlbVsnQHZhbHVlJ107XG4gICAgY29uc3QgZGF0YXR5cGUgPSBpdGVtWydAdHlwZSddIHx8IG51bGw7XG5cbiAgICAvLyBjb252ZXJ0IHRvIFhTRC9KU09OIGRhdGF0eXBlcyBhcyBhcHByb3ByaWF0ZVxuICAgIGlmKGRhdGF0eXBlID09PSAnQGpzb24nKSB7XG4gICAgICBvYmplY3QudmFsdWUgPSBqc29uQ2Fub25pY2FsaXplKHZhbHVlKTtcbiAgICAgIG9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IFJERl9KU09OX0xJVEVSQUw7XG4gICAgfSBlbHNlIGlmKHR5cGVzLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBYU0RfQk9PTEVBTjtcbiAgICB9IGVsc2UgaWYodHlwZXMuaXNEb3VibGUodmFsdWUpIHx8IGRhdGF0eXBlID09PSBYU0RfRE9VQkxFKSB7XG4gICAgICBpZighdHlwZXMuaXNEb3VibGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBjYW5vbmljYWwgZG91YmxlIHJlcHJlc2VudGF0aW9uXG4gICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZS50b0V4cG9uZW50aWFsKDE1KS5yZXBsYWNlKC8oXFxkKTAqZVxcKz8vLCAnJDFFJyk7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBYU0RfRE9VQkxFO1xuICAgIH0gZWxzZSBpZih0eXBlcy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBYU0RfSU5URUdFUjtcbiAgICB9IGVsc2UgaWYocmRmRGlyZWN0aW9uID09PSAnaTE4bi1kYXRhdHlwZScgJiZcbiAgICAgICdAZGlyZWN0aW9uJyBpbiBpdGVtKSB7XG4gICAgICBjb25zdCBkYXRhdHlwZSA9ICdodHRwczovL3d3dy53My5vcmcvbnMvaTE4biMnICtcbiAgICAgICAgKGl0ZW1bJ0BsYW5ndWFnZSddIHx8ICcnKSArXG4gICAgICAgIGBfJHtpdGVtWydAZGlyZWN0aW9uJ119YDtcbiAgICAgIG9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IGRhdGF0eXBlO1xuICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmKCdAbGFuZ3VhZ2UnIGluIGl0ZW0pIHtcbiAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgb2JqZWN0LmRhdGF0eXBlLnZhbHVlID0gZGF0YXR5cGUgfHwgUkRGX0xBTkdTVFJJTkc7XG4gICAgICBvYmplY3QubGFuZ3VhZ2UgPSBpdGVtWydAbGFuZ3VhZ2UnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBYU0RfU1RSSU5HO1xuICAgIH1cbiAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNMaXN0KGl0ZW0pKSB7XG4gICAgY29uc3QgX2xpc3QgPVxuICAgICAgX2xpc3RUb1JERihpdGVtWydAbGlzdCddLCBpc3N1ZXIsIGRhdGFzZXQsIGdyYXBoVGVybSwgcmRmRGlyZWN0aW9uKTtcbiAgICBvYmplY3QudGVybVR5cGUgPSBfbGlzdC50ZXJtVHlwZTtcbiAgICBvYmplY3QudmFsdWUgPSBfbGlzdC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb252ZXJ0IHN0cmluZy9ub2RlIG9iamVjdCB0byBSREZcbiAgICBjb25zdCBpZCA9IHR5cGVzLmlzT2JqZWN0KGl0ZW0pID8gaXRlbVsnQGlkJ10gOiBpdGVtO1xuICAgIG9iamVjdC50ZXJtVHlwZSA9IGlkLnN0YXJ0c1dpdGgoJ186JykgPyAnQmxhbmtOb2RlJyA6ICdOYW1lZE5vZGUnO1xuICAgIG9iamVjdC52YWx1ZSA9IGlkO1xuICB9XG5cbiAgLy8gc2tpcCByZWxhdGl2ZSBJUklzLCBub3QgdmFsaWQgUkRGXG4gIGlmKG9iamVjdC50ZXJtVHlwZSA9PT0gJ05hbWVkTm9kZScgJiYgIV9pc0Fic29sdXRlSXJpKG9iamVjdC52YWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIEFycmF5LlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIEFycmF5LCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgQm9vbGVhbi5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIEJvb2xlYW4sIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzQm9vbGVhbiA9IHYgPT4gKHR5cGVvZiB2ID09PSAnYm9vbGVhbicgfHxcbiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBCb29sZWFuXScpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBkb3VibGUuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBkb3VibGUsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzRG91YmxlID0gdiA9PiBhcGkuaXNOdW1iZXIodikgJiZcbiAgKFN0cmluZyh2KS5pbmRleE9mKCcuJykgIT09IC0xIHx8IE1hdGguYWJzKHYpID49IDFlMjEpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZW1wdHkgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIGVtcHR5IE9iamVjdCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNFbXB0eU9iamVjdCA9IHYgPT4gYXBpLmlzT2JqZWN0KHYpICYmIE9iamVjdC5rZXlzKHYpLmxlbmd0aCA9PT0gMDtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgTnVtYmVyLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgTnVtYmVyLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc051bWJlciA9IHYgPT4gKHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fFxuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IE51bWJlcl0nKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG51bWVyaWMuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYywgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNOdW1lcmljID0gdiA9PiAhaXNOYU4ocGFyc2VGbG9hdCh2KSkgJiYgaXNGaW5pdGUodik7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gT2JqZWN0LCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc09iamVjdCA9IHYgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgU3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgU3RyaW5nLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc1N0cmluZyA9IHYgPT4gKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fFxuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFN0cmluZ10nKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzVW5kZWZpbmVkID0gdiA9PiB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCc7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGRlZmluZSBVUkwgcGFyc2VyXG4vLyBwYXJzZVVyaSAxLjIuMlxuLy8gKGMpIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuLy8gTUlUIExpY2Vuc2Vcbi8vIHdpdGggbG9jYWwganNvbmxkLmpzIG1vZGlmaWNhdGlvbnNcbmFwaS5wYXJzZXJzID0ge1xuICBzaW1wbGU6IHtcbiAgICAvLyBSRkMgMzk4NiBiYXNpYyBwYXJ0c1xuICAgIGtleXM6IFtcbiAgICAgICdocmVmJywgJ3NjaGVtZScsICdhdXRob3JpdHknLCAncGF0aCcsICdxdWVyeScsICdmcmFnbWVudCdcbiAgICBdLFxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuICovXG4gICAgcmVnZXg6IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IyguKikpPy9cbiAgfSxcbiAgZnVsbDoge1xuICAgIGtleXM6IFtcbiAgICAgICdocmVmJywgJ3Byb3RvY29sJywgJ3NjaGVtZScsICdhdXRob3JpdHknLCAnYXV0aCcsICd1c2VyJywgJ3Bhc3N3b3JkJyxcbiAgICAgICdob3N0bmFtZScsICdwb3J0JywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnZnJhZ21lbnQnXG4gICAgXSxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlbiAqL1xuICAgIHJlZ2V4OiAvXigoW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPyg/OigoKD86W14/I1xcL10qXFwvKSopKFtePyNdKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvXG4gIH1cbn07XG5hcGkucGFyc2UgPSAoc3RyLCBwYXJzZXIpID0+IHtcbiAgY29uc3QgcGFyc2VkID0ge307XG4gIGNvbnN0IG8gPSBhcGkucGFyc2Vyc1twYXJzZXIgfHwgJ2Z1bGwnXTtcbiAgY29uc3QgbSA9IG8ucmVnZXguZXhlYyhzdHIpO1xuICBsZXQgaSA9IG8ua2V5cy5sZW5ndGg7XG4gIHdoaWxlKGktLSkge1xuICAgIHBhcnNlZFtvLmtleXNbaV1dID0gKG1baV0gPT09IHVuZGVmaW5lZCkgPyBudWxsIDogbVtpXTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBkZWZhdWx0IHBvcnRzIGluIGZvdW5kIGluIFVSTHNcbiAgaWYoKHBhcnNlZC5zY2hlbWUgPT09ICdodHRwcycgJiYgcGFyc2VkLnBvcnQgPT09ICc0NDMnKSB8fFxuICAgIChwYXJzZWQuc2NoZW1lID09PSAnaHR0cCcgJiYgcGFyc2VkLnBvcnQgPT09ICc4MCcpKSB7XG4gICAgcGFyc2VkLmhyZWYgPSBwYXJzZWQuaHJlZi5yZXBsYWNlKCc6JyArIHBhcnNlZC5wb3J0LCAnJyk7XG4gICAgcGFyc2VkLmF1dGhvcml0eSA9IHBhcnNlZC5hdXRob3JpdHkucmVwbGFjZSgnOicgKyBwYXJzZWQucG9ydCwgJycpO1xuICAgIHBhcnNlZC5wb3J0ID0gbnVsbDtcbiAgfVxuXG4gIHBhcnNlZC5ub3JtYWxpemVkUGF0aCA9IGFwaS5yZW1vdmVEb3RTZWdtZW50cyhwYXJzZWQucGF0aCk7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vKipcbiAqIFByZXBlbmRzIGEgYmFzZSBJUkkgdG8gdGhlIGdpdmVuIHJlbGF0aXZlIElSSS5cbiAqXG4gKiBAcGFyYW0gYmFzZSB0aGUgYmFzZSBJUkkuXG4gKiBAcGFyYW0gaXJpIHRoZSByZWxhdGl2ZSBJUkkuXG4gKlxuICogQHJldHVybiB0aGUgYWJzb2x1dGUgSVJJLlxuICovXG5hcGkucHJlcGVuZEJhc2UgPSAoYmFzZSwgaXJpKSA9PiB7XG4gIC8vIHNraXAgSVJJIHByb2Nlc3NpbmdcbiAgaWYoYmFzZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBpcmk7XG4gIH1cbiAgLy8gYWxyZWFkeSBhbiBhYnNvbHV0ZSBJUklcbiAgaWYoYXBpLmlzQWJzb2x1dGUoaXJpKSkge1xuICAgIHJldHVybiBpcmk7XG4gIH1cblxuICAvLyBwYXJzZSBiYXNlIGlmIGl0IGlzIGEgc3RyaW5nXG4gIGlmKCFiYXNlIHx8IHR5cGVzLmlzU3RyaW5nKGJhc2UpKSB7XG4gICAgYmFzZSA9IGFwaS5wYXJzZShiYXNlIHx8ICcnKTtcbiAgfVxuXG4gIC8vIHBhcnNlIGdpdmVuIElSSVxuICBjb25zdCByZWwgPSBhcGkucGFyc2UoaXJpKTtcblxuICAvLyBwZXIgUkZDMzk4NiA1LjIuMlxuICBjb25zdCB0cmFuc2Zvcm0gPSB7XG4gICAgcHJvdG9jb2w6IGJhc2UucHJvdG9jb2wgfHwgJydcbiAgfTtcblxuICBpZihyZWwuYXV0aG9yaXR5ICE9PSBudWxsKSB7XG4gICAgdHJhbnNmb3JtLmF1dGhvcml0eSA9IHJlbC5hdXRob3JpdHk7XG4gICAgdHJhbnNmb3JtLnBhdGggPSByZWwucGF0aDtcbiAgICB0cmFuc2Zvcm0ucXVlcnkgPSByZWwucXVlcnk7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNmb3JtLmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuXG4gICAgaWYocmVsLnBhdGggPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0ucGF0aCA9IGJhc2UucGF0aDtcbiAgICAgIGlmKHJlbC5xdWVyeSAhPT0gbnVsbCkge1xuICAgICAgICB0cmFuc2Zvcm0ucXVlcnkgPSByZWwucXVlcnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm0ucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihyZWwucGF0aC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgICAgLy8gSVJJIHJlcHJlc2VudHMgYW4gYWJzb2x1dGUgcGF0aFxuICAgICAgICB0cmFuc2Zvcm0ucGF0aCA9IHJlbC5wYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWVyZ2UgcGF0aHNcbiAgICAgICAgbGV0IHBhdGggPSBiYXNlLnBhdGg7XG5cbiAgICAgICAgLy8gYXBwZW5kIHJlbGF0aXZlIHBhdGggdG8gdGhlIGVuZCBvZiB0aGUgbGFzdCBkaXJlY3RvcnkgZnJvbSBiYXNlXG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgICAgaWYoKHBhdGgubGVuZ3RoID4gMCB8fCBiYXNlLmF1dGhvcml0eSkgJiYgcGF0aC5zdWJzdHIoLTEpICE9PSAnLycpIHtcbiAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgICAgICBwYXRoICs9IHJlbC5wYXRoO1xuXG4gICAgICAgIHRyYW5zZm9ybS5wYXRoID0gcGF0aDtcbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybS5xdWVyeSA9IHJlbC5xdWVyeTtcbiAgICB9XG4gIH1cblxuICBpZihyZWwucGF0aCAhPT0gJycpIHtcbiAgICAvLyByZW1vdmUgc2xhc2hlcyBhbmQgZG90cyBpbiBwYXRoXG4gICAgdHJhbnNmb3JtLnBhdGggPSBhcGkucmVtb3ZlRG90U2VnbWVudHModHJhbnNmb3JtLnBhdGgpO1xuICB9XG5cbiAgLy8gY29uc3RydWN0IFVSTFxuICBsZXQgcnZhbCA9IHRyYW5zZm9ybS5wcm90b2NvbDtcbiAgaWYodHJhbnNmb3JtLmF1dGhvcml0eSAhPT0gbnVsbCkge1xuICAgIHJ2YWwgKz0gJy8vJyArIHRyYW5zZm9ybS5hdXRob3JpdHk7XG4gIH1cbiAgcnZhbCArPSB0cmFuc2Zvcm0ucGF0aDtcbiAgaWYodHJhbnNmb3JtLnF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgcnZhbCArPSAnPycgKyB0cmFuc2Zvcm0ucXVlcnk7XG4gIH1cbiAgaWYocmVsLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgcnZhbCArPSAnIycgKyByZWwuZnJhZ21lbnQ7XG4gIH1cblxuICAvLyBoYW5kbGUgZW1wdHkgYmFzZVxuICBpZihydmFsID09PSAnJykge1xuICAgIHJ2YWwgPSAnLi8nO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBiYXNlIElSSSBmcm9tIHRoZSBnaXZlbiBhYnNvbHV0ZSBJUkkuXG4gKlxuICogQHBhcmFtIGJhc2UgdGhlIGJhc2UgSVJJLlxuICogQHBhcmFtIGlyaSB0aGUgYWJzb2x1dGUgSVJJLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlbGF0aXZlIElSSSBpZiByZWxhdGl2ZSB0byBiYXNlLCBvdGhlcndpc2UgdGhlIGFic29sdXRlIElSSS5cbiAqL1xuYXBpLnJlbW92ZUJhc2UgPSAoYmFzZSwgaXJpKSA9PiB7XG4gIC8vIHNraXAgSVJJIHByb2Nlc3NpbmdcbiAgaWYoYmFzZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBpcmk7XG4gIH1cblxuICBpZighYmFzZSB8fCB0eXBlcy5pc1N0cmluZyhiYXNlKSkge1xuICAgIGJhc2UgPSBhcGkucGFyc2UoYmFzZSB8fCAnJyk7XG4gIH1cblxuICAvLyBlc3RhYmxpc2ggYmFzZSByb290XG4gIGxldCByb290ID0gJyc7XG4gIGlmKGJhc2UuaHJlZiAhPT0gJycpIHtcbiAgICByb290ICs9IChiYXNlLnByb3RvY29sIHx8ICcnKSArICcvLycgKyAoYmFzZS5hdXRob3JpdHkgfHwgJycpO1xuICB9IGVsc2UgaWYoaXJpLmluZGV4T2YoJy8vJykpIHtcbiAgICAvLyBzdXBwb3J0IG5ldHdvcmstcGF0aCByZWZlcmVuY2Ugd2l0aCBlbXB0eSBiYXNlXG4gICAgcm9vdCArPSAnLy8nO1xuICB9XG5cbiAgLy8gSVJJIG5vdCByZWxhdGl2ZSB0byBiYXNlXG4gIGlmKGlyaS5pbmRleE9mKHJvb3QpICE9PSAwKSB7XG4gICAgcmV0dXJuIGlyaTtcbiAgfVxuXG4gIC8vIHJlbW92ZSByb290IGZyb20gSVJJIGFuZCBwYXJzZSByZW1haW5kZXJcbiAgY29uc3QgcmVsID0gYXBpLnBhcnNlKGlyaS5zdWJzdHIocm9vdC5sZW5ndGgpKTtcblxuICAvLyByZW1vdmUgcGF0aCBzZWdtZW50cyB0aGF0IG1hdGNoIChkbyBub3QgcmVtb3ZlIGxhc3Qgc2VnbWVudCB1bmxlc3MgdGhlcmVcbiAgLy8gaXMgYSBoYXNoIG9yIHF1ZXJ5KVxuICBjb25zdCBiYXNlU2VnbWVudHMgPSBiYXNlLm5vcm1hbGl6ZWRQYXRoLnNwbGl0KCcvJyk7XG4gIGNvbnN0IGlyaVNlZ21lbnRzID0gcmVsLm5vcm1hbGl6ZWRQYXRoLnNwbGl0KCcvJyk7XG4gIGNvbnN0IGxhc3QgPSAocmVsLmZyYWdtZW50IHx8IHJlbC5xdWVyeSkgPyAwIDogMTtcbiAgd2hpbGUoYmFzZVNlZ21lbnRzLmxlbmd0aCA+IDAgJiYgaXJpU2VnbWVudHMubGVuZ3RoID4gbGFzdCkge1xuICAgIGlmKGJhc2VTZWdtZW50c1swXSAhPT0gaXJpU2VnbWVudHNbMF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBiYXNlU2VnbWVudHMuc2hpZnQoKTtcbiAgICBpcmlTZWdtZW50cy5zaGlmdCgpO1xuICB9XG5cbiAgLy8gdXNlICcuLi8nIGZvciBlYWNoIG5vbi1tYXRjaGluZyBiYXNlIHNlZ21lbnRcbiAgbGV0IHJ2YWwgPSAnJztcbiAgaWYoYmFzZVNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBkb24ndCBjb3VudCB0aGUgbGFzdCBzZWdtZW50IChpZiBpdCBlbmRzIHdpdGggJy8nIGxhc3QgcGF0aCBkb2Vzbid0XG4gICAgLy8gY291bnQgYW5kIGlmIGl0IGRvZXNuJ3QgZW5kIHdpdGggJy8nIGl0IGlzbid0IGEgcGF0aClcbiAgICBiYXNlU2VnbWVudHMucG9wKCk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGJhc2VTZWdtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgcnZhbCArPSAnLi4vJztcbiAgICB9XG4gIH1cblxuICAvLyBwcmVwZW5kIHJlbWFpbmluZyBzZWdtZW50c1xuICBydmFsICs9IGlyaVNlZ21lbnRzLmpvaW4oJy8nKTtcblxuICAvLyBhZGQgcXVlcnkgYW5kIGhhc2hcbiAgaWYocmVsLnF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgcnZhbCArPSAnPycgKyByZWwucXVlcnk7XG4gIH1cbiAgaWYocmVsLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgcnZhbCArPSAnIycgKyByZWwuZnJhZ21lbnQ7XG4gIH1cblxuICAvLyBoYW5kbGUgZW1wdHkgYmFzZVxuICBpZihydmFsID09PSAnJykge1xuICAgIHJ2YWwgPSAnLi8nO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgZG90IHNlZ21lbnRzIGZyb20gYSBVUkwgcGF0aC5cbiAqXG4gKiBAcGFyYW0gcGF0aCB0aGUgcGF0aCB0byByZW1vdmUgZG90IHNlZ21lbnRzIGZyb20uXG4gKi9cbmFwaS5yZW1vdmVEb3RTZWdtZW50cyA9IHBhdGggPT4ge1xuICAvLyBSRkMgMzk4NiA1LjIuNCAocmV3b3JrZWQpXG5cbiAgLy8gZW1wdHkgcGF0aCBzaG9ydGN1dFxuICBpZihwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IGlucHV0ID0gcGF0aC5zcGxpdCgnLycpO1xuICBjb25zdCBvdXRwdXQgPSBbXTtcblxuICB3aGlsZShpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbmV4dCA9IGlucHV0LnNoaWZ0KCk7XG4gICAgY29uc3QgZG9uZSA9IGlucHV0Lmxlbmd0aCA9PT0gMDtcblxuICAgIGlmKG5leHQgPT09ICcuJykge1xuICAgICAgaWYoZG9uZSkge1xuICAgICAgICAvLyBlbnN1cmUgb3V0cHV0IGhhcyB0cmFpbGluZyAvXG4gICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmKG5leHQgPT09ICcuLicpIHtcbiAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgIGlmKGRvbmUpIHtcbiAgICAgICAgLy8gZW5zdXJlIG91dHB1dCBoYXMgdHJhaWxpbmcgL1xuICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHVzaChuZXh0KTtcbiAgfVxuXG4gIC8vIGlmIHBhdGggd2FzIGFic29sdXRlLCBlbnN1cmUgb3V0cHV0IGhhcyBsZWFkaW5nIC9cbiAgaWYocGF0aFswXSA9PT0gJy8nICYmIG91dHB1dC5sZW5ndGggPiAwICYmIG91dHB1dFswXSAhPT0gJycpIHtcbiAgICBvdXRwdXQudW5zaGlmdCgnJyk7XG4gIH1cbiAgaWYob3V0cHV0Lmxlbmd0aCA9PT0gMSAmJiBvdXRwdXRbMF0gPT09ICcnKSB7XG4gICAgcmV0dXJuICcvJztcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignLycpO1xufTtcblxuLy8gVE9ETzogdGltZSBiZXR0ZXIgaXNBYnNvbHV0ZS9pc1JlbGF0aXZlIGNoZWNrcyB1c2luZyBmdWxsIHJlZ2V4ZXM6XG4vLyBodHRwOi8vam1yd2FyZS5jb20vYXJ0aWNsZXMvMjAwOS91cmlfcmVnZXhwL1VSSV9yZWdleC5odG1sXG5cbi8vIHJlZ2V4IHRvIGNoZWNrIGZvciBhYnNvbHV0ZSBJUkkgKHN0YXJ0aW5nIHNjaGVtZSBhbmQgJzonKSBvciBibGFuayBub2RlIElSSVxuY29uc3QgaXNBYnNvbHV0ZVJlZ2V4ID0gL14oW0EtWmEtel1bQS1aYS16MC05Ky0uXSp8Xyk6W15cXHNdKiQvO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gYWJzb2x1dGUgSVJJIG9yIGJsYW5rIG5vZGUgSVJJLCBmYWxzZVxuICogaWYgbm90LlxuICogTm90ZTogVGhpcyB3ZWFrIGNoZWNrIG9ubHkgY2hlY2tzIGZvciBhIGNvcnJlY3Qgc3RhcnRpbmcgc2NoZW1lLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIGFic29sdXRlIElSSSwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNBYnNvbHV0ZSA9IHYgPT4gdHlwZXMuaXNTdHJpbmcodikgJiYgaXNBYnNvbHV0ZVJlZ2V4LnRlc3Qodik7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHJlbGF0aXZlIElSSSwgZmFsc2UgaWYgbm90LlxuICogTm90ZTogdGhpcyBpcyBhIHdlYWsgY2hlY2suXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSByZWxhdGl2ZSBJUkksIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzUmVsYXRpdmUgPSB2ID0+IHR5cGVzLmlzU3RyaW5nKHYpO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDE5IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ3JhcGhUeXBlcyA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG4vLyBUT0RPOiBtb3ZlIGBJZGVudGlmaWVySXNzdWVyYCB0byBpdHMgb3duIHBhY2thZ2VcbmNvbnN0IElkZW50aWZpZXJJc3N1ZXIgPSByZXF1aXJlKCdyZGYtY2Fub25pemUnKS5JZGVudGlmaWVySXNzdWVyO1xuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5cbi8vIGNvbnN0YW50c1xuY29uc3QgUkVHRVhfTElOS19IRUFERVJTID0gLyg/OjxbXj5dKj8+fFwiW15cIl0qP1wifFteLF0pKy9nO1xuY29uc3QgUkVHRVhfTElOS19IRUFERVIgPSAvXFxzKjwoW14+XSo/KT5cXHMqKD86O1xccyooLiopKT8vO1xuY29uc3QgUkVHRVhfTElOS19IRUFERVJfUEFSQU1TID1cbiAgLyguKj8pPSg/Oig/OlwiKFteXCJdKj8pXCIpfChbXlwiXSo/KSlcXHMqKD86KD86O1xccyopfCQpL2c7XG5cbmNvbnN0IERFRkFVTFRTID0ge1xuICBoZWFkZXJzOiB7XG4gICAgYWNjZXB0OiAnYXBwbGljYXRpb24vbGQranNvbiwgYXBwbGljYXRpb24vanNvbidcbiAgfVxufTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcbmFwaS5JZGVudGlmaWVySXNzdWVyID0gSWRlbnRpZmllcklzc3VlcjtcblxuLyoqXG4gKiBDbG9uZXMgYW4gb2JqZWN0LCBhcnJheSwgTWFwLCBTZXQsIG9yIHN0cmluZy9udW1iZXIuIElmIGEgdHlwZWQgSmF2YVNjcmlwdFxuICogb2JqZWN0IGlzIGdpdmVuLCBzdWNoIGFzIGEgRGF0ZSwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmFwaS5jbG9uZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBsZXQgcnZhbDtcbiAgICBpZih0eXBlcy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcnZhbCA9IFtdO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJ2YWxbaV0gPSBhcGkuY2xvbmUodmFsdWVbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgcnZhbCA9IG5ldyBNYXAoKTtcbiAgICAgIGZvcihjb25zdCBbaywgdl0gb2YgdmFsdWUpIHtcbiAgICAgICAgcnZhbC5zZXQoaywgYXBpLmNsb25lKHYpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIHJ2YWwgPSBuZXcgU2V0KCk7XG4gICAgICBmb3IoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICBydmFsLmFkZChhcGkuY2xvbmUodikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlcy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJ2YWwgPSB7fTtcbiAgICAgIGZvcihjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgcnZhbFtrZXldID0gYXBpLmNsb25lKHZhbHVlW2tleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBydmFsID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgYSB2YWx1ZSBpcyBhbiBhcnJheS4gSWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5LCBpdCBpcyByZXR1cm5lZC5cbiAqIE90aGVyd2lzZSwgaXQgaXMgd3JhcHBlZCBpbiBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHJldHVybiBhcyBhbiBhcnJheS5cbiAqXG4gKiBAcmV0dXJuIHRoZSB2YWx1ZSBhcyBhbiBhcnJheS5cbiAqL1xuYXBpLmFzQXJyYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBIVFRQIGhlYWRlcnMgb2JqZWN0IGZvciBtYWtpbmcgYSBKU09OLUxEIHJlcXVlc3QgZnJvbSBjdXN0b21cbiAqIGhlYWRlcnMgYW5kIGFzc2VydHMgdGhlIGBhY2NlcHRgIGhlYWRlciBpc24ndCBvdmVycmlkZGVuLlxuICpcbiAqIEBwYXJhbSBoZWFkZXJzIGFuIG9iamVjdCBvZiBoZWFkZXJzIHdpdGgga2V5cyBhcyBoZWFkZXIgbmFtZXMgYW5kIHZhbHVlc1xuICogICAgICAgICAgYXMgaGVhZGVyIHZhbHVlcy5cbiAqXG4gKiBAcmV0dXJuIGFuIG9iamVjdCBvZiBoZWFkZXJzIHdpdGggYSB2YWxpZCBgYWNjZXB0YCBoZWFkZXIuXG4gKi9cbmFwaS5idWlsZEhlYWRlcnMgPSAoaGVhZGVycyA9IHt9KSA9PiB7XG4gIGNvbnN0IGhhc0FjY2VwdCA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLnNvbWUoXG4gICAgaCA9PiBoLnRvTG93ZXJDYXNlKCkgPT09ICdhY2NlcHQnKTtcblxuICBpZihoYXNBY2NlcHQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICdBY2NlcHQgaGVhZGVyIG1heSBub3QgYmUgc3BlY2lmaWVkOyBvbmx5IFwiJyArXG4gICAgICBERUZBVUxUUy5oZWFkZXJzLmFjY2VwdCArICdcIiBpcyBzdXBwb3J0ZWQuJyk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7QWNjZXB0OiBERUZBVUxUUy5oZWFkZXJzLmFjY2VwdH0sIGhlYWRlcnMpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBsaW5rIGhlYWRlci4gVGhlIHJlc3VsdHMgd2lsbCBiZSBrZXknZCBieSB0aGUgdmFsdWUgb2YgXCJyZWxcIi5cbiAqXG4gKiBMaW5rOiA8aHR0cDovL2pzb24tbGQub3JnL2NvbnRleHRzL3BlcnNvbi5qc29ubGQ+O1xuICogcmVsPVwiaHR0cDovL3d3dy53My5vcmcvbnMvanNvbi1sZCNjb250ZXh0XCI7IHR5cGU9XCJhcHBsaWNhdGlvbi9sZCtqc29uXCJcbiAqXG4gKiBQYXJzZXMgYXM6IHtcbiAqICAgJ2h0dHA6Ly93d3cudzMub3JnL25zL2pzb24tbGQjY29udGV4dCc6IHtcbiAqICAgICB0YXJnZXQ6IGh0dHA6Ly9qc29uLWxkLm9yZy9jb250ZXh0cy9wZXJzb24uanNvbmxkLFxuICogICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9sZCtqc29uJ1xuICogICB9XG4gKiB9XG4gKlxuICogSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBcInJlbFwiIHdpdGggdGhlIHNhbWUgSVJJLCB0aGVuIGVudHJpZXMgaW4gdGhlXG4gKiByZXN1bHRpbmcgbWFwIGZvciB0aGF0IFwicmVsXCIgd2lsbCBiZSBhcnJheXMuXG4gKlxuICogQHBhcmFtIGhlYWRlciB0aGUgbGluayBoZWFkZXIgdG8gcGFyc2UuXG4gKi9cbmFwaS5wYXJzZUxpbmtIZWFkZXIgPSBoZWFkZXIgPT4ge1xuICBjb25zdCBydmFsID0ge307XG4gIC8vIHNwbGl0IG9uIHVuYnJhY2tldGVkL3VucXVvdGVkIGNvbW1hc1xuICBjb25zdCBlbnRyaWVzID0gaGVhZGVyLm1hdGNoKFJFR0VYX0xJTktfSEVBREVSUyk7XG4gIGZvcihsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1hdGNoID0gZW50cmllc1tpXS5tYXRjaChSRUdFWF9MSU5LX0hFQURFUik7XG4gICAgaWYoIW1hdGNoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge3RhcmdldDogbWF0Y2hbMV19O1xuICAgIGNvbnN0IHBhcmFtcyA9IG1hdGNoWzJdO1xuICAgIHdoaWxlKChtYXRjaCA9IFJFR0VYX0xJTktfSEVBREVSX1BBUkFNUy5leGVjKHBhcmFtcykpKSB7XG4gICAgICByZXN1bHRbbWF0Y2hbMV1dID0gKG1hdGNoWzJdID09PSB1bmRlZmluZWQpID8gbWF0Y2hbM10gOiBtYXRjaFsyXTtcbiAgICB9XG4gICAgY29uc3QgcmVsID0gcmVzdWx0WydyZWwnXSB8fCAnJztcbiAgICBpZihBcnJheS5pc0FycmF5KHJ2YWxbcmVsXSkpIHtcbiAgICAgIHJ2YWxbcmVsXS5wdXNoKHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmKHJ2YWwuaGFzT3duUHJvcGVydHkocmVsKSkge1xuICAgICAgcnZhbFtyZWxdID0gW3J2YWxbcmVsXSwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnZhbFtyZWxdID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQgQHR5cGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICovXG5hcGkudmFsaWRhdGVUeXBlVmFsdWUgPSAodiwgaXNGcmFtZSkgPT4ge1xuICBpZih0eXBlcy5pc1N0cmluZyh2KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKHR5cGVzLmlzQXJyYXkodikgJiYgdi5ldmVyeSh2diA9PiB0eXBlcy5pc1N0cmluZyh2dikpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmKGlzRnJhbWUgJiYgdHlwZXMuaXNPYmplY3QodikpIHtcbiAgICBzd2l0Y2goT2JqZWN0LmtleXModikubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vIGVtcHR5IG9iamVjdCBpcyB3aWxkY2FyZFxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIGRlZmF1bHQgZW50cnkgaXMgYWxsIHN0cmluZ3NcbiAgICAgICAgaWYoJ0BkZWZhdWx0JyBpbiB2ICYmXG4gICAgICAgICAgYXBpLmFzQXJyYXkodlsnQGRlZmF1bHQnXSkuZXZlcnkodnYgPT4gdHlwZXMuaXNTdHJpbmcodnYpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAdHlwZVwiIHZhbHVlIG11c3QgYSBzdHJpbmcsIGFuIGFycmF5IG9mICcgK1xuICAgICdzdHJpbmdzLCBhbiBlbXB0eSBvYmplY3QsICcgK1xuICAgICdvciBhIGRlZmF1bHQgb2JqZWN0LicsICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgIHtjb2RlOiAnaW52YWxpZCB0eXBlIHZhbHVlJywgdmFsdWU6IHZ9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdWJqZWN0IGhhcyB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gY2hlY2suXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHByb3BlcnR5IHRvIGxvb2sgZm9yLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgc3ViamVjdCBoYXMgdGhlIGdpdmVuIHByb3BlcnR5LCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5oYXNQcm9wZXJ0eSA9IChzdWJqZWN0LCBwcm9wZXJ0eSkgPT4ge1xuICBpZihzdWJqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3ViamVjdFtwcm9wZXJ0eV07XG4gICAgcmV0dXJuICghdHlwZXMuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID4gMCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBzdWJqZWN0LlxuICpcbiAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIHByb3BlcnR5IHRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBleGlzdHMsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmhhc1ZhbHVlID0gKHN1YmplY3QsIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICBpZihhcGkuaGFzUHJvcGVydHkoc3ViamVjdCwgcHJvcGVydHkpKSB7XG4gICAgbGV0IHZhbCA9IHN1YmplY3RbcHJvcGVydHldO1xuICAgIGNvbnN0IGlzTGlzdCA9IGdyYXBoVHlwZXMuaXNMaXN0KHZhbCk7XG4gICAgaWYodHlwZXMuaXNBcnJheSh2YWwpIHx8IGlzTGlzdCkge1xuICAgICAgaWYoaXNMaXN0KSB7XG4gICAgICAgIHZhbCA9IHZhbFsnQGxpc3QnXTtcbiAgICAgIH1cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYoYXBpLmNvbXBhcmVWYWx1ZXModmFsdWUsIHZhbFtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZighdHlwZXMuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIGF2b2lkIG1hdGNoaW5nIHRoZSBzZXQgb2YgdmFsdWVzIHdpdGggYW4gYXJyYXkgdmFsdWUgcGFyYW1ldGVyXG4gICAgICByZXR1cm4gYXBpLmNvbXBhcmVWYWx1ZXModmFsdWUsIHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQWRkcyBhIHZhbHVlIHRvIGEgc3ViamVjdC4gSWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5LCBhbGwgdmFsdWVzIGluIHRoZVxuICogYXJyYXkgd2lsbCBiZSBhZGRlZC5cbiAqXG4gKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byBhZGQgdGhlIHZhbHVlIHRvLlxuICogQHBhcmFtIHByb3BlcnR5IHRoZSBwcm9wZXJ0eSB0aGF0IHJlbGF0ZXMgdGhlIHZhbHVlIHRvIHRoZSBzdWJqZWN0LlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICBbcHJvcGVydHlJc0FycmF5XSB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBpcyBhbHdheXMgYW4gYXJyYXksIGZhbHNlXG4gKiAgICAgICAgICBpZiBub3QgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICBbdmFsdWVJc0FycmF5XSB0cnVlIGlmIHRoZSB2YWx1ZSB0byBiZSBhZGRlZCBzaG91bGQgYmUgcHJlc2VydmVkIGFzXG4gKiAgICAgICAgICBhbiBhcnJheSAobGlzdHMpIChkZWZhdWx0OiBmYWxzZSkuXG4gKiAgICAgICAgW2FsbG93RHVwbGljYXRlXSB0cnVlIHRvIGFsbG93IGR1cGxpY2F0ZXMsIGZhbHNlIG5vdCB0byAodXNlcyBhXG4gKiAgICAgICAgICBzaW1wbGUgc2hhbGxvdyBjb21wYXJpc29uIG9mIHN1YmplY3QgSUQgb3IgdmFsdWUpIChkZWZhdWx0OiB0cnVlKS5cbiAqICAgICAgICBbcHJlcGVuZFZhbHVlXSBmYWxzZSB0byBwcmVwZW5kIHZhbHVlIHRvIGFueSBleGlzdGluZyB2YWx1ZXMuXG4gKiAgICAgICAgICAoZGVmYXVsdDogZmFsc2UpXG4gKi9cbmFwaS5hZGRWYWx1ZSA9IChzdWJqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCEoJ3Byb3BlcnR5SXNBcnJheScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnByb3BlcnR5SXNBcnJheSA9IGZhbHNlO1xuICB9XG4gIGlmKCEoJ3ZhbHVlSXNBcnJheScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnZhbHVlSXNBcnJheSA9IGZhbHNlO1xuICB9XG4gIGlmKCEoJ2FsbG93RHVwbGljYXRlJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuYWxsb3dEdXBsaWNhdGUgPSB0cnVlO1xuICB9XG4gIGlmKCEoJ3ByZXBlbmRWYWx1ZScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnByZXBlbmRWYWx1ZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYob3B0aW9ucy52YWx1ZUlzQXJyYXkpIHtcbiAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9IGVsc2UgaWYodHlwZXMuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZih2YWx1ZS5sZW5ndGggPT09IDAgJiYgb3B0aW9ucy5wcm9wZXJ0eUlzQXJyYXkgJiZcbiAgICAgICFzdWJqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgc3ViamVjdFtwcm9wZXJ0eV0gPSBbXTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy5wcmVwZW5kVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuY29uY2F0KHN1YmplY3RbcHJvcGVydHldKTtcbiAgICAgIHN1YmplY3RbcHJvcGVydHldID0gW107XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgYXBpLmFkZFZhbHVlKHN1YmplY3QsIHByb3BlcnR5LCB2YWx1ZVtpXSwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2UgaWYoc3ViamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAvLyBjaGVjayBpZiBzdWJqZWN0IGFscmVhZHkgaGFzIHZhbHVlIGlmIGR1cGxpY2F0ZXMgbm90IGFsbG93ZWRcbiAgICBjb25zdCBoYXNWYWx1ZSA9ICghb3B0aW9ucy5hbGxvd0R1cGxpY2F0ZSAmJlxuICAgICAgYXBpLmhhc1ZhbHVlKHN1YmplY3QsIHByb3BlcnR5LCB2YWx1ZSkpO1xuXG4gICAgLy8gbWFrZSBwcm9wZXJ0eSBhbiBhcnJheSBpZiB2YWx1ZSBub3QgcHJlc2VudCBvciBhbHdheXMgYW4gYXJyYXlcbiAgICBpZighdHlwZXMuaXNBcnJheShzdWJqZWN0W3Byb3BlcnR5XSkgJiZcbiAgICAgICghaGFzVmFsdWUgfHwgb3B0aW9ucy5wcm9wZXJ0eUlzQXJyYXkpKSB7XG4gICAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IFtzdWJqZWN0W3Byb3BlcnR5XV07XG4gICAgfVxuXG4gICAgLy8gYWRkIG5ldyB2YWx1ZVxuICAgIGlmKCFoYXNWYWx1ZSkge1xuICAgICAgaWYob3B0aW9ucy5wcmVwZW5kVmFsdWUpIHtcbiAgICAgICAgc3ViamVjdFtwcm9wZXJ0eV0udW5zaGlmdCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJqZWN0W3Byb3BlcnR5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gYWRkIG5ldyB2YWx1ZSBhcyBzZXQgb3Igc2luZ2xlIHZhbHVlXG4gICAgc3ViamVjdFtwcm9wZXJ0eV0gPSBvcHRpb25zLnByb3BlcnR5SXNBcnJheSA/IFt2YWx1ZV0gOiB2YWx1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIGFsbCBvZiB0aGUgdmFsdWVzIGZvciBhIHN1YmplY3QncyBwcm9wZXJ0eSBhcyBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdC5cbiAqIEBwYXJhbSBwcm9wZXJ0eSB0aGUgcHJvcGVydHkuXG4gKlxuICogQHJldHVybiBhbGwgb2YgdGhlIHZhbHVlcyBmb3IgYSBzdWJqZWN0J3MgcHJvcGVydHkgYXMgYW4gYXJyYXkuXG4gKi9cbmFwaS5nZXRWYWx1ZXMgPSAoc3ViamVjdCwgcHJvcGVydHkpID0+IFtdLmNvbmNhdChzdWJqZWN0W3Byb3BlcnR5XSB8fCBbXSk7XG5cbi8qKlxuICogUmVtb3ZlcyBhIHByb3BlcnR5IGZyb20gYSBzdWJqZWN0LlxuICpcbiAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0LlxuICogQHBhcmFtIHByb3BlcnR5IHRoZSBwcm9wZXJ0eS5cbiAqL1xuYXBpLnJlbW92ZVByb3BlcnR5ID0gKHN1YmplY3QsIHByb3BlcnR5KSA9PiB7XG4gIGRlbGV0ZSBzdWJqZWN0W3Byb3BlcnR5XTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gYSBzdWJqZWN0LlxuICpcbiAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0LlxuICogQHBhcmFtIHByb3BlcnR5IHRoZSBwcm9wZXJ0eSB0aGF0IHJlbGF0ZXMgdGhlIHZhbHVlIHRvIHRoZSBzdWJqZWN0LlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtwcm9wZXJ0eUlzQXJyYXldIHRydWUgaWYgdGhlIHByb3BlcnR5IGlzIGFsd2F5cyBhbiBhcnJheSwgZmFsc2VcbiAqICAgICAgICAgICAgaWYgbm90IChkZWZhdWx0OiBmYWxzZSkuXG4gKi9cbmFwaS5yZW1vdmVWYWx1ZSA9IChzdWJqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCEoJ3Byb3BlcnR5SXNBcnJheScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnByb3BlcnR5SXNBcnJheSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gZmlsdGVyIG91dCB2YWx1ZVxuICBjb25zdCB2YWx1ZXMgPSBhcGkuZ2V0VmFsdWVzKHN1YmplY3QsIHByb3BlcnR5KS5maWx0ZXIoXG4gICAgZSA9PiAhYXBpLmNvbXBhcmVWYWx1ZXMoZSwgdmFsdWUpKTtcblxuICBpZih2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgYXBpLnJlbW92ZVByb3BlcnR5KHN1YmplY3QsIHByb3BlcnR5KTtcbiAgfSBlbHNlIGlmKHZhbHVlcy5sZW5ndGggPT09IDEgJiYgIW9wdGlvbnMucHJvcGVydHlJc0FycmF5KSB7XG4gICAgc3ViamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZXNbMF07XG4gIH0gZWxzZSB7XG4gICAgc3ViamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZXM7XG4gIH1cbn07XG5cbi8qKlxuICogUmVsYWJlbHMgYWxsIGJsYW5rIG5vZGVzIGluIHRoZSBnaXZlbiBKU09OLUxEIGlucHV0LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgSlNPTi1MRCBpbnB1dC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2lzc3Vlcl0gYW4gSWRlbnRpZmllcklzc3VlciB0byB1c2UgdG8gbGFiZWwgYmxhbmsgbm9kZXMuXG4gKi9cbmFwaS5yZWxhYmVsQmxhbmtOb2RlcyA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgaXNzdWVyID0gb3B0aW9ucy5pc3N1ZXIgfHwgbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YicpO1xuICByZXR1cm4gX2xhYmVsQmxhbmtOb2Rlcyhpc3N1ZXIsIGlucHV0KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIEpTT04tTEQgdmFsdWVzIGZvciBlcXVhbGl0eS4gVHdvIEpTT04tTEQgdmFsdWVzIHdpbGwgYmVcbiAqIGNvbnNpZGVyZWQgZXF1YWwgaWY6XG4gKlxuICogMS4gVGhleSBhcmUgYm90aCBwcmltaXRpdmVzIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHZhbHVlLlxuICogMi4gVGhleSBhcmUgYm90aCBAdmFsdWVzIHdpdGggdGhlIHNhbWUgQHZhbHVlLCBAdHlwZSwgQGxhbmd1YWdlLFxuICogICBhbmQgQGluZGV4LCBPUlxuICogMy4gVGhleSBib3RoIGhhdmUgQGlkcyB0aGV5IGFyZSB0aGUgc2FtZS5cbiAqXG4gKiBAcGFyYW0gdjEgdGhlIGZpcnN0IHZhbHVlLlxuICogQHBhcmFtIHYyIHRoZSBzZWNvbmQgdmFsdWUuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHYxIGFuZCB2MiBhcmUgY29uc2lkZXJlZCBlcXVhbCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuY29tcGFyZVZhbHVlcyA9ICh2MSwgdjIpID0+IHtcbiAgLy8gMS4gZXF1YWwgcHJpbWl0aXZlc1xuICBpZih2MSA9PT0gdjIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIDIuIGVxdWFsIEB2YWx1ZXNcbiAgaWYoZ3JhcGhUeXBlcy5pc1ZhbHVlKHYxKSAmJiBncmFwaFR5cGVzLmlzVmFsdWUodjIpICYmXG4gICAgdjFbJ0B2YWx1ZSddID09PSB2MlsnQHZhbHVlJ10gJiZcbiAgICB2MVsnQHR5cGUnXSA9PT0gdjJbJ0B0eXBlJ10gJiZcbiAgICB2MVsnQGxhbmd1YWdlJ10gPT09IHYyWydAbGFuZ3VhZ2UnXSAmJlxuICAgIHYxWydAaW5kZXgnXSA9PT0gdjJbJ0BpbmRleCddKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAzLiBlcXVhbCBAaWRzXG4gIGlmKHR5cGVzLmlzT2JqZWN0KHYxKSAmJlxuICAgICgnQGlkJyBpbiB2MSkgJiZcbiAgICB0eXBlcy5pc09iamVjdCh2MikgJiZcbiAgICAoJ0BpZCcgaW4gdjIpKSB7XG4gICAgcmV0dXJuIHYxWydAaWQnXSA9PT0gdjJbJ0BpZCddO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gc3RyaW5ncyBmaXJzdCBiYXNlZCBvbiBsZW5ndGggYW5kIHRoZW4gbGV4aWNvZ3JhcGhpY2FsbHkuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gLTEgaWYgYSA8IGIsIDEgaWYgYSA+IGIsIDAgaWYgYSA9PT0gYi5cbiAqL1xuYXBpLmNvbXBhcmVTaG9ydGVzdExlYXN0ID0gKGEsIGIpID0+IHtcbiAgaWYoYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZihiLmxlbmd0aCA8IGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiAoYSA8IGIpID8gLTEgOiAxO1xufTtcblxuLyoqXG4gKiBMYWJlbHMgdGhlIGJsYW5rIG5vZGVzIGluIHRoZSBnaXZlbiB2YWx1ZSB1c2luZyB0aGUgZ2l2ZW4gSWRlbnRpZmllcklzc3Vlci5cbiAqXG4gKiBAcGFyYW0gaXNzdWVyIHRoZSBJZGVudGlmaWVySXNzdWVyIHRvIHVzZS5cbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHdpdGggYmxhbmsgbm9kZXMgdG8gcmVuYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIF9sYWJlbEJsYW5rTm9kZXMoaXNzdWVyLCBlbGVtZW50KSB7XG4gIGlmKHR5cGVzLmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5sZW5ndGg7ICsraSkge1xuICAgICAgZWxlbWVudFtpXSA9IF9sYWJlbEJsYW5rTm9kZXMoaXNzdWVyLCBlbGVtZW50W2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZihncmFwaFR5cGVzLmlzTGlzdChlbGVtZW50KSkge1xuICAgIGVsZW1lbnRbJ0BsaXN0J10gPSBfbGFiZWxCbGFua05vZGVzKGlzc3VlciwgZWxlbWVudFsnQGxpc3QnXSk7XG4gIH0gZWxzZSBpZih0eXBlcy5pc09iamVjdChlbGVtZW50KSkge1xuICAgIC8vIHJlbGFiZWwgYmxhbmsgbm9kZVxuICAgIGlmKGdyYXBoVHlwZXMuaXNCbGFua05vZGUoZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnRbJ0BpZCddID0gaXNzdWVyLmdldElkKGVsZW1lbnRbJ0BpZCddKTtcbiAgICB9XG5cbiAgICAvLyByZWN1cnNpdmVseSBhcHBseSB0byBhbGwga2V5c1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50KS5zb3J0KCk7XG4gICAgZm9yKGxldCBraSA9IDA7IGtpIDwga2V5cy5sZW5ndGg7ICsra2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNba2ldO1xuICAgICAgaWYoa2V5ICE9PSAnQGlkJykge1xuICAgICAgICBlbGVtZW50W2tleV0gPSBfbGFiZWxCbGFua05vZGVzKGlzc3VlciwgZWxlbWVudFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5cbmNvbnN0IE1BWCA9IFN5bWJvbCgnbWF4JylcbmNvbnN0IExFTkdUSCA9IFN5bWJvbCgnbGVuZ3RoJylcbmNvbnN0IExFTkdUSF9DQUxDVUxBVE9SID0gU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJylcbmNvbnN0IEFMTE9XX1NUQUxFID0gU3ltYm9sKCdhbGxvd1N0YWxlJylcbmNvbnN0IE1BWF9BR0UgPSBTeW1ib2woJ21heEFnZScpXG5jb25zdCBESVNQT1NFID0gU3ltYm9sKCdkaXNwb3NlJylcbmNvbnN0IE5PX0RJU1BPU0VfT05fU0VUID0gU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpXG5jb25zdCBMUlVfTElTVCA9IFN5bWJvbCgnbHJ1TGlzdCcpXG5jb25zdCBDQUNIRSA9IFN5bWJvbCgnY2FjaGUnKVxuY29uc3QgVVBEQVRFX0FHRV9PTl9HRVQgPSBTeW1ib2woJ3VwZGF0ZUFnZU9uR2V0JylcblxuY29uc3QgbmFpdmVMZW5ndGggPSAoKSA9PiAxXG5cbi8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuXG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgb3B0aW9ucyA9IHt9XG5cbiAgICBpZiAob3B0aW9ucy5tYXggJiYgKHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXggPCAwKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG4gICAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICAgIGNvbnN0IG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4IHx8IEluZmluaXR5XG5cbiAgICBjb25zdCBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSA/IG5haXZlTGVuZ3RoIDogbGNcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcbiAgICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMFxuICAgIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2VcbiAgICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgICB0aGlzW1VQREFURV9BR0VfT05fR0VUXSA9IG9wdGlvbnMudXBkYXRlQWdlT25HZXQgfHwgZmFsc2VcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG4gIHNldCBtYXggKG1MKSB7XG4gICAgaWYgKHR5cGVvZiBtTCAhPT0gJ251bWJlcicgfHwgbUwgPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXggKCkge1xuICAgIHJldHVybiB0aGlzW01BWF1cbiAgfVxuXG4gIHNldCBhbGxvd1N0YWxlIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfVxuICBnZXQgYWxsb3dTdGFsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH1cblxuICBzZXQgbWF4QWdlIChtQSkge1xuICAgIGlmICh0eXBlb2YgbUEgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4QWdlICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhfQUdFXVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG4gIHNldCBsZW5ndGhDYWxjdWxhdG9yIChsQykge1xuICAgIGlmICh0eXBlb2YgbEMgIT09ICdmdW5jdGlvbicpXG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG5cbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwXG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB7XG4gICAgICAgIGhpdC5sZW5ndGggPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpXG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgICB9KVxuICAgIH1cbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IGxlbmd0aENhbGN1bGF0b3IgKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gfVxuXG4gIGdldCBsZW5ndGggKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH1cbiAgZ2V0IGl0ZW1Db3VudCAoKSB7IHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGggfVxuXG4gIHJmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IG5leHQgPSB3YWxrZXIubmV4dFxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBuZXh0XG4gICAgfVxuICB9XG5cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLmtleSlcbiAgfVxuXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLnZhbHVlKVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICh0aGlzW0RJU1BPU0VdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4gdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpKVxuICAgIH1cblxuICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gICAgdGhpc1tMUlVfTElTVF0gPSBuZXcgWWFsbGlzdCgpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgICB0aGlzW0xFTkdUSF0gPSAwIC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICB9XG5cbiAgZHVtcCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLm1hcChoaXQgPT5cbiAgICAgIGlzU3RhbGUodGhpcywgaGl0KSA/IGZhbHNlIDoge1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfSkudG9BcnJheSgpLmZpbHRlcihoID0+IGgpXG4gIH1cblxuICBkdW1wTHJ1ICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF1cbiAgfVxuXG4gIHNldCAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gICAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICAgIGlmIChtYXhBZ2UgJiYgdHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG5cbiAgICBjb25zdCBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICAgIGNvbnN0IGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpXG4gICAgICBjb25zdCBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSlcbiAgICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgaXRlbS5ub3cgPSBub3dcbiAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlXG4gICAgICBpdGVtLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgICAgaXRlbS5sZW5ndGggPSBsZW5cbiAgICAgIHRoaXMuZ2V0KGtleSlcbiAgICAgIHRyaW0odGhpcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICAgIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgICBpZiAodGhpc1tESVNQT1NFXSlcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KVxuICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpXG4gICAgdHJpbSh0aGlzKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBoYXMgKGtleSkge1xuICAgIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdClcbiAgfVxuXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG4gIH1cblxuICBwZWVrIChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG4gIH1cblxuICBwb3AgKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGRlbCh0aGlzLCBub2RlKVxuICAgIHJldHVybiBub2RlLnZhbHVlXG4gIH1cblxuICBkZWwgKGtleSkge1xuICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgfVxuXG4gIGxvYWQgKGFycikge1xuICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgIHRoaXMucmVzZXQoKVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gICAgZm9yIChsZXQgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgY29uc3QgaGl0ID0gYXJyW2xdXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgICBpZiAoZXhwaXJlc0F0ID09PSAwKVxuICAgICAgICAvLyB0aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJ1bmUgKCkge1xuICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IGdldCh0aGlzLCBrZXksIGZhbHNlKSlcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoc2VsZiwga2V5LCBkb1VzZSkgPT4ge1xuICBjb25zdCBub2RlID0gc2VsZltDQUNIRV0uZ2V0KGtleSlcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkge1xuICAgICAgICBpZiAoc2VsZltVUERBVEVfQUdFX09OX0dFVF0pXG4gICAgICAgICAgbm9kZS52YWx1ZS5ub3cgPSBEYXRlLm5vdygpXG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaXQudmFsdWVcbiAgfVxufVxuXG5jb25zdCBpc1N0YWxlID0gKHNlbGYsIGhpdCkgPT4ge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICByZXR1cm4gaGl0Lm1heEFnZSA/IGRpZmYgPiBoaXQubWF4QWdlXG4gICAgOiBzZWxmW01BWF9BR0VdICYmIChkaWZmID4gc2VsZltNQVhfQUdFXSlcbn1cblxuY29uc3QgdHJpbSA9IHNlbGYgPT4ge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDtcbiAgICAgIHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZGVsKHNlbGYsIHdhbGtlcilcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZGVsID0gKHNlbGYsIG5vZGUpID0+IHtcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKHNlbGZbRElTUE9TRV0pXG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcblxuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpXG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKVxuICB9XG59XG5cbmNsYXNzIEVudHJ5IHtcbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhpcy5ub3cgPSBub3dcbiAgICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwXG4gIH1cbn1cblxuY29uc3QgZm9yRWFjaFN0ZXAgPSAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSA9PiB7XG4gIGxldCBoaXQgPSBub2RlLnZhbHVlXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgaGl0ID0gdW5kZWZpbmVkXG4gIH1cbiAgaWYgKGhpdClcbiAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHNlbGYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL3Byb3BlcnR5aGFuZGxlci9JSXRlbVByb3BlcnR5SGFuZGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyQ29udGVudFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvcHJvcGVydHloYW5kbGVyL0l0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9JSHRtbFBhcnNlTGlzdGVuZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9JSXRlbVNjb3BlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvSVZvY2FiUmVnaXN0cnlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9NaWNyb2RhdGFSZGZQYXJzZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9VdGlsXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUh0bWxQYXJzZUxpc3RlbmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUl0ZW1TY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlWb2NhYlJlZ2lzdHJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaWNyb2RhdGFSZGZQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBodG1scGFyc2VyMl8xID0gcmVxdWlyZShcImh0bWxwYXJzZXIyXCIpO1xuY29uc3QgSXRlbVByb3BlcnR5SGFuZGxlckNvbnRlbnRfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyQ29udGVudFwiKTtcbmNvbnN0IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJOdW1iZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyXCIpO1xuY29uc3QgSXRlbVByb3BlcnR5SGFuZGxlclRpbWVfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyVGltZVwiKTtcbmNvbnN0IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5aGFuZGxlci9JdGVtUHJvcGVydHlIYW5kbGVyVXJsXCIpO1xuY29uc3QgVXRpbF8xID0gcmVxdWlyZShcIi4vVXRpbFwiKTtcbmNvbnN0IFZPQ0FCX1JFR0lTVFJZX0RFRkFVTFQgPSByZXF1aXJlKFwiLi92b2NhYi1yZWdpc3RyeS1kZWZhdWx0Lmpzb25cIik7XG4vKipcbiAqIEEgc3RyZWFtIHRyYW5zZm9ybWVyIHRoYXQgcGFyc2VzIE1pY3JvZGF0YSAodGV4dCkgc3RyZWFtcyB0byBhbiB7QGxpbmsgUkRGLlN0cmVhbX0uXG4gKi9cbmNsYXNzIE1pY3JvZGF0YVJkZlBhcnNlciBleHRlbmRzIHN0cmVhbV8xLlRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcih7IHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgLy8gU3RhY2tzLCB3aGVyZSB0aGUga2V5IGlzIHRoZSBjdXJyZW50IGRlcHRoLlxuICAgICAgICB0aGlzLml0ZW1TY29wZVN0YWNrID0gW107XG4gICAgICAgIHRoaXMudGV4dEJ1ZmZlclN0YWNrID0gW107XG4gICAgICAgIC8vIFZhcmlhYmxlcyBmb3IgbWFuYWdpbmcgaXRlbXJlZnMuXG4gICAgICAgIHRoaXMuaXNFbWl0dGluZ1JlZmVyZW5jZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSXRlbVJlZnNEb21haW4gPSB7fTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSXRlbVJlZnNSYW5nZUZpbmFsaXplZCA9IHt9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbGluZXMtYmV0d2Vlbi1jbGFzcy1tZW1iZXJzXG4gICAgICAgIHRoaXMucGVuZGluZ0l0ZW1SZWZzUmFuZ2VDb2xsZWN0aW5nID0ge307XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnV0aWwgPSBuZXcgVXRpbF8xLlV0aWwob3B0aW9ucy5kYXRhRmFjdG9yeSwgb3B0aW9ucy5iYXNlSVJJKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0R3JhcGggPSBvcHRpb25zLmRlZmF1bHRHcmFwaCB8fCB0aGlzLnV0aWwuZGF0YUZhY3RvcnkuZGVmYXVsdEdyYXBoKCk7XG4gICAgICAgIHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIgPSBvcHRpb25zLmh0bWxQYXJzZUxpc3RlbmVyO1xuICAgICAgICB0aGlzLnZvY2FiUmVnaXN0cnkgPSBvcHRpb25zLnZvY2FiUmVnaXN0cnkgfHwgVk9DQUJfUkVHSVNUUllfREVGQVVMVDtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSB0aGlzLmluaXRpYWxpemVQYXJzZXIoISFvcHRpb25zLnhtbE1vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgc3RyZWFtIGludG8gYSBxdWFkIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge05vZGVKUy5FdmVudEVtaXR0ZXJ9IHN0cmVhbSBBIHRleHQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1JERi5TdHJlYW19IEEgcXVhZCBzdHJlYW0uXG4gICAgICovXG4gICAgaW1wb3J0KHN0cmVhbSkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgc3RyZWFtXzEuUGFzc1Rocm91Z2goeyByZWFkYWJsZU9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCAoZXJyb3IpID0+IHBhcnNlZC5lbWl0KCdlcnJvcicsIGVycm9yKSk7XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIChkYXRhKSA9PiBvdXRwdXQucHVzaChkYXRhKSk7XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4gb3V0cHV0LnB1c2gobnVsbCkpO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBvdXRwdXQucGlwZShuZXcgTWljcm9kYXRhUmRmUGFyc2VyKHRoaXMub3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5wYXJzZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5wYXJzZXIuZW5kKCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBpdGVtIHNjb3BlIGZvciB0aGUgY3VycmVudCBkZXB0aC5cbiAgICAgKiBUaGlzIHdpbGwgc2tpcCBhbGwgdW5kZWZpbmVkIGl0ZW0gc2NvcGVzLlxuICAgICAqIEBwYXJhbSBwYXJlbnQgSWYgd2Ugc2hvdWxkIHN0YXJ0IGxvb2tpbmcgb25lIGxldmVsIGhpZ2hlciBpbiB0aGUgc3RhY2suXG4gICAgICovXG4gICAgZ2V0SXRlbVNjb3BlKHBhcmVudCkge1xuICAgICAgICBsZXQgcGFyZW50VGFnSSA9IHRoaXMuaXRlbVNjb3BlU3RhY2subGVuZ3RoIC0gKHBhcmVudCA/IDIgOiAxKTtcbiAgICAgICAgd2hpbGUgKHBhcmVudFRhZ0kgPiAwICYmICF0aGlzLml0ZW1TY29wZVN0YWNrW3BhcmVudFRhZ0ldKSB7XG4gICAgICAgICAgICBwYXJlbnRUYWdJLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbVNjb3BlU3RhY2tbcGFyZW50VGFnSV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzdGFjayBkZXB0aC5cbiAgICAgKi9cbiAgICBnZXREZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbVNjb3BlU3RhY2subGVuZ3RoO1xuICAgIH1cbiAgICBvblRhZ09wZW4obmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbWl0dGluZ1JlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0YWcgaGFzIGFuICdpZCcsIHN0YXJ0IGNvbGxlY3RpbmcgdGhlIHdob2xlIHN0YWNrIGluIHRoZSBpdGVtIHJlZmVyZW5jZSBidWZmZXJcbiAgICAgICAgICAgIGlmICgnaWQnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGF0dHJpYnV0ZXMuaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSXRlbVJlZnNSYW5nZUNvbGxlY3RpbmdbaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyOiAwLFxuICAgICAgICAgICAgICAgICAgICBpZHM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9yZSB0aGlzIGV2ZW50IGluIGFsbCBjb2xsZWN0aW5nIGl0ZW0gcmVmZXJlbmNlIGJ1ZmZlcnNcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIE9iamVjdC52YWx1ZXModGhpcy5wZW5kaW5nSXRlbVJlZnNSYW5nZUNvbGxlY3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICBidWZmZXIuZXZlbnRzLnB1c2goeyB0eXBlOiAnb3BlbicsIG5hbWUsIGF0dHJpYnV0ZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoZSB0ZXh0IGJ1ZmZlciBzdGFjayBpcyBpbiBsaW5lIHdpdGggdGhlIHN0YWNrIGRlcHRoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLXVzZWxlc3MtdW5kZWZpbmVkXG4gICAgICAgIHRoaXMudGV4dEJ1ZmZlclN0YWNrLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgLy8gUHJvY2Vzc2luZyBzdGVwcyBiYXNlZCBvbiBodHRwczovL3czYy5naXRodWIuaW8vbWljcm9kYXRhLXJkZi8jcmRmLWNvbnZlcnNpb24tYWxnb3JpdGhtXG4gICAgICAgIC8vIDEuIERldGVybWluZSB0aGUgY3VycmVudCBpdGVtIHNjb3BlXG4gICAgICAgIGxldCBpdGVtU2NvcGU7XG4gICAgICAgIGlmICgnaXRlbXNjb3BlJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgaXRlbSBzY29wZVxuICAgICAgICAgICAgbGV0IHN1YmplY3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5lbWl0dGluZ1JlZmVyZW5jZXNJdGVtU2NvcGVJZEdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIHN1YmplY3QgPSB0aGlzLmVtaXR0aW5nUmVmZXJlbmNlc0l0ZW1TY29wZUlkR2VuZXJhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0ID0gJ2l0ZW1pZCcgaW4gYXR0cmlidXRlcyAmJiB0aGlzLnV0aWwuY3JlYXRlU3ViamVjdChhdHRyaWJ1dGVzLml0ZW1pZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51dGlsLmRhdGFGYWN0b3J5LmJsYW5rTm9kZSgpO1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBnZW5lcmVyYXRlZCBpZCBpbiBhbGwgY29sbGVjdGluZyBpdGVtIHJlZmVyZW5jZSBidWZmZXJzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnBlbmRpbmdJdGVtUmVmc1JhbmdlQ29sbGVjdGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmlkcy5wdXNoKHN1YmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1TY29wZSA9IHsgc3ViamVjdCB9O1xuICAgICAgICAgICAgLy8gSWYgdGhlIGlkIHdhcyByZXVzZWQgZnJvbSBhIHJlZmVyZW5jZSwgYmxvY2sgYW55IG5ldyB0cmlwbGVzIHRvIGJlIGdlbmVyYXRlZCBmcm9tIGl0XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VtaXR0aW5nUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgIGl0ZW1TY29wZS5ibG9ja0VtaXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluaGVyaXQgdm9jYWIgZnJvbSBwYXJlbnQgaXRlbSBzY29wZVxuICAgICAgICAgICAgY29uc3QgcGFyZW50SXRlbVNjb3BlID0gdGhpcy5nZXRJdGVtU2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRJdGVtU2NvcGUgJiYgcGFyZW50SXRlbVNjb3BlLnZvY2FiKSB7XG4gICAgICAgICAgICAgICAgaXRlbVNjb3BlLnZvY2FiID0gcGFyZW50SXRlbVNjb3BlLnZvY2FiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMi4gUHVzaCBhbnkgY2hhbmdlcyB0byB0aGUgaXRlbSBzY29wZSB0byB0aGUgc3RhY2tcbiAgICAgICAgICAgIHRoaXMuaXRlbVNjb3BlU3RhY2sucHVzaChpdGVtU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwYXJlbnQgaXRlbSBzY29wZVxuICAgICAgICAgICAgaXRlbVNjb3BlID0gdGhpcy5nZXRJdGVtU2NvcGUoKTtcbiAgICAgICAgICAgIC8vIDIuIFB1c2ggYW55IGNoYW5nZXMgdG8gdGhlIGl0ZW0gc2NvcGUgdG8gdGhlIHN0YWNrXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby11c2VsZXNzLXVuZGVmaW5lZFxuICAgICAgICAgICAgdGhpcy5pdGVtU2NvcGVTdGFjay5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHZhbGlkIGl0ZW0gc2NvcGUsIHByb2Nlc3MgdGhlIGN1cnJlbnQgbm9kZVxuICAgICAgICBpZiAoaXRlbVNjb3BlKSB7XG4gICAgICAgICAgICAvLyAzLiBIYW5kbGUgaXRlbSB0eXBlc1xuICAgICAgICAgICAgaWYgKCdpdGVtdHlwZScgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMuaXRlbXR5cGUsIGl0ZW1TY29wZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDQuIFZvY2FiIGlkZW50aWZpZXIgaXMgdGhlIGZpcnN0IHZhbGlkIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtU2NvcGUudm9jYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUuIE1vZGlmeSB2b2NhYiBiYXNlZCBvbiByZWdpc3RyeVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVNjb3BlLnZvY2FiID0gdGhpcy51dGlsLmRlcml2ZVZvY2FiKHR5cGUudmFsdWUsIHRoaXMudm9jYWJSZWdpc3RyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCBpdGVtIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtU2NvcGUuYmxvY2tFbWlzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKGl0ZW1TY29wZS5zdWJqZWN0LCB0aGlzLnV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKGAke1V0aWxfMS5VdGlsLlJERn10eXBlYCksIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2F2ZSBsYW5ndWFnZSBpbiBpdGVtIHNjb3BlXG4gICAgICAgICAgICBpZiAoJ2xhbmcnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpdGVtU2NvcGUubGFuZ3VhZ2UgPSBhdHRyaWJ1dGVzLmxhbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3htbDpsYW5nJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaXRlbVNjb3BlLmxhbmd1YWdlID0gYXR0cmlidXRlc1sneG1sOmxhbmcnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBpdGVtcmVmcyAob25seSBpZiB3ZSBhbHNvIGhhZCBhbiBpdGVtc2NvcGUpXG4gICAgICAgICAgICBpZiAoJ2l0ZW1zY29wZScgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaXRlbXJlZiwgc3RvcmUgaXQgaW4gb3VyIGRvbWFpbiBidWZmZXIuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRW1pdHRpbmdSZWZlcmVuY2VzICYmICdpdGVtcmVmJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVmZXJlbmNlIG9mIGF0dHJpYnV0ZXMuaXRlbXJlZi5zcGxpdCgvXFxzKy91KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVmZXJlbmNlIGluIHRoaXMucGVuZGluZ0l0ZW1SZWZzRG9tYWluKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0l0ZW1SZWZzRG9tYWluW3JlZmVyZW5jZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0l0ZW1SZWZzRG9tYWluW3JlZmVyZW5jZV0ucHVzaChpdGVtU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlUb0VtaXRSZWZlcmVuY2VzKHJlZmVyZW5jZSwgaXRlbVNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA2LiBIYW5kbGUgaXRlbSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICgnaXRlbXByb3AnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSXRlbVByb3BlcnRpZXMoYXR0cmlidXRlcy5pdGVtcHJvcCwgZmFsc2UsIGl0ZW1TY29wZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHJldmVyc2UgaXRlbSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9taWNyb2RhdGEtcmRmLyNyZXZlcnNlLWl0ZW1wcm9wXG4gICAgICAgIGlmICgnaXRlbXByb3AtcmV2ZXJzZScgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVJdGVtUHJvcGVydGllcyhhdHRyaWJ1dGVzWydpdGVtcHJvcC1yZXZlcnNlJ10sIHRydWUsIGl0ZW1TY29wZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25UZXh0KGRhdGEpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhpcyBldmVudCBpbiBhbGwgY29sbGVjdGluZyBpdGVtIHJlZmVyZW5jZSBidWZmZXJzXG4gICAgICAgIGlmICghdGhpcy5pc0VtaXR0aW5nUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnBlbmRpbmdJdGVtUmVmc1JhbmdlQ29sbGVjdGluZykpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuZXZlbnRzLnB1c2goeyB0eXBlOiAndGV4dCcsIGRhdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2F2ZSB0aGUgdGV4dCBpbnNpZGUgYWxsIGl0ZW0gc2NvcGVzIHRoYXQgbmVlZCB0byBjb2xsZWN0IHRleHRcbiAgICAgICAgZm9yIChjb25zdCB0ZXh0QnVmZmVyIG9mIHRoaXMudGV4dEJ1ZmZlclN0YWNrKSB7XG4gICAgICAgICAgICBpZiAodGV4dEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRleHRCdWZmZXIucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvblRhZ0Nsb3NlKCkge1xuICAgICAgICAvLyBTdG9yZSB0aGlzIGV2ZW50IGluIGFsbCBjb2xsZWN0aW5nIGl0ZW0gcmVmZXJlbmNlIGJ1ZmZlcnNcbiAgICAgICAgaWYgKCF0aGlzLmlzRW1pdHRpbmdSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtyZWZlcmVuY2UsIGJ1ZmZlcl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5wZW5kaW5nSXRlbVJlZnNSYW5nZUNvbGxlY3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmNvdW50ZXItLTtcbiAgICAgICAgICAgICAgICBidWZmZXIuZXZlbnRzLnB1c2goeyB0eXBlOiAnY2xvc2UnIH0pO1xuICAgICAgICAgICAgICAgIC8vIE9uY2UgdGhlIGNvdW50ZXIgYmVjb21lcyB6ZXJvLCB0aGUgdGFnIGlzIGZ1bGx5IGJ1ZmZlcmVkLCBzbyB3ZSBmaW5hbGl6ZSBpdC5cbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmNvdW50ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSXRlbVJlZnNSYW5nZUZpbmFsaXplZFtyZWZlcmVuY2VdID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nSXRlbVJlZnNSYW5nZUNvbGxlY3RpbmdbcmVmZXJlbmNlXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGVtaXQgdGhpcyByZWZlcmVuY2Ugd2l0aCBidWZmZXJlZCBkb21haW4gaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlUb0VtaXRSZWZlcmVuY2VzKHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVtaXQgYWxsIHRyaXBsZXMgdGhhdCB3ZXJlIGRldGVybWluZWQgaW4gdGhlIGFjdGl2ZSB0YWdcbiAgICAgICAgY29uc3QgaXRlbVNjb3BlID0gdGhpcy5nZXRJdGVtU2NvcGUodHJ1ZSk7XG4gICAgICAgIGlmIChpdGVtU2NvcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gdGhpcy5nZXREZXB0aCgpO1xuICAgICAgICAgICAgaWYgKGl0ZW1TY29wZS5wcmVkaWNhdGVzICYmIGRlcHRoIGluIGl0ZW1TY29wZS5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbcHJlZGljYXRlS2V5LCBwcmVkaWNhdGVzXSBvZiBPYmplY3QuZW50cmllcyhpdGVtU2NvcGUucHJlZGljYXRlc1tkZXB0aF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHdlIGhhdmUgYSBjaGlsZCBpdGVtIHNjb3BlLCBvdGhlcndpc2UgZ2V0IHRoZSB0ZXh0IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmZWx5IGNhc3QgdGV4dEJ1ZmZlclN0YWNrLCBhcyBpdCBpcyBhbHdheXMgZGVmaW5lZCB3aGVuIGl0ZW1TY29wZS5wcmVkaWNhdGVzIGlzIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMudXRpbC5jcmVhdGVMaXRlcmFsKHRoaXMudGV4dEJ1ZmZlclN0YWNrW2RlcHRoXS5qb2luKCcnKSwgaXRlbVNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UHJlZGljYXRlVHJpcGxlcyhpdGVtU2NvcGUsIHByZWRpY2F0ZXMsIG9iamVjdCwgcHJlZGljYXRlS2V5ID09PSAncmV2ZXJzZScpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbVNjb3BlLnByZWRpY2F0ZXNbZGVwdGhdW3ByZWRpY2F0ZUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYWN0aXZlIHRhZyBmcm9tIHRoZSBzdGFja1xuICAgICAgICB0aGlzLml0ZW1TY29wZVN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnRleHRCdWZmZXJTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgb25FbmQoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgaW1wb3J0YW50IHNob3VsZCBoYXBwZW4gaGVyZS5cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBIdG1sUGFyc2VyLlxuICAgICAqIEBwYXJhbSB4bWxNb2RlIElmIHRoZSBwYXJzZXIgc2hvdWxkIGJlIHNldHVwIGluIHN0cmljdCBtb2RlLlxuICAgICAqL1xuICAgIGluaXRpYWxpemVQYXJzZXIoeG1sTW9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IGh0bWxwYXJzZXIyXzEuUGFyc2VyKHtcbiAgICAgICAgICAgIG9uY2xvc2V0YWc6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGFnQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIub25UYWdDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmVuZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIub25FbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25vcGVudGFnOiAobmFtZSwgYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UYWdPcGVuKG5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5odG1sUGFyc2VMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odG1sUGFyc2VMaXN0ZW5lci5vblRhZ09wZW4obmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9udGV4dDogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGV4dChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIub25UZXh0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGRlY29kZUVudGl0aWVzOiB0cnVlLFxuICAgICAgICAgICAgcmVjb2duaXplU2VsZkNsb3Npbmc6IHRydWUsXG4gICAgICAgICAgICB4bWxNb2RlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBnaXZlbiBpdGVtIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIGl0ZW1wcm9wVmFsdWUgVGhlIHZhbHVlIG9mIGl0ZW1wcm9wIG9yIGl0ZW1wcm9wLXJldmVyc2UuXG4gICAgICogQHBhcmFtIHJldmVyc2UgSWYgdGhlIGl0ZW0gcHJvcGVydGllcyBhcmUgcmV2ZXJzZWQgKGl0ZW1wcm9wLXJldmVyc2UpLlxuICAgICAqIEBwYXJhbSBpdGVtU2NvcGUgVGhlIGN1cnJlbnQgaXRlbSBzY29wZS5cbiAgICAgKiBAcGFyYW0gdGFnTmFtZSBUaGUgY3VycmVudCB0YWcgbmFtZS5cbiAgICAgKiBAcGFyYW0gdGFnQXR0cmlidXRlcyBUaGUgY3VycmVudCB0YWcgYXR0cmlidXRlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVJdGVtUHJvcGVydGllcyhpdGVtcHJvcFZhbHVlLCByZXZlcnNlLCBpdGVtU2NvcGUsIHRhZ05hbWUsIHRhZ0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50SXRlbVNjb3BlID0gdGhpcy5nZXRJdGVtU2NvcGUodHJ1ZSk7XG4gICAgICAgIGlmIChwYXJlbnRJdGVtU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFNldCBwcmVkaWNhdGVzIGluIHRoZSBzY29wZSwgYW5kIGhhbmRsZSB0aGVtIG9uIHRhZyBjbG9zZS5cbiAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gdGhpcy5nZXREZXB0aCgpO1xuICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlcyA9IHRoaXMudXRpbC5jcmVhdGVWb2NhYklyaXMoaXRlbXByb3BWYWx1ZSwgcGFyZW50SXRlbVNjb3BlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghcGFyZW50SXRlbVNjb3BlLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJdGVtU2NvcGUucHJlZGljYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJlbnRJdGVtU2NvcGUucHJlZGljYXRlc1tkZXB0aF0pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJdGVtU2NvcGUucHJlZGljYXRlc1tkZXB0aF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZWRpY2F0ZXNLZXkgPSByZXZlcnNlID8gJ3JldmVyc2UnIDogJ2ZvcndhcmQnO1xuICAgICAgICAgICAgcGFyZW50SXRlbVNjb3BlLnByZWRpY2F0ZXNbZGVwdGhdW3ByZWRpY2F0ZXNLZXldID0gcHJlZGljYXRlcztcbiAgICAgICAgICAgIC8vIEFwcGVuZCByZGY6dHlwZSBwcmVkaWNhdGUgaWYgdm9jYWJ1bGFyeSBleHBhbnNpb24gYXBwbGllc1xuICAgICAgICAgICAgZm9yIChjb25zdCB2b2NhYnVsYXJ5RXhwYW5zaW9uVHlwZSBvZiB0aGlzLnV0aWwuZ2V0Vm9jYWJ1bGFyeUV4cGFuc2lvblR5cGUoaXRlbXByb3BWYWx1ZSwgcGFyZW50SXRlbVNjb3BlLCB0aGlzLnZvY2FiUmVnaXN0cnkpKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljYXRlcy5wdXNoKHZvY2FidWxhcnlFeHBhbnNpb25UeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGEgcHJvcGVydHkgaGFuZGxlciB0aGF0IGFwcGxpZXMsIGZvcmNlZnVsbHkgdXNlIHRoYXQgYXMgcHJlZGljYXRlIHZhbHVlLlxuICAgICAgICAgICAgLy8gQnV0IERPTidUIGNhbGwgaGFuZGxlcnMgaW4gdGhpcyBwcm9wIGlzIGEgZGlyZWN0IChuZXN0ZWQpIGl0ZW1zY29wZS5cbiAgICAgICAgICAgIGlmIChpdGVtU2NvcGUgJiYgJ2l0ZW1zY29wZScgaW4gdGFnQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFByZWRpY2F0ZVRyaXBsZXMocGFyZW50SXRlbVNjb3BlLCBwcmVkaWNhdGVzLCBpdGVtU2NvcGUuc3ViamVjdCwgcmV2ZXJzZSk7XG4gICAgICAgICAgICAgICAgLy8gRmluYWxpemUgdGhlIHByZWRpY2F0ZXMsIHNvIHRleHQgdmFsdWVzIGRvIG5vdCBhcHBseSB0byB0aGVtLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJlbnRJdGVtU2NvcGUucHJlZGljYXRlc1tkZXB0aF1bcHJlZGljYXRlc0tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgTWljcm9kYXRhUmRmUGFyc2VyLklURU1fUFJPUEVSVFlfSEFORExFUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuY2FuSGFuZGxlKHRhZ05hbWUsIHRhZ0F0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmplY3QgPSBoYW5kbGVyLmdldE9iamVjdCh0YWdBdHRyaWJ1dGVzLCB0aGlzLnV0aWwsIHBhcmVudEl0ZW1TY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRQcmVkaWNhdGVUcmlwbGVzKHBhcmVudEl0ZW1TY29wZSwgcHJlZGljYXRlcywgb2JqZWN0LCByZXZlcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsaXplIHRoZSBwcmVkaWNhdGVzLCBzbyB0ZXh0IHZhbHVlcyBkbyBub3QgYXBwbHkgdG8gdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJlbnRJdGVtU2NvcGUucHJlZGljYXRlc1tkZXB0aF1bcHJlZGljYXRlc0tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBubyB2YWxpZCBoYW5kbGVyIHdhcyBmb3VuZCwgaW5kaWNhdGUgdGhhdCB3ZSBzaG91bGQgY29sbGVjdCB0ZXh0IGF0IHRoaXMgZGVwdGguXG4gICAgICAgICAgICBpZiAocGFyZW50SXRlbVNjb3BlLnByZWRpY2F0ZXNbZGVwdGhdW3ByZWRpY2F0ZXNLZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QnVmZmVyU3RhY2tbZGVwdGhdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCB0aGUgZ2l2ZW4gb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcHJlZGljYXRlcy5cbiAgICAgKiBAcGFyYW0gaXRlbVNjb3BlIFRoZSBjdXJyZW50IGl0ZW0gc2NvcGUuXG4gICAgICogQHBhcmFtIHByZWRpY2F0ZXMgQW4gYXJyYXkgb2YgcHJlZGljYXRlcy5cbiAgICAgKiBAcGFyYW0gb2JqZWN0IEFuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcmV2ZXJzZSBJZiB0aGUgdHJpcGxlcyBzaG91bGQgYmUgcmV2ZXJzZWQuXG4gICAgICovXG4gICAgZW1pdFByZWRpY2F0ZVRyaXBsZXMoaXRlbVNjb3BlLCBwcmVkaWNhdGVzLCBvYmplY3QsIHJldmVyc2UpIHtcbiAgICAgICAgaWYgKCFpdGVtU2NvcGUuYmxvY2tFbWlzc2lvbikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgcHJlZGljYXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExpdGVyYWxzIGNhbiBub3QgZXhpc3QgaW4gc3ViamVjdCBwb3NpdGlvbiwgc28gdGhleSBtdXN0IGJlIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QudGVybVR5cGUgIT09ICdMaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKG9iamVjdCwgcHJlZGljYXRlLCBpdGVtU2NvcGUuc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShpdGVtU2NvcGUuc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IHRoZSBnaXZlbiB0cmlwbGUgdG8gdGhlIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge1F1YWRfU3ViamVjdH0gc3ViamVjdCBBIHN1YmplY3QgdGVybS5cbiAgICAgKiBAcGFyYW0ge1F1YWRfUHJlZGljYXRlfSBwcmVkaWNhdGUgQSBwcmVkaWNhdGUgdGVybS5cbiAgICAgKiBAcGFyYW0ge1F1YWRfT2JqZWN0fSBvYmplY3QgQW4gb2JqZWN0IHRlcm0uXG4gICAgICovXG4gICAgZW1pdFRyaXBsZShzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCkge1xuICAgICAgICB0aGlzLnB1c2godGhpcy51dGlsLmRhdGFGYWN0b3J5LnF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIHRoaXMuZGVmYXVsdEdyYXBoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZW1pdCBhbGwgcGVuZGluZyBpdGVtcmVmcyBmb3IgdGhlIGdpdmVuIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlIEFuIGl0ZW0gcmVmZXJlbmNlIGlkLlxuICAgICAqIEBwYXJhbSBpdGVtU2NvcGVEb21haW4gQW4gb3B0aW9uYWwgaXRlbSBzY29wZS4gSWYgZGVmaW5lZCwgb25seSByZWZzIGZyb20gdGhpcyBzY29wZSB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG4gICAgdHJ5VG9FbWl0UmVmZXJlbmNlcyhyZWZlcmVuY2UsIGl0ZW1TY29wZURvbWFpbikge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMucGVuZGluZ0l0ZW1SZWZzUmFuZ2VGaW5hbGl6ZWRbcmVmZXJlbmNlXTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGl0ZW0gc2NvcGUgZG9tYWlucyB0byBlbWl0XG4gICAgICAgICAgICBsZXQgYXBwbGljYWJsZUl0ZW1TY29wZXM7XG4gICAgICAgICAgICBpZiAoaXRlbVNjb3BlRG9tYWluKSB7XG4gICAgICAgICAgICAgICAgYXBwbGljYWJsZUl0ZW1TY29wZXMgPSBbaXRlbVNjb3BlRG9tYWluXTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgcGVuZGluZyBhcnJheVxuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgaXMgZ3VhcmFudGVlZCB0byBleGlzdCBpbiBidWZmZXJcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtU2NvcGVEb21haW5JbmRleCA9IHRoaXMucGVuZGluZ0l0ZW1SZWZzRG9tYWluW3JlZmVyZW5jZV0uaW5kZXhPZihpdGVtU2NvcGVEb21haW4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0l0ZW1SZWZzRG9tYWluW3JlZmVyZW5jZV0uc3BsaWNlKGl0ZW1TY29wZURvbWFpbkluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGxpY2FibGVJdGVtU2NvcGVzID0gdGhpcy5wZW5kaW5nSXRlbVJlZnNEb21haW5bcmVmZXJlbmNlXTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGl0ZW1zIGZyb20gdGhlIHBlbmRpbmcgYXJyYXlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nSXRlbVJlZnNEb21haW5bcmVmZXJlbmNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcHBsaWNhYmxlSXRlbVNjb3Blcykge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHN0YWNrIHN0YXRlXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVNjb3BlU3RhY2tPbGQgPSB0aGlzLml0ZW1TY29wZVN0YWNrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRCdWZmZXJTdGFja09sZCA9IHRoaXMudGV4dEJ1ZmZlclN0YWNrO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNFbWl0dGluZ1JlZmVyZW5jZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIEZvciBhbGwgYXBwbGljYWJsZSBpdGVtIHNjb3BlcywgZW1pdCB0aGUgYnVmZmVyZWQgZXZlbnRzLlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbVNjb3BlIG9mIGFwcGxpY2FibGVJdGVtU2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbVNjb3BlU3RhY2sgPSBbaXRlbVNjb3BlXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0QnVmZmVyU3RhY2sgPSBbdW5kZWZpbmVkXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ0lkcyA9IHJhbmdlLmlkcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0aW5nUmVmZXJlbmNlc0l0ZW1TY29wZUlkR2VuZXJhdG9yID0gKCkgPT4gcGVuZGluZ0lkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHJhbmdlLmV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25UYWdPcGVuKGV2ZW50Lm5hbWUsIGV2ZW50LmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRleHQoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRhZ0Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHN0YWNrIHN0YXRlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGluZ1JlZmVyZW5jZXNJdGVtU2NvcGVJZEdlbmVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1TY29wZVN0YWNrID0gaXRlbVNjb3BlU3RhY2tPbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QnVmZmVyU3RhY2sgPSB0ZXh0QnVmZmVyU3RhY2tPbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0VtaXR0aW5nUmVmZXJlbmNlcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NaWNyb2RhdGFSZGZQYXJzZXIgPSBNaWNyb2RhdGFSZGZQYXJzZXI7XG5NaWNyb2RhdGFSZGZQYXJzZXIuSVRFTV9QUk9QRVJUWV9IQU5ETEVSUyA9IFtcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlckNvbnRlbnRfMS5JdGVtUHJvcGVydHlIYW5kbGVyQ29udGVudCgpLFxuICAgIG5ldyBJdGVtUHJvcGVydHlIYW5kbGVyVXJsXzEuSXRlbVByb3BlcnR5SGFuZGxlclVybCgnYScsICdocmVmJyksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxfMS5JdGVtUHJvcGVydHlIYW5kbGVyVXJsKCdhcmVhJywgJ2hyZWYnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwoJ2F1ZGlvJywgJ3NyYycpLFxuICAgIG5ldyBJdGVtUHJvcGVydHlIYW5kbGVyVXJsXzEuSXRlbVByb3BlcnR5SGFuZGxlclVybCgnZW1iZWQnLCAnc3JjJyksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxfMS5JdGVtUHJvcGVydHlIYW5kbGVyVXJsKCdpZnJhbWUnLCAnc3JjJyksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxfMS5JdGVtUHJvcGVydHlIYW5kbGVyVXJsKCdpbWcnLCAnc3JjJyksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxfMS5JdGVtUHJvcGVydHlIYW5kbGVyVXJsKCdsaW5rJywgJ2hyZWYnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwoJ29iamVjdCcsICdkYXRhJyksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxfMS5JdGVtUHJvcGVydHlIYW5kbGVyVXJsKCdzb3VyY2UnLCAnc3JjJyksXG4gICAgbmV3IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmxfMS5JdGVtUHJvcGVydHlIYW5kbGVyVXJsKCd0cmFjaycsICdzcmMnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclVybF8xLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwoJ3ZpZGVvJywgJ3NyYycpLFxuICAgIG5ldyBJdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyXzEuSXRlbVByb3BlcnR5SGFuZGxlck51bWJlcignZGF0YScsICd2YWx1ZScpLFxuICAgIG5ldyBJdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyXzEuSXRlbVByb3BlcnR5SGFuZGxlck51bWJlcignbWV0ZXInLCAndmFsdWUnKSxcbiAgICBuZXcgSXRlbVByb3BlcnR5SGFuZGxlclRpbWVfMS5JdGVtUHJvcGVydHlIYW5kbGVyVGltZSgpLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1pY3JvZGF0YVJkZlBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXRpbCA9IHZvaWQgMDtcbmNvbnN0IHJkZl9kYXRhX2ZhY3RvcnlfMSA9IHJlcXVpcmUoXCJyZGYtZGF0YS1mYWN0b3J5XCIpO1xuY29uc3QgcmVsYXRpdmVfdG9fYWJzb2x1dGVfaXJpXzEgPSByZXF1aXJlKFwicmVsYXRpdmUtdG8tYWJzb2x1dGUtaXJpXCIpO1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKi9cbmNsYXNzIFV0aWwge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFGYWN0b3J5LCBiYXNlSVJJKSB7XG4gICAgICAgIHRoaXMuZGF0YUZhY3RvcnkgPSBkYXRhRmFjdG9yeSB8fCBuZXcgcmRmX2RhdGFfZmFjdG9yeV8xLkRhdGFGYWN0b3J5KCk7XG4gICAgICAgIHRoaXMuYmFzZUlSSSA9IGJhc2VJUkkgfHwgJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBJUkkgaXMgdmFsaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlyaSBBIHBvdGVudGlhbCBJUkkuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGdpdmVuIElSSSBpcyB2YWxpZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZElyaShpcmkpIHtcbiAgICAgICAgcmV0dXJuIFV0aWwuSVJJX1JFR0VYLnRlc3QoaXJpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHZvY2FiIHRlcm1zIGZvciB0aGUgZ2l2ZW4gdGVybXMgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogUmVsYXRpdmUgSVJJcyB3aWxsIGJlIGJhc2VkIG9uIHRoZSBhY3RpdmUgdm9jYWIgb3IgYmFzZUlSSSBpZiBgYWxsb3dSZWxhdGl2ZUlyaXNgIGlzIHRydWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVybXMgQW4gYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7SUl0ZW1TY29wZX0gaXRlbVNjb3BlIFRoZSBhY3RpdmUgaXRlbSBzY29wZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93UmVsYXRpdmVJcmlzIElmIHJlbGF0aXZlIElSSXMgYXJlIGFsbG93ZWQuXG4gICAgICogQHJldHVybiB7VGVybVtdfSBUaGUgSVJJIHRlcm1zLlxuICAgICAqL1xuICAgIGNyZWF0ZVZvY2FiSXJpcyh0ZXJtcywgaXRlbVNjb3BlLCBhbGxvd1JlbGF0aXZlSXJpcykge1xuICAgICAgICByZXR1cm4gdGVybXMuc3BsaXQoL1xccysvdSlcbiAgICAgICAgICAgIC5maWx0ZXIodGVybSA9PiAhIXRlcm0pXG4gICAgICAgICAgICAubWFwKHByb3BlcnR5ID0+IHtcbiAgICAgICAgICAgIGlmICghVXRpbC5pc1ZhbGlkSXJpKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dSZWxhdGl2ZUlyaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IGAke2l0ZW1TY29wZS52b2NhYiB8fCBgJHt0aGlzLmJhc2VJUkl9I2B9JHtwcm9wZXJ0eX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZhY3RvcnkubmFtZWROb2RlKHByb3BlcnR5KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIodGVybSA9PiAhIXRlcm0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByZWRpY2F0ZXMgZm9yIHdoaWNoIHRoZSBnaXZlbiBpdGVtcHJvcCB2YWx1ZSBzaG91bGQgY2F1c2Ugdm9jYWJ1bGFyeSBleHBhbnNpb24uXG4gICAgICogQHBhcmFtIHRlcm1zIEFuIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaXRlbVNjb3BlIFRoZSBhY3RpdmUgaXRlbSBzY29wZS5cbiAgICAgKiBAcGFyYW0gdm9jYWJSZWdpc3RyeSBUaGUgYWN0aXZlIHZvY2FidWxhcnkgcmVnaXN0cnkuXG4gICAgICovXG4gICAgZ2V0Vm9jYWJ1bGFyeUV4cGFuc2lvblR5cGUodGVybXMsIGl0ZW1TY29wZSwgdm9jYWJSZWdpc3RyeSkge1xuICAgICAgICAvLyBDaGVjayB0aGUgcHJlc2VuY2Ugb2Ygc3ViUHJvcGVydHlPZiBvciBlcXVpdmFsZW50UHJvcGVydHlcbiAgICAgICAgY29uc3QgcGFydHMgPSB0ZXJtcy5zcGxpdCgvXFxzKy91KTtcbiAgICAgICAgaWYgKHBhcnRzLmluY2x1ZGVzKCdzdWJQcm9wZXJ0eU9mJykgfHwgcGFydHMuaW5jbHVkZXMoJ2VxdWl2YWxlbnRQcm9wZXJ0eScpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZGF0YUZhY3RvcnkubmFtZWROb2RlKGAke1V0aWwuUkRGfXR5cGVgKV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaW4gdGhlIGl0ZW0gc2NvcGUncyB2b2NhYlxuICAgICAgICBpZiAoaXRlbVNjb3BlLnZvY2FiICYmIGl0ZW1TY29wZS52b2NhYiBpbiB2b2NhYlJlZ2lzdHJ5ICYmIHZvY2FiUmVnaXN0cnlbaXRlbVNjb3BlLnZvY2FiXS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBsZXQgcHJlZGljYXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbcHJvcGVydHksIGV4cGFuc2lvbnNdIG9mIE9iamVjdFxuICAgICAgICAgICAgICAgIC5lbnRyaWVzKHZvY2FiUmVnaXN0cnlbaXRlbVNjb3BlLnZvY2FiXS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5pbmNsdWRlcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZGljYXRlcyA9IHByZWRpY2F0ZXMuY29uY2F0KE9iamVjdC52YWx1ZXMoZXhwYW5zaW9ucykubWFwKGlyaSA9PiB0aGlzLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShpcmkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuYW1lZCBub2RlIGZvciB0aGUgZ2l2ZW4gdGVybSwgd2hpY2ggY2FuIGJlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCBiYXNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpcmkgQSB0ZXJtIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHtUZXJtfSBBbiBSREYgdGVybSwgb3IgdW5kZWZpbmVkIGlmIGludmFsaWQuXG4gICAgICovXG4gICAgY3JlYXRlU3ViamVjdChpcmkpIHtcbiAgICAgICAgaWYgKCFVdGlsLmlzVmFsaWRJcmkoaXJpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpcmkgPSByZWxhdGl2ZV90b19hYnNvbHV0ZV9pcmlfMS5yZXNvbHZlKGlyaSwgdGhpcy5iYXNlSVJJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoaXJpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGxpdGVyYWwgbm9kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGl0ZXJhbCBUaGUgbGl0ZXJhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0lBY3RpdmVUYWd9IGFjdGl2ZVRhZyBUaGUgY3VycmVudCBhY3RpdmUgdGFnLlxuICAgICAqIEByZXR1cm4ge0xpdGVyYWx9IEEgbmV3IGxpdGVyYWwgbm9kZS5cbiAgICAgKi9cbiAgICBjcmVhdGVMaXRlcmFsKGxpdGVyYWwsIGFjdGl2ZVRhZykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhRmFjdG9yeS5saXRlcmFsKGxpdGVyYWwsIGFjdGl2ZVRhZy5sYW5ndWFnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgdm9jYWIgSVJJIGZyb20gYSBnaXZlbiB0eXBlIElSSS5cbiAgICAgKiBAbGluayBodHRwczovL3czYy5naXRodWIuaW8vbWljcm9kYXRhLXJkZi8jcHJvcGVydHktdXJpLWdlbmVyYXRpb25cbiAgICAgKiBAcGFyYW0gdHlwZUlyaSBBIHR5cGUgSVJJLlxuICAgICAqIEBwYXJhbSB2b2NhYlJlZ2lzdHJ5IFRoZSBhY3RpdmUgdm9jYWJ1bGFyeSByZWdpc3RyeS5cbiAgICAgKi9cbiAgICBkZXJpdmVWb2NhYih0eXBlSXJpLCB2b2NhYlJlZ2lzdHJ5KSB7XG4gICAgICAgIGxldCB2b2NhYjtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgZmluZCBhIHByZWZpeCBpbiB0aGUgdm9jYWIgcmVnaXN0cnlcbiAgICAgICAgZm9yIChjb25zdCB1cmlQcmVmaXggaW4gdm9jYWJSZWdpc3RyeSkge1xuICAgICAgICAgICAgaWYgKHR5cGVJcmkuc3RhcnRzV2l0aCh1cmlQcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgdm9jYWIgPSB1cmlQcmVmaXg7XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIGZyYWdtZW50IGlmIHByZWZpeCBkb2VzIG5vdCBlbmQgd2l0aCBhIHNsYXNoXG4gICAgICAgICAgICAgICAgaWYgKCF2b2NhYi5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvY2FiICs9ICcjJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gbWF0Y2ggd2FzIGZvdW5kLCByZW1vdmUgdGhlIGxhc3QgcGF0aCBzZWdtZW50IGZyb20gdGhlIFVSSVxuICAgICAgICBpZiAoIXZvY2FiKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoUG9zID0gdHlwZUlyaS5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICBpZiAoaGFzaFBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICB2b2NhYiA9IHR5cGVJcmkuc2xpY2UoMCwgaGFzaFBvcyArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm9jYWIgPSByZWxhdGl2ZV90b19hYnNvbHV0ZV9pcmlfMS5yZXNvbHZlKCcuJywgdHlwZUlyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvY2FiO1xuICAgIH1cbn1cbmV4cG9ydHMuVXRpbCA9IFV0aWw7XG5VdGlsLlJERiA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjJztcblV0aWwuWFNEID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hIyc7XG5VdGlsLlJERkEgPSAnaHR0cDovL3d3dy53My5vcmcvbnMvcmRmYSMnO1xuVXRpbC5JUklfUkVHRVggPSAvXihbQS1aYS16XVtcXGQrLS5BLVphLXpdKnxfKTpbXiBcIjw+W1xcXFxcXF1ge3x9XSokL3U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VdGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUl0ZW1Qcm9wZXJ0eUhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJDb250ZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBIYW5kbGVyIGZvciBhbiBpdGVtIHByb3BlcnR5IHdpdGggdGhlICdjb250ZW50JyBhdHRyaWJ1dGUuXG4gKi9cbmNsYXNzIEl0ZW1Qcm9wZXJ0eUhhbmRsZXJDb250ZW50IHtcbiAgICBjYW5IYW5kbGUodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gJ2NvbnRlbnQnIGluIGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGdldE9iamVjdChhdHRyaWJ1dGVzLCB1dGlsLCBpdGVtU2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuY3JlYXRlTGl0ZXJhbChhdHRyaWJ1dGVzLmNvbnRlbnQsIGl0ZW1TY29wZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JdGVtUHJvcGVydHlIYW5kbGVyQ29udGVudCA9IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJDb250ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlbVByb3BlcnR5SGFuZGxlckNvbnRlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vVXRpbFwiKTtcbi8qKlxuICogSGFuZGxlciBmb3IgYW4gaXRlbSBwcm9wZXJ0eSB3aXRoIGEgbnVtYmVyIGF0dHJpYnV0ZS5cbiAqL1xuY2xhc3MgSXRlbVByb3BlcnR5SGFuZGxlck51bWJlciB7XG4gICAgY29uc3RydWN0b3IodGFnTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgIH1cbiAgICBjYW5IYW5kbGUodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdOYW1lID09PSB0YWdOYW1lICYmIHRoaXMuYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBnZXRPYmplY3QoYXR0cmlidXRlcywgdXRpbCwgaXRlbVNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBsZXQgZGF0YXR5cGU7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKE51bWJlci5wYXJzZUludCh2YWx1ZSwgMTApKSAmJiAhdmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgZGF0YXR5cGUgPSBgJHtVdGlsXzEuVXRpbC5YU0R9aW50ZWdlcmA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU51bWJlci5pc05hTihOdW1iZXIucGFyc2VGbG9hdCh2YWx1ZSkpKSB7XG4gICAgICAgICAgICBkYXRhdHlwZSA9IGAke1V0aWxfMS5VdGlsLlhTRH1kb3VibGVgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLmRhdGFGYWN0b3J5LmxpdGVyYWwodmFsdWUsIGRhdGF0eXBlICYmIHV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKGRhdGF0eXBlKSk7XG4gICAgfVxufVxuZXhwb3J0cy5JdGVtUHJvcGVydHlIYW5kbGVyTnVtYmVyID0gSXRlbVByb3BlcnR5SGFuZGxlck51bWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUl0ZW1Qcm9wZXJ0eUhhbmRsZXJOdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lID0gdm9pZCAwO1xuY29uc3QgVXRpbF8xID0gcmVxdWlyZShcIi4uL1V0aWxcIik7XG4vKipcbiAqIEhhbmRsZXIgZm9yIGFuIGl0ZW0gcHJvcGVydHkgZm9yIHRpbWUgdGFncy5cbiAqL1xuY2xhc3MgSXRlbVByb3BlcnR5SGFuZGxlclRpbWUge1xuICAgIGNhbkhhbmRsZSh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAndGltZScgJiYgJ2RhdGV0aW1lJyBpbiBhdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBnZXRPYmplY3QoYXR0cmlidXRlcywgdXRpbCwgaXRlbVNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlcy5kYXRldGltZTtcbiAgICAgICAgbGV0IGRhdGF0eXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIEl0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lLlRJTUVfUkVHRVhFUykge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnJlZ2V4LmV4ZWModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGF0YXR5cGUgPSB1dGlsLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShVdGlsXzEuVXRpbC5YU0QgKyBlbnRyeS50eXBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5kYXRhRmFjdG9yeS5saXRlcmFsKHZhbHVlLCBkYXRhdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JdGVtUHJvcGVydHlIYW5kbGVyVGltZSA9IEl0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lO1xuSXRlbVByb3BlcnR5SGFuZGxlclRpbWUuVElNRV9SRUdFWEVTID0gW1xuICAgIHtcbiAgICAgICAgcmVnZXg6IC9eLT9QKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoXFxkK0gpPyhcXGQrTSk/KFxcZCsoXFwuXFxkKT9TKT8pPyQvdSxcbiAgICAgICAgdHlwZTogJ2R1cmF0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgcmVnZXg6IC9eXFxkKy1cXGRcXGQtXFxkXFxkVFxcZFxcZDpcXGRcXGQ6XFxkXFxkKChaPyl8KFsrLV1cXGRcXGQ6XFxkXFxkKSkkL3UsXG4gICAgICAgIHR5cGU6ICdkYXRlVGltZScsXG4gICAgfSxcbiAgICB7IHJlZ2V4OiAvXlxcZCstXFxkXFxkLVxcZFxcZFo/JC91LCB0eXBlOiAnZGF0ZScgfSxcbiAgICB7IHJlZ2V4OiAvXlxcZFxcZDpcXGRcXGQ6XFxkXFxkKChaPyl8KFsrLV1cXGRcXGQ6XFxkXFxkKSkkL3UsIHR5cGU6ICd0aW1lJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkKy1cXGRcXGQkL3UsIHR5cGU6ICdnWWVhck1vbnRoJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkKyQvdSwgdHlwZTogJ2dZZWFyJyB9LFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUl0ZW1Qcm9wZXJ0eUhhbmRsZXJUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JdGVtUHJvcGVydHlIYW5kbGVyVXJsID0gdm9pZCAwO1xuY29uc3QgcmVsYXRpdmVfdG9fYWJzb2x1dGVfaXJpXzEgPSByZXF1aXJlKFwicmVsYXRpdmUtdG8tYWJzb2x1dGUtaXJpXCIpO1xuLyoqXG4gKiBIYW5kbGVyIGZvciBhbiBpdGVtIHByb3BlcnR5IHdpdGggYSBVUkwgYXR0cmlidXRlLlxuICovXG5jbGFzcyBJdGVtUHJvcGVydHlIYW5kbGVyVXJsIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgfVxuICAgIGNhbkhhbmRsZSh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZ05hbWUgPT09IHRhZ05hbWUgJiYgdGhpcy5hdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGdldE9iamVjdChhdHRyaWJ1dGVzLCB1dGlsLCBpdGVtU2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKHJlbGF0aXZlX3RvX2Fic29sdXRlX2lyaV8xLnJlc29sdmUoYXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZU5hbWVdLCB1dGlsLmJhc2VJUkkpKTtcbiAgICB9XG59XG5leHBvcnRzLkl0ZW1Qcm9wZXJ0eUhhbmRsZXJVcmwgPSBJdGVtUHJvcGVydHlIYW5kbGVyVXJsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlbVByb3BlcnR5SGFuZGxlclVybC5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiaHR0cDovL3NjaGVtYS5vcmcvXCI6IHtcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgXCJhZGRpdGlvbmFsVHlwZVwiOiB7XCJzdWJQcm9wZXJ0eU9mXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI3R5cGVcIn1cbiAgICB9XG4gIH0sXG4gIFwiaHR0cDovL21pY3JvZm9ybWF0cy5vcmcvcHJvZmlsZS9oY2FyZFwiOiB7fVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUkRGID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMnLFxuICAgIFhTRCA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSMnLFxuICAgIFNXQVAgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC8xMC9zd2FwLyc7XG52YXIgX2RlZmF1bHQgPSB7XG4gIHhzZDoge1xuICAgIGRlY2ltYWw6IFhTRCArICdkZWNpbWFsJyxcbiAgICBib29sZWFuOiBYU0QgKyAnYm9vbGVhbicsXG4gICAgZG91YmxlOiBYU0QgKyAnZG91YmxlJyxcbiAgICBpbnRlZ2VyOiBYU0QgKyAnaW50ZWdlcicsXG4gICAgc3RyaW5nOiBYU0QgKyAnc3RyaW5nJ1xuICB9LFxuICByZGY6IHtcbiAgICB0eXBlOiBSREYgKyAndHlwZScsXG4gICAgbmlsOiBSREYgKyAnbmlsJyxcbiAgICBmaXJzdDogUkRGICsgJ2ZpcnN0JyxcbiAgICByZXN0OiBSREYgKyAncmVzdCcsXG4gICAgbGFuZ1N0cmluZzogUkRGICsgJ2xhbmdTdHJpbmcnXG4gIH0sXG4gIG93bDoge1xuICAgIHNhbWVBczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDIvMDcvb3dsI3NhbWVBcydcbiAgfSxcbiAgcjoge1xuICAgIGZvclNvbWU6IFNXQVAgKyAncmVpZnkjZm9yU29tZScsXG4gICAgZm9yQWxsOiBTV0FQICsgJ3JlaWZ5I2ZvckFsbCdcbiAgfSxcbiAgbG9nOiB7XG4gICAgaW1wbGllczogU1dBUCArICdsb2cjaW1wbGllcydcbiAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy50ZXJtRnJvbUlkID0gdGVybUZyb21JZDtcbmV4cG9ydHMudGVybVRvSWQgPSB0ZXJtVG9JZDtcbmV4cG9ydHMuZXNjYXBlUXVvdGVzID0gZXNjYXBlUXVvdGVzO1xuZXhwb3J0cy51bmVzY2FwZVF1b3RlcyA9IHVuZXNjYXBlUXVvdGVzO1xuZXhwb3J0cy5UcmlwbGUgPSBleHBvcnRzLlF1YWQgPSBleHBvcnRzLkRlZmF1bHRHcmFwaCA9IGV4cG9ydHMuVmFyaWFibGUgPSBleHBvcnRzLkJsYW5rTm9kZSA9IGV4cG9ydHMuTGl0ZXJhbCA9IGV4cG9ydHMuTmFtZWROb2RlID0gZXhwb3J0cy5UZXJtID0gZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX0lSSXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0lSSXNcIikpO1xuXG52YXIgX04zVXRpbCA9IHJlcXVpcmUoXCIuL04zVXRpbFwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gTjMuanMgaW1wbGVtZW50YXRpb25zIG9mIHRoZSBSREYvSlMgY29yZSBkYXRhIHR5cGVzXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JkZmpzL3JlcHJlc2VudGF0aW9uLXRhc2stZm9yY2UvYmxvYi9tYXN0ZXIvaW50ZXJmYWNlLXNwZWMubWRcbmNvbnN0IHtcbiAgcmRmLFxuICB4c2Rcbn0gPSBfSVJJcy5kZWZhdWx0O1xubGV0IERFRkFVTFRHUkFQSDtcbmxldCBfYmxhbmtOb2RlQ291bnRlciA9IDA7XG5jb25zdCBlc2NhcGVkTGl0ZXJhbCA9IC9eXCIoLipcIi4qKSg/PVwiW15cIl0qJCkvO1xuY29uc3QgcXVhZElkID0gL148PChcIig/OlwiXCJ8W15cIl0pKlwiW14gXSp8W14gXSspIChcIig/OlwiXCJ8W15cIl0pKlwiW14gXSp8W14gXSspIChcIig/OlwiXCJ8W15cIl0pKlwiW14gXSp8W14gXSspID8oXCIoPzpcIlwifFteXCJdKSpcIlteIF0qfFteIF0rKT8+PiQvOyAvLyAjIyBEYXRhRmFjdG9yeSBzaW5nbGV0b25cblxuY29uc3QgRGF0YUZhY3RvcnkgPSB7XG4gIG5hbWVkTm9kZSxcbiAgYmxhbmtOb2RlLFxuICB2YXJpYWJsZSxcbiAgbGl0ZXJhbCxcbiAgZGVmYXVsdEdyYXBoLFxuICBxdWFkLFxuICB0cmlwbGU6IHF1YWRcbn07XG52YXIgX2RlZmF1bHQgPSBEYXRhRmFjdG9yeTsgLy8gIyMgVGVybSBjb25zdHJ1Y3RvclxuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuY2xhc3MgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICB9IC8vICMjIyBUaGUgdmFsdWUgb2YgdGhpcyB0ZXJtXG5cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH0gLy8gIyMjIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCByZXByZXNlbnRzIHRoZSBzYW1lIHRlcm0gYXMgdGhlIG90aGVyXG5cblxuICBlcXVhbHMob3RoZXIpIHtcbiAgICAvLyBJZiBib3RoIHRlcm1zIHdlcmUgY3JlYXRlZCBieSB0aGlzIGxpYnJhcnksXG4gICAgLy8gZXF1YWxpdHkgY2FuIGJlIGNvbXB1dGVkIHRocm91Z2ggaWRzXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgVGVybSkgcmV0dXJuIHRoaXMuaWQgPT09IG90aGVyLmlkOyAvLyBPdGhlcndpc2UsIGNvbXBhcmUgdGVybSB0eXBlIGFuZCB2YWx1ZVxuXG4gICAgcmV0dXJuICEhb3RoZXIgJiYgdGhpcy50ZXJtVHlwZSA9PT0gb3RoZXIudGVybVR5cGUgJiYgdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWU7XG4gIH0gLy8gIyMjIFJldHVybnMgYSBwbGFpbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0ZXJtXG5cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlcm1UeXBlOiB0aGlzLnRlcm1UeXBlLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG5cbn0gLy8gIyMgTmFtZWROb2RlIGNvbnN0cnVjdG9yXG5cblxuZXhwb3J0cy5UZXJtID0gVGVybTtcblxuY2xhc3MgTmFtZWROb2RlIGV4dGVuZHMgVGVybSB7XG4gIC8vICMjIyBUaGUgdGVybSB0eXBlIG9mIHRoaXMgdGVybVxuICBnZXQgdGVybVR5cGUoKSB7XG4gICAgcmV0dXJuICdOYW1lZE5vZGUnO1xuICB9XG5cbn0gLy8gIyMgTGl0ZXJhbCBjb25zdHJ1Y3RvclxuXG5cbmV4cG9ydHMuTmFtZWROb2RlID0gTmFtZWROb2RlO1xuXG5jbGFzcyBMaXRlcmFsIGV4dGVuZHMgVGVybSB7XG4gIC8vICMjIyBUaGUgdGVybSB0eXBlIG9mIHRoaXMgdGVybVxuICBnZXQgdGVybVR5cGUoKSB7XG4gICAgcmV0dXJuICdMaXRlcmFsJztcbiAgfSAvLyAjIyMgVGhlIHRleHQgdmFsdWUgb2YgdGhpcyBsaXRlcmFsXG5cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQuc3Vic3RyaW5nKDEsIHRoaXMuaWQubGFzdEluZGV4T2YoJ1wiJykpO1xuICB9IC8vICMjIyBUaGUgbGFuZ3VhZ2Ugb2YgdGhpcyBsaXRlcmFsXG5cblxuICBnZXQgbGFuZ3VhZ2UoKSB7XG4gICAgLy8gRmluZCB0aGUgbGFzdCBxdW90YXRpb24gbWFyayAoZS5nLiwgJ1wiYWJjXCJAZW4tdXMnKVxuICAgIHZhciBpZCA9IHRoaXMuaWQsXG4gICAgICAgIGF0UG9zID0gaWQubGFzdEluZGV4T2YoJ1wiJykgKyAxOyAvLyBJZiBcIkBcIiBpdCBmb2xsb3dzLCByZXR1cm4gdGhlIHJlbWFpbmluZyBzdWJzdHJpbmc7IGVtcHR5IG90aGVyd2lzZVxuXG4gICAgcmV0dXJuIGF0UG9zIDwgaWQubGVuZ3RoICYmIGlkW2F0UG9zKytdID09PSAnQCcgPyBpZC5zdWJzdHIoYXRQb3MpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgfSAvLyAjIyMgVGhlIGRhdGF0eXBlIElSSSBvZiB0aGlzIGxpdGVyYWxcblxuXG4gIGdldCBkYXRhdHlwZSgpIHtcbiAgICByZXR1cm4gbmV3IE5hbWVkTm9kZSh0aGlzLmRhdGF0eXBlU3RyaW5nKTtcbiAgfSAvLyAjIyMgVGhlIGRhdGF0eXBlIHN0cmluZyBvZiB0aGlzIGxpdGVyYWxcblxuXG4gIGdldCBkYXRhdHlwZVN0cmluZygpIHtcbiAgICAvLyBGaW5kIHRoZSBsYXN0IHF1b3RhdGlvbiBtYXJrIChlLmcuLCAnXCJhYmNcIl5eaHR0cDovL2V4Lm9yZy90eXBlcyN0JylcbiAgICB2YXIgaWQgPSB0aGlzLmlkLFxuICAgICAgICBkdFBvcyA9IGlkLmxhc3RJbmRleE9mKCdcIicpICsgMSxcbiAgICAgICAgY2g7IC8vIElmIFwiXlwiIGl0IGZvbGxvd3MsIHJldHVybiB0aGUgcmVtYWluaW5nIHN1YnN0cmluZ1xuXG4gICAgcmV0dXJuIGR0UG9zIDwgaWQubGVuZ3RoICYmIChjaCA9IGlkW2R0UG9zXSkgPT09ICdeJyA/IGlkLnN1YnN0cihkdFBvcyArIDIpIDogLy8gSWYgXCJAXCIgZm9sbG93cywgcmV0dXJuIHJkZjpsYW5nU3RyaW5nOyB4c2Q6c3RyaW5nIG90aGVyd2lzZVxuICAgIGNoICE9PSAnQCcgPyB4c2Quc3RyaW5nIDogcmRmLmxhbmdTdHJpbmc7XG4gIH0gLy8gIyMjIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCByZXByZXNlbnRzIHRoZSBzYW1lIHRlcm0gYXMgdGhlIG90aGVyXG5cblxuICBlcXVhbHMob3RoZXIpIHtcbiAgICAvLyBJZiBib3RoIGxpdGVyYWxzIHdlcmUgY3JlYXRlZCBieSB0aGlzIGxpYnJhcnksXG4gICAgLy8gZXF1YWxpdHkgY2FuIGJlIGNvbXB1dGVkIHRocm91Z2ggaWRzXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTGl0ZXJhbCkgcmV0dXJuIHRoaXMuaWQgPT09IG90aGVyLmlkOyAvLyBPdGhlcndpc2UsIGNvbXBhcmUgdGVybSB0eXBlLCB2YWx1ZSwgbGFuZ3VhZ2UsIGFuZCBkYXRhdHlwZVxuXG4gICAgcmV0dXJuICEhb3RoZXIgJiYgISFvdGhlci5kYXRhdHlwZSAmJiB0aGlzLnRlcm1UeXBlID09PSBvdGhlci50ZXJtVHlwZSAmJiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZSAmJiB0aGlzLmxhbmd1YWdlID09PSBvdGhlci5sYW5ndWFnZSAmJiB0aGlzLmRhdGF0eXBlLnZhbHVlID09PSBvdGhlci5kYXRhdHlwZS52YWx1ZTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVybVR5cGU6IHRoaXMudGVybVR5cGUsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgZGF0YXR5cGU6IHtcbiAgICAgICAgdGVybVR5cGU6ICdOYW1lZE5vZGUnLFxuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhdHlwZVN0cmluZ1xuICAgICAgfVxuICAgIH07XG4gIH1cblxufSAvLyAjIyBCbGFua05vZGUgY29uc3RydWN0b3JcblxuXG5leHBvcnRzLkxpdGVyYWwgPSBMaXRlcmFsO1xuXG5jbGFzcyBCbGFua05vZGUgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHN1cGVyKCdfOicgKyBuYW1lKTtcbiAgfSAvLyAjIyMgVGhlIHRlcm0gdHlwZSBvZiB0aGlzIHRlcm1cblxuXG4gIGdldCB0ZXJtVHlwZSgpIHtcbiAgICByZXR1cm4gJ0JsYW5rTm9kZSc7XG4gIH0gLy8gIyMjIFRoZSBuYW1lIG9mIHRoaXMgYmxhbmsgbm9kZVxuXG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmlkLnN1YnN0cigyKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuQmxhbmtOb2RlID0gQmxhbmtOb2RlO1xuXG5jbGFzcyBWYXJpYWJsZSBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoJz8nICsgbmFtZSk7XG4gIH0gLy8gIyMjIFRoZSB0ZXJtIHR5cGUgb2YgdGhpcyB0ZXJtXG5cblxuICBnZXQgdGVybVR5cGUoKSB7XG4gICAgcmV0dXJuICdWYXJpYWJsZSc7XG4gIH0gLy8gIyMjIFRoZSBuYW1lIG9mIHRoaXMgdmFyaWFibGVcblxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZC5zdWJzdHIoMSk7XG4gIH1cblxufSAvLyAjIyBEZWZhdWx0R3JhcGggY29uc3RydWN0b3JcblxuXG5leHBvcnRzLlZhcmlhYmxlID0gVmFyaWFibGU7XG5cbmNsYXNzIERlZmF1bHRHcmFwaCBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignJyk7XG4gICAgcmV0dXJuIERFRkFVTFRHUkFQSCB8fCB0aGlzO1xuICB9IC8vICMjIyBUaGUgdGVybSB0eXBlIG9mIHRoaXMgdGVybVxuXG5cbiAgZ2V0IHRlcm1UeXBlKCkge1xuICAgIHJldHVybiAnRGVmYXVsdEdyYXBoJztcbiAgfSAvLyAjIyMgUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IHJlcHJlc2VudHMgdGhlIHNhbWUgdGVybSBhcyB0aGUgb3RoZXJcblxuXG4gIGVxdWFscyhvdGhlcikge1xuICAgIC8vIElmIGJvdGggdGVybXMgd2VyZSBjcmVhdGVkIGJ5IHRoaXMgbGlicmFyeSxcbiAgICAvLyBlcXVhbGl0eSBjYW4gYmUgY29tcHV0ZWQgdGhyb3VnaCBzdHJpY3QgZXF1YWxpdHk7XG4gICAgLy8gb3RoZXJ3aXNlLCBjb21wYXJlIHRlcm0gdHlwZXMuXG4gICAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8ICEhb3RoZXIgJiYgdGhpcy50ZXJtVHlwZSA9PT0gb3RoZXIudGVybVR5cGU7XG4gIH1cblxufSAvLyAjIyBEZWZhdWx0R3JhcGggc2luZ2xldG9uXG5cblxuZXhwb3J0cy5EZWZhdWx0R3JhcGggPSBEZWZhdWx0R3JhcGg7XG5ERUZBVUxUR1JBUEggPSBuZXcgRGVmYXVsdEdyYXBoKCk7IC8vICMjIyBDb25zdHJ1Y3RzIGEgdGVybSBmcm9tIHRoZSBnaXZlbiBpbnRlcm5hbCBzdHJpbmcgSURcblxuZnVuY3Rpb24gdGVybUZyb21JZChpZCwgZmFjdG9yeSkge1xuICBmYWN0b3J5ID0gZmFjdG9yeSB8fCBEYXRhRmFjdG9yeTsgLy8gRmFsc3kgdmFsdWUgb3IgZW1wdHkgc3RyaW5nIGluZGljYXRlIHRoZSBkZWZhdWx0IGdyYXBoXG5cbiAgaWYgKCFpZCkgcmV0dXJuIGZhY3RvcnkuZGVmYXVsdEdyYXBoKCk7IC8vIElkZW50aWZ5IHRoZSB0ZXJtIHR5cGUgYmFzZWQgb24gdGhlIGZpcnN0IGNoYXJhY3RlclxuXG4gIHN3aXRjaCAoaWRbMF0pIHtcbiAgICBjYXNlICc/JzpcbiAgICAgIHJldHVybiBmYWN0b3J5LnZhcmlhYmxlKGlkLnN1YnN0cigxKSk7XG5cbiAgICBjYXNlICdfJzpcbiAgICAgIHJldHVybiBmYWN0b3J5LmJsYW5rTm9kZShpZC5zdWJzdHIoMikpO1xuXG4gICAgY2FzZSAnXCInOlxuICAgICAgLy8gU2hvcnRjdXQgZm9yIGludGVybmFsIGxpdGVyYWxzXG4gICAgICBpZiAoZmFjdG9yeSA9PT0gRGF0YUZhY3RvcnkpIHJldHVybiBuZXcgTGl0ZXJhbChpZCk7IC8vIExpdGVyYWwgd2l0aG91dCBkYXRhdHlwZSBvciBsYW5ndWFnZVxuXG4gICAgICBpZiAoaWRbaWQubGVuZ3RoIC0gMV0gPT09ICdcIicpIHJldHVybiBmYWN0b3J5LmxpdGVyYWwoaWQuc3Vic3RyKDEsIGlkLmxlbmd0aCAtIDIpKTsgLy8gTGl0ZXJhbCB3aXRoIGRhdGF0eXBlIG9yIGxhbmd1YWdlXG5cbiAgICAgIHZhciBlbmRQb3MgPSBpZC5sYXN0SW5kZXhPZignXCInLCBpZC5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiBmYWN0b3J5LmxpdGVyYWwoaWQuc3Vic3RyKDEsIGVuZFBvcyAtIDEpLCBpZFtlbmRQb3MgKyAxXSA9PT0gJ0AnID8gaWQuc3Vic3RyKGVuZFBvcyArIDIpIDogZmFjdG9yeS5uYW1lZE5vZGUoaWQuc3Vic3RyKGVuZFBvcyArIDMpKSk7XG5cbiAgICBjYXNlICc8JzpcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBxdWFkSWQuZXhlYyhpZCk7XG4gICAgICByZXR1cm4gZmFjdG9yeS5xdWFkKHRlcm1Gcm9tSWQodW5lc2NhcGVRdW90ZXMoY29tcG9uZW50c1sxXSksIGZhY3RvcnkpLCB0ZXJtRnJvbUlkKHVuZXNjYXBlUXVvdGVzKGNvbXBvbmVudHNbMl0pLCBmYWN0b3J5KSwgdGVybUZyb21JZCh1bmVzY2FwZVF1b3Rlcyhjb21wb25lbnRzWzNdKSwgZmFjdG9yeSksIGNvbXBvbmVudHNbNF0gJiYgdGVybUZyb21JZCh1bmVzY2FwZVF1b3Rlcyhjb21wb25lbnRzWzRdKSwgZmFjdG9yeSkpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWN0b3J5Lm5hbWVkTm9kZShpZCk7XG4gIH1cbn0gLy8gIyMjIENvbnN0cnVjdHMgYW4gaW50ZXJuYWwgc3RyaW5nIElEIGZyb20gdGhlIGdpdmVuIHRlcm0gb3IgSUQgc3RyaW5nXG5cblxuZnVuY3Rpb24gdGVybVRvSWQodGVybSkge1xuICBpZiAodHlwZW9mIHRlcm0gPT09ICdzdHJpbmcnKSByZXR1cm4gdGVybTtcbiAgaWYgKHRlcm0gaW5zdGFuY2VvZiBUZXJtICYmIHRlcm0udGVybVR5cGUgIT09ICdRdWFkJykgcmV0dXJuIHRlcm0uaWQ7XG4gIGlmICghdGVybSkgcmV0dXJuIERFRkFVTFRHUkFQSC5pZDsgLy8gVGVybSBpbnN0YW50aWF0ZWQgd2l0aCBhbm90aGVyIGxpYnJhcnlcblxuICBzd2l0Y2ggKHRlcm0udGVybVR5cGUpIHtcbiAgICBjYXNlICdOYW1lZE5vZGUnOlxuICAgICAgcmV0dXJuIHRlcm0udmFsdWU7XG5cbiAgICBjYXNlICdCbGFua05vZGUnOlxuICAgICAgcmV0dXJuICdfOicgKyB0ZXJtLnZhbHVlO1xuXG4gICAgY2FzZSAnVmFyaWFibGUnOlxuICAgICAgcmV0dXJuICc/JyArIHRlcm0udmFsdWU7XG5cbiAgICBjYXNlICdEZWZhdWx0R3JhcGgnOlxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICByZXR1cm4gJ1wiJyArIHRlcm0udmFsdWUgKyAnXCInICsgKHRlcm0ubGFuZ3VhZ2UgPyAnQCcgKyB0ZXJtLmxhbmd1YWdlIDogdGVybS5kYXRhdHlwZSAmJiB0ZXJtLmRhdGF0eXBlLnZhbHVlICE9PSB4c2Quc3RyaW5nID8gJ15eJyArIHRlcm0uZGF0YXR5cGUudmFsdWUgOiAnJyk7XG5cbiAgICBjYXNlICdRdWFkJzpcbiAgICAgIC8vIFRvIGlkZW50aWZ5IFJERiogcXVhZCBjb21wb25lbnRzLCB3ZSBlc2NhcGUgcXVvdGVzIGJ5IGRvdWJsaW5nIHRoZW0uXG4gICAgICAvLyBUaGlzIGF2b2lkcyB0aGUgb3ZlcmhlYWQgb2YgYmFja3NsYXNoIHBhcnNpbmcgb2YgVHVydGxlLWxpa2Ugc3ludGF4ZXMuXG4gICAgICByZXR1cm4gYDw8JHtlc2NhcGVRdW90ZXModGVybVRvSWQodGVybS5zdWJqZWN0KSl9ICR7ZXNjYXBlUXVvdGVzKHRlcm1Ub0lkKHRlcm0ucHJlZGljYXRlKSl9ICR7ZXNjYXBlUXVvdGVzKHRlcm1Ub0lkKHRlcm0ub2JqZWN0KSl9JHsoMCwgX04zVXRpbC5pc0RlZmF1bHRHcmFwaCkodGVybS5ncmFwaCkgPyAnJyA6IGAgJHt0ZXJtVG9JZCh0ZXJtLmdyYXBoKX1gfT4+YDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdGVybVR5cGU6ICcgKyB0ZXJtLnRlcm1UeXBlKTtcbiAgfVxufSAvLyAjIyBRdWFkIGNvbnN0cnVjdG9yXG5cblxuY2xhc3MgUXVhZCBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICBzdXBlcignJyk7XG4gICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGggfHwgREVGQVVMVEdSQVBIO1xuICB9IC8vICMjIyBUaGUgdGVybSB0eXBlIG9mIHRoaXMgdGVybVxuXG5cbiAgZ2V0IHRlcm1UeXBlKCkge1xuICAgIHJldHVybiAnUXVhZCc7XG4gIH0gLy8gIyMjIFJldHVybnMgYSBwbGFpbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBxdWFkXG5cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlcm1UeXBlOiB0aGlzLnRlcm1UeXBlLFxuICAgICAgc3ViamVjdDogdGhpcy5zdWJqZWN0LnRvSlNPTigpLFxuICAgICAgcHJlZGljYXRlOiB0aGlzLnByZWRpY2F0ZS50b0pTT04oKSxcbiAgICAgIG9iamVjdDogdGhpcy5vYmplY3QudG9KU09OKCksXG4gICAgICBncmFwaDogdGhpcy5ncmFwaC50b0pTT04oKVxuICAgIH07XG4gIH0gLy8gIyMjIFJldHVybnMgd2hldGhlciB0aGlzIG9iamVjdCByZXByZXNlbnRzIHRoZSBzYW1lIHF1YWQgYXMgdGhlIG90aGVyXG5cblxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gISFvdGhlciAmJiB0aGlzLnN1YmplY3QuZXF1YWxzKG90aGVyLnN1YmplY3QpICYmIHRoaXMucHJlZGljYXRlLmVxdWFscyhvdGhlci5wcmVkaWNhdGUpICYmIHRoaXMub2JqZWN0LmVxdWFscyhvdGhlci5vYmplY3QpICYmIHRoaXMuZ3JhcGguZXF1YWxzKG90aGVyLmdyYXBoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuVHJpcGxlID0gZXhwb3J0cy5RdWFkID0gUXVhZDtcblxuLy8gIyMjIEVzY2FwZXMgdGhlIHF1b3RlcyB3aXRoaW4gdGhlIGdpdmVuIGxpdGVyYWxcbmZ1bmN0aW9uIGVzY2FwZVF1b3RlcyhpZCkge1xuICByZXR1cm4gaWQucmVwbGFjZShlc2NhcGVkTGl0ZXJhbCwgKF8sIHF1b3RlZCkgPT4gYFwiJHtxdW90ZWQucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1gKTtcbn0gLy8gIyMjIFVuZXNjYXBlcyB0aGUgcXVvdGVzIHdpdGhpbiB0aGUgZ2l2ZW4gbGl0ZXJhbFxuXG5cbmZ1bmN0aW9uIHVuZXNjYXBlUXVvdGVzKGlkKSB7XG4gIHJldHVybiBpZC5yZXBsYWNlKGVzY2FwZWRMaXRlcmFsLCAoXywgcXVvdGVkKSA9PiBgXCIke3F1b3RlZC5yZXBsYWNlKC9cIlwiL2csICdcIicpfWApO1xufSAvLyAjIyMgQ3JlYXRlcyBhbiBJUklcblxuXG5mdW5jdGlvbiBuYW1lZE5vZGUoaXJpKSB7XG4gIHJldHVybiBuZXcgTmFtZWROb2RlKGlyaSk7XG59IC8vICMjIyBDcmVhdGVzIGEgYmxhbmsgbm9kZVxuXG5cbmZ1bmN0aW9uIGJsYW5rTm9kZShuYW1lKSB7XG4gIHJldHVybiBuZXcgQmxhbmtOb2RlKG5hbWUgfHwgYG4zLSR7X2JsYW5rTm9kZUNvdW50ZXIrK31gKTtcbn0gLy8gIyMjIENyZWF0ZXMgYSBsaXRlcmFsXG5cblxuZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSwgbGFuZ3VhZ2VPckRhdGFUeXBlKSB7XG4gIC8vIENyZWF0ZSBhIGxhbmd1YWdlLXRhZ2dlZCBzdHJpbmdcbiAgaWYgKHR5cGVvZiBsYW5ndWFnZU9yRGF0YVR5cGUgPT09ICdzdHJpbmcnKSByZXR1cm4gbmV3IExpdGVyYWwoJ1wiJyArIHZhbHVlICsgJ1wiQCcgKyBsYW5ndWFnZU9yRGF0YVR5cGUudG9Mb3dlckNhc2UoKSk7IC8vIEF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIGRhdGF0eXBlIGZvciBib29sZWFucyBhbmQgbnVtYmVyc1xuXG4gIGxldCBkYXRhdHlwZSA9IGxhbmd1YWdlT3JEYXRhVHlwZSA/IGxhbmd1YWdlT3JEYXRhVHlwZS52YWx1ZSA6ICcnO1xuXG4gIGlmIChkYXRhdHlwZSA9PT0gJycpIHtcbiAgICAvLyBDb252ZXJ0IGEgYm9vbGVhblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgZGF0YXR5cGUgPSB4c2QuYm9vbGVhbjsgLy8gQ29udmVydCBhbiBpbnRlZ2VyIG9yIGRvdWJsZVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIGRhdGF0eXBlID0gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgPyB4c2QuaW50ZWdlciA6IHhzZC5kb3VibGU7ZWxzZSB7XG4gICAgICAgICAgZGF0YXR5cGUgPSB4c2QuZG91YmxlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHZhbHVlKSkgdmFsdWUgPSB2YWx1ZSA+IDAgPyAnSU5GJyA6ICctSU5GJztcbiAgICAgICAgfVxuICAgICAgfVxuICB9IC8vIENyZWF0ZSBhIGRhdGF0eXBlZCBsaXRlcmFsXG5cblxuICByZXR1cm4gZGF0YXR5cGUgPT09ICcnIHx8IGRhdGF0eXBlID09PSB4c2Quc3RyaW5nID8gbmV3IExpdGVyYWwoJ1wiJyArIHZhbHVlICsgJ1wiJykgOiBuZXcgTGl0ZXJhbCgnXCInICsgdmFsdWUgKyAnXCJeXicgKyBkYXRhdHlwZSk7XG59IC8vICMjIyBDcmVhdGVzIGEgdmFyaWFibGVcblxuXG5mdW5jdGlvbiB2YXJpYWJsZShuYW1lKSB7XG4gIHJldHVybiBuZXcgVmFyaWFibGUobmFtZSk7XG59IC8vICMjIyBSZXR1cm5zIHRoZSBkZWZhdWx0IGdyYXBoXG5cblxuZnVuY3Rpb24gZGVmYXVsdEdyYXBoKCkge1xuICByZXR1cm4gREVGQVVMVEdSQVBIO1xufSAvLyAjIyMgQ3JlYXRlcyBhIHF1YWRcblxuXG5mdW5jdGlvbiBxdWFkKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICByZXR1cm4gbmV3IFF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9JUklzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9JUklzXCIpKTtcblxudmFyIF9xdWV1ZU1pY3JvdGFzayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInF1ZXVlLW1pY3JvdGFza1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqTjNMZXhlcioqIHRva2VuaXplcyBOMyBkb2N1bWVudHMuXG5jb25zdCB7XG4gIHhzZFxufSA9IF9JUklzLmRlZmF1bHQ7IC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgcmVwbGFjZW1lbnQgc3RyaW5nIHRvIGVzY2FwZSBOMyBzdHJpbmdzXG5cbnZhciBlc2NhcGVTZXF1ZW5jZSA9IC9cXFxcdShbYS1mQS1GMC05XXs0fSl8XFxcXFUoW2EtZkEtRjAtOV17OH0pfFxcXFwoW15dKS9nO1xudmFyIGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gIFwiJ1wiOiBcIidcIixcbiAgJ1wiJzogJ1wiJyxcbiAgJ24nOiAnXFxuJyxcbiAgJ3InOiAnXFxyJyxcbiAgJ3QnOiAnXFx0JyxcbiAgJ2YnOiAnXFxmJyxcbiAgJ2InOiAnXFxiJyxcbiAgJ18nOiAnXycsXG4gICd+JzogJ34nLFxuICAnLic6ICcuJyxcbiAgJy0nOiAnLScsXG4gICchJzogJyEnLFxuICAnJCc6ICckJyxcbiAgJyYnOiAnJicsXG4gICcoJzogJygnLFxuICAnKSc6ICcpJyxcbiAgJyonOiAnKicsXG4gICcrJzogJysnLFxuICAnLCc6ICcsJyxcbiAgJzsnOiAnOycsXG4gICc9JzogJz0nLFxuICAnLyc6ICcvJyxcbiAgJz8nOiAnPycsXG4gICcjJzogJyMnLFxuICAnQCc6ICdAJyxcbiAgJyUnOiAnJSdcbn07XG52YXIgaWxsZWdhbElyaUNoYXJzID0gL1tcXHgwMC1cXHgyMDw+XFxcXFwiXFx7XFx9XFx8XFxeXFxgXS87XG52YXIgbGluZU1vZGVSZWdFeHBzID0ge1xuICBfaXJpOiB0cnVlLFxuICBfdW5lc2NhcGVkSXJpOiB0cnVlLFxuICBfc2ltcGxlUXVvdGVkU3RyaW5nOiB0cnVlLFxuICBfbGFuZ2NvZGU6IHRydWUsXG4gIF9ibGFuazogdHJ1ZSxcbiAgX25ld2xpbmU6IHRydWUsXG4gIF9jb21tZW50OiB0cnVlLFxuICBfd2hpdGVzcGFjZTogdHJ1ZSxcbiAgX2VuZE9mRmlsZTogdHJ1ZVxufTtcbnZhciBpbnZhbGlkUmVnRXhwID0gLyQwXi87IC8vICMjIENvbnN0cnVjdG9yXG5cbmNsYXNzIE4zTGV4ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLy8gIyMgUmVndWxhciBleHByZXNzaW9uc1xuICAgIC8vIEl0J3Mgc2xpZ2h0bHkgZmFzdGVyIHRvIGhhdmUgdGhlc2UgYXMgcHJvcGVydGllcyB0aGFuIGFzIGluLXNjb3BlIHZhcmlhYmxlc1xuICAgIHRoaXMuX2lyaSA9IC9ePCgoPzpbXiA8Pnt9XFxcXF18XFxcXFt1VV0pKyk+WyBcXHRdKi87IC8vIElSSSB3aXRoIGVzY2FwZSBzZXF1ZW5jZXM7IG5lZWRzIHNhbml0eSBjaGVjayBhZnRlciB1bmVzY2FwaW5nXG5cbiAgICB0aGlzLl91bmVzY2FwZWRJcmkgPSAvXjwoW15cXHgwMC1cXHgyMDw+XFxcXFwiXFx7XFx9XFx8XFxeXFxgXSopPlsgXFx0XSovOyAvLyBJUkkgd2l0aG91dCBlc2NhcGUgc2VxdWVuY2VzOyBubyB1bmVzY2FwaW5nXG5cbiAgICB0aGlzLl9zaW1wbGVRdW90ZWRTdHJpbmcgPSAvXlwiKFteXCJcXFxcXFxyXFxuXSopXCIoPz1bXlwiXSkvOyAvLyBzdHJpbmcgd2l0aG91dCBlc2NhcGUgc2VxdWVuY2VzXG5cbiAgICB0aGlzLl9zaW1wbGVBcG9zdHJvcGhlU3RyaW5nID0gL14nKFteJ1xcXFxcXHJcXG5dKiknKD89W14nXSkvO1xuICAgIHRoaXMuX2xhbmdjb2RlID0gL15AKFthLXpdKyg/Oi1bYS16MC05XSspKikoPz1bXmEtejAtOVxcLV0pL2k7XG4gICAgdGhpcy5fcHJlZml4ID0gL14oKD86W0EtWmEtelxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmZmXFx1MDM3MC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl0pKD86XFwuP1tcXC0wLTlBLVpfYS16XFx4YjdcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl0pKik/Oig/PVsjXFxzPF0pLztcbiAgICB0aGlzLl9wcmVmaXhlZCA9IC9eKCg/OltBLVphLXpcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSg/OlxcLj9bXFwtMC05QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSopPzooKD86KD86WzAtOkEtWl9hLXpcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdfCVbMC05YS1mQS1GXXsyfXxcXFxcWyEjLVxcLzs9P1xcLUBffl0pKD86KD86W1xcLlxcLTAtOkEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXXwlWzAtOWEtZkEtRl17Mn18XFxcXFshIy1cXC87PT9cXC1AX35dKSooPzpbXFwtMC06QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdfCVbMC05YS1mQS1GXXsyfXxcXFxcWyEjLVxcLzs9P1xcLUBffl0pKT8pPykoPzpbIFxcdF0rfCg/PVxcLj9bLDshXFxeXFxzIygpXFxbXFxdXFx7XFx9XCInPD5dKSkvO1xuICAgIHRoaXMuX3ZhcmlhYmxlID0gL15cXD8oPzooPzpbQS1aX2EtelxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmZmXFx1MDM3MC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl0pKD86W1xcLTAtOkEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKSg/PVsuLDshXFxeXFxzIygpXFxbXFxdXFx7XFx9XCInPD5dKS87XG4gICAgdGhpcy5fYmxhbmsgPSAvXl86KCg/OlswLTlBLVpfYS16XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkoPzpcXC4/W1xcLTAtOUEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKSg/OlsgXFx0XSt8KD89XFwuP1ssOzpcXHMjKClcXFtcXF1cXHtcXH1cIic8Pl0pKS87XG4gICAgdGhpcy5fbnVtYmVyID0gL15bXFwtK10/KD86KFxcZCtcXC5cXGQqfFxcLj9cXGQrKVtlRV1bXFwtK10/fFxcZCooXFwuKT8pXFxkKyg/PVxcLj9bLDs6XFxzIygpXFxbXFxdXFx7XFx9XCInPD5dKS87XG4gICAgdGhpcy5fYm9vbGVhbiA9IC9eKD86dHJ1ZXxmYWxzZSkoPz1bLiw7XFxzIygpXFxbXFxdXFx7XFx9XCInPD5dKS87XG4gICAgdGhpcy5fa2V5d29yZCA9IC9eQFthLXpdKyg/PVtcXHMjPDpdKS9pO1xuICAgIHRoaXMuX3NwYXJxbEtleXdvcmQgPSAvXig/OlBSRUZJWHxCQVNFfEdSQVBIKSg/PVtcXHMjPF0pL2k7XG4gICAgdGhpcy5fc2hvcnRQcmVkaWNhdGVzID0gL15hKD89W1xccygpXFxbXFxdXFx7XFx9XCInPD5dKS87XG4gICAgdGhpcy5fbmV3bGluZSA9IC9eWyBcXHRdKig/OiNbXlxcblxccl0qKT8oPzpcXHJcXG58XFxufFxccilbIFxcdF0qLztcbiAgICB0aGlzLl9jb21tZW50ID0gLyMoW15cXG5cXHJdKikvO1xuICAgIHRoaXMuX3doaXRlc3BhY2UgPSAvXlsgXFx0XSsvO1xuICAgIHRoaXMuX2VuZE9mRmlsZSA9IC9eKD86I1teXFxuXFxyXSopPyQvO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBJbiBsaW5lIG1vZGUgKE4tVHJpcGxlcyBvciBOLVF1YWRzKSwgb25seSBzaW1wbGUgZmVhdHVyZXMgbWF5IGJlIHBhcnNlZFxuXG4gICAgaWYgKHRoaXMuX2xpbmVNb2RlID0gISFvcHRpb25zLmxpbmVNb2RlKSB7XG4gICAgICB0aGlzLl9uM01vZGUgPSBmYWxzZTsgLy8gRG9uJ3QgdG9rZW5pemUgc3BlY2lhbCBsaXRlcmFsc1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuICAgICAgICBpZiAoIShrZXkgaW4gbGluZU1vZGVSZWdFeHBzKSAmJiB0aGlzW2tleV0gaW5zdGFuY2VvZiBSZWdFeHApIHRoaXNba2V5XSA9IGludmFsaWRSZWdFeHA7XG4gICAgICB9XG4gICAgfSAvLyBXaGVuIG5vdCBpbiBsaW5lIG1vZGUsIGVuYWJsZSBOMyBmdW5jdGlvbmFsaXR5IGJ5IGRlZmF1bHRcbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fbjNNb2RlID0gb3B0aW9ucy5uMyAhPT0gZmFsc2U7XG4gICAgICB9IC8vIERvbid0IG91dHB1dCBjb21tZW50IHRva2VucyBieSBkZWZhdWx0XG5cblxuICAgIHRoaXMuX2NvbW1lbnRzID0gISFvcHRpb25zLmNvbW1lbnRzOyAvLyBDYWNoZSB0aGUgbGFzdCB0ZXN0ZWQgY2xvc2luZyBwb3NpdGlvbiBvZiBsb25nIGxpdGVyYWxzXG5cbiAgICB0aGlzLl9saXRlcmFsQ2xvc2luZ1BvcyA9IDA7XG4gIH0gLy8gIyMgUHJpdmF0ZSBtZXRob2RzXG4gIC8vICMjIyBgX3Rva2VuaXplVG9FbmRgIHRva2VuaXplcyBhcyBmb3IgYXMgcG9zc2libGUsIGVtaXR0aW5nIHRva2VucyB0aHJvdWdoIHRoZSBjYWxsYmFja1xuXG5cbiAgX3Rva2VuaXplVG9FbmQoY2FsbGJhY2ssIGlucHV0RmluaXNoZWQpIHtcbiAgICAvLyBDb250aW51ZSBwYXJzaW5nIGFzIGZhciBhcyBwb3NzaWJsZTsgdGhlIGxvb3Agd2lsbCByZXR1cm4gZXZlbnR1YWxseVxuICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0LFxuICAgICAgICBvdXRwdXRDb21tZW50cyA9IHRoaXMuX2NvbW1lbnRzO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIENvdW50IGFuZCBza2lwIHdoaXRlc3BhY2UgbGluZXNcbiAgICAgIHZhciB3aGl0ZVNwYWNlTWF0Y2gsIGNvbW1lbnQ7XG5cbiAgICAgIHdoaWxlICh3aGl0ZVNwYWNlTWF0Y2ggPSB0aGlzLl9uZXdsaW5lLmV4ZWMoaW5wdXQpKSB7XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIGEgY29tbWVudFxuICAgICAgICBpZiAob3V0cHV0Q29tbWVudHMgJiYgKGNvbW1lbnQgPSB0aGlzLl9jb21tZW50LmV4ZWMod2hpdGVTcGFjZU1hdGNoWzBdKSkpIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICBsaW5lOiB0aGlzLl9saW5lLFxuICAgICAgICAgIHR5cGU6ICdjb21tZW50JyxcbiAgICAgICAgICB2YWx1ZTogY29tbWVudFsxXSxcbiAgICAgICAgICBwcmVmaXg6ICcnXG4gICAgICAgIH0pOyAvLyBBZHZhbmNlIHRoZSBpbnB1dFxuXG4gICAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyKHdoaXRlU3BhY2VNYXRjaFswXS5sZW5ndGgsIGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX2xpbmUrKztcbiAgICAgIH0gLy8gU2tpcCB3aGl0ZXNwYWNlIG9uIGN1cnJlbnQgbGluZVxuXG5cbiAgICAgIGlmICghd2hpdGVTcGFjZU1hdGNoICYmICh3aGl0ZVNwYWNlTWF0Y2ggPSB0aGlzLl93aGl0ZXNwYWNlLmV4ZWMoaW5wdXQpKSkgaW5wdXQgPSBpbnB1dC5zdWJzdHIod2hpdGVTcGFjZU1hdGNoWzBdLmxlbmd0aCwgaW5wdXQubGVuZ3RoKTsgLy8gU3RvcCBmb3Igbm93IGlmIHdlJ3JlIGF0IHRoZSBlbmRcblxuICAgICAgaWYgKHRoaXMuX2VuZE9mRmlsZS50ZXN0KGlucHV0KSkge1xuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgZmluaXNoZWQsIGVtaXQgRU9GXG4gICAgICAgIGlmIChpbnB1dEZpbmlzaGVkKSB7XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBmaW5hbCBjb21tZW50XG4gICAgICAgICAgaWYgKG91dHB1dENvbW1lbnRzICYmIChjb21tZW50ID0gdGhpcy5fY29tbWVudC5leGVjKGlucHV0KSkpIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIGxpbmU6IHRoaXMuX2xpbmUsXG4gICAgICAgICAgICB0eXBlOiAnY29tbWVudCcsXG4gICAgICAgICAgICB2YWx1ZTogY29tbWVudFsxXSxcbiAgICAgICAgICAgIHByZWZpeDogJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjYWxsYmFjayhpbnB1dCA9IG51bGwsIHtcbiAgICAgICAgICAgIGxpbmU6IHRoaXMuX2xpbmUsXG4gICAgICAgICAgICB0eXBlOiAnZW9mJyxcbiAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgIHByZWZpeDogJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgfSAvLyBMb29rIGZvciBzcGVjaWZpYyB0b2tlbiB0eXBlcyBiYXNlZCBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyXG5cblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLl9saW5lLFxuICAgICAgICAgIHR5cGUgPSAnJyxcbiAgICAgICAgICB2YWx1ZSA9ICcnLFxuICAgICAgICAgIHByZWZpeCA9ICcnLFxuICAgICAgICAgIGZpcnN0Q2hhciA9IGlucHV0WzBdLFxuICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICBtYXRjaExlbmd0aCA9IDAsXG4gICAgICAgICAgaW5jb25jbHVzaXZlID0gZmFsc2U7XG5cbiAgICAgIHN3aXRjaCAoZmlyc3RDaGFyKSB7XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIC8vIFdlIG5lZWQgYXQgbGVhc3QgMyB0b2tlbnMgbG9va2FoZWFkIHRvIGRpc3Rpbmd1aXNoIF5ePElSST4gYW5kIF5ecHJlOmZpeGVkXG4gICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA8IDMpIGJyZWFrOyAvLyBUcnkgdG8gbWF0Y2ggYSB0eXBlXG4gICAgICAgICAgZWxzZSBpZiAoaW5wdXRbMV0gPT09ICdeJykge1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c01hcmtlciA9ICdeXic7IC8vIE1vdmUgdG8gdHlwZSBJUkkgb3IgcHJlZml4ZWQgbmFtZVxuXG4gICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyKDIpO1xuXG4gICAgICAgICAgICAgIGlmIChpbnB1dFswXSAhPT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgaW5jb25jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBJZiBubyB0eXBlLCBpdCBtdXN0IGJlIGEgcGF0aCBleHByZXNzaW9uXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbjNNb2RlKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaExlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICB0eXBlID0gJ14nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCBpbiBjYXNlIHRoZSB0eXBlIGlzIGFuIElSSVxuXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGEgZnVsbCBJUkkgd2l0aG91dCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgaWYgKG1hdGNoID0gdGhpcy5fdW5lc2NhcGVkSXJpLmV4ZWMoaW5wdXQpKSB0eXBlID0gJ0lSSScsIHZhbHVlID0gbWF0Y2hbMV07IC8vIFRyeSB0byBmaW5kIGEgZnVsbCBJUkkgd2l0aCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgZWxzZSBpZiAobWF0Y2ggPSB0aGlzLl9pcmkuZXhlYyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl91bmVzY2FwZShtYXRjaFsxXSk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpbGxlZ2FsSXJpQ2hhcnMudGVzdCh2YWx1ZSkpIHJldHVybiByZXBvcnRTeW50YXhFcnJvcih0aGlzKTtcbiAgICAgICAgICAgICAgdHlwZSA9ICdJUkknO1xuICAgICAgICAgICAgfSAvLyBUcnkgdG8gZmluZCBhIG5lc3RlZCB0cmlwbGVcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0Lmxlbmd0aCA+IDEgJiYgaW5wdXRbMV0gPT09ICc8JykgdHlwZSA9ICc8PCcsIG1hdGNoTGVuZ3RoID0gMjsgLy8gVHJ5IHRvIGZpbmQgYSBiYWNrd2FyZHMgaW1wbGljYXRpb24gYXJyb3dcbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fbjNNb2RlICYmIGlucHV0Lmxlbmd0aCA+IDEgJiYgaW5wdXRbMV0gPT09ICc9JykgdHlwZSA9ICdpbnZlcnNlJywgbWF0Y2hMZW5ndGggPSAyLCB2YWx1ZSA9ICc+JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMSAmJiBpbnB1dFsxXSA9PT0gJz4nKSB0eXBlID0gJz4+JywgbWF0Y2hMZW5ndGggPSAyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ18nOlxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGEgYmxhbmsgbm9kZS4gU2luY2UgaXQgY2FuIGNvbnRhaW4gKGJ1dCBub3QgZW5kIHdpdGgpIGEgZG90LFxuICAgICAgICAgIC8vIHdlIGFsd2F5cyBuZWVkIGEgbm9uLWRvdCBjaGFyYWN0ZXIgYmVmb3JlIGRlY2lkaW5nIGl0IGlzIGEgYmxhbmsgbm9kZS5cbiAgICAgICAgICAvLyBUaGVyZWZvcmUsIHRyeSBpbnNlcnRpbmcgYSBzcGFjZSBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgICBpZiAoKG1hdGNoID0gdGhpcy5fYmxhbmsuZXhlYyhpbnB1dCkpIHx8IGlucHV0RmluaXNoZWQgJiYgKG1hdGNoID0gdGhpcy5fYmxhbmsuZXhlYyhpbnB1dCArICcgJykpKSB0eXBlID0gJ2JsYW5rJywgcHJlZml4ID0gJ18nLCB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhIGxpdGVyYWwgd2l0aG91dCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgaWYgKG1hdGNoID0gdGhpcy5fc2ltcGxlUXVvdGVkU3RyaW5nLmV4ZWMoaW5wdXQpKSB2YWx1ZSA9IG1hdGNoWzFdOyAvLyBUcnkgdG8gZmluZCBhIGxpdGVyYWwgd3JhcHBlZCBpbiB0aHJlZSBwYWlycyBvZiBxdW90ZXNcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgKHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBtYXRjaExlbmd0aFxuICAgICAgICAgICAgICB9ID0gdGhpcy5fcGFyc2VMaXRlcmFsKGlucHV0KSk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHJlcG9ydFN5bnRheEVycm9yKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsIHx8IG1hdGNoTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0eXBlID0gJ2xpdGVyYWwnO1xuICAgICAgICAgICAgdGhpcy5fbGl0ZXJhbENsb3NpbmdQb3MgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgaWYgKCF0aGlzLl9saW5lTW9kZSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBsaXRlcmFsIHdpdGhvdXQgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgaWYgKG1hdGNoID0gdGhpcy5fc2ltcGxlQXBvc3Ryb3BoZVN0cmluZy5leGVjKGlucHV0KSkgdmFsdWUgPSBtYXRjaFsxXTsgLy8gVHJ5IHRvIGZpbmQgYSBsaXRlcmFsIHdyYXBwZWQgaW4gdGhyZWUgcGFpcnMgb2YgcXVvdGVzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoe1xuICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICBtYXRjaExlbmd0aFxuICAgICAgICAgICAgICAgIH0gPSB0aGlzLl9wYXJzZUxpdGVyYWwoaW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiByZXBvcnRTeW50YXhFcnJvcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgfHwgbWF0Y2hMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgdHlwZSA9ICdsaXRlcmFsJztcbiAgICAgICAgICAgICAgdGhpcy5fbGl0ZXJhbENsb3NpbmdQb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGEgdmFyaWFibGVcbiAgICAgICAgICBpZiAodGhpcy5fbjNNb2RlICYmIChtYXRjaCA9IHRoaXMuX3ZhcmlhYmxlLmV4ZWMoaW5wdXQpKSkgdHlwZSA9ICd2YXInLCB2YWx1ZSA9IG1hdGNoWzBdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0AnOlxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGEgbGFuZ3VhZ2UgY29kZVxuICAgICAgICAgIGlmICh0aGlzLl9wcmV2aW91c01hcmtlciA9PT0gJ2xpdGVyYWwnICYmIChtYXRjaCA9IHRoaXMuX2xhbmdjb2RlLmV4ZWMoaW5wdXQpKSkgdHlwZSA9ICdsYW5nY29kZScsIHZhbHVlID0gbWF0Y2hbMV07IC8vIFRyeSB0byBmaW5kIGEga2V5d29yZFxuICAgICAgICAgIGVsc2UgaWYgKG1hdGNoID0gdGhpcy5fa2V5d29yZC5leGVjKGlucHV0KSkgdHlwZSA9IG1hdGNoWzBdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGEgZG90IGFzIHB1bmN0dWF0aW9uXG4gICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMSA/IGlucHV0RmluaXNoZWQgOiBpbnB1dFsxXSA8ICcwJyB8fCBpbnB1dFsxXSA+ICc5Jykge1xuICAgICAgICAgICAgdHlwZSA9ICcuJztcbiAgICAgICAgICAgIG1hdGNoTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gbnVtZXJpY2FsIGNhc2UgKGNvdWxkIGJlIGEgZGVjaW1hbCBkb3QpXG5cbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzEnOlxuICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgIGNhc2UgJzQnOlxuICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgY2FzZSAnNic6XG4gICAgICAgIGNhc2UgJzcnOlxuICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhIG51bWJlci4gU2luY2UgaXQgY2FuIGNvbnRhaW4gKGJ1dCBub3QgZW5kIHdpdGgpIGEgZG90LFxuICAgICAgICAgIC8vIHdlIGFsd2F5cyBuZWVkIGEgbm9uLWRvdCBjaGFyYWN0ZXIgYmVmb3JlIGRlY2lkaW5nIGl0IGlzIGEgbnVtYmVyLlxuICAgICAgICAgIC8vIFRoZXJlZm9yZSwgdHJ5IGluc2VydGluZyBhIHNwYWNlIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICAgIGlmIChtYXRjaCA9IHRoaXMuX251bWJlci5leGVjKGlucHV0KSB8fCBpbnB1dEZpbmlzaGVkICYmIChtYXRjaCA9IHRoaXMuX251bWJlci5leGVjKGlucHV0ICsgJyAnKSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnbGl0ZXJhbCcsIHZhbHVlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICBwcmVmaXggPSB0eXBlb2YgbWF0Y2hbMV0gPT09ICdzdHJpbmcnID8geHNkLmRvdWJsZSA6IHR5cGVvZiBtYXRjaFsyXSA9PT0gJ3N0cmluZycgPyB4c2QuZGVjaW1hbCA6IHhzZC5pbnRlZ2VyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0InOlxuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgY2FzZSAncCc6XG4gICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBTUEFSUUwtc3R5bGUga2V5d29yZFxuICAgICAgICAgIGlmIChtYXRjaCA9IHRoaXMuX3NwYXJxbEtleXdvcmQuZXhlYyhpbnB1dCkpIHR5cGUgPSBtYXRjaFswXS50b1VwcGVyQ2FzZSgpO2Vsc2UgaW5jb25jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIGEgYm9vbGVhblxuICAgICAgICAgIGlmIChtYXRjaCA9IHRoaXMuX2Jvb2xlYW4uZXhlYyhpbnB1dCkpIHR5cGUgPSAnbGl0ZXJhbCcsIHZhbHVlID0gbWF0Y2hbMF0sIHByZWZpeCA9IHhzZC5ib29sZWFuO2Vsc2UgaW5jb25jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhbiBhYmJyZXZpYXRlZCBwcmVkaWNhdGVcbiAgICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLl9zaG9ydFByZWRpY2F0ZXMuZXhlYyhpbnB1dCkpIHR5cGUgPSAnYWJicmV2aWF0aW9uJywgdmFsdWUgPSAnYSc7ZWxzZSBpbmNvbmNsdXNpdmUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGFuIGltcGxpY2F0aW9uIGFycm93IG9yIGVxdWFscyBzaWduXG4gICAgICAgICAgaWYgKHRoaXMuX24zTW9kZSAmJiBpbnB1dC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0eXBlID0gJ2FiYnJldmlhdGlvbic7XG4gICAgICAgICAgICBpZiAoaW5wdXRbMV0gIT09ICc+JykgbWF0Y2hMZW5ndGggPSAxLCB2YWx1ZSA9ICc9JztlbHNlIG1hdGNoTGVuZ3RoID0gMiwgdmFsdWUgPSAnPic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgaWYgKCF0aGlzLl9uM01vZGUpIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgIGNhc2UgJ10nOlxuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICBpZiAoIXRoaXMuX2xpbmVNb2RlKSB7XG4gICAgICAgICAgICBtYXRjaExlbmd0aCA9IDE7XG4gICAgICAgICAgICB0eXBlID0gZmlyc3RDaGFyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaW5jb25jbHVzaXZlID0gdHJ1ZTtcbiAgICAgIH0gLy8gU29tZSBmaXJzdCBjaGFyYWN0ZXJzIGRvIG5vdCBhbGxvdyBhbiBpbW1lZGlhdGUgZGVjaXNpb24sIHNvIGluc3BlY3QgbW9yZVxuXG5cbiAgICAgIGlmIChpbmNvbmNsdXNpdmUpIHtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBwcmVmaXhcbiAgICAgICAgaWYgKCh0aGlzLl9wcmV2aW91c01hcmtlciA9PT0gJ0BwcmVmaXgnIHx8IHRoaXMuX3ByZXZpb3VzTWFya2VyID09PSAnUFJFRklYJykgJiYgKG1hdGNoID0gdGhpcy5fcHJlZml4LmV4ZWMoaW5wdXQpKSkgdHlwZSA9ICdwcmVmaXgnLCB2YWx1ZSA9IG1hdGNoWzFdIHx8ICcnOyAvLyBUcnkgdG8gZmluZCBhIHByZWZpeGVkIG5hbWUuIFNpbmNlIGl0IGNhbiBjb250YWluIChidXQgbm90IGVuZCB3aXRoKSBhIGRvdCxcbiAgICAgICAgLy8gd2UgYWx3YXlzIG5lZWQgYSBub24tZG90IGNoYXJhY3RlciBiZWZvcmUgZGVjaWRpbmcgaXQgaXMgYSBwcmVmaXhlZCBuYW1lLlxuICAgICAgICAvLyBUaGVyZWZvcmUsIHRyeSBpbnNlcnRpbmcgYSBzcGFjZSBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgZWxzZSBpZiAoKG1hdGNoID0gdGhpcy5fcHJlZml4ZWQuZXhlYyhpbnB1dCkpIHx8IGlucHV0RmluaXNoZWQgJiYgKG1hdGNoID0gdGhpcy5fcHJlZml4ZWQuZXhlYyhpbnB1dCArICcgJykpKSB0eXBlID0gJ3ByZWZpeGVkJywgcHJlZml4ID0gbWF0Y2hbMV0gfHwgJycsIHZhbHVlID0gdGhpcy5fdW5lc2NhcGUobWF0Y2hbMl0pO1xuICAgICAgfSAvLyBBIHR5cGUgdG9rZW4gaXMgc3BlY2lhbDogaXQgY2FuIG9ubHkgYmUgZW1pdHRlZCBhZnRlciBhbiBJUkkgb3IgcHJlZml4ZWQgbmFtZSBpcyByZWFkXG5cblxuICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzTWFya2VyID09PSAnXl4nKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3ByZWZpeGVkJzpcbiAgICAgICAgICAgIHR5cGUgPSAndHlwZSc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0lSSSc6XG4gICAgICAgICAgICB0eXBlID0gJ3R5cGVJUkknO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdHlwZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdoYXQgaWYgbm90aGluZyBvZiB0aGUgYWJvdmUgd2FzIGZvdW5kP1xuXG5cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAvLyBXZSBjb3VsZCBiZSBpbiBzdHJlYW1pbmcgbW9kZSwgYW5kIHRoZW4gd2UganVzdCB3YWl0IGZvciBtb3JlIGlucHV0IHRvIGFycml2ZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhIHN5bnRheCBlcnJvciBoYXMgb2NjdXJyZWQgaW4gdGhlIGlucHV0LlxuICAgICAgICAvLyBPbmUgZXhjZXB0aW9uOiBlcnJvciBvbiBhbiB1bmFjY291bnRlZCBsaW5lYnJlYWsgKD0gbm90IGluc2lkZSBhIHRyaXBsZS1xdW90ZWQgbGl0ZXJhbCkuXG4gICAgICAgIGlmIChpbnB1dEZpbmlzaGVkIHx8ICEvXicnJ3xeXCJcIlwiLy50ZXN0KGlucHV0KSAmJiAvXFxufFxcci8udGVzdChpbnB1dCkpIHJldHVybiByZXBvcnRTeW50YXhFcnJvcih0aGlzKTtlbHNlIHJldHVybiB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgfSAvLyBFbWl0IHRoZSBwYXJzZWQgdG9rZW5cblxuXG4gICAgICB2YXIgdG9rZW4gPSB7XG4gICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgIH07XG4gICAgICBjYWxsYmFjayhudWxsLCB0b2tlbik7XG4gICAgICB0aGlzLnByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICAgIHRoaXMuX3ByZXZpb3VzTWFya2VyID0gdHlwZTsgLy8gQWR2YW5jZSB0byBuZXh0IHBhcnQgdG8gdG9rZW5pemVcblxuICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIobWF0Y2hMZW5ndGggfHwgbWF0Y2hbMF0ubGVuZ3RoLCBpbnB1dC5sZW5ndGgpO1xuICAgIH0gLy8gU2lnbmFscyB0aGUgc3ludGF4IGVycm9yIHRocm91Z2ggdGhlIGNhbGxiYWNrXG5cblxuICAgIGZ1bmN0aW9uIHJlcG9ydFN5bnRheEVycm9yKHNlbGYpIHtcbiAgICAgIGNhbGxiYWNrKHNlbGYuX3N5bnRheEVycm9yKC9eXFxTKi8uZXhlYyhpbnB1dClbMF0pKTtcbiAgICB9XG4gIH0gLy8gIyMjIGBfdW5lc2NhcGVgIHJlcGxhY2VzIE4zIGVzY2FwZSBjb2RlcyBieSB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnNcblxuXG4gIF91bmVzY2FwZShpdGVtKSB7XG4gICAgbGV0IGludmFsaWQgPSBmYWxzZTtcbiAgICBjb25zdCByZXBsYWNlZCA9IGl0ZW0ucmVwbGFjZShlc2NhcGVTZXF1ZW5jZSwgKHNlcXVlbmNlLCB1bmljb2RlNCwgdW5pY29kZTgsIGVzY2FwZWRDaGFyKSA9PiB7XG4gICAgICAvLyA0LWRpZ2l0IHVuaWNvZGUgY2hhcmFjdGVyXG4gICAgICBpZiAodHlwZW9mIHVuaWNvZGU0ID09PSAnc3RyaW5nJykgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoTnVtYmVyLnBhcnNlSW50KHVuaWNvZGU0LCAxNikpOyAvLyA4LWRpZ2l0IHVuaWNvZGUgY2hhcmFjdGVyXG5cbiAgICAgIGlmICh0eXBlb2YgdW5pY29kZTggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBjaGFyQ29kZSA9IE51bWJlci5wYXJzZUludCh1bmljb2RlOCwgMTYpO1xuICAgICAgICByZXR1cm4gY2hhckNvZGUgPD0gMHhGRkZGID8gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIucGFyc2VJbnQodW5pY29kZTgsIDE2KSkgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArICgoY2hhckNvZGUgLT0gMHgxMDAwMCkgPj4gMTApLCAweERDMDAgKyAoY2hhckNvZGUgJiAweDNGRikpO1xuICAgICAgfSAvLyBmaXhlZCBlc2NhcGUgc2VxdWVuY2VcblxuXG4gICAgICBpZiAoZXNjYXBlZENoYXIgaW4gZXNjYXBlUmVwbGFjZW1lbnRzKSByZXR1cm4gZXNjYXBlUmVwbGFjZW1lbnRzW2VzY2FwZWRDaGFyXTsgLy8gaW52YWxpZCBlc2NhcGUgc2VxdWVuY2VcblxuICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gICAgcmV0dXJuIGludmFsaWQgPyBudWxsIDogcmVwbGFjZWQ7XG4gIH0gLy8gIyMjIGBfcGFyc2VMaXRlcmFsYCBwYXJzZXMgYSBsaXRlcmFsIGludG8gYW4gdW5lc2NhcGVkIHZhbHVlXG5cblxuICBfcGFyc2VMaXRlcmFsKGlucHV0KSB7XG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgZW5vdWdoIGxvb2thaGVhZCB0byBpZGVudGlmeSB0cmlwbGUtcXVvdGVkIHN0cmluZ3NcbiAgICBpZiAoaW5wdXQubGVuZ3RoID49IDMpIHtcbiAgICAgIC8vIElkZW50aWZ5IHRoZSBvcGVuaW5nIHF1b3RlKHMpXG4gICAgICBjb25zdCBvcGVuaW5nID0gaW5wdXQubWF0Y2goL14oPzpcIlwiXCJ8XCJ8JycnfCd8KS8pWzBdO1xuICAgICAgY29uc3Qgb3BlbmluZ0xlbmd0aCA9IG9wZW5pbmcubGVuZ3RoOyAvLyBGaW5kIHRoZSBuZXh0IGNhbmRpZGF0ZSBjbG9zaW5nIHF1b3Rlc1xuXG4gICAgICBsZXQgY2xvc2luZ1BvcyA9IE1hdGgubWF4KHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zLCBvcGVuaW5nTGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKChjbG9zaW5nUG9zID0gaW5wdXQuaW5kZXhPZihvcGVuaW5nLCBjbG9zaW5nUG9zKSkgPiAwKSB7XG4gICAgICAgIC8vIENvdW50IGJhY2tzbGFzaGVzIHJpZ2h0IGJlZm9yZSB0aGUgY2xvc2luZyBxdW90ZXNcbiAgICAgICAgbGV0IGJhY2tzbGFzaENvdW50ID0gMDtcblxuICAgICAgICB3aGlsZSAoaW5wdXRbY2xvc2luZ1BvcyAtIGJhY2tzbGFzaENvdW50IC0gMV0gPT09ICdcXFxcJykgYmFja3NsYXNoQ291bnQrKzsgLy8gQW4gZXZlbiBudW1iZXIgb2YgYmFja3NsYXNoZXMgKGluIHBhcnRpY3VsYXIgMClcbiAgICAgICAgLy8gbWVhbnMgdGhlc2UgYXJlIGFjdHVhbCwgbm9uLWVzY2FwZWQgY2xvc2luZyBxdW90ZXNcblxuXG4gICAgICAgIGlmIChiYWNrc2xhc2hDb3VudCAlIDIgPT09IDApIHtcbiAgICAgICAgICAvLyBFeHRyYWN0IGFuZCB1bmVzY2FwZSB0aGUgdmFsdWVcbiAgICAgICAgICBjb25zdCByYXcgPSBpbnB1dC5zdWJzdHJpbmcob3BlbmluZ0xlbmd0aCwgY2xvc2luZ1Bvcyk7XG4gICAgICAgICAgY29uc3QgbGluZXMgPSByYXcuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLykubGVuZ3RoIC0gMTtcbiAgICAgICAgICBjb25zdCBtYXRjaExlbmd0aCA9IGNsb3NpbmdQb3MgKyBvcGVuaW5nTGVuZ3RoOyAvLyBPbmx5IHRyaXBsZS1xdW90ZWQgc3RyaW5ncyBjYW4gYmUgbXVsdGktbGluZVxuXG4gICAgICAgICAgaWYgKG9wZW5pbmdMZW5ndGggPT09IDEgJiYgbGluZXMgIT09IDAgfHwgb3BlbmluZ0xlbmd0aCA9PT0gMyAmJiB0aGlzLl9saW5lTW9kZSkgYnJlYWs7XG4gICAgICAgICAgdGhpcy5fbGluZSArPSBsaW5lcztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3VuZXNjYXBlKHJhdyksXG4gICAgICAgICAgICBtYXRjaExlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjbG9zaW5nUG9zKys7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zID0gaW5wdXQubGVuZ3RoIC0gb3BlbmluZ0xlbmd0aCArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIG1hdGNoTGVuZ3RoOiAwXG4gICAgfTtcbiAgfSAvLyAjIyMgYF9zeW50YXhFcnJvcmAgY3JlYXRlcyBhIHN5bnRheCBlcnJvciBmb3IgdGhlIGdpdmVuIGlzc3VlXG5cblxuICBfc3ludGF4RXJyb3IoaXNzdWUpIHtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5leHBlY3RlZCBcIicgKyBpc3N1ZSArICdcIiBvbiBsaW5lICcgKyB0aGlzLl9saW5lICsgJy4nKTtcbiAgICBlcnIuY29udGV4dCA9IHtcbiAgICAgIHRva2VuOiB1bmRlZmluZWQsXG4gICAgICBsaW5lOiB0aGlzLl9saW5lLFxuICAgICAgcHJldmlvdXNUb2tlbjogdGhpcy5wcmV2aW91c1Rva2VuXG4gICAgfTtcbiAgICByZXR1cm4gZXJyO1xuICB9IC8vICMjIFB1YmxpYyBtZXRob2RzXG4gIC8vICMjIyBgdG9rZW5pemVgIHN0YXJ0cyB0aGUgdHJhbnNmb3JtYXRpb24gb2YgYW4gTjMgZG9jdW1lbnQgaW50byBhbiBhcnJheSBvZiB0b2tlbnMuXG4gIC8vIFRoZSBpbnB1dCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBzdHJlYW0uXG5cblxuICB0b2tlbml6ZShpbnB1dCwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fbGluZSA9IDE7IC8vIElmIHRoZSBpbnB1dCBpcyBhIHN0cmluZywgY29udGludW91c2x5IGVtaXQgdG9rZW5zIHRocm91Z2ggdGhlIGNhbGxiYWNrIHVudGlsIHRoZSBlbmRcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0OyAvLyBJZiBhIGNhbGxiYWNrIHdhcyBwYXNzZWQsIGFzeW5jaHJvbm91c2x5IGNhbGwgaXRcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgKDAsIF9xdWV1ZU1pY3JvdGFzay5kZWZhdWx0KSgoKSA9PiBzZWxmLl90b2tlbml6ZVRvRW5kKGNhbGxiYWNrLCB0cnVlKSk7IC8vIElmIG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQsIHRva2VuaXplIHN5bmNocm9ub3VzbHkgYW5kIHJldHVyblxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IFtdLFxuICAgICAgICAgICAgICBlcnJvcjtcblxuICAgICAgICAgIHRoaXMuX3Rva2VuaXplVG9FbmQoZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIGUgPyBlcnJvciA9IGUgOiB0b2tlbnMucHVzaCh0KTtcbiAgICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfVxuICAgIH0gLy8gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgbXVzdCBiZSBhIHN0cmVhbVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dCA9ICcnO1xuICAgICAgICB0aGlzLl9wZW5kaW5nQnVmZmVyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5zZXRFbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykgaW5wdXQuc2V0RW5jb2RpbmcoJ3V0ZjgnKTsgLy8gQWRkcyB0aGUgZGF0YSBjaHVuayB0byB0aGUgYnVmZmVyIGFuZCBwYXJzZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG5cbiAgICAgICAgaW5wdXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGlmIChzZWxmLl9pbnB1dCAhPT0gbnVsbCAmJiBkYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gUHJlcGVuZCBhbnkgcHJldmlvdXMgcGVuZGluZyB3cml0ZXNcbiAgICAgICAgICAgIGlmIChzZWxmLl9wZW5kaW5nQnVmZmVyKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wZW5kaW5nQnVmZmVyLCBkYXRhXSk7XG4gICAgICAgICAgICAgIHNlbGYuX3BlbmRpbmdCdWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgfSAvLyBIb2xkIGlmIHRoZSBidWZmZXIgZW5kcyBpbiBhbiBpbmNvbXBsZXRlIHVuaWNvZGUgc2VxdWVuY2VcblxuXG4gICAgICAgICAgICBpZiAoZGF0YVtkYXRhLmxlbmd0aCAtIDFdICYgMHg4MCkge1xuICAgICAgICAgICAgICBzZWxmLl9wZW5kaW5nQnVmZmVyID0gZGF0YTtcbiAgICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlLCB0b2tlbml6ZSBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0ICs9IGRhdGE7XG5cbiAgICAgICAgICAgICAgICBzZWxmLl90b2tlbml6ZVRvRW5kKGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBQYXJzZXMgdW50aWwgdGhlIGVuZFxuXG4gICAgICAgIGlucHV0Lm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHNlbGYuX2lucHV0ICE9PSBudWxsKSBzZWxmLl90b2tlbml6ZVRvRW5kKGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0Lm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE4zTGV4ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfTjNMZXhlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTjNMZXhlclwiKSk7XG5cbnZhciBfTjNEYXRhRmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTjNEYXRhRmFjdG9yeVwiKSk7XG5cbnZhciBfSVJJcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vSVJJc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqTjNQYXJzZXIqKiBwYXJzZXMgTjMgZG9jdW1lbnRzLlxubGV0IGJsYW5rTm9kZVByZWZpeCA9IDA7IC8vICMjIENvbnN0cnVjdG9yXG5cbmNsYXNzIE4zUGFyc2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbnRleHRTdGFjayA9IFtdO1xuICAgIHRoaXMuX2dyYXBoID0gbnVsbDsgLy8gU2V0IHRoZSBkb2N1bWVudCBJUklcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5fc2V0QmFzZShvcHRpb25zLmJhc2VJUkkpO1xuXG4gICAgb3B0aW9ucy5mYWN0b3J5ICYmIGluaXREYXRhRmFjdG9yeSh0aGlzLCBvcHRpb25zLmZhY3RvcnkpOyAvLyBTZXQgc3VwcG9ydGVkIGZlYXR1cmVzIGRlcGVuZGluZyBvbiB0aGUgZm9ybWF0XG5cbiAgICB2YXIgZm9ybWF0ID0gdHlwZW9mIG9wdGlvbnMuZm9ybWF0ID09PSAnc3RyaW5nJyA/IG9wdGlvbnMuZm9ybWF0Lm1hdGNoKC9cXHcqJC8pWzBdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICAgICAgaXNUdXJ0bGUgPSAvdHVydGxlLy50ZXN0KGZvcm1hdCksXG4gICAgICAgIGlzVHJpRyA9IC90cmlnLy50ZXN0KGZvcm1hdCksXG4gICAgICAgIGlzTlRyaXBsZXMgPSAvdHJpcGxlLy50ZXN0KGZvcm1hdCksXG4gICAgICAgIGlzTlF1YWRzID0gL3F1YWQvLnRlc3QoZm9ybWF0KSxcbiAgICAgICAgaXNOMyA9IHRoaXMuX24zTW9kZSA9IC9uMy8udGVzdChmb3JtYXQpLFxuICAgICAgICBpc0xpbmVNb2RlID0gaXNOVHJpcGxlcyB8fCBpc05RdWFkcztcbiAgICBpZiAoISh0aGlzLl9zdXBwb3J0c05hbWVkR3JhcGhzID0gIShpc1R1cnRsZSB8fCBpc04zKSkpIHRoaXMuX3JlYWRQcmVkaWNhdGVPck5hbWVkR3JhcGggPSB0aGlzLl9yZWFkUHJlZGljYXRlOyAvLyBTdXBwb3J0IHRyaXBsZXMgaW4gb3RoZXIgZ3JhcGhzXG5cbiAgICB0aGlzLl9zdXBwb3J0c1F1YWRzID0gIShpc1R1cnRsZSB8fCBpc1RyaUcgfHwgaXNOVHJpcGxlcyB8fCBpc04zKTsgLy8gU3VwcG9ydCBuZXN0aW5nIG9mIHRyaXBsZXNcblxuICAgIHRoaXMuX3N1cHBvcnRzUkRGU3RhciA9IGZvcm1hdCA9PT0gJycgfHwgL3N0YXJ8XFwqJC8udGVzdChmb3JtYXQpOyAvLyBEaXNhYmxlIHJlbGF0aXZlIElSSXMgaW4gTi1UcmlwbGVzIG9yIE4tUXVhZHMgbW9kZVxuXG4gICAgaWYgKGlzTGluZU1vZGUpIHRoaXMuX3Jlc29sdmVSZWxhdGl2ZUlSSSA9IGZ1bmN0aW9uIChpcmkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdGhpcy5fYmxhbmtOb2RlUHJlZml4ID0gdHlwZW9mIG9wdGlvbnMuYmxhbmtOb2RlUHJlZml4ICE9PSAnc3RyaW5nJyA/ICcnIDogb3B0aW9ucy5ibGFua05vZGVQcmVmaXgucmVwbGFjZSgvXig/IV86KS8sICdfOicpO1xuICAgIHRoaXMuX2xleGVyID0gb3B0aW9ucy5sZXhlciB8fCBuZXcgX04zTGV4ZXIuZGVmYXVsdCh7XG4gICAgICBsaW5lTW9kZTogaXNMaW5lTW9kZSxcbiAgICAgIG4zOiBpc04zXG4gICAgfSk7IC8vIERpc2FibGUgZXhwbGljaXQgcXVhbnRpZmllcnMgYnkgZGVmYXVsdFxuXG4gICAgdGhpcy5fZXhwbGljaXRRdWFudGlmaWVycyA9ICEhb3B0aW9ucy5leHBsaWNpdFF1YW50aWZpZXJzO1xuICB9IC8vICMjIFN0YXRpYyBjbGFzcyBtZXRob2RzXG4gIC8vICMjIyBgX3Jlc2V0QmxhbmtOb2RlUHJlZml4YCByZXN0YXJ0cyBibGFuayBub2RlIHByZWZpeCBpZGVudGlmaWNhdGlvblxuXG5cbiAgc3RhdGljIF9yZXNldEJsYW5rTm9kZVByZWZpeCgpIHtcbiAgICBibGFua05vZGVQcmVmaXggPSAwO1xuICB9IC8vICMjIFByaXZhdGUgbWV0aG9kc1xuICAvLyAjIyMgYF9zZXRCYXNlYCBzZXRzIHRoZSBiYXNlIElSSSB0byByZXNvbHZlIHJlbGF0aXZlIElSSXNcblxuXG4gIF9zZXRCYXNlKGJhc2VJUkkpIHtcbiAgICBpZiAoIWJhc2VJUkkpIHtcbiAgICAgIHRoaXMuX2Jhc2UgPSAnJztcbiAgICAgIHRoaXMuX2Jhc2VQYXRoID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBmcmFnbWVudCBpZiBwcmVzZW50XG4gICAgICB2YXIgZnJhZ21lbnRQb3MgPSBiYXNlSVJJLmluZGV4T2YoJyMnKTtcbiAgICAgIGlmIChmcmFnbWVudFBvcyA+PSAwKSBiYXNlSVJJID0gYmFzZUlSSS5zdWJzdHIoMCwgZnJhZ21lbnRQb3MpOyAvLyBTZXQgYmFzZSBJUkkgYW5kIGl0cyBjb21wb25lbnRzXG5cbiAgICAgIHRoaXMuX2Jhc2UgPSBiYXNlSVJJO1xuICAgICAgdGhpcy5fYmFzZVBhdGggPSBiYXNlSVJJLmluZGV4T2YoJy8nKSA8IDAgPyBiYXNlSVJJIDogYmFzZUlSSS5yZXBsYWNlKC9bXlxcLz9dKig/OlxcPy4qKT8kLywgJycpO1xuICAgICAgYmFzZUlSSSA9IGJhc2VJUkkubWF0Y2goL14oPzooW2Etel1bYS16MC05Ky4tXSo6KSk/KD86XFwvXFwvW15cXC9dKik/L2kpO1xuICAgICAgdGhpcy5fYmFzZVJvb3QgPSBiYXNlSVJJWzBdO1xuICAgICAgdGhpcy5fYmFzZVNjaGVtZSA9IGJhc2VJUklbMV07XG4gICAgfVxuICB9IC8vICMjIyBgX3NhdmVDb250ZXh0YCBzdG9yZXMgdGhlIGN1cnJlbnQgcGFyc2luZyBjb250ZXh0XG4gIC8vIHdoZW4gZW50ZXJpbmcgYSBuZXcgc2NvcGUgKGxpc3QsIGJsYW5rIG5vZGUsIGZvcm11bGEpXG5cblxuICBfc2F2ZUNvbnRleHQodHlwZSwgZ3JhcGgsIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KSB7XG4gICAgdmFyIG4zTW9kZSA9IHRoaXMuX24zTW9kZTtcblxuICAgIHRoaXMuX2NvbnRleHRTdGFjay5wdXNoKHtcbiAgICAgIHN1YmplY3Q6IHN1YmplY3QsXG4gICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgZ3JhcGg6IGdyYXBoLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGludmVyc2U6IG4zTW9kZSA/IHRoaXMuX2ludmVyc2VQcmVkaWNhdGUgOiBmYWxzZSxcbiAgICAgIGJsYW5rUHJlZml4OiBuM01vZGUgPyB0aGlzLl9wcmVmaXhlcy5fIDogJycsXG4gICAgICBxdWFudGlmaWVkOiBuM01vZGUgPyB0aGlzLl9xdWFudGlmaWVkIDogbnVsbFxuICAgIH0pOyAvLyBUaGUgc2V0dGluZ3MgYmVsb3cgb25seSBhcHBseSB0byBOMyBzdHJlYW1zXG5cblxuICAgIGlmIChuM01vZGUpIHtcbiAgICAgIC8vIEV2ZXJ5IG5ldyBzY29wZSByZXNldHMgdGhlIHByZWRpY2F0ZSBkaXJlY3Rpb25cbiAgICAgIHRoaXMuX2ludmVyc2VQcmVkaWNhdGUgPSBmYWxzZTsgLy8gSW4gTjMsIGJsYW5rIG5vZGVzIGFyZSBzY29wZWQgdG8gYSBmb3JtdWxhXG4gICAgICAvLyAodXNpbmcgYSBkb3QgYXMgc2VwYXJhdG9yLCBhcyBhIGJsYW5rIG5vZGUgbGFiZWwgY2Fubm90IHN0YXJ0IHdpdGggaXQpXG5cbiAgICAgIHRoaXMuX3ByZWZpeGVzLl8gPSB0aGlzLl9ncmFwaCA/IHRoaXMuX2dyYXBoLmlkLnN1YnN0cigyKSArICcuJyA6ICcuJzsgLy8gUXVhbnRpZmllcnMgYXJlIHNjb3BlZCB0byBhIGZvcm11bGFcblxuICAgICAgdGhpcy5fcXVhbnRpZmllZCA9IE9iamVjdC5jcmVhdGUodGhpcy5fcXVhbnRpZmllZCk7XG4gICAgfVxuICB9IC8vICMjIyBgX3Jlc3RvcmVDb250ZXh0YCByZXN0b3JlcyB0aGUgcGFyZW50IGNvbnRleHRcbiAgLy8gd2hlbiBsZWF2aW5nIGEgc2NvcGUgKGxpc3QsIGJsYW5rIG5vZGUsIGZvcm11bGEpXG5cblxuICBfcmVzdG9yZUNvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0U3RhY2sucG9wKCksXG4gICAgICAgIG4zTW9kZSA9IHRoaXMuX24zTW9kZTtcblxuICAgIHRoaXMuX3N1YmplY3QgPSBjb250ZXh0LnN1YmplY3Q7XG4gICAgdGhpcy5fcHJlZGljYXRlID0gY29udGV4dC5wcmVkaWNhdGU7XG4gICAgdGhpcy5fb2JqZWN0ID0gY29udGV4dC5vYmplY3Q7XG4gICAgdGhpcy5fZ3JhcGggPSBjb250ZXh0LmdyYXBoOyAvLyBUaGUgc2V0dGluZ3MgYmVsb3cgb25seSBhcHBseSB0byBOMyBzdHJlYW1zXG5cbiAgICBpZiAobjNNb2RlKSB7XG4gICAgICB0aGlzLl9pbnZlcnNlUHJlZGljYXRlID0gY29udGV4dC5pbnZlcnNlO1xuICAgICAgdGhpcy5fcHJlZml4ZXMuXyA9IGNvbnRleHQuYmxhbmtQcmVmaXg7XG4gICAgICB0aGlzLl9xdWFudGlmaWVkID0gY29udGV4dC5xdWFudGlmaWVkO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9yZWFkSW5Ub3BDb250ZXh0YCByZWFkcyBhIHRva2VuIHdoZW4gaW4gdGhlIHRvcCBjb250ZXh0XG5cblxuICBfcmVhZEluVG9wQ29udGV4dCh0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgLy8gSWYgYW4gRU9GIHRva2VuIGFycml2ZXMgaW4gdGhlIHRvcCBjb250ZXh0LCBzaWduYWwgdGhhdCB3ZSdyZSBkb25lXG4gICAgICBjYXNlICdlb2YnOlxuICAgICAgICBpZiAodGhpcy5fZ3JhcGggIT09IG51bGwpIHJldHVybiB0aGlzLl9lcnJvcignVW5jbG9zZWQgZ3JhcGgnLCB0b2tlbik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wcmVmaXhlcy5fO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2sobnVsbCwgbnVsbCwgdGhpcy5fcHJlZml4ZXMpO1xuICAgICAgLy8gSXQgY291bGQgYmUgYSBwcmVmaXggZGVjbGFyYXRpb25cblxuICAgICAgY2FzZSAnUFJFRklYJzpcbiAgICAgICAgdGhpcy5fc3BhcnFsU3R5bGUgPSB0cnVlO1xuXG4gICAgICBjYXNlICdAcHJlZml4JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRQcmVmaXg7XG4gICAgICAvLyBJdCBjb3VsZCBiZSBhIGJhc2UgZGVjbGFyYXRpb25cblxuICAgICAgY2FzZSAnQkFTRSc6XG4gICAgICAgIHRoaXMuX3NwYXJxbFN0eWxlID0gdHJ1ZTtcblxuICAgICAgY2FzZSAnQGJhc2UnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZEJhc2VJUkk7XG4gICAgICAvLyBJdCBjb3VsZCBiZSBhIGdyYXBoXG5cbiAgICAgIGNhc2UgJ3snOlxuICAgICAgICBpZiAodGhpcy5fc3VwcG9ydHNOYW1lZEdyYXBocykge1xuICAgICAgICAgIHRoaXMuX2dyYXBoID0gJyc7XG4gICAgICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdWJqZWN0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ0dSQVBIJzpcbiAgICAgICAgaWYgKHRoaXMuX3N1cHBvcnRzTmFtZWRHcmFwaHMpIHJldHVybiB0aGlzLl9yZWFkTmFtZWRHcmFwaExhYmVsO1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgbmV4dCB0b2tlbiBtdXN0IGJlIGEgc3ViamVjdFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3QodG9rZW4pO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9yZWFkRW50aXR5YCByZWFkcyBhbiBJUkksIHByZWZpeGVkIG5hbWUsIGJsYW5rIG5vZGUsIG9yIHZhcmlhYmxlXG5cblxuICBfcmVhZEVudGl0eSh0b2tlbiwgcXVhbnRpZmllcikge1xuICAgIHZhciB2YWx1ZTtcblxuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgLy8gUmVhZCBhIHJlbGF0aXZlIG9yIGFic29sdXRlIElSSVxuICAgICAgY2FzZSAnSVJJJzpcbiAgICAgIGNhc2UgJ3R5cGVJUkknOlxuICAgICAgICB2YXIgaXJpID0gdGhpcy5fcmVzb2x2ZUlSSSh0b2tlbi52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGlyaSA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2Vycm9yKCdJbnZhbGlkIElSSScsIHRva2VuKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9uYW1lZE5vZGUoaXJpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBSZWFkIGEgcHJlZml4ZWQgbmFtZVxuXG4gICAgICBjYXNlICd0eXBlJzpcbiAgICAgIGNhc2UgJ3ByZWZpeGVkJzpcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuX3ByZWZpeGVzW3Rva2VuLnByZWZpeF07XG4gICAgICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmRlZmluZWQgcHJlZml4IFwiJyArIHRva2VuLnByZWZpeCArICc6XCInLCB0b2tlbik7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fbmFtZWROb2RlKHByZWZpeCArIHRva2VuLnZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBSZWFkIGEgYmxhbmsgbm9kZVxuXG4gICAgICBjYXNlICdibGFuayc6XG4gICAgICAgIHZhbHVlID0gdGhpcy5fYmxhbmtOb2RlKHRoaXMuX3ByZWZpeGVzW3Rva2VuLnByZWZpeF0gKyB0b2tlbi52YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gUmVhZCBhIHZhcmlhYmxlXG5cbiAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgIHZhbHVlID0gdGhpcy5fdmFyaWFibGUodG9rZW4udmFsdWUuc3Vic3RyKDEpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgbm90IGFuIGVudGl0eVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIGVudGl0eSBidXQgZ290ICcgKyB0b2tlbi50eXBlLCB0b2tlbik7XG4gICAgfSAvLyBJbiBOMyBtb2RlLCByZXBsYWNlIHRoZSBlbnRpdHkgaWYgaXQgaXMgcXVhbnRpZmllZFxuXG5cbiAgICBpZiAoIXF1YW50aWZpZXIgJiYgdGhpcy5fbjNNb2RlICYmIHZhbHVlLmlkIGluIHRoaXMuX3F1YW50aWZpZWQpIHZhbHVlID0gdGhpcy5fcXVhbnRpZmllZFt2YWx1ZS5pZF07XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IC8vICMjIyBgX3JlYWRTdWJqZWN0YCByZWFkcyBhIHF1YWQncyBzdWJqZWN0XG5cblxuICBfcmVhZFN1YmplY3QodG9rZW4pIHtcbiAgICB0aGlzLl9wcmVkaWNhdGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgcXVhZCB3aXRoIGEgbmV3IGJsYW5rIG5vZGUgYXMgc3ViamVjdFxuICAgICAgICB0aGlzLl9zYXZlQ29udGV4dCgnYmxhbmsnLCB0aGlzLl9ncmFwaCwgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2JsYW5rTm9kZSgpLCBudWxsLCBudWxsKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZEJsYW5rTm9kZUhlYWQ7XG5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICAvLyBTdGFydCBhIG5ldyBsaXN0XG4gICAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCdsaXN0JywgdGhpcy5fZ3JhcGgsIHRoaXMuUkRGX05JTCwgbnVsbCwgbnVsbCk7XG5cbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTGlzdEl0ZW07XG5cbiAgICAgIGNhc2UgJ3snOlxuICAgICAgICAvLyBTdGFydCBhIG5ldyBmb3JtdWxhXG4gICAgICAgIGlmICghdGhpcy5fbjNNb2RlKSByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuZXhwZWN0ZWQgZ3JhcGgnLCB0b2tlbik7XG5cbiAgICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2Zvcm11bGEnLCB0aGlzLl9ncmFwaCwgdGhpcy5fZ3JhcGggPSB0aGlzLl9ibGFua05vZGUoKSwgbnVsbCwgbnVsbCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdWJqZWN0O1xuXG4gICAgICBjYXNlICd9JzpcbiAgICAgICAgLy8gTm8gc3ViamVjdDsgdGhlIGdyYXBoIGluIHdoaWNoIHdlIGFyZSByZWFkaW5nIGlzIGNsb3NlZCBpbnN0ZWFkXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkUHVuY3R1YXRpb24odG9rZW4pO1xuXG4gICAgICBjYXNlICdAZm9yU29tZSc6XG4gICAgICAgIGlmICghdGhpcy5fbjNNb2RlKSByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuZXhwZWN0ZWQgXCJAZm9yU29tZVwiJywgdG9rZW4pO1xuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJlZGljYXRlID0gdGhpcy5OM19GT1JTT01FO1xuICAgICAgICB0aGlzLl9xdWFudGlmaWVyID0gdGhpcy5fYmxhbmtOb2RlO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFF1YW50aWZpZXJMaXN0O1xuXG4gICAgICBjYXNlICdAZm9yQWxsJzpcbiAgICAgICAgaWYgKCF0aGlzLl9uM01vZGUpIHJldHVybiB0aGlzLl9lcnJvcignVW5leHBlY3RlZCBcIkBmb3JBbGxcIicsIHRva2VuKTtcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByZWRpY2F0ZSA9IHRoaXMuTjNfRk9SQUxMO1xuICAgICAgICB0aGlzLl9xdWFudGlmaWVyID0gdGhpcy5fdmFyaWFibGU7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkUXVhbnRpZmllckxpc3Q7XG5cbiAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICBpZiAoIXRoaXMuX24zTW9kZSkgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIGxpdGVyYWwnLCB0b2tlbik7XG5cbiAgICAgICAgaWYgKHRva2VuLnByZWZpeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9saXRlcmFsVmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGVTdWJqZWN0TGl0ZXJhbDtcbiAgICAgICAgfSBlbHNlIHRoaXMuX3N1YmplY3QgPSB0aGlzLl9saXRlcmFsKHRva2VuLnZhbHVlLCB0aGlzLl9uYW1lZE5vZGUodG9rZW4ucHJlZml4KSk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzw8JzpcbiAgICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0c1JERlN0YXIpIHJldHVybiB0aGlzLl9lcnJvcignVW5leHBlY3RlZCBSREYqIHN5bnRheCcsIHRva2VuKTtcblxuICAgICAgICB0aGlzLl9zYXZlQ29udGV4dCgnPDwnLCB0aGlzLl9ncmFwaCwgbnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgICAgICAgdGhpcy5fZ3JhcGggPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3Q7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFJlYWQgdGhlIHN1YmplY3QgZW50aXR5XG4gICAgICAgIGlmICgodGhpcy5fc3ViamVjdCA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIEluIE4zIG1vZGUsIHRoZSBzdWJqZWN0IG1pZ2h0IGJlIGEgcGF0aFxuXG4gICAgICAgIGlmICh0aGlzLl9uM01vZGUpIHJldHVybiB0aGlzLl9nZXRQYXRoUmVhZGVyKHRoaXMuX3JlYWRQcmVkaWNhdGVPck5hbWVkR3JhcGgpO1xuICAgIH0gLy8gVGhlIG5leHQgdG9rZW4gbXVzdCBiZSBhIHByZWRpY2F0ZSxcbiAgICAvLyBvciwgaWYgdGhlIHN1YmplY3Qgd2FzIGFjdHVhbGx5IGEgZ3JhcGggSVJJLCBhIG5hbWVkIGdyYXBoXG5cblxuICAgIHJldHVybiB0aGlzLl9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBoO1xuICB9IC8vICMjIyBgX3JlYWRQcmVkaWNhdGVgIHJlYWRzIGEgcXVhZCdzIHByZWRpY2F0ZVxuXG5cbiAgX3JlYWRQcmVkaWNhdGUodG9rZW4pIHtcbiAgICB2YXIgdHlwZSA9IHRva2VuLnR5cGU7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2ludmVyc2UnOlxuICAgICAgICB0aGlzLl9pbnZlcnNlUHJlZGljYXRlID0gdHJ1ZTtcblxuICAgICAgY2FzZSAnYWJicmV2aWF0aW9uJzpcbiAgICAgICAgdGhpcy5fcHJlZGljYXRlID0gdGhpcy5BQkJSRVZJQVRJT05TW3Rva2VuLnZhbHVlXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJy4nOlxuICAgICAgY2FzZSAnXSc6XG4gICAgICBjYXNlICd9JzpcbiAgICAgICAgLy8gRXhwZWN0ZWQgcHJlZGljYXRlIGRpZG4ndCBjb21lLCBtdXN0IGhhdmUgYmVlbiB0cmFpbGluZyBzZW1pY29sb25cbiAgICAgICAgaWYgKHRoaXMuX3ByZWRpY2F0ZSA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkICcgKyB0eXBlLCB0b2tlbik7XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ10nID8gdGhpcy5fcmVhZEJsYW5rTm9kZVRhaWwodG9rZW4pIDogdGhpcy5fcmVhZFB1bmN0dWF0aW9uKHRva2VuKTtcblxuICAgICAgY2FzZSAnOyc6XG4gICAgICAgIC8vIEFkZGl0aW9uYWwgc2VtaWNvbG9ucyBjYW4gYmUgc2FmZWx5IGlnbm9yZWRcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZSAhPT0gbnVsbCA/IHRoaXMuX3JlYWRQcmVkaWNhdGUgOiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgcHJlZGljYXRlIGJ1dCBnb3QgOycsIHRva2VuKTtcblxuICAgICAgY2FzZSAnYmxhbmsnOlxuICAgICAgICBpZiAoIXRoaXMuX24zTW9kZSkgcmV0dXJuIHRoaXMuX2Vycm9yKCdEaXNhbGxvd2VkIGJsYW5rIG5vZGUgYXMgcHJlZGljYXRlJywgdG9rZW4pO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoKHRoaXMuX3ByZWRpY2F0ZSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgfSAvLyBUaGUgbmV4dCB0b2tlbiBtdXN0IGJlIGFuIG9iamVjdFxuXG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZE9iamVjdDtcbiAgfSAvLyAjIyMgYF9yZWFkT2JqZWN0YCByZWFkcyBhIHF1YWQncyBvYmplY3RcblxuXG4gIF9yZWFkT2JqZWN0KHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlICdsaXRlcmFsJzpcbiAgICAgICAgLy8gUmVndWxhciBsaXRlcmFsLCBjYW4gc3RpbGwgZ2V0IGEgZGF0YXR5cGUgb3IgbGFuZ3VhZ2VcbiAgICAgICAgaWYgKHRva2VuLnByZWZpeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9saXRlcmFsVmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZERhdGFUeXBlT3JMYW5nO1xuICAgICAgICB9IC8vIFByZS1kYXRhdHlwZWQgc3RyaW5nIGxpdGVyYWwgKHByZWZpeCBzdG9yZXMgdGhlIGRhdGF0eXBlKVxuICAgICAgICBlbHNlIHRoaXMuX29iamVjdCA9IHRoaXMuX2xpdGVyYWwodG9rZW4udmFsdWUsIHRoaXMuX25hbWVkTm9kZSh0b2tlbi5wcmVmaXgpKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IHF1YWQgd2l0aCBhIG5ldyBibGFuayBub2RlIGFzIHN1YmplY3RcbiAgICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2JsYW5rJywgdGhpcy5fZ3JhcGgsIHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSwgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2JsYW5rTm9kZSgpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZEJsYW5rTm9kZUhlYWQ7XG5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICAvLyBTdGFydCBhIG5ldyBsaXN0XG4gICAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCdsaXN0JywgdGhpcy5fZ3JhcGgsIHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSwgdGhpcy5SREZfTklMKTtcblxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRMaXN0SXRlbTtcblxuICAgICAgY2FzZSAneyc6XG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IGZvcm11bGFcbiAgICAgICAgaWYgKCF0aGlzLl9uM01vZGUpIHJldHVybiB0aGlzLl9lcnJvcignVW5leHBlY3RlZCBncmFwaCcsIHRva2VuKTtcblxuICAgICAgICB0aGlzLl9zYXZlQ29udGV4dCgnZm9ybXVsYScsIHRoaXMuX2dyYXBoLCB0aGlzLl9zdWJqZWN0LCB0aGlzLl9wcmVkaWNhdGUsIHRoaXMuX2dyYXBoID0gdGhpcy5fYmxhbmtOb2RlKCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkU3ViamVjdDtcblxuICAgICAgY2FzZSAnPDwnOlxuICAgICAgICBpZiAoIXRoaXMuX3N1cHBvcnRzUkRGU3RhcikgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIFJERiogc3ludGF4JywgdG9rZW4pO1xuXG4gICAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCc8PCcsIHRoaXMuX2dyYXBoLCB0aGlzLl9zdWJqZWN0LCB0aGlzLl9wcmVkaWNhdGUsIG51bGwpO1xuXG4gICAgICAgIHRoaXMuX2dyYXBoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdWJqZWN0O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBSZWFkIHRoZSBvYmplY3QgZW50aXR5XG4gICAgICAgIGlmICgodGhpcy5fb2JqZWN0ID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gSW4gTjMgbW9kZSwgdGhlIG9iamVjdCBtaWdodCBiZSBhIHBhdGhcblxuICAgICAgICBpZiAodGhpcy5fbjNNb2RlKSByZXR1cm4gdGhpcy5fZ2V0UGF0aFJlYWRlcih0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCk7XG4gIH0gLy8gIyMjIGBfcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaGAgcmVhZHMgYSBxdWFkJ3MgcHJlZGljYXRlLCBvciBhIG5hbWVkIGdyYXBoXG5cblxuICBfcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaCh0b2tlbikge1xuICAgIHJldHVybiB0b2tlbi50eXBlID09PSAneycgPyB0aGlzLl9yZWFkR3JhcGgodG9rZW4pIDogdGhpcy5fcmVhZFByZWRpY2F0ZSh0b2tlbik7XG4gIH0gLy8gIyMjIGBfcmVhZEdyYXBoYCByZWFkcyBhIGdyYXBoXG5cblxuICBfcmVhZEdyYXBoKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd7JykgcmV0dXJuIHRoaXMuX2Vycm9yKCdFeHBlY3RlZCBncmFwaCBidXQgZ290ICcgKyB0b2tlbi50eXBlLCB0b2tlbik7IC8vIFRoZSBcInN1YmplY3RcIiB3ZSByZWFkIGlzIGFjdHVhbGx5IHRoZSBHUkFQSCdzIGxhYmVsXG5cbiAgICB0aGlzLl9ncmFwaCA9IHRoaXMuX3N1YmplY3QsIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLl9yZWFkU3ViamVjdDtcbiAgfSAvLyAjIyMgYF9yZWFkQmxhbmtOb2RlSGVhZGAgcmVhZHMgdGhlIGhlYWQgb2YgYSBibGFuayBub2RlXG5cblxuICBfcmVhZEJsYW5rTm9kZUhlYWQodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ10nKSB7XG4gICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkQmxhbmtOb2RlVGFpbCh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ByZWRpY2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFByZWRpY2F0ZSh0b2tlbik7XG4gICAgfVxuICB9IC8vICMjIyBgX3JlYWRCbGFua05vZGVUYWlsYCByZWFkcyB0aGUgZW5kIG9mIGEgYmxhbmsgbm9kZVxuXG5cbiAgX3JlYWRCbGFua05vZGVUYWlsKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICddJykgcmV0dXJuIHRoaXMuX3JlYWRCbGFua05vZGVQdW5jdHVhdGlvbih0b2tlbik7IC8vIFN0b3JlIGJsYW5rIG5vZGUgcXVhZFxuXG4gICAgaWYgKHRoaXMuX3N1YmplY3QgIT09IG51bGwpIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLCB0aGlzLl9vYmplY3QsIHRoaXMuX2dyYXBoKTsgLy8gUmVzdG9yZSB0aGUgcGFyZW50IGNvbnRleHQgY29udGFpbmluZyB0aGlzIGJsYW5rIG5vZGVcblxuICAgIHZhciBlbXB0eSA9IHRoaXMuX3ByZWRpY2F0ZSA9PT0gbnVsbDtcblxuICAgIHRoaXMuX3Jlc3RvcmVDb250ZXh0KCk7IC8vIElmIHRoZSBibGFuayBub2RlIHdhcyB0aGUgc3ViamVjdCwgY29udGludWUgcmVhZGluZyB0aGUgcHJlZGljYXRlXG5cblxuICAgIGlmICh0aGlzLl9vYmplY3QgPT09IG51bGwpIC8vIElmIHRoZSBibGFuayBub2RlIHdhcyBlbXB0eSwgaXQgY291bGQgYmUgYSBuYW1lZCBncmFwaCBsYWJlbFxuICAgICAgcmV0dXJuIGVtcHR5ID8gdGhpcy5fcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaCA6IHRoaXMuX3JlYWRQcmVkaWNhdGVBZnRlckJsYW5rOyAvLyBJZiB0aGUgYmxhbmsgbm9kZSB3YXMgdGhlIG9iamVjdCwgcmVzdG9yZSBwcmV2aW91cyBjb250ZXh0IGFuZCByZWFkIHB1bmN0dWF0aW9uXG4gICAgZWxzZSByZXR1cm4gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpO1xuICB9IC8vICMjIyBgX3JlYWRQcmVkaWNhdGVBZnRlckJsYW5rYCByZWFkcyBhIHByZWRpY2F0ZSBhZnRlciBhbiBhbm9ueW1vdXMgYmxhbmsgbm9kZVxuXG5cbiAgX3JlYWRQcmVkaWNhdGVBZnRlckJsYW5rKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlICcuJzpcbiAgICAgIGNhc2UgJ30nOlxuICAgICAgICAvLyBObyBwcmVkaWNhdGUgaXMgY29taW5nIGlmIHRoZSB0cmlwbGUgaXMgdGVybWluYXRlZCBoZXJlXG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFB1bmN0dWF0aW9uKHRva2VuKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRQcmVkaWNhdGUodG9rZW4pO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9yZWFkTGlzdEl0ZW1gIHJlYWRzIGl0ZW1zIGZyb20gYSBsaXN0XG5cblxuICBfcmVhZExpc3RJdGVtKHRva2VuKSB7XG4gICAgdmFyIGl0ZW0gPSBudWxsLFxuICAgICAgICAvLyBUaGUgaXRlbSBvZiB0aGUgbGlzdFxuICAgIGxpc3QgPSBudWxsLFxuICAgICAgICAvLyBUaGUgbGlzdCBpdHNlbGZcbiAgICBwcmV2aW91c0xpc3QgPSB0aGlzLl9zdWJqZWN0LFxuICAgICAgICAvLyBUaGUgcHJldmlvdXMgbGlzdCB0aGF0IGNvbnRhaW5zIHRoaXMgbGlzdFxuICAgIHN0YWNrID0gdGhpcy5fY29udGV4dFN0YWNrLFxuICAgICAgICAvLyBUaGUgc3RhY2sgb2YgcGFyZW50IGNvbnRleHRzXG4gICAgcGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0sXG4gICAgICAgIC8vIFRoZSBwYXJlbnQgY29udGFpbmluZyB0aGUgY3VycmVudCBsaXN0XG4gICAgbmV4dCA9IHRoaXMuX3JlYWRMaXN0SXRlbTsgLy8gVGhlIG5leHQgZnVuY3Rpb24gdG8gZXhlY3V0ZVxuXG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgLy8gU3RhY2sgdGhlIGN1cnJlbnQgbGlzdCBxdWFkIGFuZCBzdGFydCBhIG5ldyBxdWFkIHdpdGggYSBibGFuayBub2RlIGFzIHN1YmplY3RcbiAgICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2JsYW5rJywgdGhpcy5fZ3JhcGgsIGxpc3QgPSB0aGlzLl9ibGFua05vZGUoKSwgdGhpcy5SREZfRklSU1QsIHRoaXMuX3N1YmplY3QgPSBpdGVtID0gdGhpcy5fYmxhbmtOb2RlKCkpO1xuXG4gICAgICAgIG5leHQgPSB0aGlzLl9yZWFkQmxhbmtOb2RlSGVhZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICAvLyBTdGFjayB0aGUgY3VycmVudCBsaXN0IHF1YWQgYW5kIHN0YXJ0IGEgbmV3IGxpc3RcbiAgICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2xpc3QnLCB0aGlzLl9ncmFwaCwgbGlzdCA9IHRoaXMuX2JsYW5rTm9kZSgpLCB0aGlzLlJERl9GSVJTVCwgdGhpcy5SREZfTklMKTtcblxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICAvLyBDbG9zaW5nIHRoZSBsaXN0OyByZXN0b3JlIHRoZSBwYXJlbnQgY29udGV4dFxuICAgICAgICB0aGlzLl9yZXN0b3JlQ29udGV4dCgpOyAvLyBJZiB0aGlzIGxpc3QgaXMgY29udGFpbmVkIHdpdGhpbiBhIHBhcmVudCBsaXN0LCByZXR1cm4gdGhlIG1lbWJlcnNoaXAgcXVhZCBoZXJlLlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgYDxwYXJlbnQgbGlzdCBlbGVtZW50PiByZGY6Zmlyc3QgPHRoaXMgbGlzdD4uYC5cblxuXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggIT09IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0udHlwZSA9PT0gJ2xpc3QnKSB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSwgdGhpcy5fb2JqZWN0LCB0aGlzLl9ncmFwaCk7IC8vIFdhcyB0aGlzIGxpc3QgdGhlIHBhcmVudCdzIHN1YmplY3Q/XG5cbiAgICAgICAgaWYgKHRoaXMuX3ByZWRpY2F0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoZSBuZXh0IHRva2VuIGlzIHRoZSBwcmVkaWNhdGVcbiAgICAgICAgICBuZXh0ID0gdGhpcy5fcmVhZFByZWRpY2F0ZTsgLy8gTm8gbGlzdCB0YWlsIGlmIHRoaXMgd2FzIGFuIGVtcHR5IGxpc3RcblxuICAgICAgICAgIGlmICh0aGlzLl9zdWJqZWN0ID09PSB0aGlzLlJERl9OSUwpIHJldHVybiBuZXh0O1xuICAgICAgICB9IC8vIFRoZSBsaXN0IHdhcyBpbiB0aGUgcGFyZW50IGNvbnRleHQncyBvYmplY3RcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpOyAvLyBObyBsaXN0IHRhaWwgaWYgdGhpcyB3YXMgYW4gZW1wdHkgbGlzdFxuXG4gICAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0ID09PSB0aGlzLlJERl9OSUwpIHJldHVybiBuZXh0O1xuICAgICAgICAgIH0gLy8gQ2xvc2UgdGhlIGxpc3QgYnkgbWFraW5nIHRoZSBoZWFkIG5pbFxuXG5cbiAgICAgICAgbGlzdCA9IHRoaXMuUkRGX05JTDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAvLyBSZWd1bGFyIGxpdGVyYWwsIGNhbiBzdGlsbCBnZXQgYSBkYXRhdHlwZSBvciBsYW5ndWFnZVxuICAgICAgICBpZiAodG9rZW4ucHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2xpdGVyYWxWYWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIG5leHQgPSB0aGlzLl9yZWFkTGlzdEl0ZW1EYXRhVHlwZU9yTGFuZztcbiAgICAgICAgfSAvLyBQcmUtZGF0YXR5cGVkIHN0cmluZyBsaXRlcmFsIChwcmVmaXggc3RvcmVzIHRoZSBkYXRhdHlwZSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5fbGl0ZXJhbCh0b2tlbi52YWx1ZSwgdGhpcy5fbmFtZWROb2RlKHRva2VuLnByZWZpeCkpO1xuICAgICAgICAgICAgbmV4dCA9IHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3snOlxuICAgICAgICAvLyBTdGFydCBhIG5ldyBmb3JtdWxhXG4gICAgICAgIGlmICghdGhpcy5fbjNNb2RlKSByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuZXhwZWN0ZWQgZ3JhcGgnLCB0b2tlbik7XG5cbiAgICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2Zvcm11bGEnLCB0aGlzLl9ncmFwaCwgdGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLCB0aGlzLl9ncmFwaCA9IHRoaXMuX2JsYW5rTm9kZSgpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3Q7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICgoaXRlbSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgfSAvLyBDcmVhdGUgYSBuZXcgYmxhbmsgbm9kZSBpZiBubyBpdGVtIGhlYWQgd2FzIGFzc2lnbmVkIHlldFxuXG5cbiAgICBpZiAobGlzdCA9PT0gbnVsbCkgdGhpcy5fc3ViamVjdCA9IGxpc3QgPSB0aGlzLl9ibGFua05vZGUoKTsgLy8gSXMgdGhpcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgbGlzdD9cblxuICAgIGlmIChwcmV2aW91c0xpc3QgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgbGlzdCBpcyBlaXRoZXIgdGhlIHN1YmplY3Qgb3IgdGhlIG9iamVjdCBvZiBpdHMgcGFyZW50XG4gICAgICBpZiAocGFyZW50LnByZWRpY2F0ZSA9PT0gbnVsbCkgcGFyZW50LnN1YmplY3QgPSBsaXN0O2Vsc2UgcGFyZW50Lm9iamVjdCA9IGxpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRpbnVlIHRoZSBwcmV2aW91cyBsaXN0IHdpdGggdGhlIGN1cnJlbnQgbGlzdFxuICAgICAgdGhpcy5fZW1pdChwcmV2aW91c0xpc3QsIHRoaXMuUkRGX1JFU1QsIGxpc3QsIHRoaXMuX2dyYXBoKTtcbiAgICB9IC8vIElmIGFuIGl0ZW0gd2FzIHJlYWQsIGFkZCBpdCB0byB0aGUgbGlzdFxuXG5cbiAgICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgLy8gSW4gTjMgbW9kZSwgdGhlIGl0ZW0gbWlnaHQgYmUgYSBwYXRoXG4gICAgICBpZiAodGhpcy5fbjNNb2RlICYmICh0b2tlbi50eXBlID09PSAnSVJJJyB8fCB0b2tlbi50eXBlID09PSAncHJlZml4ZWQnKSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29udGV4dCB0byBhZGQgdGhlIGl0ZW0ncyBwYXRoXG4gICAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCdpdGVtJywgdGhpcy5fZ3JhcGgsIGxpc3QsIHRoaXMuUkRGX0ZJUlNULCBpdGVtKTtcblxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gaXRlbSwgdGhpcy5fcHJlZGljYXRlID0gbnVsbDsgLy8gX3JlYWRQYXRoIHdpbGwgcmVzdG9yZSB0aGUgY29udGV4dCBhbmQgb3V0cHV0IHRoZSBpdGVtXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFBhdGhSZWFkZXIodGhpcy5fcmVhZExpc3RJdGVtKTtcbiAgICAgIH0gLy8gT3V0cHV0IHRoZSBpdGVtXG5cblxuICAgICAgdGhpcy5fZW1pdChsaXN0LCB0aGlzLlJERl9GSVJTVCwgaXRlbSwgdGhpcy5fZ3JhcGgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0O1xuICB9IC8vICMjIyBgX3JlYWREYXRhVHlwZU9yTGFuZ2AgcmVhZHMgYW4gX29wdGlvbmFsXyBkYXRhdHlwZSBvciBsYW5ndWFnZVxuXG5cbiAgX3JlYWREYXRhVHlwZU9yTGFuZyh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLl9jb21wbGV0ZU9iamVjdExpdGVyYWwodG9rZW4sIGZhbHNlKTtcbiAgfSAvLyAjIyMgYF9yZWFkTGlzdEl0ZW1EYXRhVHlwZU9yTGFuZ2AgcmVhZHMgYW4gX29wdGlvbmFsXyBkYXRhdHlwZSBvciBsYW5ndWFnZSBpbiBhIGxpc3RcblxuXG4gIF9yZWFkTGlzdEl0ZW1EYXRhVHlwZU9yTGFuZyh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLl9jb21wbGV0ZU9iamVjdExpdGVyYWwodG9rZW4sIHRydWUpO1xuICB9IC8vICMjIyBgX2NvbXBsZXRlTGl0ZXJhbGAgY29tcGxldGVzIGEgbGl0ZXJhbCB3aXRoIGFuIG9wdGlvbmFsIGRhdGF0eXBlIG9yIGxhbmd1YWdlXG5cblxuICBfY29tcGxldGVMaXRlcmFsKHRva2VuKSB7XG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHN0cmluZyBsaXRlcmFsIGJ5IGRlZmF1bHRcbiAgICBsZXQgbGl0ZXJhbCA9IHRoaXMuX2xpdGVyYWwodGhpcy5fbGl0ZXJhbFZhbHVlKTtcblxuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgLy8gQ3JlYXRlIGEgZGF0YXR5cGVkIGxpdGVyYWxcbiAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgY2FzZSAndHlwZUlSSSc6XG4gICAgICAgIHZhciBkYXRhdHlwZSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pO1xuXG4gICAgICAgIGlmIChkYXRhdHlwZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIE5vIGRhdGF0eXBlIG1lYW5zIGFuIGVycm9yIG9jY3VycmVkXG5cbiAgICAgICAgbGl0ZXJhbCA9IHRoaXMuX2xpdGVyYWwodGhpcy5fbGl0ZXJhbFZhbHVlLCBkYXRhdHlwZSk7XG4gICAgICAgIHRva2VuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBDcmVhdGUgYSBsYW5ndWFnZS10YWdnZWQgc3RyaW5nXG5cbiAgICAgIGNhc2UgJ2xhbmdjb2RlJzpcbiAgICAgICAgbGl0ZXJhbCA9IHRoaXMuX2xpdGVyYWwodGhpcy5fbGl0ZXJhbFZhbHVlLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgIHRva2VuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuLFxuICAgICAgbGl0ZXJhbFxuICAgIH07XG4gIH0gLy8gQ29tcGxldGVzIGEgbGl0ZXJhbCBpbiBzdWJqZWN0IHBvc2l0aW9uXG5cblxuICBfY29tcGxldGVTdWJqZWN0TGl0ZXJhbCh0b2tlbikge1xuICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLl9jb21wbGV0ZUxpdGVyYWwodG9rZW4pLmxpdGVyYWw7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQcmVkaWNhdGVPck5hbWVkR3JhcGg7XG4gIH0gLy8gQ29tcGxldGVzIGEgbGl0ZXJhbCBpbiBvYmplY3QgcG9zaXRpb25cblxuXG4gIF9jb21wbGV0ZU9iamVjdExpdGVyYWwodG9rZW4sIGxpc3RJdGVtKSB7XG4gICAgY29uc3QgY29tcGxldGVkID0gdGhpcy5fY29tcGxldGVMaXRlcmFsKHRva2VuKTtcblxuICAgIGlmICghY29tcGxldGVkKSByZXR1cm47XG4gICAgdGhpcy5fb2JqZWN0ID0gY29tcGxldGVkLmxpdGVyYWw7IC8vIElmIHRoaXMgbGl0ZXJhbCB3YXMgcGFydCBvZiBhIGxpc3QsIHdyaXRlIHRoZSBpdGVtXG4gICAgLy8gKHdlIGNvdWxkIGFsc28gY2hlY2sgdGhlIGNvbnRleHQgc3RhY2ssIGJ1dCBwYXNzaW5nIGluIGEgZmxhZyBpcyBmYXN0ZXIpXG5cbiAgICBpZiAobGlzdEl0ZW0pIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5SREZfRklSU1QsIHRoaXMuX29iamVjdCwgdGhpcy5fZ3JhcGgpOyAvLyBJZiB0aGUgdG9rZW4gd2FzIGNvbnN1bWVkLCBjb250aW51ZSB3aXRoIHRoZSByZXN0IG9mIHRoZSBpbnB1dFxuXG4gICAgaWYgKGNvbXBsZXRlZC50b2tlbiA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKTsgLy8gT3RoZXJ3aXNlLCBjb25zdW1lIHRoZSB0b2tlbiBub3dcbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVhZENhbGxiYWNrID0gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZENhbGxiYWNrKGNvbXBsZXRlZC50b2tlbik7XG4gICAgICB9XG4gIH0gLy8gIyMjIGBfcmVhZEZvcm11bGFUYWlsYCByZWFkcyB0aGUgZW5kIG9mIGEgZm9ybXVsYVxuXG5cbiAgX3JlYWRGb3JtdWxhVGFpbCh0b2tlbikge1xuICAgIGlmICh0b2tlbi50eXBlICE9PSAnfScpIHJldHVybiB0aGlzLl9yZWFkUHVuY3R1YXRpb24odG9rZW4pOyAvLyBTdG9yZSB0aGUgbGFzdCBxdWFkIG9mIHRoZSBmb3JtdWxhXG5cbiAgICBpZiAodGhpcy5fc3ViamVjdCAhPT0gbnVsbCkgdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LCB0aGlzLl9wcmVkaWNhdGUsIHRoaXMuX29iamVjdCwgdGhpcy5fZ3JhcGgpOyAvLyBSZXN0b3JlIHRoZSBwYXJlbnQgY29udGV4dCBjb250YWluaW5nIHRoaXMgZm9ybXVsYVxuXG4gICAgdGhpcy5fcmVzdG9yZUNvbnRleHQoKTsgLy8gSWYgdGhlIGZvcm11bGEgd2FzIHRoZSBzdWJqZWN0LCBjb250aW51ZSByZWFkaW5nIHRoZSBwcmVkaWNhdGUuXG4gICAgLy8gSWYgdGhlIGZvcm11bGEgd2FzIHRoZSBvYmplY3QsIHJlYWQgcHVuY3R1YXRpb24uXG5cblxuICAgIHJldHVybiB0aGlzLl9vYmplY3QgPT09IG51bGwgPyB0aGlzLl9yZWFkUHJlZGljYXRlIDogdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpO1xuICB9IC8vICMjIyBgX3JlYWRQdW5jdHVhdGlvbmAgcmVhZHMgcHVuY3R1YXRpb24gYmV0d2VlbiBxdWFkcyBvciBxdWFkIHBhcnRzXG5cblxuICBfcmVhZFB1bmN0dWF0aW9uKHRva2VuKSB7XG4gICAgdmFyIG5leHQsXG4gICAgICAgIHN1YmplY3QgPSB0aGlzLl9zdWJqZWN0LFxuICAgICAgICBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgICBpbnZlcnNlUHJlZGljYXRlID0gdGhpcy5faW52ZXJzZVByZWRpY2F0ZTtcblxuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgLy8gQSBjbG9zaW5nIGJyYWNlIGVuZHMgYSBncmFwaFxuICAgICAgY2FzZSAnfSc6XG4gICAgICAgIGlmICh0aGlzLl9ncmFwaCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIGdyYXBoIGNsb3NpbmcnLCB0b2tlbik7XG4gICAgICAgIGlmICh0aGlzLl9uM01vZGUpIHJldHVybiB0aGlzLl9yZWFkRm9ybXVsYVRhaWwodG9rZW4pO1xuICAgICAgICB0aGlzLl9ncmFwaCA9IG51bGw7XG4gICAgICAvLyBBIGRvdCBqdXN0IGVuZHMgdGhlIHN0YXRlbWVudCwgd2l0aG91dCBzaGFyaW5nIGFueXRoaW5nIHdpdGggdGhlIG5leHRcblxuICAgICAgY2FzZSAnLic6XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICBuZXh0ID0gdGhpcy5fY29udGV4dFN0YWNrLmxlbmd0aCA/IHRoaXMuX3JlYWRTdWJqZWN0IDogdGhpcy5fcmVhZEluVG9wQ29udGV4dDtcbiAgICAgICAgaWYgKGludmVyc2VQcmVkaWNhdGUpIHRoaXMuX2ludmVyc2VQcmVkaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBTZW1pY29sb24gbWVhbnMgdGhlIHN1YmplY3QgaXMgc2hhcmVkOyBwcmVkaWNhdGUgYW5kIG9iamVjdCBhcmUgZGlmZmVyZW50XG5cbiAgICAgIGNhc2UgJzsnOlxuICAgICAgICBuZXh0ID0gdGhpcy5fcmVhZFByZWRpY2F0ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBDb21tYSBtZWFucyBib3RoIHRoZSBzdWJqZWN0IGFuZCBwcmVkaWNhdGUgYXJlIHNoYXJlZDsgdGhlIG9iamVjdCBpcyBkaWZmZXJlbnRcblxuICAgICAgY2FzZSAnLCc6XG4gICAgICAgIG5leHQgPSB0aGlzLl9yZWFkT2JqZWN0O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gQW4gZW50aXR5IG1lYW5zIHRoaXMgaXMgYSBxdWFkIChvbmx5IGFsbG93ZWQgaWYgbm90IGFscmVhZHkgaW5zaWRlIGEgZ3JhcGgpXG4gICAgICAgIGlmICh0aGlzLl9zdXBwb3J0c1F1YWRzICYmIHRoaXMuX2dyYXBoID09PSBudWxsICYmIChncmFwaCA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV4dCA9IHRoaXMuX3JlYWRRdWFkUHVuY3R1YXRpb247XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIHB1bmN0dWF0aW9uIHRvIGZvbGxvdyBcIicgKyB0aGlzLl9vYmplY3QuaWQgKyAnXCInLCB0b2tlbik7XG4gICAgfSAvLyBBIHF1YWQgaGFzIGJlZW4gY29tcGxldGVkIG5vdywgc28gcmV0dXJuIGl0XG5cblxuICAgIGlmIChzdWJqZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJlZGljYXRlID0gdGhpcy5fcHJlZGljYXRlLFxuICAgICAgICAgIG9iamVjdCA9IHRoaXMuX29iamVjdDtcbiAgICAgIGlmICghaW52ZXJzZVByZWRpY2F0ZSkgdGhpcy5fZW1pdChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpO2Vsc2UgdGhpcy5fZW1pdChvYmplY3QsIHByZWRpY2F0ZSwgc3ViamVjdCwgZ3JhcGgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0O1xuICB9IC8vICMjIyBgX3JlYWRCbGFua05vZGVQdW5jdHVhdGlvbmAgcmVhZHMgcHVuY3R1YXRpb24gaW4gYSBibGFuayBub2RlXG5cblxuICBfcmVhZEJsYW5rTm9kZVB1bmN0dWF0aW9uKHRva2VuKSB7XG4gICAgdmFyIG5leHQ7XG5cbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIC8vIFNlbWljb2xvbiBtZWFucyB0aGUgc3ViamVjdCBpcyBzaGFyZWQ7IHByZWRpY2F0ZSBhbmQgb2JqZWN0IGFyZSBkaWZmZXJlbnRcbiAgICAgIGNhc2UgJzsnOlxuICAgICAgICBuZXh0ID0gdGhpcy5fcmVhZFByZWRpY2F0ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBDb21tYSBtZWFucyBib3RoIHRoZSBzdWJqZWN0IGFuZCBwcmVkaWNhdGUgYXJlIHNoYXJlZDsgdGhlIG9iamVjdCBpcyBkaWZmZXJlbnRcblxuICAgICAgY2FzZSAnLCc6XG4gICAgICAgIG5leHQgPSB0aGlzLl9yZWFkT2JqZWN0O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdFeHBlY3RlZCBwdW5jdHVhdGlvbiB0byBmb2xsb3cgXCInICsgdGhpcy5fb2JqZWN0LmlkICsgJ1wiJywgdG9rZW4pO1xuICAgIH0gLy8gQSBxdWFkIGhhcyBiZWVuIGNvbXBsZXRlZCBub3csIHNvIHJldHVybiBpdFxuXG5cbiAgICB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSwgdGhpcy5fb2JqZWN0LCB0aGlzLl9ncmFwaCk7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfSAvLyAjIyMgYF9yZWFkUXVhZFB1bmN0dWF0aW9uYCByZWFkcyBwdW5jdHVhdGlvbiBhZnRlciBhIHF1YWRcblxuXG4gIF9yZWFkUXVhZFB1bmN0dWF0aW9uKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICcuJykgcmV0dXJuIHRoaXMuX2Vycm9yKCdFeHBlY3RlZCBkb3QgdG8gZm9sbG93IHF1YWQnLCB0b2tlbik7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRJblRvcENvbnRleHQ7XG4gIH0gLy8gIyMjIGBfcmVhZFByZWZpeGAgcmVhZHMgdGhlIHByZWZpeCBvZiBhIHByZWZpeCBkZWNsYXJhdGlvblxuXG5cbiAgX3JlYWRQcmVmaXgodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3ByZWZpeCcpIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgcHJlZml4IHRvIGZvbGxvdyBAcHJlZml4JywgdG9rZW4pO1xuICAgIHRoaXMuX3ByZWZpeCA9IHRva2VuLnZhbHVlO1xuICAgIHJldHVybiB0aGlzLl9yZWFkUHJlZml4SVJJO1xuICB9IC8vICMjIyBgX3JlYWRQcmVmaXhJUklgIHJlYWRzIHRoZSBJUkkgb2YgYSBwcmVmaXggZGVjbGFyYXRpb25cblxuXG4gIF9yZWFkUHJlZml4SVJJKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICdJUkknKSByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIElSSSB0byBmb2xsb3cgcHJlZml4IFwiJyArIHRoaXMuX3ByZWZpeCArICc6XCInLCB0b2tlbik7XG5cbiAgICB2YXIgcHJlZml4Tm9kZSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pO1xuXG4gICAgdGhpcy5fcHJlZml4ZXNbdGhpcy5fcHJlZml4XSA9IHByZWZpeE5vZGUudmFsdWU7XG5cbiAgICB0aGlzLl9wcmVmaXhDYWxsYmFjayh0aGlzLl9wcmVmaXgsIHByZWZpeE5vZGUpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9uO1xuICB9IC8vICMjIyBgX3JlYWRCYXNlSVJJYCByZWFkcyB0aGUgSVJJIG9mIGEgYmFzZSBkZWNsYXJhdGlvblxuXG5cbiAgX3JlYWRCYXNlSVJJKHRva2VuKSB7XG4gICAgdmFyIGlyaSA9IHRva2VuLnR5cGUgPT09ICdJUkknICYmIHRoaXMuX3Jlc29sdmVJUkkodG9rZW4udmFsdWUpO1xuXG4gICAgaWYgKCFpcmkpIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgdmFsaWQgSVJJIHRvIGZvbGxvdyBiYXNlIGRlY2xhcmF0aW9uJywgdG9rZW4pO1xuXG4gICAgdGhpcy5fc2V0QmFzZShpcmkpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9uO1xuICB9IC8vICMjIyBgX3JlYWROYW1lZEdyYXBoTGFiZWxgIHJlYWRzIHRoZSBsYWJlbCBvZiBhIG5hbWVkIGdyYXBoXG5cblxuICBfcmVhZE5hbWVkR3JhcGhMYWJlbCh0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgY2FzZSAnSVJJJzpcbiAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgIGNhc2UgJ3ByZWZpeGVkJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdWJqZWN0KHRva2VuKSwgdGhpcy5fcmVhZEdyYXBoO1xuXG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROYW1lZEdyYXBoQmxhbmtMYWJlbDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdJbnZhbGlkIGdyYXBoIGxhYmVsJywgdG9rZW4pO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9yZWFkTmFtZWRHcmFwaExhYmVsYCByZWFkcyBhIGJsYW5rIG5vZGUgbGFiZWwgb2YgYSBuYW1lZCBncmFwaFxuXG5cbiAgX3JlYWROYW1lZEdyYXBoQmxhbmtMYWJlbCh0b2tlbikge1xuICAgIGlmICh0b2tlbi50eXBlICE9PSAnXScpIHJldHVybiB0aGlzLl9lcnJvcignSW52YWxpZCBncmFwaCBsYWJlbCcsIHRva2VuKTtcbiAgICB0aGlzLl9zdWJqZWN0ID0gdGhpcy5fYmxhbmtOb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRHcmFwaDtcbiAgfSAvLyAjIyMgYF9yZWFkRGVjbGFyYXRpb25QdW5jdHVhdGlvbmAgcmVhZHMgdGhlIHB1bmN0dWF0aW9uIG9mIGEgZGVjbGFyYXRpb25cblxuXG4gIF9yZWFkRGVjbGFyYXRpb25QdW5jdHVhdGlvbih0b2tlbikge1xuICAgIC8vIFNQQVJRTC1zdHlsZSBkZWNsYXJhdGlvbnMgZG9uJ3QgaGF2ZSBwdW5jdHVhdGlvblxuICAgIGlmICh0aGlzLl9zcGFycWxTdHlsZSkge1xuICAgICAgdGhpcy5fc3BhcnFsU3R5bGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkSW5Ub3BDb250ZXh0KHRva2VuKTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJy4nKSByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIGRlY2xhcmF0aW9uIHRvIGVuZCB3aXRoIGEgZG90JywgdG9rZW4pO1xuICAgIHJldHVybiB0aGlzLl9yZWFkSW5Ub3BDb250ZXh0O1xuICB9IC8vIFJlYWRzIGEgbGlzdCBvZiBxdWFudGlmaWVkIHN5bWJvbHMgZnJvbSBhIEBmb3JTb21lIG9yIEBmb3JBbGwgc3RhdGVtZW50XG5cblxuICBfcmVhZFF1YW50aWZpZXJMaXN0KHRva2VuKSB7XG4gICAgdmFyIGVudGl0eTtcblxuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgY2FzZSAnSVJJJzpcbiAgICAgIGNhc2UgJ3ByZWZpeGVkJzpcbiAgICAgICAgaWYgKChlbnRpdHkgPSB0aGlzLl9yZWFkRW50aXR5KHRva2VuLCB0cnVlKSkgIT09IHVuZGVmaW5lZCkgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcignVW5leHBlY3RlZCAnICsgdG9rZW4udHlwZSwgdG9rZW4pO1xuICAgIH0gLy8gV2l0aG91dCBleHBsaWNpdCBxdWFudGlmaWVycywgbWFwIGVudGl0aWVzIHRvIGEgcXVhbnRpZmllZCBlbnRpdHlcblxuXG4gICAgaWYgKCF0aGlzLl9leHBsaWNpdFF1YW50aWZpZXJzKSB0aGlzLl9xdWFudGlmaWVkW2VudGl0eS5pZF0gPSB0aGlzLl9xdWFudGlmaWVyKHRoaXMuX2JsYW5rTm9kZSgpLnZhbHVlKTsgLy8gV2l0aCBleHBsaWNpdCBxdWFudGlmaWVycywgb3V0cHV0IHRoZSByZWlmaWVkIHF1YW50aWZpZXJcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgaXRlbSwgc3RhcnQgYSBuZXcgcXVhbnRpZmllciBsaXN0XG4gICAgICAgIGlmICh0aGlzLl9zdWJqZWN0ID09PSBudWxsKSB0aGlzLl9lbWl0KHRoaXMuX2dyYXBoIHx8IHRoaXMuREVGQVVMVEdSQVBILCB0aGlzLl9wcmVkaWNhdGUsIHRoaXMuX3N1YmplY3QgPSB0aGlzLl9ibGFua05vZGUoKSwgdGhpcy5RVUFOVElGSUVSU19HUkFQSCk7IC8vIE90aGVyd2lzZSwgY29udGludWUgdGhlIHByZXZpb3VzIGxpc3RcbiAgICAgICAgZWxzZSB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuUkRGX1JFU1QsIHRoaXMuX3N1YmplY3QgPSB0aGlzLl9ibGFua05vZGUoKSwgdGhpcy5RVUFOVElGSUVSU19HUkFQSCk7IC8vIE91dHB1dCB0aGUgbGlzdCBpdGVtXG5cbiAgICAgICAgdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LCB0aGlzLlJERl9GSVJTVCwgZW50aXR5LCB0aGlzLlFVQU5USUZJRVJTX0dSQVBIKTtcbiAgICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZFF1YW50aWZpZXJQdW5jdHVhdGlvbjtcbiAgfSAvLyBSZWFkcyBwdW5jdHVhdGlvbiBmcm9tIGEgQGZvclNvbWUgb3IgQGZvckFsbCBzdGF0ZW1lbnRcblxuXG4gIF9yZWFkUXVhbnRpZmllclB1bmN0dWF0aW9uKHRva2VuKSB7XG4gICAgLy8gUmVhZCBtb3JlIHF1YW50aWZpZXJzXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICcsJykgcmV0dXJuIHRoaXMuX3JlYWRRdWFudGlmaWVyTGlzdDsgLy8gRW5kIG9mIHRoZSBxdWFudGlmaWVyIGxpc3RcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gV2l0aCBleHBsaWNpdCBxdWFudGlmaWVycywgY2xvc2UgdGhlIHF1YW50aWZpZXIgbGlzdFxuICAgICAgICBpZiAodGhpcy5fZXhwbGljaXRRdWFudGlmaWVycykge1xuICAgICAgICAgIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5SREZfUkVTVCwgdGhpcy5SREZfTklMLCB0aGlzLlFVQU5USUZJRVJTX0dSQVBIKTtcblxuICAgICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICB9IC8vIFJlYWQgYSBkb3RcblxuXG4gICAgICAgIHRoaXMuX3JlYWRDYWxsYmFjayA9IHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRDYWxsYmFjayh0b2tlbik7XG4gICAgICB9XG4gIH0gLy8gIyMjIGBfZ2V0UGF0aFJlYWRlcmAgcmVhZHMgYSBwb3RlbnRpYWwgcGF0aCBhbmQgdGhlbiByZXN1bWVzIHdpdGggdGhlIGdpdmVuIGZ1bmN0aW9uXG5cblxuICBfZ2V0UGF0aFJlYWRlcihhZnRlclBhdGgpIHtcbiAgICB0aGlzLl9hZnRlclBhdGggPSBhZnRlclBhdGg7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQYXRoO1xuICB9IC8vICMjIyBgX3JlYWRQYXRoYCByZWFkcyBhIHBvdGVudGlhbCBwYXRoXG5cblxuICBfcmVhZFBhdGgodG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIC8vIEZvcndhcmQgcGF0aFxuICAgICAgY2FzZSAnISc6XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkRm9yd2FyZFBhdGg7XG4gICAgICAvLyBCYWNrd2FyZCBwYXRoXG5cbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZEJhY2t3YXJkUGF0aDtcbiAgICAgIC8vIE5vdCBhIHBhdGg7IHJlc3VtZSByZWFkaW5nIHdoZXJlIHdlIGxlZnQgb2ZmXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuX2NvbnRleHRTdGFjayxcbiAgICAgICAgICAgIHBhcmVudCA9IHN0YWNrLmxlbmd0aCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTsgLy8gSWYgd2Ugd2VyZSByZWFkaW5nIGEgbGlzdCBpdGVtLCB3ZSBzdGlsbCBuZWVkIHRvIG91dHB1dCBpdFxuXG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09ICdpdGVtJykge1xuICAgICAgICAgIC8vIFRoZSBsaXN0IGl0ZW0gaXMgdGhlIHJlbWFpbmluZyBzdWJlamN0IGFmdGVyIHJlYWRpbmcgdGhlIHBhdGhcbiAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3N1YmplY3Q7IC8vIFN3aXRjaCBiYWNrIHRvIHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0XG5cbiAgICAgICAgICB0aGlzLl9yZXN0b3JlQ29udGV4dCgpOyAvLyBPdXRwdXQgdGhlIGxpc3QgaXRlbVxuXG5cbiAgICAgICAgICB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuUkRGX0ZJUlNULCBpdGVtLCB0aGlzLl9ncmFwaCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fYWZ0ZXJQYXRoKHRva2VuKTtcbiAgICB9XG4gIH0gLy8gIyMjIGBfcmVhZEZvcndhcmRQYXRoYCByZWFkcyBhICchJyBwYXRoXG5cblxuICBfcmVhZEZvcndhcmRQYXRoKHRva2VuKSB7XG4gICAgdmFyIHN1YmplY3QsXG4gICAgICAgIHByZWRpY2F0ZSxcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5fYmxhbmtOb2RlKCk7IC8vIFRoZSBuZXh0IHRva2VuIGlzIHRoZSBwcmVkaWNhdGVcblxuXG4gICAgaWYgKChwcmVkaWNhdGUgPSB0aGlzLl9yZWFkRW50aXR5KHRva2VuKSkgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBJZiB3ZSB3ZXJlIHJlYWRpbmcgYSBzdWJqZWN0LCByZXBsYWNlIHRoZSBzdWJqZWN0IGJ5IHRoZSBwYXRoJ3Mgb2JqZWN0XG5cbiAgICBpZiAodGhpcy5fcHJlZGljYXRlID09PSBudWxsKSBzdWJqZWN0ID0gdGhpcy5fc3ViamVjdCwgdGhpcy5fc3ViamVjdCA9IG9iamVjdDsgLy8gSWYgd2Ugd2VyZSByZWFkaW5nIGFuIG9iamVjdCwgcmVwbGFjZSB0aGUgc3ViamVjdCBieSB0aGUgcGF0aCdzIG9iamVjdFxuICAgIGVsc2Ugc3ViamVjdCA9IHRoaXMuX29iamVjdCwgdGhpcy5fb2JqZWN0ID0gb2JqZWN0OyAvLyBFbWl0IHRoZSBwYXRoJ3MgY3VycmVudCBxdWFkIGFuZCByZWFkIGl0cyBuZXh0IHNlY3Rpb25cblxuICAgIHRoaXMuX2VtaXQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIHRoaXMuX2dyYXBoKTtcblxuICAgIHJldHVybiB0aGlzLl9yZWFkUGF0aDtcbiAgfSAvLyAjIyMgYF9yZWFkQmFja3dhcmRQYXRoYCByZWFkcyBhICdeJyBwYXRoXG5cblxuICBfcmVhZEJhY2t3YXJkUGF0aCh0b2tlbikge1xuICAgIHZhciBzdWJqZWN0ID0gdGhpcy5fYmxhbmtOb2RlKCksXG4gICAgICAgIHByZWRpY2F0ZSxcbiAgICAgICAgb2JqZWN0OyAvLyBUaGUgbmV4dCB0b2tlbiBpcyB0aGUgcHJlZGljYXRlXG5cblxuICAgIGlmICgocHJlZGljYXRlID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gSWYgd2Ugd2VyZSByZWFkaW5nIGEgc3ViamVjdCwgcmVwbGFjZSB0aGUgc3ViamVjdCBieSB0aGUgcGF0aCdzIHN1YmplY3RcblxuICAgIGlmICh0aGlzLl9wcmVkaWNhdGUgPT09IG51bGwpIG9iamVjdCA9IHRoaXMuX3N1YmplY3QsIHRoaXMuX3N1YmplY3QgPSBzdWJqZWN0OyAvLyBJZiB3ZSB3ZXJlIHJlYWRpbmcgYW4gb2JqZWN0LCByZXBsYWNlIHRoZSBzdWJqZWN0IGJ5IHRoZSBwYXRoJ3Mgc3ViamVjdFxuICAgIGVsc2Ugb2JqZWN0ID0gdGhpcy5fb2JqZWN0LCB0aGlzLl9vYmplY3QgPSBzdWJqZWN0OyAvLyBFbWl0IHRoZSBwYXRoJ3MgY3VycmVudCBxdWFkIGFuZCByZWFkIGl0cyBuZXh0IHNlY3Rpb25cblxuICAgIHRoaXMuX2VtaXQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIHRoaXMuX2dyYXBoKTtcblxuICAgIHJldHVybiB0aGlzLl9yZWFkUGF0aDtcbiAgfSAvLyAjIyMgYF9yZWFkUkRGU3RhclRhaWxPckdyYXBoYCByZWFkcyB0aGUgZ3JhcGggb2YgYSBuZXN0ZWQgUkRGKiBxdWFkIG9yIHRoZSBlbmQgb2YgYSBuZXN0ZWQgUkRGKiB0cmlwbGVcblxuXG4gIF9yZWFkUkRGU3RhclRhaWxPckdyYXBoKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICc+PicpIHtcbiAgICAgIC8vIEFuIGVudGl0eSBtZWFucyB0aGlzIGlzIGEgcXVhZCAob25seSBhbGxvd2VkIGlmIG5vdCBhbHJlYWR5IGluc2lkZSBhIGdyYXBoKVxuICAgICAgaWYgKHRoaXMuX3N1cHBvcnRzUXVhZHMgJiYgdGhpcy5fZ3JhcGggPT09IG51bGwgJiYgKHRoaXMuX2dyYXBoID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLl9yZWFkUkRGU3RhclRhaWw7XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkID4+IHRvIGZvbGxvdyBcIicgKyB0aGlzLl9vYmplY3QuaWQgKyAnXCInLCB0b2tlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRSREZTdGFyVGFpbCh0b2tlbik7XG4gIH0gLy8gIyMjIGBfcmVhZFJERlN0YXJUYWlsYCByZWFkcyB0aGUgZW5kIG9mIGEgbmVzdGVkIFJERiogdHJpcGxlXG5cblxuICBfcmVhZFJERlN0YXJUYWlsKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICc+PicpIHJldHVybiB0aGlzLl9lcnJvcihgRXhwZWN0ZWQgPj4gYnV0IGdvdCAke3Rva2VuLnR5cGV9YCwgdG9rZW4pOyAvLyBSZWFkIHRoZSBxdWFkIGFuZCByZXN0b3JlIHRoZSBwcmV2aW91cyBjb250ZXh0XG5cbiAgICBjb25zdCBxdWFkID0gdGhpcy5fcXVhZCh0aGlzLl9zdWJqZWN0LCB0aGlzLl9wcmVkaWNhdGUsIHRoaXMuX29iamVjdCwgdGhpcy5fZ3JhcGggfHwgdGhpcy5ERUZBVUxUR1JBUEgpO1xuXG4gICAgdGhpcy5fcmVzdG9yZUNvbnRleHQoKTsgLy8gSWYgdGhlIHRyaXBsZSB3YXMgdGhlIHN1YmplY3QsIGNvbnRpbnVlIGJ5IHJlYWRpbmcgdGhlIHByZWRpY2F0ZS5cblxuXG4gICAgaWYgKHRoaXMuX3N1YmplY3QgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3N1YmplY3QgPSBxdWFkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRQcmVkaWNhdGU7XG4gICAgfSAvLyBJZiB0aGUgdHJpcGxlIHdhcyB0aGUgb2JqZWN0LCByZWFkIGNvbnRleHQgZW5kLlxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9vYmplY3QgPSBxdWFkO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpO1xuICAgICAgfVxuICB9IC8vICMjIyBgX2dldENvbnRleHRFbmRSZWFkZXJgIGdldHMgdGhlIG5leHQgcmVhZGVyIGZ1bmN0aW9uIGF0IHRoZSBlbmQgb2YgYSBjb250ZXh0XG5cblxuICBfZ2V0Q29udGV4dEVuZFJlYWRlcigpIHtcbiAgICB2YXIgY29udGV4dFN0YWNrID0gdGhpcy5fY29udGV4dFN0YWNrO1xuICAgIGlmICghY29udGV4dFN0YWNrLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlYWRQdW5jdHVhdGlvbjtcblxuICAgIHN3aXRjaCAoY29udGV4dFN0YWNrW2NvbnRleHRTdGFjay5sZW5ndGggLSAxXS50eXBlKSB7XG4gICAgICBjYXNlICdibGFuayc6XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkQmxhbmtOb2RlVGFpbDtcblxuICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTGlzdEl0ZW07XG5cbiAgICAgIGNhc2UgJ2Zvcm11bGEnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZEZvcm11bGFUYWlsO1xuXG4gICAgICBjYXNlICc8PCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkUkRGU3RhclRhaWxPckdyYXBoO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9lbWl0YCBzZW5kcyBhIHF1YWQgdGhyb3VnaCB0aGUgY2FsbGJhY2tcblxuXG4gIF9lbWl0KHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHRoaXMuX2NhbGxiYWNrKG51bGwsIHRoaXMuX3F1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoIHx8IHRoaXMuREVGQVVMVEdSQVBIKSk7XG4gIH0gLy8gIyMjIGBfZXJyb3JgIGVtaXRzIGFuIGVycm9yIG1lc3NhZ2UgdGhyb3VnaCB0aGUgY2FsbGJhY2tcblxuXG4gIF9lcnJvcihtZXNzYWdlLCB0b2tlbikge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSArICcgb24gbGluZSAnICsgdG9rZW4ubGluZSArICcuJyk7XG4gICAgZXJyLmNvbnRleHQgPSB7XG4gICAgICB0b2tlbjogdG9rZW4sXG4gICAgICBsaW5lOiB0b2tlbi5saW5lLFxuICAgICAgcHJldmlvdXNUb2tlbjogdGhpcy5fbGV4ZXIucHJldmlvdXNUb2tlblxuICAgIH07XG5cbiAgICB0aGlzLl9jYWxsYmFjayhlcnIpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBub29wO1xuICB9IC8vICMjIyBgX3Jlc29sdmVJUklgIHJlc29sdmVzIGFuIElSSSBhZ2FpbnN0IHRoZSBiYXNlIHBhdGhcblxuXG4gIF9yZXNvbHZlSVJJKGlyaSkge1xuICAgIHJldHVybiAvXlthLXpdW2EtejAtOSsuLV0qOi9pLnRlc3QoaXJpKSA/IGlyaSA6IHRoaXMuX3Jlc29sdmVSZWxhdGl2ZUlSSShpcmkpO1xuICB9IC8vICMjIyBgX3Jlc29sdmVSZWxhdGl2ZUlSSWAgcmVzb2x2ZXMgYW4gSVJJIGFnYWluc3QgdGhlIGJhc2UgcGF0aCxcbiAgLy8gYXNzdW1pbmcgdGhhdCBhIGJhc2UgcGF0aCBoYXMgYmVlbiBzZXQgYW5kIHRoYXQgdGhlIElSSSBpcyBpbmRlZWQgcmVsYXRpdmVcblxuXG4gIF9yZXNvbHZlUmVsYXRpdmVJUkkoaXJpKSB7XG4gICAgLy8gQW4gZW1wdHkgcmVsYXRpdmUgSVJJIGluZGljYXRlcyB0aGUgYmFzZSBJUklcbiAgICBpZiAoIWlyaS5sZW5ndGgpIHJldHVybiB0aGlzLl9iYXNlOyAvLyBEZWNpZGUgcmVzb2x2aW5nIHN0cmF0ZWd5IGJhc2VkIGluIHRoZSBmaXJzdCBjaGFyYWN0ZXJcblxuICAgIHN3aXRjaCAoaXJpWzBdKSB7XG4gICAgICAvLyBSZXNvbHZlIHJlbGF0aXZlIGZyYWdtZW50IElSSXMgYWdhaW5zdCB0aGUgYmFzZSBJUklcbiAgICAgIGNhc2UgJyMnOlxuICAgICAgICByZXR1cm4gdGhpcy5fYmFzZSArIGlyaTtcbiAgICAgIC8vIFJlc29sdmUgcmVsYXRpdmUgcXVlcnkgc3RyaW5nIElSSXMgYnkgcmVwbGFjaW5nIHRoZSBxdWVyeSBzdHJpbmdcblxuICAgICAgY2FzZSAnPyc6XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXNlLnJlcGxhY2UoLyg/OlxcPy4qKT8kLywgaXJpKTtcbiAgICAgIC8vIFJlc29sdmUgcm9vdC1yZWxhdGl2ZSBJUklzIGF0IHRoZSByb290IG9mIHRoZSBiYXNlIElSSVxuXG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgLy8gUmVzb2x2ZSBzY2hlbWUtcmVsYXRpdmUgSVJJcyB0byB0aGUgc2NoZW1lXG4gICAgICAgIHJldHVybiAoaXJpWzFdID09PSAnLycgPyB0aGlzLl9iYXNlU2NoZW1lIDogdGhpcy5fYmFzZVJvb3QpICsgdGhpcy5fcmVtb3ZlRG90U2VnbWVudHMoaXJpKTtcbiAgICAgIC8vIFJlc29sdmUgYWxsIG90aGVyIElSSXMgYXQgdGhlIGJhc2UgSVJJJ3MgcGF0aFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBSZWxhdGl2ZSBJUklzIGNhbm5vdCBjb250YWluIGEgY29sb24gaW4gdGhlIGZpcnN0IHBhdGggc2VnbWVudFxuICAgICAgICByZXR1cm4gL15bXi86XSo6Ly50ZXN0KGlyaSkgPyBudWxsIDogdGhpcy5fcmVtb3ZlRG90U2VnbWVudHModGhpcy5fYmFzZVBhdGggKyBpcmkpO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9yZW1vdmVEb3RTZWdtZW50c2AgcmVzb2x2ZXMgJy4vJyBhbmQgJy4uLycgcGF0aCBzZWdtZW50cyBpbiBhbiBJUkkgYXMgcGVyIFJGQzM5ODZcblxuXG4gIF9yZW1vdmVEb3RTZWdtZW50cyhpcmkpIHtcbiAgICAvLyBEb24ndCBtb2RpZnkgdGhlIElSSSBpZiBpdCBkb2VzIG5vdCBjb250YWluIGFueSBkb3Qgc2VnbWVudHNcbiAgICBpZiAoIS8oXnxcXC8pXFwuXFwuPygkfFsvIz9dKS8udGVzdChpcmkpKSByZXR1cm4gaXJpOyAvLyBTdGFydCB3aXRoIGFuIGltYWdpbmFyeSBzbGFzaCBiZWZvcmUgdGhlIElSSSBpbiBvcmRlciB0byByZXNvbHZlIHRyYWlsaW5nICcuLycgYW5kICcuLi8nXG5cbiAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgIGxlbmd0aCA9IGlyaS5sZW5ndGgsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgcGF0aFN0YXJ0ID0gLTEsXG4gICAgICAgIHNlZ21lbnRTdGFydCA9IDAsXG4gICAgICAgIG5leHQgPSAnLyc7XG5cbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgc3dpdGNoIChuZXh0KSB7XG4gICAgICAgIC8vIFRoZSBwYXRoIHN0YXJ0cyB3aXRoIHRoZSBmaXJzdCBzbGFzaCBhZnRlciB0aGUgYXV0aG9yaXR5XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgIGlmIChwYXRoU3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHR3byBzbGFzaGVzIGJlZm9yZSB0aGUgYXV0aG9yaXR5XG4gICAgICAgICAgICBpZiAoaXJpWysraV0gPT09ICcvJyAmJiBpcmlbKytpXSA9PT0gJy8nKSAvLyBTa2lwIHRvIHNsYXNoIGFmdGVyIHRoZSBhdXRob3JpdHlcbiAgICAgICAgICAgICAgd2hpbGUgKChwYXRoU3RhcnQgPSBpICsgMSkgPCBsZW5ndGggJiYgaXJpW3BhdGhTdGFydF0gIT09ICcvJykgaSA9IHBhdGhTdGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRG9uJ3QgbW9kaWZ5IGEgcXVlcnkgc3RyaW5nIG9yIGZyYWdtZW50XG5cbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgIGkgPSBsZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEhhbmRsZSAnLy4nIG9yICcvLi4nIHBhdGggc2VnbWVudHNcblxuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICBpZiAoaXJpW2kgKyAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBuZXh0ID0gaXJpWysraSArIDFdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG5leHQpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGEgJy8uJyBzZWdtZW50XG4gICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBpcmkuc3Vic3RyaW5nKHNlZ21lbnRTdGFydCwgaSAtIDEpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRTdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgYSB0cmFpbGluZyAnLy4nIHNlZ21lbnRcblxuICAgICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyBpcmkuc3Vic3RyaW5nKHNlZ21lbnRTdGFydCwgaSkgKyBpcmkuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGEgJy8uLicgc2VnbWVudFxuXG4gICAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgIG5leHQgPSBpcmlbKytpICsgMV07XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gdW5kZWZpbmVkIHx8IG5leHQgPT09ICcvJyB8fCBuZXh0ID09PSAnPycgfHwgbmV4dCA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gaXJpLnN1YnN0cmluZyhzZWdtZW50U3RhcnQsIGkgLSAyKTsgLy8gVHJ5IHRvIHJlbW92ZSB0aGUgcGFyZW50IHBhdGggZnJvbSByZXN1bHRcblxuICAgICAgICAgICAgICAgICAgaWYgKChzZWdtZW50U3RhcnQgPSByZXN1bHQubGFzdEluZGV4T2YoJy8nKSkgPj0gcGF0aFN0YXJ0KSByZXN1bHQgPSByZXN1bHQuc3Vic3RyKDAsIHNlZ21lbnRTdGFydCk7IC8vIFJlbW92ZSBhIHRyYWlsaW5nICcvLi4nIHNlZ21lbnRcblxuICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09ICcvJykgcmV0dXJuIHJlc3VsdCArICcvJyArIGlyaS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgc2VnbWVudFN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIG5leHQgPSBpcmlbKytpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICsgaXJpLnN1YnN0cmluZyhzZWdtZW50U3RhcnQpO1xuICB9IC8vICMjIFB1YmxpYyBtZXRob2RzXG4gIC8vICMjIyBgcGFyc2VgIHBhcnNlcyB0aGUgTjMgaW5wdXQgYW5kIGVtaXRzIGVhY2ggcGFyc2VkIHF1YWQgdGhyb3VnaCB0aGUgY2FsbGJhY2tcblxuXG4gIHBhcnNlKGlucHV0LCBxdWFkQ2FsbGJhY2ssIHByZWZpeENhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBUaGUgcmVhZCBjYWxsYmFjayBpcyB0aGUgbmV4dCBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIGEgdG9rZW4gYXJyaXZlcy5cbiAgICAvLyBXZSBzdGFydCByZWFkaW5nIGluIHRoZSB0b3AgY29udGV4dC5cblxuICAgIHRoaXMuX3JlYWRDYWxsYmFjayA9IHRoaXMuX3JlYWRJblRvcENvbnRleHQ7XG4gICAgdGhpcy5fc3BhcnFsU3R5bGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wcmVmaXhlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcHJlZml4ZXMuXyA9IHRoaXMuX2JsYW5rTm9kZVByZWZpeCA/IHRoaXMuX2JsYW5rTm9kZVByZWZpeC5zdWJzdHIoMikgOiAnYicgKyBibGFua05vZGVQcmVmaXgrKyArICdfJztcbiAgICB0aGlzLl9wcmVmaXhDYWxsYmFjayA9IHByZWZpeENhbGxiYWNrIHx8IG5vb3A7XG4gICAgdGhpcy5faW52ZXJzZVByZWRpY2F0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1YW50aWZpZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBQYXJzZSBzeW5jaHJvbm91c2x5IGlmIG5vIHF1YWQgY2FsbGJhY2sgaXMgZ2l2ZW5cblxuICAgIGlmICghcXVhZENhbGxiYWNrKSB7XG4gICAgICB2YXIgcXVhZHMgPSBbXSxcbiAgICAgICAgICBlcnJvcjtcblxuICAgICAgdGhpcy5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBlID8gZXJyb3IgPSBlIDogdCAmJiBxdWFkcy5wdXNoKHQpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fbGV4ZXIudG9rZW5pemUoaW5wdXQpLmV2ZXJ5KGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gc2VsZi5fcmVhZENhbGxiYWNrID0gc2VsZi5fcmVhZENhbGxiYWNrKHRva2VuKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgICAgcmV0dXJuIHF1YWRzO1xuICAgIH0gLy8gUGFyc2UgYXN5bmNocm9ub3VzbHkgb3RoZXJ3aXNlLCBleGVjdXRpbmcgdGhlIHJlYWQgY2FsbGJhY2sgd2hlbiBhIHRva2VuIGFycml2ZXNcblxuXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBxdWFkQ2FsbGJhY2s7XG5cbiAgICB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCwgZnVuY3Rpb24gKGVycm9yLCB0b2tlbikge1xuICAgICAgaWYgKGVycm9yICE9PSBudWxsKSBzZWxmLl9jYWxsYmFjayhlcnJvciksIHNlbGYuX2NhbGxiYWNrID0gbm9vcDtlbHNlIGlmIChzZWxmLl9yZWFkQ2FsbGJhY2spIHNlbGYuX3JlYWRDYWxsYmFjayA9IHNlbGYuX3JlYWRDYWxsYmFjayh0b2tlbik7XG4gICAgfSk7XG4gIH1cblxufSAvLyBUaGUgZW1wdHkgZnVuY3Rpb25cblxuXG5leHBvcnRzLmRlZmF1bHQgPSBOM1BhcnNlcjtcblxuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIEluaXRpYWxpemVzIHRoZSBwYXJzZXIgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmYWN0b3J5XG5cblxuZnVuY3Rpb24gaW5pdERhdGFGYWN0b3J5KHBhcnNlciwgZmFjdG9yeSkge1xuICAvLyBTZXQgZmFjdG9yeSBtZXRob2RzXG4gIHZhciBuYW1lZE5vZGUgPSBmYWN0b3J5Lm5hbWVkTm9kZTtcbiAgcGFyc2VyLl9uYW1lZE5vZGUgPSBuYW1lZE5vZGU7XG4gIHBhcnNlci5fYmxhbmtOb2RlID0gZmFjdG9yeS5ibGFua05vZGU7XG4gIHBhcnNlci5fbGl0ZXJhbCA9IGZhY3RvcnkubGl0ZXJhbDtcbiAgcGFyc2VyLl92YXJpYWJsZSA9IGZhY3RvcnkudmFyaWFibGU7XG4gIHBhcnNlci5fcXVhZCA9IGZhY3RvcnkucXVhZDtcbiAgcGFyc2VyLkRFRkFVTFRHUkFQSCA9IGZhY3RvcnkuZGVmYXVsdEdyYXBoKCk7IC8vIFNldCBjb21tb24gbmFtZWQgbm9kZXNcblxuICBwYXJzZXIuUkRGX0ZJUlNUID0gbmFtZWROb2RlKF9JUklzLmRlZmF1bHQucmRmLmZpcnN0KTtcbiAgcGFyc2VyLlJERl9SRVNUID0gbmFtZWROb2RlKF9JUklzLmRlZmF1bHQucmRmLnJlc3QpO1xuICBwYXJzZXIuUkRGX05JTCA9IG5hbWVkTm9kZShfSVJJcy5kZWZhdWx0LnJkZi5uaWwpO1xuICBwYXJzZXIuTjNfRk9SQUxMID0gbmFtZWROb2RlKF9JUklzLmRlZmF1bHQuci5mb3JBbGwpO1xuICBwYXJzZXIuTjNfRk9SU09NRSA9IG5hbWVkTm9kZShfSVJJcy5kZWZhdWx0LnIuZm9yU29tZSk7XG4gIHBhcnNlci5BQkJSRVZJQVRJT05TID0ge1xuICAgICdhJzogbmFtZWROb2RlKF9JUklzLmRlZmF1bHQucmRmLnR5cGUpLFxuICAgICc9JzogbmFtZWROb2RlKF9JUklzLmRlZmF1bHQub3dsLnNhbWVBcyksXG4gICAgJz4nOiBuYW1lZE5vZGUoX0lSSXMuZGVmYXVsdC5sb2cuaW1wbGllcylcbiAgfTtcbiAgcGFyc2VyLlFVQU5USUZJRVJTX0dSQVBIID0gbmFtZWROb2RlKCd1cm46bjM6cXVhbnRpZmllcnMnKTtcbn1cblxuaW5pdERhdGFGYWN0b3J5KE4zUGFyc2VyLnByb3RvdHlwZSwgX04zRGF0YUZhY3RvcnkuZGVmYXVsdCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfTjNEYXRhRmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL04zRGF0YUZhY3RvcnlcIikpO1xuXG52YXIgX3JlYWRhYmxlU3RyZWFtID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKTtcblxudmFyIF9JUklzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9JUklzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8vICoqTjNTdG9yZSoqIG9iamVjdHMgc3RvcmUgTjMgcXVhZHMgYnkgZ3JhcGggaW4gbWVtb3J5LlxuLy8gIyMgQ29uc3RydWN0b3JcbmNsYXNzIE4zU3RvcmUge1xuICBjb25zdHJ1Y3RvcihxdWFkcywgb3B0aW9ucykge1xuICAgIC8vIFRoZSBudW1iZXIgb2YgcXVhZHMgaXMgaW5pdGlhbGx5IHplcm9cbiAgICB0aGlzLl9zaXplID0gMDsgLy8gYF9ncmFwaHNgIGNvbnRhaW5zIHN1YmplY3QsIHByZWRpY2F0ZSwgYW5kIG9iamVjdCBpbmRleGVzIHBlciBncmFwaFxuXG4gICAgdGhpcy5fZ3JhcGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gYF9pZHNgIG1hcHMgZW50aXRpZXMgc3VjaCBhcyBgaHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9uYW1lYCB0byBudW1iZXJzLFxuICAgIC8vIHNhdmluZyBtZW1vcnkgYnkgdXNpbmcgb25seSBudW1iZXJzIGFzIGtleXMgaW4gYF9ncmFwaHNgXG5cbiAgICB0aGlzLl9pZCA9IDA7XG4gICAgdGhpcy5faWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9pZHNbJz48J10gPSAwOyAvLyBkdW1teSBlbnRyeSwgc28gdGhlIGZpcnN0IGFjdHVhbCBrZXkgaXMgbm9uLXplcm9cblxuICAgIHRoaXMuX2VudGl0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gaW52ZXJzZSBvZiBgX2lkc2BcbiAgICAvLyBgX2JsYW5rTm9kZUluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgYXV0b21hdGljYWxseSBuYW1lZCBibGFuayBub2RlXG5cbiAgICB0aGlzLl9ibGFua05vZGVJbmRleCA9IDA7IC8vIFNoaWZ0IHBhcmFtZXRlcnMgaWYgYHF1YWRzYCBpcyBub3QgZ2l2ZW5cblxuICAgIGlmICghb3B0aW9ucyAmJiBxdWFkcyAmJiAhcXVhZHNbMF0pIG9wdGlvbnMgPSBxdWFkcywgcXVhZHMgPSBudWxsO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX2ZhY3RvcnkgPSBvcHRpb25zLmZhY3RvcnkgfHwgX04zRGF0YUZhY3RvcnkuZGVmYXVsdDsgLy8gQWRkIHF1YWRzIGlmIHBhc3NlZFxuXG4gICAgaWYgKHF1YWRzKSB0aGlzLmFkZFF1YWRzKHF1YWRzKTtcbiAgfSAvLyAjIyBQdWJsaWMgcHJvcGVydGllc1xuICAvLyAjIyMgYHNpemVgIHJldHVybnMgdGhlIG51bWJlciBvZiBxdWFkcyBpbiB0aGUgc3RvcmVcblxuXG4gIGdldCBzaXplKCkge1xuICAgIC8vIFJldHVybiB0aGUgcXVhZCBjb3VudCBpZiBpZiB3YXMgY2FjaGVkXG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIGlmIChzaXplICE9PSBudWxsKSByZXR1cm4gc2l6ZTsgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgcXVhZHMgYnkgY291bnRpbmcgdG8gdGhlIGRlZXBlc3QgbGV2ZWxcblxuICAgIHNpemUgPSAwO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLl9ncmFwaHMsXG4gICAgICAgIHN1YmplY3RzLFxuICAgICAgICBzdWJqZWN0O1xuXG4gICAgZm9yICh2YXIgZ3JhcGhLZXkgaW4gZ3JhcGhzKSBmb3IgKHZhciBzdWJqZWN0S2V5IGluIHN1YmplY3RzID0gZ3JhcGhzW2dyYXBoS2V5XS5zdWJqZWN0cykgZm9yICh2YXIgcHJlZGljYXRlS2V5IGluIHN1YmplY3QgPSBzdWJqZWN0c1tzdWJqZWN0S2V5XSkgc2l6ZSArPSBPYmplY3Qua2V5cyhzdWJqZWN0W3ByZWRpY2F0ZUtleV0pLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zaXplID0gc2l6ZTtcbiAgfSAvLyAjIyBQcml2YXRlIG1ldGhvZHNcbiAgLy8gIyMjIGBfYWRkVG9JbmRleGAgYWRkcyBhIHF1YWQgdG8gYSB0aHJlZS1sYXllcmVkIGluZGV4LlxuICAvLyBSZXR1cm5zIGlmIHRoZSBpbmRleCBoYXMgY2hhbmdlZCwgaWYgdGhlIGVudHJ5IGRpZCBub3QgYWxyZWFkeSBleGlzdC5cblxuXG4gIF9hZGRUb0luZGV4KGluZGV4MCwga2V5MCwga2V5MSwga2V5Mikge1xuICAgIC8vIENyZWF0ZSBsYXllcnMgYXMgbmVjZXNzYXJ5XG4gICAgdmFyIGluZGV4MSA9IGluZGV4MFtrZXkwXSB8fCAoaW5kZXgwW2tleTBdID0ge30pO1xuICAgIHZhciBpbmRleDIgPSBpbmRleDFba2V5MV0gfHwgKGluZGV4MVtrZXkxXSA9IHt9KTsgLy8gU2V0dGluZyB0aGUga2V5IHRvIF9hbnlfIHZhbHVlIHNpZ25hbHMgdGhlIHByZXNlbmNlIG9mIHRoZSBxdWFkXG5cbiAgICB2YXIgZXhpc3RlZCA9IChrZXkyIGluIGluZGV4Mik7XG4gICAgaWYgKCFleGlzdGVkKSBpbmRleDJba2V5Ml0gPSBudWxsO1xuICAgIHJldHVybiAhZXhpc3RlZDtcbiAgfSAvLyAjIyMgYF9yZW1vdmVGcm9tSW5kZXhgIHJlbW92ZXMgYSBxdWFkIGZyb20gYSB0aHJlZS1sYXllcmVkIGluZGV4XG5cblxuICBfcmVtb3ZlRnJvbUluZGV4KGluZGV4MCwga2V5MCwga2V5MSwga2V5Mikge1xuICAgIC8vIFJlbW92ZSB0aGUgcXVhZCBmcm9tIHRoZSBpbmRleFxuICAgIHZhciBpbmRleDEgPSBpbmRleDBba2V5MF0sXG4gICAgICAgIGluZGV4MiA9IGluZGV4MVtrZXkxXSxcbiAgICAgICAga2V5O1xuICAgIGRlbGV0ZSBpbmRleDJba2V5Ml07IC8vIFJlbW92ZSBpbnRlcm1lZGlhcnkgaW5kZXggbGF5ZXJzIGlmIHRoZXkgYXJlIGVtcHR5XG5cbiAgICBmb3IgKGtleSBpbiBpbmRleDIpIHJldHVybjtcblxuICAgIGRlbGV0ZSBpbmRleDFba2V5MV07XG5cbiAgICBmb3IgKGtleSBpbiBpbmRleDEpIHJldHVybjtcblxuICAgIGRlbGV0ZSBpbmRleDBba2V5MF07XG4gIH0gLy8gIyMjIGBfZmluZEluSW5kZXhgIGZpbmRzIGEgc2V0IG9mIHF1YWRzIGluIGEgdGhyZWUtbGF5ZXJlZCBpbmRleC5cbiAgLy8gVGhlIGluZGV4IGJhc2UgaXMgYGluZGV4MGAgYW5kIHRoZSBrZXlzIGF0IGVhY2ggbGV2ZWwgYXJlIGBrZXkwYCwgYGtleTFgLCBhbmQgYGtleTJgLlxuICAvLyBBbnkgb2YgdGhlc2Uga2V5cyBjYW4gYmUgdW5kZWZpbmVkLCB3aGljaCBpcyBpbnRlcnByZXRlZCBhcyBhIHdpbGRjYXJkLlxuICAvLyBgbmFtZTBgLCBgbmFtZTFgLCBhbmQgYG5hbWUyYCBhcmUgdGhlIG5hbWVzIG9mIHRoZSBrZXlzIGF0IGVhY2ggbGV2ZWwsXG4gIC8vIHVzZWQgd2hlbiByZWNvbnN0cnVjdGluZyB0aGUgcmVzdWx0aW5nIHF1YWRcbiAgLy8gKGZvciBpbnN0YW5jZTogX3N1YmplY3RfLCBfcHJlZGljYXRlXywgYW5kIF9vYmplY3RfKS5cbiAgLy8gRmluYWxseSwgYGdyYXBoYCB3aWxsIGJlIHRoZSBncmFwaCBvZiB0aGUgY3JlYXRlZCBxdWFkcy5cbiAgLy8gSWYgYGNhbGxiYWNrYCBpcyBnaXZlbiwgZWFjaCByZXN1bHQgaXMgcGFzc2VkIHRocm91Z2ggaXRcbiAgLy8gYW5kIGl0ZXJhdGlvbiBoYWx0cyB3aGVuIGl0IHJldHVybnMgdHJ1dGh5IGZvciBhbnkgcXVhZC5cbiAgLy8gSWYgaW5zdGVhZCBgYXJyYXlgIGlzIGdpdmVuLCBlYWNoIHJlc3VsdCBpcyBhZGRlZCB0byB0aGUgYXJyYXkuXG5cblxuICBfZmluZEluSW5kZXgoaW5kZXgwLCBrZXkwLCBrZXkxLCBrZXkyLCBuYW1lMCwgbmFtZTEsIG5hbWUyLCBncmFwaCwgY2FsbGJhY2ssIGFycmF5KSB7XG4gICAgdmFyIHRtcCxcbiAgICAgICAgaW5kZXgxLFxuICAgICAgICBpbmRleDIsXG4gICAgICAgIHZhckNvdW50ID0gIWtleTAgKyAha2V5MSArICFrZXkyLFxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIG51bWJlciBvZiB2YXJpYWJsZXMsIGtleXMgb3IgcmV2ZXJzZSBpbmRleCBhcmUgZmFzdGVyXG4gICAgZW50aXR5S2V5cyA9IHZhckNvdW50ID4gMSA/IE9iamVjdC5rZXlzKHRoaXMuX2lkcykgOiB0aGlzLl9lbnRpdGllczsgLy8gSWYgYSBrZXkgaXMgc3BlY2lmaWVkLCB1c2Ugb25seSB0aGF0IHBhcnQgb2YgaW5kZXggMC5cblxuICAgIGlmIChrZXkwKSAodG1wID0gaW5kZXgwLCBpbmRleDAgPSB7fSlba2V5MF0gPSB0bXBba2V5MF07XG5cbiAgICBmb3IgKHZhciB2YWx1ZTAgaW4gaW5kZXgwKSB7XG4gICAgICB2YXIgZW50aXR5MCA9IGVudGl0eUtleXNbdmFsdWUwXTtcblxuICAgICAgaWYgKGluZGV4MSA9IGluZGV4MFt2YWx1ZTBdKSB7XG4gICAgICAgIC8vIElmIGEga2V5IGlzIHNwZWNpZmllZCwgdXNlIG9ubHkgdGhhdCBwYXJ0IG9mIGluZGV4IDEuXG4gICAgICAgIGlmIChrZXkxKSAodG1wID0gaW5kZXgxLCBpbmRleDEgPSB7fSlba2V5MV0gPSB0bXBba2V5MV07XG5cbiAgICAgICAgZm9yICh2YXIgdmFsdWUxIGluIGluZGV4MSkge1xuICAgICAgICAgIHZhciBlbnRpdHkxID0gZW50aXR5S2V5c1t2YWx1ZTFdO1xuXG4gICAgICAgICAgaWYgKGluZGV4MiA9IGluZGV4MVt2YWx1ZTFdKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHVzZSBvbmx5IHRoYXQgcGFydCBvZiBpbmRleCAyLCBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0ga2V5MiA/IGtleTIgaW4gaW5kZXgyID8gW2tleTJdIDogW10gOiBPYmplY3Qua2V5cyhpbmRleDIpOyAvLyBDcmVhdGUgcXVhZHMgZm9yIGFsbCBpdGVtcyBmb3VuZCBpbiBpbmRleCAyLlxuXG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHZhbHVlcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSB7XG4gICAgICAgICAgICAgICAgc3ViamVjdDogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBudWxsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHBhcnRzW25hbWUwXSA9ICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtRnJvbUlkKShlbnRpdHkwLCB0aGlzLl9mYWN0b3J5KTtcbiAgICAgICAgICAgICAgcGFydHNbbmFtZTFdID0gKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Gcm9tSWQpKGVudGl0eTEsIHRoaXMuX2ZhY3RvcnkpO1xuICAgICAgICAgICAgICBwYXJ0c1tuYW1lMl0gPSAoMCwgX04zRGF0YUZhY3RvcnkudGVybUZyb21JZCkoZW50aXR5S2V5c1t2YWx1ZXNbbF1dLCB0aGlzLl9mYWN0b3J5KTtcblxuICAgICAgICAgICAgICB2YXIgcXVhZCA9IHRoaXMuX2ZhY3RvcnkucXVhZChwYXJ0cy5zdWJqZWN0LCBwYXJ0cy5wcmVkaWNhdGUsIHBhcnRzLm9iamVjdCwgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Gcm9tSWQpKGdyYXBoLCB0aGlzLl9mYWN0b3J5KSk7XG5cbiAgICAgICAgICAgICAgaWYgKGFycmF5KSBhcnJheS5wdXNoKHF1YWQpO2Vsc2UgaWYgKGNhbGxiYWNrKHF1YWQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0gLy8gIyMjIGBfbG9vcGAgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBrZXlzIG9mIGluZGV4IDBcblxuXG4gIF9sb29wKGluZGV4MCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBrZXkwIGluIGluZGV4MCkgY2FsbGJhY2soa2V5MCk7XG4gIH0gLy8gIyMjIGBfbG9vcEJ5S2V5MGAgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBrZXlzIG9mIGEgY2VydGFpbiBlbnRyeSBpbiBpbmRleCAwXG5cblxuICBfbG9vcEJ5S2V5MChpbmRleDAsIGtleTAsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGluZGV4MSwga2V5MTtcblxuICAgIGlmIChpbmRleDEgPSBpbmRleDBba2V5MF0pIHtcbiAgICAgIGZvciAoa2V5MSBpbiBpbmRleDEpIGNhbGxiYWNrKGtleTEpO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9sb29wQnlLZXkxYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gZ2l2ZW4ga2V5cyBvZiBhbGwgZW50cmllcyBpbiBpbmRleCAwXG5cblxuICBfbG9vcEJ5S2V5MShpbmRleDAsIGtleTEsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGtleTAsIGluZGV4MTtcblxuICAgIGZvciAoa2V5MCBpbiBpbmRleDApIHtcbiAgICAgIGluZGV4MSA9IGluZGV4MFtrZXkwXTtcbiAgICAgIGlmIChpbmRleDFba2V5MV0pIGNhbGxiYWNrKGtleTApO1xuICAgIH1cbiAgfSAvLyAjIyMgYF9sb29wQnkyS2V5c2AgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGdpdmVuIGtleXMgb2YgY2VydGFpbiBlbnRyaWVzIGluIGluZGV4IDJcblxuXG4gIF9sb29wQnkyS2V5cyhpbmRleDAsIGtleTAsIGtleTEsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGluZGV4MSwgaW5kZXgyLCBrZXkyO1xuXG4gICAgaWYgKChpbmRleDEgPSBpbmRleDBba2V5MF0pICYmIChpbmRleDIgPSBpbmRleDFba2V5MV0pKSB7XG4gICAgICBmb3IgKGtleTIgaW4gaW5kZXgyKSBjYWxsYmFjayhrZXkyKTtcbiAgICB9XG4gIH0gLy8gIyMjIGBfY291bnRJbkluZGV4YCBjb3VudHMgbWF0Y2hpbmcgcXVhZHMgaW4gYSB0aHJlZS1sYXllcmVkIGluZGV4LlxuICAvLyBUaGUgaW5kZXggYmFzZSBpcyBgaW5kZXgwYCBhbmQgdGhlIGtleXMgYXQgZWFjaCBsZXZlbCBhcmUgYGtleTBgLCBga2V5MWAsIGFuZCBga2V5MmAuXG4gIC8vIEFueSBvZiB0aGVzZSBrZXlzIGNhbiBiZSB1bmRlZmluZWQsIHdoaWNoIGlzIGludGVycHJldGVkIGFzIGEgd2lsZGNhcmQuXG5cblxuICBfY291bnRJbkluZGV4KGluZGV4MCwga2V5MCwga2V5MSwga2V5Mikge1xuICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgIHRtcCxcbiAgICAgICAgaW5kZXgxLFxuICAgICAgICBpbmRleDI7IC8vIElmIGEga2V5IGlzIHNwZWNpZmllZCwgY291bnQgb25seSB0aGF0IHBhcnQgb2YgaW5kZXggMFxuXG4gICAgaWYgKGtleTApICh0bXAgPSBpbmRleDAsIGluZGV4MCA9IHt9KVtrZXkwXSA9IHRtcFtrZXkwXTtcblxuICAgIGZvciAodmFyIHZhbHVlMCBpbiBpbmRleDApIHtcbiAgICAgIGlmIChpbmRleDEgPSBpbmRleDBbdmFsdWUwXSkge1xuICAgICAgICAvLyBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIGNvdW50IG9ubHkgdGhhdCBwYXJ0IG9mIGluZGV4IDFcbiAgICAgICAgaWYgKGtleTEpICh0bXAgPSBpbmRleDEsIGluZGV4MSA9IHt9KVtrZXkxXSA9IHRtcFtrZXkxXTtcblxuICAgICAgICBmb3IgKHZhciB2YWx1ZTEgaW4gaW5kZXgxKSB7XG4gICAgICAgICAgaWYgKGluZGV4MiA9IGluZGV4MVt2YWx1ZTFdKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIGNvdW50IHRoZSBxdWFkIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgaWYgKGtleTIpIGtleTIgaW4gaW5kZXgyICYmIGNvdW50Kys7IC8vIE90aGVyd2lzZSwgY291bnQgYWxsIHF1YWRzXG4gICAgICAgICAgICBlbHNlIGNvdW50ICs9IE9iamVjdC5rZXlzKGluZGV4MikubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfSAvLyAjIyMgYF9nZXRHcmFwaHNgIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgZ2l2ZW4gZ3JhcGgsXG4gIC8vIG9yIGFsbCBncmFwaHMgaWYgdGhlIGFyZ3VtZW50IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuXG5cbiAgX2dldEdyYXBocyhncmFwaCkge1xuICAgIGlmICghaXNTdHJpbmcoZ3JhcGgpKSByZXR1cm4gdGhpcy5fZ3JhcGhzO1xuICAgIHZhciBncmFwaHMgPSB7fTtcbiAgICBncmFwaHNbZ3JhcGhdID0gdGhpcy5fZ3JhcGhzW2dyYXBoXTtcbiAgICByZXR1cm4gZ3JhcGhzO1xuICB9IC8vICMjIyBgX3VuaXF1ZUVudGl0aWVzYCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFuIGVudGl0eSBJRFxuICAvLyBhbmQgcGFzc2VzIHRoZSBjb3JyZXNwb25kaW5nIGVudGl0eSB0byBjYWxsYmFjayBpZiBpdCBoYXNuJ3Qgb2NjdXJyZWQgYmVmb3JlLlxuXG5cbiAgX3VuaXF1ZUVudGl0aWVzKGNhbGxiYWNrKSB7XG4gICAgdmFyIHVuaXF1ZUlkcyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGVudGl0aWVzID0gdGhpcy5fZW50aXRpZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKCEoaWQgaW4gdW5pcXVlSWRzKSkge1xuICAgICAgICB1bmlxdWVJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Gcm9tSWQpKGVudGl0aWVzW2lkXSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0gLy8gIyMgUHVibGljIG1ldGhvZHNcbiAgLy8gIyMjIGBhZGRRdWFkYCBhZGRzIGEgbmV3IHF1YWQgdG8gdGhlIHN0b3JlLlxuICAvLyBSZXR1cm5zIGlmIHRoZSBxdWFkIGluZGV4IGhhcyBjaGFuZ2VkLCBpZiB0aGUgcXVhZCBkaWQgbm90IGFscmVhZHkgZXhpc3QuXG5cblxuICBhZGRRdWFkKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBhIHF1YWQgb2JqZWN0IGlzIGdpdmVuIGluc3RlYWQgb2YgY29tcG9uZW50c1xuICAgIGlmICghcHJlZGljYXRlKSBncmFwaCA9IHN1YmplY3QuZ3JhcGgsIG9iamVjdCA9IHN1YmplY3Qub2JqZWN0LCBwcmVkaWNhdGUgPSBzdWJqZWN0LnByZWRpY2F0ZSwgc3ViamVjdCA9IHN1YmplY3Quc3ViamVjdDsgLy8gQ29udmVydCB0ZXJtcyB0byBpbnRlcm5hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cblxuICAgIHN1YmplY3QgPSAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKHN1YmplY3QpO1xuICAgIHByZWRpY2F0ZSA9ICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkocHJlZGljYXRlKTtcbiAgICBvYmplY3QgPSAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKG9iamVjdCk7XG4gICAgZ3JhcGggPSAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKGdyYXBoKTsgLy8gRmluZCB0aGUgZ3JhcGggdGhhdCB3aWxsIGNvbnRhaW4gdGhlIHRyaXBsZVxuXG4gICAgdmFyIGdyYXBoSXRlbSA9IHRoaXMuX2dyYXBoc1tncmFwaF07IC8vIENyZWF0ZSB0aGUgZ3JhcGggaWYgaXQgZG9lc24ndCBleGlzdCB5ZXRcblxuICAgIGlmICghZ3JhcGhJdGVtKSB7XG4gICAgICBncmFwaEl0ZW0gPSB0aGlzLl9ncmFwaHNbZ3JhcGhdID0ge1xuICAgICAgICBzdWJqZWN0czoge30sXG4gICAgICAgIHByZWRpY2F0ZXM6IHt9LFxuICAgICAgICBvYmplY3RzOiB7fVxuICAgICAgfTsgLy8gRnJlZXppbmcgYSBncmFwaCBoZWxwcyBzdWJzZXF1ZW50IGBhZGRgIHBlcmZvcm1hbmNlLFxuICAgICAgLy8gYW5kIHByb3BlcnRpZXMgd2lsbCBuZXZlciBiZSBtb2RpZmllZCBhbnl3YXlcblxuICAgICAgT2JqZWN0LmZyZWV6ZShncmFwaEl0ZW0pO1xuICAgIH0gLy8gU2luY2UgZW50aXRpZXMgY2FuIG9mdGVuIGJlIGxvbmcgSVJJcywgd2UgYXZvaWQgc3RvcmluZyB0aGVtIGluIGV2ZXJ5IGluZGV4LlxuICAgIC8vIEluc3RlYWQsIHdlIGhhdmUgYSBzZXBhcmF0ZSBpbmRleCB0aGF0IG1hcHMgZW50aXRpZXMgdG8gbnVtYmVycyxcbiAgICAvLyB3aGljaCBhcmUgdGhlbiB1c2VkIGFzIGtleXMgaW4gdGhlIG90aGVyIGluZGV4ZXMuXG5cblxuICAgIHZhciBpZHMgPSB0aGlzLl9pZHM7XG4gICAgdmFyIGVudGl0aWVzID0gdGhpcy5fZW50aXRpZXM7XG4gICAgc3ViamVjdCA9IGlkc1tzdWJqZWN0XSB8fCAoaWRzW2VudGl0aWVzWysrdGhpcy5faWRdID0gc3ViamVjdF0gPSB0aGlzLl9pZCk7XG4gICAgcHJlZGljYXRlID0gaWRzW3ByZWRpY2F0ZV0gfHwgKGlkc1tlbnRpdGllc1srK3RoaXMuX2lkXSA9IHByZWRpY2F0ZV0gPSB0aGlzLl9pZCk7XG4gICAgb2JqZWN0ID0gaWRzW29iamVjdF0gfHwgKGlkc1tlbnRpdGllc1srK3RoaXMuX2lkXSA9IG9iamVjdF0gPSB0aGlzLl9pZCk7XG5cbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX2FkZFRvSW5kZXgoZ3JhcGhJdGVtLnN1YmplY3RzLCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCk7XG5cbiAgICB0aGlzLl9hZGRUb0luZGV4KGdyYXBoSXRlbS5wcmVkaWNhdGVzLCBwcmVkaWNhdGUsIG9iamVjdCwgc3ViamVjdCk7XG5cbiAgICB0aGlzLl9hZGRUb0luZGV4KGdyYXBoSXRlbS5vYmplY3RzLCBvYmplY3QsIHN1YmplY3QsIHByZWRpY2F0ZSk7IC8vIFRoZSBjYWNoZWQgcXVhZCBjb3VudCBpcyBub3cgaW52YWxpZFxuXG5cbiAgICB0aGlzLl9zaXplID0gbnVsbDtcbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfSAvLyAjIyMgYGFkZFF1YWRzYCBhZGRzIG11bHRpcGxlIHF1YWRzIHRvIHRoZSBzdG9yZVxuXG5cbiAgYWRkUXVhZHMocXVhZHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1YWRzLmxlbmd0aDsgaSsrKSB0aGlzLmFkZFF1YWQocXVhZHNbaV0pO1xuICB9IC8vICMjIyBgaW1wb3J0YCBhZGRzIGEgc3RyZWFtIG9mIHF1YWRzIHRvIHRoZSBzdG9yZVxuXG5cbiAgaW1wb3J0KHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAocXVhZCkge1xuICAgICAgc2VsZi5hZGRRdWFkKHF1YWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH0gLy8gIyMjIGByZW1vdmVRdWFkYCByZW1vdmVzIGEgcXVhZCBmcm9tIHRoZSBzdG9yZSBpZiBpdCBleGlzdHNcblxuXG4gIHJlbW92ZVF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgLy8gU2hpZnQgYXJndW1lbnRzIGlmIGEgcXVhZCBvYmplY3QgaXMgZ2l2ZW4gaW5zdGVhZCBvZiBjb21wb25lbnRzXG4gICAgaWYgKCFwcmVkaWNhdGUpIGdyYXBoID0gc3ViamVjdC5ncmFwaCwgb2JqZWN0ID0gc3ViamVjdC5vYmplY3QsIHByZWRpY2F0ZSA9IHN1YmplY3QucHJlZGljYXRlLCBzdWJqZWN0ID0gc3ViamVjdC5zdWJqZWN0OyAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuXG4gICAgc3ViamVjdCA9ICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoc3ViamVjdCk7XG4gICAgcHJlZGljYXRlID0gKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShwcmVkaWNhdGUpO1xuICAgIG9iamVjdCA9ICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkob2JqZWN0KTtcbiAgICBncmFwaCA9ICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoZ3JhcGgpOyAvLyBGaW5kIGludGVybmFsIGlkZW50aWZpZXJzIGZvciBhbGwgY29tcG9uZW50c1xuICAgIC8vIGFuZCB2ZXJpZnkgdGhlIHF1YWQgZXhpc3RzLlxuXG4gICAgdmFyIGdyYXBoSXRlbSxcbiAgICAgICAgaWRzID0gdGhpcy5faWRzLFxuICAgICAgICBncmFwaHMgPSB0aGlzLl9ncmFwaHMsXG4gICAgICAgIHN1YmplY3RzLFxuICAgICAgICBwcmVkaWNhdGVzO1xuICAgIGlmICghKHN1YmplY3QgPSBpZHNbc3ViamVjdF0pIHx8ICEocHJlZGljYXRlID0gaWRzW3ByZWRpY2F0ZV0pIHx8ICEob2JqZWN0ID0gaWRzW29iamVjdF0pIHx8ICEoZ3JhcGhJdGVtID0gZ3JhcGhzW2dyYXBoXSkgfHwgIShzdWJqZWN0cyA9IGdyYXBoSXRlbS5zdWJqZWN0c1tzdWJqZWN0XSkgfHwgIShwcmVkaWNhdGVzID0gc3ViamVjdHNbcHJlZGljYXRlXSkgfHwgIShvYmplY3QgaW4gcHJlZGljYXRlcykpIHJldHVybiBmYWxzZTsgLy8gUmVtb3ZlIGl0IGZyb20gYWxsIGluZGV4ZXNcblxuICAgIHRoaXMuX3JlbW92ZUZyb21JbmRleChncmFwaEl0ZW0uc3ViamVjdHMsIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KTtcblxuICAgIHRoaXMuX3JlbW92ZUZyb21JbmRleChncmFwaEl0ZW0ucHJlZGljYXRlcywgcHJlZGljYXRlLCBvYmplY3QsIHN1YmplY3QpO1xuXG4gICAgdGhpcy5fcmVtb3ZlRnJvbUluZGV4KGdyYXBoSXRlbS5vYmplY3RzLCBvYmplY3QsIHN1YmplY3QsIHByZWRpY2F0ZSk7XG5cbiAgICBpZiAodGhpcy5fc2l6ZSAhPT0gbnVsbCkgdGhpcy5fc2l6ZS0tOyAvLyBSZW1vdmUgdGhlIGdyYXBoIGlmIGl0IGlzIGVtcHR5XG5cbiAgICBmb3IgKHN1YmplY3QgaW4gZ3JhcGhJdGVtLnN1YmplY3RzKSByZXR1cm4gdHJ1ZTtcblxuICAgIGRlbGV0ZSBncmFwaHNbZ3JhcGhdO1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vICMjIyBgcmVtb3ZlUXVhZHNgIHJlbW92ZXMgbXVsdGlwbGUgcXVhZHMgZnJvbSB0aGUgc3RvcmVcblxuXG4gIHJlbW92ZVF1YWRzKHF1YWRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFkcy5sZW5ndGg7IGkrKykgdGhpcy5yZW1vdmVRdWFkKHF1YWRzW2ldKTtcbiAgfSAvLyAjIyMgYHJlbW92ZWAgcmVtb3ZlcyBhIHN0cmVhbSBvZiBxdWFkcyBmcm9tIHRoZSBzdG9yZVxuXG5cbiAgcmVtb3ZlKHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAocXVhZCkge1xuICAgICAgc2VsZi5yZW1vdmVRdWFkKHF1YWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH0gLy8gIyMjIGByZW1vdmVNYXRjaGVzYCByZW1vdmVzIGFsbCBtYXRjaGluZyBxdWFkcyBmcm9tIHRoZSBzdG9yZVxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICByZW1vdmVNYXRjaGVzKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZSh0aGlzLm1hdGNoKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkpO1xuICB9IC8vICMjIyBgZGVsZXRlR3JhcGhgIHJlbW92ZXMgYWxsIHRyaXBsZXMgd2l0aCB0aGUgZ2l2ZW4gZ3JhcGggZnJvbSB0aGUgc3RvcmVcblxuXG4gIGRlbGV0ZUdyYXBoKGdyYXBoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hlcyhudWxsLCBudWxsLCBudWxsLCBncmFwaCk7XG4gIH0gLy8gIyMjIGBnZXRRdWFkc2AgcmV0dXJucyBhbiBhcnJheSBvZiBxdWFkcyBtYXRjaGluZyBhIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGdldFF1YWRzKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIC8vIENvbnZlcnQgdGVybXMgdG8gaW50ZXJuYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgc3ViamVjdCA9IHN1YmplY3QgJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShzdWJqZWN0KTtcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUgJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShwcmVkaWNhdGUpO1xuICAgIG9iamVjdCA9IG9iamVjdCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKG9iamVjdCk7XG4gICAgZ3JhcGggPSBncmFwaCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKGdyYXBoKTtcblxuICAgIHZhciBxdWFkcyA9IFtdLFxuICAgICAgICBncmFwaHMgPSB0aGlzLl9nZXRHcmFwaHMoZ3JhcGgpLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBpZHMgPSB0aGlzLl9pZHMsXG4gICAgICAgIHN1YmplY3RJZCxcbiAgICAgICAgcHJlZGljYXRlSWQsXG4gICAgICAgIG9iamVjdElkOyAvLyBUcmFuc2xhdGUgSVJJcyB0byBpbnRlcm5hbCBpbmRleCBrZXlzLlxuXG5cbiAgICBpZiAoaXNTdHJpbmcoc3ViamVjdCkgJiYgIShzdWJqZWN0SWQgPSBpZHNbc3ViamVjdF0pIHx8IGlzU3RyaW5nKHByZWRpY2F0ZSkgJiYgIShwcmVkaWNhdGVJZCA9IGlkc1twcmVkaWNhdGVdKSB8fCBpc1N0cmluZyhvYmplY3QpICYmICEob2JqZWN0SWQgPSBpZHNbb2JqZWN0XSkpIHJldHVybiBxdWFkcztcblxuICAgIGZvciAodmFyIGdyYXBoSWQgaW4gZ3JhcGhzKSB7XG4gICAgICAvLyBPbmx5IGlmIHRoZSBzcGVjaWZpZWQgZ3JhcGggY29udGFpbnMgdHJpcGxlcywgdGhlcmUgY2FuIGJlIHJlc3VsdHNcbiAgICAgIGlmIChjb250ZW50ID0gZ3JhcGhzW2dyYXBoSWRdKSB7XG4gICAgICAgIC8vIENob29zZSB0aGUgb3B0aW1hbCBpbmRleCwgYmFzZWQgb24gd2hhdCBmaWVsZHMgYXJlIHByZXNlbnRcbiAgICAgICAgaWYgKHN1YmplY3RJZCkge1xuICAgICAgICAgIGlmIChvYmplY3RJZCkgLy8gSWYgc3ViamVjdCBhbmQgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIG9iamVjdCBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgICB0aGlzLl9maW5kSW5JbmRleChjb250ZW50Lm9iamVjdHMsIG9iamVjdElkLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkLCAnb2JqZWN0JywgJ3N1YmplY3QnLCAncHJlZGljYXRlJywgZ3JhcGhJZCwgbnVsbCwgcXVhZHMpO2Vsc2UgLy8gSWYgb25seSBzdWJqZWN0IGFuZCBwb3NzaWJseSBwcmVkaWNhdGUgYXJlIGdpdmVuLCB0aGUgc3ViamVjdCBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgICB0aGlzLl9maW5kSW5JbmRleChjb250ZW50LnN1YmplY3RzLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkLCBudWxsLCAnc3ViamVjdCcsICdwcmVkaWNhdGUnLCAnb2JqZWN0JywgZ3JhcGhJZCwgbnVsbCwgcXVhZHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWRpY2F0ZUlkKSAvLyBJZiBvbmx5IHByZWRpY2F0ZSBhbmQgcG9zc2libHkgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIHByZWRpY2F0ZSBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgdGhpcy5fZmluZEluSW5kZXgoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQsIG51bGwsICdwcmVkaWNhdGUnLCAnb2JqZWN0JywgJ3N1YmplY3QnLCBncmFwaElkLCBudWxsLCBxdWFkcyk7ZWxzZSBpZiAob2JqZWN0SWQpIC8vIElmIG9ubHkgb2JqZWN0IGlzIGdpdmVuLCB0aGUgb2JqZWN0IGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICB0aGlzLl9maW5kSW5JbmRleChjb250ZW50Lm9iamVjdHMsIG9iamVjdElkLCBudWxsLCBudWxsLCAnb2JqZWN0JywgJ3N1YmplY3QnLCAncHJlZGljYXRlJywgZ3JhcGhJZCwgbnVsbCwgcXVhZHMpO2Vsc2UgLy8gSWYgbm90aGluZyBpcyBnaXZlbiwgaXRlcmF0ZSBzdWJqZWN0cyBhbmQgcHJlZGljYXRlcyBmaXJzdFxuICAgICAgICAgIHRoaXMuX2ZpbmRJbkluZGV4KGNvbnRlbnQuc3ViamVjdHMsIG51bGwsIG51bGwsIG51bGwsICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCBncmFwaElkLCBudWxsLCBxdWFkcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1YWRzO1xuICB9IC8vICMjIyBgbWF0Y2hgIHJldHVybnMgYSBzdHJlYW0gb2YgcXVhZHMgbWF0Y2hpbmcgYSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBtYXRjaChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICB2YXIgc3RyZWFtID0gbmV3IF9yZWFkYWJsZVN0cmVhbS5SZWFkYWJsZSh7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgfSk7IC8vIEluaXRpYWxpemUgc3RyZWFtIG9uY2UgaXQgaXMgYmVpbmcgcmVhZFxuXG4gICAgc3RyZWFtLl9yZWFkID0gKCkgPT4ge1xuICAgICAgZm9yICh2YXIgcXVhZCBvZiB0aGlzLmdldFF1YWRzKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkpIHN0cmVhbS5wdXNoKHF1YWQpO1xuXG4gICAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfSAvLyAjIyMgYGNvdW50UXVhZHNgIHJldHVybnMgdGhlIG51bWJlciBvZiBxdWFkcyBtYXRjaGluZyBhIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGNvdW50UXVhZHMoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgLy8gQ29udmVydCB0ZXJtcyB0byBpbnRlcm5hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICBzdWJqZWN0ID0gc3ViamVjdCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKHN1YmplY3QpO1xuICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZSAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKHByZWRpY2F0ZSk7XG4gICAgb2JqZWN0ID0gb2JqZWN0ICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkob2JqZWN0KTtcbiAgICBncmFwaCA9IGdyYXBoICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoZ3JhcGgpO1xuXG4gICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgZ3JhcGhzID0gdGhpcy5fZ2V0R3JhcGhzKGdyYXBoKSxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgaWRzID0gdGhpcy5faWRzLFxuICAgICAgICBzdWJqZWN0SWQsXG4gICAgICAgIHByZWRpY2F0ZUlkLFxuICAgICAgICBvYmplY3RJZDsgLy8gVHJhbnNsYXRlIElSSXMgdG8gaW50ZXJuYWwgaW5kZXgga2V5cy5cblxuXG4gICAgaWYgKGlzU3RyaW5nKHN1YmplY3QpICYmICEoc3ViamVjdElkID0gaWRzW3N1YmplY3RdKSB8fCBpc1N0cmluZyhwcmVkaWNhdGUpICYmICEocHJlZGljYXRlSWQgPSBpZHNbcHJlZGljYXRlXSkgfHwgaXNTdHJpbmcob2JqZWN0KSAmJiAhKG9iamVjdElkID0gaWRzW29iamVjdF0pKSByZXR1cm4gMDtcblxuICAgIGZvciAodmFyIGdyYXBoSWQgaW4gZ3JhcGhzKSB7XG4gICAgICAvLyBPbmx5IGlmIHRoZSBzcGVjaWZpZWQgZ3JhcGggY29udGFpbnMgdHJpcGxlcywgdGhlcmUgY2FuIGJlIHJlc3VsdHNcbiAgICAgIGlmIChjb250ZW50ID0gZ3JhcGhzW2dyYXBoSWRdKSB7XG4gICAgICAgIC8vIENob29zZSB0aGUgb3B0aW1hbCBpbmRleCwgYmFzZWQgb24gd2hhdCBmaWVsZHMgYXJlIHByZXNlbnRcbiAgICAgICAgaWYgKHN1YmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0KSAvLyBJZiBzdWJqZWN0IGFuZCBvYmplY3QgYXJlIGdpdmVuLCB0aGUgb2JqZWN0IGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICAgIGNvdW50ICs9IHRoaXMuX2NvdW50SW5JbmRleChjb250ZW50Lm9iamVjdHMsIG9iamVjdElkLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkKTtlbHNlIC8vIElmIG9ubHkgc3ViamVjdCBhbmQgcG9zc2libHkgcHJlZGljYXRlIGFyZSBnaXZlbiwgdGhlIHN1YmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgICAgY291bnQgKz0gdGhpcy5fY291bnRJbkluZGV4KGNvbnRlbnQuc3ViamVjdHMsIHN1YmplY3RJZCwgcHJlZGljYXRlSWQsIG9iamVjdElkKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVkaWNhdGUpIHtcbiAgICAgICAgICAvLyBJZiBvbmx5IHByZWRpY2F0ZSBhbmQgcG9zc2libHkgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIHByZWRpY2F0ZSBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgY291bnQgKz0gdGhpcy5fY291bnRJbkluZGV4KGNvbnRlbnQucHJlZGljYXRlcywgcHJlZGljYXRlSWQsIG9iamVjdElkLCBzdWJqZWN0SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG9ubHkgb2JqZWN0IGlzIHBvc3NpYmx5IGdpdmVuLCB0aGUgb2JqZWN0IGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICBjb3VudCArPSB0aGlzLl9jb3VudEluSW5kZXgoY29udGVudC5vYmplY3RzLCBvYmplY3RJZCwgc3ViamVjdElkLCBwcmVkaWNhdGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH0gLy8gIyMjIGBmb3JFYWNoYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gYWxsIHF1YWRzLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBmb3JFYWNoKGNhbGxiYWNrLCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICB0aGlzLnNvbWUoZnVuY3Rpb24gKHF1YWQpIHtcbiAgICAgIGNhbGxiYWNrKHF1YWQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCk7XG4gIH0gLy8gIyMjIGBldmVyeWAgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBxdWFkcyxcbiAgLy8gYW5kIHJldHVybnMgYHRydWVgIGlmIGl0IHJldHVybnMgdHJ1dGh5IGZvciBhbGwgdGhlbS5cbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuXG5cbiAgZXZlcnkoY2FsbGJhY2ssIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHZhciBzb21lID0gZmFsc2U7XG4gICAgdmFyIGV2ZXJ5ID0gIXRoaXMuc29tZShmdW5jdGlvbiAocXVhZCkge1xuICAgICAgc29tZSA9IHRydWU7XG4gICAgICByZXR1cm4gIWNhbGxiYWNrKHF1YWQpO1xuICAgIH0sIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCk7XG4gICAgcmV0dXJuIHNvbWUgJiYgZXZlcnk7XG4gIH0gLy8gIyMjIGBzb21lYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gYWxsIHF1YWRzLFxuICAvLyBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgaXQgcmV0dXJucyB0cnV0aHkgZm9yIGFueSBvZiB0aGVtLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBzb21lKGNhbGxiYWNrLCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIHN1YmplY3QgPSBzdWJqZWN0ICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoc3ViamVjdCk7XG4gICAgcHJlZGljYXRlID0gcHJlZGljYXRlICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkocHJlZGljYXRlKTtcbiAgICBvYmplY3QgPSBvYmplY3QgJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShvYmplY3QpO1xuICAgIGdyYXBoID0gZ3JhcGggJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShncmFwaCk7XG5cbiAgICB2YXIgZ3JhcGhzID0gdGhpcy5fZ2V0R3JhcGhzKGdyYXBoKSxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgaWRzID0gdGhpcy5faWRzLFxuICAgICAgICBzdWJqZWN0SWQsXG4gICAgICAgIHByZWRpY2F0ZUlkLFxuICAgICAgICBvYmplY3RJZDsgLy8gVHJhbnNsYXRlIElSSXMgdG8gaW50ZXJuYWwgaW5kZXgga2V5cy5cblxuXG4gICAgaWYgKGlzU3RyaW5nKHN1YmplY3QpICYmICEoc3ViamVjdElkID0gaWRzW3N1YmplY3RdKSB8fCBpc1N0cmluZyhwcmVkaWNhdGUpICYmICEocHJlZGljYXRlSWQgPSBpZHNbcHJlZGljYXRlXSkgfHwgaXNTdHJpbmcob2JqZWN0KSAmJiAhKG9iamVjdElkID0gaWRzW29iamVjdF0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBncmFwaElkIGluIGdyYXBocykge1xuICAgICAgLy8gT25seSBpZiB0aGUgc3BlY2lmaWVkIGdyYXBoIGNvbnRhaW5zIHRyaXBsZXMsIHRoZXJlIGNhbiBiZSByZXN1bHRzXG4gICAgICBpZiAoY29udGVudCA9IGdyYXBoc1tncmFwaElkXSkge1xuICAgICAgICAvLyBDaG9vc2UgdGhlIG9wdGltYWwgaW5kZXgsIGJhc2VkIG9uIHdoYXQgZmllbGRzIGFyZSBwcmVzZW50XG4gICAgICAgIGlmIChzdWJqZWN0SWQpIHtcbiAgICAgICAgICBpZiAob2JqZWN0SWQpIHtcbiAgICAgICAgICAgIC8vIElmIHN1YmplY3QgYW5kIG9iamVjdCBhcmUgZ2l2ZW4sIHRoZSBvYmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbmRJbkluZGV4KGNvbnRlbnQub2JqZWN0cywgb2JqZWN0SWQsIHN1YmplY3RJZCwgcHJlZGljYXRlSWQsICdvYmplY3QnLCAnc3ViamVjdCcsICdwcmVkaWNhdGUnLCBncmFwaElkLCBjYWxsYmFjaywgbnVsbCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSAvLyBJZiBvbmx5IHN1YmplY3QgYW5kIHBvc3NpYmx5IHByZWRpY2F0ZSBhcmUgZ2l2ZW4sIHRoZSBzdWJqZWN0IGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICAgIGlmICh0aGlzLl9maW5kSW5JbmRleChjb250ZW50LnN1YmplY3RzLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkLCBudWxsLCAnc3ViamVjdCcsICdwcmVkaWNhdGUnLCAnb2JqZWN0JywgZ3JhcGhJZCwgY2FsbGJhY2ssIG51bGwpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVkaWNhdGVJZCkge1xuICAgICAgICAgIC8vIElmIG9ubHkgcHJlZGljYXRlIGFuZCBwb3NzaWJseSBvYmplY3QgYXJlIGdpdmVuLCB0aGUgcHJlZGljYXRlIGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICBpZiAodGhpcy5fZmluZEluSW5kZXgoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQsIG51bGwsICdwcmVkaWNhdGUnLCAnb2JqZWN0JywgJ3N1YmplY3QnLCBncmFwaElkLCBjYWxsYmFjaywgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3RJZCkge1xuICAgICAgICAgIC8vIElmIG9ubHkgb2JqZWN0IGlzIGdpdmVuLCB0aGUgb2JqZWN0IGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICBpZiAodGhpcy5fZmluZEluSW5kZXgoY29udGVudC5vYmplY3RzLCBvYmplY3RJZCwgbnVsbCwgbnVsbCwgJ29iamVjdCcsICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsIGdyYXBoSWQsIGNhbGxiYWNrLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgLy8gSWYgbm90aGluZyBpcyBnaXZlbiwgaXRlcmF0ZSBzdWJqZWN0cyBhbmQgcHJlZGljYXRlcyBmaXJzdFxuICAgICAgICAgIGlmICh0aGlzLl9maW5kSW5JbmRleChjb250ZW50LnN1YmplY3RzLCBudWxsLCBudWxsLCBudWxsLCAnc3ViamVjdCcsICdwcmVkaWNhdGUnLCAnb2JqZWN0JywgZ3JhcGhJZCwgY2FsbGJhY2ssIG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vICMjIyBgZ2V0U3ViamVjdHNgIHJldHVybnMgYWxsIHN1YmplY3RzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGdldFN1YmplY3RzKHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdGhpcy5mb3JTdWJqZWN0cyhmdW5jdGlvbiAocykge1xuICAgICAgcmVzdWx0cy5wdXNoKHMpO1xuICAgIH0sIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gLy8gIyMjIGBmb3JTdWJqZWN0c2AgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBzdWJqZWN0cyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBmb3JTdWJqZWN0cyhjYWxsYmFjaywgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgLy8gQ29udmVydCB0ZXJtcyB0byBpbnRlcm5hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUgJiYgKDAsIF9OM0RhdGFGYWN0b3J5LnRlcm1Ub0lkKShwcmVkaWNhdGUpO1xuICAgIG9iamVjdCA9IG9iamVjdCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKG9iamVjdCk7XG4gICAgZ3JhcGggPSBncmFwaCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKGdyYXBoKTtcblxuICAgIHZhciBpZHMgPSB0aGlzLl9pZHMsXG4gICAgICAgIGdyYXBocyA9IHRoaXMuX2dldEdyYXBocyhncmFwaCksXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIHByZWRpY2F0ZUlkLFxuICAgICAgICBvYmplY3RJZDtcblxuICAgIGNhbGxiYWNrID0gdGhpcy5fdW5pcXVlRW50aXRpZXMoY2FsbGJhY2spOyAvLyBUcmFuc2xhdGUgSVJJcyB0byBpbnRlcm5hbCBpbmRleCBrZXlzLlxuXG4gICAgaWYgKGlzU3RyaW5nKHByZWRpY2F0ZSkgJiYgIShwcmVkaWNhdGVJZCA9IGlkc1twcmVkaWNhdGVdKSB8fCBpc1N0cmluZyhvYmplY3QpICYmICEob2JqZWN0SWQgPSBpZHNbb2JqZWN0XSkpIHJldHVybjtcblxuICAgIGZvciAoZ3JhcGggaW4gZ3JhcGhzKSB7XG4gICAgICAvLyBPbmx5IGlmIHRoZSBzcGVjaWZpZWQgZ3JhcGggY29udGFpbnMgdHJpcGxlcywgdGhlcmUgY2FuIGJlIHJlc3VsdHNcbiAgICAgIGlmIChjb250ZW50ID0gZ3JhcGhzW2dyYXBoXSkge1xuICAgICAgICAvLyBDaG9vc2Ugb3B0aW1hbCBpbmRleCBiYXNlZCBvbiB3aGljaCBmaWVsZHMgYXJlIHdpbGRjYXJkc1xuICAgICAgICBpZiAocHJlZGljYXRlSWQpIHtcbiAgICAgICAgICBpZiAob2JqZWN0SWQpIC8vIElmIHByZWRpY2F0ZSBhbmQgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIFBPUyBpbmRleCBpcyBiZXN0LlxuICAgICAgICAgICAgdGhpcy5fbG9vcEJ5MktleXMoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQsIGNhbGxiYWNrKTtlbHNlIC8vIElmIG9ubHkgcHJlZGljYXRlIGlzIGdpdmVuLCB0aGUgU1BPIGluZGV4IGlzIGJlc3QuXG4gICAgICAgICAgICB0aGlzLl9sb29wQnlLZXkxKGNvbnRlbnQuc3ViamVjdHMsIHByZWRpY2F0ZUlkLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqZWN0SWQpIC8vIElmIG9ubHkgb2JqZWN0IGlzIGdpdmVuLCB0aGUgT1NQIGluZGV4IGlzIGJlc3QuXG4gICAgICAgICAgdGhpcy5fbG9vcEJ5S2V5MChjb250ZW50Lm9iamVjdHMsIG9iamVjdElkLCBjYWxsYmFjayk7ZWxzZSAvLyBJZiBubyBwYXJhbXMgZ2l2ZW4sIGl0ZXJhdGUgYWxsIHRoZSBzdWJqZWN0c1xuICAgICAgICAgIHRoaXMuX2xvb3AoY29udGVudC5zdWJqZWN0cywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyAjIyMgYGdldFByZWRpY2F0ZXNgIHJldHVybnMgYWxsIHByZWRpY2F0ZXMgdGhhdCBtYXRjaCB0aGUgcGF0dGVybi5cbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuXG5cbiAgZ2V0UHJlZGljYXRlcyhzdWJqZWN0LCBvYmplY3QsIGdyYXBoKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB0aGlzLmZvclByZWRpY2F0ZXMoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJlc3VsdHMucHVzaChwKTtcbiAgICB9LCBzdWJqZWN0LCBvYmplY3QsIGdyYXBoKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSAvLyAjIyMgYGZvclByZWRpY2F0ZXNgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBhbGwgcHJlZGljYXRlcyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBmb3JQcmVkaWNhdGVzKGNhbGxiYWNrLCBzdWJqZWN0LCBvYmplY3QsIGdyYXBoKSB7XG4gICAgLy8gQ29udmVydCB0ZXJtcyB0byBpbnRlcm5hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICBzdWJqZWN0ID0gc3ViamVjdCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKHN1YmplY3QpO1xuICAgIG9iamVjdCA9IG9iamVjdCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKG9iamVjdCk7XG4gICAgZ3JhcGggPSBncmFwaCAmJiAoMCwgX04zRGF0YUZhY3RvcnkudGVybVRvSWQpKGdyYXBoKTtcblxuICAgIHZhciBpZHMgPSB0aGlzLl9pZHMsXG4gICAgICAgIGdyYXBocyA9IHRoaXMuX2dldEdyYXBocyhncmFwaCksXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIHN1YmplY3RJZCxcbiAgICAgICAgb2JqZWN0SWQ7XG5cbiAgICBjYWxsYmFjayA9IHRoaXMuX3VuaXF1ZUVudGl0aWVzKGNhbGxiYWNrKTsgLy8gVHJhbnNsYXRlIElSSXMgdG8gaW50ZXJuYWwgaW5kZXgga2V5cy5cblxuICAgIGlmIChpc1N0cmluZyhzdWJqZWN0KSAmJiAhKHN1YmplY3RJZCA9IGlkc1tzdWJqZWN0XSkgfHwgaXNTdHJpbmcob2JqZWN0KSAmJiAhKG9iamVjdElkID0gaWRzW29iamVjdF0pKSByZXR1cm47XG5cbiAgICBmb3IgKGdyYXBoIGluIGdyYXBocykge1xuICAgICAgLy8gT25seSBpZiB0aGUgc3BlY2lmaWVkIGdyYXBoIGNvbnRhaW5zIHRyaXBsZXMsIHRoZXJlIGNhbiBiZSByZXN1bHRzXG4gICAgICBpZiAoY29udGVudCA9IGdyYXBoc1tncmFwaF0pIHtcbiAgICAgICAgLy8gQ2hvb3NlIG9wdGltYWwgaW5kZXggYmFzZWQgb24gd2hpY2ggZmllbGRzIGFyZSB3aWxkY2FyZHNcbiAgICAgICAgaWYgKHN1YmplY3RJZCkge1xuICAgICAgICAgIGlmIChvYmplY3RJZCkgLy8gSWYgc3ViamVjdCBhbmQgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIE9TUCBpbmRleCBpcyBiZXN0LlxuICAgICAgICAgICAgdGhpcy5fbG9vcEJ5MktleXMoY29udGVudC5vYmplY3RzLCBvYmplY3RJZCwgc3ViamVjdElkLCBjYWxsYmFjayk7ZWxzZSAvLyBJZiBvbmx5IHN1YmplY3QgaXMgZ2l2ZW4sIHRoZSBTUE8gaW5kZXggaXMgYmVzdC5cbiAgICAgICAgICAgIHRoaXMuX2xvb3BCeUtleTAoY29udGVudC5zdWJqZWN0cywgc3ViamVjdElkLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqZWN0SWQpIC8vIElmIG9ubHkgb2JqZWN0IGlzIGdpdmVuLCB0aGUgUE9TIGluZGV4IGlzIGJlc3QuXG4gICAgICAgICAgdGhpcy5fbG9vcEJ5S2V5MShjb250ZW50LnByZWRpY2F0ZXMsIG9iamVjdElkLCBjYWxsYmFjayk7ZWxzZSAvLyBJZiBubyBwYXJhbXMgZ2l2ZW4sIGl0ZXJhdGUgYWxsIHRoZSBwcmVkaWNhdGVzLlxuICAgICAgICAgIHRoaXMuX2xvb3AoY29udGVudC5wcmVkaWNhdGVzLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vICMjIyBgZ2V0T2JqZWN0c2AgcmV0dXJucyBhbGwgb2JqZWN0cyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBnZXRPYmplY3RzKHN1YmplY3QsIHByZWRpY2F0ZSwgZ3JhcGgpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHRoaXMuZm9yT2JqZWN0cyhmdW5jdGlvbiAobykge1xuICAgICAgcmVzdWx0cy5wdXNoKG8pO1xuICAgIH0sIHN1YmplY3QsIHByZWRpY2F0ZSwgZ3JhcGgpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9IC8vICMjIyBgZm9yT2JqZWN0c2AgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBvYmplY3RzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cblxuXG4gIGZvck9iamVjdHMoY2FsbGJhY2ssIHN1YmplY3QsIHByZWRpY2F0ZSwgZ3JhcGgpIHtcbiAgICAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIHN1YmplY3QgPSBzdWJqZWN0ICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoc3ViamVjdCk7XG4gICAgcHJlZGljYXRlID0gcHJlZGljYXRlICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkocHJlZGljYXRlKTtcbiAgICBncmFwaCA9IGdyYXBoICYmICgwLCBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZCkoZ3JhcGgpO1xuXG4gICAgdmFyIGlkcyA9IHRoaXMuX2lkcyxcbiAgICAgICAgZ3JhcGhzID0gdGhpcy5fZ2V0R3JhcGhzKGdyYXBoKSxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgc3ViamVjdElkLFxuICAgICAgICBwcmVkaWNhdGVJZDtcblxuICAgIGNhbGxiYWNrID0gdGhpcy5fdW5pcXVlRW50aXRpZXMoY2FsbGJhY2spOyAvLyBUcmFuc2xhdGUgSVJJcyB0byBpbnRlcm5hbCBpbmRleCBrZXlzLlxuXG4gICAgaWYgKGlzU3RyaW5nKHN1YmplY3QpICYmICEoc3ViamVjdElkID0gaWRzW3N1YmplY3RdKSB8fCBpc1N0cmluZyhwcmVkaWNhdGUpICYmICEocHJlZGljYXRlSWQgPSBpZHNbcHJlZGljYXRlXSkpIHJldHVybjtcblxuICAgIGZvciAoZ3JhcGggaW4gZ3JhcGhzKSB7XG4gICAgICAvLyBPbmx5IGlmIHRoZSBzcGVjaWZpZWQgZ3JhcGggY29udGFpbnMgdHJpcGxlcywgdGhlcmUgY2FuIGJlIHJlc3VsdHNcbiAgICAgIGlmIChjb250ZW50ID0gZ3JhcGhzW2dyYXBoXSkge1xuICAgICAgICAvLyBDaG9vc2Ugb3B0aW1hbCBpbmRleCBiYXNlZCBvbiB3aGljaCBmaWVsZHMgYXJlIHdpbGRjYXJkc1xuICAgICAgICBpZiAoc3ViamVjdElkKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZUlkKSAvLyBJZiBzdWJqZWN0IGFuZCBwcmVkaWNhdGUgYXJlIGdpdmVuLCB0aGUgU1BPIGluZGV4IGlzIGJlc3QuXG4gICAgICAgICAgICB0aGlzLl9sb29wQnkyS2V5cyhjb250ZW50LnN1YmplY3RzLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkLCBjYWxsYmFjayk7ZWxzZSAvLyBJZiBvbmx5IHN1YmplY3QgaXMgZ2l2ZW4sIHRoZSBPU1AgaW5kZXggaXMgYmVzdC5cbiAgICAgICAgICAgIHRoaXMuX2xvb3BCeUtleTEoY29udGVudC5vYmplY3RzLCBzdWJqZWN0SWQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVkaWNhdGVJZCkgLy8gSWYgb25seSBwcmVkaWNhdGUgaXMgZ2l2ZW4sIHRoZSBQT1MgaW5kZXggaXMgYmVzdC5cbiAgICAgICAgICB0aGlzLl9sb29wQnlLZXkwKGNvbnRlbnQucHJlZGljYXRlcywgcHJlZGljYXRlSWQsIGNhbGxiYWNrKTtlbHNlIC8vIElmIG5vIHBhcmFtcyBnaXZlbiwgaXRlcmF0ZSBhbGwgdGhlIG9iamVjdHMuXG4gICAgICAgICAgdGhpcy5fbG9vcChjb250ZW50Lm9iamVjdHMsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gIyMjIGBnZXRHcmFwaHNgIHJldHVybnMgYWxsIGdyYXBocyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBnZXRHcmFwaHMoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHRoaXMuZm9yR3JhcGhzKGZ1bmN0aW9uIChnKSB7XG4gICAgICByZXN1bHRzLnB1c2goZyk7XG4gICAgfSwgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9IC8vICMjIyBgZm9yR3JhcGhzYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gYWxsIGdyYXBocyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG5cblxuICBmb3JHcmFwaHMoY2FsbGJhY2ssIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KSB7XG4gICAgZm9yICh2YXIgZ3JhcGggaW4gdGhpcy5fZ3JhcGhzKSB7XG4gICAgICB0aGlzLnNvbWUoZnVuY3Rpb24gKHF1YWQpIHtcbiAgICAgICAgY2FsbGJhY2socXVhZC5ncmFwaCk7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBIYWx0IGl0ZXJhdGlvbiBvZiBzb21lKClcbiAgICAgIH0sIHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCk7XG4gICAgfVxuICB9IC8vICMjIyBgY3JlYXRlQmxhbmtOb2RlYCBjcmVhdGVzIGEgbmV3IGJsYW5rIG5vZGUsIHJldHVybmluZyBpdHMgbmFtZVxuXG5cbiAgY3JlYXRlQmxhbmtOb2RlKHN1Z2dlc3RlZE5hbWUpIHtcbiAgICB2YXIgbmFtZSwgaW5kZXg7IC8vIEdlbmVyYXRlIGEgbmFtZSBiYXNlZCBvbiB0aGUgc3VnZ2VzdGVkIG5hbWVcblxuICAgIGlmIChzdWdnZXN0ZWROYW1lKSB7XG4gICAgICBuYW1lID0gc3VnZ2VzdGVkTmFtZSA9ICdfOicgKyBzdWdnZXN0ZWROYW1lLCBpbmRleCA9IDE7XG5cbiAgICAgIHdoaWxlICh0aGlzLl9pZHNbbmFtZV0pIG5hbWUgPSBzdWdnZXN0ZWROYW1lICsgaW5kZXgrKztcbiAgICB9IC8vIEdlbmVyYXRlIGEgZ2VuZXJpYyBibGFuayBub2RlIG5hbWVcbiAgICBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5hbWUgPSAnXzpiJyArIHRoaXMuX2JsYW5rTm9kZUluZGV4Kys7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuX2lkc1tuYW1lXSk7XG4gICAgICB9IC8vIEFkZCB0aGUgYmxhbmsgbm9kZSB0byB0aGUgZW50aXRpZXMsIGF2b2lkaW5nIHRoZSBnZW5lcmF0aW9uIG9mIGR1cGxpY2F0ZXNcblxuXG4gICAgdGhpcy5faWRzW25hbWVdID0gKyt0aGlzLl9pZDtcbiAgICB0aGlzLl9lbnRpdGllc1t0aGlzLl9pZF0gPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLl9mYWN0b3J5LmJsYW5rTm9kZShuYW1lLnN1YnN0cigyKSk7XG4gIH0gLy8gIyMjIGBleHRyYWN0TGlzdHNgIGZpbmRzIGFuZCByZW1vdmVzIGFsbCBsaXN0IHRyaXBsZXNcbiAgLy8gYW5kIHJldHVybnMgdGhlIGl0ZW1zIHBlciBsaXN0LlxuXG5cbiAgZXh0cmFjdExpc3RzKHtcbiAgICByZW1vdmUgPSBmYWxzZSxcbiAgICBpZ25vcmVFcnJvcnMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB2YXIgbGlzdHMgPSB7fTsgLy8gaGFzIHNjYWxhciBrZXlzIHNvIGNvdWxkIGJlIGEgc2ltcGxlIE9iamVjdFxuXG4gICAgdmFyIG9uRXJyb3IgPSBpZ25vcmVFcnJvcnMgPyAoKSA9PiB0cnVlIDogKG5vZGUsIG1lc3NhZ2UpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtub2RlLnZhbHVlfSAke21lc3NhZ2V9YCk7XG4gICAgfTsgLy8gVHJhdmVyc2UgZWFjaCBsaXN0IGZyb20gaXRzIHRhaWxcblxuICAgIHZhciB0YWlscyA9IHRoaXMuZ2V0UXVhZHMobnVsbCwgX0lSSXMuZGVmYXVsdC5yZGYucmVzdCwgX0lSSXMuZGVmYXVsdC5yZGYubmlsLCBudWxsKTtcbiAgICB2YXIgdG9SZW1vdmUgPSByZW1vdmUgPyBbLi4udGFpbHNdIDogW107XG4gICAgdGFpbHMuZm9yRWFjaCh0YWlsUXVhZCA9PiB7XG4gICAgICB2YXIgaXRlbXMgPSBbXTsgLy8gdGhlIG1lbWJlcnMgZm91bmQgYXMgb2JqZWN0cyBvZiByZGY6Zmlyc3QgcXVhZHNcblxuICAgICAgdmFyIG1hbGZvcm1lZCA9IGZhbHNlOyAvLyBzaWduYWxzIHdoZXRoZXIgdGhlIGN1cnJlbnQgbGlzdCBpcyBtYWxmb3JtZWRcblxuICAgICAgdmFyIGhlYWQ7IC8vIHRoZSBoZWFkIG9mIHRoZSBsaXN0IChfOmIxIGluIGFib3ZlIGV4YW1wbGUpXG5cbiAgICAgIHZhciBoZWFkUG9zOyAvLyBzZXQgdG8gc3ViamVjdCBvciBvYmplY3Qgd2hlbiBoZWFkIGlzIHNldFxuXG4gICAgICB2YXIgZ3JhcGggPSB0YWlsUXVhZC5ncmFwaDsgLy8gbWFrZSBzdXJlIGxpc3QgaXMgaW4gZXhhY3RseSBvbmUgZ3JhcGhcbiAgICAgIC8vIFRyYXZlcnNlIHRoZSBsaXN0IGZyb20gdGFpbCB0byBlbmRcblxuICAgICAgdmFyIGN1cnJlbnQgPSB0YWlsUXVhZC5zdWJqZWN0O1xuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiAhbWFsZm9ybWVkKSB7XG4gICAgICAgIHZhciBvYmplY3RRdWFkcyA9IHRoaXMuZ2V0UXVhZHMobnVsbCwgbnVsbCwgY3VycmVudCwgbnVsbCk7XG4gICAgICAgIHZhciBzdWJqZWN0UXVhZHMgPSB0aGlzLmdldFF1YWRzKGN1cnJlbnQsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHF1YWQsXG4gICAgICAgICAgICBmaXJzdCA9IG51bGwsXG4gICAgICAgICAgICByZXN0ID0gbnVsbCxcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7IC8vIEZpbmQgdGhlIGZpcnN0IGFuZCByZXN0IG9mIHRoaXMgbGlzdCBub2RlXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHN1YmplY3RRdWFkcy5sZW5ndGggJiYgIW1hbGZvcm1lZDsgaSsrKSB7XG4gICAgICAgICAgcXVhZCA9IHN1YmplY3RRdWFkc1tpXTtcbiAgICAgICAgICBpZiAoIXF1YWQuZ3JhcGguZXF1YWxzKGdyYXBoKSkgbWFsZm9ybWVkID0gb25FcnJvcihjdXJyZW50LCAnbm90IGNvbmZpbmVkIHRvIHNpbmdsZSBncmFwaCcpO2Vsc2UgaWYgKGhlYWQpIG1hbGZvcm1lZCA9IG9uRXJyb3IoY3VycmVudCwgJ2hhcyBub24tbGlzdCBhcmNzIG91dCcpOyAvLyBvbmUgcmRmOmZpcnN0XG4gICAgICAgICAgZWxzZSBpZiAocXVhZC5wcmVkaWNhdGUudmFsdWUgPT09IF9JUklzLmRlZmF1bHQucmRmLmZpcnN0KSB7XG4gICAgICAgICAgICAgIGlmIChmaXJzdCkgbWFsZm9ybWVkID0gb25FcnJvcihjdXJyZW50LCAnaGFzIG11bHRpcGxlIHJkZjpmaXJzdCBhcmNzJyk7ZWxzZSB0b1JlbW92ZS5wdXNoKGZpcnN0ID0gcXVhZCk7XG4gICAgICAgICAgICB9IC8vIG9uZSByZGY6cmVzdFxuICAgICAgICAgICAgZWxzZSBpZiAocXVhZC5wcmVkaWNhdGUudmFsdWUgPT09IF9JUklzLmRlZmF1bHQucmRmLnJlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdCkgbWFsZm9ybWVkID0gb25FcnJvcihjdXJyZW50LCAnaGFzIG11bHRpcGxlIHJkZjpyZXN0IGFyY3MnKTtlbHNlIHRvUmVtb3ZlLnB1c2gocmVzdCA9IHF1YWQpO1xuICAgICAgICAgICAgICB9IC8vIGFsaWVuIHRyaXBsZVxuICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3RRdWFkcy5sZW5ndGgpIG1hbGZvcm1lZCA9IG9uRXJyb3IoY3VycmVudCwgJ2NhblxcJ3QgYmUgc3ViamVjdCBhbmQgb2JqZWN0Jyk7ZWxzZSB7XG4gICAgICAgICAgICAgICAgICBoZWFkID0gcXVhZDsgLy8gZS5nLiB7ICgxIDIgMykgOnAgOm8gfVxuXG4gICAgICAgICAgICAgICAgICBoZWFkUG9zID0gJ3N1YmplY3QnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB7IDpzIDpwICgxIDIpIH0gYXJyaXZlcyBoZXJlIHdpdGggbm8gaGVhZFxuICAgICAgICAvLyB7ICgxIDIpIDpwIDpvIH0gYXJyaXZlcyBoZXJlIHdpdGggaGVhZCBzZXQgdG8gdGhlIGxpc3QuXG5cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqZWN0UXVhZHMubGVuZ3RoICYmICFtYWxmb3JtZWQ7ICsraSkge1xuICAgICAgICAgIHF1YWQgPSBvYmplY3RRdWFkc1tpXTtcbiAgICAgICAgICBpZiAoaGVhZCkgbWFsZm9ybWVkID0gb25FcnJvcihjdXJyZW50LCAnY2FuXFwndCBoYXZlIGNvcmVmZXJlbmNlcycpOyAvLyBvbmUgcmRmOnJlc3RcbiAgICAgICAgICBlbHNlIGlmIChxdWFkLnByZWRpY2F0ZS52YWx1ZSA9PT0gX0lSSXMuZGVmYXVsdC5yZGYucmVzdCkge1xuICAgICAgICAgICAgICBpZiAocGFyZW50KSBtYWxmb3JtZWQgPSBvbkVycm9yKGN1cnJlbnQsICdoYXMgaW5jb21pbmcgcmRmOnJlc3QgYXJjcycpO2Vsc2UgcGFyZW50ID0gcXVhZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhlYWQgPSBxdWFkOyAvLyBlLmcuIHsgOnMgOnAgKDEgMikgfVxuXG4gICAgICAgICAgICAgIGhlYWRQb3MgPSAnb2JqZWN0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgbGlzdCBpdGVtIGFuZCBjb250aW51ZSB3aXRoIHBhcmVudFxuXG5cbiAgICAgICAgaWYgKCFmaXJzdCkgbWFsZm9ybWVkID0gb25FcnJvcihjdXJyZW50LCAnaGFzIG5vIGxpc3QgaGVhZCcpO2Vsc2UgaXRlbXMudW5zaGlmdChmaXJzdC5vYmplY3QpO1xuICAgICAgICBjdXJyZW50ID0gcGFyZW50ICYmIHBhcmVudC5zdWJqZWN0O1xuICAgICAgfSAvLyBEb24ndCByZW1vdmUgYW55IHF1YWRzIGlmIHRoZSBsaXN0IGlzIG1hbGZvcm1lZFxuXG5cbiAgICAgIGlmIChtYWxmb3JtZWQpIHJlbW92ZSA9IGZhbHNlOyAvLyBTdG9yZSB0aGUgbGlzdCB1bmRlciB0aGUgdmFsdWUgb2YgaXRzIGhlYWRcbiAgICAgIGVsc2UgaWYgKGhlYWQpIGxpc3RzW2hlYWRbaGVhZFBvc10udmFsdWVdID0gaXRlbXM7XG4gICAgfSk7IC8vIFJlbW92ZSBsaXN0IHF1YWRzIGlmIHJlcXVlc3RlZFxuXG4gICAgaWYgKHJlbW92ZSkgdGhpcy5yZW1vdmVRdWFkcyh0b1JlbW92ZSk7XG4gICAgcmV0dXJuIGxpc3RzO1xuICB9XG5cbn0gLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZ1xuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IE4zU3RvcmU7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJyB8fCBzIGluc3RhbmNlb2YgU3RyaW5nO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX04zUGFyc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9OM1BhcnNlclwiKSk7XG5cbnZhciBfcmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyAqKk4zU3RyZWFtUGFyc2VyKiogcGFyc2VzIGEgdGV4dCBzdHJlYW0gaW50byBhIHF1YWQgc3RyZWFtLlxuLy8gIyMgQ29uc3RydWN0b3JcbmNsYXNzIE4zU3RyZWFtUGFyc2VyIGV4dGVuZHMgX3JlYWRhYmxlU3RyZWFtLlRyYW5zZm9ybSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBkZWNvZGVTdHJpbmdzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID0gdHJ1ZTsgLy8gU2V0IHVwIHBhcnNlciB3aXRoIGR1bW15IHN0cmVhbSB0byBvYnRhaW4gYGRhdGFgIGFuZCBgZW5kYCBjYWxsYmFja3NcblxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgcGFyc2VyID0gbmV3IF9OM1BhcnNlci5kZWZhdWx0KG9wdGlvbnMpLFxuICAgICAgICBvbkRhdGEsXG4gICAgICAgIG9uRW5kO1xuICAgIHBhcnNlci5wYXJzZSh7XG4gICAgICBvbjogZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50KSB7XG4gICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICBvbkRhdGEgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIG9uRW5kID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIC8vIEhhbmRsZSBxdWFkcyBieSBwdXNoaW5nIHRoZW0gZG93biB0aGUgcGlwZWxpbmVcbiAgICBmdW5jdGlvbiAoZXJyb3IsIHF1YWQpIHtcbiAgICAgIGVycm9yICYmIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcikgfHwgcXVhZCAmJiBzZWxmLnB1c2gocXVhZCk7XG4gICAgfSwgLy8gRW1pdCBwcmVmaXhlcyB0aHJvdWdoIHRoZSBgcHJlZml4YCBldmVudFxuICAgIGZ1bmN0aW9uIChwcmVmaXgsIHVyaSkge1xuICAgICAgc2VsZi5lbWl0KCdwcmVmaXgnLCBwcmVmaXgsIHVyaSk7XG4gICAgfSk7IC8vIEltcGxlbWVudCBUcmFuc2Zvcm0gbWV0aG9kcyB0aHJvdWdoIHBhcnNlciBjYWxsYmFja3NcblxuICAgIHRoaXMuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICAgIG9uRGF0YShjaHVuayk7XG4gICAgICBkb25lKCk7XG4gICAgfTtcblxuICAgIHRoaXMuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIG9uRW5kKCk7XG4gICAgICBkb25lKCk7XG4gICAgfTtcbiAgfSAvLyAjIyMgUGFyc2VzIGEgc3RyZWFtIG9mIHN0cmluZ3NcblxuXG4gIGltcG9ydChzdHJlYW0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzZWxmLndyaXRlKGNodW5rKTtcbiAgICB9KTtcbiAgICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW5kKCk7XG4gICAgfSk7XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE4zU3RyZWFtUGFyc2VyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlYWRhYmxlU3RyZWFtID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKTtcblxudmFyIF9OM1dyaXRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTjNXcml0ZXJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyAqKk4zU3RyZWFtV3JpdGVyKiogc2VyaWFsaXplcyBhIHF1YWQgc3RyZWFtIGludG8gYSB0ZXh0IHN0cmVhbS5cbi8vICMjIENvbnN0cnVjdG9yXG5jbGFzcyBOM1N0cmVhbVdyaXRlciBleHRlbmRzIF9yZWFkYWJsZVN0cmVhbS5UcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgZW5jb2Rpbmc6ICd1dGY4J1xuICAgIH0pO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUub2JqZWN0TW9kZSA9IHRydWU7IC8vIFNldCB1cCB3cml0ZXIgd2l0aCBhIGR1bW15IHN0cmVhbSBvYmplY3RcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd3JpdGVyID0gdGhpcy5fd3JpdGVyID0gbmV3IF9OM1dyaXRlci5kZWZhdWx0KHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiAocXVhZCwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHNlbGYucHVzaChxdWFkKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH0sXG4gICAgICBlbmQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSwgb3B0aW9ucyk7IC8vIEltcGxlbWVudCBUcmFuc2Zvcm0gbWV0aG9kcyBvbiB0b3Agb2Ygd3JpdGVyXG5cbiAgICB0aGlzLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAocXVhZCwgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICAgIHdyaXRlci5hZGRRdWFkKHF1YWQsIGRvbmUpO1xuICAgIH07XG5cbiAgICB0aGlzLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICB3cml0ZXIuZW5kKGRvbmUpO1xuICAgIH07XG4gIH0gLy8gIyMjIFNlcmlhbGl6ZXMgYSBzdHJlYW0gb2YgcXVhZHNcblxuXG4gIGltcG9ydChzdHJlYW0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKHF1YWQpIHtcbiAgICAgIHNlbGYud3JpdGUocXVhZCk7XG4gICAgfSk7XG4gICAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVuZCgpO1xuICAgIH0pO1xuICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG4gICAgc3RyZWFtLm9uKCdwcmVmaXgnLCBmdW5jdGlvbiAocHJlZml4LCBpcmkpIHtcbiAgICAgIHNlbGYuX3dyaXRlci5hZGRQcmVmaXgocHJlZml4LCBpcmkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gTjNTdHJlYW1Xcml0ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzTmFtZWROb2RlID0gaXNOYW1lZE5vZGU7XG5leHBvcnRzLmlzQmxhbmtOb2RlID0gaXNCbGFua05vZGU7XG5leHBvcnRzLmlzTGl0ZXJhbCA9IGlzTGl0ZXJhbDtcbmV4cG9ydHMuaXNWYXJpYWJsZSA9IGlzVmFyaWFibGU7XG5leHBvcnRzLmlzRGVmYXVsdEdyYXBoID0gaXNEZWZhdWx0R3JhcGg7XG5leHBvcnRzLmluRGVmYXVsdEdyYXBoID0gaW5EZWZhdWx0R3JhcGg7XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMucHJlZml4ZXMgPSBwcmVmaXhlcztcblxudmFyIF9OM0RhdGFGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9OM0RhdGFGYWN0b3J5XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gKipOM1V0aWwqKiBwcm92aWRlcyBOMyB1dGlsaXR5IGZ1bmN0aW9ucy5cbi8vIFRlc3RzIHdoZXRoZXIgdGhlIGdpdmVuIHRlcm0gcmVwcmVzZW50cyBhbiBJUklcbmZ1bmN0aW9uIGlzTmFtZWROb2RlKHRlcm0pIHtcbiAgcmV0dXJuICEhdGVybSAmJiB0ZXJtLnRlcm1UeXBlID09PSAnTmFtZWROb2RlJztcbn0gLy8gVGVzdHMgd2hldGhlciB0aGUgZ2l2ZW4gdGVybSByZXByZXNlbnRzIGEgYmxhbmsgbm9kZVxuXG5cbmZ1bmN0aW9uIGlzQmxhbmtOb2RlKHRlcm0pIHtcbiAgcmV0dXJuICEhdGVybSAmJiB0ZXJtLnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJztcbn0gLy8gVGVzdHMgd2hldGhlciB0aGUgZ2l2ZW4gdGVybSByZXByZXNlbnRzIGEgbGl0ZXJhbFxuXG5cbmZ1bmN0aW9uIGlzTGl0ZXJhbCh0ZXJtKSB7XG4gIHJldHVybiAhIXRlcm0gJiYgdGVybS50ZXJtVHlwZSA9PT0gJ0xpdGVyYWwnO1xufSAvLyBUZXN0cyB3aGV0aGVyIHRoZSBnaXZlbiB0ZXJtIHJlcHJlc2VudHMgYSB2YXJpYWJsZVxuXG5cbmZ1bmN0aW9uIGlzVmFyaWFibGUodGVybSkge1xuICByZXR1cm4gISF0ZXJtICYmIHRlcm0udGVybVR5cGUgPT09ICdWYXJpYWJsZSc7XG59IC8vIFRlc3RzIHdoZXRoZXIgdGhlIGdpdmVuIHRlcm0gcmVwcmVzZW50cyB0aGUgZGVmYXVsdCBncmFwaFxuXG5cbmZ1bmN0aW9uIGlzRGVmYXVsdEdyYXBoKHRlcm0pIHtcbiAgcmV0dXJuICEhdGVybSAmJiB0ZXJtLnRlcm1UeXBlID09PSAnRGVmYXVsdEdyYXBoJztcbn0gLy8gVGVzdHMgd2hldGhlciB0aGUgZ2l2ZW4gcXVhZCBpcyBpbiB0aGUgZGVmYXVsdCBncmFwaFxuXG5cbmZ1bmN0aW9uIGluRGVmYXVsdEdyYXBoKHF1YWQpIHtcbiAgcmV0dXJuIGlzRGVmYXVsdEdyYXBoKHF1YWQuZ3JhcGgpO1xufSAvLyBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcmVwZW5kcyB0aGUgZ2l2ZW4gSVJJIHRvIGEgbG9jYWwgbmFtZVxuXG5cbmZ1bmN0aW9uIHByZWZpeChpcmksIGZhY3RvcnkpIHtcbiAgcmV0dXJuIHByZWZpeGVzKHtcbiAgICAnJzogaXJpXG4gIH0sIGZhY3RvcnkpKCcnKTtcbn0gLy8gQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHJlZ2lzdGVyaW5nIGFuZCBleHBhbmRpbmcgcHJlZml4ZXNcblxuXG5mdW5jdGlvbiBwcmVmaXhlcyhkZWZhdWx0UHJlZml4ZXMsIGZhY3RvcnkpIHtcbiAgLy8gQWRkIGFsbCBvZiB0aGUgZGVmYXVsdCBwcmVmaXhlc1xuICB2YXIgcHJlZml4ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIHByZWZpeCBpbiBkZWZhdWx0UHJlZml4ZXMpIHByb2Nlc3NQcmVmaXgocHJlZml4LCBkZWZhdWx0UHJlZml4ZXNbcHJlZml4XSk7IC8vIFNldCB0aGUgZGVmYXVsdCBmYWN0b3J5IGlmIG5vbmUgd2FzIHNwZWNpZmllZFxuXG5cbiAgZmFjdG9yeSA9IGZhY3RvcnkgfHwgX04zRGF0YUZhY3RvcnkuZGVmYXVsdDsgLy8gUmVnaXN0ZXJzIGEgbmV3IHByZWZpeCAoaWYgYW4gSVJJIHdhcyBzcGVjaWZpZWQpXG4gIC8vIG9yIHJldHJpZXZlcyBhIGZ1bmN0aW9uIHRoYXQgZXhwYW5kcyBhbiBleGlzdGluZyBwcmVmaXggKGlmIG5vIElSSSB3YXMgc3BlY2lmaWVkKVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NQcmVmaXgocHJlZml4LCBpcmkpIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgcHJlZml4IGlmIGFuIElSSSBpcyBzcGVjaWZpZWQgb3IgdGhlIHByZWZpeCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKHR5cGVvZiBpcmkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IGV4cGFuZHMgdGhlIHByZWZpeFxuICAgICAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgcHJlZml4ZXNbcHJlZml4XSA9IGZ1bmN0aW9uIChsb2NhbCkge1xuICAgICAgICByZXR1cm4gY2FjaGVbbG9jYWxdIHx8IChjYWNoZVtsb2NhbF0gPSBmYWN0b3J5Lm5hbWVkTm9kZShpcmkgKyBsb2NhbCkpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEocHJlZml4IGluIHByZWZpeGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByZWZpeDogJyArIHByZWZpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeGVzW3ByZWZpeF07XG4gIH1cblxuICByZXR1cm4gcHJvY2Vzc1ByZWZpeDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9JUklzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9JUklzXCIpKTtcblxudmFyIF9OM0RhdGFGYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vTjNEYXRhRmFjdG9yeVwiKSk7XG5cbnZhciBfTjNVdGlsID0gcmVxdWlyZShcIi4vTjNVdGlsXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gKipOM1dyaXRlcioqIHdyaXRlcyBOMyBkb2N1bWVudHMuXG5jb25zdCBERUZBVUxUR1JBUEggPSBfTjNEYXRhRmFjdG9yeS5kZWZhdWx0LmRlZmF1bHRHcmFwaCgpO1xuXG5jb25zdCB7XG4gIHJkZixcbiAgeHNkXG59ID0gX0lSSXMuZGVmYXVsdDsgLy8gQ2hhcmFjdGVycyBpbiBsaXRlcmFscyB0aGF0IHJlcXVpcmUgZXNjYXBpbmdcblxudmFyIGVzY2FwZSA9IC9bXCJcXFxcXFx0XFxuXFxyXFxiXFxmXFx1MDAwMC1cXHUwMDE5XFx1ZDgwMC1cXHVkYmZmXS8sXG4gICAgZXNjYXBlQWxsID0gL1tcIlxcXFxcXHRcXG5cXHJcXGJcXGZcXHUwMDAwLVxcdTAwMTldfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0vZyxcbiAgICBlc2NhcGVkQ2hhcmFjdGVycyA9IHtcbiAgJ1xcXFwnOiAnXFxcXFxcXFwnLFxuICAnXCInOiAnXFxcXFwiJyxcbiAgJ1xcdCc6ICdcXFxcdCcsXG4gICdcXG4nOiAnXFxcXG4nLFxuICAnXFxyJzogJ1xcXFxyJyxcbiAgJ1xcYic6ICdcXFxcYicsXG4gICdcXGYnOiAnXFxcXGYnXG59OyAvLyAjIyBQbGFjZWhvbGRlciBjbGFzcyB0byByZXByZXNlbnQgYWxyZWFkeSBwcmV0dHktcHJpbnRlZCB0ZXJtc1xuXG5jbGFzcyBTZXJpYWxpemVkVGVybSBleHRlbmRzIF9OM0RhdGFGYWN0b3J5LlRlcm0ge1xuICAvLyBQcmV0dHktcHJpbnRlZCBub2RlcyBhcmUgbm90IGVxdWFsIHRvIGFueSBvdGhlciBub2RlXG4gIC8vIChlLmcuLCBbXSBkb2VzIG5vdCBlcXVhbCBbXSlcbiAgZXF1YWxzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59IC8vICMjIENvbnN0cnVjdG9yXG5cblxuY2xhc3MgTjNXcml0ZXIge1xuICBjb25zdHJ1Y3RvcihvdXRwdXRTdHJlYW0sIG9wdGlvbnMpIHtcbiAgICAvLyAjIyMgYF9wcmVmaXhSZWdleGAgbWF0Y2hlcyBhIHByZWZpeGVkIG5hbWUgb3IgSVJJIHRoYXQgYmVnaW5zIHdpdGggb25lIG9mIHRoZSBhZGRlZCBwcmVmaXhlc1xuICAgIHRoaXMuX3ByZWZpeFJlZ2V4ID0gLyQwXi87IC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbm90IGEgc3RyZWFtXG5cbiAgICBpZiAob3V0cHV0U3RyZWFtICYmIHR5cGVvZiBvdXRwdXRTdHJlYW0ud3JpdGUgIT09ICdmdW5jdGlvbicpIG9wdGlvbnMgPSBvdXRwdXRTdHJlYW0sIG91dHB1dFN0cmVhbSA9IG51bGw7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fbGlzdHMgPSBvcHRpb25zLmxpc3RzOyAvLyBJZiBubyBvdXRwdXQgc3RyZWFtIGdpdmVuLCBzZW5kIHRoZSBvdXRwdXQgYXMgc3RyaW5nIHRocm91Z2ggdGhlIGVuZCBjYWxsYmFja1xuXG4gICAgaWYgKCFvdXRwdXRTdHJlYW0pIHtcbiAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgIHRoaXMuX291dHB1dFN0cmVhbSA9IHtcbiAgICAgICAgd3JpdGUoY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICAgICAgb3V0cHV0ICs9IGNodW5rO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZDogZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICBkb25lICYmIGRvbmUobnVsbCwgb3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2VuZFN0cmVhbSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX291dHB1dFN0cmVhbSA9IG91dHB1dFN0cmVhbTtcbiAgICAgIHRoaXMuX2VuZFN0cmVhbSA9IG9wdGlvbnMuZW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFvcHRpb25zLmVuZDtcbiAgICB9IC8vIEluaXRpYWxpemUgd3JpdGVyLCBkZXBlbmRpbmcgb24gdGhlIGZvcm1hdFxuXG5cbiAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcblxuICAgIGlmICghL3RyaXBsZXxxdWFkL2kudGVzdChvcHRpb25zLmZvcm1hdCkpIHtcbiAgICAgIHRoaXMuX2dyYXBoID0gREVGQVVMVEdSQVBIO1xuICAgICAgdGhpcy5fcHJlZml4SVJJcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBvcHRpb25zLnByZWZpeGVzICYmIHRoaXMuYWRkUHJlZml4ZXMob3B0aW9ucy5wcmVmaXhlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dyaXRlUXVhZCA9IHRoaXMuX3dyaXRlUXVhZExpbmU7XG4gICAgfVxuICB9IC8vICMjIFByaXZhdGUgbWV0aG9kc1xuICAvLyAjIyMgV2hldGhlciB0aGUgY3VycmVudCBncmFwaCBpcyB0aGUgZGVmYXVsdCBncmFwaFxuXG5cbiAgZ2V0IF9pbkRlZmF1bHRHcmFwaCgpIHtcbiAgICByZXR1cm4gREVGQVVMVEdSQVBILmVxdWFscyh0aGlzLl9ncmFwaCk7XG4gIH0gLy8gIyMjIGBfd3JpdGVgIHdyaXRlcyB0aGUgYXJndW1lbnQgdG8gdGhlIG91dHB1dCBzdHJlYW1cblxuXG4gIF93cml0ZShzdHJpbmcsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fb3V0cHV0U3RyZWFtLndyaXRlKHN0cmluZywgJ3V0ZjgnLCBjYWxsYmFjayk7XG4gIH0gLy8gIyMjIGBfd3JpdGVRdWFkYCB3cml0ZXMgdGhlIHF1YWQgdG8gdGhlIG91dHB1dCBzdHJlYW1cblxuXG4gIF93cml0ZVF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoLCBkb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdyaXRlIHRoZSBncmFwaCdzIGxhYmVsIGlmIGl0IGhhcyBjaGFuZ2VkXG4gICAgICBpZiAoIWdyYXBoLmVxdWFscyh0aGlzLl9ncmFwaCkpIHtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIHByZXZpb3VzIGdyYXBoIGFuZCBzdGFydCB0aGUgbmV3IG9uZVxuICAgICAgICB0aGlzLl93cml0ZSgodGhpcy5fc3ViamVjdCA9PT0gbnVsbCA/ICcnIDogdGhpcy5faW5EZWZhdWx0R3JhcGggPyAnLlxcbicgOiAnXFxufVxcbicpICsgKERFRkFVTFRHUkFQSC5lcXVhbHMoZ3JhcGgpID8gJycgOiB0aGlzLl9lbmNvZGVJcmlPckJsYW5rKGdyYXBoKSArICcge1xcbicpKTtcblxuICAgICAgICB0aGlzLl9ncmFwaCA9IGdyYXBoO1xuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgIH0gLy8gRG9uJ3QgcmVwZWF0IHRoZSBzdWJqZWN0IGlmIGl0J3MgdGhlIHNhbWVcblxuXG4gICAgICBpZiAoc3ViamVjdC5lcXVhbHModGhpcy5fc3ViamVjdCkpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwZWF0IHRoZSBwcmVkaWNhdGUgaWYgaXQncyB0aGUgc2FtZVxuICAgICAgICBpZiAocHJlZGljYXRlLmVxdWFscyh0aGlzLl9wcmVkaWNhdGUpKSB0aGlzLl93cml0ZSgnLCAnICsgdGhpcy5fZW5jb2RlT2JqZWN0KG9iamVjdCksIGRvbmUpOyAvLyBTYW1lIHN1YmplY3QsIGRpZmZlcmVudCBwcmVkaWNhdGVcbiAgICAgICAgZWxzZSB0aGlzLl93cml0ZSgnO1xcbiAgICAnICsgdGhpcy5fZW5jb2RlUHJlZGljYXRlKHRoaXMuX3ByZWRpY2F0ZSA9IHByZWRpY2F0ZSkgKyAnICcgKyB0aGlzLl9lbmNvZGVPYmplY3Qob2JqZWN0KSwgZG9uZSk7XG4gICAgICB9IC8vIERpZmZlcmVudCBzdWJqZWN0OyB3cml0ZSB0aGUgd2hvbGUgcXVhZFxuICAgICAgZWxzZSB0aGlzLl93cml0ZSgodGhpcy5fc3ViamVjdCA9PT0gbnVsbCA/ICcnIDogJy5cXG4nKSArIHRoaXMuX2VuY29kZVN1YmplY3QodGhpcy5fc3ViamVjdCA9IHN1YmplY3QpICsgJyAnICsgdGhpcy5fZW5jb2RlUHJlZGljYXRlKHRoaXMuX3ByZWRpY2F0ZSA9IHByZWRpY2F0ZSkgKyAnICcgKyB0aGlzLl9lbmNvZGVPYmplY3Qob2JqZWN0KSwgZG9uZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRvbmUgJiYgZG9uZShlcnJvcik7XG4gICAgfVxuICB9IC8vICMjIyBgX3dyaXRlUXVhZExpbmVgIHdyaXRlcyB0aGUgcXVhZCB0byB0aGUgb3V0cHV0IHN0cmVhbSBhcyBhIHNpbmdsZSBsaW5lXG5cblxuICBfd3JpdGVRdWFkTGluZShzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgsIGRvbmUpIHtcbiAgICAvLyBXcml0ZSB0aGUgcXVhZCB3aXRob3V0IHByZWZpeGVzXG4gICAgZGVsZXRlIHRoaXMuX3ByZWZpeE1hdGNoO1xuXG4gICAgdGhpcy5fd3JpdGUodGhpcy5xdWFkVG9TdHJpbmcoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSwgZG9uZSk7XG4gIH0gLy8gIyMjIGBxdWFkVG9TdHJpbmdgIHNlcmlhbGl6ZXMgYSBxdWFkIGFzIGEgc3RyaW5nXG5cblxuICBxdWFkVG9TdHJpbmcoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVN1YmplY3Qoc3ViamVjdCkgKyAnICcgKyB0aGlzLl9lbmNvZGVJcmlPckJsYW5rKHByZWRpY2F0ZSkgKyAnICcgKyB0aGlzLl9lbmNvZGVPYmplY3Qob2JqZWN0KSArIChncmFwaCAmJiBncmFwaC52YWx1ZSA/ICcgJyArIHRoaXMuX2VuY29kZUlyaU9yQmxhbmsoZ3JhcGgpICsgJyAuXFxuJyA6ICcgLlxcbicpO1xuICB9IC8vICMjIyBgcXVhZHNUb1N0cmluZ2Agc2VyaWFsaXplcyBhbiBhcnJheSBvZiBxdWFkcyBhcyBhIHN0cmluZ1xuXG5cbiAgcXVhZHNUb1N0cmluZyhxdWFkcykge1xuICAgIHJldHVybiBxdWFkcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1YWRUb1N0cmluZyh0LnN1YmplY3QsIHQucHJlZGljYXRlLCB0Lm9iamVjdCwgdC5ncmFwaCk7XG4gICAgfSwgdGhpcykuam9pbignJyk7XG4gIH0gLy8gIyMjIGBfZW5jb2RlU3ViamVjdGAgcmVwcmVzZW50cyBhIHN1YmplY3RcblxuXG4gIF9lbmNvZGVTdWJqZWN0KGVudGl0eSkge1xuICAgIHJldHVybiBlbnRpdHkudGVybVR5cGUgPT09ICdRdWFkJyA/IHRoaXMuX2VuY29kZVF1YWQoZW50aXR5KSA6IHRoaXMuX2VuY29kZUlyaU9yQmxhbmsoZW50aXR5KTtcbiAgfSAvLyAjIyMgYF9lbmNvZGVJcmlPckJsYW5rYCByZXByZXNlbnRzIGFuIElSSSBvciBibGFuayBub2RlXG5cblxuICBfZW5jb2RlSXJpT3JCbGFuayhlbnRpdHkpIHtcbiAgICAvLyBBIGJsYW5rIG5vZGUgb3IgbGlzdCBpcyByZXByZXNlbnRlZCBhcy1pc1xuICAgIGlmIChlbnRpdHkudGVybVR5cGUgIT09ICdOYW1lZE5vZGUnKSB7XG4gICAgICAvLyBJZiBpdCBpcyBhIGxpc3QgaGVhZCwgcHJldHR5LXByaW50IGl0XG4gICAgICBpZiAodGhpcy5fbGlzdHMgJiYgZW50aXR5LnZhbHVlIGluIHRoaXMuX2xpc3RzKSBlbnRpdHkgPSB0aGlzLmxpc3QodGhpcy5fbGlzdHNbZW50aXR5LnZhbHVlXSk7XG4gICAgICByZXR1cm4gJ2lkJyBpbiBlbnRpdHkgPyBlbnRpdHkuaWQgOiAnXzonICsgZW50aXR5LnZhbHVlO1xuICAgIH0gLy8gRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVyc1xuXG5cbiAgICB2YXIgaXJpID0gZW50aXR5LnZhbHVlO1xuICAgIGlmIChlc2NhcGUudGVzdChpcmkpKSBpcmkgPSBpcmkucmVwbGFjZShlc2NhcGVBbGwsIGNoYXJhY3RlclJlcGxhY2VyKTsgLy8gVHJ5IHRvIHJlcHJlc2VudCB0aGUgSVJJIGFzIHByZWZpeGVkIG5hbWVcblxuICAgIHZhciBwcmVmaXhNYXRjaCA9IHRoaXMuX3ByZWZpeFJlZ2V4LmV4ZWMoaXJpKTtcblxuICAgIHJldHVybiAhcHJlZml4TWF0Y2ggPyAnPCcgKyBpcmkgKyAnPicgOiAhcHJlZml4TWF0Y2hbMV0gPyBpcmkgOiB0aGlzLl9wcmVmaXhJUklzW3ByZWZpeE1hdGNoWzFdXSArIHByZWZpeE1hdGNoWzJdO1xuICB9IC8vICMjIyBgX2VuY29kZUxpdGVyYWxgIHJlcHJlc2VudHMgYSBsaXRlcmFsXG5cblxuICBfZW5jb2RlTGl0ZXJhbChsaXRlcmFsKSB7XG4gICAgLy8gRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgIHZhciB2YWx1ZSA9IGxpdGVyYWwudmFsdWU7XG4gICAgaWYgKGVzY2FwZS50ZXN0KHZhbHVlKSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGVzY2FwZUFsbCwgY2hhcmFjdGVyUmVwbGFjZXIpOyAvLyBXcml0ZSB0aGUgbGl0ZXJhbCwgcG9zc2libHkgd2l0aCB0eXBlIG9yIGxhbmd1YWdlXG5cbiAgICBpZiAobGl0ZXJhbC5sYW5ndWFnZSkgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIkAnICsgbGl0ZXJhbC5sYW5ndWFnZTtlbHNlIGlmIChsaXRlcmFsLmRhdGF0eXBlLnZhbHVlICE9PSB4c2Quc3RyaW5nKSByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiXl4nICsgdGhpcy5fZW5jb2RlSXJpT3JCbGFuayhsaXRlcmFsLmRhdGF0eXBlKTtlbHNlIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICB9IC8vICMjIyBgX2VuY29kZVByZWRpY2F0ZWAgcmVwcmVzZW50cyBhIHByZWRpY2F0ZVxuXG5cbiAgX2VuY29kZVByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlLnZhbHVlID09PSByZGYudHlwZSA/ICdhJyA6IHRoaXMuX2VuY29kZUlyaU9yQmxhbmsocHJlZGljYXRlKTtcbiAgfSAvLyAjIyMgYF9lbmNvZGVPYmplY3RgIHJlcHJlc2VudHMgYW4gb2JqZWN0XG5cblxuICBfZW5jb2RlT2JqZWN0KG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0LnRlcm1UeXBlKSB7XG4gICAgICBjYXNlICdRdWFkJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVF1YWQob2JqZWN0KTtcblxuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVMaXRlcmFsKG9iamVjdCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVJcmlPckJsYW5rKG9iamVjdCk7XG4gICAgfVxuICB9IC8vICMjIyBgX2VuY29kZVF1YWRgIGVuY29kZXMgYW4gUkRGKiBxdWFkXG5cblxuICBfZW5jb2RlUXVhZCh7XG4gICAgc3ViamVjdCxcbiAgICBwcmVkaWNhdGUsXG4gICAgb2JqZWN0LFxuICAgIGdyYXBoXG4gIH0pIHtcbiAgICByZXR1cm4gYDw8JHt0aGlzLl9lbmNvZGVTdWJqZWN0KHN1YmplY3QpfSAke3RoaXMuX2VuY29kZVByZWRpY2F0ZShwcmVkaWNhdGUpfSAke3RoaXMuX2VuY29kZU9iamVjdChvYmplY3QpfSR7KDAsIF9OM1V0aWwuaXNEZWZhdWx0R3JhcGgpKGdyYXBoKSA/ICcnIDogYCAke3RoaXMuX2VuY29kZUlyaU9yQmxhbmsoZ3JhcGgpfWB9Pj5gO1xuICB9IC8vICMjIyBgX2Jsb2NrZWRXcml0ZWAgcmVwbGFjZXMgYF93cml0ZWAgYWZ0ZXIgdGhlIHdyaXRlciBoYXMgYmVlbiBjbG9zZWRcblxuXG4gIF9ibG9ja2VkV3JpdGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgd3JpdGUgYmVjYXVzZSB0aGUgd3JpdGVyIGhhcyBiZWVuIGNsb3NlZC4nKTtcbiAgfSAvLyAjIyMgYGFkZFF1YWRgIGFkZHMgdGhlIHF1YWQgdG8gdGhlIG91dHB1dCBzdHJlYW1cblxuXG4gIGFkZFF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoLCBkb25lKSB7XG4gICAgLy8gVGhlIHF1YWQgd2FzIGdpdmVuIGFzIGFuIG9iamVjdCwgc28gc2hpZnQgcGFyYW1ldGVyc1xuICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCkgdGhpcy5fd3JpdGVRdWFkKHN1YmplY3Quc3ViamVjdCwgc3ViamVjdC5wcmVkaWNhdGUsIHN1YmplY3Qub2JqZWN0LCBzdWJqZWN0LmdyYXBoLCBwcmVkaWNhdGUpOyAvLyBUaGUgb3B0aW9uYWwgYGdyYXBoYCBwYXJhbWV0ZXIgd2FzIG5vdCBwcm92aWRlZFxuICAgIGVsc2UgaWYgKHR5cGVvZiBncmFwaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGVRdWFkKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBERUZBVUxUR1JBUEgsIGdyYXBoKTsgLy8gVGhlIGBncmFwaGAgcGFyYW1ldGVyIHdhcyBwcm92aWRlZFxuICAgICAgZWxzZSB0aGlzLl93cml0ZVF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoIHx8IERFRkFVTFRHUkFQSCwgZG9uZSk7XG4gIH0gLy8gIyMjIGBhZGRRdWFkc2AgYWRkcyB0aGUgcXVhZHMgdG8gdGhlIG91dHB1dCBzdHJlYW1cblxuXG4gIGFkZFF1YWRzKHF1YWRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFkcy5sZW5ndGg7IGkrKykgdGhpcy5hZGRRdWFkKHF1YWRzW2ldKTtcbiAgfSAvLyAjIyMgYGFkZFByZWZpeGAgYWRkcyB0aGUgcHJlZml4IHRvIHRoZSBvdXRwdXQgc3RyZWFtXG5cblxuICBhZGRQcmVmaXgocHJlZml4LCBpcmksIGRvbmUpIHtcbiAgICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgICBwcmVmaXhlc1twcmVmaXhdID0gaXJpO1xuICAgIHRoaXMuYWRkUHJlZml4ZXMocHJlZml4ZXMsIGRvbmUpO1xuICB9IC8vICMjIyBgYWRkUHJlZml4ZXNgIGFkZHMgdGhlIHByZWZpeGVzIHRvIHRoZSBvdXRwdXQgc3RyZWFtXG5cblxuICBhZGRQcmVmaXhlcyhwcmVmaXhlcywgZG9uZSkge1xuICAgIHZhciBwcmVmaXhJUklzID0gdGhpcy5fcHJlZml4SVJJcyxcbiAgICAgICAgaGFzUHJlZml4ZXMgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIHByZWZpeCBpbiBwcmVmaXhlcykge1xuICAgICAgdmFyIGlyaSA9IHByZWZpeGVzW3ByZWZpeF07XG4gICAgICBpZiAodHlwZW9mIGlyaSAhPT0gJ3N0cmluZycpIGlyaSA9IGlyaS52YWx1ZTtcbiAgICAgIGhhc1ByZWZpeGVzID0gdHJ1ZTsgLy8gRmluaXNoIGEgcG9zc2libGUgcGVuZGluZyBxdWFkXG5cbiAgICAgIGlmICh0aGlzLl9zdWJqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3dyaXRlKHRoaXMuX2luRGVmYXVsdEdyYXBoID8gJy5cXG4nIDogJ1xcbn1cXG4nKTtcblxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbCwgdGhpcy5fZ3JhcGggPSAnJztcbiAgICAgIH0gLy8gU3RvcmUgYW5kIHdyaXRlIHRoZSBwcmVmaXhcblxuXG4gICAgICBwcmVmaXhJUklzW2lyaV0gPSBwcmVmaXggKz0gJzonO1xuXG4gICAgICB0aGlzLl93cml0ZSgnQHByZWZpeCAnICsgcHJlZml4ICsgJyA8JyArIGlyaSArICc+LlxcbicpO1xuICAgIH0gLy8gUmVjcmVhdGUgdGhlIHByZWZpeCBtYXRjaGVyXG5cblxuICAgIGlmIChoYXNQcmVmaXhlcykge1xuICAgICAgdmFyIElSSWxpc3QgPSAnJyxcbiAgICAgICAgICBwcmVmaXhMaXN0ID0gJyc7XG5cbiAgICAgIGZvciAodmFyIHByZWZpeElSSSBpbiBwcmVmaXhJUklzKSB7XG4gICAgICAgIElSSWxpc3QgKz0gSVJJbGlzdCA/ICd8JyArIHByZWZpeElSSSA6IHByZWZpeElSSTtcbiAgICAgICAgcHJlZml4TGlzdCArPSAocHJlZml4TGlzdCA/ICd8JyA6ICcnKSArIHByZWZpeElSSXNbcHJlZml4SVJJXTtcbiAgICAgIH1cblxuICAgICAgSVJJbGlzdCA9IElSSWxpc3QucmVwbGFjZSgvW1xcXVxcL1xcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXCRdL2csICdcXFxcJCYnKTtcbiAgICAgIHRoaXMuX3ByZWZpeFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBwcmVmaXhMaXN0ICsgJylbXlxcL10qJHwnICsgJ14oJyArIElSSWxpc3QgKyAnKShbYS16QS1aXVtcXFxcLV9hLXpBLVowLTldKikkJyk7XG4gICAgfSAvLyBFbmQgYSBwcmVmaXggYmxvY2sgd2l0aCBhIG5ld2xpbmVcblxuXG4gICAgdGhpcy5fd3JpdGUoaGFzUHJlZml4ZXMgPyAnXFxuJyA6ICcnLCBkb25lKTtcbiAgfSAvLyAjIyMgYGJsYW5rYCBjcmVhdGVzIGEgYmxhbmsgbm9kZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50XG5cblxuICBibGFuayhwcmVkaWNhdGUsIG9iamVjdCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHByZWRpY2F0ZSxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIGxlbmd0aDsgLy8gRW1wdHkgYmxhbmsgbm9kZVxuXG4gICAgaWYgKHByZWRpY2F0ZSA9PT0gdW5kZWZpbmVkKSBjaGlsZHJlbiA9IFtdOyAvLyBCbGFuayBub2RlIHBhc3NlZCBhcyBibGFuayhUZXJtKFwicHJlZGljYXRlXCIpLCBUZXJtKFwib2JqZWN0XCIpKVxuICAgIGVsc2UgaWYgKHByZWRpY2F0ZS50ZXJtVHlwZSkgY2hpbGRyZW4gPSBbe1xuICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1dOyAvLyBCbGFuayBub2RlIHBhc3NlZCBhcyBibGFuayh7IHByZWRpY2F0ZTogcHJlZGljYXRlLCBvYmplY3Q6IG9iamVjdCB9KVxuICAgICAgZWxzZSBpZiAoISgnbGVuZ3RoJyBpbiBwcmVkaWNhdGUpKSBjaGlsZHJlbiA9IFtwcmVkaWNhdGVdO1xuXG4gICAgc3dpdGNoIChsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIEdlbmVyYXRlIGFuIGVtcHR5IGJsYW5rIG5vZGVcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJpYWxpemVkVGVybSgnW10nKTtcbiAgICAgIC8vIEdlbmVyYXRlIGEgbm9uLW5lc3RlZCBvbmUtdHJpcGxlIGJsYW5rIG5vZGVcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIShjaGlsZC5vYmplY3QgaW5zdGFuY2VvZiBTZXJpYWxpemVkVGVybSkpIHJldHVybiBuZXcgU2VyaWFsaXplZFRlcm0oJ1sgJyArIHRoaXMuX2VuY29kZVByZWRpY2F0ZShjaGlsZC5wcmVkaWNhdGUpICsgJyAnICsgdGhpcy5fZW5jb2RlT2JqZWN0KGNoaWxkLm9iamVjdCkgKyAnIF0nKTtcbiAgICAgIC8vIEdlbmVyYXRlIGEgbXVsdGktdHJpcGxlIG9yIG5lc3RlZCBibGFuayBub2RlXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBjb250ZW50cyA9ICdbJzsgLy8gV3JpdGUgYWxsIHRyaXBsZXMgaW4gb3JkZXJcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTsgLy8gV3JpdGUgb25seSB0aGUgb2JqZWN0IGlzIHRoZSBwcmVkaWNhdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzXG5cbiAgICAgICAgICBpZiAoY2hpbGQucHJlZGljYXRlLmVxdWFscyhwcmVkaWNhdGUpKSBjb250ZW50cyArPSAnLCAnICsgdGhpcy5fZW5jb2RlT2JqZWN0KGNoaWxkLm9iamVjdCk7IC8vIE90aGVyd2lzZSwgd3JpdGUgdGhlIHByZWRpY2F0ZSBhbmQgdGhlIG9iamVjdFxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZW50cyArPSAoaSA/ICc7XFxuICAnIDogJ1xcbiAgJykgKyB0aGlzLl9lbmNvZGVQcmVkaWNhdGUoY2hpbGQucHJlZGljYXRlKSArICcgJyArIHRoaXMuX2VuY29kZU9iamVjdChjaGlsZC5vYmplY3QpO1xuICAgICAgICAgICAgICBwcmVkaWNhdGUgPSBjaGlsZC5wcmVkaWNhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFNlcmlhbGl6ZWRUZXJtKGNvbnRlbnRzICsgJ1xcbl0nKTtcbiAgICB9XG4gIH0gLy8gIyMjIGBsaXN0YCBjcmVhdGVzIGEgbGlzdCBub2RlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnRcblxuXG4gIGxpc3QoZWxlbWVudHMpIHtcbiAgICB2YXIgbGVuZ3RoID0gZWxlbWVudHMgJiYgZWxlbWVudHMubGVuZ3RoIHx8IDAsXG4gICAgICAgIGNvbnRlbnRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBjb250ZW50c1tpXSA9IHRoaXMuX2VuY29kZU9iamVjdChlbGVtZW50c1tpXSk7XG5cbiAgICByZXR1cm4gbmV3IFNlcmlhbGl6ZWRUZXJtKCcoJyArIGNvbnRlbnRzLmpvaW4oJyAnKSArICcpJyk7XG4gIH0gLy8gIyMjIGBlbmRgIHNpZ25hbHMgdGhlIGVuZCBvZiB0aGUgb3V0cHV0IHN0cmVhbVxuXG5cbiAgZW5kKGRvbmUpIHtcbiAgICAvLyBGaW5pc2ggYSBwb3NzaWJsZSBwZW5kaW5nIHF1YWRcbiAgICBpZiAodGhpcy5fc3ViamVjdCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fd3JpdGUodGhpcy5faW5EZWZhdWx0R3JhcGggPyAnLlxcbicgOiAnXFxufVxcbicpO1xuXG4gICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICB9IC8vIERpc2FsbG93IGZ1cnRoZXIgd3JpdGluZ1xuXG5cbiAgICB0aGlzLl93cml0ZSA9IHRoaXMuX2Jsb2NrZWRXcml0ZTsgLy8gVHJ5IHRvIGVuZCB0aGUgdW5kZXJseWluZyBzdHJlYW0sIGVuc3VyaW5nIGRvbmUgaXMgY2FsbGVkIGV4YWN0bHkgb25lIHRpbWVcblxuICAgIHZhciBzaW5nbGVEb25lID0gZG9uZSAmJiBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xuICAgICAgc2luZ2xlRG9uZSA9IG51bGwsIGRvbmUoZXJyb3IsIHJlc3VsdCk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9lbmRTdHJlYW0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdXRwdXRTdHJlYW0uZW5kKHNpbmdsZURvbmUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLyogZXJyb3IgY2xvc2luZyBzdHJlYW0gKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzaW5nbGVEb25lICYmIHNpbmdsZURvbmUoKTtcbiAgfVxuXG59IC8vIFJlcGxhY2VzIGEgY2hhcmFjdGVyIGJ5IGl0cyBlc2NhcGVkIHZlcnNpb25cblxuXG5leHBvcnRzLmRlZmF1bHQgPSBOM1dyaXRlcjtcblxuZnVuY3Rpb24gY2hhcmFjdGVyUmVwbGFjZXIoY2hhcmFjdGVyKSB7XG4gIC8vIFJlcGxhY2UgYSBzaW5nbGUgY2hhcmFjdGVyIGJ5IGl0cyBlc2NhcGVkIHZlcnNpb25cbiAgdmFyIHJlc3VsdCA9IGVzY2FwZWRDaGFyYWN0ZXJzW2NoYXJhY3Rlcl07XG5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gUmVwbGFjZSBhIHNpbmdsZSBjaGFyYWN0ZXIgd2l0aCBpdHMgNC1iaXQgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VcbiAgICBpZiAoY2hhcmFjdGVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmVzdWx0ID0gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgICAgcmVzdWx0ID0gJ1xcXFx1MDAwMCcuc3Vic3RyKDAsIDYgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdDtcbiAgICB9IC8vIFJlcGxhY2UgYSBzdXJyb2dhdGUgcGFpciB3aXRoIGl0cyA4LWJpdCB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAoKGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIC0gMHhEODAwKSAqIDB4NDAwICsgY2hhcmFjdGVyLmNoYXJDb2RlQXQoMSkgKyAweDI0MDApLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmVzdWx0ID0gJ1xcXFxVMDAwMDAwMDAnLnN1YnN0cigwLCAxMCAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0O1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxleGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM0xleGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFyc2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM1BhcnNlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldyaXRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNXcml0ZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdG9yZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNTdG9yZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmVhbVBhcnNlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNTdHJlYW1QYXJzZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHJlYW1Xcml0ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zU3RyZWFtV3JpdGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YUZhY3RvcnlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zRGF0YUZhY3RvcnkuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUZXJtXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM0RhdGFGYWN0b3J5LlRlcm07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZWROb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM0RhdGFGYWN0b3J5Lk5hbWVkTm9kZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaXRlcmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM0RhdGFGYWN0b3J5LkxpdGVyYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmxhbmtOb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9OM0RhdGFGYWN0b3J5LkJsYW5rTm9kZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYXJpYWJsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNEYXRhRmFjdG9yeS5WYXJpYWJsZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWZhdWx0R3JhcGhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zRGF0YUZhY3RvcnkuRGVmYXVsdEdyYXBoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlF1YWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zRGF0YUZhY3RvcnkuUXVhZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmlwbGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zRGF0YUZhY3RvcnkuVHJpcGxlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRlcm1Gcm9tSWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX04zRGF0YUZhY3RvcnkudGVybUZyb21JZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0ZXJtVG9JZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTjNEYXRhRmFjdG9yeS50ZXJtVG9JZDtcbiAgfVxufSk7XG5leHBvcnRzLlV0aWwgPSB2b2lkIDA7XG5cbnZhciBfTjNMZXhlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTjNMZXhlclwiKSk7XG5cbnZhciBfTjNQYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL04zUGFyc2VyXCIpKTtcblxudmFyIF9OM1dyaXRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTjNXcml0ZXJcIikpO1xuXG52YXIgX04zU3RvcmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL04zU3RvcmVcIikpO1xuXG52YXIgX04zU3RyZWFtUGFyc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9OM1N0cmVhbVBhcnNlclwiKSk7XG5cbnZhciBfTjNTdHJlYW1Xcml0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL04zU3RyZWFtV3JpdGVyXCIpKTtcblxudmFyIFV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9OM1V0aWxcIikpO1xuXG5leHBvcnRzLlV0aWwgPSBVdGlsO1xuXG52YXIgX04zRGF0YUZhY3RvcnkgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9OM0RhdGFGYWN0b3J5XCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9IiwiLyoqXG4gKiBCYXNlLU4vQmFzZS1YIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBmcm9tIGJhc2UteDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmFzZS14XG4gKlxuICogV2hpY2ggaXMgTUlUIGxpY2Vuc2VkOlxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCBiYXNlLXggY29udHJpYnV0b3JzIChjKSAyMDE2XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGJhc2VOIGFscGhhYmV0IGluZGV4ZXNcbnZhciBfcmV2ZXJzZUFscGhhYmV0cyA9IHt9O1xuXG4vKipcbiAqIEJhc2VOLWVuY29kZXMgYSBVaW50OEFycmF5IHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2VOLWVuY29kZWQgb3V0cHV0IHN0cmluZy5cbiAqL1xuYXBpLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCwgbWF4bGluZSkge1xuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYobWF4bGluZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBtYXhsaW5lICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibWF4bGluZVwiIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgaWYoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgLy8gYXNzdW1lIGZvcmdlIGJ5dGUgYnVmZmVyXG4gICAgb3V0cHV0ID0gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgICB2YXIgZGlnaXRzID0gWzBdO1xuICAgIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0W2ldOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIGJhc2U7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IoaSA9IDA7IGlucHV0W2ldID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG91dHB1dCArPSBmaXJzdDtcbiAgICB9XG4gICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gICAgfVxuICB9XG5cbiAgaWYobWF4bGluZSkge1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJy57MSwnICsgbWF4bGluZSArICd9JywgJ2cnKTtcbiAgICBvdXRwdXQgPSBvdXRwdXQubWF0Y2gocmVnZXgpLmpvaW4oJ1xcclxcbicpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2VOLWVuY29kZWQgKHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldCkgc3RyaW5nIHRvIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlTi1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5LlxuICovXG5hcGkuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIGFscGhhYmV0KSB7XG4gIGlmKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlucHV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF07XG4gIGlmKCF0YWJsZSkge1xuICAgIC8vIGNvbXB1dGUgcmV2ZXJzZSBhbHBoYWJldFxuICAgIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0YWJsZVthbHBoYWJldC5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgdmFyIGJ5dGVzID0gWzBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB0YWJsZVtpbnB1dC5jaGFyQ29kZUF0KGkpXTtcbiAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBieXRlc1tqXSAqIGJhc2U7XG4gICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgIGNhcnJ5ID4+PSA4O1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgY2FycnkgPj49IDg7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgZm9yKHZhciBrID0gMDsgaW5wdXRba10gPT09IGZpcnN0ICYmIGsgPCBpbnB1dC5sZW5ndGggLSAxOyArK2spIHtcbiAgICBieXRlcy5wdXNoKDApO1xuICB9XG5cbiAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpO1xufTtcblxuZnVuY3Rpb24gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCkge1xuICB2YXIgaSA9IDA7XG4gIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gIHZhciBkaWdpdHMgPSBbMF07XG4gIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCgpOyArK2kpIHtcbiAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0LmF0KGkpOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IoaSA9IDA7IGlucHV0LmF0KGkpID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGgoKSAtIDE7ICsraSkge1xuICAgIG91dHB1dCArPSBmaXJzdDtcbiAgfVxuICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIG91dHB1dCArPSBhbHBoYWJldFtkaWdpdHNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiIsIi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnM6IHtcbiAgICB1c2VQdXJlSmF2YVNjcmlwdDogZmFsc2VcbiAgfVxufTtcbiIsIi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlIG1lc3NhZ2UgZGlnZXN0cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAyMDExLTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1kID0gZm9yZ2UubWQgfHwge307XG5mb3JnZS5tZC5hbGdvcml0aG1zID0gZm9yZ2UubWQuYWxnb3JpdGhtcyB8fCB7fTtcbiIsIi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMTYwLWJpdCBkaWdlc3QgKFNIQS0xKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgc2hhMSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2Uuc2hhMSA9IGZvcmdlLnNoYTEgfHwge307XG5mb3JnZS5tZC5zaGExID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5zaGExID0gc2hhMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gYSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKi9cbnNoYTEuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGRvIGluaXRpYWxpemF0aW9uIGFzIG5lY2Vzc2FyeVxuICBpZighX2luaXRpYWxpemVkKSB7XG4gICAgX2luaXQoKTtcbiAgfVxuXG4gIC8vIFNIQS0xIHN0YXRlIGNvbnRhaW5zIGZpdmUgMzItYml0IGludGVnZXJzXG4gIHZhciBfc3RhdGUgPSBudWxsO1xuXG4gIC8vIGlucHV0IGJ1ZmZlclxuICB2YXIgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyB1c2VkIGZvciB3b3JkIHN0b3JhZ2VcbiAgdmFyIF93ID0gbmV3IEFycmF5KDgwKTtcblxuICAvLyBtZXNzYWdlIGRpZ2VzdCBvYmplY3RcbiAgdmFyIG1kID0ge1xuICAgIGFsZ29yaXRobTogJ3NoYTEnLFxuICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICBkaWdlc3RMZW5ndGg6IDIwLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogOFxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoNjQgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDY0ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX3N0YXRlID0ge1xuICAgICAgaDA6IDB4Njc0NTIzMDEsXG4gICAgICBoMTogMHhFRkNEQUI4OSxcbiAgICAgIGgyOiAweDk4QkFEQ0ZFLFxuICAgICAgaDM6IDB4MTAzMjU0NzYsXG4gICAgICBoNDogMHhDM0QyRTFGMFxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtMSBwYWRkaW5nLiBUaGVuIHdlIGRvIHRoZSBmaW5hbCB1cGRhdGVcbiAgICBvbiBhIGNvcHkgb2YgdGhlIHN0YXRlIHNvIHRoYXQgaWYgdGhlIHVzZXIgd2FudHMgdG8gZ2V0XG4gICAgaW50ZXJtZWRpYXRlIGRpZ2VzdHMgdGhleSBjYW4gZG8gc28uICovXG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBieXRlcyB0aGF0IG11c3QgYmUgYWRkZWQgdG8gdGhlIG1lc3NhZ2VcbiAgICB0byBlbnN1cmUgaXRzIGxlbmd0aCBpcyBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIuIEluIG90aGVyIHdvcmRzLFxuICAgIHRoZSBkYXRhIHRvIGJlIGRpZ2VzdGVkIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA1MTIgYml0cyAob3IgMTI4IGJ5dGVzKS5cbiAgICBUaGlzIGRhdGEgaW5jbHVkZXMgdGhlIG1lc3NhZ2UsIHNvbWUgcGFkZGluZywgYW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgbWVzc2FnZS4gU2luY2UgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZSB3aWxsIGJlIGVuY29kZWQgYXMgOCBieXRlcyAoNjRcbiAgICBiaXRzKSwgdGhhdCBtZWFucyB0aGF0IHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGRhdGEgbXVzdCBoYXZlIDU2IGJ5dGVzXG4gICAgKDQ0OCBiaXRzKSBvZiBtZXNzYWdlIGFuZCBwYWRkaW5nLiBUaGVyZWZvcmUsIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2VcbiAgICBwbHVzIHRoZSBwYWRkaW5nIG11c3QgYmUgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyIGJlY2F1c2VcbiAgICA1MTIgLSAxMjggPSA0NDguXG5cbiAgICBJbiBvcmRlciB0byBmaWxsIHVwIHRoZSBtZXNzYWdlIGxlbmd0aCBpdCBtdXN0IGJlIGZpbGxlZCB3aXRoXG4gICAgcGFkZGluZyB0aGF0IGJlZ2lucyB3aXRoIDEgYml0IGZvbGxvd2VkIGJ5IGFsbCAwIGJpdHMuIFBhZGRpbmdcbiAgICBtdXN0ICphbHdheXMqIGJlIHByZXNlbnQsIHNvIGlmIHRoZSBtZXNzYWdlIGxlbmd0aCBpcyBhbHJlYWR5XG4gICAgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLCB0aGVuIDUxMiBwYWRkaW5nIGJpdHMgbXVzdCBiZSBhZGRlZC4gKi9cblxuICAgIHZhciBmaW5hbEJsb2NrID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9pbnB1dC5ieXRlcygpKTtcblxuICAgIC8vIGNvbXB1dGUgcmVtYWluaW5nIHNpemUgdG8gYmUgZGlnZXN0ZWQgKGluY2x1ZGUgbWVzc2FnZSBsZW5ndGggc2l6ZSlcbiAgICB2YXIgcmVtYWluaW5nID0gKFxuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMV0gK1xuICAgICAgbWQubWVzc2FnZUxlbmd0aFNpemUpO1xuXG4gICAgLy8gYWRkIHBhZGRpbmcgZm9yIG92ZXJmbG93IGJsb2NrU2l6ZSAtIG92ZXJmbG93XG4gICAgLy8gX3BhZGRpbmcgc3RhcnRzIHdpdGggMSBieXRlIHdpdGggZmlyc3QgYml0IGlzIHNldCAoYnl0ZSB2YWx1ZSAxMjgpLCB0aGVuXG4gICAgLy8gdGhlcmUgbWF5IGJlIHVwIHRvIChibG9ja1NpemUgLSAxKSBvdGhlciBwYWQgYnl0ZXNcbiAgICB2YXIgb3ZlcmZsb3cgPSByZW1haW5pbmcgJiAobWQuYmxvY2tMZW5ndGggLSAxKTtcbiAgICBmaW5hbEJsb2NrLnB1dEJ5dGVzKF9wYWRkaW5nLnN1YnN0cigwLCBtZC5ibG9ja0xlbmd0aCAtIG92ZXJmbG93KSk7XG5cbiAgICAvLyBzZXJpYWxpemUgbWVzc2FnZSBsZW5ndGggaW4gYml0cyBpbiBiaWctZW5kaWFuIG9yZGVyOyBzaW5jZSBsZW5ndGhcbiAgICAvLyBpcyBzdG9yZWQgaW4gYnl0ZXMgd2UgbXVsdGlwbHkgYnkgOCBhbmQgYWRkIGNhcnJ5IGZyb20gbmV4dCBpbnRcbiAgICB2YXIgbmV4dCwgY2Fycnk7XG4gICAgdmFyIGJpdHMgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFswXSAqIDg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgbmV4dCA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2kgKyAxXSAqIDg7XG4gICAgICBjYXJyeSA9IChuZXh0IC8gMHgxMDAwMDAwMDApID4+PiAwO1xuICAgICAgYml0cyArPSBjYXJyeTtcbiAgICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyA+Pj4gMCk7XG4gICAgICBiaXRzID0gbmV4dCA+Pj4gMDtcbiAgICB9XG4gICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzKTtcblxuICAgIHZhciBzMiA9IHtcbiAgICAgIGgwOiBfc3RhdGUuaDAsXG4gICAgICBoMTogX3N0YXRlLmgxLFxuICAgICAgaDI6IF9zdGF0ZS5oMixcbiAgICAgIGgzOiBfc3RhdGUuaDMsXG4gICAgICBoNDogX3N0YXRlLmg0XG4gICAgfTtcbiAgICBfdXBkYXRlKHMyLCBfdywgZmluYWxCbG9jayk7XG4gICAgdmFyIHJ2YWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDApO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDEpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDIpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDMpO1xuICAgIHJ2YWwucHV0SW50MzIoczIuaDQpO1xuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIHJldHVybiBtZDtcbn07XG5cbi8vIHNoYS0xIHBhZGRpbmcgYnl0ZXMgbm90IGluaXRpYWxpemVkIHlldFxudmFyIF9wYWRkaW5nID0gbnVsbDtcbnZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS0xIHN0YXRlIHdpdGggdGhlIGdpdmVuIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzIHRoZSBTSEEtMSBzdGF0ZSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gdyB0aGUgYXJyYXkgdG8gdXNlIHRvIHN0b3JlIHdvcmRzLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byB1cGRhdGUgd2l0aC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAvLyBjb25zdW1lIDUxMiBiaXQgKDY0IGJ5dGUpIGNodW5rc1xuICB2YXIgdCwgYSwgYiwgYywgZCwgZSwgZiwgaTtcbiAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aCgpO1xuICB3aGlsZShsZW4gPj0gNjQpIHtcbiAgICAvLyB0aGUgdyBhcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHNpeHRlZW4gMzItYml0IGJpZy1lbmRpYW4gd29yZHNcbiAgICAvLyBhbmQgdGhlbiBleHRlbmRlZCBpbnRvIDgwIDMyLWJpdCB3b3JkcyBhY2NvcmRpbmcgdG8gU0hBLTEgYWxnb3JpdGhtXG4gICAgLy8gYW5kIGZvciAzMi03OSB1c2luZyBNYXggTG9ja3R5dWtoaW4ncyBvcHRpbWl6YXRpb25cblxuICAgIC8vIGluaXRpYWxpemUgaGFzaCB2YWx1ZSBmb3IgdGhpcyBjaHVua1xuICAgIGEgPSBzLmgwO1xuICAgIGIgPSBzLmgxO1xuICAgIGMgPSBzLmgyO1xuICAgIGQgPSBzLmgzO1xuICAgIGUgPSBzLmg0O1xuXG4gICAgLy8gcm91bmQgMVxuICAgIGZvcihpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHQgPSBieXRlcy5nZXRJbnQzMigpO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NUE4Mjc5OTkgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDIwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gM10gXiB3W2kgLSA4XSBeIHdbaSAtIDE0XSBeIHdbaSAtIDE2XSk7XG4gICAgICB0ID0gKHQgPDwgMSkgfCAodCA+Pj4gMzEpO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NUE4Mjc5OTkgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgLy8gcm91bmQgMlxuICAgIGZvcig7IGkgPCAzMjsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDNdIF4gd1tpIC0gOF0gXiB3W2kgLSAxNF0gXiB3W2kgLSAxNl0pO1xuICAgICAgdCA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg2RUQ5RUJBMSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICBmb3IoOyBpIDwgNDA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDZFRDlFQkExICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDNcbiAgICBmb3IoOyBpIDwgNjA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgXiBjKSk7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4OEYxQkJDREMgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgLy8gcm91bmQgNFxuICAgIGZvcig7IGkgPCA4MDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDZdIF4gd1tpIC0gMTZdIF4gd1tpIC0gMjhdIF4gd1tpIC0gMzJdKTtcbiAgICAgIHQgPSAodCA8PCAyKSB8ICh0ID4+PiAzMCk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4Q0E2MkMxRDYgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgaGFzaCBzdGF0ZVxuICAgIHMuaDAgPSAocy5oMCArIGEpIHwgMDtcbiAgICBzLmgxID0gKHMuaDEgKyBiKSB8IDA7XG4gICAgcy5oMiA9IChzLmgyICsgYykgfCAwO1xuICAgIHMuaDMgPSAocy5oMyArIGQpIHwgMDtcbiAgICBzLmg0ID0gKHMuaDQgKyBlKSB8IDA7XG5cbiAgICBsZW4gLT0gNjQ7XG4gIH1cbn1cbiIsIi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMjU2LWJpdCBkaWdlc3QgKFNIQS0yNTYpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFNlZSBGSVBTIDE4MC0yIGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBzaGEyNTYgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnNoYTI1NiA9IGZvcmdlLnNoYTI1NiB8fCB7fTtcbmZvcmdlLm1kLnNoYTI1NiA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMjU2ID0gc2hhMjU2O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTSEEtMjU2IG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICovXG5zaGEyNTYuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGRvIGluaXRpYWxpemF0aW9uIGFzIG5lY2Vzc2FyeVxuICBpZighX2luaXRpYWxpemVkKSB7XG4gICAgX2luaXQoKTtcbiAgfVxuXG4gIC8vIFNIQS0yNTYgc3RhdGUgY29udGFpbnMgZWlnaHQgMzItYml0IGludGVnZXJzXG4gIHZhciBfc3RhdGUgPSBudWxsO1xuXG4gIC8vIGlucHV0IGJ1ZmZlclxuICB2YXIgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyB1c2VkIGZvciB3b3JkIHN0b3JhZ2VcbiAgdmFyIF93ID0gbmV3IEFycmF5KDY0KTtcblxuICAvLyBtZXNzYWdlIGRpZ2VzdCBvYmplY3RcbiAgdmFyIG1kID0ge1xuICAgIGFsZ29yaXRobTogJ3NoYTI1NicsXG4gICAgYmxvY2tMZW5ndGg6IDY0LFxuICAgIGRpZ2VzdExlbmd0aDogMzIsXG4gICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgbWVzc2FnZUxlbmd0aDogMCxcbiAgICAvLyB0cnVlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgLy8gc2l6ZSBvZiBtZXNzYWdlIGxlbmd0aCBpbiBieXRlc1xuICAgIG1lc3NhZ2VMZW5ndGhTaXplOiA4XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdXAgdG8gNTYtYml0IG1lc3NhZ2UgbGVuZ3RoIGZvciBjb252ZW5pZW5jZVxuICAgIG1kLm1lc3NhZ2VMZW5ndGggPSAwO1xuXG4gICAgLy8gZnVsbCBtZXNzYWdlIGxlbmd0aCAoc2V0IG1kLm1lc3NhZ2VMZW5ndGg2NCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkpXG4gICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoNjQgPSBbXTtcbiAgICB2YXIgaW50MzJzID0gbWQubWVzc2FnZUxlbmd0aFNpemUgLyA0O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGgucHVzaCgwKTtcbiAgICB9XG4gICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBfc3RhdGUgPSB7XG4gICAgICBoMDogMHg2QTA5RTY2NyxcbiAgICAgIGgxOiAweEJCNjdBRTg1LFxuICAgICAgaDI6IDB4M0M2RUYzNzIsXG4gICAgICBoMzogMHhBNTRGRjUzQSxcbiAgICAgIGg0OiAweDUxMEU1MjdGLFxuICAgICAgaDU6IDB4OUIwNTY4OEMsXG4gICAgICBoNjogMHgxRjgzRDlBQixcbiAgICAgIGg3OiAweDVCRTBDRDE5XG4gICAgfTtcbiAgICByZXR1cm4gbWQ7XG4gIH07XG4gIC8vIHN0YXJ0IGRpZ2VzdCBhdXRvbWF0aWNhbGx5IGZvciBmaXJzdCB0aW1lXG4gIG1kLnN0YXJ0KCk7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGRpZ2VzdCB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGlucHV0LiBUaGUgZ2l2ZW4gaW5wdXQgY2FuXG4gICAqIHRyZWF0ZWQgYXMgcmF3IGlucHV0IChubyBlbmNvZGluZyB3aWxsIGJlIGFwcGxpZWQpIG9yIGFuIGVuY29kaW5nIG9mXG4gICAqICd1dGY4JyBtYXliZSBnaXZlbiB0byBlbmNvZGUgdGhlIGlucHV0IHVzaW5nIFVURi04LlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIHRoZSBtZXNzYWdlIGlucHV0IHRvIHVwZGF0ZSB3aXRoLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnVwZGF0ZSA9IGZ1bmN0aW9uKG1zZywgZW5jb2RpbmcpIHtcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICBtc2cgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgobXNnKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWVzc2FnZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gbXNnLmxlbmd0aDtcbiAgICBtZC5tZXNzYWdlTGVuZ3RoICs9IGxlbjtcbiAgICBsZW4gPSBbKGxlbiAvIDB4MTAwMDAwMDAwKSA+Pj4gMCwgbGVuID4+PiAwXTtcbiAgICBmb3IodmFyIGkgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gKz0gbGVuWzFdO1xuICAgICAgbGVuWzFdID0gbGVuWzBdICsgKChtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID4+PiAwO1xuICAgICAgbGVuWzBdID0gKChsZW5bMV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgIH1cblxuICAgIC8vIGFkZCBieXRlcyB0byBpbnB1dCBidWZmZXJcbiAgICBfaW5wdXQucHV0Qnl0ZXMobXNnKTtcblxuICAgIC8vIHByb2Nlc3MgYnl0ZXNcbiAgICBfdXBkYXRlKF9zdGF0ZSwgX3csIF9pbnB1dCk7XG5cbiAgICAvLyBjb21wYWN0IGlucHV0IGJ1ZmZlciBldmVyeSAySyBvciBpZiBlbXB0eVxuICAgIGlmKF9pbnB1dC5yZWFkID4gMjA0OCB8fCBfaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIF9pbnB1dC5jb21wYWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgKi9cbiAgbWQuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgLyogTm90ZTogSGVyZSB3ZSBjb3B5IHRoZSByZW1haW5pbmcgYnl0ZXMgaW4gdGhlIGlucHV0IGJ1ZmZlciBhbmRcbiAgICBhZGQgdGhlIGFwcHJvcHJpYXRlIFNIQS0yNTYgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDggYnl0ZXMgKDY0XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSA1NiBieXRlc1xuICAgICg0NDggYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiBiZWNhdXNlXG4gICAgNTEyIC0gMTI4ID0gNDQ4LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiwgdGhlbiA1MTIgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeSBmcm9tIG5leHQgaW50XG4gICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgY2FycnkgPSAobmV4dCAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgYml0cyA9IG5leHQgPj4+IDA7XG4gICAgfVxuICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG5cbiAgICB2YXIgczIgPSB7XG4gICAgICBoMDogX3N0YXRlLmgwLFxuICAgICAgaDE6IF9zdGF0ZS5oMSxcbiAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICBoMzogX3N0YXRlLmgzLFxuICAgICAgaDQ6IF9zdGF0ZS5oNCxcbiAgICAgIGg1OiBfc3RhdGUuaDUsXG4gICAgICBoNjogX3N0YXRlLmg2LFxuICAgICAgaDc6IF9zdGF0ZS5oN1xuICAgIH07XG4gICAgX3VwZGF0ZShzMiwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgxKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgyKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg0KTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg1KTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg2KTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg3KTtcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtMjU2IHBhZGRpbmcgYnl0ZXMgbm90IGluaXRpYWxpemVkIHlldFxudmFyIF9wYWRkaW5nID0gbnVsbDtcbnZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLy8gdGFibGUgb2YgY29uc3RhbnRzXG52YXIgX2sgPSBudWxsO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjb25zdGFudCB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBjcmVhdGUgcGFkZGluZ1xuICBfcGFkZGluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KTtcbiAgX3BhZGRpbmcgKz0gZm9yZ2UudXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCksIDY0KTtcblxuICAvLyBjcmVhdGUgSyB0YWJsZSBmb3IgU0hBLTI1NlxuICBfayA9IFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuICAgIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMyxcbiAgICAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gICAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuICAgIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMyxcbiAgICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gICAgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuICAgIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcbiAgICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXTtcblxuICAvLyBub3cgaW5pdGlhbGl6ZWRcbiAgX2luaXRpYWxpemVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgU0hBLTI1NiBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gcyB0aGUgU0hBLTI1NiBzdGF0ZSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gdyB0aGUgYXJyYXkgdG8gdXNlIHRvIHN0b3JlIHdvcmRzLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byB1cGRhdGUgd2l0aC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZShzLCB3LCBieXRlcykge1xuICAvLyBjb25zdW1lIDUxMiBiaXQgKDY0IGJ5dGUpIGNodW5rc1xuICB2YXIgdDEsIHQyLCBzMCwgczEsIGNoLCBtYWosIGksIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGg7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDY0KSB7XG4gICAgLy8gdGhlIHcgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBzaXh0ZWVuIDMyLWJpdCBiaWctZW5kaWFuIHdvcmRzXG4gICAgLy8gYW5kIHRoZW4gZXh0ZW5kZWQgaW50byA2NCAzMi1iaXQgd29yZHMgYWNjb3JkaW5nIHRvIFNIQS0yNTZcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB3W2ldID0gYnl0ZXMuZ2V0SW50MzIoKTtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIC8vIFhPUiB3b3JkIDIgd29yZHMgYWdvIHJvdCByaWdodCAxNywgcm90IHJpZ2h0IDE5LCBzaGZ0IHJpZ2h0IDEwXG4gICAgICB0MSA9IHdbaSAtIDJdO1xuICAgICAgdDEgPVxuICAgICAgICAoKHQxID4+PiAxNykgfCAodDEgPDwgMTUpKSBeXG4gICAgICAgICgodDEgPj4+IDE5KSB8ICh0MSA8PCAxMykpIF5cbiAgICAgICAgKHQxID4+PiAxMCk7XG4gICAgICAvLyBYT1Igd29yZCAxNSB3b3JkcyBhZ28gcm90IHJpZ2h0IDcsIHJvdCByaWdodCAxOCwgc2hmdCByaWdodCAzXG4gICAgICB0MiA9IHdbaSAtIDE1XTtcbiAgICAgIHQyID1cbiAgICAgICAgKCh0MiA+Pj4gNykgfCAodDIgPDwgMjUpKSBeXG4gICAgICAgICgodDIgPj4+IDE4KSB8ICh0MiA8PCAxNCkpIF5cbiAgICAgICAgKHQyID4+PiAzKTtcbiAgICAgIC8vIHN1bSh0MSwgd29yZCA3IGFnbywgdDIsIHdvcmQgMTYgYWdvKSBtb2R1bG8gMl4zMlxuICAgICAgd1tpXSA9ICh0MSArIHdbaSAtIDddICsgdDIgKyB3W2kgLSAxNl0pIHwgMDtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhID0gcy5oMDtcbiAgICBiID0gcy5oMTtcbiAgICBjID0gcy5oMjtcbiAgICBkID0gcy5oMztcbiAgICBlID0gcy5oNDtcbiAgICBmID0gcy5oNTtcbiAgICBnID0gcy5oNjtcbiAgICBoID0gcy5oNztcblxuICAgIC8vIHJvdW5kIGZ1bmN0aW9uXG4gICAgZm9yKGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgLy8gU3VtMShlKVxuICAgICAgczEgPVxuICAgICAgICAoKGUgPj4+IDYpIHwgKGUgPDwgMjYpKSBeXG4gICAgICAgICgoZSA+Pj4gMTEpIHwgKGUgPDwgMjEpKSBeXG4gICAgICAgICgoZSA+Pj4gMjUpIHwgKGUgPDwgNykpO1xuICAgICAgLy8gQ2goZSwgZiwgZykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBjaCA9IGcgXiAoZSAmIChmIF4gZykpO1xuICAgICAgLy8gU3VtMChhKVxuICAgICAgczAgPVxuICAgICAgICAoKGEgPj4+IDIpIHwgKGEgPDwgMzApKSBeXG4gICAgICAgICgoYSA+Pj4gMTMpIHwgKGEgPDwgMTkpKSBeXG4gICAgICAgICgoYSA+Pj4gMjIpIHwgKGEgPDwgMTApKTtcbiAgICAgIC8vIE1haihhLCBiLCBjKSAob3B0aW1pemVkIHRoZSBzYW1lIHdheSBhcyBTSEEtMSlcbiAgICAgIG1haiA9IChhICYgYikgfCAoYyAmIChhIF4gYikpO1xuXG4gICAgICAvLyBtYWluIGFsZ29yaXRobVxuICAgICAgdDEgPSBoICsgczEgKyBjaCArIF9rW2ldICsgd1tpXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBoID0gZztcbiAgICAgIGcgPSBmO1xuICAgICAgZiA9IGU7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIC8vIGNhbid0IHRydW5jYXRlIHdpdGggYHwgMGBcbiAgICAgIGUgPSAoZCArIHQxKSA+Pj4gMDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IGI7XG4gICAgICBiID0gYTtcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgLy8gY2FuJ3QgdHJ1bmNhdGUgd2l0aCBgfCAwYFxuICAgICAgYSA9ICh0MSArIHQyKSA+Pj4gMDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgaGFzaCBzdGF0ZVxuICAgIHMuaDAgPSAocy5oMCArIGEpIHwgMDtcbiAgICBzLmgxID0gKHMuaDEgKyBiKSB8IDA7XG4gICAgcy5oMiA9IChzLmgyICsgYykgfCAwO1xuICAgIHMuaDMgPSAocy5oMyArIGQpIHwgMDtcbiAgICBzLmg0ID0gKHMuaDQgKyBlKSB8IDA7XG4gICAgcy5oNSA9IChzLmg1ICsgZikgfCAwO1xuICAgIHMuaDYgPSAocy5oNiArIGcpIHwgMDtcbiAgICBzLmg3ID0gKHMuaDcgKyBoKSB8IDA7XG4gICAgbGVuIC09IDY0O1xuICB9XG59XG4iLCIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3ZWIgYXBwbGljYXRpb25zLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTggRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xudmFyIGJhc2VOID0gcmVxdWlyZSgnLi9iYXNlTicpO1xuXG4vKiBVdGlsaXRpZXMgQVBJICovXG52YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UudXRpbCA9IGZvcmdlLnV0aWwgfHwge307XG5cbi8vIGRlZmluZSBzZXRJbW1lZGlhdGUgYW5kIG5leHRUaWNrXG4oZnVuY3Rpb24oKSB7XG4gIC8vIHVzZSBuYXRpdmUgbmV4dFRpY2sgKHVubGVzcyB3ZSdyZSBpbiB3ZWJwYWNrKVxuICAvLyB3ZWJwYWNrIChvciBiZXR0ZXIgbm9kZS1saWJzLWJyb3dzZXIgcG9seWZpbGwpIHNldHMgcHJvY2Vzcy5icm93c2VyLlxuICAvLyB0aGlzIHdheSB3ZSBjYW4gZGV0ZWN0IHdlYnBhY2sgcHJvcGVybHlcbiAgaWYodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MubmV4dFRpY2sgJiYgIXByb2Nlc3MuYnJvd3Nlcikge1xuICAgIHV0aWwubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgIGlmKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwb2x5ZmlsbCBzZXRJbW1lZGlhdGUgd2l0aCBuZXh0VGljaywgb2xkZXIgdmVyc2lvbnMgb2Ygbm9kZVxuICAgICAgLy8gKHRob3NlIHcvbyBzZXRJbW1lZGlhdGUpIHdvbid0IHRvdGFsbHkgc3RhcnZlIElPXG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHV0aWwubmV4dFRpY2s7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHBvbHlmaWxsIG5leHRUaWNrIHdpdGggbmF0aXZlIHNldEltbWVkaWF0ZVxuICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXRpbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNldEltbWVkaWF0ZS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7IH07XG4gICAgdXRpbC5uZXh0VGljayA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qIE5vdGU6IEEgcG9seWZpbGwgdXBncmFkZSBwYXR0ZXJuIGlzIHVzZWQgaGVyZSB0byBhbGxvdyBjb21iaW5pbmdcbiAgcG9seWZpbGxzLiBGb3IgZXhhbXBsZSwgTXV0YXRpb25PYnNlcnZlciBpcyBmYXN0LCBidXQgYmxvY2tzIFVJIHVwZGF0ZXMsXG4gIHNvIGl0IG5lZWRzIHRvIGFsbG93IFVJIHVwZGF0ZXMgcGVyaW9kaWNhbGx5LCBzbyBpdCBmYWxscyBiYWNrIG9uXG4gIHBvc3RNZXNzYWdlIG9yIHNldFRpbWVvdXQuICovXG5cbiAgLy8gcG9seWZpbGwgd2l0aCBzZXRUaW1lb3V0XG4gIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgfTtcblxuICAvLyB1cGdyYWRlIHBvbHlmaWxsIHRvIHVzZSBwb3N0TWVzc2FnZVxuICBpZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgbXNnID0gJ2ZvcmdlLnNldEltbWVkaWF0ZSc7XG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIC8vIG9ubHkgc2VuZCBtZXNzYWdlIHdoZW4gb25lIGhhc24ndCBiZWVuIHNlbnQgaW5cbiAgICAgIC8vIHRoZSBjdXJyZW50IHR1cm4gb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgIGlmKGNhbGxiYWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1zZywgJyonKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGlmKGV2ZW50LnNvdXJjZSA9PT0gd2luZG93ICYmIGV2ZW50LmRhdGEgPT09IG1zZykge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmFyIGNvcHkgPSBjYWxsYmFja3Muc2xpY2UoKTtcbiAgICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgIGNvcHkuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIsIHRydWUpO1xuICB9XG5cbiAgLy8gdXBncmFkZSBwb2x5ZmlsbCB0byB1c2UgTXV0YXRpb25PYnNlcnZlclxuICBpZih0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBwb2x5ZmlsbCB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgYXR0ciA9IHRydWU7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvcHkuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSkub2JzZXJ2ZShkaXYsIHthdHRyaWJ1dGVzOiB0cnVlfSk7XG4gICAgdmFyIG9sZFNldEltbWVkaWF0ZSA9IHV0aWwuc2V0SW1tZWRpYXRlO1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGlmKERhdGUubm93KCkgLSBub3cgPiAxNSkge1xuICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBvbGRTZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAvLyBvbmx5IHRyaWdnZXIgb2JzZXJ2ZXIgd2hlbiBpdCBoYXNuJ3QgYmVlbiB0cmlnZ2VyZWQgaW5cbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgdHVybiBvZiB0aGUgZXZlbnQgbG9vcFxuICAgICAgICBpZihjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYScsIGF0dHIgPSAhYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdXRpbC5uZXh0VGljayA9IHV0aWwuc2V0SW1tZWRpYXRlO1xufSkoKTtcblxuLy8gY2hlY2sgaWYgcnVubmluZyB1bmRlciBOb2RlLmpzXG51dGlsLmlzTm9kZWpzID1cbiAgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuXG5cbi8vICdzZWxmJyB3aWxsIGFsc28gd29yayBpbiBXZWIgV29ya2VycyAoaW5zdGFuY2Ugb2YgV29ya2VyR2xvYmFsU2NvcGUpIHdoaWxlXG4vLyBpdCB3aWxsIHBvaW50IHRvIGB3aW5kb3dgIGluIHRoZSBtYWluIHRocmVhZC5cbi8vIFRvIHJlbWFpbiBjb21wYXRpYmxlIHdpdGggb2xkZXIgYnJvd3NlcnMsIHdlIGZhbGwgYmFjayB0byAnd2luZG93JyBpZiAnc2VsZidcbi8vIGlzIG5vdCBhdmFpbGFibGUuXG51dGlsLmdsb2JhbFNjb3BlID0gKGZ1bmN0aW9uKCkge1xuICBpZih1dGlsLmlzTm9kZWpzKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBzZWxmO1xufSkoKTtcblxuLy8gZGVmaW5lIGlzQXJyYXlcbnV0aWwuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJcbnV0aWwuaXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJWaWV3XG51dGlsLmlzQXJyYXlCdWZmZXJWaWV3ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAmJiB1dGlsLmlzQXJyYXlCdWZmZXIoeC5idWZmZXIpICYmIHguYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgYSBiaXRzIHBhcmFtIGlzIDgsIDE2LCAyNCwgb3IgMzIuIFVzZWQgdG8gdmFsaWRhdGUgaW5wdXQgZm9yXG4gKiBhbGdvcml0aG1zIHdoZXJlIGJpdCBtYW5pcHVsYXRpb24sIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIGFuZC9vciBhbGdvcml0aG1cbiAqIGRlc2lnbiBvbmx5IGFsbG93IGZvciBieXRlIG9wZXJhdGlvbnMgb2YgYSBsaW1pdGVkIHNpemUuXG4gKlxuICogQHBhcmFtIG4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogVGhyb3cgRXJyb3IgaWYgbiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCaXRzUGFyYW0obikge1xuICBpZighKG4gPT09IDggfHwgbiA9PT0gMTYgfHwgbiA9PT0gMjQgfHwgbiA9PT0gMzIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IDgsIDE2LCAyNCwgb3IgMzIgYml0cyBzdXBwb3J0ZWQ6ICcgKyBuKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBzZXQgQnl0ZUJ1ZmZlciB0byBiZXN0IGF2YWlsYWJsZSBiYWNraW5nXG51dGlsLkJ5dGVCdWZmZXIgPSBCeXRlU3RyaW5nQnVmZmVyO1xuXG4vKiogQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBmb3IgYSBiaW5hcnkgc3RyaW5nIGJhY2tlZCBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gW2JdIHRoZSBieXRlcyB0byB3cmFwIChlaXRoZXIgZW5jb2RlZCBhcyBzdHJpbmcsIG9uZSBieXRlIHBlclxuICogICAgICAgICAgY2hhcmFjdGVyLCBvciBhcyBhbiBBcnJheUJ1ZmZlciBvciBUeXBlZCBBcnJheSkuXG4gKi9cbmZ1bmN0aW9uIEJ5dGVTdHJpbmdCdWZmZXIoYikge1xuICAvLyBUT0RPOiB1cGRhdGUgdG8gbWF0Y2ggRGF0YUJ1ZmZlciBBUElcblxuICAvLyB0aGUgZGF0YSBpbiB0aGlzIGJ1ZmZlclxuICB0aGlzLmRhdGEgPSAnJztcbiAgLy8gdGhlIHBvaW50ZXIgZm9yIHJlYWRpbmcgZnJvbSB0aGlzIGJ1ZmZlclxuICB0aGlzLnJlYWQgPSAwO1xuXG4gIGlmKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuZGF0YSA9IGI7XG4gIH0gZWxzZSBpZih1dGlsLmlzQXJyYXlCdWZmZXIoYikgfHwgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhiKSkge1xuICAgIGlmKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGIgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb252ZXJ0IG5hdGl2ZSBidWZmZXIgdG8gZm9yZ2UgYnVmZmVyXG4gICAgICAvLyBGSVhNRTogc3VwcG9ydCBuYXRpdmUgYnVmZmVycyBpbnRlcm5hbGx5IGluc3RlYWRcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhpcy5wdXRCeXRlKGFycltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihiIGluc3RhbmNlb2YgQnl0ZVN0cmluZ0J1ZmZlciB8fFxuICAgICh0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIuZGF0YSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgYi5yZWFkID09PSAnbnVtYmVyJykpIHtcbiAgICAvLyBjb3B5IGV4aXN0aW5nIGJ1ZmZlclxuICAgIHRoaXMuZGF0YSA9IGIuZGF0YTtcbiAgICB0aGlzLnJlYWQgPSBiLnJlYWQ7XG4gIH1cblxuICAvLyB1c2VkIGZvciB2OCBvcHRpbWl6YXRpb25cbiAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xufVxudXRpbC5CeXRlU3RyaW5nQnVmZmVyID0gQnl0ZVN0cmluZ0J1ZmZlcjtcblxuLyogTm90ZTogVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gZm9yIFY4LWJhc2VkIGJyb3dzZXJzLiBXaGVuIFY4IGNvbmNhdGVuYXRlc1xuICBhIHN0cmluZywgdGhlIHN0cmluZ3MgYXJlIG9ubHkgam9pbmVkIGxvZ2ljYWxseSB1c2luZyBhIFwiY29ucyBzdHJpbmdcIiBvclxuICBcImNvbnN0cnVjdGVkL2NvbmNhdGVuYXRlZCBzdHJpbmdcIi4gVGhlc2UgY29udGFpbmVycyBrZWVwIHJlZmVyZW5jZXMgdG8gb25lXG4gIGFub3RoZXIgYW5kIGNhbiByZXN1bHQgaW4gdmVyeSBsYXJnZSBtZW1vcnkgdXNhZ2UuIEZvciBleGFtcGxlLCBpZiBhIDJNQlxuICBzdHJpbmcgaXMgY29uc3RydWN0ZWQgYnkgY29uY2F0ZW5hdGluZyA0IGJ5dGVzIHRvZ2V0aGVyIGF0IGEgdGltZSwgdGhlXG4gIG1lbW9yeSB1c2FnZSB3aWxsIGJlIH40NE1COyBzbyB+MjJ4IGluY3JlYXNlLiBUaGUgc3RyaW5ncyBhcmUgb25seSBqb2luZWRcbiAgdG9nZXRoZXIgd2hlbiBhbiBvcGVyYXRpb24gcmVxdWlyaW5nIHRoZWlyIGpvaW5pbmcgdGFrZXMgcGxhY2UsIHN1Y2ggYXNcbiAgc3Vic3RyKCkuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYWRkaW5nIGRhdGEgdG8gdGhpcyBidWZmZXIgdG8gZW5zdXJlXG4gIHRoZXNlIHR5cGVzIG9mIHN0cmluZ3MgYXJlIHBlcmlvZGljYWxseSBqb2luZWQgdG8gcmVkdWNlIHRoZSBtZW1vcnlcbiAgZm9vdHByaW50LiAqL1xudmFyIF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCA9IDQwOTY7XG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nID0gZnVuY3Rpb24oeCkge1xuICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCArPSB4O1xuICBpZih0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCA+IF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCkge1xuICAgIC8vIHRoaXMgc3Vic3RyKCkgc2hvdWxkIGNhdXNlIHRoZSBjb25zdHJ1Y3RlZCBzdHJpbmcgdG8gam9pblxuICAgIHRoaXMuZGF0YS5zdWJzdHIoMCwgMSk7XG4gICAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShiKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyIE4gdGltZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyBvZiB2YWx1ZSBiIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgYiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gIHZhciBkID0gdGhpcy5kYXRhO1xuICB3aGlsZShuID4gMCkge1xuICAgIGlmKG4gJiAxKSB7XG4gICAgICBkICs9IGI7XG4gICAgfVxuICAgIG4gPj4+PSAxO1xuICAgIGlmKG4gPiAwKSB7XG4gICAgICBiICs9IGI7XG4gICAgfVxuICB9XG4gIHRoaXMuZGF0YSA9IGQ7XG4gIHRoaXMuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcobik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgKGFzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nKSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHRoaXMuZGF0YSArPSBieXRlcztcbiAgdGhpcy5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyhieXRlcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIFVURi0xNiBlbmNvZGVkIHN0cmluZyBpbnRvIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXModXRpbC5lbmNvZGVVdGY4KHN0cikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMTYtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMTYtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNiA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzIgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMTYtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMTYtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNkxlID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDI0TGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDMyTGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGFuIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIGJ5dGVzID0gJyc7XG4gIGRvIHtcbiAgICBuIC09IDg7XG4gICAgYnl0ZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaSA+PiBuKSAmIDB4RkYpO1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnl0ZXMpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci4gVHdvJ3NcbiAqIGNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24gaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRTaWduZWRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIC8vIHB1dEludCBjaGVja3MgblxuICBpZihpIDwgMCkge1xuICAgIGkgKz0gMiA8PCAobiAtIDEpO1xuICB9XG4gIHJldHVybiB0aGlzLnB1dEludChpLCBuKTtcbn07XG5cbi8qKlxuICogUHV0cyB0aGUgZ2l2ZW4gYnVmZmVyIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHB1dCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKGJ1ZmZlci5nZXRCeXRlcygpKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgZnJvbSB0aGlzIGJ1ZmZlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSAxLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKyspO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSk7XG4gIHRoaXMucmVhZCArPSAyO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQyNCBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDMuXG4gKlxuICogQHJldHVybiB0aGUgdWludDI0LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDI0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpKTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDMyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgPDwgMjQgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAzKSk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQxNiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDIuXG4gKlxuICogQHJldHVybiB0aGUgdWludDE2LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDE2TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCk7XG4gIHRoaXMucmVhZCArPSAyO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQyNCBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDMuXG4gKlxuICogQHJldHVybiB0aGUgdWludDI0LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDI0TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikgPDwgMTYpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzJMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMykgPDwgMjQpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZVxuICogcmVhZCBwb2ludGVyIGJ5IGNlaWwobi84KS5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50ID0gZnVuY3Rpb24obikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHZhciBydmFsID0gMDtcbiAgZG8ge1xuICAgIC8vIFRPRE86IFVzZSAocnZhbCAqIDB4MTAwKSBpZiBhZGRpbmcgc3VwcG9ydCBmb3IgMzMgdG8gNTMgYml0cy5cbiAgICBydmFsID0gKHJ2YWwgPDwgOCkgKyB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyk7XG4gICAgbiAtPSA4O1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIsIHVzaW5nXG4gKiB0d28ncyBjb21wbGVtZW50LCBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldFNpZ25lZEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgLy8gZ2V0SW50IGNoZWNrcyBuXG4gIHZhciB4ID0gdGhpcy5nZXRJbnQobik7XG4gIHZhciBtYXggPSAyIDw8IChuIC0gMik7XG4gIGlmKHggPj0gbWF4KSB7XG4gICAgeCAtPSBtYXggPDwgMTtcbiAgfVxuICByZXR1cm4geDtcbn07XG5cbi8qKlxuICogUmVhZHMgYnl0ZXMgb3V0IGFzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIGFuZCBjbGVhcnMgdGhlbSBmcm9tIHRoZVxuICogYnVmZmVyLiBOb3RlIHRoYXQgdGhlIHJlc3VsdGluZyBzdHJpbmcgaXMgYmluYXJ5IGVuY29kZWQgKGluIG5vZGUuanMgdGhpc1xuICogZW5jb2RpbmcgaXMgcmVmZXJyZWQgdG8gYXMgYGJpbmFyeWAsIGl0IGlzICpub3QqIGB1dGY4YCkuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZCwgdW5kZWZpbmVkIG9yIG51bGwgZm9yIGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIHJ2YWw7XG4gIGlmKGNvdW50KSB7XG4gICAgLy8gcmVhZCBjb3VudCBieXRlc1xuICAgIGNvdW50ID0gTWF0aC5taW4odGhpcy5sZW5ndGgoKSwgY291bnQpO1xuICAgIHJ2YWwgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCk7XG4gICAgdGhpcy5yZWFkICs9IGNvdW50O1xuICB9IGVsc2UgaWYoY291bnQgPT09IDApIHtcbiAgICBydmFsID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBhbGwgYnl0ZXMsIG9wdGltaXplIHRvIG9ubHkgY29weSB3aGVuIG5lZWRlZFxuICAgIHJ2YWwgPSAodGhpcy5yZWFkID09PSAwKSA/IHRoaXMuZGF0YSA6IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYnl0ZXMgZnJvbSB0aGlzIGJ1ZmZlciB3aXRob3V0XG4gKiBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZXQsIG9taXQgdG8gZ2V0IGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgc3RyaW5nIGZ1bGwgb2YgYmluYXJ5IGVuY29kZWQgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHJldHVybiAodHlwZW9mKGNvdW50KSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpIDpcbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgaSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuc2V0QXQgPSBmdW5jdGlvbihpLCBiKSB7XG4gIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHIoMCwgdGhpcy5yZWFkICsgaSkgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoYikgK1xuICAgIHRoaXMuZGF0YS5zdWJzdHIodGhpcy5yZWFkICsgaSArIDEpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBieXRlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHJldHVybiB0aGUgbGFzdCBieXRlLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMuZGF0YS5sZW5ndGggLSAxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY29weS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjID0gdXRpbC5jcmVhdGVCdWZmZXIodGhpcy5kYXRhKTtcbiAgYy5yZWFkID0gdGhpcy5yZWFkO1xuICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ29tcGFjdHMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMucmVhZCA+IDApIHtcbiAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLnJlYWQgPSAwO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRhdGEgPSAnJztcbiAgdGhpcy5yZWFkID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0ZW5zIHRoaXMgYnVmZmVyIGJ5IHRyaW1pbmcgYnl0ZXMgb2ZmIG9mIHRoZSBlbmQgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gdHJpbSBvZmYuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBsZW4gPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyKHRoaXMucmVhZCwgbGVuKTtcbiAgdGhpcy5yZWFkID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAnJztcbiAgZm9yKHZhciBpID0gdGhpcy5yZWFkOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGIgPSB0aGlzLmRhdGEuY2hhckNvZGVBdChpKTtcbiAgICBpZihiIDwgMTYpIHtcbiAgICAgIHJ2YWwgKz0gJzAnO1xuICAgIH1cbiAgICBydmFsICs9IGIudG9TdHJpbmcoMTYpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciB0byBhIFVURi0xNiBzdHJpbmcgKHN0YW5kYXJkIEphdmFTY3JpcHQgc3RyaW5nKS5cbiAqXG4gKiBAcmV0dXJuIGEgVVRGLTE2IHN0cmluZy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdXRpbC5kZWNvZGVVdGY4KHRoaXMuYnl0ZXMoKSk7XG59O1xuXG4vKiogRW5kIEJ1ZmZlciB3L0JpbmFyeVN0cmluZyBiYWNraW5nICovXG5cbi8qKiBCdWZmZXIgdy9VSW50OEFycmF5IGJhY2tpbmcgKi9cblxuLyoqXG4gKiBGSVhNRTogRXhwZXJpbWVudGFsLiBEbyBub3QgdXNlIHlldC5cbiAqXG4gKiBDb25zdHJ1Y3RvciBmb3IgYW4gQXJyYXlCdWZmZXItYmFja2VkIGJ5dGUgYnVmZmVyLlxuICpcbiAqIFRoZSBidWZmZXIgbWF5IGJlIGNvbnN0cnVjdGVkIGZyb20gYSBzdHJpbmcsIGFuIEFycmF5QnVmZmVyLCBEYXRhVmlldywgb3IgYVxuICogVHlwZWRBcnJheS5cbiAqXG4gKiBJZiBhIHN0cmluZyBpcyBnaXZlbiwgaXRzIGVuY29kaW5nIHNob3VsZCBiZSBwcm92aWRlZCBhcyBhbiBvcHRpb24sXG4gKiBvdGhlcndpc2UgaXQgd2lsbCBkZWZhdWx0IHRvICdiaW5hcnknLiBBICdiaW5hcnknIHN0cmluZyBpcyBlbmNvZGVkIHN1Y2hcbiAqIHRoYXQgZWFjaCBjaGFyYWN0ZXIgaXMgb25lIGJ5dGUgaW4gbGVuZ3RoIGFuZCBzaXplLlxuICpcbiAqIElmIGFuIEFycmF5QnVmZmVyLCBEYXRhVmlldywgb3IgVHlwZWRBcnJheSBpcyBnaXZlbiwgaXQgd2lsbCBiZSB1c2VkXG4gKiAqZGlyZWN0bHkqIHdpdGhvdXQgYW55IGNvcHlpbmcuIE5vdGUgdGhhdCwgaWYgYSB3cml0ZSB0byB0aGUgYnVmZmVyIHJlcXVpcmVzXG4gKiBtb3JlIHNwYWNlLCB0aGUgYnVmZmVyIHdpbGwgYWxsb2NhdGUgYSBuZXcgYmFja2luZyBBcnJheUJ1ZmZlciB0b1xuICogYWNjb21tb2RhdGUuIFRoZSBzdGFydGluZyByZWFkIGFuZCB3cml0ZSBvZmZzZXRzIGZvciB0aGUgYnVmZmVyIG1heSBiZVxuICogZ2l2ZW4gYXMgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gW2JdIHRoZSBpbml0aWFsIGJ5dGVzIGZvciB0aGlzIGJ1ZmZlci5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtyZWFkT2Zmc2V0XSB0aGUgc3RhcnRpbmcgcmVhZCBvZmZzZXQgdG8gdXNlIChkZWZhdWx0OiAwKS5cbiAqICAgICAgICAgIFt3cml0ZU9mZnNldF0gdGhlIHN0YXJ0aW5nIHdyaXRlIG9mZnNldCB0byB1c2UgKGRlZmF1bHQ6IHRoZVxuICogICAgICAgICAgICBsZW5ndGggb2YgdGhlIGZpcnN0IHBhcmFtZXRlcikuXG4gKiAgICAgICAgICBbZ3Jvd1NpemVdIHRoZSBtaW5pbXVtIGFtb3VudCwgaW4gYnl0ZXMsIHRvIGdyb3cgdGhlIGJ1ZmZlciBieSB0b1xuICogICAgICAgICAgICBhY2NvbW1vZGF0ZSB3cml0ZXMgKGRlZmF1bHQ6IDEwMjQpLlxuICogICAgICAgICAgW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgKCdiaW5hcnknLCAndXRmOCcsICd1dGYxNicsICdoZXgnKSBmb3IgdGhlXG4gKiAgICAgICAgICAgIGZpcnN0IHBhcmFtZXRlciwgaWYgaXQgaXMgYSBzdHJpbmcgKGRlZmF1bHQ6ICdiaW5hcnknKS5cbiAqL1xuZnVuY3Rpb24gRGF0YUJ1ZmZlcihiLCBvcHRpb25zKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBwb2ludGVycyBmb3IgcmVhZCBmcm9tL3dyaXRlIHRvIGJ1ZmZlclxuICB0aGlzLnJlYWQgPSBvcHRpb25zLnJlYWRPZmZzZXQgfHwgMDtcbiAgdGhpcy5ncm93U2l6ZSA9IG9wdGlvbnMuZ3Jvd1NpemUgfHwgMTAyNDtcblxuICB2YXIgaXNBcnJheUJ1ZmZlciA9IHV0aWwuaXNBcnJheUJ1ZmZlcihiKTtcbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID0gdXRpbC5pc0FycmF5QnVmZmVyVmlldyhiKTtcbiAgaWYoaXNBcnJheUJ1ZmZlciB8fCBpc0FycmF5QnVmZmVyVmlldykge1xuICAgIC8vIHVzZSBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgIGlmKGlzQXJyYXlCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogYWRqdXN0IHJlYWQvd3JpdGUgb2Zmc2V0IGJhc2VkIG9uIHRoZSB0eXBlIG9mIHZpZXdcbiAgICAgIC8vIG9yIHNwZWNpZnkgdGhhdCB0aGlzIG11c3QgYmUgZG9uZSBpbiB0aGUgb3B0aW9ucyAuLi4gdGhhdCB0aGVcbiAgICAgIC8vIG9mZnNldHMgYXJlIGJ5dGUtYmFzZWRcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICB0aGlzLndyaXRlID0gKCd3cml0ZU9mZnNldCcgaW4gb3B0aW9ucyA/XG4gICAgICBvcHRpb25zLndyaXRlT2Zmc2V0IDogdGhpcy5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGluaXRpYWxpemUgdG8gZW1wdHkgYXJyYXkgYnVmZmVyIGFuZCBhZGQgYW55IGdpdmVuIGJ5dGVzIHVzaW5nIHB1dEJ5dGVzXG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB0aGlzLndyaXRlID0gMDtcblxuICBpZihiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMucHV0Qnl0ZXMoYik7XG4gIH1cblxuICBpZignd3JpdGVPZmZzZXQnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLndyaXRlID0gb3B0aW9ucy53cml0ZU9mZnNldDtcbiAgfVxufVxudXRpbC5EYXRhQnVmZmVyID0gRGF0YUJ1ZmZlcjtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53cml0ZSAtIHRoaXMucmVhZDtcbn07XG5cbi8qKlxuICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGlzIGJ1ZmZlciBpcyBlbXB0eS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBidWZmZXIgaXMgZW1wdHksIGZhbHNlIGlmIG5vdC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCgpIDw9IDA7XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgdGhpcyBidWZmZXIgaGFzIGVub3VnaCBlbXB0eSBzcGFjZSB0byBhY2NvbW1vZGF0ZSB0aGUgZ2l2ZW4gbnVtYmVyXG4gKiBvZiBieXRlcy4gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIG1heSBiZSBnaXZlbiB0aGF0IGluZGljYXRlcyBhIG1pbmltdW1cbiAqIGFtb3VudCB0byBncm93IHRoZSBidWZmZXIgaWYgbmVjZXNzYXJ5LiBJZiB0aGUgcGFyYW1ldGVyIGlzIG5vdCBnaXZlbixcbiAqIHRoZSBidWZmZXIgd2lsbCBiZSBncm93biBieSBzb21lIHByZXZpb3VzbHktc3BlY2lmaWVkIGRlZmF1bHQgYW1vdW50XG4gKiBvciBoZXVyaXN0aWMuXG4gKlxuICogQHBhcmFtIGFtb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGFjY29tbW9kYXRlLlxuICogQHBhcmFtIFtncm93U2l6ZV0gdGhlIG1pbmltdW0gYW1vdW50LCBpbiBieXRlcywgdG8gZ3JvdyB0aGUgYnVmZmVyIGJ5IGlmXG4gKiAgICAgICAgICBuZWNlc3NhcnkuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYWNjb21tb2RhdGUgPSBmdW5jdGlvbihhbW91bnQsIGdyb3dTaXplKSB7XG4gIGlmKHRoaXMubGVuZ3RoKCkgPj0gYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ3Jvd1NpemUgPSBNYXRoLm1heChncm93U2l6ZSB8fCB0aGlzLmdyb3dTaXplLCBhbW91bnQpO1xuXG4gIC8vIGdyb3cgYnVmZmVyXG4gIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShcbiAgICB0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLmRhdGEuYnl0ZU9mZnNldCwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgpO1xuICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSArIGdyb3dTaXplKTtcbiAgZHN0LnNldChzcmMpO1xuICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoZHN0LmJ1ZmZlcik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMSk7XG4gIHRoaXMuZGF0YS5zZXRVaW50OCh0aGlzLndyaXRlKyssIGIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIgTiB0aW1lcy5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHZhbHVlIGIgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZmlsbFdpdGhCeXRlID0gZnVuY3Rpb24oYiwgbikge1xuICB0aGlzLmFjY29tbW9kYXRlKG4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgdGhpcy5kYXRhLnNldFVpbnQ4KGIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGJ5dGVzIGluIHRoaXMgYnVmZmVyLiBUaGUgYnl0ZXMgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nLCBhblxuICogQXJyYXlCdWZmZXIsIGEgRGF0YVZpZXcsIG9yIGEgVHlwZWRBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIHB1dC5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyBmb3IgdGhlIGZpcnN0IHBhcmFtZXRlciAoJ2JpbmFyeScsICd1dGY4JyxcbiAqICAgICAgICAgICd1dGYxNicsICdoZXgnKSwgaWYgaXQgaXMgYSBzdHJpbmcgKGRlZmF1bHQ6ICdiaW5hcnknKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMsIGVuY29kaW5nKSB7XG4gIGlmKHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYnl0ZXMpKSB7XG4gICAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGxlbiA9IHNyYy5ieXRlTGVuZ3RoIC0gc3JjLmJ5dGVPZmZzZXQ7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShsZW4pO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICBkc3Quc2V0KHNyYyk7XG4gICAgdGhpcy53cml0ZSArPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZih1dGlsLmlzQXJyYXlCdWZmZXIoYnl0ZXMpKSB7XG4gICAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICB0aGlzLmFjY29tbW9kYXRlKHNyYy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcik7XG4gICAgZHN0LnNldChzcmMsIHRoaXMud3JpdGUpO1xuICAgIHRoaXMud3JpdGUgKz0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBieXRlcyBpcyBhIHV0aWwuRGF0YUJ1ZmZlciBvciBlcXVpdmFsZW50XG4gIGlmKGJ5dGVzIGluc3RhbmNlb2YgdXRpbC5EYXRhQnVmZmVyIHx8XG4gICAgKHR5cGVvZiBieXRlcyA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgYnl0ZXMucmVhZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGJ5dGVzLndyaXRlID09PSAnbnVtYmVyJyAmJlxuICAgIHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYnl0ZXMuZGF0YSkpKSB7XG4gICAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmRhdGEuYnl0ZUxlbmd0aCwgYnl0ZXMucmVhZCwgYnl0ZXMubGVuZ3RoKCkpO1xuICAgIHRoaXMuYWNjb21tb2RhdGUoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShieXRlcy5kYXRhLmJ5dGVMZW5ndGgsIHRoaXMud3JpdGUpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLndyaXRlICs9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYoYnl0ZXMgaW5zdGFuY2VvZiB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIpIHtcbiAgICAvLyBjb3B5IGJpbmFyeSBzdHJpbmcgYW5kIHByb2Nlc3MgYXMgdGhlIHNhbWUgYXMgYSBzdHJpbmcgcGFyYW1ldGVyIGJlbG93XG4gICAgYnl0ZXMgPSBieXRlcy5kYXRhO1xuICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gIH1cblxuICAvLyBzdHJpbmcgY29udmVyc2lvblxuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICdiaW5hcnknO1xuICBpZih0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHZpZXc7XG5cbiAgICAvLyBkZWNvZGUgZnJvbSBzdHJpbmdcbiAgICBpZihlbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJ5dGVzLmxlbmd0aCAvIDIpKTtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC5iaW5hcnkuaGV4LmRlY29kZShieXRlcywgdmlldywgdGhpcy53cml0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKE1hdGguY2VpbChieXRlcy5sZW5ndGggLyA0KSAqIDMpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5iYXNlNjQuZGVjb2RlKGJ5dGVzLCB2aWV3LCB0aGlzLndyaXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGVuY29kZSB0ZXh0IGFzIFVURi04IGJ5dGVzXG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgLy8gZW5jb2RlIGFzIFVURi04IHRoZW4gZGVjb2RlIHN0cmluZyBhcyByYXcgYmluYXJ5XG4gICAgICBieXRlcyA9IHV0aWwuZW5jb2RlVXRmOChieXRlcyk7XG4gICAgICBlbmNvZGluZyA9ICdiaW5hcnknO1xuICAgIH1cblxuICAgIC8vIGRlY29kZSBzdHJpbmcgYXMgcmF3IGJpbmFyeVxuICAgIGlmKGVuY29kaW5nID09PSAnYmluYXJ5JyB8fCBlbmNvZGluZyA9PT0gJ3JhdycpIHtcbiAgICAgIC8vIG9uZSBieXRlIHBlciBjaGFyYWN0ZXJcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC5iaW5hcnkucmF3LmRlY29kZSh2aWV3KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGVuY29kZSB0ZXh0IGFzIFVURi0xNiBieXRlc1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmMTYnKSB7XG4gICAgICAvLyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlclxuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShieXRlcy5sZW5ndGggKiAyKTtcbiAgICAgIHZpZXcgPSBuZXcgVWludDE2QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwudGV4dC51dGYxNi5lbmNvZGUodmlldyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cblxuICB0aHJvdyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXI6ICcgKyBieXRlcyk7XG59O1xuXG4vKipcbiAqIFB1dHMgdGhlIGdpdmVuIGJ1ZmZlciBpbnRvIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgdGhlIGJ1ZmZlciB0byBwdXQgaW50byB0aGlzIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB0aGlzLnB1dEJ5dGVzKGJ1ZmZlcik7XG4gIGJ1ZmZlci5jbGVhcigpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIHN0cmluZyBpbnRvIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBwdXQuXG4gKiBAcGFyYW0gW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgZm9yIHRoZSBzdHJpbmcgKGRlZmF1bHQ6ICd1dGYxNicpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKHN0ciwgJ3V0ZjE2Jyk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDIpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSk7XG4gIHRoaXMud3JpdGUgKz0gMjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDMpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgMHhGRkZGKTtcbiAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDB4RkYpO1xuICB0aGlzLndyaXRlICs9IDM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGkpO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMTYtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMTYtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNkxlID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDIpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSwgdHJ1ZSk7XG4gIHRoaXMud3JpdGUgKz0gMjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDI0TGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUsIGkgPj4gMTYgJiAweEZGKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGkgPj4gOCAmIDB4RkZGRiwgdHJ1ZSk7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyTGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoNCk7XG4gIHRoaXMuZGF0YS5zZXRJbnQzMih0aGlzLndyaXRlLCBpLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSA0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhbiBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHRoaXMuYWNjb21tb2RhdGUobiAvIDgpO1xuICBkbyB7XG4gICAgbiAtPSA4O1xuICAgIHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUrKywgKGkgPj4gbikgJiAweEZGKTtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci4gVHdvJ3NcbiAqIGNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24gaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB0aGlzLmFjY29tbW9kYXRlKG4gLyA4KTtcbiAgaWYoaSA8IDApIHtcbiAgICBpICs9IDIgPDwgKG4gLSAxKTtcbiAgfVxuICByZXR1cm4gdGhpcy5wdXRJbnQoaSwgbik7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGZyb20gdGhpcyBidWZmZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgMS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCsrKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQxNiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDIuXG4gKlxuICogQHJldHVybiB0aGUgdWludDE2LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDE2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCk7XG4gIHRoaXMucmVhZCArPSAyO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQyNCBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDMuXG4gKlxuICogQHJldHVybiB0aGUgdWludDI0LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDI0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCArIDIpKTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDMyKHRoaXMucmVhZCk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQxNiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDIuXG4gKlxuICogQHJldHVybiB0aGUgdWludDE2LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDE2TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkLCB0cnVlKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkICsgMSwgdHJ1ZSkgPDwgOCk7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDMyKHRoaXMucmVhZCwgdHJ1ZSk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlXG4gKiByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIHJ2YWwgPSAwO1xuICBkbyB7XG4gICAgLy8gVE9ETzogVXNlIChydmFsICogMHgxMDApIGlmIGFkZGluZyBzdXBwb3J0IGZvciAzMyB0byA1MyBiaXRzLlxuICAgIHJ2YWwgPSAocnZhbCA8PCA4KSArIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCsrKTtcbiAgICBuIC09IDg7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciwgdXNpbmdcbiAqIHR3bydzIGNvbXBsZW1lbnQsIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0U2lnbmVkSW50ID0gZnVuY3Rpb24obikge1xuICAvLyBnZXRJbnQgY2hlY2tzIG5cbiAgdmFyIHggPSB0aGlzLmdldEludChuKTtcbiAgdmFyIG1heCA9IDIgPDwgKG4gLSAyKTtcbiAgaWYoeCA+PSBtYXgpIHtcbiAgICB4IC09IG1heCA8PCAxO1xuICB9XG4gIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlcyBvdXQgYXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgYW5kIGNsZWFycyB0aGVtIGZyb20gdGhlXG4gKiBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZCwgdW5kZWZpbmVkIG9yIG51bGwgZm9yIGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlIHRoaXMgbWV0aG9kLCBpdCBpcyBwb29ybHkgbmFtZWQgYW5kXG4gIC8vIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScpIHJlcGxhY2VzIGl0XG4gIC8vIGFkZCBhIHRvVHlwZWRBcnJheSgpL3RvQXJyYXlCdWZmZXIoKSBmdW5jdGlvblxuICB2YXIgcnZhbDtcbiAgaWYoY291bnQpIHtcbiAgICAvLyByZWFkIGNvdW50IGJ5dGVzXG4gICAgY291bnQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBjb3VudCk7XG4gICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB0aGlzLnJlYWQgKz0gY291bnQ7XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMCkge1xuICAgIHJ2YWwgPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGFsbCBieXRlcywgb3B0aW1pemUgdG8gb25seSBjb3B5IHdoZW4gbmVlZGVkXG4gICAgcnZhbCA9ICh0aGlzLnJlYWQgPT09IDApID8gdGhpcy5kYXRhIDogdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nIG9mIHRoZSBieXRlcyBmcm9tIHRoaXMgYnVmZmVyIHdpdGhvdXRcbiAqIG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdldCwgb21pdCB0byBnZXQgYWxsLlxuICpcbiAqIEByZXR1cm4gYSBzdHJpbmcgZnVsbCBvZiBiaW5hcnkgZW5jb2RlZCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlIHRoaXMgbWV0aG9kLCBpdCBpcyBwb29ybHkgbmFtZWQsIGFkZCBcImdldFN0cmluZygpXCJcbiAgcmV0dXJuICh0eXBlb2YoY291bnQpID09PSAndW5kZWZpbmVkJyA/XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCkgOlxuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuZ2V0VWludDgodGhpcy5yZWFkICsgaSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuc2V0QXQgPSBmdW5jdGlvbihpLCBiKSB7XG4gIHRoaXMuZGF0YS5zZXRVaW50OChpLCBiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxhc3QgYnl0ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGxhc3QgYnl0ZS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuZ2V0VWludDgodGhpcy53cml0ZSAtIDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjb3B5LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyB1dGlsLkRhdGFCdWZmZXIodGhpcyk7XG59O1xuXG4vKipcbiAqIENvbXBhY3RzIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLnJlYWQgPiAwKSB7XG4gICAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMucmVhZCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHNyYy5ieXRlTGVuZ3RoKTtcbiAgICBkc3Quc2V0KHNyYyk7XG4gICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGRzdCk7XG4gICAgdGhpcy53cml0ZSAtPSB0aGlzLnJlYWQ7XG4gICAgdGhpcy5yZWFkID0gMDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIHRoaXMucmVhZCA9IHRoaXMud3JpdGUgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hvcnRlbnMgdGhpcyBidWZmZXIgYnkgdHJpbWluZyBieXRlcyBvZmYgb2YgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byB0cmltIG9mZi5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdGhpcy53cml0ZSA9IE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoKCkgLSBjb3VudCk7XG4gIHRoaXMucmVhZCA9IE1hdGgubWluKHRoaXMucmVhZCwgdGhpcy53cml0ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gJyc7XG4gIGZvcih2YXIgaSA9IHRoaXMucmVhZDsgaSA8IHRoaXMuZGF0YS5ieXRlTGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYiA9IHRoaXMuZGF0YS5nZXRVaW50OChpKTtcbiAgICBpZihiIDwgMTYpIHtcbiAgICAgIHJ2YWwgKz0gJzAnO1xuICAgIH1cbiAgICBydmFsICs9IGIudG9TdHJpbmcoMTYpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciB0byBhIHN0cmluZywgdXNpbmcgdGhlIGdpdmVuIGVuY29kaW5nLiBJZiBub1xuICogZW5jb2RpbmcgaXMgZ2l2ZW4sICd1dGY4JyAoVVRGLTgpIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIHRvIHVzZTogJ2JpbmFyeScsICd1dGY4JywgJ3V0ZjE2JywgJ2hleCcsXG4gKiAgICAgICAgICAnYmFzZTY0JyAoZGVmYXVsdDogJ3V0ZjgnKS5cbiAqXG4gKiBAcmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLCB0aGlzLnJlYWQsIHRoaXMubGVuZ3RoKCkpO1xuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBlbmNvZGUgdG8gc3RyaW5nXG4gIGlmKGVuY29kaW5nID09PSAnYmluYXJ5JyB8fCBlbmNvZGluZyA9PT0gJ3JhdycpIHtcbiAgICByZXR1cm4gdXRpbC5iaW5hcnkucmF3LmVuY29kZSh2aWV3KTtcbiAgfVxuICBpZihlbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICByZXR1cm4gdXRpbC5iaW5hcnkuaGV4LmVuY29kZSh2aWV3KTtcbiAgfVxuICBpZihlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSh2aWV3KTtcbiAgfVxuXG4gIC8vIGRlY29kZSB0byB0ZXh0XG4gIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICByZXR1cm4gdXRpbC50ZXh0LnV0ZjguZGVjb2RlKHZpZXcpO1xuICB9XG4gIGlmKGVuY29kaW5nID09PSAndXRmMTYnKSB7XG4gICAgcmV0dXJuIHV0aWwudGV4dC51dGYxNi5kZWNvZGUodmlldyk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG59O1xuXG4vKiogRW5kIEJ1ZmZlciB3L1VJbnQ4QXJyYXkgYmFja2luZyAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBidWZmZXIgdGhhdCBzdG9yZXMgYnl0ZXMuIEEgdmFsdWUgbWF5IGJlIGdpdmVuIHRvIHBvcHVsYXRlIHRoZVxuICogYnVmZmVyIHdpdGggZGF0YS4gVGhpcyB2YWx1ZSBjYW4gZWl0aGVyIGJlIHN0cmluZyBvZiBlbmNvZGVkIGJ5dGVzIG9yIGFcbiAqIHJlZ3VsYXIgc3RyaW5nIG9mIGNoYXJhY3RlcnMuIFdoZW4gcGFzc2luZyBhIHN0cmluZyBvZiBiaW5hcnkgZW5jb2RlZFxuICogYnl0ZXMsIHRoZSBlbmNvZGluZyBgcmF3YCBzaG91bGQgYmUgZ2l2ZW4uIFRoaXMgaXMgYWxzbyB0aGUgZGVmYXVsdC4gV2hlblxuICogcGFzc2luZyBhIHN0cmluZyBvZiBjaGFyYWN0ZXJzLCB0aGUgZW5jb2RpbmcgYHV0ZjhgIHNob3VsZCBiZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gW2lucHV0XSBhIHN0cmluZyB3aXRoIGVuY29kZWQgYnl0ZXMgdG8gc3RvcmUgaW4gdGhlIGJ1ZmZlci5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gKi9cbnV0aWwuY3JlYXRlQnVmZmVyID0gZnVuY3Rpb24oaW5wdXQsIGVuY29kaW5nKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSwgdXNlIG5ldyBCeXRlQnVmZmVyKCkgaW5zdGVhZFxuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICdyYXcnO1xuICBpZihpbnB1dCAhPT0gdW5kZWZpbmVkICYmIGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICBpbnB1dCA9IHV0aWwuZW5jb2RlVXRmOChpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIG5ldyB1dGlsLkJ5dGVCdWZmZXIoaW5wdXQpO1xufTtcblxuLyoqXG4gKiBGaWxscyBhIHN0cmluZyB3aXRoIGEgcGFydGljdWxhciB2YWx1ZS4gSWYgeW91IHdhbnQgdGhlIHN0cmluZyB0byBiZSBhIGJ5dGVcbiAqIHN0cmluZywgcGFzcyBpbiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoZUJ5dGUpLlxuICpcbiAqIEBwYXJhbSBjIHRoZSBjaGFyYWN0ZXIgdG8gZmlsbCB0aGUgc3RyaW5nIHdpdGgsIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gKiAgICAgICAgICB0byBmaWxsIHRoZSBzdHJpbmcgd2l0aCBhIGJ5dGUgdmFsdWUuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb2YgdmFsdWUgYyB0byBmaWxsIHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgZmlsbGVkIHN0cmluZy5cbiAqL1xudXRpbC5maWxsU3RyaW5nID0gZnVuY3Rpb24oYywgbikge1xuICB2YXIgcyA9ICcnO1xuICB3aGlsZShuID4gMCkge1xuICAgIGlmKG4gJiAxKSB7XG4gICAgICBzICs9IGM7XG4gICAgfVxuICAgIG4gPj4+PSAxO1xuICAgIGlmKG4gPiAwKSB7XG4gICAgICBjICs9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHBlciBieXRlIFhPUiBiZXR3ZWVuIHR3byBieXRlIHN0cmluZ3MgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhXG4gKiBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHMxIGZpcnN0IHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBzMiBzZWNvbmQgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBYT1IuXG4gKlxuICogQHJldHVybiB0aGUgWE9SJ2QgcmVzdWx0LlxuICovXG51dGlsLnhvckJ5dGVzID0gZnVuY3Rpb24oczEsIHMyLCBuKSB7XG4gIHZhciBzMyA9ICcnO1xuICB2YXIgYiA9ICcnO1xuICB2YXIgdCA9ICcnO1xuICB2YXIgaSA9IDA7XG4gIHZhciBjID0gMDtcbiAgZm9yKDsgbiA+IDA7IC0tbiwgKytpKSB7XG4gICAgYiA9IHMxLmNoYXJDb2RlQXQoaSkgXiBzMi5jaGFyQ29kZUF0KGkpO1xuICAgIGlmKGMgPj0gMTApIHtcbiAgICAgIHMzICs9IHQ7XG4gICAgICB0ID0gJyc7XG4gICAgICBjID0gMDtcbiAgICB9XG4gICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpO1xuICAgICsrYztcbiAgfVxuICBzMyArPSB0O1xuICByZXR1cm4gczM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyBpbnRvIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGhleCB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICovXG51dGlsLmhleFRvQnl0ZXMgPSBmdW5jdGlvbihoZXgpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5oZXguZGVjb2RlIGluc3RlYWQuXCJcbiAgdmFyIHJ2YWwgPSAnJztcbiAgdmFyIGkgPSAwO1xuICBpZihoZXgubGVuZ3RoICYgMSA9PSAxKSB7XG4gICAgLy8gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBjb252ZXJ0IGZpcnN0IGNoYXJhY3RlciBhbG9uZVxuICAgIGkgPSAxO1xuICAgIHJ2YWwgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXhbMF0sIDE2KSk7XG4gIH1cbiAgLy8gY29udmVydCAyIGNoYXJhY3RlcnMgKDEgYnl0ZSkgYXQgYSB0aW1lXG4gIGZvcig7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBydmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpKTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcyB0byBoZXguXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIHN0cmluZyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIHN0cmluZyBvZiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLmJ5dGVzVG9IZXggPSBmdW5jdGlvbihieXRlcykge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmhleC5lbmNvZGUgaW5zdGVhZC5cIlxuICByZXR1cm4gdXRpbC5jcmVhdGVCdWZmZXIoYnl0ZXMpLnRvSGV4KCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIDMyLWJpdCBpbnRlZ2VyIHRvIDQtYmlnLWVuZGlhbiBieXRlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlIHN0cmluZy5cbiAqL1xudXRpbC5pbnQzMlRvQnl0ZXMgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiAoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vLyBiYXNlNjQgY2hhcmFjdGVycywgcmV2ZXJzZSBtYXBwaW5nXG52YXIgX2Jhc2U2NCA9XG4gICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG52YXIgX2Jhc2U2NElkeCA9IFtcbi8qNDMgLTQzID0gMCovXG4vKicrJywgIDEsICAyLCAgMywnLycgKi9cbiAgIDYyLCAtMSwgLTEsIC0xLCA2MyxcblxuLyonMCcsJzEnLCcyJywnMycsJzQnLCc1JywnNicsJzcnLCc4JywnOScgKi9cbiAgIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDU4LCA1OSwgNjAsIDYxLFxuXG4vKjE1LCAxNiwgMTcsJz0nLCAxOSwgMjAsIDIxICovXG4gIC0xLCAtMSwgLTEsIDY0LCAtMSwgLTEsIC0xLFxuXG4vKjY1IC0gNDMgPSAyMiovXG4vKidBJywnQicsJ0MnLCdEJywnRScsJ0YnLCdHJywnSCcsJ0knLCdKJywnSycsJ0wnLCdNJywgKi9cbiAgIDAsICAxLCAgMiwgIDMsICA0LCAgNSwgIDYsICA3LCAgOCwgIDksIDEwLCAxMSwgMTIsXG5cbi8qJ04nLCdPJywnUCcsJ1EnLCdSJywnUycsJ1QnLCdVJywnVicsJ1cnLCdYJywnWScsJ1onICovXG4gICAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSxcblxuLyo5MSAtIDQzID0gNDggKi9cbi8qNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MyAqL1xuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuXG4vKjk3IC0gNDMgPSA1NCovXG4vKidhJywnYicsJ2MnLCdkJywnZScsJ2YnLCdnJywnaCcsJ2knLCdqJywnaycsJ2wnLCdtJyAqL1xuICAgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsXG5cbi8qJ24nLCdvJywncCcsJ3EnLCdyJywncycsJ3QnLCd1JywndicsJ3cnLCd4JywneScsJ3onICovXG4gICAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNDYsIDQ3LCA0OCwgNDksIDUwLCA1MVxuXTtcblxuLy8gYmFzZTU4IGNoYXJhY3RlcnMgKEJpdGNvaW4gYWxwaGFiZXQpXG52YXIgX2Jhc2U1OCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6JztcblxuLyoqXG4gKiBCYXNlNjQgZW5jb2RlcyBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmluYXJ5IGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIHRvIGJhc2U2NC1lbmNvZGUuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZW5jb2RlZCBjaGFyYWN0ZXJzIHBlciBsaW5lIHRvIHVzZSxcbiAqICAgICAgICAgIGRlZmF1bHRzIHRvIG5vbmUuXG4gKlxuICogQHJldHVybiB0aGUgYmFzZTY0LWVuY29kZWQgb3V0cHV0LlxuICovXG51dGlsLmVuY29kZTY0ID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5iYXNlNjQuZW5jb2RlIGluc3RlYWQuXCJcbiAgdmFyIGxpbmUgPSAnJztcbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZShpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgY2hyMSA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICBjaHIyID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgIGNocjMgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG5cbiAgICAvLyBlbmNvZGUgNCBjaGFyYWN0ZXIgZ3JvdXBcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KGNocjEgPj4gMik7XG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpKTtcbiAgICBpZihpc05hTihjaHIyKSkge1xuICAgICAgbGluZSArPSAnPT0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKTtcbiAgICAgIGxpbmUgKz0gaXNOYU4oY2hyMykgPyAnPScgOiBfYmFzZTY0LmNoYXJBdChjaHIzICYgNjMpO1xuICAgIH1cblxuICAgIGlmKG1heGxpbmUgJiYgbGluZS5sZW5ndGggPiBtYXhsaW5lKSB7XG4gICAgICBvdXRwdXQgKz0gbGluZS5zdWJzdHIoMCwgbWF4bGluZSkgKyAnXFxyXFxuJztcbiAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cihtYXhsaW5lKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0ICs9IGxpbmU7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIEJhc2U2NCBkZWNvZGVzIGEgc3RyaW5nIGludG8gYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJhc2U2NC1lbmNvZGVkIGlucHV0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5kZWNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZSBpbnN0ZWFkLlwiXG5cbiAgLy8gcmVtb3ZlIGFsbCBub24tYmFzZTY0IGNoYXJhY3RlcnNcbiAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgJycpO1xuXG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZShpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgZW5jMSA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzIgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMzID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jNCA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KSk7XG4gICAgaWYoZW5jMyAhPT0gNjQpIHtcbiAgICAgIC8vIGRlY29kZWQgYXQgbGVhc3QgMiBieXRlc1xuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMikpO1xuICAgICAgaWYoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgLy8gZGVjb2RlZCAzIGJ5dGVzXG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGNoYXJhY3RlcnMgKGEgc3RhbmRhcmQgSmF2YVNjcmlwdFxuICogc3RyaW5nKSBhcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyB3aGVyZSB0aGUgYnl0ZXMgcmVwcmVzZW50XG4gKiBhIFVURi04IGVuY29kZWQgc3RyaW5nIG9mIGNoYXJhY3RlcnMuIE5vbi1BU0NJSSBjaGFyYWN0ZXJzIHdpbGwgYmVcbiAqIGVuY29kZWQgYXMgbXVsdGlwbGUgYnl0ZXMgYWNjb3JkaW5nIHRvIFVURi04LlxuICpcbiAqIEBwYXJhbSBzdHIgYSBzdGFuZGFyZCBzdHJpbmcgb2YgY2hhcmFjdGVycyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgYmluYXJ5IGVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmVuY29kZVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZyB0aGF0IGNvbnRhaW5zIGJ5dGVzIHRoYXRcbiAqIHJlcHJlc2VudCBhIFVURi04IGVuY29kZWQgc3RyaW5nIG9mIGNoYXJhY3RlcnMgLS0gaW50byBhXG4gKiBzdHJpbmcgb2YgY2hhcmFjdGVycyAoYSBzdGFuZGFyZCBKYXZhU2NyaXB0IHN0cmluZykuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgYmluYXJ5IGVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgc3RhbmRhcmQgc3RyaW5nIG9mIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuZGVjb2RlVXRmOCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn07XG5cbi8vIGJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyB0b29sc1xuLy8gRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG51dGlsLmJpbmFyeSA9IHtcbiAgcmF3OiB7fSxcbiAgaGV4OiB7fSxcbiAgYmFzZTY0OiB7fSxcbiAgYmFzZTU4OiB7fSxcbiAgYmFzZU4gOiB7XG4gICAgZW5jb2RlOiBiYXNlTi5lbmNvZGUsXG4gICAgZGVjb2RlOiBiYXNlTi5kZWNvZGVcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgVWludDhBcnJheSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy4gVGhpcyBlbmNvZGluZyB1c2VzXG4gKiBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1IGZvciBlYWNoIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5iaW5hcnkucmF3LmVuY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuIFRoaXMgZW5jb2RpbmcgdXNlc1xuICogYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgYmluYXJ5LWVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LnJhdy5kZWNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSAnYmluYXJ5JyBzdHJpbmcsIEFycmF5QnVmZmVyLCBEYXRhVmlldywgVHlwZWRBcnJheSwgb3JcbiAqIEJ5dGVCdWZmZXIgYXMgYSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuYmluYXJ5LmhleC5lbmNvZGUgPSB1dGlsLmJ5dGVzVG9IZXg7XG5cbi8qKlxuICogRGVjb2RlcyBhIGhleC1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGhleCB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5oZXguZGVjb2RlID0gZnVuY3Rpb24oaGV4LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBpID0gMCwgaiA9IG9mZnNldDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEpIHtcbiAgICAvLyBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGNvbnZlcnQgZmlyc3QgY2hhcmFjdGVyIGFsb25lXG4gICAgaSA9IDE7XG4gICAgb3V0W2orK10gPSBwYXJzZUludChoZXhbMF0sIDE2KTtcbiAgfVxuICAvLyBjb252ZXJ0IDIgY2hhcmFjdGVycyAoMSBieXRlKSBhdCBhIHRpbWVcbiAgZm9yKDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgIG91dFtqKytdID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEJhc2U2NC1lbmNvZGVzIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dCBzdHJpbmcuXG4gKi9cbnV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCBpbnB1dC5ieXRlTGVuZ3RoKSB7XG4gICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgY2hyMyA9IGlucHV0W2krK107XG5cbiAgICAvLyBlbmNvZGUgNCBjaGFyYWN0ZXIgZ3JvdXBcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KGNocjEgPj4gMik7XG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpKTtcbiAgICBpZihpc05hTihjaHIyKSkge1xuICAgICAgbGluZSArPSAnPT0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKTtcbiAgICAgIGxpbmUgKz0gaXNOYU4oY2hyMykgPyAnPScgOiBfYmFzZTY0LmNoYXJBdChjaHIzICYgNjMpO1xuICAgIH1cblxuICAgIGlmKG1heGxpbmUgJiYgbGluZS5sZW5ndGggPiBtYXhsaW5lKSB7XG4gICAgICBvdXRwdXQgKz0gbGluZS5zdWJzdHIoMCwgbWF4bGluZSkgKyAnXFxyXFxuJztcbiAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cihtYXhsaW5lKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0ICs9IGxpbmU7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZTY0LWVuY29kZWQgaW5wdXQgc3RyaW5nLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDQpICogMyk7XG4gIH1cblxuICAvLyByZW1vdmUgYWxsIG5vbi1iYXNlNjQgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dFtqKytdID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICBpZihlbmMzICE9PSA2NCkge1xuICAgICAgLy8gZGVjb2RlZCBhdCBsZWFzdCAyIGJ5dGVzXG4gICAgICBvdXRbaisrXSA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xuICAgICAgaWYoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgLy8gZGVjb2RlZCAzIGJ5dGVzXG4gICAgICAgIG91dFtqKytdID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSByZXN1bHQgaXMgdGhlIGV4YWN0IGRlY29kZWQgbGVuZ3RoXG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQuc3ViYXJyYXkoMCwgaik7XG59O1xuXG4vLyBhZGQgc3VwcG9ydCBmb3IgYmFzZTU4IGVuY29kaW5nL2RlY29kaW5nIHdpdGggQml0Y29pbiBhbHBoYWJldFxudXRpbC5iaW5hcnkuYmFzZTU4LmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlTi5lbmNvZGUoaW5wdXQsIF9iYXNlNTgsIG1heGxpbmUpO1xufTtcbnV0aWwuYmluYXJ5LmJhc2U1OC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZU4uZGVjb2RlKGlucHV0LCBfYmFzZTU4LCBtYXhsaW5lKTtcbn07XG5cbi8vIHRleHQgZW5jb2RpbmcvZGVjb2RpbmcgdG9vbHNcbi8vIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxudXRpbC50ZXh0ID0ge1xuICB1dGY4OiB7fSxcbiAgdXRmMTY6IHt9XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtOCBpbiBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwudGV4dC51dGY4LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgc3RyID0gdXRpbC5lbmNvZGVVdGY4KHN0cik7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi04IGNvbnRlbnRzIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgVWludDhBcnJheSB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAqL1xudXRpbC50ZXh0LnV0ZjguZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWwuZGVjb2RlVXRmOChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKSk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtMTYgaW4gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLnRleHQudXRmMTYuZW5jb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCAqIDIpO1xuICB9XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KG91dC5idWZmZXIpO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIHZhciBrID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgdmlld1trKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaiArPSAyO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi0xNiBjb250ZW50cyBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gKi9cbnV0aWwudGV4dC51dGYxNi5kZWNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnl0ZXMuYnVmZmVyKSk7XG59O1xuXG4vKipcbiAqIERlZmxhdGVzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIGEgZmxhc2ggaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBieXRlcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSByYXcgdHJ1ZSB0byByZXR1cm4gb25seSByYXcgZGVmbGF0ZSBkYXRhLCBmYWxzZSB0byBpbmNsdWRlIHpsaWJcbiAqICAgICAgICAgIGhlYWRlciBhbmQgdHJhaWxlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLlxuICovXG51dGlsLmRlZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgYnl0ZXMgPSB1dGlsLmRlY29kZTY0KGFwaS5kZWZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsKTtcblxuICAvLyBzdHJpcCB6bGliIGhlYWRlciBhbmQgdHJhaWxlciBpZiBuZWNlc3NhcnlcbiAgaWYocmF3KSB7XG4gICAgLy8gemxpYiBoZWFkZXIgaXMgMiBieXRlcyAoQ01GLEZMRykgd2hlcmUgRkxHIGluZGljYXRlcyB0aGF0XG4gICAgLy8gdGhlcmUgaXMgYSA0LWJ5dGUgRElDVCAoYWxkZXItMzIpIGJsb2NrIGJlZm9yZSB0aGUgZGF0YSBpZlxuICAgIC8vIGl0cyA1dGggYml0IGlzIHNldFxuICAgIHZhciBzdGFydCA9IDI7XG4gICAgdmFyIGZsZyA9IGJ5dGVzLmNoYXJDb2RlQXQoMSk7XG4gICAgaWYoZmxnICYgMHgyMCkge1xuICAgICAgc3RhcnQgPSA2O1xuICAgIH1cbiAgICAvLyB6bGliIHRyYWlsZXIgaXMgNCBieXRlcyBvZiBhZGxlci0zMlxuICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKHN0YXJ0LCBieXRlcy5sZW5ndGggLSA0KTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn07XG5cbi8qKlxuICogSW5mbGF0ZXMgdGhlIGdpdmVuIGRhdGEgdXNpbmcgYSBmbGFzaCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBkYXRhLlxuICogQHBhcmFtIHJhdyB0cnVlIGlmIHRoZSBpbmNvbWluZyBkYXRhIGhhcyBubyB6bGliIGhlYWRlciBvciB0cmFpbGVyIGFuZCBpc1xuICogICAgICAgICAgcmF3IERFRkxBVEUgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbmZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLCBudWxsIG9uIGVycm9yLlxuICovXG51dGlsLmluZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgLy8gVE9ETzogYWRkIHpsaWIgaGVhZGVyIGFuZCB0cmFpbGVyIGlmIG5lY2Vzc2FyeS9wb3NzaWJsZVxuICB2YXIgcnZhbCA9IGFwaS5pbmZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsO1xuICByZXR1cm4gKHJ2YWwgPT09IG51bGwpID8gbnVsbCA6IHV0aWwuZGVjb2RlNjQocnZhbCk7XG59O1xuXG4vKipcbiAqIFNldHMgYSBzdG9yYWdlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0gb2JqIHRoZSBzdG9yYWdlIG9iamVjdCwgbnVsbCB0byByZW1vdmUuXG4gKi9cbnZhciBfc2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQsIG9iaikge1xuICBpZighYXBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gIH1cblxuICB2YXIgcnZhbDtcbiAgaWYob2JqID09PSBudWxsKSB7XG4gICAgcnZhbCA9IGFwaS5yZW1vdmVJdGVtKGlkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBqc29uLWVuY29kZSBhbmQgYmFzZTY0LWVuY29kZSBvYmplY3RcbiAgICBvYmogPSB1dGlsLmVuY29kZTY0KEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIHJ2YWwgPSBhcGkuc2V0SXRlbShpZCwgb2JqKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBwb3RlbnRpYWwgZmxhc2ggZXJyb3JcbiAgaWYodHlwZW9mKHJ2YWwpICE9PSAndW5kZWZpbmVkJyAmJiBydmFsLnJ2YWwgIT09IHRydWUpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocnZhbC5lcnJvci5tZXNzYWdlKTtcbiAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgZXJyb3IubmFtZSA9IHJ2YWwuZXJyb3IubmFtZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIGEgc3RvcmFnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIHN0b3JhZ2Ugb2JqZWN0IGVudHJ5IG9yIG51bGwgaWYgbm9uZSBleGlzdHMuXG4gKi9cbnZhciBfZ2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQpIHtcbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBleGlzdGluZyBlbnRyeVxuICB2YXIgcnZhbCA9IGFwaS5nZXRJdGVtKGlkKTtcblxuICAvKiBOb3RlOiBXZSBjaGVjayBhcGkuaW5pdCBiZWNhdXNlIHdlIGNhbid0IGRvIChhcGkgPT0gbG9jYWxTdG9yYWdlKVxuICAgIG9uIElFIGJlY2F1c2Ugb2YgXCJDbGFzcyBkb2Vzbid0IHN1cHBvcnQgQXV0b21hdGlvblwiIGV4Y2VwdGlvbi4gT25seVxuICAgIHRoZSBmbGFzaCBhcGkgaGFzIGFuIGluaXQgbWV0aG9kIHNvIHRoaXMgd29ya3MgdG9vLCBidXQgd2UgbmVlZCBhXG4gICAgYmV0dGVyIHNvbHV0aW9uIGluIHRoZSBmdXR1cmUuICovXG5cbiAgLy8gZmxhc2ggcmV0dXJucyBpdGVtIHdyYXBwZWQgaW4gYW4gb2JqZWN0LCBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gIGlmKGFwaS5pbml0KSB7XG4gICAgaWYocnZhbC5ydmFsID09PSBudWxsKSB7XG4gICAgICBpZihydmFsLmVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihydmFsLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gbm8gZXJyb3IsIGJ1dCBhbHNvIG5vIGl0ZW1cbiAgICAgIHJ2YWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsID0gcnZhbC5ydmFsO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSBkZWNvZGluZ1xuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgLy8gYmFzZTY0LWRlY29kZSBhbmQganNvbi1kZWNvZGUgZGF0YVxuICAgIHJ2YWwgPSBKU09OLnBhcnNlKHV0aWwuZGVjb2RlNjQocnZhbCkpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFN0b3JlcyBhbiBpdGVtIGluIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKi9cbnZhciBfc2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgZGF0YSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogPT09IG51bGwpIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc3RvcmFnZSBvYmplY3RcbiAgICBvYmogPSB7fTtcbiAgfVxuICAvLyB1cGRhdGUga2V5XG4gIG9ialtrZXldID0gZGF0YTtcblxuICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgb2JqKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnZhciBfZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIHJ2YWwgPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIC8vIHJldHVybiBkYXRhIGF0IGtleVxuICAgIHJ2YWwgPSAoa2V5IGluIHJ2YWwpID8gcnZhbFtrZXldIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKi9cbnZhciBfcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogIT09IG51bGwgJiYga2V5IGluIG9iaikge1xuICAgIC8vIHJlbW92ZSBrZXlcbiAgICBkZWxldGUgb2JqW2tleV07XG5cbiAgICAvLyBzZWUgaWYgZW50cnkgaGFzIG5vIGtleXMgcmVtYWluaW5nXG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKGVtcHR5KSB7XG4gICAgICAvLyByZW1vdmUgZW50cnkgZW50aXJlbHkgaWYgbm8ga2V5cyBhcmUgbGVmdFxuICAgICAgb2JqID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqL1xudmFyIF9jbGVhckl0ZW1zID0gZnVuY3Rpb24oYXBpLCBpZCkge1xuICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBudWxsKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBzdG9yYWdlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBmdW5jIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICogQHBhcmFtIGFyZ3MgdGhlIGFyZ3VtZW50cyBmb3IgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIGxvY2F0aW9uIHRoZSBsb2NhdGlvbiBhcmd1bWVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXG4gKi9cbnZhciBfY2FsbFN0b3JhZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIGxvY2F0aW9uKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBkZWZhdWx0IHN0b3JhZ2UgdHlwZXNcbiAgaWYodHlwZW9mKGxvY2F0aW9uKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhdGlvbiA9IFsnd2ViJywgJ2ZsYXNoJ107XG4gIH1cblxuICAvLyBhcHBseSBzdG9yYWdlIHR5cGVzIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcbiAgdmFyIHR5cGU7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciBleGNlcHRpb24gPSBudWxsO1xuICBmb3IodmFyIGlkeCBpbiBsb2NhdGlvbikge1xuICAgIHR5cGUgPSBsb2NhdGlvbltpZHhdO1xuICAgIHRyeSB7XG4gICAgICBpZih0eXBlID09PSAnZmxhc2gnIHx8IHR5cGUgPT09ICdib3RoJykge1xuICAgICAgICBpZihhcmdzWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGFzaCBsb2NhbCBzdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSAodHlwZSA9PT0gJ2ZsYXNoJyk7XG4gICAgICB9XG4gICAgICBpZih0eXBlID09PSAnd2ViJyB8fCB0eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgYXJnc1swXSA9IGxvY2FsU3RvcmFnZTtcbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgIGV4Y2VwdGlvbiA9IGV4O1xuICAgIH1cbiAgICBpZihkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZighZG9uZSkge1xuICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTdG9yZXMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFRoZSBhdmFpbGFibGUgdHlwZXMgb2YgbG9jYWwgc3RvcmFnZSBpbmNsdWRlICdmbGFzaCcsICd3ZWInLCBhbmQgJ2JvdGgnLlxuICpcbiAqIFRoZSB0eXBlICdmbGFzaCcgcmVmZXJzIHRvIGZsYXNoIGxvY2FsIHN0b3JhZ2UgKFNoYXJlZE9iamVjdCkuIEluIG9yZGVyXG4gKiB0byB1c2UgZmxhc2ggbG9jYWwgc3RvcmFnZSwgdGhlICdhcGknIHBhcmFtZXRlciBtdXN0IGJlIHZhbGlkLiBUaGUgdHlwZVxuICogJ3dlYicgcmVmZXJzIHRvIFdlYlN0b3JhZ2UsIGlmIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci4gVGhlIHR5cGUgJ2JvdGgnXG4gKiByZWZlcnMgdG8gc3RvcmluZyB1c2luZyBib3RoICdmbGFzaCcgYW5kICd3ZWInLCBub3QganVzdCBvbmUgb3IgdGhlXG4gKiBvdGhlci5cbiAqXG4gKiBUaGUgbG9jYXRpb24gYXJyYXkgc2hvdWxkIGxpc3QgdGhlIHN0b3JhZ2UgdHlwZXMgdG8gdXNlIGluIG9yZGVyIG9mXG4gKiBwcmVmZXJlbmNlOlxuICpcbiAqIFsnZmxhc2gnXTogZmxhc2ggb25seSBzdG9yYWdlXG4gKiBbJ3dlYiddOiB3ZWIgb25seSBzdG9yYWdlXG4gKiBbJ2JvdGgnXTogdHJ5IHRvIHN0b3JlIGluIGJvdGhcbiAqIFsnZmxhc2gnLCd3ZWInXTogc3RvcmUgaW4gZmxhc2ggZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnd2ViJ1xuICogWyd3ZWInLCdmbGFzaCddOiBzdG9yZSBpbiB3ZWIgZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnZmxhc2gnXG4gKlxuICogVGhlIGxvY2F0aW9uIGFycmF5IGRlZmF1bHRzIHRvOiBbJ3dlYicsICdmbGFzaCddXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLCBudWxsIHRvIHVzZSBvbmx5IFdlYlN0b3JhZ2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLnNldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9zZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSwgbnVsbCB0byB1c2Ugb25seSBXZWJTdG9yYWdlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnV0aWwuZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9nZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5yZW1vdmVJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfcmVtb3ZlSXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UgaWYgZmxhc2ggaXMgYXZhaWxhYmxlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwuY2xlYXJJdGVtcyA9IGZ1bmN0aW9uKGFwaSwgaWQsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9jbGVhckl0ZW1zLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBzY2hlbWUsIGhvc3QsIGFuZCBwb3J0IGZyb20gYW4gaHR0cChzKSB1cmwuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgdXJsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgdXJsIG9iamVjdCBvciBudWxsIGlmIHRoZSB1cmwgaXMgaW52YWxpZC5cbiAqL1xudXRpbC5wYXJzZVVybCA9IGZ1bmN0aW9uKHN0cikge1xuICAvLyBGSVhNRTogdGhpcyByZWdleCBsb29rcyBhIGJpdCBicm9rZW5cbiAgdmFyIHJlZ2V4ID0gL14oaHR0cHM/KTpcXC9cXC8oW146Jl5cXC9dKik6PyhcXGQqKSguKikkL2c7XG4gIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gIHZhciBtID0gcmVnZXguZXhlYyhzdHIpO1xuICB2YXIgdXJsID0gKG0gPT09IG51bGwpID8gbnVsbCA6IHtcbiAgICBmdWxsOiBzdHIsXG4gICAgc2NoZW1lOiBtWzFdLFxuICAgIGhvc3Q6IG1bMl0sXG4gICAgcG9ydDogbVszXSxcbiAgICBwYXRoOiBtWzRdXG4gIH07XG4gIGlmKHVybCkge1xuICAgIHVybC5mdWxsSG9zdCA9IHVybC5ob3N0O1xuICAgIGlmKHVybC5wb3J0KSB7XG4gICAgICBpZih1cmwucG9ydCAhPT0gODAgJiYgdXJsLnNjaGVtZSA9PT0gJ2h0dHAnKSB7XG4gICAgICAgIHVybC5mdWxsSG9zdCArPSAnOicgKyB1cmwucG9ydDtcbiAgICAgIH0gZWxzZSBpZih1cmwucG9ydCAhPT0gNDQzICYmIHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgICAgdXJsLmZ1bGxIb3N0ICs9ICc6JyArIHVybC5wb3J0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih1cmwuc2NoZW1lID09PSAnaHR0cCcpIHtcbiAgICAgIHVybC5wb3J0ID0gODA7XG4gICAgfSBlbHNlIGlmKHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgIHVybC5wb3J0ID0gNDQzO1xuICAgIH1cbiAgICB1cmwuZnVsbCA9IHVybC5zY2hlbWUgKyAnOi8vJyArIHVybC5mdWxsSG9zdDtcbiAgfVxuICByZXR1cm4gdXJsO1xufTtcblxuLyogU3RvcmFnZSBmb3IgcXVlcnkgdmFyaWFibGVzICovXG52YXIgX3F1ZXJ5VmFyaWFibGVzID0gbnVsbDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB3aW5kb3cgbG9jYXRpb24gcXVlcnkgdmFyaWFibGVzLiBRdWVyeSBpcyBwYXJzZWQgb24gdGhlIGZpcnN0XG4gKiBjYWxsIGFuZCB0aGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgb24gc3Vic2VxdWVudCBjYWxscy4gVGhlIG1hcHBpbmdcbiAqIGlzIGZyb20ga2V5cyB0byBhbiBhcnJheSBvZiB2YWx1ZXMuIFBhcmFtZXRlcnMgd2l0aG91dCB2YWx1ZXMgd2lsbCBoYXZlXG4gKiBhbiBvYmplY3Qga2V5IHNldCBidXQgbm8gdmFsdWUgYWRkZWQgdG8gdGhlIHZhbHVlIGFycmF5LiBWYWx1ZXMgYXJlXG4gKiB1bmVzY2FwZWQuXG4gKlxuICogLi4uP2sxPXYxJmsyPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCJdLFxuICogICBcImsyXCI6IFtcInYyXCJdXG4gKiB9XG4gKlxuICogLi4uP2sxPXYxJmsxPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCIsIFwidjJcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazI6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl0sXG4gKiAgIFwiazJcIjogW11cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW11cbiAqIH1cbiAqXG4gKiBAcGFyYW0gcXVlcnkgdGhlIHF1ZXJ5IHN0cmluZyB0byBwYXJzZSAob3B0aW9uYWwsIGRlZmF1bHQgdG8gY2FjaGVkXG4gKiAgICAgICAgICByZXN1bHRzIGZyb20gcGFyc2luZyB3aW5kb3cgbG9jYXRpb24gc2VhcmNoIHF1ZXJ5KS5cbiAqXG4gKiBAcmV0dXJuIG9iamVjdCBtYXBwaW5nIGtleXMgdG8gdmFyaWFibGVzLlxuICovXG51dGlsLmdldFF1ZXJ5VmFyaWFibGVzID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24ocSkge1xuICAgIHZhciBydmFsID0ge307XG4gICAgdmFyIGt2cGFpcnMgPSBxLnNwbGl0KCcmJyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGt2cGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb3MgPSBrdnBhaXJzW2ldLmluZGV4T2YoJz0nKTtcbiAgICAgIHZhciBrZXk7XG4gICAgICB2YXIgdmFsO1xuICAgICAgaWYocG9zID4gMCkge1xuICAgICAgICBrZXkgPSBrdnBhaXJzW2ldLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICB2YWwgPSBrdnBhaXJzW2ldLnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGt2cGFpcnNbaV07XG4gICAgICAgIHZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZighKGtleSBpbiBydmFsKSkge1xuICAgICAgICBydmFsW2tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIC8vIGRpc2FsbG93IG92ZXJyaWRpbmcgb2JqZWN0IHByb3RvdHlwZSBrZXlzXG4gICAgICBpZighKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgcnZhbFtrZXldLnB1c2godW5lc2NhcGUodmFsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gICB2YXIgcnZhbDtcbiAgIGlmKHR5cGVvZihxdWVyeSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgIC8vIHNldCBjYWNoZWQgdmFyaWFibGVzIGlmIG5lZWRlZFxuICAgICBpZihfcXVlcnlWYXJpYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICBpZih0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgICAgICAvLyBwYXJzZSB3aW5kb3cgc2VhcmNoIHF1ZXJ5XG4gICAgICAgICAgX3F1ZXJ5VmFyaWFibGVzID0gcGFyc2Uod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gcXVlcnkgdmFyaWFibGVzIGF2YWlsYWJsZVxuICAgICAgICAgIF9xdWVyeVZhcmlhYmxlcyA9IHt9O1xuICAgICAgIH1cbiAgICAgfVxuICAgICBydmFsID0gX3F1ZXJ5VmFyaWFibGVzO1xuICAgfSBlbHNlIHtcbiAgICAgLy8gcGFyc2UgZ2l2ZW4gcXVlcnlcbiAgICAgcnZhbCA9IHBhcnNlKHF1ZXJ5KTtcbiAgIH1cbiAgIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBmcmFnbWVudCBpbnRvIGEgcGF0aCBhbmQgcXVlcnkuIFRoaXMgbWV0aG9kIHdpbGwgdGFrZSBhIFVSSVxuICogZnJhZ21lbnQgYW5kIGJyZWFrIGl0IHVwIGFzIGlmIGl0IHdlcmUgdGhlIG1haW4gVVJJLiBGb3IgZXhhbXBsZTpcbiAqICAgIC9iYXIvYmF6P2E9MSZiPTJcbiAqIHJlc3VsdHMgaW46XG4gKiAgICB7XG4gKiAgICAgICBwYXRoOiBbXCJiYXJcIiwgXCJiYXpcIl0sXG4gKiAgICAgICBxdWVyeToge1wiazFcIjogW1widjFcIl0sIFwiazJcIjogW1widjJcIl19XG4gKiAgICB9XG4gKlxuICogQHJldHVybiBvYmplY3Qgd2l0aCBhIHBhdGggYXJyYXkgYW5kIHF1ZXJ5IG9iamVjdC5cbiAqL1xudXRpbC5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgLy8gZGVmYXVsdCB0byB3aG9sZSBmcmFnbWVudFxuICB2YXIgZnAgPSBmcmFnbWVudDtcbiAgdmFyIGZxID0gJyc7XG4gIC8vIHNwbGl0IGludG8gcGF0aCBhbmQgcXVlcnkgaWYgcG9zc2libGUgYXQgdGhlIGZpcnN0ICc/J1xuICB2YXIgcG9zID0gZnJhZ21lbnQuaW5kZXhPZignPycpO1xuICBpZihwb3MgPiAwKSB7XG4gICAgZnAgPSBmcmFnbWVudC5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICBmcSA9IGZyYWdtZW50LnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgfVxuICAvLyBzcGxpdCBwYXRoIGJhc2VkIG9uICcvJyBhbmQgaWdub3JlIGZpcnN0IGVsZW1lbnQgaWYgZW1wdHlcbiAgdmFyIHBhdGggPSBmcC5zcGxpdCgnLycpO1xuICBpZihwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aFswXSA9PT0gJycpIHtcbiAgICBwYXRoLnNoaWZ0KCk7XG4gIH1cbiAgLy8gY29udmVydCBxdWVyeSBpbnRvIG9iamVjdFxuICB2YXIgcXVlcnkgPSAoZnEgPT09ICcnKSA/IHt9IDogdXRpbC5nZXRRdWVyeVZhcmlhYmxlcyhmcSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoU3RyaW5nOiBmcCxcbiAgICBxdWVyeVN0cmluZzogZnEsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnlcbiAgfTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSByZXF1ZXN0IG91dCBvZiBhIFVSSS1saWtlIHJlcXVlc3Qgc3RyaW5nLiBUaGlzIGlzIGludGVuZGVkIHRvXG4gKiBiZSB1c2VkIHdoZXJlIGEgZnJhZ21lbnQgaWQgKGFmdGVyIGEgVVJJICcjJykgaXMgcGFyc2VkIGFzIGEgVVJJIHdpdGhcbiAqIHBhdGggYW5kIHF1ZXJ5IHBhcnRzLiBUaGUgc3RyaW5nIHNob3VsZCBoYXZlIGEgcGF0aCBiZWdpbm5pbmcgYW5kXG4gKiBkZWxpbWl0ZWQgYnkgJy8nIGFuZCBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzIGZvbGxvd2luZyBhICc/Jy4gVGhlXG4gKiBxdWVyeSBzaG91bGQgYmUgYSBzdGFuZGFyZCBVUkwgc2V0IG9mIGtleSB2YWx1ZSBwYWlycyBkZWxpbWl0ZWQgYnlcbiAqICcmJy4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRoZSBpbml0aWFsICcvJyBvbiB0aGUgcGF0aCBpcyBub3RcbiAqIHJlcXVpcmVkLiBUaGUgcmVxdWVzdCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgQVBJLCAoZnVsbHkgZGVzY3JpYmVkXG4gKiBpbiB0aGUgbWV0aG9kIGNvZGUpOlxuICogICAge1xuICogICAgICAgcGF0aDogPHRoZSBwYXRoIHN0cmluZyBwYXJ0Pi5cbiAqICAgICAgIHF1ZXJ5OiA8dGhlIHF1ZXJ5IHN0cmluZyBwYXJ0PixcbiAqICAgICAgIGdldFBhdGgoaSk6IGdldCBwYXJ0IG9yIGFsbCBvZiB0aGUgc3BsaXQgcGF0aCBhcnJheSxcbiAqICAgICAgIGdldFF1ZXJ5KGssIGkpOiBnZXQgcGFydCBvciBhbGwgb2YgYSBxdWVyeSBrZXkgYXJyYXksXG4gKiAgICAgICBnZXRRdWVyeUxhc3QoaywgX2RlZmF1bHQpOiBnZXQgbGFzdCBlbGVtZW50IG9mIGEgcXVlcnkga2V5IGFycmF5LlxuICogICAgfVxuICpcbiAqIEByZXR1cm4gb2JqZWN0IHdpdGggcmVxdWVzdCBwYXJhbWV0ZXJzLlxuICovXG51dGlsLm1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxU3RyaW5nKSB7XG4gIHZhciBmcmFnID0gdXRpbC5wYXJzZUZyYWdtZW50KHJlcVN0cmluZyk7XG4gIHZhciByZXEgPSB7XG4gICAgLy8gZnVsbCBwYXRoIHN0cmluZ1xuICAgIHBhdGg6IGZyYWcucGF0aFN0cmluZyxcbiAgICAvLyBmdWxsIHF1ZXJ5IHN0cmluZ1xuICAgIHF1ZXJ5OiBmcmFnLnF1ZXJ5U3RyaW5nLFxuICAgIC8qKlxuICAgICAqIEdldCBwYXRoIG9yIGVsZW1lbnQgaW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHBhdGggaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHBhdGggb3IgcGFydCBvZiBwYXRoIGlmIGkgcHJvdmlkZWQuXG4gICAgICovXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuICh0eXBlb2YoaSkgPT09ICd1bmRlZmluZWQnKSA/IGZyYWcucGF0aCA6IGZyYWcucGF0aFtpXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBxdWVyeSwgdmFsdWVzIGZvciBhIGtleSwgb3IgdmFsdWUgZm9yIGEga2V5IGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGsgb3B0aW9uYWwgcXVlcnkga2V5LlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHF1ZXJ5IGtleSBpbmRleC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gcXVlcnksIHZhbHVlcyBmb3IgYSBrZXksIG9yIHZhbHVlIGZvciBhIGtleSBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRRdWVyeTogZnVuY3Rpb24oaywgaSkge1xuICAgICAgdmFyIHJ2YWw7XG4gICAgICBpZih0eXBlb2YoaykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJ2YWwgPSBmcmFnLnF1ZXJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IGZyYWcucXVlcnlba107XG4gICAgICAgIGlmKHJ2YWwgJiYgdHlwZW9mKGkpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICBydmFsID0gcnZhbFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcbiAgICBnZXRRdWVyeUxhc3Q6IGZ1bmN0aW9uKGssIF9kZWZhdWx0KSB7XG4gICAgICB2YXIgcnZhbDtcbiAgICAgIHZhciB2YWxzID0gcmVxLmdldFF1ZXJ5KGspO1xuICAgICAgaWYodmFscykge1xuICAgICAgICBydmFsID0gdmFsc1t2YWxzLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IF9kZWZhdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIFVSSSBvdXQgb2YgYSBwYXRoLCBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzLCBhbmQgYVxuICogZnJhZ21lbnQuIFVzZXMgalF1ZXJ5LnBhcmFtKCkgaW50ZXJuYWxseSBmb3IgcXVlcnkgc3RyaW5nIGNyZWF0aW9uLlxuICogSWYgdGhlIHBhdGggaXMgYW4gYXJyYXksIGl0IHdpbGwgYmUgam9pbmVkIHdpdGggJy8nLlxuICpcbiAqIEBwYXJhbSBwYXRoIHN0cmluZyBwYXRoIG9yIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gcXVlcnkgb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycy4gKG9wdGlvbmFsKVxuICogQHBhcmFtIGZyYWdtZW50IGZyYWdtZW50IHN0cmluZy4gKG9wdGlvbmFsKVxuICpcbiAqIEByZXR1cm4gc3RyaW5nIG9iamVjdCB3aXRoIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAqL1xudXRpbC5tYWtlTGluayA9IGZ1bmN0aW9uKHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCkge1xuICAvLyBqb2luIHBhdGggcGFydHMgaWYgbmVlZGVkXG4gIHBhdGggPSBqUXVlcnkuaXNBcnJheShwYXRoKSA/IHBhdGguam9pbignLycpIDogcGF0aDtcblxuICB2YXIgcXN0ciA9IGpRdWVyeS5wYXJhbShxdWVyeSB8fCB7fSk7XG4gIGZyYWdtZW50ID0gZnJhZ21lbnQgfHwgJyc7XG4gIHJldHVybiBwYXRoICtcbiAgICAoKHFzdHIubGVuZ3RoID4gMCkgPyAoJz8nICsgcXN0cikgOiAnJykgK1xuICAgICgoZnJhZ21lbnQubGVuZ3RoID4gMCkgPyAoJyMnICsgZnJhZ21lbnQpIDogJycpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgZW1wdHkuXG4gKlxuICogVGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0LWZyb20tanNvbi82Nzk5MzcjNjc5OTM3XG4gKlxuICogQHBhcmFtIG9iamVjdCB0aGUgb2JqZWN0IHRvIGNoZWNrLlxuICovXG51dGlsLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRm9ybWF0IHdpdGggc2ltcGxlIHByaW50Zi1zdHlsZSBpbnRlcnBvbGF0aW9uLlxuICpcbiAqICUlOiBsaXRlcmFsICclJ1xuICogJXMsJW86IGNvbnZlcnQgbmV4dCBhcmd1bWVudCBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBmb3JtYXQgdGhlIHN0cmluZyB0byBmb3JtYXQuXG4gKiBAcGFyYW0gLi4uIGFyZ3VtZW50cyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBmb3JtYXQgc3RyaW5nLlxuICovXG51dGlsLmZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICB2YXIgcmUgPSAvJS4vZztcbiAgLy8gY3VycmVudCBtYXRjaFxuICB2YXIgbWF0Y2g7XG4gIC8vIGN1cnJlbnQgcGFydFxuICB2YXIgcGFydDtcbiAgLy8gY3VycmVudCBhcmcgaW5kZXhcbiAgdmFyIGFyZ2kgPSAwO1xuICAvLyBjb2xsZWN0ZWQgcGFydHMgdG8gcmVjb21iaW5lIGxhdGVyXG4gIHZhciBwYXJ0cyA9IFtdO1xuICAvLyBsYXN0IGluZGV4IGZvdW5kXG4gIHZhciBsYXN0ID0gMDtcbiAgLy8gbG9vcCB3aGlsZSBtYXRjaGVzIHJlbWFpblxuICB3aGlsZSgobWF0Y2ggPSByZS5leGVjKGZvcm1hdCkpKSB7XG4gICAgcGFydCA9IGZvcm1hdC5zdWJzdHJpbmcobGFzdCwgcmUubGFzdEluZGV4IC0gMik7XG4gICAgLy8gZG9uJ3QgYWRkIGVtcHR5IHN0cmluZ3MgKGllLCBwYXJ0cyBiZXR3ZWVuICVzJXMpXG4gICAgaWYocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICBsYXN0ID0gcmUubGFzdEluZGV4O1xuICAgIC8vIHN3aXRjaCBvbiAlIGNvZGVcbiAgICB2YXIgY29kZSA9IG1hdGNoWzBdWzFdO1xuICAgIHN3aXRjaChjb2RlKSB7XG4gICAgY2FzZSAncyc6XG4gICAgY2FzZSAnbyc6XG4gICAgICAvLyBjaGVjayBpZiBlbm91Z2ggYXJndW1lbnRzIHdlcmUgZ2l2ZW5cbiAgICAgIGlmKGFyZ2kgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXJndW1lbnRzW2FyZ2krKyArIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2goJzw/PicpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gRklYTUU6IGRvIHByb3BlciBmb3JtYXRpbmcgZm9yIG51bWJlcnMsIGV0Y1xuICAgIC8vY2FzZSAnZic6XG4gICAgLy9jYXNlICdkJzpcbiAgICBjYXNlICclJzpcbiAgICAgIHBhcnRzLnB1c2goJyUnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwYXJ0cy5wdXNoKCc8JScgKyBjb2RlICsgJz8+Jyk7XG4gICAgfVxuICB9XG4gIC8vIGFkZCB0cmFpbGluZyBwYXJ0IG9mIGZvcm1hdCBzdHJpbmdcbiAgcGFydHMucHVzaChmb3JtYXQuc3Vic3RyaW5nKGxhc3QpKTtcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbnVtYmVyLlxuICpcbiAqIGh0dHA6Ly9zbmlwcGxyLmNvbS92aWV3LzU5NDUvamF2YXNjcmlwdC1udW1iZXJmb3JtYXQtLXBvcnRlZC1mcm9tLXBocC9cbiAqL1xudXRpbC5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbihudW1iZXIsIGRlY2ltYWxzLCBkZWNfcG9pbnQsIHRob3VzYW5kc19zZXApIHtcbiAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBKb25hcyBSYW9uaSBTb2FyZXMgU2lsdmEgKGh0dHA6Ly93d3cuanNmcm9taGVsbC5jb20pXG4gIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gIC8vICsgICAgIGJ1Z2ZpeCBieTogTWljaGFlbCBXaGl0ZSAoaHR0cDovL2NyZXN0aWRnLmNvbSlcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBCZW5qYW1pbiBMdXB0b25cbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBBbGxhbiBKZW5zZW4gKGh0dHA6Ly93d3cud2ludGVybmV0Lm5vKVxuICAvLyArICAgIHJldmlzZWQgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKiAgICAgZXhhbXBsZSAxOiBudW1iZXJfZm9ybWF0KDEyMzQuNTY3OCwgMiwgJy4nLCAnJyk7XG4gIC8vICogICAgIHJldHVybnMgMTogMTIzNC41N1xuXG4gIHZhciBuID0gbnVtYmVyLCBjID0gaXNOYU4oZGVjaW1hbHMgPSBNYXRoLmFicyhkZWNpbWFscykpID8gMiA6IGRlY2ltYWxzO1xuICB2YXIgZCA9IGRlY19wb2ludCA9PT0gdW5kZWZpbmVkID8gJywnIDogZGVjX3BvaW50O1xuICB2YXIgdCA9IHRob3VzYW5kc19zZXAgPT09IHVuZGVmaW5lZCA/XG4gICAnLicgOiB0aG91c2FuZHNfc2VwLCBzID0gbiA8IDAgPyAnLScgOiAnJztcbiAgdmFyIGkgPSBwYXJzZUludCgobiA9IE1hdGguYWJzKCtuIHx8IDApLnRvRml4ZWQoYykpLCAxMCkgKyAnJztcbiAgdmFyIGogPSAoaS5sZW5ndGggPiAzKSA/IGkubGVuZ3RoICUgMyA6IDA7XG4gIHJldHVybiBzICsgKGogPyBpLnN1YnN0cigwLCBqKSArIHQgOiAnJykgK1xuICAgIGkuc3Vic3RyKGopLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLCAnJDEnICsgdCkgK1xuICAgIChjID8gZCArIE1hdGguYWJzKG4gLSBpKS50b0ZpeGVkKGMpLnNsaWNlKDIpIDogJycpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgYnl0ZSBzaXplLlxuICpcbiAqIGh0dHA6Ly9zbmlwcGxyLmNvbS92aWV3LzU5NDkvZm9ybWF0LWh1bWFuaXplLWZpbGUtYnl0ZS1zaXplLXByZXNlbnRhdGlvbi1pbi1qYXZhc2NyaXB0L1xuICovXG51dGlsLmZvcm1hdFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIGlmKHNpemUgPj0gMTA3Mzc0MTgyNCkge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA3Mzc0MTgyNCwgMiwgJy4nLCAnJykgKyAnIEdpQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwNDg1NzYpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwNDg1NzYsIDIsICcuJywgJycpICsgJyBNaUInO1xuICB9IGVsc2UgaWYoc2l6ZSA+PSAxMDI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDI0LCAwKSArICcgS2lCJztcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSwgMCkgKyAnIGJ5dGVzJztcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpbnRvIGJ5dGVzIChpbiBuZXR3b3JrIG9yZGVyKS5cbiAqXG4gKiBAcGFyYW0gaXAgdGhlIElQdjQgb3IgSVB2NiBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIElQdjYgb3IgMTYtYnl0ZSBJUHY2IGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndFxuICogICAgICAgICBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVAgPSBmdW5jdGlvbihpcCkge1xuICBpZihpcC5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NChpcCk7XG4gIH1cbiAgaWYoaXAuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHJldHVybiB1dGlsLmJ5dGVzRnJvbUlQdjYoaXApO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBpbnRvIGJ5dGVzIChpbiBuZXR3b3JrIG9yZGVyKS5cbiAqXG4gKiBAcGFyYW0gaXAgdGhlIElQdjQgYWRkcmVzcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIDQtYnl0ZSBhZGRyZXNzIG9yIG51bGwgaWYgdGhlIGFkZHJlc3MgY2FuJ3QgYmUgcGFyc2VkLlxuICovXG51dGlsLmJ5dGVzRnJvbUlQdjQgPSBmdW5jdGlvbihpcCkge1xuICBpcCA9IGlwLnNwbGl0KCcuJyk7XG4gIGlmKGlwLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBiID0gdXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlwLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIG51bSA9IHBhcnNlSW50KGlwW2ldLCAxMCk7XG4gICAgaWYoaXNOYU4obnVtKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGIucHV0Qnl0ZShudW0pO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NiBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgMTYtYnl0ZSBhZGRyZXNzIG9yIG51bGwgaWYgdGhlIGFkZHJlc3MgY2FuJ3QgYmUgcGFyc2VkLlxuICovXG51dGlsLmJ5dGVzRnJvbUlQdjYgPSBmdW5jdGlvbihpcCkge1xuICB2YXIgYmxhbmtzID0gMDtcbiAgaXAgPSBpcC5zcGxpdCgnOicpLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgaWYoZS5sZW5ndGggPT09IDApICsrYmxhbmtzO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgdmFyIHplcm9zID0gKDggLSBpcC5sZW5ndGggKyBibGFua3MpICogMjtcbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgaWYoIWlwW2ldIHx8IGlwW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYi5maWxsV2l0aEJ5dGUoMCwgemVyb3MpO1xuICAgICAgemVyb3MgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBieXRlcyA9IHV0aWwuaGV4VG9CeXRlcyhpcFtpXSk7XG4gICAgaWYoYnl0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgYi5wdXRCeXRlKDApO1xuICAgIH1cbiAgICBiLnB1dEJ5dGVzKGJ5dGVzKTtcbiAgfVxuICByZXR1cm4gYi5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyA0LWJ5dGVzIGludG8gYW4gSVB2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb3IgMTYtYnl0ZXMgaW50b1xuICogYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFRoZSBieXRlcyBtdXN0IGJlIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgb3IgSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaWYgNCBvciAxNiBieXRlcyxcbiAqICAgICAgICAgcmVzcGVjdGl2ZWx5LCBhcmUgZ2l2ZW4sIG90aGVyd2lzZSBudWxsLlxuICovXG51dGlsLmJ5dGVzVG9JUCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gNCkge1xuICAgIHJldHVybiB1dGlsLmJ5dGVzVG9JUHY0KGJ5dGVzKTtcbiAgfVxuICBpZihieXRlcy5sZW5ndGggPT09IDE2KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjYoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyA0LWJ5dGVzIGludG8gYW4gSVB2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFRoZSBieXRlcyBtdXN0IGJlXG4gKiBpbiBuZXR3b3JrIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciBudWxsIGZvciBhbiBpbnZhbGlkICMgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQdjQgPSBmdW5jdGlvbihieXRlcykge1xuICBpZihieXRlcy5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaXAucHVzaChieXRlcy5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuICByZXR1cm4gaXAuam9pbignLicpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyAxNi1ieXRlcyBpbnRvIGFuIElQdjE2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjE2IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciBudWxsIGZvciBhbiBpbnZhbGlkICMgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQdjYgPSBmdW5jdGlvbihieXRlcykge1xuICBpZihieXRlcy5sZW5ndGggIT09IDE2KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGlwID0gW107XG4gIHZhciB6ZXJvR3JvdXBzID0gW107XG4gIHZhciB6ZXJvTWF4R3JvdXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgaGV4ID0gdXRpbC5ieXRlc1RvSGV4KGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdKTtcbiAgICAvLyBjYW5vbmljYWxpemUgemVybyByZXByZXNlbnRhdGlvblxuICAgIHdoaWxlKGhleFswXSA9PT0gJzAnICYmIGhleCAhPT0gJzAnKSB7XG4gICAgICBoZXggPSBoZXguc3Vic3RyKDEpO1xuICAgIH1cbiAgICBpZihoZXggPT09ICcwJykge1xuICAgICAgdmFyIGxhc3QgPSB6ZXJvR3JvdXBzW3plcm9Hcm91cHMubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgaWR4ID0gaXAubGVuZ3RoO1xuICAgICAgaWYoIWxhc3QgfHwgaWR4ICE9PSBsYXN0LmVuZCArIDEpIHtcbiAgICAgICAgemVyb0dyb3Vwcy5wdXNoKHtzdGFydDogaWR4LCBlbmQ6IGlkeH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdC5lbmQgPSBpZHg7XG4gICAgICAgIGlmKChsYXN0LmVuZCAtIGxhc3Quc3RhcnQpID5cbiAgICAgICAgICAoemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLmVuZCAtIHplcm9Hcm91cHNbemVyb01heEdyb3VwXS5zdGFydCkpIHtcbiAgICAgICAgICB6ZXJvTWF4R3JvdXAgPSB6ZXJvR3JvdXBzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaXAucHVzaChoZXgpO1xuICB9XG4gIGlmKHplcm9Hcm91cHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBncm91cCA9IHplcm9Hcm91cHNbemVyb01heEdyb3VwXTtcbiAgICAvLyBvbmx5IHNob3J0ZW4gZ3JvdXAgb2YgbGVuZ3RoID4gMFxuICAgIGlmKGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ID4gMCkge1xuICAgICAgaXAuc3BsaWNlKGdyb3VwLnN0YXJ0LCBncm91cC5lbmQgLSBncm91cC5zdGFydCArIDEsICcnKTtcbiAgICAgIGlmKGdyb3VwLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGlwLnVuc2hpZnQoJycpO1xuICAgICAgfVxuICAgICAgaWYoZ3JvdXAuZW5kID09PSA3KSB7XG4gICAgICAgIGlwLnB1c2goJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaXAuam9pbignOicpO1xufTtcblxuLyoqXG4gKiBFc3RpbWF0ZXMgdGhlIG51bWJlciBvZiBwcm9jZXNzZXMgdGhhdCBjYW4gYmUgcnVuIGNvbmN1cnJlbnRseS4gSWZcbiAqIGNyZWF0aW5nIFdlYiBXb3JrZXJzLCBrZWVwIGluIG1pbmQgdGhhdCB0aGUgbWFpbiBKYXZhU2NyaXB0IHByb2Nlc3MgbmVlZHNcbiAqIGl0cyBvd24gY29yZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICB1cGRhdGUgdHJ1ZSB0byBmb3JjZSBhbiB1cGRhdGUgKG5vdCB1c2UgdGhlIGNhY2hlZCB2YWx1ZSkuXG4gKiBAcGFyYW0gY2FsbGJhY2soZXJyLCBtYXgpIGNhbGxlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICovXG51dGlsLmVzdGltYXRlQ29yZXMgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCdjb3JlcycgaW4gdXRpbCAmJiAhb3B0aW9ucy51cGRhdGUpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cbiAgaWYodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnaGFyZHdhcmVDb25jdXJyZW5jeScgaW4gbmF2aWdhdG9yICYmXG4gICAgbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgPiAwKSB7XG4gICAgdXRpbC5jb3JlcyA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHdvcmtlcnMgbm90IGF2YWlsYWJsZVxuICAgIHV0aWwuY29yZXMgPSAxO1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgQmxvYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBjYW4ndCBlc3RpbWF0ZSwgZGVmYXVsdCB0byAyXG4gICAgdXRpbC5jb3JlcyA9IDI7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG5cbiAgLy8gY3JlYXRlIHdvcmtlciBjb25jdXJyZW5jeSBlc3RpbWF0aW9uIGNvZGUgYXMgYmxvYlxuICB2YXIgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoWycoJyxcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gcnVuIHdvcmtlciBmb3IgNCBtc1xuICAgICAgICB2YXIgc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgZXQgPSBzdCArIDQ7XG4gICAgICAgIHdoaWxlKERhdGUubm93KCkgPCBldCk7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe3N0OiBzdCwgZXQ6IGV0fSk7XG4gICAgICB9KTtcbiAgICB9LnRvU3RyaW5nKCksXG4gICcpKCknXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J30pKTtcblxuICAvLyB0YWtlIDUgc2FtcGxlcyB1c2luZyAxNiB3b3JrZXJzXG4gIHNhbXBsZShbXSwgNSwgMTYpO1xuXG4gIGZ1bmN0aW9uIHNhbXBsZShtYXgsIHNhbXBsZXMsIG51bVdvcmtlcnMpIHtcbiAgICBpZihzYW1wbGVzID09PSAwKSB7XG4gICAgICAvLyBnZXQgb3ZlcmxhcCBhdmVyYWdlXG4gICAgICB2YXIgYXZnID0gTWF0aC5mbG9vcihtYXgucmVkdWNlKGZ1bmN0aW9uKGF2ZywgeCkge1xuICAgICAgICByZXR1cm4gYXZnICsgeDtcbiAgICAgIH0sIDApIC8gbWF4Lmxlbmd0aCk7XG4gICAgICB1dGlsLmNvcmVzID0gTWF0aC5tYXgoMSwgYXZnKTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVybCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gICAgfVxuICAgIG1hcChudW1Xb3JrZXJzLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgIG1heC5wdXNoKHJlZHVjZShudW1Xb3JrZXJzLCByZXN1bHRzKSk7XG4gICAgICBzYW1wbGUobWF4LCBzYW1wbGVzIC0gMSwgbnVtV29ya2Vycyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXAobnVtV29ya2VycywgY2FsbGJhY2spIHtcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVybCk7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGUuZGF0YSk7XG4gICAgICAgIGlmKHJlc3VsdHMubGVuZ3RoID09PSBudW1Xb3JrZXJzKSB7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd29ya2Vycy5wdXNoKHdvcmtlcik7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIHdvcmtlcnNbaV0ucG9zdE1lc3NhZ2UoaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpIHtcbiAgICAvLyBmaW5kIG92ZXJsYXBwaW5nIHRpbWUgd2luZG93c1xuICAgIHZhciBvdmVybGFwcyA9IFtdO1xuICAgIGZvcih2YXIgbiA9IDA7IG4gPCBudW1Xb3JrZXJzOyArK24pIHtcbiAgICAgIHZhciByMSA9IHJlc3VsdHNbbl07XG4gICAgICB2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW25dID0gW107XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgIGlmKG4gPT09IGkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcjIgPSByZXN1bHRzW2ldO1xuICAgICAgICBpZigocjEuc3QgPiByMi5zdCAmJiByMS5zdCA8IHIyLmV0KSB8fFxuICAgICAgICAgIChyMi5zdCA+IHIxLnN0ICYmIHIyLnN0IDwgcjEuZXQpKSB7XG4gICAgICAgICAgb3ZlcmxhcC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGdldCBtYXhpbXVtIG92ZXJsYXBzIC4uLiBkb24ndCBpbmNsdWRlIG92ZXJsYXBwaW5nIHdvcmtlciBpdHNlbGZcbiAgICAvLyBhcyB0aGUgbWFpbiBKUyBwcm9jZXNzIHdhcyBhbHNvIGJlaW5nIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHdvcmsgYW5kXG4gICAgLy8gd291bGQgaGF2ZSB0byBiZSBzdWJ0cmFjdGVkIGZyb20gdGhlIGVzdGltYXRlIGFueXdheVxuICAgIHJldHVybiBvdmVybGFwcy5yZWR1Y2UoZnVuY3Rpb24obWF4LCBvdmVybGFwKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBvdmVybGFwLmxlbmd0aCk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIHF1ZXVlLW1pY3JvdGFzay4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubGV0IHByb21pc2VcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbidcbiAgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKGdsb2JhbFRoaXMpXG4gIC8vIHJldXNlIHJlc29sdmVkIHByb21pc2UsIGFuZCBhbGxvY2F0ZSBpdCBsYXppbHlcbiAgOiBjYiA9PiAocHJvbWlzZSB8fCAocHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpKSlcbiAgICAudGhlbihjYilcbiAgICAuY2F0Y2goZXJyID0+IHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlcnIgfSwgMCkpXG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEFzeW5jQWxnb3JpdGhtIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1heENhbGxTdGFja0RlcHRoID0gNTAwLFxuICAgIG1heFRvdGFsQ2FsbFN0YWNrRGVwdGggPSAweEZGRkZGRkZGLFxuICAgIC8vIG1pbGxpc2Vjb25kc1xuICAgIHRpbWVTbGljZSA9IDEwXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuc2NoZWR1bGUgPSB7fTtcbiAgICB0aGlzLnNjaGVkdWxlLk1BWF9ERVBUSCA9IG1heENhbGxTdGFja0RlcHRoO1xuICAgIHRoaXMuc2NoZWR1bGUuTUFYX1RPVEFMX0RFUFRIID0gbWF4VG90YWxDYWxsU3RhY2tEZXB0aDtcbiAgICB0aGlzLnNjaGVkdWxlLmRlcHRoID0gMDtcbiAgICB0aGlzLnNjaGVkdWxlLnRvdGFsRGVwdGggPSAwO1xuICAgIHRoaXMuc2NoZWR1bGUudGltZVNsaWNlID0gdGltZVNsaWNlO1xuICB9XG5cbiAgLy8gZG8gc29tZSB3b3JrIGluIGEgdGltZSBzbGljZSwgYnV0IGluIHNlcmlhbFxuICBkb1dvcmsoZm4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2NoZWR1bGUgPSB0aGlzLnNjaGVkdWxlO1xuXG4gICAgaWYoc2NoZWR1bGUudG90YWxEZXB0aCA+PSBzY2hlZHVsZS5NQVhfVE9UQUxfREVQVEgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXG4gICAgICAgICdNYXhpbXVtIHRvdGFsIGNhbGwgc3RhY2sgZGVwdGggZXhjZWVkZWQ7IGNhbm9uaWNhbGl6YXRpb24gYWJvcnRpbmcuJykpO1xuICAgIH1cblxuICAgIChmdW5jdGlvbiB3b3JrKCkge1xuICAgICAgaWYoc2NoZWR1bGUuZGVwdGggPT09IHNjaGVkdWxlLk1BWF9ERVBUSCkge1xuICAgICAgICAvLyBzdGFjayB0b28gZGVlcCwgcnVuIG9uIG5leHQgdGlja1xuICAgICAgICBzY2hlZHVsZS5kZXB0aCA9IDA7XG4gICAgICAgIHNjaGVkdWxlLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHV0aWwubmV4dFRpY2sod29yayk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIG5vdCB5ZXQgcnVubmluZywgZm9yY2UgcnVuXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgaWYoIXNjaGVkdWxlLnJ1bm5pbmcpIHtcbiAgICAgICAgc2NoZWR1bGUuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICBzY2hlZHVsZS5kZWFkbGluZSA9IHNjaGVkdWxlLnN0YXJ0ICsgc2NoZWR1bGUudGltZVNsaWNlO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBzaG91bGQgYWxzbyBpbmNsdWRlIGFuIGVzdGltYXRlIG9mIGV4cGVjdGVkV29ya1RpbWVcbiAgICAgIGlmKG5vdyA8IHNjaGVkdWxlLmRlYWRsaW5lKSB7XG4gICAgICAgIHNjaGVkdWxlLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBzY2hlZHVsZS5kZXB0aCsrO1xuICAgICAgICBzY2hlZHVsZS50b3RhbERlcHRoKys7XG4gICAgICAgIHJldHVybiBmbigoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICBzY2hlZHVsZS5kZXB0aC0tO1xuICAgICAgICAgIHNjaGVkdWxlLnRvdGFsRGVwdGgtLTtcbiAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBub3QgZW5vdWdoIHRpbWUgbGVmdCBpbiB0aGlzIHNsaWNlLCBydW4gYWZ0ZXIgbGV0dGluZyBicm93c2VyXG4gICAgICAvLyBkbyBzb21lIG90aGVyIHRoaW5nc1xuICAgICAgc2NoZWR1bGUuZGVwdGggPSAwO1xuICAgICAgc2NoZWR1bGUucnVubmluZyA9IGZhbHNlO1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUod29yayk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8vIGFzeW5jaHJvbm91c2x5IGxvb3BcbiAgZm9yRWFjaChpdGVyYWJsZSwgZm4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGl0ZXJhdG9yO1xuICAgIGxldCBpZHggPSAwO1xuICAgIGxldCBsZW5ndGg7XG4gICAgaWYoQXJyYXkuaXNBcnJheShpdGVyYWJsZSkpIHtcbiAgICAgIGxlbmd0aCA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgICAgIGl0ZXJhdG9yID0gKCkgPT4ge1xuICAgICAgICBpZihpZHggPT09IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRvci52YWx1ZSA9IGl0ZXJhYmxlW2lkeCsrXTtcbiAgICAgICAgaXRlcmF0b3Iua2V5ID0gaWR4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdGVyYWJsZSk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIGl0ZXJhdG9yID0gKCkgPT4ge1xuICAgICAgICBpZihpZHggPT09IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRvci5rZXkgPSBrZXlzW2lkeCsrXTtcbiAgICAgICAgaXRlcmF0b3IudmFsdWUgPSBpdGVyYWJsZVtpdGVyYXRvci5rZXldO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgKGZ1bmN0aW9uIGl0ZXJhdGUoZXJyKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBpZihpdGVyYXRvcigpKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmRvV29yaygoKSA9PiBmbihpdGVyYXRvci52YWx1ZSwgaXRlcmF0b3Iua2V5LCBpdGVyYXRlKSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pKCk7XG4gIH1cblxuICAvLyBhc3luY2hyb25vdXMgd2F0ZXJmYWxsXG4gIHdhdGVyZmFsbChmbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5mb3JFYWNoKFxuICAgICAgZm5zLCAoZm4sIGlkeCwgY2FsbGJhY2spID0+IHNlbGYuZG9Xb3JrKGZuLCBjYWxsYmFjayksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIGFzeW5jaHJvbm91cyB3aGlsZVxuICB3aGlsc3QoY29uZGl0aW9uLCBmbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAoZnVuY3Rpb24gbG9vcChlcnIpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmKCFjb25kaXRpb24oKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZG9Xb3JrKGZuLCBsb29wKTtcbiAgICB9KSgpO1xuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIElkZW50aWZpZXJJc3N1ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJZGVudGlmaWVySXNzdWVyLiBBIElkZW50aWZpZXJJc3N1ZXIgaXNzdWVzIHVuaXF1ZVxuICAgKiBpZGVudGlmaWVycywga2VlcGluZyB0cmFjayBvZiBhbnkgcHJldmlvdXNseSBpc3N1ZWQgaWRlbnRpZmllcnMuXG4gICAqXG4gICAqIEBwYXJhbSBwcmVmaXggdGhlIHByZWZpeCB0byB1c2UgKCc8cHJlZml4Pjxjb3VudGVyPicpLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJlZml4KSB7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICB0aGlzLmV4aXN0aW5nID0ge307XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHRoaXMgSWRlbnRpZmllcklzc3Vlci5cbiAgICpcbiAgICogQHJldHVybiBhIGNvcHkgb2YgdGhpcyBJZGVudGlmaWVySXNzdWVyLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBJZGVudGlmaWVySXNzdWVyKHRoaXMucHJlZml4KTtcbiAgICBjb3B5LmNvdW50ZXIgPSB0aGlzLmNvdW50ZXI7XG4gICAgY29weS5leGlzdGluZyA9IHV0aWwuY2xvbmUodGhpcy5leGlzdGluZyk7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmV3IGlkZW50aWZpZXIgZm9yIHRoZSBnaXZlbiBvbGQgaWRlbnRpZmllciwgd2hlcmUgaWYgbm8gb2xkXG4gICAqIGlkZW50aWZpZXIgaXMgZ2l2ZW4gYSBuZXcgaWRlbnRpZmllciB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIFtvbGRdIHRoZSBvbGQgaWRlbnRpZmllciB0byBnZXQgdGhlIG5ldyBpZGVudGlmaWVyIGZvci5cbiAgICpcbiAgICogQHJldHVybiB0aGUgbmV3IGlkZW50aWZpZXIuXG4gICAqL1xuICBnZXRJZChvbGQpIHtcbiAgICAvLyByZXR1cm4gZXhpc3Rpbmcgb2xkIGlkZW50aWZpZXJcbiAgICBpZihvbGQgJiYgb2xkIGluIHRoaXMuZXhpc3RpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4aXN0aW5nW29sZF07XG4gICAgfVxuXG4gICAgLy8gZ2V0IG5leHQgaWRlbnRpZmllclxuICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLnByZWZpeCArIHRoaXMuY291bnRlcjtcbiAgICB0aGlzLmNvdW50ZXIgKz0gMTtcblxuICAgIC8vIHNhdmUgbWFwcGluZ1xuICAgIGlmKG9sZCkge1xuICAgICAgdGhpcy5leGlzdGluZ1tvbGRdID0gaWRlbnRpZmllcjtcbiAgICB9XG5cbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9sZCBpZGVudGlmZXIgaGFzIGFscmVhZHkgYmVlbiBhc3NpZ25lZCBhIG5ld1xuICAgKiBpZGVudGlmaWVyLlxuICAgKlxuICAgKiBAcGFyYW0gb2xkIHRoZSBvbGQgaWRlbnRpZmllciB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBvbGQgaWRlbnRpZmllciBoYXMgYmVlbiBhc3NpZ25lZCBhIG5ldyBpZGVudGlmaWVyLFxuICAgKiAgIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGhhc0lkKG9sZCkge1xuICAgIHJldHVybiAob2xkIGluIHRoaXMuZXhpc3RpbmcpO1xuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgZm9yZ2UgPSByZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9mb3JnZScpO1xucmVxdWlyZSgnbm9kZS1mb3JnZS9saWIvbWQnKTtcbnJlcXVpcmUoJ25vZGUtZm9yZ2UvbGliL3NoYTEnKTtcbnJlcXVpcmUoJ25vZGUtZm9yZ2UvbGliL3NoYTI1NicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1lc3NhZ2VEaWdlc3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBNZXNzYWdlRGlnZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYWxnb3JpdGhtKSB7XG4gICAgdGhpcy5tZCA9IGZvcmdlLm1kW2FsZ29yaXRobV0uY3JlYXRlKCk7XG4gIH1cblxuICB1cGRhdGUobXNnKSB7XG4gICAgdGhpcy5tZC51cGRhdGUobXNnLCAndXRmOCcpO1xuICB9XG5cbiAgZGlnZXN0KCkge1xuICAgIHJldHVybiB0aGlzLm1kLmRpZ2VzdCgpLnRvSGV4KCk7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmNvbnN0IFRFUk1TID0gWydzdWJqZWN0JywgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCAnZ3JhcGgnXTtcbmNvbnN0IFJERiA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjJztcbmNvbnN0IFJERl9MQU5HU1RSSU5HID0gUkRGICsgJ2xhbmdTdHJpbmcnO1xuY29uc3QgWFNEX1NUUklORyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNzdHJpbmcnO1xuXG4vLyBidWlsZCByZWdleGVzXG5jb25zdCBSRUdFWCA9IHt9O1xuKCgpID0+IHtcbiAgY29uc3QgaXJpID0gJyg/OjwoW146XSs6W14+XSopPiknO1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvdHVydGxlLyNncmFtbWFyLXByb2R1Y3Rpb24tQkxBTktfTk9ERV9MQUJFTFxuICBjb25zdCBQTl9DSEFSU19CQVNFID1cbiAgICAnQS1aJyArICdhLXonICtcbiAgICAnXFx1MDBDMC1cXHUwMEQ2JyArXG4gICAgJ1xcdTAwRDgtXFx1MDBGNicgK1xuICAgICdcXHUwMEY4LVxcdTAyRkYnICtcbiAgICAnXFx1MDM3MC1cXHUwMzdEJyArXG4gICAgJ1xcdTAzN0YtXFx1MUZGRicgK1xuICAgICdcXHUyMDBDLVxcdTIwMEQnICtcbiAgICAnXFx1MjA3MC1cXHUyMThGJyArXG4gICAgJ1xcdTJDMDAtXFx1MkZFRicgK1xuICAgICdcXHUzMDAxLVxcdUQ3RkYnICtcbiAgICAnXFx1RjkwMC1cXHVGRENGJyArXG4gICAgJ1xcdUZERjAtXFx1RkZGRCc7XG4gICAgLy8gVE9ETzpcbiAgICAvLydcXHUxMDAwMC1cXHVFRkZGRic7XG4gIGNvbnN0IFBOX0NIQVJTX1UgPVxuICAgIFBOX0NIQVJTX0JBU0UgK1xuICAgICdfJztcbiAgY29uc3QgUE5fQ0hBUlMgPVxuICAgIFBOX0NIQVJTX1UgK1xuICAgICcwLTknICtcbiAgICAnLScgK1xuICAgICdcXHUwMEI3JyArXG4gICAgJ1xcdTAzMDAtXFx1MDM2RicgK1xuICAgICdcXHUyMDNGLVxcdTIwNDAnO1xuICBjb25zdCBCTEFOS19OT0RFX0xBQkVMID1cbiAgICAnKF86JyArXG4gICAgICAnKD86WycgKyBQTl9DSEFSU19VICsgJzAtOV0pJyArXG4gICAgICAnKD86KD86WycgKyBQTl9DSEFSUyArICcuXSkqKD86WycgKyBQTl9DSEFSUyArICddKSk/JyArXG4gICAgJyknO1xuICBjb25zdCBibm9kZSA9IEJMQU5LX05PREVfTEFCRUw7XG4gIGNvbnN0IHBsYWluID0gJ1wiKFteXCJcXFxcXFxcXF0qKD86XFxcXFxcXFwuW15cIlxcXFxcXFxcXSopKilcIic7XG4gIGNvbnN0IGRhdGF0eXBlID0gJyg/OlxcXFxeXFxcXF4nICsgaXJpICsgJyknO1xuICBjb25zdCBsYW5ndWFnZSA9ICcoPzpAKFthLXpBLVpdKyg/Oi1bYS16QS1aMC05XSspKikpJztcbiAgY29uc3QgbGl0ZXJhbCA9ICcoPzonICsgcGxhaW4gKyAnKD86JyArIGRhdGF0eXBlICsgJ3wnICsgbGFuZ3VhZ2UgKyAnKT8pJztcbiAgY29uc3Qgd3MgPSAnWyBcXFxcdF0rJztcbiAgY29uc3Qgd3NvID0gJ1sgXFxcXHRdKic7XG5cbiAgLy8gZGVmaW5lIHF1YWQgcGFydCByZWdleGVzXG4gIGNvbnN0IHN1YmplY3QgPSAnKD86JyArIGlyaSArICd8JyArIGJub2RlICsgJyknICsgd3M7XG4gIGNvbnN0IHByb3BlcnR5ID0gaXJpICsgd3M7XG4gIGNvbnN0IG9iamVjdCA9ICcoPzonICsgaXJpICsgJ3wnICsgYm5vZGUgKyAnfCcgKyBsaXRlcmFsICsgJyknICsgd3NvO1xuICBjb25zdCBncmFwaE5hbWUgPSAnKD86XFxcXC58KD86KD86JyArIGlyaSArICd8JyArIGJub2RlICsgJyknICsgd3NvICsgJ1xcXFwuKSknO1xuXG4gIC8vIGVuZCBvZiBsaW5lIGFuZCBlbXB0eSByZWdleGVzXG4gIFJFR0VYLmVvbG4gPSAvKD86XFxyXFxuKXwoPzpcXG4pfCg/OlxccikvZztcbiAgUkVHRVguZW1wdHkgPSBuZXcgUmVnRXhwKCdeJyArIHdzbyArICckJyk7XG5cbiAgLy8gZnVsbCBxdWFkIHJlZ2V4XG4gIFJFR0VYLnF1YWQgPSBuZXcgUmVnRXhwKFxuICAgICdeJyArIHdzbyArIHN1YmplY3QgKyBwcm9wZXJ0eSArIG9iamVjdCArIGdyYXBoTmFtZSArIHdzbyArICckJyk7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE5RdWFkcyB7XG4gIC8qKlxuICAgKiBQYXJzZXMgUkRGIGluIHRoZSBmb3JtIG9mIE4tUXVhZHMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dCB0aGUgTi1RdWFkcyBpbnB1dCB0byBwYXJzZS5cbiAgICpcbiAgICogQHJldHVybiBhbiBSREYgZGF0YXNldCAoYW4gYXJyYXkgb2YgcXVhZHMgcGVyIGh0dHA6Ly9yZGYuanMub3JnLykuXG4gICAqL1xuICBzdGF0aWMgcGFyc2UoaW5wdXQpIHtcbiAgICAvLyBidWlsZCBSREYgZGF0YXNldFxuICAgIGNvbnN0IGRhdGFzZXQgPSBbXTtcblxuICAgIGNvbnN0IGdyYXBocyA9IHt9O1xuXG4gICAgLy8gc3BsaXQgTi1RdWFkIGlucHV0IGludG8gbGluZXNcbiAgICBjb25zdCBsaW5lcyA9IGlucHV0LnNwbGl0KFJFR0VYLmVvbG4pO1xuICAgIGxldCBsaW5lTnVtYmVyID0gMDtcbiAgICBmb3IoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgbGluZU51bWJlcisrO1xuXG4gICAgICAvLyBza2lwIGVtcHR5IGxpbmVzXG4gICAgICBpZihSRUdFWC5lbXB0eS50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBxdWFkXG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goUkVHRVgucXVhZCk7XG4gICAgICBpZihtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ04tUXVhZHMgcGFyc2UgZXJyb3Igb24gbGluZSAnICsgbGluZU51bWJlciArICcuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSBSREYgcXVhZFxuICAgICAgY29uc3QgcXVhZCA9IHt9O1xuXG4gICAgICAvLyBnZXQgc3ViamVjdFxuICAgICAgaWYobWF0Y2hbMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBxdWFkLnN1YmplY3QgPSB7dGVybVR5cGU6ICdOYW1lZE5vZGUnLCB2YWx1ZTogbWF0Y2hbMV19O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVhZC5zdWJqZWN0ID0ge3Rlcm1UeXBlOiAnQmxhbmtOb2RlJywgdmFsdWU6IG1hdGNoWzJdfTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IHByZWRpY2F0ZVxuICAgICAgcXVhZC5wcmVkaWNhdGUgPSB7dGVybVR5cGU6ICdOYW1lZE5vZGUnLCB2YWx1ZTogbWF0Y2hbM119O1xuXG4gICAgICAvLyBnZXQgb2JqZWN0XG4gICAgICBpZihtYXRjaFs0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1YWQub2JqZWN0ID0ge3Rlcm1UeXBlOiAnTmFtZWROb2RlJywgdmFsdWU6IG1hdGNoWzRdfTtcbiAgICAgIH0gZWxzZSBpZihtYXRjaFs1XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1YWQub2JqZWN0ID0ge3Rlcm1UeXBlOiAnQmxhbmtOb2RlJywgdmFsdWU6IG1hdGNoWzVdfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1YWQub2JqZWN0ID0ge1xuICAgICAgICAgIHRlcm1UeXBlOiAnTGl0ZXJhbCcsXG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkYXRhdHlwZToge1xuICAgICAgICAgICAgdGVybVR5cGU6ICdOYW1lZE5vZGUnXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZihtYXRjaFs3XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcXVhZC5vYmplY3QuZGF0YXR5cGUudmFsdWUgPSBtYXRjaFs3XTtcbiAgICAgICAgfSBlbHNlIGlmKG1hdGNoWzhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBxdWFkLm9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IFJERl9MQU5HU1RSSU5HO1xuICAgICAgICAgIHF1YWQub2JqZWN0Lmxhbmd1YWdlID0gbWF0Y2hbOF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVhZC5vYmplY3QuZGF0YXR5cGUudmFsdWUgPSBYU0RfU1RSSU5HO1xuICAgICAgICB9XG4gICAgICAgIHF1YWQub2JqZWN0LnZhbHVlID0gX3VuZXNjYXBlKG1hdGNoWzZdKTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGdyYXBoXG4gICAgICBpZihtYXRjaFs5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1YWQuZ3JhcGggPSB7XG4gICAgICAgICAgdGVybVR5cGU6ICdOYW1lZE5vZGUnLFxuICAgICAgICAgIHZhbHVlOiBtYXRjaFs5XVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmKG1hdGNoWzEwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1YWQuZ3JhcGggPSB7XG4gICAgICAgICAgdGVybVR5cGU6ICdCbGFua05vZGUnLFxuICAgICAgICAgIHZhbHVlOiBtYXRjaFsxMF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1YWQuZ3JhcGggPSB7XG4gICAgICAgICAgdGVybVR5cGU6ICdEZWZhdWx0R3JhcGgnLFxuICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGFkZCBxdWFkIGlmIGl0IGlzIHVuaXF1ZSBpbiBpdHMgZ3JhcGhcbiAgICAgIGlmKCEocXVhZC5ncmFwaC52YWx1ZSBpbiBncmFwaHMpKSB7XG4gICAgICAgIGdyYXBoc1txdWFkLmdyYXBoLnZhbHVlXSA9IFtxdWFkXTtcbiAgICAgICAgZGF0YXNldC5wdXNoKHF1YWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHF1YWRzID0gZ3JhcGhzW3F1YWQuZ3JhcGgudmFsdWVdO1xuICAgICAgICBmb3IoY29uc3QgcSBvZiBxdWFkcykge1xuICAgICAgICAgIGlmKF9jb21wYXJlVHJpcGxlcyhxLCBxdWFkKSkge1xuICAgICAgICAgICAgdW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYodW5pcXVlKSB7XG4gICAgICAgICAgcXVhZHMucHVzaChxdWFkKTtcbiAgICAgICAgICBkYXRhc2V0LnB1c2gocXVhZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YXNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBSREYgZGF0YXNldCB0byBOLVF1YWRzLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YXNldCAoYXJyYXkgb2YgcXVhZHMpIHRoZSBSREYgZGF0YXNldCB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBOLVF1YWRzIHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyBzZXJpYWxpemUoZGF0YXNldCkge1xuICAgIGlmKCFBcnJheS5pc0FycmF5KGRhdGFzZXQpKSB7XG4gICAgICBkYXRhc2V0ID0gTlF1YWRzLmxlZ2FjeURhdGFzZXRUb1F1YWRzKGRhdGFzZXQpO1xuICAgIH1cbiAgICBjb25zdCBxdWFkcyA9IFtdO1xuICAgIGZvcihjb25zdCBxdWFkIG9mIGRhdGFzZXQpIHtcbiAgICAgIHF1YWRzLnB1c2goTlF1YWRzLnNlcmlhbGl6ZVF1YWQocXVhZCkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVhZHMuc29ydCgpLmpvaW4oJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIFJERiBxdWFkIHRvIGFuIE4tUXVhZCBzdHJpbmcgKGEgc2luZ2xlIHF1YWQpLlxuICAgKlxuICAgKiBAcGFyYW0gcXVhZCB0aGUgUkRGIHF1YWQgY29udmVydC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgTi1RdWFkIHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyBzZXJpYWxpemVRdWFkKHF1YWQpIHtcbiAgICBjb25zdCBzID0gcXVhZC5zdWJqZWN0O1xuICAgIGNvbnN0IHAgPSBxdWFkLnByZWRpY2F0ZTtcbiAgICBjb25zdCBvID0gcXVhZC5vYmplY3Q7XG4gICAgY29uc3QgZyA9IHF1YWQuZ3JhcGg7XG5cbiAgICBsZXQgbnF1YWQgPSAnJztcblxuICAgIC8vIHN1YmplY3QgYW5kIHByZWRpY2F0ZSBjYW4gb25seSBiZSBOYW1lZE5vZGUgb3IgQmxhbmtOb2RlXG4gICAgW3MsIHBdLmZvckVhY2godGVybSA9PiB7XG4gICAgICBpZih0ZXJtLnRlcm1UeXBlID09PSAnTmFtZWROb2RlJykge1xuICAgICAgICBucXVhZCArPSAnPCcgKyB0ZXJtLnZhbHVlICsgJz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnF1YWQgKz0gdGVybS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIG5xdWFkICs9ICcgJztcbiAgICB9KTtcblxuICAgIC8vIG9iamVjdCBpcyBOYW1lZE5vZGUsIEJsYW5rTm9kZSwgb3IgTGl0ZXJhbFxuICAgIGlmKG8udGVybVR5cGUgPT09ICdOYW1lZE5vZGUnKSB7XG4gICAgICBucXVhZCArPSAnPCcgKyBvLnZhbHVlICsgJz4nO1xuICAgIH0gZWxzZSBpZihvLnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJykge1xuICAgICAgbnF1YWQgKz0gby52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnF1YWQgKz0gJ1wiJyArIF9lc2NhcGUoby52YWx1ZSkgKyAnXCInO1xuICAgICAgaWYoby5kYXRhdHlwZS52YWx1ZSA9PT0gUkRGX0xBTkdTVFJJTkcpIHtcbiAgICAgICAgaWYoby5sYW5ndWFnZSkge1xuICAgICAgICAgIG5xdWFkICs9ICdAJyArIG8ubGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihvLmRhdGF0eXBlLnZhbHVlICE9PSBYU0RfU1RSSU5HKSB7XG4gICAgICAgIG5xdWFkICs9ICdeXjwnICsgby5kYXRhdHlwZS52YWx1ZSArICc+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBncmFwaCBjYW4gb25seSBiZSBOYW1lZE5vZGUgb3IgQmxhbmtOb2RlIChvciBEZWZhdWx0R3JhcGgsIGJ1dCB0aGF0XG4gICAgLy8gZG9lcyBub3QgYWRkIHRvIGBucXVhZGApXG4gICAgaWYoZy50ZXJtVHlwZSA9PT0gJ05hbWVkTm9kZScpIHtcbiAgICAgIG5xdWFkICs9ICcgPCcgKyBnLnZhbHVlICsgJz4nO1xuICAgIH0gZWxzZSBpZihnLnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJykge1xuICAgICAgbnF1YWQgKz0gJyAnICsgZy52YWx1ZTtcbiAgICB9XG5cbiAgICBucXVhZCArPSAnIC5cXG4nO1xuICAgIHJldHVybiBucXVhZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGxlZ2FjeS1mb3JtYXR0ZWQgZGF0YXNldCB0byBhbiBhcnJheSBvZiBxdWFkcyBkYXRhc2V0IHBlclxuICAgKiBodHRwOi8vcmRmLmpzLm9yZy8uXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhc2V0IHRoZSBsZWdhY3kgZGF0YXNldCB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBhcnJheSBvZiBxdWFkcyBkYXRhc2V0LlxuICAgKi9cbiAgc3RhdGljIGxlZ2FjeURhdGFzZXRUb1F1YWRzKGRhdGFzZXQpIHtcbiAgICBjb25zdCBxdWFkcyA9IFtdO1xuXG4gICAgY29uc3QgdGVybVR5cGVNYXAgPSB7XG4gICAgICAnYmxhbmsgbm9kZSc6ICdCbGFua05vZGUnLFxuICAgICAgSVJJOiAnTmFtZWROb2RlJyxcbiAgICAgIGxpdGVyYWw6ICdMaXRlcmFsJ1xuICAgIH07XG5cbiAgICBmb3IoY29uc3QgZ3JhcGhOYW1lIGluIGRhdGFzZXQpIHtcbiAgICAgIGNvbnN0IHRyaXBsZXMgPSBkYXRhc2V0W2dyYXBoTmFtZV07XG4gICAgICB0cmlwbGVzLmZvckVhY2godHJpcGxlID0+IHtcbiAgICAgICAgY29uc3QgcXVhZCA9IHt9O1xuICAgICAgICBmb3IoY29uc3QgY29tcG9uZW50TmFtZSBpbiB0cmlwbGUpIHtcbiAgICAgICAgICBjb25zdCBvbGRDb21wb25lbnQgPSB0cmlwbGVbY29tcG9uZW50TmFtZV07XG4gICAgICAgICAgY29uc3QgbmV3Q29tcG9uZW50ID0ge1xuICAgICAgICAgICAgdGVybVR5cGU6IHRlcm1UeXBlTWFwW29sZENvbXBvbmVudC50eXBlXSxcbiAgICAgICAgICAgIHZhbHVlOiBvbGRDb21wb25lbnQudmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmKG5ld0NvbXBvbmVudC50ZXJtVHlwZSA9PT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICBuZXdDb21wb25lbnQuZGF0YXR5cGUgPSB7XG4gICAgICAgICAgICAgIHRlcm1UeXBlOiAnTmFtZWROb2RlJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmKCdkYXRhdHlwZScgaW4gb2xkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIG5ld0NvbXBvbmVudC5kYXRhdHlwZS52YWx1ZSA9IG9sZENvbXBvbmVudC5kYXRhdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCdsYW5ndWFnZScgaW4gb2xkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIGlmKCEoJ2RhdGF0eXBlJyBpbiBvbGRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29tcG9uZW50LmRhdGF0eXBlLnZhbHVlID0gUkRGX0xBTkdTVFJJTkc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV3Q29tcG9uZW50Lmxhbmd1YWdlID0gb2xkQ29tcG9uZW50Lmxhbmd1YWdlO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCEoJ2RhdGF0eXBlJyBpbiBvbGRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIG5ld0NvbXBvbmVudC5kYXRhdHlwZS52YWx1ZSA9IFhTRF9TVFJJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1YWRbY29tcG9uZW50TmFtZV0gPSBuZXdDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZ3JhcGhOYW1lID09PSAnQGRlZmF1bHQnKSB7XG4gICAgICAgICAgcXVhZC5ncmFwaCA9IHtcbiAgICAgICAgICAgIHRlcm1UeXBlOiAnRGVmYXVsdEdyYXBoJyxcbiAgICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVhZC5ncmFwaCA9IHtcbiAgICAgICAgICAgIHRlcm1UeXBlOiBncmFwaE5hbWUuc3RhcnRzV2l0aCgnXzonKSA/ICdCbGFua05vZGUnIDogJ05hbWVkTm9kZScsXG4gICAgICAgICAgICB2YWx1ZTogZ3JhcGhOYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBxdWFkcy5wdXNoKHF1YWQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1YWRzO1xuICB9XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHR3byBSREYgdHJpcGxlcyBmb3IgZXF1YWxpdHkuXG4gKlxuICogQHBhcmFtIHQxIHRoZSBmaXJzdCB0cmlwbGUuXG4gKiBAcGFyYW0gdDIgdGhlIHNlY29uZCB0cmlwbGUuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB0cmlwbGVzIGFyZSB0aGUgc2FtZSwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfY29tcGFyZVRyaXBsZXModDEsIHQyKSB7XG4gIGZvcihjb25zdCBrIGluIHQxKSB7XG4gICAgaWYodDFba10udGVybVR5cGUgIT09IHQyW2tdLnRlcm1UeXBlIHx8IHQxW2tdLnZhbHVlICE9PSB0MltrXS52YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZih0MS5vYmplY3QudGVybVR5cGUgIT09ICdMaXRlcmFsJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiAoXG4gICAgKHQxLm9iamVjdC5kYXRhdHlwZS50ZXJtVHlwZSA9PT0gdDIub2JqZWN0LmRhdGF0eXBlLnRlcm1UeXBlKSAmJlxuICAgICh0MS5vYmplY3QuZGF0YXR5cGUudmFsdWUgPT09IHQyLm9iamVjdC5kYXRhdHlwZS52YWx1ZSkgJiZcbiAgICAodDEub2JqZWN0Lmxhbmd1YWdlID09PSB0Mi5vYmplY3QubGFuZ3VhZ2UpXG4gICk7XG59XG5cbmNvbnN0IF9lc2NhcGVSZWdleCA9IC9bXCJcXFxcXFxuXFxyXS9nO1xuLyoqXG4gKiBFc2NhcGUgc3RyaW5nIHRvIE4tUXVhZHMgbGl0ZXJhbFxuICovXG5mdW5jdGlvbiBfZXNjYXBlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShfZXNjYXBlUmVnZXgsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgc3dpdGNoKG1hdGNoKSB7XG4gICAgICBjYXNlICdcIic6IHJldHVybiAnXFxcXFwiJztcbiAgICAgIGNhc2UgJ1xcXFwnOiByZXR1cm4gJ1xcXFxcXFxcJztcbiAgICAgIGNhc2UgJ1xcbic6IHJldHVybiAnXFxcXG4nO1xuICAgICAgY2FzZSAnXFxyJzogcmV0dXJuICdcXFxccic7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgX3VuZXNjYXBlUmVnZXggPVxuICAvKD86XFxcXChbdGJucmZcIidcXFxcXSkpfCg/OlxcXFx1KFswLTlBLUZhLWZdezR9KSl8KD86XFxcXFUoWzAtOUEtRmEtZl17OH0pKS9nO1xuLyoqXG4gKiBVbmVzY2FwZSBOLVF1YWRzIGxpdGVyYWwgdG8gc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIF91bmVzY2FwZShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoX3VuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBjb2RlLCB1LCBVKSB7XG4gICAgaWYoY29kZSkge1xuICAgICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAndCc6IHJldHVybiAnXFx0JztcbiAgICAgICAgY2FzZSAnYic6IHJldHVybiAnXFxiJztcbiAgICAgICAgY2FzZSAnbic6IHJldHVybiAnXFxuJztcbiAgICAgICAgY2FzZSAncic6IHJldHVybiAnXFxyJztcbiAgICAgICAgY2FzZSAnZic6IHJldHVybiAnXFxmJztcbiAgICAgICAgY2FzZSAnXCInOiByZXR1cm4gJ1wiJztcbiAgICAgICAgY2FzZSAnXFwnJzogcmV0dXJuICdcXCcnO1xuICAgICAgICBjYXNlICdcXFxcJzogcmV0dXJuICdcXFxcJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodSwgMTYpKTtcbiAgICB9XG4gICAgaWYoVSkge1xuICAgICAgLy8gRklYTUU6IHN1cHBvcnQgbGFyZ2VyIHZhbHVlc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBVIGVzY2FwZScpO1xuICAgIH1cbiAgfSk7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOiBjb252ZXJ0IHRvIEVTNiBpdGVyYWJsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBlcm11dGF0b3Ige1xuICAvKipcbiAgICogQSBQZXJtdXRhdG9yIGl0ZXJhdGVzIG92ZXIgYWxsIHBvc3NpYmxlIHBlcm11dGF0aW9ucyBvZiB0aGUgZ2l2ZW4gYXJyYXlcbiAgICogb2YgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0IHRoZSBhcnJheSBvZiBlbGVtZW50cyB0byBpdGVyYXRlIG92ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsaXN0KSB7XG4gICAgLy8gb3JpZ2luYWwgYXJyYXlcbiAgICB0aGlzLmxpc3QgPSBsaXN0LnNvcnQoKTtcbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZSBwZXJtdXRhdGlvbnNcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAvLyBkaXJlY3Rpb25hbCBpbmZvIGZvciBwZXJtdXRhdGlvbiBhbGdvcml0aG1cbiAgICB0aGlzLmxlZnQgPSB7fTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5sZWZ0W2xpc3RbaV1dID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGFub3RoZXIgcGVybXV0YXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhbm90aGVyIHBlcm11dGF0aW9uLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBoYXNOZXh0KCkge1xuICAgIHJldHVybiAhdGhpcy5kb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5leHQgcGVybXV0YXRpb24uIENhbGwgaGFzTmV4dCgpIHRvIGVuc3VyZSB0aGVyZSBpcyBhbm90aGVyIG9uZVxuICAgKiBmaXJzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgbmV4dCBwZXJtdXRhdGlvbi5cbiAgICovXG4gIG5leHQoKSB7XG4gICAgLy8gY29weSBjdXJyZW50IHBlcm11dGF0aW9uXG4gICAgY29uc3QgcnZhbCA9IHRoaXMubGlzdC5zbGljZSgpO1xuXG4gICAgLyogQ2FsY3VsYXRlIHRoZSBuZXh0IHBlcm11dGF0aW9uIHVzaW5nIHRoZSBTdGVpbmhhdXMtSm9obnNvbi1Ucm90dGVyXG4gICAgIHBlcm11dGF0aW9uIGFsZ29yaXRobS4gKi9cblxuICAgIC8vIGdldCBsYXJnZXN0IG1vYmlsZSBlbGVtZW50IGtcbiAgICAvLyAobW9iaWxlOiBlbGVtZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgb25lIGl0IGlzIGxvb2tpbmcgYXQpXG4gICAgbGV0IGsgPSBudWxsO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGlzdC5sZW5ndGg7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5saXN0W2ldO1xuICAgICAgY29uc3QgbGVmdCA9IHRoaXMubGVmdFtlbGVtZW50XTtcbiAgICAgIGlmKChrID09PSBudWxsIHx8IGVsZW1lbnQgPiBrKSAmJlxuICAgICAgICAoKGxlZnQgJiYgaSA+IDAgJiYgZWxlbWVudCA+IHRoaXMubGlzdFtpIC0gMV0pIHx8XG4gICAgICAgICghbGVmdCAmJiBpIDwgKGxlbmd0aCAtIDEpICYmIGVsZW1lbnQgPiB0aGlzLmxpc3RbaSArIDFdKSkpIHtcbiAgICAgICAgayA9IGVsZW1lbnQ7XG4gICAgICAgIHBvcyA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm8gbW9yZSBwZXJtdXRhdGlvbnNcbiAgICBpZihrID09PSBudWxsKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzd2FwIGsgYW5kIHRoZSBlbGVtZW50IGl0IGlzIGxvb2tpbmcgYXRcbiAgICAgIGNvbnN0IHN3YXAgPSB0aGlzLmxlZnRba10gPyBwb3MgLSAxIDogcG9zICsgMTtcbiAgICAgIHRoaXMubGlzdFtwb3NdID0gdGhpcy5saXN0W3N3YXBdO1xuICAgICAgdGhpcy5saXN0W3N3YXBdID0gaztcblxuICAgICAgLy8gcmV2ZXJzZSB0aGUgZGlyZWN0aW9uIG9mIGFsbCBlbGVtZW50cyBsYXJnZXIgdGhhbiBrXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYodGhpcy5saXN0W2ldID4gaykge1xuICAgICAgICAgIHRoaXMubGVmdFt0aGlzLmxpc3RbaV1dID0gIXRoaXMubGVmdFt0aGlzLmxpc3RbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cbn07XG5cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzeW5jQWxnb3JpdGhtID0gcmVxdWlyZSgnLi9Bc3luY0FsZ29yaXRobScpO1xuY29uc3QgSWRlbnRpZmllcklzc3VlciA9IHJlcXVpcmUoJy4vSWRlbnRpZmllcklzc3VlcicpO1xuY29uc3QgTWVzc2FnZURpZ2VzdCA9IHJlcXVpcmUoJy4vTWVzc2FnZURpZ2VzdCcpO1xuY29uc3QgUGVybXV0YXRvciA9IHJlcXVpcmUoJy4vUGVybXV0YXRvcicpO1xuY29uc3QgTlF1YWRzID0gcmVxdWlyZSgnLi9OUXVhZHMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuY29uc3QgUE9TSVRJT05TID0ge3N1YmplY3Q6ICdzJywgb2JqZWN0OiAnbycsIGdyYXBoOiAnZyd9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFVSRE5BMjAxNSBleHRlbmRzIEFzeW5jQWxnb3JpdGhtIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMubmFtZSA9ICdVUkROQTIwMTUnO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIHRoaXMuYmxhbmtOb2RlSW5mbyA9IHt9O1xuICAgIHRoaXMuaGFzaFRvQmxhbmtOb2RlcyA9IHt9O1xuICAgIHRoaXMuY2Fub25pY2FsSXNzdWVyID0gbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YzE0bicpO1xuICAgIHRoaXMuaGFzaEFsZ29yaXRobSA9ICdzaGEyNTYnO1xuICAgIHRoaXMucXVhZHM7XG4gIH1cblxuICAvLyA0LjQpIE5vcm1hbGl6YXRpb24gQWxnb3JpdGhtXG4gIG1haW4oZGF0YXNldCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBzZWxmLnNjaGVkdWxlLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHNlbGYucXVhZHMgPSBkYXRhc2V0O1xuXG4gICAgLy8gMSkgQ3JlYXRlIHRoZSBub3JtYWxpemF0aW9uIHN0YXRlLlxuXG4gICAgLy8gTm90ZTogT3B0aW1pemUgYnkgZ2VuZXJhdGluZyBub24tbm9ybWFsaXplZCBibGFuayBub2RlIG1hcCBjb25jdXJyZW50bHkuXG4gICAgY29uc3Qgbm9uTm9ybWFsaXplZCA9IHt9O1xuXG4gICAgc2VsZi53YXRlcmZhbGwoW1xuICAgICAgY2FsbGJhY2sgPT4ge1xuICAgICAgICAvLyAyKSBGb3IgZXZlcnkgcXVhZCBpbiBpbnB1dCBkYXRhc2V0OlxuICAgICAgICBzZWxmLmZvckVhY2goZGF0YXNldCwgKHF1YWQsIGlkeCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAvLyAyLjEpIEZvciBlYWNoIGJsYW5rIG5vZGUgdGhhdCBvY2N1cnMgaW4gdGhlIHF1YWQsIGFkZCBhIHJlZmVyZW5jZVxuICAgICAgICAgIC8vIHRvIHRoZSBxdWFkIHVzaW5nIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgaW4gdGhlIGJsYW5rIG5vZGUgdG9cbiAgICAgICAgICAvLyBxdWFkcyBtYXAsIGNyZWF0aW5nIGEgbmV3IGVudHJ5IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICBzZWxmLmZvckVhY2hDb21wb25lbnQocXVhZCwgY29tcG9uZW50ID0+IHtcbiAgICAgICAgICAgIGlmKGNvbXBvbmVudC50ZXJtVHlwZSAhPT0gJ0JsYW5rTm9kZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSBjb21wb25lbnQudmFsdWU7XG4gICAgICAgICAgICBpZihpZCBpbiBzZWxmLmJsYW5rTm9kZUluZm8pIHtcbiAgICAgICAgICAgICAgc2VsZi5ibGFua05vZGVJbmZvW2lkXS5xdWFkcy5wdXNoKHF1YWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9uTm9ybWFsaXplZFtpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBzZWxmLmJsYW5rTm9kZUluZm9baWRdID0ge3F1YWRzOiBbcXVhZF19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgfSxcbiAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgLy8gMykgQ3JlYXRlIGEgbGlzdCBvZiBub24tbm9ybWFsaXplZCBibGFuayBub2RlIGlkZW50aWZpZXJzXG4gICAgICAgIC8vIG5vbi1ub3JtYWxpemVkIGlkZW50aWZpZXJzIGFuZCBwb3B1bGF0ZSBpdCB1c2luZyB0aGUga2V5cyBmcm9tIHRoZVxuICAgICAgICAvLyBibGFuayBub2RlIHRvIHF1YWRzIG1hcC5cbiAgICAgICAgLy8gTm90ZTogV2UgdXNlIGEgbWFwIGhlcmUgYW5kIGl0IHdhcyBnZW5lcmF0ZWQgZHVyaW5nIHN0ZXAgMi5cblxuICAgICAgICAvLyA0KSBJbml0aWFsaXplIHNpbXBsZSwgYSBib29sZWFuIGZsYWcsIHRvIHRydWUuXG4gICAgICAgIGxldCBzaW1wbGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIDUpIFdoaWxlIHNpbXBsZSBpcyB0cnVlLCBpc3N1ZSBjYW5vbmljYWwgaWRlbnRpZmllcnMgZm9yIGJsYW5rIG5vZGVzOlxuICAgICAgICBzZWxmLndoaWxzdCgoKSA9PiBzaW1wbGUsIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAvLyA1LjEpIFNldCBzaW1wbGUgdG8gZmFsc2UuXG4gICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyA1LjIpIENsZWFyIGhhc2ggdG8gYmxhbmsgbm9kZXMgbWFwLlxuICAgICAgICAgIHNlbGYuaGFzaFRvQmxhbmtOb2RlcyA9IHt9O1xuXG4gICAgICAgICAgc2VsZi53YXRlcmZhbGwoW1xuICAgICAgICAgICAgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICAvLyA1LjMpIEZvciBlYWNoIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpZGVudGlmaWVyIGluXG4gICAgICAgICAgICAgIC8vIG5vbi1ub3JtYWxpemVkIGlkZW50aWZpZXJzOlxuICAgICAgICAgICAgICBzZWxmLmZvckVhY2gobm9uTm9ybWFsaXplZCwgKHZhbHVlLCBpZCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAvLyA1LjMuMSkgQ3JlYXRlIGEgaGFzaCwgaGFzaCwgYWNjb3JkaW5nIHRvIHRoZSBIYXNoIEZpcnN0XG4gICAgICAgICAgICAgICAgLy8gRGVncmVlIFF1YWRzIGFsZ29yaXRobS5cbiAgICAgICAgICAgICAgICBzZWxmLmhhc2hGaXJzdERlZ3JlZVF1YWRzKGlkLCAoZXJyLCBoYXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyA1LjMuMikgQWRkIGhhc2ggYW5kIGlkZW50aWZpZXIgdG8gaGFzaCB0byBibGFuayBub2RlcyBtYXAsXG4gICAgICAgICAgICAgICAgICAvLyBjcmVhdGluZyBhIG5ldyBlbnRyeSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgICBpZihoYXNoIGluIHNlbGYuaGFzaFRvQmxhbmtOb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhhc2hUb0JsYW5rTm9kZXNbaGFzaF0ucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhhc2hUb0JsYW5rTm9kZXNbaGFzaF0gPSBbaWRdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgLy8gNS40KSBGb3IgZWFjaCBoYXNoIHRvIGlkZW50aWZpZXIgbGlzdCBtYXBwaW5nIGluIGhhc2ggdG8gYmxhbmtcbiAgICAgICAgICAgICAgLy8gbm9kZXMgbWFwLCBsZXhpY29ncmFwaGljYWxseS1zb3J0ZWQgYnkgaGFzaDpcbiAgICAgICAgICAgICAgY29uc3QgaGFzaGVzID0gT2JqZWN0LmtleXMoc2VsZi5oYXNoVG9CbGFua05vZGVzKS5zb3J0KCk7XG4gICAgICAgICAgICAgIHNlbGYuZm9yRWFjaChoYXNoZXMsIChoYXNoLCBpLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIDUuNC4xKSBJZiB0aGUgbGVuZ3RoIG9mIGlkZW50aWZpZXIgbGlzdCBpcyBncmVhdGVyIHRoYW4gMSxcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSB0byB0aGUgbmV4dCBtYXBwaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlkTGlzdCA9IHNlbGYuaGFzaFRvQmxhbmtOb2Rlc1toYXNoXTtcbiAgICAgICAgICAgICAgICBpZihpZExpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gNS40LjIpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmcgY2Fub25pY2FsXG4gICAgICAgICAgICAgICAgLy8gaXNzdWVyIGFuZCB0aGUgc2luZ2xlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpbiBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgLy8gbGlzdCwgaWRlbnRpZmllciwgdG8gaXNzdWUgYSBjYW5vbmljYWwgcmVwbGFjZW1lbnQgaWRlbnRpZmllclxuICAgICAgICAgICAgICAgIC8vIGZvciBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGNoYW5naW5nIGBnZXRJZGAgdG8gYGlzc3VlYFxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gaWRMaXN0WzBdO1xuICAgICAgICAgICAgICAgIHNlbGYuY2Fub25pY2FsSXNzdWVyLmdldElkKGlkKTtcblxuICAgICAgICAgICAgICAgIC8vIDUuNC4zKSBSZW1vdmUgaWRlbnRpZmllciBmcm9tIG5vbi1ub3JtYWxpemVkIGlkZW50aWZpZXJzLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub25Ob3JtYWxpemVkW2lkXTtcblxuICAgICAgICAgICAgICAgIC8vIDUuNC40KSBSZW1vdmUgaGFzaCBmcm9tIHRoZSBoYXNoIHRvIGJsYW5rIG5vZGVzIG1hcC5cbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5oYXNoVG9CbGFua05vZGVzW2hhc2hdO1xuXG4gICAgICAgICAgICAgICAgLy8gNS40LjUpIFNldCBzaW1wbGUgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgICBzaW1wbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLCBjYWxsYmFjayk7XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICBjYWxsYmFjayA9PiB7XG4gICAgICAgIC8vIDYpIEZvciBlYWNoIGhhc2ggdG8gaWRlbnRpZmllciBsaXN0IG1hcHBpbmcgaW4gaGFzaCB0byBibGFuayBub2Rlc1xuICAgICAgICAvLyBtYXAsIGxleGljb2dyYXBoaWNhbGx5LXNvcnRlZCBieSBoYXNoOlxuICAgICAgICBjb25zdCBoYXNoZXMgPSBPYmplY3Qua2V5cyhzZWxmLmhhc2hUb0JsYW5rTm9kZXMpLnNvcnQoKTtcbiAgICAgICAgc2VsZi5mb3JFYWNoKGhhc2hlcywgKGhhc2gsIGlkeCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAvLyA2LjEpIENyZWF0ZSBoYXNoIHBhdGggbGlzdCB3aGVyZSBlYWNoIGl0ZW0gd2lsbCBiZSBhIHJlc3VsdCBvZlxuICAgICAgICAgIC8vIHJ1bm5pbmcgdGhlIEhhc2ggTi1EZWdyZWUgUXVhZHMgYWxnb3JpdGhtLlxuICAgICAgICAgIGNvbnN0IGhhc2hQYXRoTGlzdCA9IFtdO1xuXG4gICAgICAgICAgLy8gNi4yKSBGb3IgZWFjaCBibGFuayBub2RlIGlkZW50aWZpZXIgaWRlbnRpZmllciBpbiBpZGVudGlmaWVyIGxpc3Q6XG4gICAgICAgICAgY29uc3QgaWRMaXN0ID0gc2VsZi5oYXNoVG9CbGFua05vZGVzW2hhc2hdO1xuICAgICAgICAgIHNlbGYud2F0ZXJmYWxsKFtcbiAgICAgICAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgc2VsZi5mb3JFYWNoKGlkTGlzdCwgKGlkLCBpZHgsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gNi4yLjEpIElmIGEgY2Fub25pY2FsIGlkZW50aWZpZXIgaGFzIGFscmVhZHkgYmVlbiBpc3N1ZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gaWRlbnRpZmllciwgY29udGludWUgdG8gdGhlIG5leHQgaWRlbnRpZmllci5cbiAgICAgICAgICAgICAgICBpZihzZWxmLmNhbm9uaWNhbElzc3Vlci5oYXNJZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIDYuMi4yKSBDcmVhdGUgdGVtcG9yYXJ5IGlzc3VlciwgYW4gaWRlbnRpZmllciBpc3N1ZXJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplZCB3aXRoIHRoZSBwcmVmaXggXzpiLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlzc3VlciA9IG5ldyBJZGVudGlmaWVySXNzdWVyKCdfOmInKTtcblxuICAgICAgICAgICAgICAgIC8vIDYuMi4zKSBVc2UgdGhlIElzc3VlIElkZW50aWZpZXIgYWxnb3JpdGhtLCBwYXNzaW5nIHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgIC8vIGlzc3VlciBhbmQgaWRlbnRpZmllciwgdG8gaXNzdWUgYSBuZXcgdGVtcG9yYXJ5IGJsYW5rIG5vZGVcbiAgICAgICAgICAgICAgICAvLyBpZGVudGlmaWVyIGZvciBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgIGlzc3Vlci5nZXRJZChpZCk7XG5cbiAgICAgICAgICAgICAgICAvLyA2LjIuNCkgUnVuIHRoZSBIYXNoIE4tRGVncmVlIFF1YWRzIGFsZ29yaXRobSwgcGFzc2luZ1xuICAgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBpc3N1ZXIsIGFuZCBhcHBlbmQgdGhlIHJlc3VsdCB0byB0aGUgaGFzaCBwYXRoXG4gICAgICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgICAgICBzZWxmLmhhc2hORGVncmVlUXVhZHMoaWQsIGlzc3VlciwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBoYXNoUGF0aExpc3QucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgLy8gNi4zKSBGb3IgZWFjaCByZXN1bHQgaW4gdGhlIGhhc2ggcGF0aCBsaXN0LFxuICAgICAgICAgICAgICAvLyBsZXhpY29ncmFwaGljYWxseS1zb3J0ZWQgYnkgdGhlIGhhc2ggaW4gcmVzdWx0OlxuICAgICAgICAgICAgICAvLyBUT0RPOiB1c2UgYFN0cmluZy5sb2NhbGVDb21wYXJlYD9cbiAgICAgICAgICAgICAgaGFzaFBhdGhMaXN0LnNvcnQoKGEsIGIpID0+XG4gICAgICAgICAgICAgICAgKGEuaGFzaCA8IGIuaGFzaCkgPyAtMSA6ICgoYS5oYXNoID4gYi5oYXNoKSA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgIHNlbGYuZm9yRWFjaChoYXNoUGF0aExpc3QsIChyZXN1bHQsIGlkeCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAvLyA2LjMuMSkgRm9yIGVhY2ggYmxhbmsgbm9kZSBpZGVudGlmaWVyLCBleGlzdGluZyBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2FzIGlzc3VlZCBhIHRlbXBvcmFyeSBpZGVudGlmaWVyIGJ5IGlkZW50aWZpZXIgaXNzdWVyXG4gICAgICAgICAgICAgICAgLy8gaW4gcmVzdWx0LCBpc3N1ZSBhIGNhbm9uaWNhbCBpZGVudGlmaWVyLCBpbiB0aGUgc2FtZSBvcmRlcixcbiAgICAgICAgICAgICAgICAvLyB1c2luZyB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmcgY2Fub25pY2FsXG4gICAgICAgICAgICAgICAgLy8gaXNzdWVyIGFuZCBleGlzdGluZyBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgIGZvcihjb25zdCBleGlzdGluZyBpbiByZXN1bHQuaXNzdWVyLmV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmNhbm9uaWNhbElzc3Vlci5nZXRJZChleGlzdGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLCBjYWxsYmFjayk7XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgIH0sIGNhbGxiYWNrID0+IHtcbiAgICAgICAgLyogTm90ZTogQXQgdGhpcyBwb2ludCBhbGwgYmxhbmsgbm9kZXMgaW4gdGhlIHNldCBvZiBSREYgcXVhZHMgaGF2ZSBiZWVuXG4gICAgICAgIGFzc2lnbmVkIGNhbm9uaWNhbCBpZGVudGlmaWVycywgd2hpY2ggaGF2ZSBiZWVuIHN0b3JlZCBpbiB0aGUgY2Fub25pY2FsXG4gICAgICAgIGlzc3Vlci4gSGVyZSBlYWNoIHF1YWQgaXMgdXBkYXRlZCBieSBhc3NpZ25pbmcgZWFjaCBvZiBpdHMgYmxhbmsgbm9kZXNcbiAgICAgICAgaXRzIG5ldyBpZGVudGlmaWVyLiAqL1xuXG4gICAgICAgIC8vIDcpIEZvciBlYWNoIHF1YWQsIHF1YWQsIGluIGlucHV0IGRhdGFzZXQ6XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBbXTtcbiAgICAgICAgc2VsZi53YXRlcmZhbGwoW1xuICAgICAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIHNlbGYuZm9yRWFjaChzZWxmLnF1YWRzLCAocXVhZCwgaWR4LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAvLyA3LjEpIENyZWF0ZSBhIGNvcHksIHF1YWQgY29weSwgb2YgcXVhZCBhbmQgcmVwbGFjZSBhbnkgZXhpc3RpbmdcbiAgICAgICAgICAgICAgLy8gYmxhbmsgbm9kZSBpZGVudGlmaWVycyB1c2luZyB0aGUgY2Fub25pY2FsIGlkZW50aWZpZXJzXG4gICAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgaXNzdWVkIGJ5IGNhbm9uaWNhbCBpc3N1ZXIuXG4gICAgICAgICAgICAgIC8vIE5vdGU6IFdlIG9wdGltaXplIGF3YXkgdGhlIGNvcHkgaGVyZS5cbiAgICAgICAgICAgICAgc2VsZi5mb3JFYWNoQ29tcG9uZW50KHF1YWQsIGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYoY29tcG9uZW50LnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJyAmJlxuICAgICAgICAgICAgICAgICAgIWNvbXBvbmVudC52YWx1ZS5zdGFydHNXaXRoKHNlbGYuY2Fub25pY2FsSXNzdWVyLnByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IHNlbGYuY2Fub25pY2FsSXNzdWVyLmdldElkKGNvbXBvbmVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gNy4yKSBBZGQgcXVhZCBjb3B5IHRvIHRoZSBub3JtYWxpemVkIGRhdGFzZXQuXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChOUXVhZHMuc2VyaWFsaXplUXVhZChxdWFkKSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAvLyBzb3J0IG5vcm1hbGl6ZWQgb3V0cHV0XG4gICAgICAgICAgICBub3JtYWxpemVkLnNvcnQoKTtcblxuICAgICAgICAgICAgLy8gOCkgUmV0dXJuIHRoZSBub3JtYWxpemVkIGRhdGFzZXQuXG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVkLmpvaW4oJycpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICBdLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgXSwgZXJyID0+IGNhbGxiYWNrKGVyciwgcmVzdWx0KSk7XG4gIH1cblxuICAvLyA0LjYpIEhhc2ggRmlyc3QgRGVncmVlIFF1YWRzXG4gIGhhc2hGaXJzdERlZ3JlZVF1YWRzKGlkLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gcmV0dXJuIGNhY2hlZCBoYXNoXG4gICAgY29uc3QgaW5mbyA9IHNlbGYuYmxhbmtOb2RlSW5mb1tpZF07XG4gICAgaWYoJ2hhc2gnIGluIGluZm8pIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpbmZvLmhhc2gpO1xuICAgIH1cblxuICAgIC8vIDEpIEluaXRpYWxpemUgbnF1YWRzIHRvIGFuIGVtcHR5IGxpc3QuIEl0IHdpbGwgYmUgdXNlZCB0byBzdG9yZSBxdWFkcyBpblxuICAgIC8vIE4tUXVhZHMgZm9ybWF0LlxuICAgIGNvbnN0IG5xdWFkcyA9IFtdO1xuXG4gICAgLy8gMikgR2V0IHRoZSBsaXN0IG9mIHF1YWRzIHF1YWRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVmZXJlbmNlIGJsYW5rIG5vZGVcbiAgICAvLyBpZGVudGlmaWVyIGluIHRoZSBibGFuayBub2RlIHRvIHF1YWRzIG1hcC5cbiAgICBjb25zdCBxdWFkcyA9IGluZm8ucXVhZHM7XG5cbiAgICAvLyAzKSBGb3IgZWFjaCBxdWFkIHF1YWQgaW4gcXVhZHM6XG4gICAgc2VsZi5mb3JFYWNoKHF1YWRzLCAocXVhZCwgaWR4LCBjYWxsYmFjaykgPT4ge1xuICAgICAgLy8gMy4xKSBTZXJpYWxpemUgdGhlIHF1YWQgaW4gTi1RdWFkcyBmb3JtYXQgd2l0aCB0aGUgZm9sbG93aW5nIHNwZWNpYWxcbiAgICAgIC8vIHJ1bGU6XG5cbiAgICAgIC8vIDMuMS4xKSBJZiBhbnkgY29tcG9uZW50IGluIHF1YWQgaXMgYW4gYmxhbmsgbm9kZSwgdGhlbiBzZXJpYWxpemUgaXRcbiAgICAgIC8vIHVzaW5nIGEgc3BlY2lhbCBpZGVudGlmaWVyIGFzIGZvbGxvd3M6XG4gICAgICBjb25zdCBjb3B5ID0ge3ByZWRpY2F0ZTogcXVhZC5wcmVkaWNhdGV9O1xuICAgICAgc2VsZi5mb3JFYWNoQ29tcG9uZW50KHF1YWQsIChjb21wb25lbnQsIGtleSkgPT4ge1xuICAgICAgICAvLyAzLjEuMikgSWYgdGhlIGJsYW5rIG5vZGUncyBleGlzdGluZyBibGFuayBub2RlIGlkZW50aWZpZXIgbWF0Y2hlcyB0aGVcbiAgICAgICAgLy8gcmVmZXJlbmNlIGJsYW5rIG5vZGUgaWRlbnRpZmllciB0aGVuIHVzZSB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyXG4gICAgICAgIC8vIF86YSwgb3RoZXJ3aXNlLCB1c2UgdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBfOnouXG4gICAgICAgIGNvcHlba2V5XSA9IHNlbGYubW9kaWZ5Rmlyc3REZWdyZWVDb21wb25lbnQoaWQsIGNvbXBvbmVudCwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgbnF1YWRzLnB1c2goTlF1YWRzLnNlcmlhbGl6ZVF1YWQoY29weSkpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9LCBlcnIgPT4ge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgLy8gNCkgU29ydCBucXVhZHMgaW4gbGV4aWNvZ3JhcGhpY2FsIG9yZGVyLlxuICAgICAgbnF1YWRzLnNvcnQoKTtcblxuICAgICAgLy8gNSkgUmV0dXJuIHRoZSBoYXNoIHRoYXQgcmVzdWx0cyBmcm9tIHBhc3NpbmcgdGhlIHNvcnRlZCwgam9pbmVkIG5xdWFkc1xuICAgICAgLy8gdGhyb3VnaCB0aGUgaGFzaCBhbGdvcml0aG0uXG4gICAgICBjb25zdCBtZCA9IG5ldyBNZXNzYWdlRGlnZXN0KHNlbGYuaGFzaEFsZ29yaXRobSk7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbnF1YWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG1kLnVwZGF0ZShucXVhZHNbaV0pO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogcmVwcmVzZW50IGFzIGJ5dGUgYnVmZmVyIGluc3RlYWQgdG8gY3V0IG1lbW9yeSB1c2FnZSBpbiBoYWxmXG4gICAgICBpbmZvLmhhc2ggPSBtZC5kaWdlc3QoKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGluZm8uaGFzaCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyA0LjcpIEhhc2ggUmVsYXRlZCBCbGFuayBOb2RlXG4gIGhhc2hSZWxhdGVkQmxhbmtOb2RlKHJlbGF0ZWQsIHF1YWQsIGlzc3VlciwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyAxKSBTZXQgdGhlIGlkZW50aWZpZXIgdG8gdXNlIGZvciByZWxhdGVkLCBwcmVmZXJyaW5nIGZpcnN0IHRoZSBjYW5vbmljYWxcbiAgICAvLyBpZGVudGlmaWVyIGZvciByZWxhdGVkIGlmIGlzc3VlZCwgc2Vjb25kIHRoZSBpZGVudGlmaWVyIGlzc3VlZCBieSBpc3N1ZXJcbiAgICAvLyBpZiBpc3N1ZWQsIGFuZCBsYXN0LCBpZiBuZWNlc3NhcnksIHRoZSByZXN1bHQgb2YgdGhlIEhhc2ggRmlyc3QgRGVncmVlXG4gICAgLy8gUXVhZHMgYWxnb3JpdGhtLCBwYXNzaW5nIHJlbGF0ZWQuXG4gICAgbGV0IGlkO1xuICAgIHNlbGYud2F0ZXJmYWxsKFtcbiAgICAgIGNhbGxiYWNrID0+IHtcbiAgICAgICAgaWYoc2VsZi5jYW5vbmljYWxJc3N1ZXIuaGFzSWQocmVsYXRlZCkpIHtcbiAgICAgICAgICBpZCA9IHNlbGYuY2Fub25pY2FsSXNzdWVyLmdldElkKHJlbGF0ZWQpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGlzc3Vlci5oYXNJZChyZWxhdGVkKSkge1xuICAgICAgICAgIGlkID0gaXNzdWVyLmdldElkKHJlbGF0ZWQpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuaGFzaEZpcnN0RGVncmVlUXVhZHMocmVsYXRlZCwgKGVyciwgaGFzaCkgPT4ge1xuICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkID0gaGFzaDtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBdLCBlcnIgPT4ge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyAyKSBJbml0aWFsaXplIGEgc3RyaW5nIGlucHV0IHRvIHRoZSB2YWx1ZSBvZiBwb3NpdGlvbi5cbiAgICAgIC8vIE5vdGU6IFdlIHVzZSBhIGhhc2ggb2JqZWN0IGluc3RlYWQuXG4gICAgICBjb25zdCBtZCA9IG5ldyBNZXNzYWdlRGlnZXN0KHNlbGYuaGFzaEFsZ29yaXRobSk7XG4gICAgICBtZC51cGRhdGUocG9zaXRpb24pO1xuXG4gICAgICAvLyAzKSBJZiBwb3NpdGlvbiBpcyBub3QgZywgYXBwZW5kIDwsIHRoZSB2YWx1ZSBvZiB0aGUgcHJlZGljYXRlIGluIHF1YWQsXG4gICAgICAvLyBhbmQgPiB0byBpbnB1dC5cbiAgICAgIGlmKHBvc2l0aW9uICE9PSAnZycpIHtcbiAgICAgICAgbWQudXBkYXRlKHNlbGYuZ2V0UmVsYXRlZFByZWRpY2F0ZShxdWFkKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIDQpIEFwcGVuZCBpZGVudGlmaWVyIHRvIGlucHV0LlxuICAgICAgbWQudXBkYXRlKGlkKTtcblxuICAgICAgLy8gNSkgUmV0dXJuIHRoZSBoYXNoIHRoYXQgcmVzdWx0cyBmcm9tIHBhc3NpbmcgaW5wdXQgdGhyb3VnaCB0aGUgaGFzaFxuICAgICAgLy8gYWxnb3JpdGhtLlxuICAgICAgLy8gVE9ETzogcmVwcmVzZW50IGFzIGJ5dGUgYnVmZmVyIGluc3RlYWQgdG8gY3V0IG1lbW9yeSB1c2FnZSBpbiBoYWxmXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbWQuZGlnZXN0KCkpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gNC44KSBIYXNoIE4tRGVncmVlIFF1YWRzXG4gIGhhc2hORGVncmVlUXVhZHMoaWQsIGlzc3VlciwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIDEpIENyZWF0ZSBhIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXAgZm9yIHN0b3JpbmcgaGFzaGVzIHRoYXRcbiAgICAvLyBpZGVudGlmeSByZWxhdGVkIGJsYW5rIG5vZGVzLlxuICAgIC8vIE5vdGU6IDIpIGFuZCAzKSBoYW5kbGVkIHdpdGhpbiBgY3JlYXRlSGFzaFRvUmVsYXRlZGBcbiAgICBsZXQgaGFzaFRvUmVsYXRlZDtcbiAgICBjb25zdCBtZCA9IG5ldyBNZXNzYWdlRGlnZXN0KHNlbGYuaGFzaEFsZ29yaXRobSk7XG4gICAgc2VsZi53YXRlcmZhbGwoW1xuICAgICAgY2FsbGJhY2sgPT4gc2VsZi5jcmVhdGVIYXNoVG9SZWxhdGVkKGlkLCBpc3N1ZXIsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNoVG9SZWxhdGVkID0gcmVzdWx0O1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSksXG4gICAgICBjYWxsYmFjayA9PiB7XG4gICAgICAgIC8vIDQpIENyZWF0ZSBhbiBlbXB0eSBzdHJpbmcsIGRhdGEgdG8gaGFzaC5cbiAgICAgICAgLy8gTm90ZTogV2UgY3JlYXRlZCBhIGhhc2ggb2JqZWN0IGBtZGAgYWJvdmUgaW5zdGVhZC5cblxuICAgICAgICAvLyA1KSBGb3IgZWFjaCByZWxhdGVkIGhhc2ggdG8gYmxhbmsgbm9kZSBsaXN0IG1hcHBpbmcgaW4gaGFzaCB0b1xuICAgICAgICAvLyByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcCwgc29ydGVkIGxleGljb2dyYXBoaWNhbGx5IGJ5IHJlbGF0ZWQgaGFzaDpcbiAgICAgICAgY29uc3QgaGFzaGVzID0gT2JqZWN0LmtleXMoaGFzaFRvUmVsYXRlZCkuc29ydCgpO1xuICAgICAgICBzZWxmLmZvckVhY2goaGFzaGVzLCAoaGFzaCwgaWR4LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIC8vIDUuMSkgQXBwZW5kIHRoZSByZWxhdGVkIGhhc2ggdG8gdGhlIGRhdGEgdG8gaGFzaC5cbiAgICAgICAgICBtZC51cGRhdGUoaGFzaCk7XG5cbiAgICAgICAgICAvLyA1LjIpIENyZWF0ZSBhIHN0cmluZyBjaG9zZW4gcGF0aC5cbiAgICAgICAgICBsZXQgY2hvc2VuUGF0aCA9ICcnO1xuXG4gICAgICAgICAgLy8gNS4zKSBDcmVhdGUgYW4gdW5zZXQgY2hvc2VuIGlzc3VlciB2YXJpYWJsZS5cbiAgICAgICAgICBsZXQgY2hvc2VuSXNzdWVyO1xuXG4gICAgICAgICAgLy8gNS40KSBGb3IgZWFjaCBwZXJtdXRhdGlvbiBvZiBibGFuayBub2RlIGxpc3Q6XG4gICAgICAgICAgY29uc3QgcGVybXV0YXRvciA9IG5ldyBQZXJtdXRhdG9yKGhhc2hUb1JlbGF0ZWRbaGFzaF0pO1xuICAgICAgICAgIHNlbGYud2hpbHN0KCgpID0+IHBlcm11dGF0b3IuaGFzTmV4dCgpLCBuZXh0UGVybXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVybXV0YXRpb24gPSBwZXJtdXRhdG9yLm5leHQoKTtcblxuICAgICAgICAgICAgLy8gNS40LjEpIENyZWF0ZSBhIGNvcHkgb2YgaXNzdWVyLCBpc3N1ZXIgY29weS5cbiAgICAgICAgICAgIGxldCBpc3N1ZXJDb3B5ID0gaXNzdWVyLmNsb25lKCk7XG5cbiAgICAgICAgICAgIC8vIDUuNC4yKSBDcmVhdGUgYSBzdHJpbmcgcGF0aC5cbiAgICAgICAgICAgIGxldCBwYXRoID0gJyc7XG5cbiAgICAgICAgICAgIC8vIDUuNC4zKSBDcmVhdGUgYSByZWN1cnNpb24gbGlzdCwgdG8gc3RvcmUgYmxhbmsgbm9kZSBpZGVudGlmaWVyc1xuICAgICAgICAgICAgLy8gdGhhdCBtdXN0IGJlIHJlY3Vyc2l2ZWx5IHByb2Nlc3NlZCBieSB0aGlzIGFsZ29yaXRobS5cbiAgICAgICAgICAgIGNvbnN0IHJlY3Vyc2lvbkxpc3QgPSBbXTtcblxuICAgICAgICAgICAgc2VsZi53YXRlcmZhbGwoW1xuICAgICAgICAgICAgICBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAgICAgLy8gNS40LjQpIEZvciBlYWNoIHJlbGF0ZWQgaW4gcGVybXV0YXRpb246XG4gICAgICAgICAgICAgICAgc2VsZi5mb3JFYWNoKHBlcm11dGF0aW9uLCAocmVsYXRlZCwgaWR4LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgLy8gNS40LjQuMSkgSWYgYSBjYW5vbmljYWwgaWRlbnRpZmllciBoYXMgYmVlbiBpc3N1ZWQgZm9yXG4gICAgICAgICAgICAgICAgICAvLyByZWxhdGVkLCBhcHBlbmQgaXQgdG8gcGF0aC5cbiAgICAgICAgICAgICAgICAgIGlmKHNlbGYuY2Fub25pY2FsSXNzdWVyLmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gc2VsZi5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQocmVsYXRlZCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyA1LjQuNC4yKSBPdGhlcndpc2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIDUuNC40LjIuMSkgSWYgaXNzdWVyIGNvcHkgaGFzIG5vdCBpc3N1ZWQgYW4gaWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcmVsYXRlZCwgYXBwZW5kIHJlbGF0ZWQgdG8gcmVjdXJzaW9uIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgIGlmKCFpc3N1ZXJDb3B5Lmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uTGlzdC5wdXNoKHJlbGF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIDUuNC40LjIuMikgVXNlIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBpc3N1ZXIgY29weSBhbmQgcmVsYXRlZCBhbmQgYXBwZW5kIHRoZSByZXN1bHQgdG8gcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBpc3N1ZXJDb3B5LmdldElkKHJlbGF0ZWQpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyA1LjQuNC4zKSBJZiBjaG9zZW4gcGF0aCBpcyBub3QgZW1wdHkgYW5kIHRoZSBsZW5ndGggb2YgcGF0aFxuICAgICAgICAgICAgICAgICAgLy8gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgY2hvc2VuIHBhdGggYW5kXG4gICAgICAgICAgICAgICAgICAvLyBwYXRoIGlzIGxleGljb2dyYXBoaWNhbGx5IGdyZWF0ZXIgdGhhbiBjaG9zZW4gcGF0aCwgdGhlblxuICAgICAgICAgICAgICAgICAgLy8gc2tpcCB0byB0aGUgbmV4dCBwZXJtdXRhdGlvbi5cbiAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IENvbXBhcmluZyBwYXRoIGxlbmd0aCB0byBjaG9zZW4gcGF0aCBsZW5ndGggY2FuIGJlXG4gICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgYXdheTsgb25seSBjb21wYXJlIGxleGljb2dyYXBoaWNhbGx5LlxuICAgICAgICAgICAgICAgICAgaWYoY2hvc2VuUGF0aC5sZW5ndGggIT09IDAgJiYgcGF0aCA+IGNob3NlblBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IG1heSBjYXVzZSBpbmFjY3VyYXRlIHRvdGFsIGRlcHRoIGNhbGN1bGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0UGVybXV0YXRpb24oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAgICAgLy8gNS40LjUpIEZvciBlYWNoIHJlbGF0ZWQgaW4gcmVjdXJzaW9uIGxpc3Q6XG4gICAgICAgICAgICAgICAgc2VsZi5mb3JFYWNoKHJlY3Vyc2lvbkxpc3QsIChyZWxhdGVkLCBpZHgsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyA1LjQuNS4xKSBTZXQgcmVzdWx0IHRvIHRoZSByZXN1bHQgb2YgcmVjdXJzaXZlbHkgZXhlY3V0aW5nXG4gICAgICAgICAgICAgICAgICAvLyB0aGUgSGFzaCBOLURlZ3JlZSBRdWFkcyBhbGdvcml0aG0sIHBhc3NpbmcgcmVsYXRlZCBmb3JcbiAgICAgICAgICAgICAgICAgIC8vIGlkZW50aWZpZXIgYW5kIGlzc3VlciBjb3B5IGZvciBwYXRoIGlkZW50aWZpZXIgaXNzdWVyLlxuICAgICAgICAgICAgICAgICAgc2VsZi5oYXNoTkRlZ3JlZVF1YWRzKHJlbGF0ZWQsIGlzc3VlckNvcHksIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIDUuNC41LjIpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gaXNzdWVyIGNvcHkgYW5kIHJlbGF0ZWQgYW5kIGFwcGVuZCB0aGUgcmVzdWx0IHRvIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gaXNzdWVyQ29weS5nZXRJZChyZWxhdGVkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyA1LjQuNS4zKSBBcHBlbmQgPCwgdGhlIGhhc2ggaW4gcmVzdWx0LCBhbmQgPiB0byBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9ICc8JyArIHJlc3VsdC5oYXNoICsgJz4nO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIDUuNC41LjQpIFNldCBpc3N1ZXIgY29weSB0byB0aGUgaWRlbnRpZmllciBpc3N1ZXIgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICBpc3N1ZXJDb3B5ID0gcmVzdWx0Lmlzc3VlcjtcblxuICAgICAgICAgICAgICAgICAgICAvLyA1LjQuNS41KSBJZiBjaG9zZW4gcGF0aCBpcyBub3QgZW1wdHkgYW5kIHRoZSBsZW5ndGggb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0aCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiBjaG9zZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0aCBhbmQgcGF0aCBpcyBsZXhpY29ncmFwaGljYWxseSBncmVhdGVyIHRoYW4gY2hvc2VuXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhdGgsIHRoZW4gc2tpcCB0byB0aGUgbmV4dCBwZXJtdXRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogQ29tcGFyaW5nIHBhdGggbGVuZ3RoIHRvIGNob3NlbiBwYXRoIGxlbmd0aCBjYW4gYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIGF3YXk7IG9ubHkgY29tcGFyZSBsZXhpY29ncmFwaGljYWxseS5cbiAgICAgICAgICAgICAgICAgICAgaWYoY2hvc2VuUGF0aC5sZW5ndGggIT09IDAgJiYgcGF0aCA+IGNob3NlblBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogbWF5IGNhdXNlIGluYWNjdXJhdGUgdG90YWwgZGVwdGggY2FsY3VsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFBlcm11dGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICAgIC8vIDUuNC42KSBJZiBjaG9zZW4gcGF0aCBpcyBlbXB0eSBvciBwYXRoIGlzIGxleGljb2dyYXBoaWNhbGx5XG4gICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIGNob3NlbiBwYXRoLCBzZXQgY2hvc2VuIHBhdGggdG8gcGF0aCBhbmQgY2hvc2VuXG4gICAgICAgICAgICAgICAgLy8gaXNzdWVyIHRvIGlzc3VlciBjb3B5LlxuICAgICAgICAgICAgICAgIGlmKGNob3NlblBhdGgubGVuZ3RoID09PSAwIHx8IHBhdGggPCBjaG9zZW5QYXRoKSB7XG4gICAgICAgICAgICAgICAgICBjaG9zZW5QYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgIGNob3Nlbklzc3VlciA9IGlzc3VlckNvcHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sIG5leHRQZXJtdXRhdGlvbik7XG4gICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gNS41KSBBcHBlbmQgY2hvc2VuIHBhdGggdG8gZGF0YSB0byBoYXNoLlxuICAgICAgICAgICAgbWQudXBkYXRlKGNob3NlblBhdGgpO1xuXG4gICAgICAgICAgICAvLyA1LjYpIFJlcGxhY2UgaXNzdWVyLCBieSByZWZlcmVuY2UsIHdpdGggY2hvc2VuIGlzc3Vlci5cbiAgICAgICAgICAgIGlzc3VlciA9IGNob3Nlbklzc3VlcjtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICBdLCBlcnIgPT4ge1xuICAgICAgLy8gNikgUmV0dXJuIGlzc3VlciBhbmQgdGhlIGhhc2ggdGhhdCByZXN1bHRzIGZyb20gcGFzc2luZyBkYXRhIHRvIGhhc2hcbiAgICAgIC8vIHRocm91Z2ggdGhlIGhhc2ggYWxnb3JpdGhtLlxuICAgICAgY2FsbGJhY2soZXJyLCB7aGFzaDogbWQuZGlnZXN0KCksIGlzc3Vlcn0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBtb2RpZnlpbmcgY29tcG9uZW50IGR1cmluZyBIYXNoIEZpcnN0IERlZ3JlZSBRdWFkc1xuICBtb2RpZnlGaXJzdERlZ3JlZUNvbXBvbmVudChpZCwgY29tcG9uZW50KSB7XG4gICAgaWYoY29tcG9uZW50LnRlcm1UeXBlICE9PSAnQmxhbmtOb2RlJykge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG4gICAgY29tcG9uZW50ID0gdXRpbC5jbG9uZShjb21wb25lbnQpO1xuICAgIGNvbXBvbmVudC52YWx1ZSA9IChjb21wb25lbnQudmFsdWUgPT09IGlkID8gJ186YScgOiAnXzp6Jyk7XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgZ2V0dGluZyBhIHJlbGF0ZWQgcHJlZGljYXRlXG4gIGdldFJlbGF0ZWRQcmVkaWNhdGUocXVhZCkge1xuICAgIHJldHVybiAnPCcgKyBxdWFkLnByZWRpY2F0ZS52YWx1ZSArICc+JztcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgY3JlYXRpbmcgaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcFxuICBjcmVhdGVIYXNoVG9SZWxhdGVkKGlkLCBpc3N1ZXIsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyAxKSBDcmVhdGUgYSBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwIGZvciBzdG9yaW5nIGhhc2hlcyB0aGF0XG4gICAgLy8gaWRlbnRpZnkgcmVsYXRlZCBibGFuayBub2Rlcy5cbiAgICBjb25zdCBoYXNoVG9SZWxhdGVkID0ge307XG5cbiAgICAvLyAyKSBHZXQgYSByZWZlcmVuY2UsIHF1YWRzLCB0byB0aGUgbGlzdCBvZiBxdWFkcyBpbiB0aGUgYmxhbmsgbm9kZSB0b1xuICAgIC8vIHF1YWRzIG1hcCBmb3IgdGhlIGtleSBpZGVudGlmaWVyLlxuICAgIGNvbnN0IHF1YWRzID0gc2VsZi5ibGFua05vZGVJbmZvW2lkXS5xdWFkcztcblxuICAgIC8vIDMpIEZvciBlYWNoIHF1YWQgaW4gcXVhZHM6XG4gICAgc2VsZi5mb3JFYWNoKHF1YWRzLCAocXVhZCwgaWR4LCBjYWxsYmFjaykgPT4ge1xuICAgICAgLy8gMy4xKSBGb3IgZWFjaCBjb21wb25lbnQgaW4gcXVhZCwgaWYgY29tcG9uZW50IGlzIHRoZSBzdWJqZWN0LCBvYmplY3QsXG4gICAgICAvLyBhbmQgZ3JhcGggbmFtZSBhbmQgaXQgaXMgYSBibGFuayBub2RlIHRoYXQgaXMgbm90IGlkZW50aWZpZWQgYnlcbiAgICAgIC8vIGlkZW50aWZpZXI6XG4gICAgICBzZWxmLmZvckVhY2gocXVhZCwgKGNvbXBvbmVudCwga2V5LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBpZihrZXkgPT09ICdwcmVkaWNhdGUnIHx8XG4gICAgICAgICAgIShjb21wb25lbnQudGVybVR5cGUgPT09ICdCbGFua05vZGUnICYmIGNvbXBvbmVudC52YWx1ZSAhPT0gaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjEpIFNldCBoYXNoIHRvIHRoZSByZXN1bHQgb2YgdGhlIEhhc2ggUmVsYXRlZCBCbGFuayBOb2RlXG4gICAgICAgIC8vIGFsZ29yaXRobSwgcGFzc2luZyB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGZvciBjb21wb25lbnQgYXNcbiAgICAgICAgLy8gcmVsYXRlZCwgcXVhZCwgcGF0aCBpZGVudGlmaWVyIGlzc3VlciBhcyBpc3N1ZXIsIGFuZCBwb3NpdGlvbiBhc1xuICAgICAgICAvLyBlaXRoZXIgcywgbywgb3IgZyBiYXNlZCBvbiB3aGV0aGVyIGNvbXBvbmVudCBpcyBhIHN1YmplY3QsIG9iamVjdCxcbiAgICAgICAgLy8gZ3JhcGggbmFtZSwgcmVzcGVjdGl2ZWx5LlxuICAgICAgICBjb25zdCByZWxhdGVkID0gY29tcG9uZW50LnZhbHVlO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IFBPU0lUSU9OU1trZXldO1xuICAgICAgICBzZWxmLmhhc2hSZWxhdGVkQmxhbmtOb2RlKFxuICAgICAgICAgIHJlbGF0ZWQsIHF1YWQsIGlzc3VlciwgcG9zaXRpb24sIChlcnIsIGhhc2gpID0+IHtcbiAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDMuMS4yKSBBZGQgYSBtYXBwaW5nIG9mIGhhc2ggdG8gdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBmb3JcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwLCBhZGRpbmcgYW4gZW50cnkgYXNcbiAgICAgICAgICAgIC8vIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGlmKGhhc2ggaW4gaGFzaFRvUmVsYXRlZCkge1xuICAgICAgICAgICAgICBoYXNoVG9SZWxhdGVkW2hhc2hdLnB1c2gocmVsYXRlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYXNoVG9SZWxhdGVkW2hhc2hdID0gW3JlbGF0ZWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9LCBlcnIgPT4gY2FsbGJhY2soZXJyLCBoYXNoVG9SZWxhdGVkKSk7XG4gIH1cblxuICAvLyBoZWxwZXIgdGhhdCBpdGVyYXRlcyBvdmVyIHF1YWQgY29tcG9uZW50cyAoc2tpcHMgcHJlZGljYXRlKVxuICBmb3JFYWNoQ29tcG9uZW50KHF1YWQsIG9wKSB7XG4gICAgZm9yKGNvbnN0IGtleSBpbiBxdWFkKSB7XG4gICAgICAvLyBza2lwIGBwcmVkaWNhdGVgXG4gICAgICBpZihrZXkgPT09ICdwcmVkaWNhdGUnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb3AocXVhZFtrZXldLCBrZXksIHF1YWQpO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBJZGVudGlmaWVySXNzdWVyID0gcmVxdWlyZSgnLi9JZGVudGlmaWVySXNzdWVyJyk7XG5jb25zdCBNZXNzYWdlRGlnZXN0ID0gcmVxdWlyZSgnLi9NZXNzYWdlRGlnZXN0Jyk7XG5jb25zdCBQZXJtdXRhdG9yID0gcmVxdWlyZSgnLi9QZXJtdXRhdG9yJyk7XG5jb25zdCBOUXVhZHMgPSByZXF1aXJlKCcuL05RdWFkcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCBQT1NJVElPTlMgPSB7c3ViamVjdDogJ3MnLCBvYmplY3Q6ICdvJywgZ3JhcGg6ICdnJ307XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVVJETkEyMDE1U3luYyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9ICdVUkROQTIwMTUnO1xuICAgIHRoaXMuYmxhbmtOb2RlSW5mbyA9IHt9O1xuICAgIHRoaXMuaGFzaFRvQmxhbmtOb2RlcyA9IHt9O1xuICAgIHRoaXMuY2Fub25pY2FsSXNzdWVyID0gbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YzE0bicpO1xuICAgIHRoaXMuaGFzaEFsZ29yaXRobSA9ICdzaGEyNTYnO1xuICAgIHRoaXMucXVhZHM7XG4gIH1cblxuICAvLyA0LjQpIE5vcm1hbGl6YXRpb24gQWxnb3JpdGhtXG4gIG1haW4oZGF0YXNldCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYucXVhZHMgPSBkYXRhc2V0O1xuXG4gICAgLy8gMSkgQ3JlYXRlIHRoZSBub3JtYWxpemF0aW9uIHN0YXRlLlxuXG4gICAgLy8gTm90ZTogT3B0aW1pemUgYnkgZ2VuZXJhdGluZyBub24tbm9ybWFsaXplZCBibGFuayBub2RlIG1hcCBjb25jdXJyZW50bHkuXG4gICAgY29uc3Qgbm9uTm9ybWFsaXplZCA9IHt9O1xuXG4gICAgLy8gMikgRm9yIGV2ZXJ5IHF1YWQgaW4gaW5wdXQgZGF0YXNldDpcbiAgICBmb3IoY29uc3QgcXVhZCBvZiBkYXRhc2V0KSB7XG4gICAgICAvLyAyLjEpIEZvciBlYWNoIGJsYW5rIG5vZGUgdGhhdCBvY2N1cnMgaW4gdGhlIHF1YWQsIGFkZCBhIHJlZmVyZW5jZVxuICAgICAgLy8gdG8gdGhlIHF1YWQgdXNpbmcgdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpbiB0aGUgYmxhbmsgbm9kZSB0b1xuICAgICAgLy8gcXVhZHMgbWFwLCBjcmVhdGluZyBhIG5ldyBlbnRyeSBpZiBuZWNlc3NhcnkuXG4gICAgICBzZWxmLmZvckVhY2hDb21wb25lbnQocXVhZCwgY29tcG9uZW50ID0+IHtcbiAgICAgICAgaWYoY29tcG9uZW50LnRlcm1UeXBlICE9PSAnQmxhbmtOb2RlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IGNvbXBvbmVudC52YWx1ZTtcbiAgICAgICAgaWYoaWQgaW4gc2VsZi5ibGFua05vZGVJbmZvKSB7XG4gICAgICAgICAgc2VsZi5ibGFua05vZGVJbmZvW2lkXS5xdWFkcy5wdXNoKHF1YWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vbk5vcm1hbGl6ZWRbaWRdID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLmJsYW5rTm9kZUluZm9baWRdID0ge3F1YWRzOiBbcXVhZF19O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAzKSBDcmVhdGUgYSBsaXN0IG9mIG5vbi1ub3JtYWxpemVkIGJsYW5rIG5vZGUgaWRlbnRpZmllcnNcbiAgICAvLyBub24tbm9ybWFsaXplZCBpZGVudGlmaWVycyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgdGhlIGtleXMgZnJvbSB0aGVcbiAgICAvLyBibGFuayBub2RlIHRvIHF1YWRzIG1hcC5cbiAgICAvLyBOb3RlOiBXZSB1c2UgYSBtYXAgaGVyZSBhbmQgaXQgd2FzIGdlbmVyYXRlZCBkdXJpbmcgc3RlcCAyLlxuXG4gICAgLy8gNCkgSW5pdGlhbGl6ZSBzaW1wbGUsIGEgYm9vbGVhbiBmbGFnLCB0byB0cnVlLlxuICAgIGxldCBzaW1wbGUgPSB0cnVlO1xuXG4gICAgLy8gNSkgV2hpbGUgc2ltcGxlIGlzIHRydWUsIGlzc3VlIGNhbm9uaWNhbCBpZGVudGlmaWVycyBmb3IgYmxhbmsgbm9kZXM6XG4gICAgd2hpbGUoc2ltcGxlKSB7XG4gICAgICAvLyA1LjEpIFNldCBzaW1wbGUgdG8gZmFsc2UuXG4gICAgICBzaW1wbGUgPSBmYWxzZTtcblxuICAgICAgLy8gNS4yKSBDbGVhciBoYXNoIHRvIGJsYW5rIG5vZGVzIG1hcC5cbiAgICAgIHNlbGYuaGFzaFRvQmxhbmtOb2RlcyA9IHt9O1xuXG4gICAgICAvLyA1LjMpIEZvciBlYWNoIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpZGVudGlmaWVyIGluIG5vbi1ub3JtYWxpemVkXG4gICAgICAvLyBpZGVudGlmaWVyczpcbiAgICAgIGZvcihjb25zdCBpZCBpbiBub25Ob3JtYWxpemVkKSB7XG4gICAgICAgIC8vIDUuMy4xKSBDcmVhdGUgYSBoYXNoLCBoYXNoLCBhY2NvcmRpbmcgdG8gdGhlIEhhc2ggRmlyc3QgRGVncmVlXG4gICAgICAgIC8vIFF1YWRzIGFsZ29yaXRobS5cbiAgICAgICAgY29uc3QgaGFzaCA9IHNlbGYuaGFzaEZpcnN0RGVncmVlUXVhZHMoaWQpO1xuXG4gICAgICAgIC8vIDUuMy4yKSBBZGQgaGFzaCBhbmQgaWRlbnRpZmllciB0byBoYXNoIHRvIGJsYW5rIG5vZGVzIG1hcCxcbiAgICAgICAgLy8gY3JlYXRpbmcgYSBuZXcgZW50cnkgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZihoYXNoIGluIHNlbGYuaGFzaFRvQmxhbmtOb2Rlcykge1xuICAgICAgICAgIHNlbGYuaGFzaFRvQmxhbmtOb2Rlc1toYXNoXS5wdXNoKGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmhhc2hUb0JsYW5rTm9kZXNbaGFzaF0gPSBbaWRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDUuNCkgRm9yIGVhY2ggaGFzaCB0byBpZGVudGlmaWVyIGxpc3QgbWFwcGluZyBpbiBoYXNoIHRvIGJsYW5rXG4gICAgICAvLyBub2RlcyBtYXAsIGxleGljb2dyYXBoaWNhbGx5LXNvcnRlZCBieSBoYXNoOlxuICAgICAgY29uc3QgaGFzaGVzID0gT2JqZWN0LmtleXMoc2VsZi5oYXNoVG9CbGFua05vZGVzKS5zb3J0KCk7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgaGFzaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIC8vIDUuNC4xKSBJZiB0aGUgbGVuZ3RoIG9mIGlkZW50aWZpZXIgbGlzdCBpcyBncmVhdGVyIHRoYW4gMSxcbiAgICAgICAgLy8gY29udGludWUgdG8gdGhlIG5leHQgbWFwcGluZy5cbiAgICAgICAgY29uc3QgaGFzaCA9IGhhc2hlc1tpXTtcbiAgICAgICAgY29uc3QgaWRMaXN0ID0gc2VsZi5oYXNoVG9CbGFua05vZGVzW2hhc2hdO1xuICAgICAgICBpZihpZExpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS40LjIpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmcgY2Fub25pY2FsXG4gICAgICAgIC8vIGlzc3VlciBhbmQgdGhlIHNpbmdsZSBibGFuayBub2RlIGlkZW50aWZpZXIgaW4gaWRlbnRpZmllclxuICAgICAgICAvLyBsaXN0LCBpZGVudGlmaWVyLCB0byBpc3N1ZSBhIGNhbm9uaWNhbCByZXBsYWNlbWVudCBpZGVudGlmaWVyXG4gICAgICAgIC8vIGZvciBpZGVudGlmaWVyLlxuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBjaGFuZ2luZyBgZ2V0SWRgIHRvIGBpc3N1ZWBcbiAgICAgICAgY29uc3QgaWQgPSBpZExpc3RbMF07XG4gICAgICAgIHNlbGYuY2Fub25pY2FsSXNzdWVyLmdldElkKGlkKTtcblxuICAgICAgICAvLyA1LjQuMykgUmVtb3ZlIGlkZW50aWZpZXIgZnJvbSBub24tbm9ybWFsaXplZCBpZGVudGlmaWVycy5cbiAgICAgICAgZGVsZXRlIG5vbk5vcm1hbGl6ZWRbaWRdO1xuXG4gICAgICAgIC8vIDUuNC40KSBSZW1vdmUgaGFzaCBmcm9tIHRoZSBoYXNoIHRvIGJsYW5rIG5vZGVzIG1hcC5cbiAgICAgICAgZGVsZXRlIHNlbGYuaGFzaFRvQmxhbmtOb2Rlc1toYXNoXTtcblxuICAgICAgICAvLyA1LjQuNSkgU2V0IHNpbXBsZSB0byB0cnVlLlxuICAgICAgICBzaW1wbGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDYpIEZvciBlYWNoIGhhc2ggdG8gaWRlbnRpZmllciBsaXN0IG1hcHBpbmcgaW4gaGFzaCB0byBibGFuayBub2RlcyBtYXAsXG4gICAgLy8gbGV4aWNvZ3JhcGhpY2FsbHktc29ydGVkIGJ5IGhhc2g6XG4gICAgY29uc3QgaGFzaGVzID0gT2JqZWN0LmtleXMoc2VsZi5oYXNoVG9CbGFua05vZGVzKS5zb3J0KCk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGhhc2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gNi4xKSBDcmVhdGUgaGFzaCBwYXRoIGxpc3Qgd2hlcmUgZWFjaCBpdGVtIHdpbGwgYmUgYSByZXN1bHQgb2ZcbiAgICAgIC8vIHJ1bm5pbmcgdGhlIEhhc2ggTi1EZWdyZWUgUXVhZHMgYWxnb3JpdGhtLlxuICAgICAgY29uc3QgaGFzaFBhdGhMaXN0ID0gW107XG5cbiAgICAgIC8vIDYuMikgRm9yIGVhY2ggYmxhbmsgbm9kZSBpZGVudGlmaWVyIGlkZW50aWZpZXIgaW4gaWRlbnRpZmllciBsaXN0OlxuICAgICAgY29uc3QgaGFzaCA9IGhhc2hlc1tpXTtcbiAgICAgIGNvbnN0IGlkTGlzdCA9IHNlbGYuaGFzaFRvQmxhbmtOb2Rlc1toYXNoXTtcbiAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBpZExpc3QubGVuZ3RoOyArK2opIHtcbiAgICAgICAgLy8gNi4yLjEpIElmIGEgY2Fub25pY2FsIGlkZW50aWZpZXIgaGFzIGFscmVhZHkgYmVlbiBpc3N1ZWQgZm9yXG4gICAgICAgIC8vIGlkZW50aWZpZXIsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IGlkZW50aWZpZXIuXG4gICAgICAgIGNvbnN0IGlkID0gaWRMaXN0W2pdO1xuICAgICAgICBpZihzZWxmLmNhbm9uaWNhbElzc3Vlci5oYXNJZChpZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuMi4yKSBDcmVhdGUgdGVtcG9yYXJ5IGlzc3VlciwgYW4gaWRlbnRpZmllciBpc3N1ZXJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgd2l0aCB0aGUgcHJlZml4IF86Yi5cbiAgICAgICAgY29uc3QgaXNzdWVyID0gbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YicpO1xuXG4gICAgICAgIC8vIDYuMi4zKSBVc2UgdGhlIElzc3VlIElkZW50aWZpZXIgYWxnb3JpdGhtLCBwYXNzaW5nIHRlbXBvcmFyeVxuICAgICAgICAvLyBpc3N1ZXIgYW5kIGlkZW50aWZpZXIsIHRvIGlzc3VlIGEgbmV3IHRlbXBvcmFyeSBibGFuayBub2RlXG4gICAgICAgIC8vIGlkZW50aWZpZXIgZm9yIGlkZW50aWZpZXIuXG4gICAgICAgIGlzc3Vlci5nZXRJZChpZCk7XG5cbiAgICAgICAgLy8gNi4yLjQpIFJ1biB0aGUgSGFzaCBOLURlZ3JlZSBRdWFkcyBhbGdvcml0aG0sIHBhc3NpbmdcbiAgICAgICAgLy8gdGVtcG9yYXJ5IGlzc3VlciwgYW5kIGFwcGVuZCB0aGUgcmVzdWx0IHRvIHRoZSBoYXNoIHBhdGggbGlzdC5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2VsZi5oYXNoTkRlZ3JlZVF1YWRzKGlkLCBpc3N1ZXIpO1xuICAgICAgICBoYXNoUGF0aExpc3QucHVzaChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICAvLyA2LjMpIEZvciBlYWNoIHJlc3VsdCBpbiB0aGUgaGFzaCBwYXRoIGxpc3QsXG4gICAgICAvLyBsZXhpY29ncmFwaGljYWxseS1zb3J0ZWQgYnkgdGhlIGhhc2ggaW4gcmVzdWx0OlxuICAgICAgLy8gVE9ETzogdXNlIGBTdHJpbmcubG9jYWxlQ29tcGFyZWA/XG4gICAgICBoYXNoUGF0aExpc3Quc29ydCgoYSwgYikgPT5cbiAgICAgICAgKGEuaGFzaCA8IGIuaGFzaCkgPyAtMSA6ICgoYS5oYXNoID4gYi5oYXNoKSA/IDEgOiAwKSk7XG4gICAgICBmb3IobGV0IGogPSAwOyBqIDwgaGFzaFBhdGhMaXN0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgIC8vIDYuMy4xKSBGb3IgZWFjaCBibGFuayBub2RlIGlkZW50aWZpZXIsIGV4aXN0aW5nIGlkZW50aWZpZXIsXG4gICAgICAgIC8vIHRoYXQgd2FzIGlzc3VlZCBhIHRlbXBvcmFyeSBpZGVudGlmaWVyIGJ5IGlkZW50aWZpZXIgaXNzdWVyXG4gICAgICAgIC8vIGluIHJlc3VsdCwgaXNzdWUgYSBjYW5vbmljYWwgaWRlbnRpZmllciwgaW4gdGhlIHNhbWUgb3JkZXIsXG4gICAgICAgIC8vIHVzaW5nIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZyBjYW5vbmljYWxcbiAgICAgICAgLy8gaXNzdWVyIGFuZCBleGlzdGluZyBpZGVudGlmaWVyLlxuICAgICAgICBjb25zdCByZXN1bHQgPSBoYXNoUGF0aExpc3Rbal07XG4gICAgICAgIGZvcihjb25zdCBleGlzdGluZyBpbiByZXN1bHQuaXNzdWVyLmV4aXN0aW5nKSB7XG4gICAgICAgICAgc2VsZi5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQoZXhpc3RpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogTm90ZTogQXQgdGhpcyBwb2ludCBhbGwgYmxhbmsgbm9kZXMgaW4gdGhlIHNldCBvZiBSREYgcXVhZHMgaGF2ZSBiZWVuXG4gICAgYXNzaWduZWQgY2Fub25pY2FsIGlkZW50aWZpZXJzLCB3aGljaCBoYXZlIGJlZW4gc3RvcmVkIGluIHRoZSBjYW5vbmljYWxcbiAgICBpc3N1ZXIuIEhlcmUgZWFjaCBxdWFkIGlzIHVwZGF0ZWQgYnkgYXNzaWduaW5nIGVhY2ggb2YgaXRzIGJsYW5rIG5vZGVzXG4gICAgaXRzIG5ldyBpZGVudGlmaWVyLiAqL1xuXG4gICAgLy8gNykgRm9yIGVhY2ggcXVhZCwgcXVhZCwgaW4gaW5wdXQgZGF0YXNldDpcbiAgICBjb25zdCBub3JtYWxpemVkID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNlbGYucXVhZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIDcuMSkgQ3JlYXRlIGEgY29weSwgcXVhZCBjb3B5LCBvZiBxdWFkIGFuZCByZXBsYWNlIGFueSBleGlzdGluZ1xuICAgICAgLy8gYmxhbmsgbm9kZSBpZGVudGlmaWVycyB1c2luZyB0aGUgY2Fub25pY2FsIGlkZW50aWZpZXJzXG4gICAgICAvLyBwcmV2aW91c2x5IGlzc3VlZCBieSBjYW5vbmljYWwgaXNzdWVyLlxuICAgICAgLy8gTm90ZTogV2Ugb3B0aW1pemUgYXdheSB0aGUgY29weSBoZXJlLlxuICAgICAgY29uc3QgcXVhZCA9IHNlbGYucXVhZHNbaV07XG4gICAgICBzZWxmLmZvckVhY2hDb21wb25lbnQocXVhZCwgY29tcG9uZW50ID0+IHtcbiAgICAgICAgaWYoY29tcG9uZW50LnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJyAmJlxuICAgICAgICAgICFjb21wb25lbnQudmFsdWUuc3RhcnRzV2l0aChzZWxmLmNhbm9uaWNhbElzc3Vlci5wcmVmaXgpKSB7XG4gICAgICAgICAgY29tcG9uZW50LnZhbHVlID0gc2VsZi5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQoY29tcG9uZW50LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyA3LjIpIEFkZCBxdWFkIGNvcHkgdG8gdGhlIG5vcm1hbGl6ZWQgZGF0YXNldC5cbiAgICAgIG5vcm1hbGl6ZWQucHVzaChOUXVhZHMuc2VyaWFsaXplUXVhZChxdWFkKSk7XG4gICAgfVxuXG4gICAgLy8gc29ydCBub3JtYWxpemVkIG91dHB1dFxuICAgIG5vcm1hbGl6ZWQuc29ydCgpO1xuXG4gICAgLy8gOCkgUmV0dXJuIHRoZSBub3JtYWxpemVkIGRhdGFzZXQuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQuam9pbignJyk7XG4gIH1cblxuICAvLyA0LjYpIEhhc2ggRmlyc3QgRGVncmVlIFF1YWRzXG4gIGhhc2hGaXJzdERlZ3JlZVF1YWRzKGlkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyByZXR1cm4gY2FjaGVkIGhhc2hcbiAgICBjb25zdCBpbmZvID0gc2VsZi5ibGFua05vZGVJbmZvW2lkXTtcbiAgICBpZignaGFzaCcgaW4gaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uaGFzaDtcbiAgICB9XG5cbiAgICAvLyAxKSBJbml0aWFsaXplIG5xdWFkcyB0byBhbiBlbXB0eSBsaXN0LiBJdCB3aWxsIGJlIHVzZWQgdG8gc3RvcmUgcXVhZHMgaW5cbiAgICAvLyBOLVF1YWRzIGZvcm1hdC5cbiAgICBjb25zdCBucXVhZHMgPSBbXTtcblxuICAgIC8vIDIpIEdldCB0aGUgbGlzdCBvZiBxdWFkcyBgcXVhZHNgIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVmZXJlbmNlIGJsYW5rIG5vZGVcbiAgICAvLyBpZGVudGlmaWVyIGluIHRoZSBibGFuayBub2RlIHRvIHF1YWRzIG1hcC5cbiAgICBjb25zdCBxdWFkcyA9IGluZm8ucXVhZHM7XG5cbiAgICAvLyAzKSBGb3IgZWFjaCBxdWFkIGBxdWFkYCBpbiBgcXVhZHNgOlxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBxdWFkcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcXVhZCA9IHF1YWRzW2ldO1xuXG4gICAgICAvLyAzLjEpIFNlcmlhbGl6ZSB0aGUgcXVhZCBpbiBOLVF1YWRzIGZvcm1hdCB3aXRoIHRoZSBmb2xsb3dpbmcgc3BlY2lhbFxuICAgICAgLy8gcnVsZTpcblxuICAgICAgLy8gMy4xLjEpIElmIGFueSBjb21wb25lbnQgaW4gcXVhZCBpcyBhbiBibGFuayBub2RlLCB0aGVuIHNlcmlhbGl6ZSBpdFxuICAgICAgLy8gdXNpbmcgYSBzcGVjaWFsIGlkZW50aWZpZXIgYXMgZm9sbG93czpcbiAgICAgIGNvbnN0IGNvcHkgPSB7cHJlZGljYXRlOiBxdWFkLnByZWRpY2F0ZX07XG4gICAgICBzZWxmLmZvckVhY2hDb21wb25lbnQocXVhZCwgKGNvbXBvbmVudCwga2V5KSA9PiB7XG4gICAgICAgIC8vIDMuMS4yKSBJZiB0aGUgYmxhbmsgbm9kZSdzIGV4aXN0aW5nIGJsYW5rIG5vZGUgaWRlbnRpZmllciBtYXRjaGVzXG4gICAgICAgIC8vIHRoZSByZWZlcmVuY2UgYmxhbmsgbm9kZSBpZGVudGlmaWVyIHRoZW4gdXNlIHRoZSBibGFuayBub2RlXG4gICAgICAgIC8vIGlkZW50aWZpZXIgXzphLCBvdGhlcndpc2UsIHVzZSB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIF86ei5cbiAgICAgICAgY29weVtrZXldID0gc2VsZi5tb2RpZnlGaXJzdERlZ3JlZUNvbXBvbmVudChpZCwgY29tcG9uZW50LCBrZXkpO1xuICAgICAgfSk7XG4gICAgICBucXVhZHMucHVzaChOUXVhZHMuc2VyaWFsaXplUXVhZChjb3B5KSk7XG4gICAgfVxuXG4gICAgLy8gNCkgU29ydCBucXVhZHMgaW4gbGV4aWNvZ3JhcGhpY2FsIG9yZGVyLlxuICAgIG5xdWFkcy5zb3J0KCk7XG5cbiAgICAvLyA1KSBSZXR1cm4gdGhlIGhhc2ggdGhhdCByZXN1bHRzIGZyb20gcGFzc2luZyB0aGUgc29ydGVkLCBqb2luZWQgbnF1YWRzXG4gICAgLy8gdGhyb3VnaCB0aGUgaGFzaCBhbGdvcml0aG0uXG4gICAgY29uc3QgbWQgPSBuZXcgTWVzc2FnZURpZ2VzdChzZWxmLmhhc2hBbGdvcml0aG0pO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBucXVhZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG1kLnVwZGF0ZShucXVhZHNbaV0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiByZXByZXNlbnQgYXMgYnl0ZSBidWZmZXIgaW5zdGVhZCB0byBjdXQgbWVtb3J5IHVzYWdlIGluIGhhbGZcbiAgICBpbmZvLmhhc2ggPSBtZC5kaWdlc3QoKTtcbiAgICByZXR1cm4gaW5mby5oYXNoO1xuICB9XG5cbiAgLy8gNC43KSBIYXNoIFJlbGF0ZWQgQmxhbmsgTm9kZVxuICBoYXNoUmVsYXRlZEJsYW5rTm9kZShyZWxhdGVkLCBxdWFkLCBpc3N1ZXIsIHBvc2l0aW9uKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyAxKSBTZXQgdGhlIGlkZW50aWZpZXIgdG8gdXNlIGZvciByZWxhdGVkLCBwcmVmZXJyaW5nIGZpcnN0IHRoZSBjYW5vbmljYWxcbiAgICAvLyBpZGVudGlmaWVyIGZvciByZWxhdGVkIGlmIGlzc3VlZCwgc2Vjb25kIHRoZSBpZGVudGlmaWVyIGlzc3VlZCBieSBpc3N1ZXJcbiAgICAvLyBpZiBpc3N1ZWQsIGFuZCBsYXN0LCBpZiBuZWNlc3NhcnksIHRoZSByZXN1bHQgb2YgdGhlIEhhc2ggRmlyc3QgRGVncmVlXG4gICAgLy8gUXVhZHMgYWxnb3JpdGhtLCBwYXNzaW5nIHJlbGF0ZWQuXG4gICAgbGV0IGlkO1xuICAgIGlmKHNlbGYuY2Fub25pY2FsSXNzdWVyLmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICBpZCA9IHNlbGYuY2Fub25pY2FsSXNzdWVyLmdldElkKHJlbGF0ZWQpO1xuICAgIH0gZWxzZSBpZihpc3N1ZXIuaGFzSWQocmVsYXRlZCkpIHtcbiAgICAgIGlkID0gaXNzdWVyLmdldElkKHJlbGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHNlbGYuaGFzaEZpcnN0RGVncmVlUXVhZHMocmVsYXRlZCk7XG4gICAgfVxuXG4gICAgLy8gMikgSW5pdGlhbGl6ZSBhIHN0cmluZyBpbnB1dCB0byB0aGUgdmFsdWUgb2YgcG9zaXRpb24uXG4gICAgLy8gTm90ZTogV2UgdXNlIGEgaGFzaCBvYmplY3QgaW5zdGVhZC5cbiAgICBjb25zdCBtZCA9IG5ldyBNZXNzYWdlRGlnZXN0KHNlbGYuaGFzaEFsZ29yaXRobSk7XG4gICAgbWQudXBkYXRlKHBvc2l0aW9uKTtcblxuICAgIC8vIDMpIElmIHBvc2l0aW9uIGlzIG5vdCBnLCBhcHBlbmQgPCwgdGhlIHZhbHVlIG9mIHRoZSBwcmVkaWNhdGUgaW4gcXVhZCxcbiAgICAvLyBhbmQgPiB0byBpbnB1dC5cbiAgICBpZihwb3NpdGlvbiAhPT0gJ2cnKSB7XG4gICAgICBtZC51cGRhdGUoc2VsZi5nZXRSZWxhdGVkUHJlZGljYXRlKHF1YWQpKTtcbiAgICB9XG5cbiAgICAvLyA0KSBBcHBlbmQgaWRlbnRpZmllciB0byBpbnB1dC5cbiAgICBtZC51cGRhdGUoaWQpO1xuXG4gICAgLy8gNSkgUmV0dXJuIHRoZSBoYXNoIHRoYXQgcmVzdWx0cyBmcm9tIHBhc3NpbmcgaW5wdXQgdGhyb3VnaCB0aGUgaGFzaFxuICAgIC8vIGFsZ29yaXRobS5cbiAgICAvLyBUT0RPOiByZXByZXNlbnQgYXMgYnl0ZSBidWZmZXIgaW5zdGVhZCB0byBjdXQgbWVtb3J5IHVzYWdlIGluIGhhbGZcbiAgICByZXR1cm4gbWQuZGlnZXN0KCk7XG4gIH1cblxuICAvLyA0LjgpIEhhc2ggTi1EZWdyZWUgUXVhZHNcbiAgaGFzaE5EZWdyZWVRdWFkcyhpZCwgaXNzdWVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyAxKSBDcmVhdGUgYSBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwIGZvciBzdG9yaW5nIGhhc2hlcyB0aGF0XG4gICAgLy8gaWRlbnRpZnkgcmVsYXRlZCBibGFuayBub2Rlcy5cbiAgICAvLyBOb3RlOiAyKSBhbmQgMykgaGFuZGxlZCB3aXRoaW4gYGNyZWF0ZUhhc2hUb1JlbGF0ZWRgXG4gICAgY29uc3QgbWQgPSBuZXcgTWVzc2FnZURpZ2VzdChzZWxmLmhhc2hBbGdvcml0aG0pO1xuICAgIGNvbnN0IGhhc2hUb1JlbGF0ZWQgPSBzZWxmLmNyZWF0ZUhhc2hUb1JlbGF0ZWQoaWQsIGlzc3Vlcik7XG5cbiAgICAvLyA0KSBDcmVhdGUgYW4gZW1wdHkgc3RyaW5nLCBkYXRhIHRvIGhhc2guXG4gICAgLy8gTm90ZTogV2UgY3JlYXRlZCBhIGhhc2ggb2JqZWN0IGBtZGAgYWJvdmUgaW5zdGVhZC5cblxuICAgIC8vIDUpIEZvciBlYWNoIHJlbGF0ZWQgaGFzaCB0byBibGFuayBub2RlIGxpc3QgbWFwcGluZyBpbiBoYXNoIHRvIHJlbGF0ZWRcbiAgICAvLyBibGFuayBub2RlcyBtYXAsIHNvcnRlZCBsZXhpY29ncmFwaGljYWxseSBieSByZWxhdGVkIGhhc2g6XG4gICAgY29uc3QgaGFzaGVzID0gT2JqZWN0LmtleXMoaGFzaFRvUmVsYXRlZCkuc29ydCgpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBoYXNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIDUuMSkgQXBwZW5kIHRoZSByZWxhdGVkIGhhc2ggdG8gdGhlIGRhdGEgdG8gaGFzaC5cbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoZXNbaV07XG4gICAgICBtZC51cGRhdGUoaGFzaCk7XG5cbiAgICAgIC8vIDUuMikgQ3JlYXRlIGEgc3RyaW5nIGNob3NlbiBwYXRoLlxuICAgICAgbGV0IGNob3NlblBhdGggPSAnJztcblxuICAgICAgLy8gNS4zKSBDcmVhdGUgYW4gdW5zZXQgY2hvc2VuIGlzc3VlciB2YXJpYWJsZS5cbiAgICAgIGxldCBjaG9zZW5Jc3N1ZXI7XG5cbiAgICAgIC8vIDUuNCkgRm9yIGVhY2ggcGVybXV0YXRpb24gb2YgYmxhbmsgbm9kZSBsaXN0OlxuICAgICAgY29uc3QgcGVybXV0YXRvciA9IG5ldyBQZXJtdXRhdG9yKGhhc2hUb1JlbGF0ZWRbaGFzaF0pO1xuICAgICAgd2hpbGUocGVybXV0YXRvci5oYXNOZXh0KCkpIHtcbiAgICAgICAgY29uc3QgcGVybXV0YXRpb24gPSBwZXJtdXRhdG9yLm5leHQoKTtcblxuICAgICAgICAvLyA1LjQuMSkgQ3JlYXRlIGEgY29weSBvZiBpc3N1ZXIsIGlzc3VlciBjb3B5LlxuICAgICAgICBsZXQgaXNzdWVyQ29weSA9IGlzc3Vlci5jbG9uZSgpO1xuXG4gICAgICAgIC8vIDUuNC4yKSBDcmVhdGUgYSBzdHJpbmcgcGF0aC5cbiAgICAgICAgbGV0IHBhdGggPSAnJztcblxuICAgICAgICAvLyA1LjQuMykgQ3JlYXRlIGEgcmVjdXJzaW9uIGxpc3QsIHRvIHN0b3JlIGJsYW5rIG5vZGUgaWRlbnRpZmllcnNcbiAgICAgICAgLy8gdGhhdCBtdXN0IGJlIHJlY3Vyc2l2ZWx5IHByb2Nlc3NlZCBieSB0aGlzIGFsZ29yaXRobS5cbiAgICAgICAgY29uc3QgcmVjdXJzaW9uTGlzdCA9IFtdO1xuXG4gICAgICAgIC8vIDUuNC40KSBGb3IgZWFjaCByZWxhdGVkIGluIHBlcm11dGF0aW9uOlxuICAgICAgICBsZXQgbmV4dFBlcm11dGF0aW9uID0gZmFsc2U7XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBwZXJtdXRhdGlvbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgIC8vIDUuNC40LjEpIElmIGEgY2Fub25pY2FsIGlkZW50aWZpZXIgaGFzIGJlZW4gaXNzdWVkIGZvclxuICAgICAgICAgIC8vIHJlbGF0ZWQsIGFwcGVuZCBpdCB0byBwYXRoLlxuICAgICAgICAgIGNvbnN0IHJlbGF0ZWQgPSBwZXJtdXRhdGlvbltqXTtcbiAgICAgICAgICBpZihzZWxmLmNhbm9uaWNhbElzc3Vlci5oYXNJZChyZWxhdGVkKSkge1xuICAgICAgICAgICAgcGF0aCArPSBzZWxmLmNhbm9uaWNhbElzc3Vlci5nZXRJZChyZWxhdGVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNS40LjQuMikgT3RoZXJ3aXNlOlxuICAgICAgICAgICAgLy8gNS40LjQuMi4xKSBJZiBpc3N1ZXIgY29weSBoYXMgbm90IGlzc3VlZCBhbiBpZGVudGlmaWVyIGZvclxuICAgICAgICAgICAgLy8gcmVsYXRlZCwgYXBwZW5kIHJlbGF0ZWQgdG8gcmVjdXJzaW9uIGxpc3QuXG4gICAgICAgICAgICBpZighaXNzdWVyQ29weS5oYXNJZChyZWxhdGVkKSkge1xuICAgICAgICAgICAgICByZWN1cnNpb25MaXN0LnB1c2gocmVsYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA1LjQuNC4yLjIpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmdcbiAgICAgICAgICAgIC8vIGlzc3VlciBjb3B5IGFuZCByZWxhdGVkIGFuZCBhcHBlbmQgdGhlIHJlc3VsdCB0byBwYXRoLlxuICAgICAgICAgICAgcGF0aCArPSBpc3N1ZXJDb3B5LmdldElkKHJlbGF0ZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDUuNC40LjMpIElmIGNob3NlbiBwYXRoIGlzIG5vdCBlbXB0eSBhbmQgdGhlIGxlbmd0aCBvZiBwYXRoXG4gICAgICAgICAgLy8gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgY2hvc2VuIHBhdGggYW5kXG4gICAgICAgICAgLy8gcGF0aCBpcyBsZXhpY29ncmFwaGljYWxseSBncmVhdGVyIHRoYW4gY2hvc2VuIHBhdGgsIHRoZW5cbiAgICAgICAgICAvLyBza2lwIHRvIHRoZSBuZXh0IHBlcm11dGF0aW9uLlxuICAgICAgICAgIC8vIE5vdGU6IENvbXBhcmluZyBwYXRoIGxlbmd0aCB0byBjaG9zZW4gcGF0aCBsZW5ndGggY2FuIGJlIG9wdGltaXplZFxuICAgICAgICAgIC8vIGF3YXk7IG9ubHkgY29tcGFyZSBsZXhpY29ncmFwaGljYWxseS5cbiAgICAgICAgICBpZihjaG9zZW5QYXRoLmxlbmd0aCAhPT0gMCAmJiBwYXRoID4gY2hvc2VuUGF0aCkge1xuICAgICAgICAgICAgbmV4dFBlcm11dGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG5leHRQZXJtdXRhdGlvbikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS40LjUpIEZvciBlYWNoIHJlbGF0ZWQgaW4gcmVjdXJzaW9uIGxpc3Q6XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCByZWN1cnNpb25MaXN0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgLy8gNS40LjUuMSkgU2V0IHJlc3VsdCB0byB0aGUgcmVzdWx0IG9mIHJlY3Vyc2l2ZWx5IGV4ZWN1dGluZ1xuICAgICAgICAgIC8vIHRoZSBIYXNoIE4tRGVncmVlIFF1YWRzIGFsZ29yaXRobSwgcGFzc2luZyByZWxhdGVkIGZvclxuICAgICAgICAgIC8vIGlkZW50aWZpZXIgYW5kIGlzc3VlciBjb3B5IGZvciBwYXRoIGlkZW50aWZpZXIgaXNzdWVyLlxuICAgICAgICAgIGNvbnN0IHJlbGF0ZWQgPSByZWN1cnNpb25MaXN0W2pdO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNlbGYuaGFzaE5EZWdyZWVRdWFkcyhyZWxhdGVkLCBpc3N1ZXJDb3B5KTtcblxuICAgICAgICAgIC8vIDUuNC41LjIpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmcgaXNzdWVyXG4gICAgICAgICAgLy8gY29weSBhbmQgcmVsYXRlZCBhbmQgYXBwZW5kIHRoZSByZXN1bHQgdG8gcGF0aC5cbiAgICAgICAgICBwYXRoICs9IGlzc3VlckNvcHkuZ2V0SWQocmVsYXRlZCk7XG5cbiAgICAgICAgICAvLyA1LjQuNS4zKSBBcHBlbmQgPCwgdGhlIGhhc2ggaW4gcmVzdWx0LCBhbmQgPiB0byBwYXRoLlxuICAgICAgICAgIHBhdGggKz0gJzwnICsgcmVzdWx0Lmhhc2ggKyAnPic7XG5cbiAgICAgICAgICAvLyA1LjQuNS40KSBTZXQgaXNzdWVyIGNvcHkgdG8gdGhlIGlkZW50aWZpZXIgaXNzdWVyIGluXG4gICAgICAgICAgLy8gcmVzdWx0LlxuICAgICAgICAgIGlzc3VlckNvcHkgPSByZXN1bHQuaXNzdWVyO1xuXG4gICAgICAgICAgLy8gNS40LjUuNSkgSWYgY2hvc2VuIHBhdGggaXMgbm90IGVtcHR5IGFuZCB0aGUgbGVuZ3RoIG9mIHBhdGhcbiAgICAgICAgICAvLyBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiBjaG9zZW4gcGF0aCBhbmRcbiAgICAgICAgICAvLyBwYXRoIGlzIGxleGljb2dyYXBoaWNhbGx5IGdyZWF0ZXIgdGhhbiBjaG9zZW4gcGF0aCwgdGhlblxuICAgICAgICAgIC8vIHNraXAgdG8gdGhlIG5leHQgcGVybXV0YXRpb24uXG4gICAgICAgICAgLy8gTm90ZTogQ29tcGFyaW5nIHBhdGggbGVuZ3RoIHRvIGNob3NlbiBwYXRoIGxlbmd0aCBjYW4gYmUgb3B0aW1pemVkXG4gICAgICAgICAgLy8gYXdheTsgb25seSBjb21wYXJlIGxleGljb2dyYXBoaWNhbGx5LlxuICAgICAgICAgIGlmKGNob3NlblBhdGgubGVuZ3RoICE9PSAwICYmIHBhdGggPiBjaG9zZW5QYXRoKSB7XG4gICAgICAgICAgICBuZXh0UGVybXV0YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYobmV4dFBlcm11dGF0aW9uKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LjQuNikgSWYgY2hvc2VuIHBhdGggaXMgZW1wdHkgb3IgcGF0aCBpcyBsZXhpY29ncmFwaGljYWxseVxuICAgICAgICAvLyBsZXNzIHRoYW4gY2hvc2VuIHBhdGgsIHNldCBjaG9zZW4gcGF0aCB0byBwYXRoIGFuZCBjaG9zZW5cbiAgICAgICAgLy8gaXNzdWVyIHRvIGlzc3VlciBjb3B5LlxuICAgICAgICBpZihjaG9zZW5QYXRoLmxlbmd0aCA9PT0gMCB8fCBwYXRoIDwgY2hvc2VuUGF0aCkge1xuICAgICAgICAgIGNob3NlblBhdGggPSBwYXRoO1xuICAgICAgICAgIGNob3Nlbklzc3VlciA9IGlzc3VlckNvcHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNS41KSBBcHBlbmQgY2hvc2VuIHBhdGggdG8gZGF0YSB0byBoYXNoLlxuICAgICAgbWQudXBkYXRlKGNob3NlblBhdGgpO1xuXG4gICAgICAvLyA1LjYpIFJlcGxhY2UgaXNzdWVyLCBieSByZWZlcmVuY2UsIHdpdGggY2hvc2VuIGlzc3Vlci5cbiAgICAgIGlzc3VlciA9IGNob3Nlbklzc3VlcjtcbiAgICB9XG5cbiAgICAvLyA2KSBSZXR1cm4gaXNzdWVyIGFuZCB0aGUgaGFzaCB0aGF0IHJlc3VsdHMgZnJvbSBwYXNzaW5nIGRhdGEgdG8gaGFzaFxuICAgIC8vIHRocm91Z2ggdGhlIGhhc2ggYWxnb3JpdGhtLlxuICAgIHJldHVybiB7aGFzaDogbWQuZGlnZXN0KCksIGlzc3Vlcn07XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIG1vZGlmeWluZyBjb21wb25lbnQgZHVyaW5nIEhhc2ggRmlyc3QgRGVncmVlIFF1YWRzXG4gIG1vZGlmeUZpcnN0RGVncmVlQ29tcG9uZW50KGlkLCBjb21wb25lbnQpIHtcbiAgICBpZihjb21wb25lbnQudGVybVR5cGUgIT09ICdCbGFua05vZGUnKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cbiAgICBjb21wb25lbnQgPSB1dGlsLmNsb25lKGNvbXBvbmVudCk7XG4gICAgY29tcG9uZW50LnZhbHVlID0gKGNvbXBvbmVudC52YWx1ZSA9PT0gaWQgPyAnXzphJyA6ICdfOnonKTtcbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBnZXR0aW5nIGEgcmVsYXRlZCBwcmVkaWNhdGVcbiAgZ2V0UmVsYXRlZFByZWRpY2F0ZShxdWFkKSB7XG4gICAgcmV0dXJuICc8JyArIHF1YWQucHJlZGljYXRlLnZhbHVlICsgJz4nO1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjcmVhdGluZyBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwXG4gIGNyZWF0ZUhhc2hUb1JlbGF0ZWQoaWQsIGlzc3Vlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gMSkgQ3JlYXRlIGEgaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcCBmb3Igc3RvcmluZyBoYXNoZXMgdGhhdFxuICAgIC8vIGlkZW50aWZ5IHJlbGF0ZWQgYmxhbmsgbm9kZXMuXG4gICAgY29uc3QgaGFzaFRvUmVsYXRlZCA9IHt9O1xuXG4gICAgLy8gMikgR2V0IGEgcmVmZXJlbmNlLCBxdWFkcywgdG8gdGhlIGxpc3Qgb2YgcXVhZHMgaW4gdGhlIGJsYW5rIG5vZGUgdG9cbiAgICAvLyBxdWFkcyBtYXAgZm9yIHRoZSBrZXkgaWRlbnRpZmllci5cbiAgICBjb25zdCBxdWFkcyA9IHNlbGYuYmxhbmtOb2RlSW5mb1tpZF0ucXVhZHM7XG5cbiAgICAvLyAzKSBGb3IgZWFjaCBxdWFkIGluIHF1YWRzOlxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBxdWFkcy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gMy4xKSBGb3IgZWFjaCBjb21wb25lbnQgaW4gcXVhZCwgaWYgY29tcG9uZW50IGlzIHRoZSBzdWJqZWN0LCBvYmplY3QsXG4gICAgICAvLyBhbmQgZ3JhcGggbmFtZSBhbmQgaXQgaXMgYSBibGFuayBub2RlIHRoYXQgaXMgbm90IGlkZW50aWZpZWQgYnlcbiAgICAgIC8vIGlkZW50aWZpZXI6XG4gICAgICBjb25zdCBxdWFkID0gcXVhZHNbaV07XG4gICAgICBmb3IoY29uc3Qga2V5IGluIHF1YWQpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcXVhZFtrZXldO1xuICAgICAgICBpZihrZXkgPT09ICdwcmVkaWNhdGUnIHx8XG4gICAgICAgICAgIShjb21wb25lbnQudGVybVR5cGUgPT09ICdCbGFua05vZGUnICYmIGNvbXBvbmVudC52YWx1ZSAhPT0gaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjEpIFNldCBoYXNoIHRvIHRoZSByZXN1bHQgb2YgdGhlIEhhc2ggUmVsYXRlZCBCbGFuayBOb2RlXG4gICAgICAgIC8vIGFsZ29yaXRobSwgcGFzc2luZyB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGZvciBjb21wb25lbnQgYXNcbiAgICAgICAgLy8gcmVsYXRlZCwgcXVhZCwgcGF0aCBpZGVudGlmaWVyIGlzc3VlciBhcyBpc3N1ZXIsIGFuZCBwb3NpdGlvbiBhc1xuICAgICAgICAvLyBlaXRoZXIgcywgbywgb3IgZyBiYXNlZCBvbiB3aGV0aGVyIGNvbXBvbmVudCBpcyBhIHN1YmplY3QsIG9iamVjdCxcbiAgICAgICAgLy8gZ3JhcGggbmFtZSwgcmVzcGVjdGl2ZWx5LlxuICAgICAgICBjb25zdCByZWxhdGVkID0gY29tcG9uZW50LnZhbHVlO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IFBPU0lUSU9OU1trZXldO1xuICAgICAgICBjb25zdCBoYXNoID0gc2VsZi5oYXNoUmVsYXRlZEJsYW5rTm9kZShyZWxhdGVkLCBxdWFkLCBpc3N1ZXIsIHBvc2l0aW9uKTtcblxuICAgICAgICAvLyAzLjEuMikgQWRkIGEgbWFwcGluZyBvZiBoYXNoIHRvIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgZm9yXG4gICAgICAgIC8vIGNvbXBvbmVudCB0byBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwLCBhZGRpbmcgYW4gZW50cnkgYXNcbiAgICAgICAgLy8gbmVjZXNzYXJ5LlxuICAgICAgICBpZihoYXNoIGluIGhhc2hUb1JlbGF0ZWQpIHtcbiAgICAgICAgICBoYXNoVG9SZWxhdGVkW2hhc2hdLnB1c2gocmVsYXRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzaFRvUmVsYXRlZFtoYXNoXSA9IFtyZWxhdGVkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXNoVG9SZWxhdGVkO1xuICB9XG5cbiAgLy8gaGVscGVyIHRoYXQgaXRlcmF0ZXMgb3ZlciBxdWFkIGNvbXBvbmVudHMgKHNraXBzIHByZWRpY2F0ZSlcbiAgZm9yRWFjaENvbXBvbmVudChxdWFkLCBvcCkge1xuICAgIGZvcihjb25zdCBrZXkgaW4gcXVhZCkge1xuICAgICAgLy8gc2tpcCBgcHJlZGljYXRlYFxuICAgICAgaWYoa2V5ID09PSAncHJlZGljYXRlJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG9wKHF1YWRba2V5XSwga2V5LCBxdWFkKTtcbiAgICB9XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVUkROQTIwMTUgPSByZXF1aXJlKCcuL1VSRE5BMjAxNScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFVSRE5BMjAxMiBleHRlbmRzIFVSRE5BMjAxNSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLm5hbWUgPSAnVVJHTkEyMDEyJztcbiAgICB0aGlzLmhhc2hBbGdvcml0aG0gPSAnc2hhMSc7XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIG1vZGlmeWluZyBjb21wb25lbnQgZHVyaW5nIEhhc2ggRmlyc3QgRGVncmVlIFF1YWRzXG4gIG1vZGlmeUZpcnN0RGVncmVlQ29tcG9uZW50KGlkLCBjb21wb25lbnQsIGtleSkge1xuICAgIGlmKGNvbXBvbmVudC50ZXJtVHlwZSAhPT0gJ0JsYW5rTm9kZScpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuICAgIGNvbXBvbmVudCA9IHV0aWwuY2xvbmUoY29tcG9uZW50KTtcbiAgICBpZihrZXkgPT09ICduYW1lJykge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gJ186Zyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC52YWx1ZSA9IChjb21wb25lbnQudmFsdWUgPT09IGlkID8gJ186YScgOiAnXzp6Jyk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIGdldHRpbmcgYSByZWxhdGVkIHByZWRpY2F0ZVxuICBnZXRSZWxhdGVkUHJlZGljYXRlKHF1YWQpIHtcbiAgICByZXR1cm4gcXVhZC5wcmVkaWNhdGUudmFsdWU7XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIGNyZWF0aW5nIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXBcbiAgY3JlYXRlSGFzaFRvUmVsYXRlZChpZCwgaXNzdWVyLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gMSkgQ3JlYXRlIGEgaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcCBmb3Igc3RvcmluZyBoYXNoZXMgdGhhdFxuICAgIC8vIGlkZW50aWZ5IHJlbGF0ZWQgYmxhbmsgbm9kZXMuXG4gICAgY29uc3QgaGFzaFRvUmVsYXRlZCA9IHt9O1xuXG4gICAgLy8gMikgR2V0IGEgcmVmZXJlbmNlLCBxdWFkcywgdG8gdGhlIGxpc3Qgb2YgcXVhZHMgaW4gdGhlIGJsYW5rIG5vZGUgdG9cbiAgICAvLyBxdWFkcyBtYXAgZm9yIHRoZSBrZXkgaWRlbnRpZmllci5cbiAgICBjb25zdCBxdWFkcyA9IHNlbGYuYmxhbmtOb2RlSW5mb1tpZF0ucXVhZHM7XG5cbiAgICAvLyAzKSBGb3IgZWFjaCBxdWFkIGluIHF1YWRzOlxuICAgIHNlbGYuZm9yRWFjaChxdWFkcywgKHF1YWQsIGlkeCwgY2FsbGJhY2spID0+IHtcbiAgICAgIC8vIDMuMSkgSWYgdGhlIHF1YWQncyBzdWJqZWN0IGlzIGEgYmxhbmsgbm9kZSB0aGF0IGRvZXMgbm90IG1hdGNoXG4gICAgICAvLyBpZGVudGlmaWVyLCBzZXQgaGFzaCB0byB0aGUgcmVzdWx0IG9mIHRoZSBIYXNoIFJlbGF0ZWQgQmxhbmsgTm9kZVxuICAgICAgLy8gYWxnb3JpdGhtLCBwYXNzaW5nIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgZm9yIHN1YmplY3QgYXMgcmVsYXRlZCxcbiAgICAgIC8vIHF1YWQsIHBhdGggaWRlbnRpZmllciBpc3N1ZXIgYXMgaXNzdWVyLCBhbmQgcCBhcyBwb3NpdGlvbi5cbiAgICAgIGxldCBwb3NpdGlvbjtcbiAgICAgIGxldCByZWxhdGVkO1xuICAgICAgaWYocXVhZC5zdWJqZWN0LnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJyAmJiBxdWFkLnN1YmplY3QudmFsdWUgIT09IGlkKSB7XG4gICAgICAgIHJlbGF0ZWQgPSBxdWFkLnN1YmplY3QudmFsdWU7XG4gICAgICAgIHBvc2l0aW9uID0gJ3AnO1xuICAgICAgfSBlbHNlIGlmKFxuICAgICAgICBxdWFkLm9iamVjdC50ZXJtVHlwZSA9PT0gJ0JsYW5rTm9kZScgJiYgcXVhZC5vYmplY3QudmFsdWUgIT09IGlkKSB7XG4gICAgICAgIC8vIDMuMikgT3RoZXJ3aXNlLCBpZiBxdWFkJ3Mgb2JqZWN0IGlzIGEgYmxhbmsgbm9kZSB0aGF0IGRvZXMgbm90IG1hdGNoXG4gICAgICAgIC8vIGlkZW50aWZpZXIsIHRvIHRoZSByZXN1bHQgb2YgdGhlIEhhc2ggUmVsYXRlZCBCbGFuayBOb2RlIGFsZ29yaXRobSxcbiAgICAgICAgLy8gcGFzc2luZyB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGZvciBvYmplY3QgYXMgcmVsYXRlZCwgcXVhZCwgcGF0aFxuICAgICAgICAvLyBpZGVudGlmaWVyIGlzc3VlciBhcyBpc3N1ZXIsIGFuZCByIGFzIHBvc2l0aW9uLlxuICAgICAgICByZWxhdGVkID0gcXVhZC5vYmplY3QudmFsdWU7XG4gICAgICAgIHBvc2l0aW9uID0gJ3InO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMy4zKSBPdGhlcndpc2UsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHF1YWQuXG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgLy8gMy40KSBBZGQgYSBtYXBwaW5nIG9mIGhhc2ggdG8gdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBmb3IgdGhlXG4gICAgICAvLyBjb21wb25lbnQgdGhhdCBtYXRjaGVkIChzdWJqZWN0IG9yIG9iamVjdCkgdG8gaGFzaCB0byByZWxhdGVkIGJsYW5rXG4gICAgICAvLyBub2RlcyBtYXAsIGFkZGluZyBhbiBlbnRyeSBhcyBuZWNlc3NhcnkuXG4gICAgICBzZWxmLmhhc2hSZWxhdGVkQmxhbmtOb2RlKFxuICAgICAgICByZWxhdGVkLCBxdWFkLCBpc3N1ZXIsIHBvc2l0aW9uLCAoZXJyLCBoYXNoKSA9PiB7XG4gICAgICAgICAgaWYoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoaGFzaCBpbiBoYXNoVG9SZWxhdGVkKSB7XG4gICAgICAgICAgICBoYXNoVG9SZWxhdGVkW2hhc2hdLnB1c2gocmVsYXRlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc2hUb1JlbGF0ZWRbaGFzaF0gPSBbcmVsYXRlZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH0sIGVyciA9PiBjYWxsYmFjayhlcnIsIGhhc2hUb1JlbGF0ZWQpKTtcbiAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVUkROQTIwMTVTeW5jID0gcmVxdWlyZSgnLi9VUkROQTIwMTVTeW5jJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVVJETkEyMDEyU3luYyBleHRlbmRzIFVSRE5BMjAxNVN5bmMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZSA9ICdVUkdOQTIwMTInO1xuICAgIHRoaXMuaGFzaEFsZ29yaXRobSA9ICdzaGExJztcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgbW9kaWZ5aW5nIGNvbXBvbmVudCBkdXJpbmcgSGFzaCBGaXJzdCBEZWdyZWUgUXVhZHNcbiAgbW9kaWZ5Rmlyc3REZWdyZWVDb21wb25lbnQoaWQsIGNvbXBvbmVudCwga2V5KSB7XG4gICAgaWYoY29tcG9uZW50LnRlcm1UeXBlICE9PSAnQmxhbmtOb2RlJykge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG4gICAgY29tcG9uZW50ID0gdXRpbC5jbG9uZShjb21wb25lbnQpO1xuICAgIGlmKGtleSA9PT0gJ25hbWUnKSB7XG4gICAgICBjb21wb25lbnQudmFsdWUgPSAnXzpnJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gKGNvbXBvbmVudC52YWx1ZSA9PT0gaWQgPyAnXzphJyA6ICdfOnonKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgZ2V0dGluZyBhIHJlbGF0ZWQgcHJlZGljYXRlXG4gIGdldFJlbGF0ZWRQcmVkaWNhdGUocXVhZCkge1xuICAgIHJldHVybiBxdWFkLnByZWRpY2F0ZS52YWx1ZTtcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgY3JlYXRpbmcgaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcFxuICBjcmVhdGVIYXNoVG9SZWxhdGVkKGlkLCBpc3N1ZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIDEpIENyZWF0ZSBhIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXAgZm9yIHN0b3JpbmcgaGFzaGVzIHRoYXRcbiAgICAvLyBpZGVudGlmeSByZWxhdGVkIGJsYW5rIG5vZGVzLlxuICAgIGNvbnN0IGhhc2hUb1JlbGF0ZWQgPSB7fTtcblxuICAgIC8vIDIpIEdldCBhIHJlZmVyZW5jZSwgcXVhZHMsIHRvIHRoZSBsaXN0IG9mIHF1YWRzIGluIHRoZSBibGFuayBub2RlIHRvXG4gICAgLy8gcXVhZHMgbWFwIGZvciB0aGUga2V5IGlkZW50aWZpZXIuXG4gICAgY29uc3QgcXVhZHMgPSBzZWxmLmJsYW5rTm9kZUluZm9baWRdLnF1YWRzO1xuXG4gICAgLy8gMykgRm9yIGVhY2ggcXVhZCBpbiBxdWFkczpcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcXVhZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIDMuMSkgSWYgdGhlIHF1YWQncyBzdWJqZWN0IGlzIGEgYmxhbmsgbm9kZSB0aGF0IGRvZXMgbm90IG1hdGNoXG4gICAgICAvLyBpZGVudGlmaWVyLCBzZXQgaGFzaCB0byB0aGUgcmVzdWx0IG9mIHRoZSBIYXNoIFJlbGF0ZWQgQmxhbmsgTm9kZVxuICAgICAgLy8gYWxnb3JpdGhtLCBwYXNzaW5nIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgZm9yIHN1YmplY3QgYXMgcmVsYXRlZCxcbiAgICAgIC8vIHF1YWQsIHBhdGggaWRlbnRpZmllciBpc3N1ZXIgYXMgaXNzdWVyLCBhbmQgcCBhcyBwb3NpdGlvbi5cbiAgICAgIGNvbnN0IHF1YWQgPSBxdWFkc1tpXTtcbiAgICAgIGxldCBwb3NpdGlvbjtcbiAgICAgIGxldCByZWxhdGVkO1xuICAgICAgaWYocXVhZC5zdWJqZWN0LnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJyAmJiBxdWFkLnN1YmplY3QudmFsdWUgIT09IGlkKSB7XG4gICAgICAgIHJlbGF0ZWQgPSBxdWFkLnN1YmplY3QudmFsdWU7XG4gICAgICAgIHBvc2l0aW9uID0gJ3AnO1xuICAgICAgfSBlbHNlIGlmKFxuICAgICAgICBxdWFkLm9iamVjdC50ZXJtVHlwZSA9PT0gJ0JsYW5rTm9kZScgJiYgcXVhZC5vYmplY3QudmFsdWUgIT09IGlkKSB7XG4gICAgICAgIC8vIDMuMikgT3RoZXJ3aXNlLCBpZiBxdWFkJ3Mgb2JqZWN0IGlzIGEgYmxhbmsgbm9kZSB0aGF0IGRvZXMgbm90IG1hdGNoXG4gICAgICAgIC8vIGlkZW50aWZpZXIsIHRvIHRoZSByZXN1bHQgb2YgdGhlIEhhc2ggUmVsYXRlZCBCbGFuayBOb2RlIGFsZ29yaXRobSxcbiAgICAgICAgLy8gcGFzc2luZyB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGZvciBvYmplY3QgYXMgcmVsYXRlZCwgcXVhZCwgcGF0aFxuICAgICAgICAvLyBpZGVudGlmaWVyIGlzc3VlciBhcyBpc3N1ZXIsIGFuZCByIGFzIHBvc2l0aW9uLlxuICAgICAgICByZWxhdGVkID0gcXVhZC5vYmplY3QudmFsdWU7XG4gICAgICAgIHBvc2l0aW9uID0gJ3InO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMy4zKSBPdGhlcndpc2UsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHF1YWQuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gMy40KSBBZGQgYSBtYXBwaW5nIG9mIGhhc2ggdG8gdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBmb3IgdGhlXG4gICAgICAvLyBjb21wb25lbnQgdGhhdCBtYXRjaGVkIChzdWJqZWN0IG9yIG9iamVjdCkgdG8gaGFzaCB0byByZWxhdGVkIGJsYW5rXG4gICAgICAvLyBub2RlcyBtYXAsIGFkZGluZyBhbiBlbnRyeSBhcyBuZWNlc3NhcnkuXG4gICAgICBjb25zdCBoYXNoID0gc2VsZi5oYXNoUmVsYXRlZEJsYW5rTm9kZShyZWxhdGVkLCBxdWFkLCBpc3N1ZXIsIHBvc2l0aW9uKTtcbiAgICAgIGlmKGhhc2ggaW4gaGFzaFRvUmVsYXRlZCkge1xuICAgICAgICBoYXNoVG9SZWxhdGVkW2hhc2hdLnB1c2gocmVsYXRlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNoVG9SZWxhdGVkW2hhc2hdID0gW3JlbGF0ZWRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXNoVG9SZWxhdGVkO1xuICB9XG59O1xuIiwiLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUkRGIERhdGFzZXQgTm9ybWFsaXphdGlvbiBzcGVjaWZpY2F0aW9uLlxuICogVGhpcyBsaWJyYXJ5IHdvcmtzIGluIHRoZSBicm93c2VyIGFuZCBub2RlLmpzLlxuICpcbiAqIEJTRCAzLUNsYXVzZSBMaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgRGlnaXRhbCBCYXphYXIsIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBU1xuICogSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBXG4gKiBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgVVJETkEyMDE1ID0gcmVxdWlyZSgnLi9VUkROQTIwMTUnKTtcbmNvbnN0IFVSR05BMjAxMiA9IHJlcXVpcmUoJy4vVVJHTkEyMDEyJyk7XG5jb25zdCBVUkROQTIwMTVTeW5jID0gcmVxdWlyZSgnLi9VUkROQTIwMTVTeW5jJyk7XG5jb25zdCBVUkdOQTIwMTJTeW5jID0gcmVxdWlyZSgnLi9VUkdOQTIwMTJTeW5jJyk7XG5cbi8vIG9wdGlvbmFsIG5hdGl2ZSBzdXBwb3J0XG5sZXQgcmRmQ2Fub25pemVOYXRpdmU7XG50cnkge1xuICByZGZDYW5vbml6ZU5hdGl2ZSA9IHJlcXVpcmUoJ3JkZi1jYW5vbml6ZS1uYXRpdmUnKTtcbn0gY2F0Y2goZSkge31cblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLy8gZXhwb3NlIGhlbHBlcnNcbmFwaS5OUXVhZHMgPSByZXF1aXJlKCcuL05RdWFkcycpO1xuYXBpLklkZW50aWZpZXJJc3N1ZXIgPSByZXF1aXJlKCcuL0lkZW50aWZpZXJJc3N1ZXInKTtcblxuLyoqXG4gKiBHZXQgb3Igc2V0IG5hdGl2ZSBBUEkuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgbmF0aXZlIEFQSS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjdXJyZW50bHkgc2V0IG5hdGl2ZSBBUEkuXG4gKi9cbmFwaS5fcmRmQ2Fub25pemVOYXRpdmUgPSBmdW5jdGlvbihhcGkpIHtcbiAgaWYoYXBpKSB7XG4gICAgcmRmQ2Fub25pemVOYXRpdmUgPSBhcGk7XG4gIH1cbiAgcmV0dXJuIHJkZkNhbm9uaXplTmF0aXZlO1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBjYW5vbml6ZXMgYW4gUkRGIGRhdGFzZXQuXG4gKlxuICogQHBhcmFtIGRhdGFzZXQgdGhlIGRhdGFzZXQgdG8gY2Fub25pemUuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGNhbm9uaWNhbGl6YXRpb24gYWxnb3JpdGhtIHRvIHVzZSwgYFVSRE5BMjAxNWAgb3JcbiAqICAgICAgICAgICAgYFVSR05BMjAxMmAuXG4gKiAgICAgICAgICBbdXNlTmF0aXZlXSB1c2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIChkZWZhdWx0OiBmYWxzZSkuXG4gKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwgY2Fub25pY2FsKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY2Fub25pY2FsaXplZCBSREYgRGF0YXNldC5cbiAqL1xuYXBpLmNhbm9uaXplID0gdXRpbC5jYWxsYmFja2lmeShhc3luYyBmdW5jdGlvbihkYXRhc2V0LCBvcHRpb25zKSB7XG4gIGxldCBjYWxsYmFjaztcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjYWxsYmFjayA9IChlcnIsIGNhbm9uaWNhbCkgPT4ge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgLyppZihvcHRpb25zLmZvcm1hdCA9PT0gJ2FwcGxpY2F0aW9uL24tcXVhZHMnKSB7XG4gICAgICAgIGNhbm9uaWNhbCA9IGNhbm9uaWNhbC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGNhbm9uaWNhbCA9IF9wYXJzZU5RdWFkcyhjYW5vbmljYWwuam9pbignJykpOyovXG5cbiAgICAgIHJlc29sdmUoY2Fub25pY2FsKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBiYWNrLWNvbXBhdCB3aXRoIGxlZ2FjeSBkYXRhc2V0XG4gIGlmKCFBcnJheS5pc0FycmF5KGRhdGFzZXQpKSB7XG4gICAgZGF0YXNldCA9IGFwaS5OUXVhZHMubGVnYWN5RGF0YXNldFRvUXVhZHMoZGF0YXNldCk7XG4gIH1cblxuICAvLyBUT0RPOiBjb252ZXJ0IGFsZ29yaXRobXMgdG8gUHJvbWlzZS1iYXNlZCBhc3luY1xuICBpZihvcHRpb25zLnVzZU5hdGl2ZSkge1xuICAgIGlmKHJkZkNhbm9uaXplTmF0aXZlKSB7XG4gICAgICByZGZDYW5vbml6ZU5hdGl2ZS5jYW5vbml6ZShkYXRhc2V0LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmRmLWNhbm9uaXplLW5hdGl2ZSBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmKG9wdGlvbnMuYWxnb3JpdGhtID09PSAnVVJETkEyMDE1Jykge1xuICAgICAgbmV3IFVSRE5BMjAxNShvcHRpb25zKS5tYWluKGRhdGFzZXQsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICdVUkdOQTIwMTInKSB7XG4gICAgICBuZXcgVVJHTkEyMDEyKG9wdGlvbnMpLm1haW4oZGF0YXNldCwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZighKCdhbGdvcml0aG0nIGluIG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFJERiBEYXRhc2V0IENhbm9uaWNhbGl6YXRpb24gYWxnb3JpdGhtIHNwZWNpZmllZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSW52YWxpZCBSREYgRGF0YXNldCBDYW5vbmljYWxpemF0aW9uIGFsZ29yaXRobTogJyArIG9wdGlvbnMuYWxnb3JpdGhtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn0pO1xuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgY2Fub25pemVzIGFuIFJERiBkYXRhc2V0LlxuICpcbiAqIEBwYXJhbSBkYXRhc2V0IHRoZSBkYXRhc2V0IHRvIGNhbm9uaXplLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBjYW5vbmljYWxpemF0aW9uIGFsZ29yaXRobSB0byB1c2UsIGBVUkROQTIwMTVgIG9yXG4gKiAgICAgICAgICAgIGBVUkdOQTIwMTJgLlxuICogICAgICAgICAgW3VzZU5hdGl2ZV0gdXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiAoZGVmYXVsdDogZmFsc2UpLlxuICpcbiAqIEByZXR1cm4gdGhlIFJERiBkYXRhc2V0IGluIGNhbm9uaWNhbCBmb3JtLlxuICovXG5hcGkuY2Fub25pemVTeW5jID0gZnVuY3Rpb24oZGF0YXNldCwgb3B0aW9ucykge1xuICAvLyBiYWNrLWNvbXBhdCB3aXRoIGxlZ2FjeSBkYXRhc2V0XG4gIGlmKCFBcnJheS5pc0FycmF5KGRhdGFzZXQpKSB7XG4gICAgZGF0YXNldCA9IGFwaS5OUXVhZHMubGVnYWN5RGF0YXNldFRvUXVhZHMoZGF0YXNldCk7XG4gIH1cblxuICBpZihvcHRpb25zLnVzZU5hdGl2ZSkge1xuICAgIGlmKHJkZkNhbm9uaXplTmF0aXZlKSB7XG4gICAgICByZXR1cm4gcmRmQ2Fub25pemVOYXRpdmUuY2Fub25pemVTeW5jKGRhdGFzZXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JkZi1jYW5vbml6ZS1uYXRpdmUgbm90IGF2YWlsYWJsZScpO1xuICB9XG4gIGlmKG9wdGlvbnMuYWxnb3JpdGhtID09PSAnVVJETkEyMDE1Jykge1xuICAgIHJldHVybiBuZXcgVVJETkEyMDE1U3luYyhvcHRpb25zKS5tYWluKGRhdGFzZXQpO1xuICB9IGVsc2UgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICdVUkdOQTIwMTInKSB7XG4gICAgcmV0dXJuIG5ldyBVUkdOQTIwMTJTeW5jKG9wdGlvbnMpLm1haW4oZGF0YXNldCk7XG4gIH1cbiAgaWYoISgnYWxnb3JpdGhtJyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gUkRGIERhdGFzZXQgQ2Fub25pY2FsaXphdGlvbiBhbGdvcml0aG0gc3BlY2lmaWVkLicpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YWxpZCBSREYgRGF0YXNldCBDYW5vbmljYWxpemF0aW9uIGFsZ29yaXRobTogJyArIG9wdGlvbnMuYWxnb3JpdGhtKTtcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vLyBkZWZpbmUgc2V0SW1tZWRpYXRlIGFuZCBuZXh0VGlja1xuLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG4vLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jYW9sYW4vYXN5bmMvYmxvYi9tYXN0ZXIvbGliL2FzeW5jLmpzXG5cbi8vIGNhcHR1cmUgdGhlIGdsb2JhbCByZWZlcmVuY2UgdG8gZ3VhcmQgYWdhaW5zdCBmYWtlVGltZXIgbW9ja3NcbmNvbnN0IF9zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIHNldEltbWVkaWF0ZTtcblxuY29uc3QgX2RlbGF5ID0gX3NldEltbWVkaWF0ZSA/XG4gIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyAoZm9yIElFMTAgY29tcGF0aWJpbGl0eSlcbiAgZm4gPT4gX3NldEltbWVkaWF0ZShmbikgOlxuICBmbiA9PiBzZXRUaW1lb3V0KGZuLCAwKTtcblxuaWYodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gIGFwaS5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG59IGVsc2Uge1xuICBhcGkubmV4dFRpY2sgPSBfZGVsYXk7XG59XG5hcGkuc2V0SW1tZWRpYXRlID0gX3NldEltbWVkaWF0ZSA/IF9kZWxheSA6IGFwaS5uZXh0VGljaztcblxuLyoqXG4gKiBDbG9uZXMgYW4gb2JqZWN0LCBhcnJheSwgb3Igc3RyaW5nL251bWJlci4gSWYgYSB0eXBlZCBKYXZhU2NyaXB0IG9iamVjdFxuICogaXMgZ2l2ZW4sIHN1Y2ggYXMgYSBEYXRlLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGNsb25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuYXBpLmNsb25lID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGxldCBydmFsO1xuICAgIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBydmFsID0gW107XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcnZhbFtpXSA9IGFwaS5jbG9uZSh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFwaS5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJ2YWwgPSB7fTtcbiAgICAgIGZvcihjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgcnZhbFtrZXldID0gYXBpLmNsb25lKHZhbHVlW2tleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBydmFsID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBPYmplY3QsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzT2JqZWN0ID0gdiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNVbmRlZmluZWQgPSB2ID0+IHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJztcblxuYXBpLmNhbGxiYWNraWZ5ID0gZm4gPT4ge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXJncy5wb3AoKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gX2ludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gX2ludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBudWxsLCByZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBfaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIGVyciwgcmVzdWx0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgfSBjYXRjaCh1bmhhbmRsZWRFcnJvcikge1xuICAgIC8vIHRocm93IHVuaGFuZGxlZCBlcnJvcnMgdG8gcHJldmVudCBcInVuaGFuZGxlZCByZWplY3RlZCBwcm9taXNlXCJcbiAgICAvLyBhbmQgc2ltdWxhdGUgd2hhdCB3b3VsZCBoYXZlIGhhcHBlbmVkIGluIGEgcHJvbWlzZWxlc3MgQVBJXG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0aHJvdyB1bmhhbmRsZWRFcnJvcjtcbiAgICB9KTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvQmxhbmtOb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvRGF0YUZhY3RvcnlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9EZWZhdWx0R3JhcGhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9MaXRlcmFsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvTmFtZWROb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvUXVhZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL1ZhcmlhYmxlXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CbGFua05vZGUgPSB2b2lkIDA7XG4vKipcbiAqIEEgdGVybSB0aGF0IHJlcHJlc2VudHMgYW4gUkRGIGJsYW5rIG5vZGUgd2l0aCBhIGxhYmVsLlxuICovXG5jbGFzcyBCbGFua05vZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGVybVR5cGUgPSAnQmxhbmtOb2RlJztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICEhb3RoZXIgJiYgb3RoZXIudGVybVR5cGUgPT09ICdCbGFua05vZGUnICYmIG90aGVyLnZhbHVlID09PSB0aGlzLnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxhbmtOb2RlID0gQmxhbmtOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmxhbmtOb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRhRmFjdG9yeSA9IHZvaWQgMDtcbmNvbnN0IEJsYW5rTm9kZV8xID0gcmVxdWlyZShcIi4vQmxhbmtOb2RlXCIpO1xuY29uc3QgRGVmYXVsdEdyYXBoXzEgPSByZXF1aXJlKFwiLi9EZWZhdWx0R3JhcGhcIik7XG5jb25zdCBMaXRlcmFsXzEgPSByZXF1aXJlKFwiLi9MaXRlcmFsXCIpO1xuY29uc3QgTmFtZWROb2RlXzEgPSByZXF1aXJlKFwiLi9OYW1lZE5vZGVcIik7XG5jb25zdCBRdWFkXzEgPSByZXF1aXJlKFwiLi9RdWFkXCIpO1xuY29uc3QgVmFyaWFibGVfMSA9IHJlcXVpcmUoXCIuL1ZhcmlhYmxlXCIpO1xubGV0IGRhdGFGYWN0b3J5Q291bnRlciA9IDA7XG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgaW5zdGFudGlhdGluZyBSREYgdGVybXMgYW5kIHF1YWRzLlxuICovXG5jbGFzcyBEYXRhRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmJsYW5rTm9kZUNvdW50ZXIgPSAwO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5ibGFua05vZGVQcmVmaXggPSBvcHRpb25zLmJsYW5rTm9kZVByZWZpeCB8fCBgZGZfJHtkYXRhRmFjdG9yeUNvdW50ZXIrK31fYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBJUkkgZm9yIHRoZSBuYW1lZCBub2RlLlxuICAgICAqIEByZXR1cm4gQSBuZXcgaW5zdGFuY2Ugb2YgTmFtZWROb2RlLlxuICAgICAqIEBzZWUgTmFtZWROb2RlXG4gICAgICovXG4gICAgbmFtZWROb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlXzEuTmFtZWROb2RlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBvcHRpb25hbCBibGFuayBub2RlIGlkZW50aWZpZXIuXG4gICAgICogQHJldHVybiBBIG5ldyBpbnN0YW5jZSBvZiBCbGFua05vZGUuXG4gICAgICogICAgICAgICBJZiB0aGUgYHZhbHVlYCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIGEgbmV3IGlkZW50aWZpZXJcbiAgICAgKiAgICAgICAgIGZvciB0aGUgYmxhbmsgbm9kZSBpcyBnZW5lcmF0ZWQgZm9yIGVhY2ggY2FsbC5cbiAgICAgKiBAc2VlIEJsYW5rTm9kZVxuICAgICAqL1xuICAgIGJsYW5rTm9kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJsYW5rTm9kZV8xLkJsYW5rTm9kZSh2YWx1ZSB8fCBgJHt0aGlzLmJsYW5rTm9kZVByZWZpeH0ke3RoaXMuYmxhbmtOb2RlQ291bnRlcisrfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAgICAgICAgICAgIFRoZSBsaXRlcmFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZU9yRGF0YXR5cGUgVGhlIG9wdGlvbmFsIGxhbmd1YWdlIG9yIGRhdGF0eXBlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgYGxhbmd1YWdlT3JEYXRhdHlwZWAgaXMgYSBOYW1lZE5vZGUsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGl0IGlzIHVzZWQgZm9yIHRoZSB2YWx1ZSBvZiBgTmFtZWROb2RlLmRhdGF0eXBlYC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyd2lzZSBgbGFuZ3VhZ2VPckRhdGF0eXBlYCBpcyB1c2VkIGZvciB0aGUgdmFsdWVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGBOYW1lZE5vZGUubGFuZ3VhZ2VgLlxuICAgICAqIEByZXR1cm4gQSBuZXcgaW5zdGFuY2Ugb2YgTGl0ZXJhbC5cbiAgICAgKiBAc2VlIExpdGVyYWxcbiAgICAgKi9cbiAgICBsaXRlcmFsKHZhbHVlLCBsYW5ndWFnZU9yRGF0YXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsXzEuTGl0ZXJhbCh2YWx1ZSwgbGFuZ3VhZ2VPckRhdGF0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YXJpYWJsZSBuYW1lXG4gICAgICogQHJldHVybiBBIG5ldyBpbnN0YW5jZSBvZiBWYXJpYWJsZS5cbiAgICAgKiBAc2VlIFZhcmlhYmxlXG4gICAgICovXG4gICAgdmFyaWFibGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZV8xLlZhcmlhYmxlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBEZWZhdWx0R3JhcGguXG4gICAgICovXG4gICAgZGVmYXVsdEdyYXBoKCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdEdyYXBoXzEuRGVmYXVsdEdyYXBoLklOU1RBTkNFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc3ViamVjdCAgIFRoZSBxdWFkIHN1YmplY3QgdGVybS5cbiAgICAgKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBxdWFkIHByZWRpY2F0ZSB0ZXJtLlxuICAgICAqIEBwYXJhbSBvYmplY3QgICAgVGhlIHF1YWQgb2JqZWN0IHRlcm0uXG4gICAgICogQHBhcmFtIGdyYXBoICAgICBUaGUgcXVhZCBncmFwaCB0ZXJtLlxuICAgICAqIEByZXR1cm4gQSBuZXcgaW5zdGFuY2Ugb2YgUXVhZC5cbiAgICAgKiBAc2VlIFF1YWRcbiAgICAgKi9cbiAgICBxdWFkKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1YWRfMS5RdWFkKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCB8fCB0aGlzLmRlZmF1bHRHcmFwaCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiB0ZXJtIHVzaW5nIHRoaXMgZGF0YSBmYWN0b3J5LlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbCBBbiBSREYgdGVybS5cbiAgICAgKiBAcmV0dXJuIEEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiB0ZXJtLlxuICAgICAqL1xuICAgIGZyb21UZXJtKG9yaWdpbmFsKSB7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBuYXN0eSBhbnkgY2FzdHMgd2hlbiB0aGlzIFRTIGJ1ZyBoYXMgYmVlbiBmaXhlZDpcbiAgICAgICAgLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjY5MzNcbiAgICAgICAgc3dpdGNoIChvcmlnaW5hbC50ZXJtVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTmFtZWROb2RlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lZE5vZGUob3JpZ2luYWwudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnQmxhbmtOb2RlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ibGFua05vZGUob3JpZ2luYWwudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpdGVyYWwob3JpZ2luYWwudmFsdWUsIG9yaWdpbmFsLmxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbC5kYXRhdHlwZS5lcXVhbHMoTGl0ZXJhbF8xLkxpdGVyYWwuWFNEX1NUUklORykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbChvcmlnaW5hbC52YWx1ZSwgdGhpcy5mcm9tVGVybShvcmlnaW5hbC5kYXRhdHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsKG9yaWdpbmFsLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ1ZhcmlhYmxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZShvcmlnaW5hbC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdEZWZhdWx0R3JhcGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRHcmFwaCgpO1xuICAgICAgICAgICAgY2FzZSAnUXVhZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVhZCh0aGlzLmZyb21UZXJtKG9yaWdpbmFsLnN1YmplY3QpLCB0aGlzLmZyb21UZXJtKG9yaWdpbmFsLnByZWRpY2F0ZSksIHRoaXMuZnJvbVRlcm0ob3JpZ2luYWwub2JqZWN0KSwgdGhpcy5mcm9tVGVybShvcmlnaW5hbC5ncmFwaCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGUgZ2l2ZW4gcXVhZCB1c2luZyB0aGlzIGRhdGEgZmFjdG9yeS5cbiAgICAgKiBAcGFyYW0gb3JpZ2luYWwgQW4gUkRGIHF1YWQuXG4gICAgICogQHJldHVybiBBIGRlZXAgY29weSBvZiB0aGUgZ2l2ZW4gcXVhZC5cbiAgICAgKi9cbiAgICBmcm9tUXVhZChvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tVGVybShvcmlnaW5hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBpbnRlcm5hbCBibGFuayBub2RlIGNvdW50ZXIuXG4gICAgICovXG4gICAgcmVzZXRCbGFua05vZGVDb3VudGVyKCkge1xuICAgICAgICB0aGlzLmJsYW5rTm9kZUNvdW50ZXIgPSAwO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YUZhY3RvcnkgPSBEYXRhRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZhdWx0R3JhcGggPSB2b2lkIDA7XG4vKipcbiAqIEEgc2luZ2xldG9uIHRlcm0gaW5zdGFuY2UgdGhhdCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IGdyYXBoLlxuICogSXQncyBvbmx5IGFsbG93ZWQgdG8gYXNzaWduIGEgRGVmYXVsdEdyYXBoIHRvIHRoZSAuZ3JhcGggcHJvcGVydHkgb2YgYSBRdWFkLlxuICovXG5jbGFzcyBEZWZhdWx0R3JhcGgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRlcm1UeXBlID0gJ0RlZmF1bHRHcmFwaCc7XG4gICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICAgICAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3RvclxuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICEhb3RoZXIgJiYgb3RoZXIudGVybVR5cGUgPT09ICdEZWZhdWx0R3JhcGgnO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVmYXVsdEdyYXBoID0gRGVmYXVsdEdyYXBoO1xuRGVmYXVsdEdyYXBoLklOU1RBTkNFID0gbmV3IERlZmF1bHRHcmFwaCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmYXVsdEdyYXBoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXRlcmFsID0gdm9pZCAwO1xuY29uc3QgTmFtZWROb2RlXzEgPSByZXF1aXJlKFwiLi9OYW1lZE5vZGVcIik7XG4vKipcbiAqIEEgdGVybSB0aGF0IHJlcHJlc2VudHMgYW4gUkRGIGxpdGVyYWwsIGNvbnRhaW5pbmcgYSBzdHJpbmcgd2l0aCBhbiBvcHRpb25hbCBsYW5ndWFnZSB0YWcgb3IgZGF0YXR5cGUuXG4gKi9cbmNsYXNzIExpdGVyYWwge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBsYW5ndWFnZU9yRGF0YXR5cGUpIHtcbiAgICAgICAgdGhpcy50ZXJtVHlwZSA9ICdMaXRlcmFsJztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGxhbmd1YWdlT3JEYXRhdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZU9yRGF0YXR5cGU7XG4gICAgICAgICAgICB0aGlzLmRhdGF0eXBlID0gTGl0ZXJhbC5SREZfTEFOR1VBR0VfU1RSSU5HO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlT3JEYXRhdHlwZSkge1xuICAgICAgICAgICAgdGhpcy5sYW5ndWFnZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5kYXRhdHlwZSA9IGxhbmd1YWdlT3JEYXRhdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFuZ3VhZ2UgPSAnJztcbiAgICAgICAgICAgIHRoaXMuZGF0YXR5cGUgPSBMaXRlcmFsLlhTRF9TVFJJTkc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAhIW90aGVyICYmIG90aGVyLnRlcm1UeXBlID09PSAnTGl0ZXJhbCcgJiYgb3RoZXIudmFsdWUgPT09IHRoaXMudmFsdWUgJiZcbiAgICAgICAgICAgIG90aGVyLmxhbmd1YWdlID09PSB0aGlzLmxhbmd1YWdlICYmIG90aGVyLmRhdGF0eXBlLmVxdWFscyh0aGlzLmRhdGF0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkxpdGVyYWwgPSBMaXRlcmFsO1xuTGl0ZXJhbC5SREZfTEFOR1VBR0VfU1RSSU5HID0gbmV3IE5hbWVkTm9kZV8xLk5hbWVkTm9kZSgnaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI2xhbmdTdHJpbmcnKTtcbkxpdGVyYWwuWFNEX1NUUklORyA9IG5ldyBOYW1lZE5vZGVfMS5OYW1lZE5vZGUoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI3N0cmluZycpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGl0ZXJhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmFtZWROb2RlID0gdm9pZCAwO1xuLyoqXG4gKiBBIHRlcm0gdGhhdCBjb250YWlucyBhbiBJUkkuXG4gKi9cbmNsYXNzIE5hbWVkTm9kZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy50ZXJtVHlwZSA9ICdOYW1lZE5vZGUnO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gISFvdGhlciAmJiBvdGhlci50ZXJtVHlwZSA9PT0gJ05hbWVkTm9kZScgJiYgb3RoZXIudmFsdWUgPT09IHRoaXMudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lZE5vZGUgPSBOYW1lZE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OYW1lZE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1YWQgPSB2b2lkIDA7XG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIERlZmF1bHRHcmFwaCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IGdyYXBoLlxuICogSXQncyBvbmx5IGFsbG93ZWQgdG8gYXNzaWduIGEgRGVmYXVsdEdyYXBoIHRvIHRoZSAuZ3JhcGggcHJvcGVydHkgb2YgYSBRdWFkLlxuICovXG5jbGFzcyBRdWFkIHtcbiAgICBjb25zdHJ1Y3RvcihzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAgICAgdGhpcy50ZXJtVHlwZSA9ICdRdWFkJztcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIC8vIGB8fCAhb3RoZXIudGVybVR5cGVgIGlzIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBmYWN0b3JpZXMgd2l0aG91dCBSREYqIHN1cHBvcnQuXG4gICAgICAgIHJldHVybiAhIW90aGVyICYmIChvdGhlci50ZXJtVHlwZSA9PT0gJ1F1YWQnIHx8ICFvdGhlci50ZXJtVHlwZSkgJiZcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdC5lcXVhbHMob3RoZXIuc3ViamVjdCkgJiZcbiAgICAgICAgICAgIHRoaXMucHJlZGljYXRlLmVxdWFscyhvdGhlci5wcmVkaWNhdGUpICYmXG4gICAgICAgICAgICB0aGlzLm9iamVjdC5lcXVhbHMob3RoZXIub2JqZWN0KSAmJlxuICAgICAgICAgICAgdGhpcy5ncmFwaC5lcXVhbHMob3RoZXIuZ3JhcGgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUXVhZCA9IFF1YWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYXJpYWJsZSA9IHZvaWQgMDtcbi8qKlxuICogQSB0ZXJtIHRoYXQgcmVwcmVzZW50cyBhIHZhcmlhYmxlLlxuICovXG5jbGFzcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy50ZXJtVHlwZSA9ICdWYXJpYWJsZSc7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAhIW90aGVyICYmIG90aGVyLnRlcm1UeXBlID09PSAnVmFyaWFibGUnICYmIG90aGVyLnZhbHVlID09PSB0aGlzLnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGUgPSBWYXJpYWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhcmlhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL0lBY3RpdmVUYWdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9JSHRtbFBhcnNlTGlzdGVuZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9JUmRmYVBhdHRlcm5cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9SZGZhUGFyc2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvUmRmYVByb2ZpbGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi9VdGlsXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUFjdGl2ZVRhZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlSZGZhUGF0dGVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmRmYVBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGh0bWxwYXJzZXIyXzEgPSByZXF1aXJlKFwiaHRtbHBhcnNlcjJcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBJTklUSUFMX0NPTlRFWFRfWEhUTUwgPSByZXF1aXJlKFwiLi9pbml0aWFsLWNvbnRleHQteGh0bWwuanNvblwiKTtcbmNvbnN0IElOSVRJQUxfQ09OVEVYVCA9IHJlcXVpcmUoXCIuL2luaXRpYWwtY29udGV4dC5qc29uXCIpO1xuY29uc3QgUmRmYVByb2ZpbGVfMSA9IHJlcXVpcmUoXCIuL1JkZmFQcm9maWxlXCIpO1xuY29uc3QgVXRpbF8xID0gcmVxdWlyZShcIi4vVXRpbFwiKTtcbi8qKlxuICogQSBzdHJlYW0gdHJhbnNmb3JtZXIgdGhhdCBwYXJzZXMgUkRGYSAodGV4dCkgc3RyZWFtcyB0byBhbiB7QGxpbmsgUkRGLlN0cmVhbX0uXG4gKi9cbmNsYXNzIFJkZmFQYXJzZXIgZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoeyByZWFkYWJsZU9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFnU3RhY2sgPSBbXTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudXRpbCA9IG5ldyBVdGlsXzEuVXRpbChvcHRpb25zLmRhdGFGYWN0b3J5LCBvcHRpb25zLmJhc2VJUkkpO1xuICAgICAgICB0aGlzLmRlZmF1bHRHcmFwaCA9IG9wdGlvbnMuZGVmYXVsdEdyYXBoIHx8IHRoaXMudXRpbC5kYXRhRmFjdG9yeS5kZWZhdWx0R3JhcGgoKTtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IG9wdGlvbnMuY29udGVudFR5cGUgPyBVdGlsXzEuVXRpbC5jb250ZW50VHlwZVRvUHJvZmlsZShvcHRpb25zLmNvbnRlbnRUeXBlKSA6IG9wdGlvbnMucHJvZmlsZSB8fCAnJztcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IG9wdGlvbnMuZmVhdHVyZXMgfHwgUmRmYVByb2ZpbGVfMS5SREZBX0ZFQVRVUkVTW3Byb2ZpbGVdO1xuICAgICAgICB0aGlzLmh0bWxQYXJzZUxpc3RlbmVyID0gb3B0aW9ucy5odG1sUGFyc2VMaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5yZGZhUGF0dGVybnMgPSB0aGlzLmZlYXR1cmVzLmNvcHlSZGZhUGF0dGVybnMgPyB7fSA6IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1JkZmFQYXR0ZXJuQ29waWVzID0gdGhpcy5mZWF0dXJlcy5jb3B5UmRmYVBhdHRlcm5zID8ge30gOiBudWxsO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHRoaXMuaW5pdGlhbGl6ZVBhcnNlcihwcm9maWxlID09PSAneG1sJyk7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFnU3RhY2sucHVzaCh7XG4gICAgICAgICAgICBpbmNvbXBsZXRlVHJpcGxlczogW10sXG4gICAgICAgICAgICBpbmxpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IG9wdGlvbnMubGFuZ3VhZ2UsXG4gICAgICAgICAgICBsaXN0TWFwcGluZzoge30sXG4gICAgICAgICAgICBsaXN0TWFwcGluZ0xvY2FsOiB7fSxcbiAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgcHJlZml4ZXNBbGw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgSU5JVElBTF9DT05URVhUWydAY29udGV4dCddKSwgdGhpcy5mZWF0dXJlcy54aHRtbEluaXRpYWxDb250ZXh0ID8gSU5JVElBTF9DT05URVhUX1hIVE1MWydAY29udGV4dCddIDoge30pLFxuICAgICAgICAgICAgcHJlZml4ZXNDdXN0b206IHt9LFxuICAgICAgICAgICAgc2tpcEVsZW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgdm9jYWI6IG9wdGlvbnMudm9jYWIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgc3RyZWFtIGludG8gYSBxdWFkIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge05vZGVKUy5FdmVudEVtaXR0ZXJ9IHN0cmVhbSBBIHRleHQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge1JERi5TdHJlYW19IEEgcXVhZCBzdHJlYW0uXG4gICAgICovXG4gICAgaW1wb3J0KHN0cmVhbSkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgc3RyZWFtXzEuUGFzc1Rocm91Z2goeyByZWFkYWJsZU9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCAoZXJyb3IpID0+IHBhcnNlZC5lbWl0KCdlcnJvcicsIGVycm9yKSk7XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIChkYXRhKSA9PiBvdXRwdXQucHVzaChkYXRhKSk7XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4gb3V0cHV0LnB1c2gobnVsbCkpO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBvdXRwdXQucGlwZShuZXcgUmRmYVBhcnNlcih0aGlzLm9wdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucGFyc2VyLndyaXRlKGNodW5rKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucGFyc2VyLmVuZCgpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBvblRhZ09wZW4obmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBhcmVudCB0YWcgKGlnbm9yZSBza2lwcGVkIHRhZ3MpXG4gICAgICAgIGxldCBwYXJlbnRUYWdJID0gdGhpcy5hY3RpdmVUYWdTdGFjay5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAocGFyZW50VGFnSSA+IDAgJiYgdGhpcy5hY3RpdmVUYWdTdGFja1twYXJlbnRUYWdJXS5za2lwRWxlbWVudCkge1xuICAgICAgICAgICAgcGFyZW50VGFnSS0tO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnRUYWcgPSB0aGlzLmFjdGl2ZVRhZ1N0YWNrW3BhcmVudFRhZ0ldO1xuICAgICAgICAvLyBJZiB3ZSBza2lwcGVkIGEgdGFnLCBtYWtlIHN1cmUgd2UgRE8gdXNlIHRoZSBsYW5nLCBwcmVmaXhlcyBhbmQgdm9jYWIgb2YgdGhlIHNraXBwZWQgdGFnXG4gICAgICAgIGlmIChwYXJlbnRUYWdJICE9PSB0aGlzLmFjdGl2ZVRhZ1N0YWNrLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHBhcmVudFRhZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50VGFnKSwgeyBsYW5ndWFnZTogdGhpcy5hY3RpdmVUYWdTdGFja1t0aGlzLmFjdGl2ZVRhZ1N0YWNrLmxlbmd0aCAtIDFdLmxhbmd1YWdlLCBwcmVmaXhlc0FsbDogdGhpcy5hY3RpdmVUYWdTdGFja1t0aGlzLmFjdGl2ZVRhZ1N0YWNrLmxlbmd0aCAtIDFdLnByZWZpeGVzQWxsLCBwcmVmaXhlc0N1c3RvbTogdGhpcy5hY3RpdmVUYWdTdGFja1t0aGlzLmFjdGl2ZVRhZ1N0YWNrLmxlbmd0aCAtIDFdLnByZWZpeGVzQ3VzdG9tLCB2b2NhYjogdGhpcy5hY3RpdmVUYWdTdGFja1t0aGlzLmFjdGl2ZVRhZ1N0YWNrLmxlbmd0aCAtIDFdLnZvY2FiIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBhY3RpdmUgdGFnIGFuZCBpbmhlcml0IGxhbmd1YWdlIHNjb3BlIGFuZCBiYXNlSVJJIGZyb20gcGFyZW50XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhZyA9IHtcbiAgICAgICAgICAgIGNvbGxlY3RDaGlsZFRhZ3M6IHBhcmVudFRhZy5jb2xsZWN0Q2hpbGRUYWdzLFxuICAgICAgICAgICAgaW5jb21wbGV0ZVRyaXBsZXM6IFtdLFxuICAgICAgICAgICAgaW5saXN0OiAnaW5saXN0JyBpbiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgbGlzdE1hcHBpbmc6IFtdLFxuICAgICAgICAgICAgbGlzdE1hcHBpbmdMb2NhbDogcGFyZW50VGFnLmxpc3RNYXBwaW5nLFxuICAgICAgICAgICAgbG9jYWxCYXNlSVJJOiBwYXJlbnRUYWcubG9jYWxCYXNlSVJJLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHByZWZpeGVzQWxsOiBudWxsLFxuICAgICAgICAgICAgcHJlZml4ZXNDdXN0b206IG51bGwsXG4gICAgICAgICAgICBza2lwRWxlbWVudDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZlVGFnU3RhY2sucHVzaChhY3RpdmVUYWcpO1xuICAgICAgICAvLyBTYXZlIHRoZSB0YWcgY29udGVudHMgaWYgbmVlZGVkXG4gICAgICAgIGlmIChhY3RpdmVUYWcuY29sbGVjdENoaWxkVGFncykge1xuICAgICAgICAgICAgLy8gQWRkIGV4cGxpY2l0bHkgZGVmaW5lZCB4bWxucywgeG1sbnM6KiBhbmQgcHJlZml4ZXMgdG8gYXR0cmlidXRlcywgYXMgcmVxdWlyZWQgYnkgdGhlIHNwZWMgKFN0ZXAgMTEsIG5vdGUpXG4gICAgICAgICAgICAvLyBTb3J0IHByZWZpeGVzIGFscGhhYmV0aWNhbGx5IGZvciBkZXRlcm1pbmlzdGljIG5hbWVzcGFjZSBkZWNsYXJhdGlvbiBvcmRlclxuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVmaXggb2YgT2JqZWN0LmtleXMocGFyZW50VGFnLnByZWZpeGVzQ3VzdG9tKS5zb3J0KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXggPSBwYXJlbnRUYWcucHJlZml4ZXNDdXN0b21bcHJlZml4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVLZXkgPSBwcmVmaXggPT09ICcnID8gJ3htbG5zJyA6ICd4bWxuczonICsgcHJlZml4O1xuICAgICAgICAgICAgICAgIGlmICghKGF0dHJpYnV0ZUtleSBpbiBhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZUtleV0gPSBzdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlc1NlcmlhbGl6ZWQgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoKGtleSkgPT4gYCR7a2V5fT1cIiR7YXR0cmlidXRlc1trZXldfVwiYCkuam9pbignICcpO1xuICAgICAgICAgICAgYWN0aXZlVGFnLnRleHQgPSBbYDwke25hbWV9JHthdHRyaWJ1dGVzU2VyaWFsaXplZCA/ICcgJyArIGF0dHJpYnV0ZXNTZXJpYWxpemVkIDogJyd9PmBdO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXMuc2tpcEhhbmRsaW5nWG1sTGl0ZXJhbENoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhbGxvd1Rlcm1zSW5SZWxQcmVkaWNhdGVzID0gdHJ1ZTtcbiAgICAgICAgbGV0IGFsbG93VGVybXNJblJldlByZWRpY2F0ZXMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcy5vbmx5QWxsb3dVcmlSZWxSZXZJZlByb3BlcnR5KSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaWxsZWdhbCByZWwvcmV2IHZhbHVlcyB3aGVuIHByb3BlcnR5IGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmICgncHJvcGVydHknIGluIGF0dHJpYnV0ZXMgJiYgJ3JlbCcgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGFsbG93VGVybXNJblJlbFByZWRpY2F0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5yZWwuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5yZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdwcm9wZXJ0eScgaW4gYXR0cmlidXRlcyAmJiAncmV2JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dUZXJtc0luUmV2UHJlZGljYXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnJldi5pbmRleE9mKCc6JykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXMuY29weVJkZmFQYXR0ZXJucykge1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgdGFnIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHBhcmVudFRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVyblRhZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdFBhdHRlcm46IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhcmVudFRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnLmNoaWxkcmVuLnB1c2gocGF0dGVyblRhZyk7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFnLmNvbGxlY3RlZFBhdHRlcm5UYWcgPSBwYXR0ZXJuVGFnO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHRhZ3Mgd2l0aCB0eXBlIHJkZmE6UGF0dGVybiBhcyBwYXR0ZXJuc1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMudHlwZW9mID09PSAncmRmYTpQYXR0ZXJuJykge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnID0ge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRhZyxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RQYXR0ZXJuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc3RhbnRpYXRlIHBhdHRlcm5zIG9uIHJkZmE6Y29weVxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMucHJvcGVydHkgPT09ICdyZGZhOmNvcHknKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29weVRhcmdldFBhdHRlcm5JZCA9IGF0dHJpYnV0ZXMucmVzb3VyY2UgfHwgYXR0cmlidXRlcy5ocmVmIHx8IGF0dHJpYnV0ZXMuc3JjO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJkZmFQYXR0ZXJuc1tjb3B5VGFyZ2V0UGF0dGVybklkXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRQYXR0ZXJuQ29weShwYXJlbnRUYWcsIHRoaXMucmRmYVBhdHRlcm5zW2NvcHlUYXJnZXRQYXR0ZXJuSWRdLCBjb3B5VGFyZ2V0UGF0dGVybklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nUmRmYVBhdHRlcm5Db3BpZXNbY29weVRhcmdldFBhdHRlcm5JZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JkZmFQYXR0ZXJuQ29waWVzW2NvcHlUYXJnZXRQYXR0ZXJuSWRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmRmYVBhdHRlcm5Db3BpZXNbY29weVRhcmdldFBhdHRlcm5JZF0ucHVzaChwYXJlbnRUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gPGJhc2U+IHRhZ3Mgb3ZlcnJpZGUgdGhlIGJhc2VJUkkgb2YgdGhlIHdob2xlIGRvY3VtZW50XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzLmJhc2VUYWcgJiYgbmFtZSA9PT0gJ2Jhc2UnICYmIGF0dHJpYnV0ZXMuaHJlZikge1xuICAgICAgICAgICAgdGhpcy51dGlsLmJhc2VJUkkgPSB0aGlzLnV0aWwuZ2V0QmFzZUlSSShhdHRyaWJ1dGVzLmhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHhtbDpiYXNlIGF0dHJpYnV0ZXMgb3ZlcnJpZGUgdGhlIGJhc2VJUkkgb2YgdGhlIGN1cnJlbnQgdGFnIGFuZCBjaGlsZHJlblxuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcy54bWxCYXNlICYmIGF0dHJpYnV0ZXNbJ3htbDpiYXNlJ10pIHtcbiAgICAgICAgICAgIGFjdGl2ZVRhZy5sb2NhbEJhc2VJUkkgPSB0aGlzLnV0aWwuZ2V0QmFzZUlSSShhdHRyaWJ1dGVzWyd4bWw6YmFzZSddKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA8dGltZT4gdGFncyBzZXQgYW4gaW5pdGlhbCBkYXRhdHlwZVxuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcy50aW1lVGFnICYmIG5hbWUgPT09ICd0aW1lJyAmJiAhYXR0cmlidXRlcy5kYXRhdHlwZSkge1xuICAgICAgICAgICAgYWN0aXZlVGFnLmludGVycHJldE9iamVjdEFzVGltZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvY2Vzc2luZyBiYXNlZCBvbiBodHRwczovL3d3dy53My5vcmcvVFIvcmRmYS1jb3JlLyNzX3JkZmFpbmRldGFpbFxuICAgICAgICAvLyAxOiBpbml0aWFsaXplIHZhbHVlc1xuICAgICAgICBsZXQgbmV3U3ViamVjdDtcbiAgICAgICAgbGV0IGN1cnJlbnRPYmplY3RSZXNvdXJjZTtcbiAgICAgICAgbGV0IHR5cGVkUmVzb3VyY2U7XG4gICAgICAgIC8vIDI6IGhhbmRsZSB2b2NhYiBhdHRyaWJ1dGUgdG8gc2V0IGFjdGl2ZSB2b2NhYnVsYXJ5XG4gICAgICAgIC8vIFZvY2FiIHNldHMgdGhlIGFjdGl2ZSB2b2NhYnVsYXJ5XG4gICAgICAgIGlmICgndm9jYWInIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnZvY2FiKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFnLnZvY2FiID0gYXR0cmlidXRlcy52b2NhYjtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUodGhpcy51dGlsLmdldEJhc2VJcmlUZXJtKGFjdGl2ZVRhZyksIHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoVXRpbF8xLlV0aWwuUkRGQSArICd1c2VzVm9jYWJ1bGFyeScpLCB0aGlzLnV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKGFjdGl2ZVRhZy52b2NhYikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdm9jYWIgaXMgc2V0IHRvICcnLCB0aGVuIHdlIGZhbGxiYWNrIHRvIHRoZSByb290IHZvY2FiIGFzIGRlZmluZWQgdmlhIHRoZSBwYXJzZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcudm9jYWIgPSB0aGlzLmFjdGl2ZVRhZ1N0YWNrWzBdLnZvY2FiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlVGFnLnZvY2FiID0gcGFyZW50VGFnLnZvY2FiO1xuICAgICAgICB9XG4gICAgICAgIC8vIDM6IGhhbmRsZSBwcmVmaXhlc1xuICAgICAgICBhY3RpdmVUYWcucHJlZml4ZXNDdXN0b20gPSBVdGlsXzEuVXRpbC5wYXJzZVByZWZpeGVzKGF0dHJpYnV0ZXMsIHBhcmVudFRhZy5wcmVmaXhlc0N1c3RvbSwgdGhpcy5mZWF0dXJlcy54bWxuc1ByZWZpeE1hcHBpbmdzKTtcbiAgICAgICAgYWN0aXZlVGFnLnByZWZpeGVzQWxsID0gT2JqZWN0LmtleXMoYWN0aXZlVGFnLnByZWZpeGVzQ3VzdG9tKS5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50VGFnLnByZWZpeGVzQWxsKSwgYWN0aXZlVGFnLnByZWZpeGVzQ3VzdG9tKSA6IHBhcmVudFRhZy5wcmVmaXhlc0FsbDtcbiAgICAgICAgLy8gSGFuZGxlIHJvbGUgYXR0cmlidXRlXG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzLnJvbGVBdHRyaWJ1dGUgJiYgYXR0cmlidXRlcy5yb2xlKSB7XG4gICAgICAgICAgICBjb25zdCByb2xlU3ViamVjdCA9IGF0dHJpYnV0ZXMuaWRcbiAgICAgICAgICAgICAgICA/IHRoaXMudXRpbC5jcmVhdGVJcmkoJyMnICsgYXR0cmlidXRlcy5pZCwgYWN0aXZlVGFnLCBmYWxzZSwgZmFsc2UsIGZhbHNlKVxuICAgICAgICAgICAgICAgIDogdGhpcy51dGlsLmNyZWF0ZUJsYW5rTm9kZSgpO1xuICAgICAgICAgICAgLy8gVGVtcG9yYXJpbHkgb3ZlcnJpZGUgdm9jYWJcbiAgICAgICAgICAgIGNvbnN0IHZvY2FiT2xkID0gYWN0aXZlVGFnLnZvY2FiO1xuICAgICAgICAgICAgYWN0aXZlVGFnLnZvY2FiID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjJztcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm9sZSBvZiB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMucm9sZSwgYWN0aXZlVGFnLCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUocm9sZVN1YmplY3QsIHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjcm9sZScpLCByb2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZVRhZy52b2NhYiA9IHZvY2FiT2xkO1xuICAgICAgICB9XG4gICAgICAgIC8vIDQ6IGhhbmRsZSBsYW5ndWFnZVxuICAgICAgICAvLyBTYXZlIGxhbmd1YWdlIGF0dHJpYnV0ZSB2YWx1ZSBpbiBhY3RpdmUgdGFnXG4gICAgICAgIGlmICgneG1sOmxhbmcnIGluIGF0dHJpYnV0ZXMgfHwgKHRoaXMuZmVhdHVyZXMubGFuZ0F0dHJpYnV0ZSAmJiAnbGFuZycgaW4gYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgIGFjdGl2ZVRhZy5sYW5ndWFnZSA9IGF0dHJpYnV0ZXNbJ3htbDpsYW5nJ10gfHwgYXR0cmlidXRlcy5sYW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlVGFnLmxhbmd1YWdlID0gcGFyZW50VGFnLmxhbmd1YWdlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUm9vdFRhZyA9IHRoaXMuYWN0aXZlVGFnU3RhY2subGVuZ3RoID09PSAyO1xuICAgICAgICBpZiAoISgncmVsJyBpbiBhdHRyaWJ1dGVzKSAmJiAhKCdyZXYnIGluIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAvLyA1OiBEZXRlcm1pbmUgdGhlIG5ldyBzdWJqZWN0IHdoZW4gcmVsIGFuZCByZXYgYXJlIG5vdCBwcmVzZW50XG4gICAgICAgICAgICBpZiAoJ3Byb3BlcnR5JyBpbiBhdHRyaWJ1dGVzICYmICEoJ2NvbnRlbnQnIGluIGF0dHJpYnV0ZXMpICYmICEoJ2RhdGF0eXBlJyBpbiBhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgIC8vIDUuMTogcHJvcGVydHkgaXMgcHJlc2VudCwgYnV0IG5vdCBjb250ZW50IGFuZCBkYXRhdHlwZVxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBuZXcgc3ViamVjdFxuICAgICAgICAgICAgICAgIGlmICgnYWJvdXQnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViamVjdCA9IHRoaXMudXRpbC5jcmVhdGVJcmkoYXR0cmlidXRlcy5hYm91dCwgYWN0aXZlVGFnLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy5leHBsaWNpdE5ld1N1YmplY3QgPSAhIW5ld1N1YmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUm9vdFRhZykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWJqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50VGFnLm9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWJqZWN0ID0gcGFyZW50VGFnLm9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoJ3R5cGVvZicgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ2Fib3V0JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc291cmNlID0gdGhpcy51dGlsLmNyZWF0ZUlyaShhdHRyaWJ1dGVzLmFib3V0LCBhY3RpdmVUYWcsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVkUmVzb3VyY2UgJiYgaXNSb290VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc291cmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVkUmVzb3VyY2UgJiYgJ3Jlc291cmNlJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc291cmNlID0gdGhpcy51dGlsLmNyZWF0ZUlyaShhdHRyaWJ1dGVzLnJlc291cmNlLCBhY3RpdmVUYWcsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVkUmVzb3VyY2UgJiYgKCdocmVmJyBpbiBhdHRyaWJ1dGVzIHx8ICdzcmMnIGluIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc291cmNlID0gdGhpcy51dGlsLmNyZWF0ZUlyaShhdHRyaWJ1dGVzLmhyZWYgfHwgYXR0cmlidXRlcy5zcmMsIGFjdGl2ZVRhZywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVkUmVzb3VyY2UgJiYgdGhpcy5pc0luaGVyaXRTdWJqZWN0SW5IZWFkQm9keShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRSZXNvdXJjZSA9IG5ld1N1YmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlZFJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc291cmNlID0gdGhpcy51dGlsLmNyZWF0ZUJsYW5rTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYmplY3RSZXNvdXJjZSA9IHR5cGVkUmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gNS4yXG4gICAgICAgICAgICAgICAgaWYgKCdhYm91dCcgaW4gYXR0cmlidXRlcyB8fCAncmVzb3VyY2UnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViamVjdCA9IHRoaXMudXRpbC5jcmVhdGVJcmkoYXR0cmlidXRlcy5hYm91dCB8fCBhdHRyaWJ1dGVzLnJlc291cmNlLCBhY3RpdmVUYWcsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFnLmV4cGxpY2l0TmV3U3ViamVjdCA9ICEhbmV3U3ViamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdTdWJqZWN0ICYmICgnaHJlZicgaW4gYXR0cmlidXRlcyB8fCAnc3JjJyBpbiBhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWJqZWN0ID0gdGhpcy51dGlsLmNyZWF0ZUlyaShhdHRyaWJ1dGVzLmhyZWYgfHwgYXR0cmlidXRlcy5zcmMsIGFjdGl2ZVRhZywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFnLmV4cGxpY2l0TmV3U3ViamVjdCA9ICEhbmV3U3ViamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jvb3RUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNJbmhlcml0U3ViamVjdEluSGVhZEJvZHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3QgPSBwYXJlbnRUYWcub2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCd0eXBlb2YnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3QgPSB0aGlzLnV0aWwuY3JlYXRlQmxhbmtOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWcuZXhwbGljaXROZXdTdWJqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRUYWcub2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdWJqZWN0ID0gcGFyZW50VGFnLm9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCdwcm9wZXJ0eScgaW4gYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWcuc2tpcEVsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKCd0eXBlb2YnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWRSZXNvdXJjZSA9IG5ld1N1YmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBlaXRoZXIgcmVsIG9yIHJldiBpcyBwcmVzZW50XG4gICAgICAgICAgICAvLyA2OiBEZXRlcm1pbmUgdGhlIG5ldyBzdWJqZWN0IHdoZW4gcmVsIG9yIHJldiBhcmUgcHJlc2VudFxuICAgICAgICAgICAgLy8gRGVmaW5lIG5ldyBzdWJqZWN0XG4gICAgICAgICAgICBpZiAoJ2Fib3V0JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgbmV3U3ViamVjdCA9IHRoaXMudXRpbC5jcmVhdGVJcmkoYXR0cmlidXRlcy5hYm91dCwgYWN0aXZlVGFnLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFnLmV4cGxpY2l0TmV3U3ViamVjdCA9ICEhbmV3U3ViamVjdDtcbiAgICAgICAgICAgICAgICBpZiAoJ3R5cGVvZicgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc291cmNlID0gbmV3U3ViamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1Jvb3RUYWcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdWJqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudFRhZy5vYmplY3QpIHtcbiAgICAgICAgICAgICAgICBuZXdTdWJqZWN0ID0gcGFyZW50VGFnLm9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZmluZSBvYmplY3RcbiAgICAgICAgICAgIGlmICgncmVzb3VyY2UnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50T2JqZWN0UmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlSXJpKGF0dHJpYnV0ZXMucmVzb3VyY2UsIGFjdGl2ZVRhZywgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50T2JqZWN0UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ2hyZWYnIGluIGF0dHJpYnV0ZXMgfHwgJ3NyYycgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T2JqZWN0UmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlSXJpKGF0dHJpYnV0ZXMuaHJlZiB8fCBhdHRyaWJ1dGVzLnNyYywgYWN0aXZlVGFnLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgndHlwZW9mJyBpbiBhdHRyaWJ1dGVzICYmICEoJ2Fib3V0JyBpbiBhdHRyaWJ1dGVzKSAmJiAhdGhpcy5pc0luaGVyaXRTdWJqZWN0SW5IZWFkQm9keShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T2JqZWN0UmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlQmxhbmtOb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHR5cGVkIHJlc291cmNlXG4gICAgICAgICAgICBpZiAoJ3R5cGVvZicgaW4gYXR0cmlidXRlcyAmJiAhKCdhYm91dCcgaW4gYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0luaGVyaXRTdWJqZWN0SW5IZWFkQm9keShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc291cmNlID0gbmV3U3ViamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzb3VyY2UgPSBjdXJyZW50T2JqZWN0UmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDc6IElmIGEgdHlwZWQgcmVzb3VyY2Ugd2FzIGRlZmluZWQsIGVtaXQgaXQgYXMgYSB0cmlwbGVcbiAgICAgICAgaWYgKHR5cGVkUmVzb3VyY2UpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMudHlwZW9mLCBhY3RpdmVUYWcsIHRydWUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaSh0eXBlZFJlc291cmNlLCBhY3RpdmVUYWcpLCB0aGlzLnV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKFV0aWxfMS5VdGlsLlJERiArICd0eXBlJyksIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDg6IFJlc2V0IGxpc3QgbWFwcGluZyBpZiB3ZSBoYXZlIGEgbmV3IHN1YmplY3RcbiAgICAgICAgaWYgKG5ld1N1YmplY3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZVRhZy5saXN0TWFwcGluZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIDk6IElmIGFuIG9iamVjdCB3YXMgZGVmaW5lZCwgZW1pdCB0cmlwbGVzIGZvciBpdFxuICAgICAgICBpZiAoY3VycmVudE9iamVjdFJlc291cmNlKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgbGlzdCBtYXBwaW5nXG4gICAgICAgICAgICBpZiAoJ3JlbCcgaW4gYXR0cmlidXRlcyAmJiAnaW5saXN0JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgdGhpcy51dGlsLmNyZWF0ZVZvY2FiSXJpcyhhdHRyaWJ1dGVzLnJlbCwgYWN0aXZlVGFnLCBhbGxvd1Rlcm1zSW5SZWxQcmVkaWNhdGVzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0TWFwcGluZyhhY3RpdmVUYWcsIG5ld1N1YmplY3QsIHByZWRpY2F0ZSwgY3VycmVudE9iamVjdFJlc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgcHJlZGljYXRlcyB1c2luZyByZWwgb3IgcmV2ICh1bmxlc3MgcmVsIGFuZCBpbmxpc3QgYXJlIHByZXNlbnQpXG4gICAgICAgICAgICBpZiAoISgncmVsJyBpbiBhdHRyaWJ1dGVzICYmICdpbmxpc3QnIGluIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdyZWwnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgdGhpcy51dGlsLmNyZWF0ZVZvY2FiSXJpcyhhdHRyaWJ1dGVzLnJlbCwgYWN0aXZlVGFnLCBhbGxvd1Rlcm1zSW5SZWxQcmVkaWNhdGVzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZSh0aGlzLnV0aWwuZ2V0UmVzb3VyY2VPckJhc2VJcmkobmV3U3ViamVjdCwgYWN0aXZlVGFnKSwgcHJlZGljYXRlLCB0aGlzLnV0aWwuZ2V0UmVzb3VyY2VPckJhc2VJcmkoY3VycmVudE9iamVjdFJlc291cmNlLCBhY3RpdmVUYWcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3JldicgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMucmV2LCBhY3RpdmVUYWcsIGFsbG93VGVybXNJblJldlByZWRpY2F0ZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaShjdXJyZW50T2JqZWN0UmVzb3VyY2UsIGFjdGl2ZVRhZyksIHByZWRpY2F0ZSwgdGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKG5ld1N1YmplY3QsIGFjdGl2ZVRhZykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDEwOiBTdG9yZSBpbmNvbXBsZXRlIHRyaXBsZXMgaWYgd2UgZG9uJ3QgaGF2ZSBhbiBvYmplY3QsIGJ1dCB3ZSBkbyBoYXZlIHByZWRpY2F0ZXNcbiAgICAgICAgaWYgKCFjdXJyZW50T2JqZWN0UmVzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICgncmVsJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdpbmxpc3QnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgdGhpcy51dGlsLmNyZWF0ZVZvY2FiSXJpcyhhdHRyaWJ1dGVzLnJlbCwgYWN0aXZlVGFnLCBhbGxvd1Rlcm1zSW5SZWxQcmVkaWNhdGVzLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdE1hcHBpbmcoYWN0aXZlVGFnLCBuZXdTdWJqZWN0LCBwcmVkaWNhdGUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFnLmluY29tcGxldGVUcmlwbGVzLnB1c2goeyBwcmVkaWNhdGUsIHJldmVyc2U6IGZhbHNlLCBsaXN0OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMucmVsLCBhY3RpdmVUYWcsIGFsbG93VGVybXNJblJlbFByZWRpY2F0ZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFnLmluY29tcGxldGVUcmlwbGVzLnB1c2goeyBwcmVkaWNhdGUsIHJldmVyc2U6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdyZXYnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMucmV2LCBhY3RpdmVUYWcsIGFsbG93VGVybXNJblJldlByZWRpY2F0ZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWcuaW5jb21wbGV0ZVRyaXBsZXMucHVzaCh7IHByZWRpY2F0ZSwgcmV2ZXJzZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgYSBibGFuayBub2RlIG9iamVjdCwgc28gdGhlIGNoaWxkcmVuIGNhbiBtYWtlIHVzZSBvZiB0aGlzIHdoZW4gY29tcGxldGluZyB0aGUgdHJpcGxlc1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVRhZy5pbmNvbXBsZXRlVHJpcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE9iamVjdFJlc291cmNlID0gdGhpcy51dGlsLmNyZWF0ZUJsYW5rTm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDExOiBEZXRlcm1pbmUgY3VycmVudCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICBpZiAoJ3Byb3BlcnR5JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgcHJlZGljYXRlc1xuICAgICAgICAgICAgYWN0aXZlVGFnLnByZWRpY2F0ZXMgPSB0aGlzLnV0aWwuY3JlYXRlVm9jYWJJcmlzKGF0dHJpYnV0ZXMucHJvcGVydHksIGFjdGl2ZVRhZywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gU2F2ZSBkYXRhdHlwZSBhdHRyaWJ1dGUgdmFsdWUgaW4gYWN0aXZlIHRhZ1xuICAgICAgICAgICAgbGV0IGxvY2FsT2JqZWN0UmVzb3VyY2U7XG4gICAgICAgICAgICBpZiAoJ2RhdGF0eXBlJyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFnLmRhdGF0eXBlID0gdGhpcy51dGlsLmNyZWF0ZUlyaShhdHRyaWJ1dGVzLmRhdGF0eXBlLCBhY3RpdmVUYWcsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVGFnLmRhdGF0eXBlXG4gICAgICAgICAgICAgICAgICAgICYmIChhY3RpdmVUYWcuZGF0YXR5cGUudmFsdWUgPT09IFV0aWxfMS5VdGlsLlJERiArICdYTUxMaXRlcmFsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHRoaXMuZmVhdHVyZXMuaHRtbERhdGF0eXBlICYmIGFjdGl2ZVRhZy5kYXRhdHlwZS52YWx1ZSA9PT0gVXRpbF8xLlV0aWwuUkRGICsgJ0hUTUwnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFnLmNvbGxlY3RDaGlsZFRhZ3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgcmVzb3VyY2VcbiAgICAgICAgICAgICAgICBpZiAoISgncmV2JyBpbiBhdHRyaWJ1dGVzKSAmJiAhKCdyZWwnIGluIGF0dHJpYnV0ZXMpICYmICEoJ2NvbnRlbnQnIGluIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgncmVzb3VyY2UnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsT2JqZWN0UmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlSXJpKGF0dHJpYnV0ZXMucmVzb3VyY2UsIGFjdGl2ZVRhZywgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxPYmplY3RSZXNvdXJjZSAmJiAnaHJlZicgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxPYmplY3RSZXNvdXJjZSA9IHRoaXMudXRpbC5jcmVhdGVJcmkoYXR0cmlidXRlcy5ocmVmLCBhY3RpdmVUYWcsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbE9iamVjdFJlc291cmNlICYmICdzcmMnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsT2JqZWN0UmVzb3VyY2UgPSB0aGlzLnV0aWwuY3JlYXRlSXJpKGF0dHJpYnV0ZXMuc3JjLCBhY3RpdmVUYWcsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCd0eXBlb2YnIGluIGF0dHJpYnV0ZXMgJiYgISgnYWJvdXQnIGluIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsT2JqZWN0UmVzb3VyY2UgPSB0eXBlZFJlc291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnY29udGVudCcgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIC8vIEVtaXQgdHJpcGxlcyBiYXNlZCBvbiBjb250ZW50IGF0dHJpYnV0ZSBoYXMgcHJlZmVyZW5jZSBvdmVyIHRleHQgY29udGVudFxuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMudXRpbC5jcmVhdGVMaXRlcmFsKGF0dHJpYnV0ZXMuY29udGVudCwgYWN0aXZlVGFnKTtcbiAgICAgICAgICAgICAgICBpZiAoJ2lubGlzdCcgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiBhY3RpdmVUYWcucHJlZGljYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0TWFwcGluZyhhY3RpdmVUYWcsIG5ld1N1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaShuZXdTdWJqZWN0LCBhY3RpdmVUYWcpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiBhY3RpdmVUYWcucHJlZGljYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnNldCBwcmVkaWNhdGUgdG8gYXZvaWQgdGV4dCBjb250ZW50cyB0byBwcm9kdWNlIG5ldyB0cmlwbGVzXG4gICAgICAgICAgICAgICAgYWN0aXZlVGFnLnByZWRpY2F0ZXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mZWF0dXJlcy5kYXRldGltZUF0dHJpYnV0ZSAmJiAnZGF0ZXRpbWUnIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcuaW50ZXJwcmV0T2JqZWN0QXNUaW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBEYXRldGltZSBhdHRyaWJ1dGUgb24gdGltZSB0YWcgaGFzIHByZWZlcmVuY2Ugb3ZlciB0ZXh0IGNvbnRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3QgPSB0aGlzLnV0aWwuY3JlYXRlTGl0ZXJhbChhdHRyaWJ1dGVzLmRhdGV0aW1lLCBhY3RpdmVUYWcpO1xuICAgICAgICAgICAgICAgIGlmICgnaW5saXN0JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIGFjdGl2ZVRhZy5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RNYXBwaW5nKGFjdGl2ZVRhZywgbmV3U3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKG5ld1N1YmplY3QsIGFjdGl2ZVRhZyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIGFjdGl2ZVRhZy5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVuc2V0IHByZWRpY2F0ZSB0byBhdm9pZCB0ZXh0IGNvbnRlbnRzIHRvIHByb2R1Y2UgbmV3IHRyaXBsZXNcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcucHJlZGljYXRlcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbE9iamVjdFJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gRW1pdCB0cmlwbGVzIGZvciBhbGwgcmVzb3VyY2Ugb2JqZWN0c1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaShsb2NhbE9iamVjdFJlc291cmNlLCBhY3RpdmVUYWcpO1xuICAgICAgICAgICAgICAgIGlmICgnaW5saXN0JyBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIGFjdGl2ZVRhZy5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RNYXBwaW5nKGFjdGl2ZVRhZywgbmV3U3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKG5ld1N1YmplY3QsIGFjdGl2ZVRhZyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIGFjdGl2ZVRhZy5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVuc2V0IHByZWRpY2F0ZSB0byBhdm9pZCB0ZXh0IGNvbnRlbnRzIHRvIHByb2R1Y2UgbmV3IHRyaXBsZXNcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWcucHJlZGljYXRlcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gMTI6IENvbXBsZXRlIGluY29tcGxldGUgdHJpcGxlc1xuICAgICAgICBsZXQgaW5jb21wbGV0ZVRyaXBsZXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFhY3RpdmVUYWcuc2tpcEVsZW1lbnQgJiYgbmV3U3ViamVjdCAmJiBwYXJlbnRUYWcuaW5jb21wbGV0ZVRyaXBsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5jb21wbGV0ZVRyaXBsZXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaShwYXJlbnRUYWcuc3ViamVjdCwgYWN0aXZlVGFnKTtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaShuZXdTdWJqZWN0LCBhY3RpdmVUYWcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmNvbXBsZXRlVHJpcGxlIG9mIHBhcmVudFRhZy5pbmNvbXBsZXRlVHJpcGxlcykge1xuICAgICAgICAgICAgICAgIGlmICghaW5jb21wbGV0ZVRyaXBsZS5yZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNvbXBsZXRlVHJpcGxlLmxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGFjdGl2ZSB0YWcgdGhhdCBkZWZpbmVkIHRoZSBsaXN0IGJ5IGdvaW5nIHVwIHRoZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0SW5MaXN0VGFnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZVRhZ1N0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFnU3RhY2tbaV0uaW5saXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0SW5MaXN0VGFnID0gdGhpcy5hY3RpdmVUYWdTdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3RJbkxpc3RUYWcgaXMgZ3VhcmFudGVlZCB0byBiZSBub24tbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0TWFwcGluZyhmaXJzdEluTGlzdFRhZywgbmV3U3ViamVjdCwgaW5jb21wbGV0ZVRyaXBsZS5wcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUoc3ViamVjdCwgaW5jb21wbGV0ZVRyaXBsZS5wcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShvYmplY3QsIGluY29tcGxldGVUcmlwbGUucHJlZGljYXRlLCBzdWJqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmNvbXBsZXRlVHJpcGxlc0NvbXBsZXRlZCAmJiBwYXJlbnRUYWcuaW5jb21wbGV0ZVRyaXBsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYWN0aXZlVGFnLmluY29tcGxldGVUcmlwbGVzID0gYWN0aXZlVGFnLmluY29tcGxldGVUcmlwbGVzLmNvbmNhdChwYXJlbnRUYWcuaW5jb21wbGV0ZVRyaXBsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDEzOiBTYXZlIGV2YWx1YXRpb24gY29udGV4dCBpbnRvIGFjdGl2ZSB0YWdcbiAgICAgICAgYWN0aXZlVGFnLnN1YmplY3QgPSBuZXdTdWJqZWN0IHx8IHBhcmVudFRhZy5zdWJqZWN0O1xuICAgICAgICBhY3RpdmVUYWcub2JqZWN0ID0gY3VycmVudE9iamVjdFJlc291cmNlIHx8IG5ld1N1YmplY3Q7XG4gICAgfVxuICAgIG9uVGV4dChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhZyA9IHRoaXMuYWN0aXZlVGFnU3RhY2tbdGhpcy5hY3RpdmVUYWdTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gQ29sbGVjdCB0ZXh0IGluIHBhdHRlcm4gdGFnIGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcy5jb3B5UmRmYVBhdHRlcm5zICYmIGFjdGl2ZVRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnKSB7XG4gICAgICAgICAgICBhY3RpdmVUYWcuY29sbGVjdGVkUGF0dGVyblRhZy50ZXh0LnB1c2goZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2F2ZSB0aGUgdGV4dCBpbnNpZGUgdGhlIGFjdGl2ZSB0YWdcbiAgICAgICAgaWYgKCFhY3RpdmVUYWcudGV4dCkge1xuICAgICAgICAgICAgYWN0aXZlVGFnLnRleHQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVUYWcudGV4dC5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICBvblRhZ0Nsb3NlKCkge1xuICAgICAgICAvLyBHZXQgdGhlIGFjdGl2ZSB0YWdcbiAgICAgICAgY29uc3QgYWN0aXZlVGFnID0gdGhpcy5hY3RpdmVUYWdTdGFja1t0aGlzLmFjdGl2ZVRhZ1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBwYXJlbnRUYWcgPSB0aGlzLmFjdGl2ZVRhZ1N0YWNrW3RoaXMuYWN0aXZlVGFnU3RhY2subGVuZ3RoIC0gMl07XG4gICAgICAgIGlmICghKGFjdGl2ZVRhZy5jb2xsZWN0Q2hpbGRUYWdzICYmIHBhcmVudFRhZy5jb2xsZWN0Q2hpbGRUYWdzICYmIHRoaXMuZmVhdHVyZXMuc2tpcEhhbmRsaW5nWG1sTGl0ZXJhbENoaWxkcmVuKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZGV0ZWN0IGEgZmluYWxpemVkIHJkZmE6UGF0dGVybiB0YWcsIHN0b3JlIGl0XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlcy5jb3B5UmRmYVBhdHRlcm5zICYmIGFjdGl2ZVRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnXG4gICAgICAgICAgICAgICAgJiYgYWN0aXZlVGFnLmNvbGxlY3RlZFBhdHRlcm5UYWcucm9vdFBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuSWQgPSBhY3RpdmVUYWcuY29sbGVjdGVkUGF0dGVyblRhZy5hdHRyaWJ1dGVzLnJlc291cmNlO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSByZXNvdXJjZSBhbmQgdHlwZW9mIGF0dHJpYnV0ZXMgdG8gYXZvaWQgaXQgYmVpbmcgc2VlbiBhcyBhIG5ldyBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZVRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnLmF0dHJpYnV0ZXMucmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZVRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnLmF0dHJpYnV0ZXMudHlwZW9mO1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgdGhpcy5yZGZhUGF0dGVybnNbcGF0dGVybklkXSA9IGFjdGl2ZVRhZy5jb2xsZWN0ZWRQYXR0ZXJuVGFnO1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGFsbCBwZW5kaW5nIGNvcGllcyBmb3IgdGhpcyBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1JkZmFQYXR0ZXJuQ29waWVzW3BhdHRlcm5JZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy5wZW5kaW5nUmRmYVBhdHRlcm5Db3BpZXNbcGF0dGVybklkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UGF0dGVybkNvcHkodGFnLCBhY3RpdmVUYWcuY29sbGVjdGVkUGF0dGVyblRhZywgcGF0dGVybklkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmRmYVBhdHRlcm5Db3BpZXNbcGF0dGVybklkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBhY3RpdmUgdGFnIGZyb20gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWdTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbWl0IGFsbCB0cmlwbGVzIHRoYXQgd2VyZSBkZXRlcm1pbmVkIGluIHRoZSBhY3RpdmUgdGFnXG4gICAgICAgICAgICBpZiAoYWN0aXZlVGFnLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKGFjdGl2ZVRhZy5zdWJqZWN0LCBhY3RpdmVUYWcpO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0U2VnbWVudHMgPSBhY3RpdmVUYWcudGV4dCB8fCBbXTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVGFnLmNvbGxlY3RDaGlsZFRhZ3MgJiYgcGFyZW50VGFnLmNvbGxlY3RDaGlsZFRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluc2lkZSBhbiBYTUxMaXRlcmFsIGNoaWxkIHRoYXQgYWxzbyBoYXMgUkRGYSBjb250ZW50LCBpZ25vcmUgdGhlIHRhZyBuYW1lIHRoYXQgd2FzIGNvbGxlY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgdGV4dFNlZ21lbnRzID0gdGV4dFNlZ21lbnRzLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3QgPSB0aGlzLnV0aWwuY3JlYXRlTGl0ZXJhbCh0ZXh0U2VnbWVudHMuam9pbignJyksIGFjdGl2ZVRhZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVRhZy5pbmxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgYWN0aXZlVGFnLnByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdE1hcHBpbmcoYWN0aXZlVGFnLCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZGljYXRlIG9mIGFjdGl2ZVRhZy5wcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRleHQsIHVubGVzcyB0aGUgcGFyZW50IGlzIGFsc28gY29sbGVjdGluZyB0ZXh0XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUYWcucHJlZGljYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWcudGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMTQ6IEhhbmRsZSBsb2NhbCBsaXN0IG1hcHBpbmdcbiAgICAgICAgICAgIGlmIChhY3RpdmVUYWcub2JqZWN0ICYmIE9iamVjdC5rZXlzKGFjdGl2ZVRhZy5saXN0TWFwcGluZykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnV0aWwuZ2V0UmVzb3VyY2VPckJhc2VJcmkoYWN0aXZlVGFnLm9iamVjdCwgYWN0aXZlVGFnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZVZhbHVlIGluIGFjdGl2ZVRhZy5saXN0TWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB0aGlzLnV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKHByZWRpY2F0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gYWN0aXZlVGFnLmxpc3RNYXBwaW5nW3ByZWRpY2F0ZVZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb24tZW1wdHkgbGlzdCwgZW1pdCBsaW5rZWQgbGlzdCBvZiByZGY6Zmlyc3QgYW5kIHJkZjpyZXN0IGNoYWluc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm5vZGVzID0gdmFsdWVzLm1hcCgoKSA9PiB0aGlzLnV0aWwuY3JlYXRlQmxhbmtOb2RlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmplY3QgPSB0aGlzLnV0aWwuZ2V0UmVzb3VyY2VPckJhc2VJcmkodmFsdWVzW2ldLCBhY3RpdmVUYWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShibm9kZXNbaV0sIHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoVXRpbF8xLlV0aWwuUkRGICsgJ2ZpcnN0JyksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKGJub2Rlc1tpXSwgdGhpcy51dGlsLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShVdGlsXzEuVXRpbC5SREYgKyAncmVzdCcpLCAoaSA8IHZhbHVlcy5sZW5ndGggLSAxKSA/IGJub2Rlc1tpICsgMV0gOiB0aGlzLnV0aWwuZGF0YUZhY3RvcnkubmFtZWROb2RlKFV0aWxfMS5VdGlsLlJERiArICduaWwnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IHRyaXBsZSBmb3IgdGhlIGZpcnN0IGxpbmtlZCBsaXN0IGNoYWluXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUoc3ViamVjdCwgcHJlZGljYXRlLCBibm9kZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1wdHkgbGlzdCwganVzdCBlbWl0IHJkZjpuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShzdWJqZWN0LCBwcmVkaWNhdGUsIHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoVXRpbF8xLlV0aWwuUkRGICsgJ25pbCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGFjdGl2ZSB0YWcgZnJvbSB0aGUgc3RhY2tcbiAgICAgICAgdGhpcy5hY3RpdmVUYWdTdGFjay5wb3AoKTtcbiAgICAgICAgLy8gU2F2ZSB0aGUgdGFnIGNvbnRlbnRzIGlmIG5lZWRlZFxuICAgICAgICBpZiAoYWN0aXZlVGFnLmNvbGxlY3RDaGlsZFRhZ3MgJiYgYWN0aXZlVGFnLnRleHQpIHtcbiAgICAgICAgICAgIGFjdGl2ZVRhZy50ZXh0LnB1c2goYDwvJHthY3RpdmVUYWcubmFtZX0+YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSB0ZXh0IGNvbnRlbnRzLCB0cnkgdG8gYXBwZW5kIGl0IHRvIHRoZSBwYXJlbnQgdGFnXG4gICAgICAgIGlmIChhY3RpdmVUYWcudGV4dCAmJiBwYXJlbnRUYWcpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50VGFnLnRleHQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRUYWcudGV4dCA9IGFjdGl2ZVRhZy50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50VGFnLnRleHQgPSBwYXJlbnRUYWcudGV4dC5jb25jYXQoYWN0aXZlVGFnLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9uRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlcy5jb3B5UmRmYVBhdHRlcm5zKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzLmNvcHlSZGZhUGF0dGVybnMgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEVtaXQgYWxsIHVucmVmZXJlbmNlZCBwYXR0ZXJuc1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuSWQgaW4gdGhpcy5yZGZhUGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5yZGZhUGF0dGVybnNbcGF0dGVybklkXTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4ucmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLmF0dHJpYnV0ZXMudHlwZW9mID0gJ3JkZmE6UGF0dGVybic7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uYXR0cmlidXRlcy5yZXNvdXJjZSA9IHBhdHRlcm5JZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UGF0dGVybkNvcHkocGF0dGVybi5wYXJlbnRUYWcsIHBhdHRlcm4sIHBhdHRlcm5JZCk7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4ucmVmZXJlbmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGF0dGVybi5hdHRyaWJ1dGVzLnR5cGVvZjtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdHRlcm4uYXR0cmlidXRlcy5yZXNvdXJjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbWl0IGFsbCB1bnJlZmVyZW5jZWQgY29weSBsaW5rc1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuSWQgaW4gdGhpcy5wZW5kaW5nUmRmYVBhdHRlcm5Db3BpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmVudFRhZyBvZiB0aGlzLnBlbmRpbmdSZGZhUGF0dGVybkNvcGllc1twYXR0ZXJuSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFnU3RhY2sucHVzaChwYXJlbnRUYWcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGFnT3BlbignbGluaycsIHsgcHJvcGVydHk6ICdyZGZhOmNvcHknLCBocmVmOiBwYXR0ZXJuSWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UYWdDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMuY29weVJkZmFQYXR0ZXJucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIG5ldyBzdWJqZWN0IGNhbiBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IG9iamVjdFxuICAgICAqIGlmIHRoZSByZXNvdXJjZSBkZWZpbmVzIG5vIG5ldyBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBjdXJyZW50IHRhZyBuYW1lLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJZiB0aGUgc3ViamVjdCBjYW4gYmUgaW5oZXJpdGVkLlxuICAgICAqL1xuICAgIGlzSW5oZXJpdFN1YmplY3RJbkhlYWRCb2R5KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXMuaW5oZXJpdFN1YmplY3RJbkhlYWRCb2R5ICYmIChuYW1lID09PSAnaGVhZCcgfHwgbmFtZSA9PT0gJ2JvZHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdCBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcHJlZGljYXRlIGFuZCBvYmplY3QgaW4gdGhlIGFjdGl2ZSB0YWcuXG4gICAgICogQHBhcmFtIHtJQWN0aXZlVGFnfSBhY3RpdmVUYWcgVGhlIGFjdGl2ZSB0YWcuXG4gICAgICogQHBhcmFtIHtUZXJtIHwgYm9vbGVhbn0gc3ViamVjdCBBIHN1YmplY3QgdGVybSwgdGhpcyB3aWxsIG9ubHkgYmUgdXNlZCB0byBjcmVhdGUgYSBzZXBhcmF0ZSBsaXN0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBhY3RpdmVUYWcuZXhwbGljaXROZXdTdWJqZWN0IGlzIHRydWUuXG4gICAgICogQHBhcmFtIHtUZXJtfSBwcmVkaWNhdGUgQSBwcmVkaWNhdGUgdGVybS5cbiAgICAgKiBAcGFyYW0ge1Rlcm0gfCBib29sZWFufSBjdXJyZW50T2JqZWN0UmVzb3VyY2UgVGhlIGN1cnJlbnQgb2JqZWN0IHJlc291cmNlLlxuICAgICAqL1xuICAgIGFkZExpc3RNYXBwaW5nKGFjdGl2ZVRhZywgc3ViamVjdCwgcHJlZGljYXRlLCBjdXJyZW50T2JqZWN0UmVzb3VyY2UpIHtcbiAgICAgICAgaWYgKGFjdGl2ZVRhZy5leHBsaWNpdE5ld1N1YmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGJOb2RlID0gdGhpcy51dGlsLmNyZWF0ZUJsYW5rTm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0VHJpcGxlKHRoaXMudXRpbC5nZXRSZXNvdXJjZU9yQmFzZUlyaShzdWJqZWN0LCBhY3RpdmVUYWcpLCBwcmVkaWNhdGUsIGJOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFRyaXBsZShiTm9kZSwgdGhpcy51dGlsLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShVdGlsXzEuVXRpbC5SREYgKyAnZmlyc3QnKSwgdGhpcy51dGlsLmdldFJlc291cmNlT3JCYXNlSXJpKGN1cnJlbnRPYmplY3RSZXNvdXJjZSwgYWN0aXZlVGFnKSk7XG4gICAgICAgICAgICB0aGlzLmVtaXRUcmlwbGUoYk5vZGUsIHRoaXMudXRpbC5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoVXRpbF8xLlV0aWwuUkRGICsgJ3Jlc3QnKSwgdGhpcy51dGlsLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShVdGlsXzEuVXRpbC5SREYgKyAnbmlsJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByZWRpY2F0ZUxpc3QgPSBhY3RpdmVUYWcubGlzdE1hcHBpbmdMb2NhbFtwcmVkaWNhdGUudmFsdWVdO1xuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFnLmxpc3RNYXBwaW5nTG9jYWxbcHJlZGljYXRlLnZhbHVlXSA9IHByZWRpY2F0ZUxpc3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50T2JqZWN0UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGVMaXN0LnB1c2goY3VycmVudE9iamVjdFJlc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IHRoZSBnaXZlbiB0cmlwbGUgdG8gdGhlIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge1Rlcm19IHN1YmplY3QgQSBzdWJqZWN0IHRlcm0uXG4gICAgICogQHBhcmFtIHtUZXJtfSBwcmVkaWNhdGUgQSBwcmVkaWNhdGUgdGVybS5cbiAgICAgKiBAcGFyYW0ge1Rlcm19IG9iamVjdCBBbiBvYmplY3QgdGVybS5cbiAgICAgKi9cbiAgICBlbWl0VHJpcGxlKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIElSSXNcbiAgICAgICAgaWYgKChzdWJqZWN0LnRlcm1UeXBlID09PSAnTmFtZWROb2RlJyAmJiBzdWJqZWN0LnZhbHVlLmluZGV4T2YoJzonKSA8IDApXG4gICAgICAgICAgICB8fCAocHJlZGljYXRlLnRlcm1UeXBlID09PSAnTmFtZWROb2RlJyAmJiBwcmVkaWNhdGUudmFsdWUuaW5kZXhPZignOicpIDwgMClcbiAgICAgICAgICAgIHx8IChvYmplY3QudGVybVR5cGUgPT09ICdOYW1lZE5vZGUnICYmIG9iamVjdC52YWx1ZS5pbmRleE9mKCc6JykgPCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVzaCh0aGlzLnV0aWwuZGF0YUZhY3RvcnkucXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgdGhpcy5kZWZhdWx0R3JhcGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBhbiBpbnN0YW50aWF0aW9uIG9mIHRoZSBnaXZlbiBwYXR0ZXJuIHdpdGggdGhlIGdpdmVuIHBhcmVudCB0YWcuXG4gICAgICogQHBhcmFtIHtJQWN0aXZlVGFnfSBwYXJlbnRUYWcgVGhlIHBhcmVudCB0YWcgdG8gaW5zdGFudGlhdGUgaW4uXG4gICAgICogQHBhcmFtIHtJUmRmYVBhdHRlcm59IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gaW5zdGFudGlhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RQYXR0ZXJuSWQgVGhlIHBhdHRlcm4gaWQuXG4gICAgICovXG4gICAgZW1pdFBhdHRlcm5Db3B5KHBhcmVudFRhZywgcGF0dGVybiwgcm9vdFBhdHRlcm5JZCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhZ1N0YWNrLnB1c2gocGFyZW50VGFnKTtcbiAgICAgICAgcGF0dGVybi5yZWZlcmVuY2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgYmxhbmsgbm9kZXMgd2l0aGluIHBhdHRlcm5zIGFyZSBpbnN0YW50aWF0ZWQgb25seSBvbmNlLlxuICAgICAgICAvLyBBbGwgbmV4dCBwYXR0ZXJuIGNvcGllcyB3aWxsIHJldXNlIHRoZSBpbnN0YW50aWF0ZWQgYmxhbmsgbm9kZXMgZnJvbSB0aGUgZmlyc3QgcGF0dGVybi5cbiAgICAgICAgaWYgKCFwYXR0ZXJuLmNvbnN0cnVjdGVkQmxhbmtOb2Rlcykge1xuICAgICAgICAgICAgcGF0dGVybi5jb25zdHJ1Y3RlZEJsYW5rTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudXRpbC5ibGFua05vZGVGYWN0b3J5ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJOb2RlID0gdGhpcy51dGlsLmRhdGFGYWN0b3J5LmJsYW5rTm9kZSgpO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4uY29uc3RydWN0ZWRCbGFua05vZGVzLnB1c2goYk5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiTm9kZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmxhbmtOb2RlSW5kZXggPSAwO1xuICAgICAgICAgICAgdGhpcy51dGlsLmJsYW5rTm9kZUZhY3RvcnkgPSAoKSA9PiBwYXR0ZXJuLmNvbnN0cnVjdGVkQmxhbmtOb2Rlc1tibGFua05vZGVJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBseSBldmVyeXRoaW5nIHdpdGhpbiB0aGUgcGF0dGVyblxuICAgICAgICB0aGlzLmVtaXRQYXR0ZXJuQ29weUFic29sdXRlKHBhdHRlcm4sIHRydWUsIHJvb3RQYXR0ZXJuSWQpO1xuICAgICAgICB0aGlzLnV0aWwuYmxhbmtOb2RlRmFjdG9yeSA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFnU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgYW4gaW5zdGFudGlhdGlvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIHRoZSBnaXZlbiBwYXJlbnQgdGFnLlxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgcHJvYmFibHkgbm90IGJlIGNhbGxlZCBkaXJlY3RseSxcbiAgICAgKiBjYWxsIHtAbGluayBlbWl0UGF0dGVybkNvcHl9IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lSZGZhUGF0dGVybn0gcGF0dGVybiBUaGUgcGF0dGVybiB0byBpbnN0YW50aWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJvb3QgSWYgdGhpcyBpcyB0aGUgcm9vdCBjYWxsIGZvciB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdFBhdHRlcm5JZCBUaGUgcGF0dGVybiBpZC5cbiAgICAgKi9cbiAgICBlbWl0UGF0dGVybkNvcHlBYnNvbHV0ZShwYXR0ZXJuLCByb290LCByb290UGF0dGVybklkKSB7XG4gICAgICAgIC8vIFN0b3Agb24gZGV0ZWN0aW9uIG9mIGN5Y2xpYyBwYXR0ZXJuc1xuICAgICAgICBpZiAoIXJvb3QgJiYgcGF0dGVybi5hdHRyaWJ1dGVzLnByb3BlcnR5ID09PSAncmRmYTpjb3B5JyAmJiBwYXR0ZXJuLmF0dHJpYnV0ZXMuaHJlZiA9PT0gcm9vdFBhdHRlcm5JZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25UYWdPcGVuKHBhdHRlcm4ubmFtZSwgcGF0dGVybi5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZm9yIChjb25zdCB0ZXh0IG9mIHBhdHRlcm4udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5vblRleHQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBwYXR0ZXJuLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRQYXR0ZXJuQ29weUFic29sdXRlKGNoaWxkLCBmYWxzZSwgcm9vdFBhdHRlcm5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblRhZ0Nsb3NlKCk7XG4gICAgfVxuICAgIGluaXRpYWxpemVQYXJzZXIoeG1sTW9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IGh0bWxwYXJzZXIyXzEuUGFyc2VyKHtcbiAgICAgICAgICAgIG9uY2xvc2V0YWc6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGFnQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIub25UYWdDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lbmQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmh0bWxQYXJzZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmh0bWxQYXJzZUxpc3RlbmVyLm9uRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbm9wZW50YWc6IChuYW1lLCBhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRhZ09wZW4obmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmh0bWxQYXJzZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmh0bWxQYXJzZUxpc3RlbmVyLm9uVGFnT3BlbihuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9udGV4dDogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGV4dChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHRtbFBhcnNlTGlzdGVuZXIub25UZXh0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWNvZGVFbnRpdGllczogdHJ1ZSxcbiAgICAgICAgICAgIHJlY29nbml6ZVNlbGZDbG9zaW5nOiB0cnVlLFxuICAgICAgICAgICAgeG1sTW9kZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZGZhUGFyc2VyID0gUmRmYVBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJkZmFQYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJERkFfQ09OVEVOVFRZUEVTID0gZXhwb3J0cy5SREZBX0ZFQVRVUkVTID0gdm9pZCAwO1xuLyoqXG4gKiBBIG1hcHBpbmcgb2YgUkRGYSBwcm9maWxlIHRvIGEgZmVhdHVyZXMgb2JqZWN0LlxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXNcbmV4cG9ydHMuUkRGQV9GRUFUVVJFUyA9IHtcbiAgICAnJzoge1xuICAgICAgICBiYXNlVGFnOiB0cnVlLFxuICAgICAgICB4bWxCYXNlOiB0cnVlLFxuICAgICAgICBsYW5nQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICBvbmx5QWxsb3dVcmlSZWxSZXZJZlByb3BlcnR5OiB0cnVlLFxuICAgICAgICBpbmhlcml0U3ViamVjdEluSGVhZEJvZHk6IHRydWUsXG4gICAgICAgIGRhdGV0aW1lQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICB0aW1lVGFnOiB0cnVlLFxuICAgICAgICBodG1sRGF0YXR5cGU6IHRydWUsXG4gICAgICAgIGNvcHlSZGZhUGF0dGVybnM6IHRydWUsXG4gICAgICAgIHhtbG5zUHJlZml4TWFwcGluZ3M6IHRydWUsXG4gICAgICAgIHhodG1sSW5pdGlhbENvbnRleHQ6IHRydWUsXG4gICAgICAgIHJvbGVBdHRyaWJ1dGU6IHRydWUsXG4gICAgfSxcbiAgICAnY29yZSc6IHtcbiAgICAgICAgYmFzZVRhZzogZmFsc2UsXG4gICAgICAgIHhtbEJhc2U6IGZhbHNlLFxuICAgICAgICBsYW5nQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICBvbmx5QWxsb3dVcmlSZWxSZXZJZlByb3BlcnR5OiB0cnVlLFxuICAgICAgICBpbmhlcml0U3ViamVjdEluSGVhZEJvZHk6IGZhbHNlLFxuICAgICAgICBkYXRldGltZUF0dHJpYnV0ZTogZmFsc2UsXG4gICAgICAgIHRpbWVUYWc6IGZhbHNlLFxuICAgICAgICBodG1sRGF0YXR5cGU6IGZhbHNlLFxuICAgICAgICBjb3B5UmRmYVBhdHRlcm5zOiB0cnVlLFxuICAgICAgICB4bWxuc1ByZWZpeE1hcHBpbmdzOiB0cnVlLFxuICAgICAgICB4aHRtbEluaXRpYWxDb250ZXh0OiBmYWxzZSxcbiAgICAgICAgcm9sZUF0dHJpYnV0ZTogZmFsc2UsXG4gICAgfSxcbiAgICAnaHRtbCc6IHtcbiAgICAgICAgYmFzZVRhZzogdHJ1ZSxcbiAgICAgICAgeG1sQmFzZTogZmFsc2UsXG4gICAgICAgIGxhbmdBdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIG9ubHlBbGxvd1VyaVJlbFJldklmUHJvcGVydHk6IHRydWUsXG4gICAgICAgIGluaGVyaXRTdWJqZWN0SW5IZWFkQm9keTogdHJ1ZSxcbiAgICAgICAgZGF0ZXRpbWVBdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIHRpbWVUYWc6IHRydWUsXG4gICAgICAgIGh0bWxEYXRhdHlwZTogdHJ1ZSxcbiAgICAgICAgY29weVJkZmFQYXR0ZXJuczogdHJ1ZSxcbiAgICAgICAgeG1sbnNQcmVmaXhNYXBwaW5nczogdHJ1ZSxcbiAgICAgICAgeGh0bWxJbml0aWFsQ29udGV4dDogZmFsc2UsXG4gICAgICAgIHJvbGVBdHRyaWJ1dGU6IHRydWUsXG4gICAgfSxcbiAgICAneGh0bWwnOiB7XG4gICAgICAgIGJhc2VUYWc6IHRydWUsXG4gICAgICAgIHhtbEJhc2U6IGZhbHNlLFxuICAgICAgICBsYW5nQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICBvbmx5QWxsb3dVcmlSZWxSZXZJZlByb3BlcnR5OiB0cnVlLFxuICAgICAgICBpbmhlcml0U3ViamVjdEluSGVhZEJvZHk6IHRydWUsXG4gICAgICAgIGRhdGV0aW1lQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICB0aW1lVGFnOiB0cnVlLFxuICAgICAgICBodG1sRGF0YXR5cGU6IHRydWUsXG4gICAgICAgIGNvcHlSZGZhUGF0dGVybnM6IHRydWUsXG4gICAgICAgIHhtbG5zUHJlZml4TWFwcGluZ3M6IHRydWUsXG4gICAgICAgIHhodG1sSW5pdGlhbENvbnRleHQ6IHRydWUsXG4gICAgICAgIHJvbGVBdHRyaWJ1dGU6IHRydWUsXG4gICAgfSxcbiAgICAneG1sJzoge1xuICAgICAgICBiYXNlVGFnOiBmYWxzZSxcbiAgICAgICAgeG1sQmFzZTogdHJ1ZSxcbiAgICAgICAgbGFuZ0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgb25seUFsbG93VXJpUmVsUmV2SWZQcm9wZXJ0eTogZmFsc2UsXG4gICAgICAgIGluaGVyaXRTdWJqZWN0SW5IZWFkQm9keTogZmFsc2UsXG4gICAgICAgIGRhdGV0aW1lQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICB0aW1lVGFnOiB0cnVlLFxuICAgICAgICBodG1sRGF0YXR5cGU6IGZhbHNlLFxuICAgICAgICBjb3B5UmRmYVBhdHRlcm5zOiBmYWxzZSxcbiAgICAgICAgeG1sbnNQcmVmaXhNYXBwaW5nczogdHJ1ZSxcbiAgICAgICAgeGh0bWxJbml0aWFsQ29udGV4dDogZmFsc2UsXG4gICAgICAgIHJvbGVBdHRyaWJ1dGU6IHRydWUsXG4gICAgfSxcbn07XG4vLyB0c2xpbnQ6ZW5hYmxlOm9iamVjdC1saXRlcmFsLXNvcnQta2V5c1xuLy8gdHNsaW50OmRpc2FibGU6b2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzXG5leHBvcnRzLlJERkFfQ09OVEVOVFRZUEVTID0ge1xuICAgIC8vIEhUTUxcbiAgICAndGV4dC9odG1sJzogJ2h0bWwnLFxuICAgIC8vIFhIVE1MXG4gICAgJ2FwcGxpY2F0aW9uL3hodG1sK3htbCc6ICd4aHRtbCcsXG4gICAgLy8gWE1MXG4gICAgJ2FwcGxpY2F0aW9uL3htbCc6ICd4bWwnLFxuICAgICd0ZXh0L3htbCc6ICd4bWwnLFxuICAgICdpbWFnZS9zdmcreG1sJzogJ3htbCcsXG59O1xuLy8gdHNsaW50OmVuYWJsZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXNcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJkZmFQcm9maWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VdGlsID0gdm9pZCAwO1xuY29uc3QgcmVsYXRpdmVfdG9fYWJzb2x1dGVfaXJpXzEgPSByZXF1aXJlKFwicmVsYXRpdmUtdG8tYWJzb2x1dGUtaXJpXCIpO1xuY29uc3QgUmRmYVByb2ZpbGVfMSA9IHJlcXVpcmUoXCIuL1JkZmFQcm9maWxlXCIpO1xuY29uc3QgcmRmX2RhdGFfZmFjdG9yeV8xID0gcmVxdWlyZShcInJkZi1kYXRhLWZhY3RvcnlcIik7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuY2xhc3MgVXRpbCB7XG4gICAgY29uc3RydWN0b3IoZGF0YUZhY3RvcnksIGJhc2VJUkkpIHtcbiAgICAgICAgdGhpcy5kYXRhRmFjdG9yeSA9IGRhdGFGYWN0b3J5IHx8IG5ldyByZGZfZGF0YV9mYWN0b3J5XzEuRGF0YUZhY3RvcnkoKTtcbiAgICAgICAgdGhpcy5iYXNlSVJJID0gdGhpcy5kYXRhRmFjdG9yeS5uYW1lZE5vZGUoYmFzZUlSSSB8fCAnJyk7XG4gICAgICAgIHRoaXMuYmFzZUlSSURvY3VtZW50ID0gdGhpcy5iYXNlSVJJO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcHJlZml4ZXMgb2YgdGhlIGN1cnJlbnQgdGFnJ3MgYXR0cmlidXRlcy5cbiAgICAgKiBAcGFyYW0ge3tbcDogc3RyaW5nXTogc3RyaW5nfX0gYXR0cmlidXRlcyBBIHRhZydzIGF0dHJpYnV0ZXMuXG4gICAgICogQHBhcmFtIHt7W3A6IHN0cmluZ106IHN0cmluZ319IHBhcmVudFByZWZpeGVzIFRoZSBwcmVmaXhlcyBmcm9tIHRoZSBwYXJlbnQgdGFnLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0geG1sbnNQcmVmaXhNYXBwaW5ncyBJZiBwcmVmaXhlcyBzaG91bGQgYmUgZXh0cmFjdGVkIGZyb20geG1sbnNQcmVmaXhNYXBwaW5ncy5cbiAgICAgKiBAcmV0dXJuIHt7W3A6IHN0cmluZ106IHN0cmluZ319IFRoZSBuZXcgcHJlZml4ZXMuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlUHJlZml4ZXMoYXR0cmlidXRlcywgcGFyZW50UHJlZml4ZXMsIHhtbG5zUHJlZml4TWFwcGluZ3MpIHtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbFByZWZpeGVzID0ge307XG4gICAgICAgIGlmICh4bWxuc1ByZWZpeE1hcHBpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5zdGFydHNXaXRoKCd4bWxucycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcmVmaXhlc1thdHRyaWJ1dGUuc3Vic3RyKDYpXSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMucHJlZml4IHx8IE9iamVjdC5rZXlzKGFkZGl0aW9uYWxQcmVmaXhlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFByZWZpeGVzKSwgYWRkaXRpb25hbFByZWZpeGVzKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnByZWZpeCkge1xuICAgICAgICAgICAgICAgIGxldCBwcmVmaXhNYXRjaDtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIHdoaWxlIChwcmVmaXhNYXRjaCA9IFV0aWwuUFJFRklYX1JFR0VYLmV4ZWMoYXR0cmlidXRlcy5wcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeGVzW3ByZWZpeE1hdGNoWzFdXSA9IHByZWZpeE1hdGNoWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmVmaXhlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRQcmVmaXhlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBhbmQgdGhlIGdpdmVuIHRlcm0gdmFsdWUgYmFzZWQgb24gdGhlIGdpdmVuIHByZWZpeGVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXJtIEEgdGVybSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3tbcDogc3RyaW5nXTogc3RyaW5nfVtdfSBwcmVmaXhlcyBUaGUgYXZhaWxhYmxlIHByZWZpeGVzLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXhwYW5kZWQgVVJMLCBvciB0aGUgdGVybSBhcy1pcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhwYW5kUHJlZml4ZWRUZXJtKHRlcm0sIGFjdGl2ZVRhZykge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdGVybSBpcyBwcmVmaXhlZFxuICAgICAgICBjb25zdCBjb2xvbkluZGV4ID0gdGVybS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgIGxldCBsb2NhbDtcbiAgICAgICAgaWYgKGNvbG9uSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcHJlZml4ID0gdGVybS5zdWJzdHIoMCwgY29sb25JbmRleCk7XG4gICAgICAgICAgICBsb2NhbCA9IHRlcm0uc3Vic3RyKGNvbG9uSW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHBhbmQgZGVmYXVsdCBuYW1lc3BhY2VcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiMnICsgbG9jYWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGV4cGFuZCB0aGUgcHJlZml4XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeEVsZW1lbnQgPSBhY3RpdmVUYWcucHJlZml4ZXNBbGxbcHJlZml4XTtcbiAgICAgICAgICAgIGlmIChwcmVmaXhFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeEVsZW1lbnQgKyBsb2NhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gZXhwYW5kIHRoZSB0ZXJtXG4gICAgICAgIGlmICh0ZXJtKSB7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZFRlcm0gPSBhY3RpdmVUYWcucHJlZml4ZXNBbGxbdGVybS50b0xvY2FsZUxvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmIChleHBhbmRlZFRlcm0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kZWRUZXJtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXJtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gSVJJIGlzIHZhbGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpcmkgQSBwb3RlbnRpYWwgSVJJLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBnaXZlbiBJUkkgaXMgdmFsaWQuXG4gICAgICovXG4gICAgc3RhdGljIGlzVmFsaWRJcmkoaXJpKSB7XG4gICAgICAgIHJldHVybiBVdGlsLklSSV9SRUdFWC50ZXN0KGlyaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgUkRGYSBwcm9maWxlIGZyb20gdGhlIGdpdmVuIGNvbnRlbnQgdHlwZS5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgZGVmYXVsdCBSREZhIHByb2ZpbGUgKGFsbCBmZWF0dXJlcyBlbmFibGVkKSBmb3IgdW5rbm93biBjb250ZW50IHR5cGVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50VHlwZSBBIGNvbnRlbnQgdHlwZS5cbiAgICAgKiBAcmV0dXJucyB7UmRmYVByb2ZpbGV9IEFuIFJERmEgcHJvZmlsZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udGVudFR5cGVUb1Byb2ZpbGUoY29udGVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFJkZmFQcm9maWxlXzEuUkRGQV9DT05URU5UVFlQRVNbY29udGVudFR5cGVdIHx8ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhc2UgSVJJLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlSXJpVmFsdWUgQSBiYXNlIElSSSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIEEgYmFzZSBJUkkgbmFtZWQgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRCYXNlSVJJKGJhc2VJcmlWYWx1ZSkge1xuICAgICAgICBsZXQgaHJlZiA9IGJhc2VJcmlWYWx1ZTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICAgICAgICBpZiAoZnJhZ21lbnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBocmVmID0gaHJlZi5zdWJzdHIoMCwgZnJhZ21lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZhY3RvcnkubmFtZWROb2RlKHJlbGF0aXZlX3RvX2Fic29sdXRlX2lyaV8xLnJlc29sdmUoaHJlZiwgdGhpcy5iYXNlSVJJLnZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB0ZXJtIGlzIGEgYm9vbGVhbiwgcmV0dXJuIHRoZSBiYXNlSVJJLCBvdGhlcndpc2UgcmV0dXJuIHRoZSB0ZXJtIGFzLWlzLlxuICAgICAqIEBwYXJhbSB7VGVybSB8IGJvb2xlYW59IHRlcm0gQSB0ZXJtIG9yIGJvb2xlYW4sIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGUgYmFzZUlSSS5cbiAgICAgKiBAcGFyYW0ge0lBY3RpdmVUYWd9IGFjdGl2ZVRhZyBBbiBhY3RpdmUgdGFnLlxuICAgICAqIEByZXR1cm5zIHtUZXJtfSBBIHRlcm0uXG4gICAgICovXG4gICAgZ2V0UmVzb3VyY2VPckJhc2VJcmkodGVybSwgYWN0aXZlVGFnKSB7XG4gICAgICAgIHJldHVybiB0ZXJtID09PSB0cnVlID8gdGhpcy5nZXRCYXNlSXJpVGVybShhY3RpdmVUYWcpIDogdGVybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhY3RpdmUgYmFzZSBJUkkgYXMgYW4gUkRGIHRlcm0uXG4gICAgICogQHBhcmFtIHtJQWN0aXZlVGFnfSBhY3RpdmVUYWcgVGhlIGFjdGl2ZSB0YWcuXG4gICAgICogQHJldHVybiB7TmFtZWROb2RlfSBUaGUgYmFzZSBJUkkgdGVybS5cbiAgICAgKi9cbiAgICBnZXRCYXNlSXJpVGVybShhY3RpdmVUYWcpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVRhZy5sb2NhbEJhc2VJUkkgfHwgdGhpcy5iYXNlSVJJO1xuICAgIH1cbiAgICBjcmVhdGVWb2NhYklyaXModGVybXMsIGFjdGl2ZVRhZywgYWxsb3dUZXJtcywgYWxsb3dCbGFua05vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRlcm1zLnNwbGl0KC9cXHMrLylcbiAgICAgICAgICAgIC5maWx0ZXIoKHRlcm0pID0+IHRlcm0gJiYgKGFsbG93VGVybXMgfHwgdGVybS5pbmRleE9mKCc6JykgPj0gMCkpXG4gICAgICAgICAgICAubWFwKChwcm9wZXJ0eSkgPT4gdGhpcy5jcmVhdGVJcmkocHJvcGVydHksIGFjdGl2ZVRhZywgdHJ1ZSwgdHJ1ZSwgYWxsb3dCbGFua05vZGUpKVxuICAgICAgICAgICAgLmZpbHRlcigodGVybSkgPT4gdGVybSAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGxpdGVyYWwgbm9kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGl0ZXJhbCBUaGUgbGl0ZXJhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0lBY3RpdmVUYWd9IGFjdGl2ZVRhZyBUaGUgY3VycmVudCBhY3RpdmUgdGFnLlxuICAgICAqIEByZXR1cm4ge0xpdGVyYWx9IEEgbmV3IGxpdGVyYWwgbm9kZS5cbiAgICAgKi9cbiAgICBjcmVhdGVMaXRlcmFsKGxpdGVyYWwsIGFjdGl2ZVRhZykge1xuICAgICAgICBpZiAoYWN0aXZlVGFnLmludGVycHJldE9iamVjdEFzVGltZSAmJiAhYWN0aXZlVGFnLmRhdGF0eXBlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIFV0aWwuVElNRV9SRUdFWEVTKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpdGVyYWwubWF0Y2goZW50cnkucmVnZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhZy5kYXRhdHlwZSA9IHRoaXMuZGF0YUZhY3RvcnkubmFtZWROb2RlKFV0aWwuWFNEICsgZW50cnkudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhRmFjdG9yeS5saXRlcmFsKGxpdGVyYWwsIGFjdGl2ZVRhZy5kYXRhdHlwZSB8fCBhY3RpdmVUYWcubGFuZ3VhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBibGFuayBub2RlLlxuICAgICAqIEByZXR1cm5zIHtCbGFua05vZGV9IEEgbmV3IGJsYW5rIG5vZGUuXG4gICAgICovXG4gICAgY3JlYXRlQmxhbmtOb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5ibGFua05vZGVGYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibGFua05vZGVGYWN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZhY3RvcnkuYmxhbmtOb2RlKCk7XG4gICAgfVxuICAgIGNyZWF0ZUlyaSh0ZXJtLCBhY3RpdmVUYWcsIHZvY2FiLCBhbGxvd1NhZmVDdXJpZSwgYWxsb3dCbGFua05vZGUpIHtcbiAgICAgICAgdGVybSA9IHRlcm0gfHwgJyc7XG4gICAgICAgIGlmICghYWxsb3dTYWZlQ3VyaWUpIHtcbiAgICAgICAgICAgIGlmICghdm9jYWIpIHtcbiAgICAgICAgICAgICAgICB0ZXJtID0gcmVsYXRpdmVfdG9fYWJzb2x1dGVfaXJpXzEucmVzb2x2ZSh0ZXJtLCB0aGlzLmdldEJhc2VJcmlUZXJtKGFjdGl2ZVRhZykudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFVdGlsLmlzVmFsaWRJcmkodGVybSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZSh0ZXJtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgc3RyaWN0IENVUklFc1xuICAgICAgICBpZiAodGVybS5sZW5ndGggPiAwICYmIHRlcm1bMF0gPT09ICdbJyAmJiB0ZXJtW3Rlcm0ubGVuZ3RoIC0gMV0gPT09ICddJykge1xuICAgICAgICAgICAgdGVybSA9IHRlcm0uc3Vic3RyKDEsIHRlcm0ubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAvLyBTdHJpY3QgQ1VSSUVzIE1VU1QgaGF2ZSBhIHByZWZpeCBzZXBhcmF0b3JcbiAgICAgICAgICAgIGlmICh0ZXJtLmluZGV4T2YoJzonKSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYmxhbmsgbm9kZXNcbiAgICAgICAgaWYgKHRlcm0uc3RhcnRzV2l0aCgnXzonKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFsbG93QmxhbmtOb2RlID8gdGhpcy5kYXRhRmFjdG9yeS5ibGFua05vZGUodGVybS5zdWJzdHIoMikgfHwgJ2JfaWRlbnRpdHknKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHZvY2FiIElSSXNcbiAgICAgICAgaWYgKHZvY2FiKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlVGFnLnZvY2FiICYmIHRlcm0uaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShhY3RpdmVUYWcudm9jYWIgKyB0ZXJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgcHJlZml4ZWQgSVJJc1xuICAgICAgICBsZXQgaXJpID0gVXRpbC5leHBhbmRQcmVmaXhlZFRlcm0odGVybSwgYWN0aXZlVGFnKTtcbiAgICAgICAgLy8gUmVzb2x2ZSBhZ2FpbnN0IGJhc2VJUkkgaWYgaW4gYmFzZS1tb2RlLCBvciBpZiB0aGUgdGVybSB3YXMgYSBwcmVmaXhlZCByZWxhdGl2ZSBJUklcbiAgICAgICAgaWYgKCF2b2NhYikge1xuICAgICAgICAgICAgaXJpID0gcmVsYXRpdmVfdG9fYWJzb2x1dGVfaXJpXzEucmVzb2x2ZShpcmksIHRoaXMuZ2V0QmFzZUlyaVRlcm0oYWN0aXZlVGFnKS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGVybSAhPT0gaXJpKSB7XG4gICAgICAgICAgICBpcmkgPSByZWxhdGl2ZV90b19hYnNvbHV0ZV9pcmlfMS5yZXNvbHZlKGlyaSwgdGhpcy5iYXNlSVJJRG9jdW1lbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghVXRpbC5pc1ZhbGlkSXJpKGlyaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFGYWN0b3J5Lm5hbWVkTm9kZShpcmkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVXRpbCA9IFV0aWw7XG5VdGlsLlJERiA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjJztcblV0aWwuWFNEID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hIyc7XG5VdGlsLlJERkEgPSAnaHR0cDovL3d3dy53My5vcmcvbnMvcmRmYSMnO1xuVXRpbC5QUkVGSVhfUkVHRVggPSAvXFxzKihbXjpcXHNdKikqOlxccyooW15cXHNdKikqXFxzKi9nO1xuVXRpbC5USU1FX1JFR0VYRVMgPSBbXG4gICAge1xuICAgICAgICByZWdleDogL14tP1AoWzAtOV0rWSk/KFswLTldK00pPyhbMC05XStEKT8oVChbMC05XStIKT8oWzAtOV0rTSk/KFswLTldKyhcXC5bMC05XSk/Uyk/KT8kLyxcbiAgICAgICAgdHlwZTogJ2R1cmF0aW9uJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgcmVnZXg6IC9eWzAtOV0rLVswLTldWzAtOV0tWzAtOV1bMC05XVRbMC05XVswLTldOlswLTldWzAtOV06WzAtOV1bMC05XSgoWj8pfChbXFwrLV1bMC05XVswLTldOlswLTldWzAtOV0pKSQvLFxuICAgICAgICB0eXBlOiAnZGF0ZVRpbWUnLFxuICAgIH0sXG4gICAgeyByZWdleDogL15bMC05XSstWzAtOV1bMC05XS1bMC05XVswLTldWj8kLywgdHlwZTogJ2RhdGUnIH0sXG4gICAgeyByZWdleDogL15bMC05XVswLTldOlswLTldWzAtOV06WzAtOV1bMC05XSgoWj8pfChbXFwrLV1bMC05XVswLTldOlswLTldWzAtOV0pKSQvLCB0eXBlOiAndGltZScgfSxcbiAgICB7IHJlZ2V4OiAvXlswLTldKy1bMC05XVswLTldJC8sIHR5cGU6ICdnWWVhck1vbnRoJyB9LFxuICAgIHsgcmVnZXg6IC9eWzAtOV0rJC8sIHR5cGU6ICdnWWVhcicgfSxcbl07XG5VdGlsLklSSV9SRUdFWCA9IC9eKFtBLVphLXpdW0EtWmEtejAtOSstLl0qfF8pOlteIFwiPD57fXxcXFxcXFxbXFxdYF0qJC87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VdGlsLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJAY29udGV4dFwiOiB7XG4gICAgXCJhbHRlcm5hdGVcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2FsdGVybmF0ZVwiLFxuICAgIFwiYXBwZW5kaXhcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2FwcGVuZGl4XCIsXG4gICAgXCJjaXRlXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNjaXRlXCIsXG4gICAgXCJib29rbWFya1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjYm9va21hcmtcIixcbiAgICBcImNvbnRlbnRzXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNjb250ZW50c1wiLFxuICAgIFwiY2hhcHRlclwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjY2hhcHRlclwiLFxuICAgIFwiY29weXJpZ2h0XCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNjb3B5cmlnaHRcIixcbiAgICBcImZpcnN0XCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNmaXJzdFwiLFxuICAgIFwiZ2xvc3NhcnlcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2dsb3NzYXJ5XCIsXG4gICAgXCJoZWxwXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNoZWxwXCIsXG4gICAgXCJpY29uXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNpY29uXCIsXG4gICAgXCJpbmRleFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjaW5kZXhcIixcbiAgICBcImxhc3RcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2xhc3RcIixcbiAgICBcImxpY2Vuc2VcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2xpY2Vuc2VcIixcbiAgICBcIm1ldGFcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI21ldGFcIixcbiAgICBcIm5leHRcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI25leHRcIixcbiAgICBcInByZXZcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI3ByZXZcIixcbiAgICBcInByZXZpb3VzXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNwcmV2aW91c1wiLFxuICAgIFwic2VjdGlvblwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjc2VjdGlvblwiLFxuICAgIFwic3RhcnRcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI3N0YXJ0XCIsXG4gICAgXCJzdHlsZXNoZWV0XCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNzdHlsZXNoZWV0XCIsXG4gICAgXCJzdWJzZWN0aW9uXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNzdWJzZWN0aW9uXCIsXG4gICAgXCJ0b3BcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI3RvcFwiLFxuICAgIFwidXBcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI3VwXCIsXG4gICAgXCJwM3B2MVwiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwvdm9jYWIjcDNwdjFcIlxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiQGNvbnRleHRcIjoge1xuICAgIFwiYXNcIjogXCJodHRwczovL3d3dy53My5vcmcvbnMvYWN0aXZpdHlzdHJlYW1zI1wiLFxuICAgIFwiY2F0XCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvZGNhdCNcIixcbiAgICBcImNjXCI6IFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXCIsXG4gICAgXCJjbnRcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDA4L2NvbnRlbnQjXCIsXG4gICAgXCJjc3Z3XCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvY3N2dyNcIixcbiAgICBcImN0YWdcIjogXCJodHRwOi8vY29tbW9udGFnLm9yZy9ucyNcIixcbiAgICBcImRjXCI6IFwiaHR0cDovL3B1cmwub3JnL2RjL3Rlcm1zL1wiLFxuICAgIFwiZGMxMVwiOiBcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCIsXG4gICAgXCJkY2F0XCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvZGNhdCNcIixcbiAgICBcImRjdGVybXNcIjogXCJodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvXCIsXG4gICAgXCJkcXZcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9kcXYjXCIsXG4gICAgXCJkdXZcIjogXCJodHRwczovL3d3dy53My5vcmcvVFIvdm9jYWItZHV2I1wiLFxuICAgIFwiZWFybFwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL2VhcmwjXCIsXG4gICAgXCJmb2FmXCI6IFwiaHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9cIixcbiAgICBcImdsZHBcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9wZW9wbGUjXCIsXG4gICAgXCJnclwiOiBcImh0dHA6Ly9wdXJsLm9yZy9nb29kcmVsYXRpb25zL3YxI1wiLFxuICAgIFwiZ3JkZGxcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAzL2cvZGF0YS12aWV3I1wiLFxuICAgIFwiaHRcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDA2L2h0dHAjXCIsXG4gICAgXCJpY2FsXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMi8xMi9jYWwvaWNhbHR6ZCNcIixcbiAgICBcImxkcFwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL2xkcCNcIixcbiAgICBcIm1hXCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvbWEtb250I1wiLFxuICAgIFwib2FcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9vYSNcIixcbiAgICBcIm9kcmxcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9vZHJsLzIvXCIsXG4gICAgXCJvZ1wiOiBcImh0dHA6Ly9vZ3AubWUvbnMjXCIsXG4gICAgXCJvcmdcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9vcmcjXCIsXG4gICAgXCJvd2xcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAyLzA3L293bCNcIixcbiAgICBcInByb3ZcIjogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9wcm92I1wiLFxuICAgIFwicHRyXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwOS9wb2ludGVycyNcIixcbiAgICBcInFiXCI6IFwiaHR0cDovL3B1cmwub3JnL2xpbmtlZC1kYXRhL2N1YmUjXCIsXG4gICAgXCJyZXZcIjogXCJodHRwOi8vcHVybC5vcmcvc3R1ZmYvcmV2I1wiLFxuICAgIFwicmRmXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1wiLFxuICAgIFwicmRmYVwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL3JkZmEjXCIsXG4gICAgXCJyZGZzXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC8wMS9yZGYtc2NoZW1hI1wiLFxuICAgIFwicmlmXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwNy9yaWYjXCIsXG4gICAgXCJyclwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL3Iycm1sI1wiLFxuICAgIFwic2NoZW1hXCI6IFwiaHR0cDovL3NjaGVtYS5vcmcvXCIsXG4gICAgXCJzZFwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL3NwYXJxbC1zZXJ2aWNlLWRlc2NyaXB0aW9uI1wiLFxuICAgIFwic2lvY1wiOiBcImh0dHA6Ly9yZGZzLm9yZy9zaW9jL25zI1wiLFxuICAgIFwic2tvc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDQvMDIvc2tvcy9jb3JlI1wiLFxuICAgIFwic2tvc3hsXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwOC8wNS9za29zLXhsI1wiLFxuICAgIFwic3NuXCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvc3NuL1wiLFxuICAgIFwic29zYVwiOiBcImh0dHA6Ly93d3cudzMub3JnL25zL3Nvc2EvXCIsXG4gICAgXCJ0aW1lXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwNi90aW1lI1wiLFxuICAgIFwidlwiOiBcImh0dHA6Ly9yZGYuZGF0YS12b2NhYnVsYXJ5Lm9yZy8jXCIsXG4gICAgXCJ2Y2FyZFwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDYvdmNhcmQvbnMjXCIsXG4gICAgXCJ2b2lkXCI6IFwiaHR0cDovL3JkZnMub3JnL25zL3ZvaWQjXCIsXG4gICAgXCJ3ZHJcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDA3LzA1L3Bvd2RlciNcIixcbiAgICBcIndkcnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDA3LzA1L3Bvd2Rlci1zI1wiLFxuICAgIFwieGh2XCI6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC92b2NhYiNcIixcbiAgICBcInhtbFwiOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgIFwieHNkXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjXCIsXG4gICAgXCJkZXNjcmliZWRieVwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDcvMDUvcG93ZGVyLXMjZGVzY3JpYmVkYnlcIixcbiAgICBcImxpY2Vuc2VcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI2xpY2Vuc2VcIixcbiAgICBcInJvbGVcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sL3ZvY2FiI3JvbGVcIlxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY29kZXMgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0c0xvb3NlKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHJldHVybiBfQmFzZS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBOb2RlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBCYXNlLm5hbWU7XG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9PUFRfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuICdUaGUgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfVxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdUaGUgJyArIG5hbWUgKyAnIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0RFU1RST1lFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnQ2Fubm90IGNhbGwgJyArIG5hbWUgKyAnIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NVUxUSVBMRV9DQUxMQkFDSycsICdDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9DQU5OT1RfUElQRScsICdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJywgJ3dyaXRlIGFmdGVyIGVuZCcpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX05VTExfVkFMVUVTJywgJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiAnVW5rbm93biBlbmNvZGluZzogJyArIGFyZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQnLCAnc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxcbiAgICBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzA7XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG4gIGNiKGVyKTtcbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuXG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9OyAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9IC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cblxuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTsgLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG5cbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59OyAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpOyAvLyBUT0RPKEJyaWRnZUFSKTogV3JpdGUgYSB0ZXN0IGZvciB0aGVzZSB0d28gZXJyb3IgY2FzZXNcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcblxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCgpO1xuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HKCk7XG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcbi8qIDxyZXBsYWNlbWVudD4gKi9cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufSAvLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuXG5cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICAgIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOyAvLyBkcmFpbiBldmVudCBmbGFnLlxuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7IC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG5cbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTsgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cblxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuXG4gIHRoaXMuY29ya2VkID0gMDsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cblxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuXG5cbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7IC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuXG4gIHRoaXMucGVuZGluZ2NiID0gMDsgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cblxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7IC8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxuXG5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3kuXG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufSAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5cblxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpOyAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59IC8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cblxuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG5cbiAgaWYgKGVyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cblxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOyAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cblxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcblxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCk7XG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn0gLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5cblxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufSAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuXG5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOyAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tOyAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH0gLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuXG5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG5cbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcblxuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG5cbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cblxuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gICAgQnVmZmVyID0gX3JlcXVpcmUuQnVmZmVyO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoc3JjLCB0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3VtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICAgIHJldCA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICBuIC09IHJldC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QnVmZmVyKG4pIHtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cblxuICB9LCB7XG4gICAga2V5OiBjdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XG4gIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlO1xuXG4gIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCkge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuICB9O1xuXG4gIHZhciB3cml0YWJsZUVuZGVkID0gc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZDtcblxuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgIHJlYWRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghd3JpdGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gIH07XG5cbiAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHZhciBlcnI7XG5cbiAgICBpZiAocmVhZGFibGUgJiYgIXJlYWRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlIHx8ICFzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbiBvbnJlcXVlc3QoKSB7XG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICB9O1xuXG4gIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gIH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSkge1xuICAgIC8vIGxlZ2FjeSBzdHJlYW1zXG4gICAgc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgfVxuXG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXInKVxufTtcbiIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvcHVtcCB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVvcztcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVEO1xuXG5mdW5jdGlvbiBub29wKGVycikge1xuICAvLyBSZXRocm93IHRoZSBlcnJvciBpZiBpdCBleGlzdHMgdG8gYXZvaWQgc3dhbGxvd2luZyBpdFxuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWU7XG4gIH0pO1xuICBpZiAoZW9zID09PSB1bmRlZmluZWQpIGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IHJlYWRpbmcsXG4gICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIGNsb3NlZCA9IHRydWU7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7IC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxsKGZuKSB7XG4gIGZuKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59XG5cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbm9vcDtcbiAgcmV0dXJuIHN0cmVhbXMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdHJlYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXTtcblxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKTtcbiAgfVxuXG4gIHZhciBlcnJvcjtcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwO1xuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuO1xuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfSU5WQUxJRF9PUFRfVkFMVUUgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfSU5WQUxJRF9PUFRfVkFMVUU7XG5cbmZ1bmN0aW9uIGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaGlnaFdhdGVyTWFyayAhPSBudWxsID8gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIDogaXNEdXBsZXggPyBvcHRpb25zW2R1cGxleEtleV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7XG4gIHZhciBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KTtcblxuICBpZiAoaHdtICE9IG51bGwpIHtcbiAgICBpZiAoIShpc0Zpbml0ZShod20pICYmIE1hdGguZmxvb3IoaHdtKSA9PT0gaHdtKSB8fCBod20gPCAwKSB7XG4gICAgICB2YXIgbmFtZSA9IGlzRHVwbGV4ID8gZHVwbGV4S2V5IDogJ2hpZ2hXYXRlck1hcmsnO1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX09QVF9WQUxVRShuYW1lLCBod20pO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmZsb29yKGh3bSk7XG4gIH0gLy8gRGVmYXVsdCB2YWx1ZVxuXG5cbiAgcmV0dXJuIHN0YXRlLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEhpZ2hXYXRlck1hcms6IGdldEhpZ2hXYXRlck1hcmtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuZXhwb3J0cy5maW5pc2hlZCA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpO1xuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMnKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vbGliL1Jlc29sdmVcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHJlbGF0aXZlIElSSSB0byBhbiBhYnNvbHV0ZSBJUklcbiAqIGJ5IHRha2luZyBpbnRvIGFjY291bnQgdGhlIGdpdmVuIG9wdGlvbmFsIGJhc2VJUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlSVJJIFRoZSByZWxhdGl2ZSBJUkkgdG8gY29udmVydCB0byBhbiBhYnNvbHV0ZSBJUkkuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZUlSSSBUaGUgb3B0aW9uYWwgYmFzZSBJUkkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGFuIGFic29sdXRlIElSSS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZUlSSSwgYmFzZUlSSSkge1xuICAgIGJhc2VJUkkgPSBiYXNlSVJJIHx8ICcnO1xuICAgIGNvbnN0IGJhc2VGcmFnbWVudFBvcyA9IGJhc2VJUkkuaW5kZXhPZignIycpO1xuICAgIC8vIElnbm9yZSBhbnkgZnJhZ21lbnRzIGluIHRoZSBiYXNlIElSSVxuICAgIGlmIChiYXNlRnJhZ21lbnRQb3MgPiAwKSB7XG4gICAgICAgIGJhc2VJUkkgPSBiYXNlSVJJLnN1YnN0cigwLCBiYXNlRnJhZ21lbnRQb3MpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IGVtcHR5IHZhbHVlIGRpcmVjdGx5IHRvIGJhc2UgSVJJXG4gICAgaWYgKCFyZWxhdGl2ZUlSSS5sZW5ndGgpIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGJhc2VJUkkgTVVTVCBiZSBhYnNvbHV0ZSwgb3RoZXJ3aXNlIHdlIGVycm9yXG4gICAgICAgIGlmIChiYXNlSVJJLmluZGV4T2YoJzonKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgaW52YWxpZCBiYXNlSVJJICcke2Jhc2VJUkl9JyBmb3IgdmFsdWUgJyR7cmVsYXRpdmVJUkl9J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlSVJJO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgdmFsdWUgc3RhcnRzIHdpdGggYSBxdWVyeSBjaGFyYWN0ZXIsIGNvbmNhdCBkaXJlY3RseSAoYnV0IHN0cmlwIHRoZSBleGlzdGluZyBxdWVyeSlcbiAgICBpZiAocmVsYXRpdmVJUkkuc3RhcnRzV2l0aCgnPycpKSB7XG4gICAgICAgIGNvbnN0IGJhc2VRdWVyeVBvcyA9IGJhc2VJUkkuaW5kZXhPZignPycpO1xuICAgICAgICBpZiAoYmFzZVF1ZXJ5UG9zID4gMCkge1xuICAgICAgICAgICAgYmFzZUlSSSA9IGJhc2VJUkkuc3Vic3RyKDAsIGJhc2VRdWVyeVBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VJUkkgKyByZWxhdGl2ZUlSSTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHZhbHVlIHN0YXJ0cyB3aXRoIGEgZnJhZ21lbnQgY2hhcmFjdGVyLCBjb25jYXQgZGlyZWN0bHlcbiAgICBpZiAocmVsYXRpdmVJUkkuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgIHJldHVybiBiYXNlSVJJICsgcmVsYXRpdmVJUkk7XG4gICAgfVxuICAgIC8vIElnbm9yZSBiYXNlSVJJIGlmIGl0IGlzIGVtcHR5XG4gICAgaWYgKCFiYXNlSVJJLmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWxhdGl2ZUNvbG9uUG9zID0gcmVsYXRpdmVJUkkuaW5kZXhPZignOicpO1xuICAgICAgICBpZiAocmVsYXRpdmVDb2xvblBvcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgaW52YWxpZCByZWxhdGl2ZSBJUkkgJyR7cmVsYXRpdmVJUkl9JyBmb3IgYSBtaXNzaW5nIGJhc2VJUklgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlRG90U2VnbWVudHNPZlBhdGgocmVsYXRpdmVJUkksIHJlbGF0aXZlQ29sb25Qb3MpO1xuICAgIH1cbiAgICAvLyBJZ25vcmUgYmFzZUlSSSBpZiB0aGUgdmFsdWUgaXMgYWJzb2x1dGVcbiAgICBjb25zdCB2YWx1ZUNvbG9uUG9zID0gcmVsYXRpdmVJUkkuaW5kZXhPZignOicpO1xuICAgIGlmICh2YWx1ZUNvbG9uUG9zID49IDApIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZURvdFNlZ21lbnRzT2ZQYXRoKHJlbGF0aXZlSVJJLCB2YWx1ZUNvbG9uUG9zKTtcbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGJhc2VJUkkgTVVTVCBiZSBhYnNvbHV0ZSwgb3RoZXJ3aXNlIHdlIGVycm9yXG4gICAgY29uc3QgYmFzZUNvbG9uUG9zID0gYmFzZUlSSS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGJhc2VDb2xvblBvcyA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBpbnZhbGlkIGJhc2VJUkkgJyR7YmFzZUlSSX0nIGZvciB2YWx1ZSAnJHtyZWxhdGl2ZUlSSX0nYCk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VJUklTY2hlbWUgPSBiYXNlSVJJLnN1YnN0cigwLCBiYXNlQ29sb25Qb3MgKyAxKTtcbiAgICAvLyBJbmhlcml0IHRoZSBiYXNlSVJJIHNjaGVtZSBpZiB0aGUgdmFsdWUgc3RhcnRzIHdpdGggJy8vJ1xuICAgIGlmIChyZWxhdGl2ZUlSSS5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiYXNlSVJJU2NoZW1lICsgcmVtb3ZlRG90U2VnbWVudHNPZlBhdGgocmVsYXRpdmVJUkksIHZhbHVlQ29sb25Qb3MpO1xuICAgIH1cbiAgICAvLyBDaGVjayBjYXNlcyB3aGVyZSAnOi8vJyBvY2N1cnMgaW4gdGhlIGJhc2VJUkksIGFuZCB3aGVyZSB0aGVyZSBpcyBubyAnLycgYWZ0ZXIgYSAnOicgYW55bW9yZS5cbiAgICBsZXQgYmFzZVNsYXNoQWZ0ZXJDb2xvblBvcztcbiAgICBpZiAoYmFzZUlSSS5pbmRleE9mKCcvLycsIGJhc2VDb2xvblBvcykgPT09IGJhc2VDb2xvblBvcyArIDEpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYWRkaXRpb25hbCAnLycgYWZ0ZXIgdGhlICcvLycuXG4gICAgICAgIGJhc2VTbGFzaEFmdGVyQ29sb25Qb3MgPSBiYXNlSVJJLmluZGV4T2YoJy8nLCBiYXNlQ29sb25Qb3MgKyAzKTtcbiAgICAgICAgaWYgKGJhc2VTbGFzaEFmdGVyQ29sb25Qb3MgPCAwKSB7XG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgb3RoZXIgdGhhbiBhICcvJyBmb2xsb3dzIHRoZSAnOi8vJywgYXBwZW5kIHRoZSB2YWx1ZSBhZnRlciBhICcvJyxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgcHJlZml4IHRoZSB2YWx1ZSB3aXRoIG9ubHkgdGhlIGJhc2VJUkkgc2NoZW1lLlxuICAgICAgICAgICAgaWYgKGJhc2VJUkkubGVuZ3RoID4gYmFzZUNvbG9uUG9zICsgMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlSVJJICsgJy8nICsgcmVtb3ZlRG90U2VnbWVudHNPZlBhdGgocmVsYXRpdmVJUkksIHZhbHVlQ29sb25Qb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VJUklTY2hlbWUgKyByZW1vdmVEb3RTZWdtZW50c09mUGF0aChyZWxhdGl2ZUlSSSwgdmFsdWVDb2xvblBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBldmVuIGEgc2luZ2xlICcvJyBhZnRlciB0aGUgJzonXG4gICAgICAgIGJhc2VTbGFzaEFmdGVyQ29sb25Qb3MgPSBiYXNlSVJJLmluZGV4T2YoJy8nLCBiYXNlQ29sb25Qb3MgKyAxKTtcbiAgICAgICAgaWYgKGJhc2VTbGFzaEFmdGVyQ29sb25Qb3MgPCAwKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgJy8nIGFmdGVyIHRoZSAnOicsXG4gICAgICAgICAgICAvLyBwcmVmaXggdGhlIHZhbHVlIHdpdGggb25seSB0aGUgYmFzZUlSSSBzY2hlbWUuXG4gICAgICAgICAgICByZXR1cm4gYmFzZUlSSVNjaGVtZSArIHJlbW92ZURvdFNlZ21lbnRzT2ZQYXRoKHJlbGF0aXZlSVJJLCB2YWx1ZUNvbG9uUG9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgdmFsdWUgc3RhcnRzIHdpdGggYSAnLycsIHRoZW4gcHJlZml4IGl0IHdpdGggZXZlcnl0aGluZyBiZWZvcmUgdGhlIGZpcnN0IGVmZmVjdGl2ZSBzbGFzaCBvZiB0aGUgYmFzZSBJUkkuXG4gICAgaWYgKHJlbGF0aXZlSVJJLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmFzZUlSSS5zdWJzdHIoMCwgYmFzZVNsYXNoQWZ0ZXJDb2xvblBvcykgKyByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZUlSSSk7XG4gICAgfVxuICAgIGxldCBiYXNlSVJJUGF0aCA9IGJhc2VJUkkuc3Vic3RyKGJhc2VTbGFzaEFmdGVyQ29sb25Qb3MpO1xuICAgIGNvbnN0IGJhc2VJUklMYXN0U2xhc2hQb3MgPSBiYXNlSVJJUGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIC8vIElnbm9yZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBsYXN0ICcvJyBpbiB0aGUgYmFzZUlSSSBwYXRoXG4gICAgaWYgKGJhc2VJUklMYXN0U2xhc2hQb3MgPj0gMCAmJiBiYXNlSVJJTGFzdFNsYXNoUG9zIDwgYmFzZUlSSVBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICBiYXNlSVJJUGF0aCA9IGJhc2VJUklQYXRoLnN1YnN0cigwLCBiYXNlSVJJTGFzdFNsYXNoUG9zICsgMSk7XG4gICAgICAgIC8vIEFsc28gcmVtb3ZlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHJlbGF0aXZlIHBhdGggaWYgaXQgc3RhcnRzIHdpdGggJy4nIChhbmQgbm90ICcuLicgb3IgJy4vJylcbiAgICAgICAgLy8gVGhpcyBjaGFuZ2UgaXMgb25seSBhbGxvd2VkIGlmIHRoZXJlIGlzIHNvbWV0aGluZyBlbHNlIGZvbGxvd2luZyB0aGUgcGF0aFxuICAgICAgICBpZiAocmVsYXRpdmVJUklbMF0gPT09ICcuJyAmJiByZWxhdGl2ZUlSSVsxXSAhPT0gJy4nICYmIHJlbGF0aXZlSVJJWzFdICE9PSAnLycgJiYgcmVsYXRpdmVJUklbMl0pIHtcbiAgICAgICAgICAgIHJlbGF0aXZlSVJJID0gcmVsYXRpdmVJUkkuc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFByZWZpeCB0aGUgdmFsdWUgd2l0aCB0aGUgYmFzZUlSSSBwYXRoIHdoZXJlXG4gICAgcmVsYXRpdmVJUkkgPSBiYXNlSVJJUGF0aCArIHJlbGF0aXZlSVJJO1xuICAgIC8vIFJlbW92ZSBkb3Qgc2VnbWVudCBmcm9tIHRoZSBJUklcbiAgICByZWxhdGl2ZUlSSSA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlSVJJKTtcbiAgICAvLyBQcmVmaXggb3VyIHRyYW5zZm9ybWVkIHZhbHVlIHdpdGggdGhlIHBhcnQgb2YgdGhlIGJhc2VJUkkgdW50aWwgdGhlIGZpcnN0ICcvJyBhZnRlciB0aGUgZmlyc3QgJzonLlxuICAgIHJldHVybiBiYXNlSVJJLnN1YnN0cigwLCBiYXNlU2xhc2hBZnRlckNvbG9uUG9zKSArIHJlbGF0aXZlSVJJO1xufVxuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbi8qKlxuICogUmVtb3ZlIGRvdCBzZWdtZW50cyBmcm9tIHRoZSBnaXZlbiBwYXRoLFxuICogYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzOTg2LnR4dCAocGFnZSAzMikuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBBbiBJUkkgcGF0aC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSBwYXRoLCB3aWxsIGFsd2F5cyBzdGFydCB3aXRoIGEgJy8nLlxuICovXG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyhwYXRoKSB7XG4gICAgLy8gUHJlcGFyZSBhIGJ1ZmZlciB3aXRoIHNlZ21lbnRzIGJldHdlZW4gZWFjaCAnLy5cbiAgICAvLyBFYWNoIHNlZ21lbnQgcmVwcmVzZW50cyBhbiBhcnJheSBvZiBjaGFyYWN0ZXJzLlxuICAgIGNvbnN0IHNlZ21lbnRCdWZmZXJzID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gUmVtb3ZlICcvLicgb3IgJy8uLidcbiAgICAgICAgc3dpdGNoIChwYXRoW2ldKSB7XG4gICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICBpZiAocGF0aFtpICsgMV0gPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aFtpICsgMl0gPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgc2VnbWVudCBpZiB3ZSBmaW5kIGFuIGludmFsaWQgY2hhcmFjdGVyIGFmdGVyIHRoZSAnLidcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDaGFyYWN0ZXJBbGxvd2VkQWZ0ZXJSZWxhdGl2ZVBhdGhTZWdtZW50KHBhdGhbaSArIDNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWZmZXJzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIHRvIHBhcmVudCBkaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSByZW1vdmUgYSBwYXJlbnQgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1ZmZlcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBlbmQgd2l0aCBhIHNsYXNoIGlmIHRoZXJlIGlzIGEgdHJhaWxpbmcgJy8uLidcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGF0aFtpICsgM10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50QnVmZmVycy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IHNlZ21lbnQgaWYgd2UgZmluZCBhbiBpbnZhbGlkIGNoYXJhY3RlciBhZnRlciB0aGUgJy4nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2hhcmFjdGVyQWxsb3dlZEFmdGVyUmVsYXRpdmVQYXRoU2VnbWVudChwYXRoW2kgKyAyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50QnVmZmVycy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBlbmQgd2l0aCBhIHNsYXNoIGlmIHRoZXJlIGlzIGEgdHJhaWxpbmcgJy8uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoW2kgKyAyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWZmZXJzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gdG8gdGhlIGN1cnJlbnQgZGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBhIG5ldyBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWZmZXJzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgICAgICAvLyBRdWVyeSBhbmQgZnJhZ21lbnQgc3RyaW5nIHNob3VsZCBiZSBhcHBlbmRlZCB1bmNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoIXNlZ21lbnRCdWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50QnVmZmVycy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1ZmZlcnNbc2VnbWVudEJ1ZmZlcnMubGVuZ3RoIC0gMV0ucHVzaChwYXRoLnN1YnN0cihpKSk7XG4gICAgICAgICAgICAgICAgLy8gQnJlYWsgdGhlIHdoaWxlIGxvb3BcbiAgICAgICAgICAgICAgICBpID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIE5vdCBhIHNwZWNpYWwgY2hhcmFjdGVyLCBqdXN0IGFwcGVuZCBpdCB0byBvdXIgYnVmZmVyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWdtZW50QnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZ21lbnRCdWZmZXJzW3NlZ21lbnRCdWZmZXJzLmxlbmd0aCAtIDFdLnB1c2gocGF0aFtpXSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnLycgKyBzZWdtZW50QnVmZmVycy5tYXAoKGJ1ZmZlcikgPT4gYnVmZmVyLmpvaW4oJycpKS5qb2luKCcvJyk7XG59XG5leHBvcnRzLnJlbW92ZURvdFNlZ21lbnRzID0gcmVtb3ZlRG90U2VnbWVudHM7XG4vKipcbiAqIFJlbW92ZXMgZG90IHNlZ21lbnRzIG9mIHRoZSBnaXZlbiBJUkkuXG4gKiBAcGFyYW0ge3N0cmluZ30gaXJpIEFuIElSSSAob3IgcGFydCBvZiBJUkkpLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbG9uUG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCAnOicgaW4gdGhlIElSSS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIElSSSB3aGVyZSBkb3Qgc2VnbWVudHMgd2VyZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50c09mUGF0aChpcmksIGNvbG9uUG9zaXRpb24pIHtcbiAgICAvLyBEZXRlcm1pbmUgd2hlcmUgd2Ugc2hvdWxkIHN0YXJ0IGxvb2tpbmcgZm9yIHRoZSBmaXJzdCAnLycgdGhhdCBpbmRpY2F0ZXMgdGhlIHN0YXJ0IG9mIHRoZSBwYXRoXG4gICAgbGV0IHNlYXJjaE9mZnNldCA9IGNvbG9uUG9zaXRpb24gKyAxO1xuICAgIGlmIChjb2xvblBvc2l0aW9uID49IDApIHtcbiAgICAgICAgaWYgKGlyaVtjb2xvblBvc2l0aW9uICsgMV0gPT09ICcvJyAmJiBpcmlbY29sb25Qb3NpdGlvbiArIDJdID09PSAnLycpIHtcbiAgICAgICAgICAgIHNlYXJjaE9mZnNldCA9IGNvbG9uUG9zaXRpb24gKyAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaXJpWzBdID09PSAnLycgJiYgaXJpWzFdID09PSAnLycpIHtcbiAgICAgICAgICAgIHNlYXJjaE9mZnNldCA9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBwYXRoXG4gICAgY29uc3QgcGF0aFNlcGFyYXRvciA9IGlyaS5pbmRleE9mKCcvJywgc2VhcmNoT2Zmc2V0KTtcbiAgICBpZiAocGF0aFNlcGFyYXRvciA8IDApIHtcbiAgICAgICAgcmV0dXJuIGlyaTtcbiAgICB9XG4gICAgY29uc3QgYmFzZSA9IGlyaS5zdWJzdHIoMCwgcGF0aFNlcGFyYXRvcik7XG4gICAgY29uc3QgcGF0aCA9IGlyaS5zdWJzdHIocGF0aFNlcGFyYXRvcik7XG4gICAgLy8gUmVtb3ZlIGRvdCBzZWdtZW50cyBmcm9tIHRoZSBwYXRoXG4gICAgcmV0dXJuIGJhc2UgKyByZW1vdmVEb3RTZWdtZW50cyhwYXRoKTtcbn1cbmV4cG9ydHMucmVtb3ZlRG90U2VnbWVudHNPZlBhdGggPSByZW1vdmVEb3RTZWdtZW50c09mUGF0aDtcbmZ1bmN0aW9uIGlzQ2hhcmFjdGVyQWxsb3dlZEFmdGVyUmVsYXRpdmVQYXRoU2VnbWVudChjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gIWNoYXJhY3RlciB8fCBjaGFyYWN0ZXIgPT09ICcjJyB8fCBjaGFyYWN0ZXIgPT09ICc/JyB8fCBjaGFyYWN0ZXIgPT09ICcvJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc29sdmUuanMubWFwIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblN0cmVhbS5maW5pc2hlZCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJylcblN0cmVhbS5waXBlbGluZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpXG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWWFsbGlzdCkge1xuICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlcjsgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgIHlpZWxkIHdhbGtlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IFlhbGxpc3RcblxuWWFsbGlzdC5Ob2RlID0gTm9kZVxuWWFsbGlzdC5jcmVhdGUgPSBZYWxsaXN0XG5cbmZ1bmN0aW9uIFlhbGxpc3QgKGxpc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBZYWxsaXN0KSkge1xuICAgIHNlbGYgPSBuZXcgWWFsbGlzdCgpXG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsXG4gIHNlbGYuaGVhZCA9IG51bGxcbiAgc2VsZi5sZW5ndGggPSAwXG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2VsZi5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0JylcbiAgfVxuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2XG4gIH1cblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHRcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0XG4gIH1cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXZcbiAgfVxuXG4gIG5vZGUubGlzdC5sZW5ndGgtLVxuICBub2RlLm5leHQgPSBudWxsXG4gIG5vZGUucHJldiA9IG51bGxcbiAgbm9kZS5saXN0ID0gbnVsbFxuXG4gIHJldHVybiBuZXh0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50IC8qLCAuLi5ub2RlcyAqLykge1xuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggLSAxXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgICB3YWxrZXIgPSB0aGlzLnJlbW92ZU5vZGUod2Fsa2VyKVxuICB9XG4gIGlmICh3YWxrZXIgPT09IG51bGwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgfVxuXG4gIGlmICh3YWxrZXIgIT09IHRoaXMuaGVhZCAmJiB3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHdhbGtlciA9IGluc2VydCh0aGlzLCB3YWxrZXIsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0IChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgP1xuICAgIG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6XG4gICAgbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZilcblxuICBpZiAoaW5zZXJ0ZWQubmV4dCA9PT0gbnVsbCkge1xuICAgIHNlbGYudGFpbCA9IGluc2VydGVkXG4gIH1cbiAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICBzZWxmLmhlYWQgPSBpbnNlcnRlZFxuICB9XG5cbiAgc2VsZi5sZW5ndGgrK1xuXG4gIHJldHVybiBpbnNlcnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuXG50cnkge1xuICAvLyBhZGQgaWYgc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yIGlzIHByZXNlbnRcbiAgcmVxdWlyZSgnLi9pdGVyYXRvci5qcycpKFlhbGxpc3QpXG59IGNhdGNoIChlcikge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IFN0b3JlID0gcmVxdWlyZSgnbjMnKS5TdG9yZTtcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoJ24zJykuUGFyc2VyO1xuY29uc3QganNvbmxkID0gcmVxdWlyZSgnanNvbmxkJyk7XG5jb25zdCBSZWFkYWJsZSA9IHJlcXVpcmUoJ3N0cmVhbScpLlJlYWRhYmxlO1xuY29uc3QgUmRmYVBhcnNlciA9IHJlcXVpcmUoJ3JkZmEtc3RyZWFtaW5nLXBhcnNlcicpLlJkZmFQYXJzZXI7XG5jb25zdCBNaWNyb2RhdGFQYXJzZXIgPSByZXF1aXJlKCdtaWNyb2RhdGEtcmRmLXN0cmVhbWluZy1wYXJzZXInKS5NaWNyb2RhdGFSZGZQYXJzZXI7XG5cbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzLmpzJyk7XG5cbi8qKlxuICogUGFyc2VzIGpzb24tbGQgdG8gcXVhZHMgaW50byB0aGUgbjMuU3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gaW5wdXQgZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVcmwgLSBtYWluIHNoYXBlIFVSTFxuICogQHJldHVybiB7UHJvbWlzZTxTdG9yZT59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlSnNvbkxkKHRleHQsIGJhc2VVcmwpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICBkYXRhWydAaWQnXSA9IGJhc2VVcmw7XG4gICAgY29uc3QgbnF1YWRzID0gYXdhaXQganNvbmxkLnRvUkRGKGRhdGEsIHtmb3JtYXQ6ICdhcHBsaWNhdGlvbi9uLXF1YWRzJywgYmFzZTogYmFzZVVybH0pO1xuICAgIHJldHVybiBwYXJzZU5RdWFkcyhucXVhZHMsIGJhc2VVcmwpO1xufVxuXG5cbi8qKlxuICogUGFyc2UgUkRGYSB0byBxdWFkcyBpbnRvIHRoZSBuMy5TdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVybCAtIG1haW4gc2hhcGUgVVJMXG4gKiBAcmV0dXJuIHtQcm9taXNlPFN0b3JlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VSZGZhKHRleHQsIGJhc2VVcmwpIHtcbiAgICBjb25zdCB0ZXh0U3RyZWFtID0gbmV3IFJlYWRhYmxlKCk7XG4gICAgdGV4dFN0cmVhbS5wdXNoKHRleHQpO1xuICAgIHRleHRTdHJlYW0ucHVzaChudWxsKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gbmV3IFN0b3JlKCk7XG4gICAgICAgIGNvbnN0IHJkZmFQYXJzZXIgPSBuZXcgUmRmYVBhcnNlcih7YmFzZUlSSTogYmFzZVVybCwgY29udGVudFR5cGU6ICd0ZXh0L2h0bWwnfSk7XG4gICAgICAgIHRleHRTdHJlYW0ucGlwZShyZGZhUGFyc2VyKVxuICAgICAgICAgICAgLm9uKCdkYXRhJywgcXVhZCA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcmUuYWRkUXVhZChxdWFkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2Vycm9yJywgZXJyID0+IHJlaihlcnIpKVxuICAgICAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlLmdldFF1YWRzKCkubGVuZ3RoID09PSAwKSByZXModW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICByZXMoc3RvcmUpXG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgbWljcm9kYXRhIHRvIHF1YWRzIGludG8gdGhlIG4zLlN0b3JlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVXJsIC0gbWFpbiBzaGFwZSBVUkxcbiAqIEByZXR1cm4ge1Byb21pc2U8U3RvcmU+fVxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZU1pY3JvZGF0YSh0ZXh0LCBiYXNlVXJsKSB7XG4gICAgY29uc3QgdGV4dFN0cmVhbSA9IG5ldyBSZWFkYWJsZSgpO1xuICAgIHRleHRTdHJlYW0ucHVzaCh0ZXh0KTtcbiAgICB0ZXh0U3RyZWFtLnB1c2gobnVsbCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICBjb25zdCBzdG9yZSA9IG5ldyBTdG9yZSgpO1xuICAgICAgICBjb25zdCByZGZhUGFyc2VyID0gbmV3IE1pY3JvZGF0YVBhcnNlcih7YmFzZUlSSTogYmFzZVVybH0pO1xuICAgICAgICB0ZXh0U3RyZWFtLnBpcGUocmRmYVBhcnNlcilcbiAgICAgICAgICAgIC5vbignZGF0YScsIHF1YWQgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3JlLmFkZFF1YWQocXVhZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdlcnJvcicsIGVyciA9PiByZWooZXJyKSlcbiAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZS5nZXRRdWFkcygpLmxlbmd0aCA9PT0gMCkgcmVzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgcmVzKHN0b3JlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gaW5wdXQgZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVcmwgLSBtYWluIHNoYXBlIFVSTFxuICogQHJldHVybiB7U3RvcmV9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlTlF1YWRzKHRleHQsIGJhc2VVcmwpIHtcbiAgICBjb25zdCB0dXJ0bGVQYXJzZXIgPSBuZXcgUGFyc2VyKHtcbiAgICAgICAgZm9ybWF0OiAnYXBwbGljYXRpb24vbi1xdWFkcycsXG4gICAgICAgIGJhc2VJUkk6IGJhc2VVcmwsXG4gICAgfSk7XG4gICAgY29uc3Qgc3RvcmUgPSBuZXcgU3RvcmUoKTtcbiAgICB0dXJ0bGVQYXJzZXIucGFyc2UodGV4dCkuZm9yRWFjaChxdWFkID0+IHtcbiAgICAgICAgc3RvcmUuYWRkUXVhZChxdWFkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVXJsIC0gbWFpbiBzaGFwZSBVUkxcbiAqIEByZXR1cm4ge1N0b3JlfVxuICovXG5mdW5jdGlvbiBwYXJzZVR1cnRsZSh0ZXh0LCBiYXNlVXJsKSB7XG4gICAgY29uc3QgdHVydGxlUGFyc2VyID0gbmV3IFBhcnNlcih7XG4gICAgICAgIGZvcm1hdDogJ3RleHQvdHVydGxlJyxcbiAgICAgICAgYmFzZUlSSTogYmFzZVVybCxcbiAgICB9KTtcbiAgICBjb25zdCBzdG9yZSA9IG5ldyBTdG9yZSgpO1xuICAgIHR1cnRsZVBhcnNlci5wYXJzZSh0ZXh0KS5mb3JFYWNoKHF1YWQgPT4ge1xuICAgICAgICBzdG9yZS5hZGRRdWFkKHF1YWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRyeWluZyB0byBwYXJzZSBpbnB1dCB0ZXh0IGludG8gYSBjZXJ0YWluIGZvcm1hdFxuICogQHBhcmFtIHsqfSBwYXJzZXIgcGFyc2VyIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmRlZmluZWR8U3RvcmU+fVxuICovXG5hc3luYyBmdW5jdGlvbiB0cnlQYXJzZShwYXJzZXIpIHtcbiAgICBsZXQgcXVhZHM7XG4gICAgdHJ5IHtcbiAgICAgICAgcXVhZHMgPSBhd2FpdCBwYXJzZXIoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHJldHVybiBxdWFkcztcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGlucHV0IHRvIHF1YWRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBtYWluIHNoYXBlIFVSTFxuICogQHJldHVybnMge1Byb21pc2U8U3RvcmU+fVxuICovXG5hc3luYyBmdW5jdGlvbiBzdHJpbmdUb1F1YWRzKHRleHQsIHVybCkge1xuICAgIGNvbnN0IGpzb25QYXJzZXIgPSBhc3luYyAoKSA9PiBhd2FpdCBwYXJzZUpzb25MZCh0ZXh0LCB1cmwpO1xuICAgIGNvbnN0IG1pY3JvZGF0YVBhcnNlciA9IGFzeW5jICgpID0+IGF3YWl0IHBhcnNlTWljcm9kYXRhKHRleHQsIHVybCk7XG4gICAgY29uc3QgcmRmYVBhcnNlciA9IGFzeW5jICgpID0+IGF3YWl0IHBhcnNlUmRmYSh0ZXh0LCB1cmwpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRyeVBhcnNlKGpzb25QYXJzZXIpIHx8XG4gICAgICAgIGF3YWl0IHRyeVBhcnNlKG1pY3JvZGF0YVBhcnNlcikgfHxcbiAgICAgICAgYXdhaXQgdHJ5UGFyc2UocmRmYVBhcnNlcik7XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkIHx8IHJlcy5nZXRRdWFkcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWREYXRhRXJyb3IoJ0Vycm9yIHdoaWxlIHBhcnNpbmcgdGhlIGRhdGEuICcgK1xuICAgICAgICAgICAgJ1RoaXMgY291bGQgYmUgY2F1c2VkIGJ5IGluY29ycmVjdCBkYXRhIG9yIGluY29ycmVjdCBkYXRhIGZvcm1hdC4gJyArXG4gICAgICAgICAgICAnUG9zc2libGUgZm9ybWF0czoganNvbi1sZCwgbWljcm9kYXRhLCByZGZhJyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhcnNlSnNvbkxkOiBwYXJzZUpzb25MZCxcbiAgICBwYXJzZU1pY3JvZGF0YTogcGFyc2VNaWNyb2RhdGEsXG4gICAgcGFyc2VSZGZhOiBwYXJzZVJkZmEsXG4gICAgcGFyc2VOUXVhZHM6IHBhcnNlTlF1YWRzLFxuICAgIHBhcnNlVHVydGxlOiBwYXJzZVR1cnRsZSxcbiAgICBzdHJpbmdUb1F1YWRzOiBzdHJpbmdUb1F1YWRzLFxufTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3RyaW5nVG9RdWFkczogcmVxdWlyZSgnLi9wYXJzZXInKS5zdHJpbmdUb1F1YWRzLFxuICAgIHBhcnNlSnNvbkxkOiByZXF1aXJlKCcuL3BhcnNlcicpLnBhcnNlSnNvbkxkLFxuICAgIHBhcnNlTWljcm9kYXRhOiByZXF1aXJlKCcuL3BhcnNlcicpLnBhcnNlTWljcm9kYXRhLFxuICAgIHBhcnNlUmRmYTogcmVxdWlyZSgnLi9wYXJzZXInKS5wYXJzZVJkZmEsXG4gICAgcGFyc2VOUXVhZHM6IHJlcXVpcmUoJy4vcGFyc2VyJykucGFyc2VOUXVhZHMsXG4gICAgcmFuZG9tVXJsOiByZXF1aXJlKCcuL3V0aWwnKS5yYW5kb21VcmwsXG4gICAgcXVhZHNUb1NoYXBlczogcmVxdWlyZSgnLi91dGlsJykucXVhZHNUb1NoYXBlc1xufSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcblxuY29uc3QganNvbmxkID0gcmVxdWlyZSgnanNvbmxkJyk7XG5jb25zdCBuMyA9IHJlcXVpcmUoJ24zJyk7XG5jb25zdCBTdG9yZSA9IG4zLlN0b3JlO1xuY29uc3QgUmRmYVBhcnNlciA9IHJlcXVpcmUoJ3JkZmEtc3RyZWFtaW5nLXBhcnNlcicpLlJkZmFQYXJzZXI7XG5cbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cblxuLyoqXG4gKiBMb2FkcyByZWxhdGVkIGRhdGEgKHNoYXBlcywgY29udGV4dCwgZXRjLikgZnJvbSByZW1vdGUgb3IgbG9jYWwgc291cmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluayB1cmwgdG8gdGhlIHJlbW90ZSBzb3VyY2Ugb3IgbG9jYWwgcGF0aFxuICogQHJldHVybiB7Kn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZERhdGEobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKFwiXmh0dHBzPzovL1wiKSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IGF4aW9zLmdldChsaW5rKSkuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhsaW5rKS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlcyBmcm9tIG9iamVjdHMgYXJyYXlcbiAqIEBwYXJhbSB7W29iamVjdF19IGl0ZW1zXG4gKiBAcGFyYW0ge1tzdHJpbmddfSBrZXlzXG4gKiBAcmV0dXJucyB7W29iamVjdF19XG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUJ5KGl0ZW1zLCBrZXlzKSB7XG4gICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgbGV0IHZhbCA9ICcnO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHZhbCArPSBpdGVtW2tleV0pO1xuICAgICAgICByZXR1cm4gc2Vlbi5oYXNPd25Qcm9wZXJ0eSh2YWwpID8gZmFsc2UgOiAoc2Vlblt2YWxdID0gdHJ1ZSk7XG4gICAgfSlcbn1cblxuLyoqXG4gKiAgR2VuZXJhdGVzIHJhbmRvbSBVUkwgYXMgYmFzZVxuICogIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqICBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbVVybChsZW5ndGggPSAxNikge1xuICAgIGxldCByZXN1bHQgPSAnaHR0cHM6Ly9leGFtcGxlLm9yZy8nO1xuICAgIGNvbnN0IGNoYXJhY3RlcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRmluZHMgc3Ryb25nbHkgY29ubmVjdGVkIGNvbXBvbmVudHMgaW4gdGhlIGRhdGEgZ3JhcGhcbiAqIEBwYXJhbSB7U3RvcmV9IHN0b3JlXG4gKiBAcmV0dXJuIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAtIG1hcCBmcm9tIHN1YmplY3QgdXJpcyB0b1xuICogY29tcG9uZW50IGlkc1xuICovXG5mdW5jdGlvbiBzdHJvbmdseUNvbm5lY3RlZENvbXBvbmVudHMoc3RvcmUpIHtcbiAgICBjb25zdCBub2RlcyA9IFsuLi5uZXcgU2V0KHN0b3JlLmdldFN1YmplY3RzKClcbiAgICAgICAgLm1hcCh4ID0+IHguaWQpKV07XG5cbiAgICBjb25zdCBvcmRlciA9IFtdO1xuICAgIGxldCBjb21wb25lbnQgPSBbXTtcbiAgICBsZXQgY29tcG9uZW50SWR4ID0gMDtcbiAgICBjb25zdCBjb21wb25lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHVzZWQgPSBuZXcgTWFwKCk7XG5cbiAgICBjb25zdCBmb3J3YXJkRGZzID0gKHYpID0+IHtcbiAgICAgICAgdXNlZC5zZXQodiwgdHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgcXVhZCBvZiBzdG9yZS5nZXRRdWFkcyh2LCB1bmRlZmluZWQsIHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmNsdWRlcyhxdWFkLm9iamVjdC5pZCkgJiYgIXVzZWQuZ2V0KHF1YWQub2JqZWN0LmlkKSlcbiAgICAgICAgICAgICAgICBmb3J3YXJkRGZzKHF1YWQub2JqZWN0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBvcmRlci5wdXNoKHYpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhY2t3YXJkRGZzID0gKHYpID0+IHtcbiAgICAgICAgdXNlZC5zZXQodiwgdHJ1ZSk7XG4gICAgICAgIGNvbXBvbmVudC5wdXNoKHYpO1xuICAgICAgICBmb3IgKGNvbnN0IHF1YWQgb2Ygc3RvcmUuZ2V0UXVhZHModW5kZWZpbmVkLCB1bmRlZmluZWQsIHYpKSB7XG4gICAgICAgICAgICBpZiAoIXVzZWQuZ2V0KHF1YWQuc3ViamVjdC5pZCkpXG4gICAgICAgICAgICAgICAgYmFja3dhcmREZnMocXVhZC5zdWJqZWN0LmlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlcykgdXNlZC5zZXQobm9kZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAoIXVzZWQuZ2V0KG5vZGUpKVxuICAgICAgICAgICAgZm9yd2FyZERmcyhub2RlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB1c2VkLnNldChub2RlLCBmYWxzZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gb3JkZXJbbm9kZXMubGVuZ3RoLTEtaV07XG4gICAgICAgIGlmICghdXNlZC5nZXQobm9kZSkpIHtcbiAgICAgICAgICAgIGJhY2t3YXJkRGZzKG5vZGUpO1xuICAgICAgICAgICAgY29tcG9uZW50LmZvckVhY2goeCA9PiBjb21wb25lbnRzLnNldCh4LCBjb21wb25lbnRJZHgpKTtcbiAgICAgICAgICAgIGNvbXBvbmVudElkeCsrO1xuICAgICAgICAgICAgY29tcG9uZW50ID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbi8qKlxuICogUGFyc2VzIHF1YWRzIHRvIG11bHRpcGxlIHN0b3JlcyB3aGljaCByZXByZXNlbnQgcm9vdCBub2Rlc1xuICogaW4gdGhlIGRhdGEgZ3JhcGhcbiAqIEBwYXJhbSB7U3RvcmV9IHN0b3JlXG4gKi9cbmZ1bmN0aW9uIHF1YWRzVG9TaGFwZXMoc3RvcmUpIHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gc3Ryb25nbHlDb25uZWN0ZWRDb21wb25lbnRzKHN0b3JlKTtcbiAgICBjb25zdCBub3RSb290ID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgcXVhZCBvZiBzdG9yZS5nZXRRdWFkcygpKSB7XG4gICAgICAgIGlmIChjb21wb25lbnRzLmhhcyhxdWFkLnN1YmplY3QuaWQpICYmXG4gICAgICAgICAgICBjb21wb25lbnRzLmhhcyhxdWFkLm9iamVjdC5pZCkgJiZcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZ2V0KHF1YWQuc3ViamVjdC5pZCkgIT09IGNvbXBvbmVudHMuZ2V0KHF1YWQub2JqZWN0LmlkKSkge1xuICAgICAgICAgICAgbm90Um9vdC5hZGQoY29tcG9uZW50cy5nZXQocXVhZC5vYmplY3QuaWQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNoYXBlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtub2RlLCBjb21wb25lbnRdIG9mIGNvbXBvbmVudHMuZW50cmllcygpKSB7XG4gICAgICAgIGlmICghbm90Um9vdC5oYXMoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgc2hhcGVzLnNldChub2RlLCBnZXRTaGFwZShub2RlLCBzdG9yZSwgc2hhcGVzLCBbXSkpO1xuICAgICAgICAgICAgbm90Um9vdC5hZGQoY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhcGVzO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGdldHMgYWxsIHRyaXBsZXMsIHJlbGF0ZWQgdG8gdGhlIHNoYXBlXG4gKiBAcGFyYW0ge2FueX0gaWQgLSBpZCBvZiB0aGUgY29uc3RydWN0ZWQgc2hhcGVcbiAqIEBwYXJhbSB7U3RvcmV9IHN0b3JlIC0gc3RvcmUsIGNvbnRhaW5pbmcgYWxsIHRoZSB0cmlwbGVzXG4gKiBAcGFyYW0ge01hcDxhbnksIFN0b3JlPn0gc2hhcGVzIC0gbWFwIFtpZCAtPiBzaGFwZSBTdG9yZV1cbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gcGFyc2VkIC0gYXJyYXkgZm9yIHRyYWNraW5nIHJlY3Vyc2l2ZSBsb29wc1xuICovXG5mdW5jdGlvbiBnZXRTaGFwZShpZCwgc3RvcmUsIHNoYXBlcywgcGFyc2VkKSB7XG4gICAgY29uc3Qgc2hhcGVRdWFkcyA9IHN0b3JlLmdldFF1YWRzKGlkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgaWYgKHNoYXBlUXVhZHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgcGFyc2VkLnB1c2goaWQpO1xuICAgIGZvciAoY29uc3QgcXVhZCBvZiBzdG9yZS5nZXRRdWFkcyhpZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpKSB7XG4gICAgICAgIGlmIChwYXJzZWQuaW5jbHVkZXMocXVhZC5vYmplY3QuaWQpKSB7XG4gICAgICAgICAgICBzaGFwZVF1YWRzLnB1c2gocXVhZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmVzdGVkU3RvcmU7XG4gICAgICAgIGlmIChzaGFwZXMuZ2V0KHF1YWQub2JqZWN0KSkge1xuICAgICAgICAgICAgbmVzdGVkU3RvcmUgPSBzaGFwZXMuZ2V0KHF1YWQub2JqZWN0LmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lc3RlZFN0b3JlID0gZ2V0U2hhcGUocXVhZC5vYmplY3QuaWQsIHN0b3JlLCBzaGFwZXMsIHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lc3RlZFN0b3JlICYmIG5lc3RlZFN0b3JlLmdldFF1YWRzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2hhcGVRdWFkcy5wdXNoKC4uLm5lc3RlZFN0b3JlLmdldFF1YWRzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNoYXBlU3RvcmUgPSBuZXcgU3RvcmUoKTtcbiAgICBmb3IgKGNvbnN0IHF1YWQgb2Ygc2hhcGVRdWFkcykge1xuICAgICAgICBzaGFwZVN0b3JlLmFkZFF1YWQocXVhZCk7XG4gICAgfVxuICAgIHJldHVybiBzaGFwZVN0b3JlO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJhbmRvbVVybDogcmFuZG9tVXJsLFxuICAgIGxvYWREYXRhOiBsb2FkRGF0YSxcbiAgICB1bmlxdWVCeTogdW5pcXVlQnksXG4gICAgcXVhZHNUb1NoYXBlczogcXVhZHNUb1NoYXBlcyxcbn07Il19
